<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>std.zlib</title>
        </head><body>
        <h1>std.zlib</h1>
        <!-- Generated by Ddoc from /usr/include/x86_64-linux-gnu/dmd/phobos/std/zlib.d -->
Compress/decompress data using the <a href="http://www._zlib.net"><u>zlib</u> library</a>.
<br><br>
<b>References:</b><br>
<a href="http://en.wikipedia.org/wiki/Zlib">Wikipedia</a>

<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>

<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big>class <u>ZlibException</u>: object.Exception;
</big></dt>
<dd>Errors throw a <u>ZlibException</u>.<br><br>

</dd>
<dt><big>uint <u>adler32</u>(uint <i>adler</i>, const(void)[] <i>buf</i>);
</big></dt>
<dd>Compute the Adler32 checksum of the data in <i>buf</i>[]. <i>adler</i> is the starting
 value when computing a cumulative checksum.<br><br>

</dd>
<dt><big>uint <u>crc32</u>(uint <i>crc</i>, const(void)[] <i>buf</i>);
</big></dt>
<dd>Compute the CRC32 checksum of the data in <i>buf</i>[]. <i>crc</i> is the starting value
 when computing a cumulative checksum.<br><br>

</dd>
<dt><big>const(void)[] <u>compress</u>(const(void)[] <i>srcbuf</i>, int <i>level</i>);
<br>const(void)[] <u>compress</u>(const(void)[] <i>buf</i>);
</big></dt>
<dd>Compresses the data in <i>srcbuf</i>[] using compression level <i>level</i>.
 The default value
 for <i>level</i> is 6, legal values are 1..9, with 1 being the least compression
 and 9 being the most.
 Returns the compressed data.<br><br>

</dd>
<dt><big>void[] <u>uncompress</u>(void[] <i>srcbuf</i>, size_t <i>destlen</i> = 0u, int <i>winbits</i> = 15);
</big></dt>
<dd>Decompresses the data in <i>srcbuf</i>[].
<br><br>
<b>Params:</b><br>
<table><tr><td>size_t <i>destlen</i></td>
<td>size of the uncompressed data.
 It need not be accurate, but the decompression will be faster if the exact
 size is supplied.</td></tr>
</table><br>
<b>Returns:</b><br>
the decompressed data.<br><br>

</dd>
<dt><big>enum <u>HeaderFormat</u>;
</big></dt>
<dd>the header format the compressed stream is wrapped in<br><br>

<dl><dt><big><u>deflate</u></big></dt>
<dd>a standard zlib header<br><br>

</dd>
<dt><big><u>gzip</u></big></dt>
<dd>a <u>gzip</u> file format header<br><br>

</dd>
<dt><big><u>determineFromData</u></big></dt>
<dd>used when decompressing. Try to automatically detect the stream format by looking at the data<br><br>

</dd>
</dl>
</dd>
<dt><big>class <u>Compress</u>;
</big></dt>
<dd>Used when the data to be compressed is not all in one buffer.<br><br>

<dl><dt><big>this(int <i>level</i>, HeaderFormat <i>header</i> = cast(HeaderFormat)0);
<br>this(HeaderFormat <i>header</i> = cast(HeaderFormat)0);
</big></dt>
<dd>Construct. <i>level</i> is the same as for D.zlib.compress(). <i>header</i> can be used to make a gzip compatible stream.<br><br>

</dd>
<dt><big>const(void)[] <u>compress</u>(const(void)[] <i>buf</i>);
</big></dt>
<dd>Compress the data in <i>buf</i> and return the compressed data.
 The buffers
 returned from successive calls to this should be concatenated together.<br><br>

</dd>
<dt><big>void[] <u>flush</u>(int <i>mode</i> = Z_FINISH);
</big></dt>
<dd>Compress and return any remaining data.
 The returned data should be appended to that returned by compress().
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>mode</i></td>
<td>one of the following:
          <dl>                   <dt>Z_SYNC_FLUSH </dt>
                    <dd>Syncs up flushing to the next byte boundary.
                        Used when more data is to be compressed later on.</dd>
                    <dt>Z_FULL_FLUSH </dt>
                    <dd>Syncs up flushing to the next byte boundary.
                        Used when more data is to be compressed later on,
                        and the decompressor needs to be restartable at this
                        point.</dd>
                    <dt>Z_FINISH</dt>
                    <dd>(default) Used when finished compressing the data. </dd>
                </dl></td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big>class <u>UnCompress</u>;
</big></dt>
<dd>Used when the data to be decompressed is not all in one buffer.<br><br>

<dl><dt><big>this(uint <i>destbufsize</i>);
<br>this(HeaderFormat <i>format</i> = cast(HeaderFormat)2);
</big></dt>
<dd>Construct. <i>destbufsize</i> is the same as for D.zlib.uncompress().<br><br>

</dd>
<dt><big>const(void)[] <u>uncompress</u>(const(void)[] <i>buf</i>);
</big></dt>
<dd>Decompress the data in <i>buf</i> and return the decompressed data.
 The buffers returned from successive calls to this should be concatenated
 together.<br><br>

</dd>
<dt><big>void[] <u>flush</u>();
</big></dt>
<dd>Decompress and return any remaining data.
 The returned data should be appended to that returned by uncompress().
 The UnCompress object cannot be used further.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. Copyright Digital Mars 2000 - 2011.
</small>
        </body></html>
