[
{
"name" : "std.algorithm",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/algorithm.d",
"comment" : "\n<script type=\"text\/javascript\">inhibitQuickIndex = 1<\/script>\n\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Searching) $(TD $(MYREF balancedParens) $(MYREF\nboyerMooreFinder) $(MYREF canFind) $(MYREF count) $(MYREF countUntil)\n$(MYREF endsWith) $(MYREF commonPrefix) $(MYREF find) $(MYREF\nfindAdjacent) $(MYREF findAmong) $(MYREF findSkip) $(MYREF findSplit)\n$(MYREF findSplitAfter) $(MYREF findSplitBefore) $(MYREF indexOf)\n$(MYREF minCount) $(MYREF minPos) $(MYREF mismatch) $(MYREF skipOver)\n$(MYREF startsWith) $(MYREF until) )\n)\n$(TR $(TDNW Comparison) $(TD $(MYREF cmp) $(MYREF equal) $(MYREF\nlevenshteinDistance) $(MYREF levenshteinDistanceAndPath) $(MYREF max)\n$(MYREF min) $(MYREF mismatch) )\n)\n$(TR $(TDNW Iteration) $(TD $(MYREF filter) $(MYREF filterBidirectional)\n$(MYREF group) $(MYREF joiner) $(MYREF map) $(MYREF reduce) $(MYREF\nsplitter) $(MYREF uniq) )\n)\n$(TR $(TDNW Sorting) $(TD $(MYREF completeSort) $(MYREF isPartitioned)\n$(MYREF isSorted) $(MYREF makeIndex) $(MYREF partialSort) $(MYREF\npartition) $(MYREF partition3) $(MYREF schwartzSort) $(MYREF sort)\n$(MYREF topN) $(MYREF topNCopy) )\n)\n$(TR $(TDNW Set&nbsp;operations) $(TD $(MYREF\nlargestPartialIntersection) $(MYREF largestPartialIntersectionWeighted)\n$(MYREF nWayUnion) $(MYREF setDifference) $(MYREF setIntersection) $(MYREF\nsetSymmetricDifference) $(MYREF setUnion) )\n)\n$(TR $(TDNW Mutation) $(TD $(MYREF bringToFront) $(MYREF copy) $(MYREF\nfill) $(MYREF initializeAll) $(MYREF move) $(MYREF moveAll) $(MYREF\nmoveSome) $(MYREF remove) $(MYREF reverse) $(MYREF swap) $(MYREF\nswapRanges) $(MYREF uninitializedFill) ))\n)\n\nImplements algorithms oriented mainly towards processing of\nsequences. Some functions are semantic equivalents or supersets of\nthose found in the $(D $(LESS)_algorithm$(GREATER)) header in $(WEB\nsgi.com\/tech\/stl\/, Alexander Stepanov's Standard Template Library) for\nC++.\n\nMany functions in this module are parameterized with a function or a\n$(GLOSSARY predicate). The predicate may be passed either as a\nfunction name, a delegate name, a $(GLOSSARY functor) name, or a\ncompile-time string. The string may consist of $(B any) legal D\nexpression that uses the symbol $(D a) (for unary functions) or the\nsymbols $(D a) and $(D b) (for binary functions). These names will NOT\ninterfere with other homonym symbols in user code because they are\nevaluated in a different context. The default for all binary\ncomparison predicates is $(D \"a == b\") for unordered operations and\n$(D \"a < b\") for ordered operations.\n\nExample:\n\n----\nint[] a = ...;\nstatic bool greater(int a, int b)\n{\n    return a > b;\n}\nsort!(greater)(a);  \/\/ predicate as alias\nsort!(\"a > b\")(a);  \/\/ predicate as string\n                    \/\/ (no ambiguity with array name)\nsort(a);            \/\/ no predicate, \"a < b\" is implicit\n----\n\n$(BOOKTABLE Cheat Sheet,\n$(TR $(TH Function Name) $(TH Description)\n)\n$(LEADINGROW Searching\n)\n$(TR $(TDNW $(LREF balancedParens)) $(TD $(D\nbalancedParens(\"((1 + 1) \/ 2)\")) returns $(D true) because the string\nhas balanced parentheses.)\n)\n$(TR $(TDNW $(LREF boyerMooreFinder)) $(TD $(D find(\"hello\nworld\", boyerMooreFinder(\"or\"))) returns $(D \"orld\") using the $(LUCKY\nBoyer-Moore _algorithm).)\n)\n$(TR $(TDNW $(LREF canFind)) $(TD $(D canFind(\"hello world\",\n\"or\")) returns $(D true).)\n)\n$(TR $(TDNW $(LREF count)) $(TD Counts elements that are equal\nto a specified value or satisfy a predicate. $(D count([1, 2, 1], 1))\nreturns $(D 2) and $(D count!\"a < 0\"([1, -3, 0])) returns $(D 1).)\n)\n$(TR $(TDNW $(LREF countUntil)) $(TD $(D countUntil(a, b))\nreturns the number of steps taken in $(D a) to reach $(D b); for\nexample, $(D countUntil(\"hello!\", \"o\")) returns $(D 4).)\n)\n$(TR $(TDNW $(LREF endsWith)) $(TD $(D endsWith(\"rocks\", \"ks\"))\nreturns $(D true).)\n)\n$(TR $(TD $(LREF find)) $(TD $(D find(\"hello world\",\n\"or\")) returns $(D \"orld\") using linear search. (For binary search refer\nto $(XREF range,sortedRange).))\n)\n$(TR $(TDNW $(LREF findAdjacent)) $(TD $(D findAdjacent([1, 2,\n3, 3, 4])) returns the subrange starting with two equal adjacent\nelements, i.e. $(D [3, 3, 4]).)\n)\n$(TR $(TDNW $(LREF findAmong)) $(TD $(D findAmong(\"abcd\",\n\"qcx\")) returns $(D \"cd\") because $(D 'c') is among $(D \"qcx\").)\n)\n$(TR $(TDNW $(LREF findSkip)) $(TD If $(D a = \"abcde\"), then\n$(D findSkip(a, \"x\")) returns $(D false) and leaves $(D a) unchanged,\nwhereas $(D findSkip(a, 'c')) advances $(D a) to $(D \"cde\") and\nreturns $(D true).)\n)\n$(TR $(TDNW $(LREF findSplit)) $(TD $(D findSplit(\"abcdefg\",\n\"de\")) returns the three ranges $(D \"abc\"), $(D \"de\"), and $(D\n\"fg\").)\n)\n$(TR $(TDNW $(LREF findSplitAfter)) $(TD $(D\nfindSplitAfter(\"abcdefg\", \"de\")) returns the two ranges $(D \"abcde\")\nand $(D \"fg\").)\n)\n$(TR $(TDNW $(LREF findSplitBefore)) $(TD $(D\nfindSplitBefore(\"abcdefg\", \"de\")) returns the two ranges $(D \"abc\") and\n$(D \"defg\").)\n)\n$(TR $(TDNW $(LREF minCount)) $(TD $(D minCount([2, 1, 1, 4,\n1])) returns $(D tuple(1, 3)).)\n)\n$(TR $(TDNW $(LREF minPos)) $(TD $(D minPos([2, 3, 1, 3, 4,\n1])) returns the subrange $(D [1, 3, 4, 1]), i.e., positions the range\nat the first occurrence of its minimal element.)\n)\n$(TR $(TDNW $(LREF skipOver)) $(TD Assume $(D a = \"blah\"). Then\n$(D skipOver(a, \"bi\")) leaves $(D a) unchanged and returns $(D false),\nwhereas $(D skipOver(a, \"bl\")) advances $(D a) to refer to $(D \"ah\")\nand returns $(D true).)\n)\n$(TR $(TDNW $(LREF startsWith)) $(TD $(D startsWith(\"hello,\nworld\", \"hello\")) returns $(D true).)\n)\n$(TR $(TDNW $(LREF until)) $(TD Lazily iterates a range\nuntil a specific value is found.)\n)\n$(LEADINGROW Comparison\n)\n$(TR $(TDNW $(LREF cmp)) $(TD $(D cmp(\"abc\", \"abcd\")) is $(D\n-1), $(D cmp(\"abc\", aba\")) is $(D 1), and $(D cmp(\"abc\", \"abc\")) is\n$(D 0).)\n)\n$(TR $(TDNW $(LREF equal)) $(TD Compares ranges for\nelement-by-element equality, e.g. $(D equal([1, 2, 3], [1.0, 2.0,\n3.0])) returns $(D true).)\n)\n$(TR $(TDNW $(LREF levenshteinDistance)) $(TD $(D\nlevenshteinDistance(\"kitten\", \"sitting\")) returns $(D 3) by using the\n$(LUCKY Levenshtein distance _algorithm).)\n)\n$(TR $(TDNW $(LREF levenshteinDistanceAndPath)) $(TD $(D\nlevenshteinDistanceAndPath(\"kitten\", \"sitting\")) returns $(D tuple(3,\n\"snnnsni\")) by using the $(LUCKY Levenshtein distance _algorithm).)\n)\n$(TR $(TDNW $(LREF max)) $(TD $(D max(3, 4, 2)) returns $(D\n4).)\n)\n$(TR $(TDNW $(LREF min)) $(TD $(D min(3, 4, 2)) returns $(D\n2).)\n)\n$(TR $(TDNW $(LREF mismatch)) $(TD $(D mismatch(\"oh hi\",\n\"ohayo\")) returns $(D tuple(\" hi\", \"ayo\")).)\n)\n$(LEADINGROW Iteration\n)\n$(TR $(TDNW $(LREF filter)) $(TD $(D filter!\"a > 0\"([1, -1, 2,\n0, -3])) iterates over elements $(D 1), $(D 2), and $(D 0).)\n)\n$(TR $(TDNW $(LREF filterBidirectional)) $(TD Similar to $(D\nfilter), but also provides $(D back) and $(D popBack) at a small\nincrease in cost.)\n)\n$(TR $(TDNW $(LREF group)) $(TD $(D group([5, 2, 2, 3, 3]))\nreturns a range containing the tuples $(D tuple(5, 1)),\n$(D tuple(2, 2)), and $(D tuple(3, 2)).)\n)\n$(TR $(TDNW $(LREF joiner)) $(TD $(D joiner([\"hello\",\n\"world!\"], \";\")) returns a range that iterates over the characters $(D\n\"hello; world!\"). No new string is created - the existing inputs are\niterated.)\n)\n$(TR $(TDNW $(LREF map)) $(TD $(D map!\"2 * a\"([1, 2, 3]))\nlazily returns a range with the numbers $(D 2), $(D 4), $(D 6).)\n)\n$(TR $(TDNW $(LREF reduce)) $(TD $(D reduce!\"a + b\"([1, 2, 3,\n4])) returns $(D 10).)\n)\n$(TR $(TDNW $(LREF splitter)) $(TD Lazily splits a range by a\nseparator.)\n)\n$(TR $(TDNW $(LREF uniq)) $(TD Iterates over the unique elements\nin a range, which is assumed sorted.)\n)\n$(LEADINGROW Sorting\n)\n$(TR $(TDNW $(LREF completeSort)) $(TD If $(D a = [10, 20, 30])\nand $(D b = [40, 6, 15]), then $(D completeSort(a, b)) leaves $(D a =\n[6, 10, 15]) and $(D b = [20, 30, 40]). The range $(D a) must be\nsorted prior to the call, and as a result the combination $(D $(XREF\nrange,chain)(a, b)) is sorted.)\n)\n$(TR $(TDNW $(LREF isPartitioned)) $(TD $(D isPartitioned!\"a <\n0\"([-1, -2, 1, 0, 2])) returns $(D true) because the predicate is $(D\ntrue) for a portion of the range and $(D false) afterwards.)\n)\n$(TR $(TDNW $(LREF isSorted)) $(TD $(D isSorted([1, 1, 2, 3]))\nreturns $(D true).)\n)\n$(TR $(TDNW $(LREF makeIndex)) $(TD Creates a separate index\nfor a range.)\n)\n$(TR $(TDNW $(LREF partialSort)) $(TD If $(D a = [5, 4, 3, 2,\n1]), then $(D partialSort(a, 3)) leaves $(D a[0 .. 3] = [1, 2,\n3]). The other elements of $(D a) are left in an unspecified order.)\n)\n$(TR $(TDNW $(LREF partition)) $(TD Partitions a range\naccording to a predicate.)\n)\n$(TR $(TDNW $(LREF schwartzSort)) $(TD Sorts with the help of\nthe $(LUCKY Schwartzian transform).)\n)\n$(TR $(TDNW $(LREF sort)) $(TD Sorts.)\n)\n$(TR $(TDNW $(LREF topN)) $(TD Separates the top elements in a\nrange.)\n)\n$(TR $(TDNW $(LREF topNCopy)) $(TD Copies out the top elements\nof a range.)\n)\n$(LEADINGROW Set operations\n)\n$(TR $(TDNW $(LREF largestPartialIntersection)) $(TD Copies out\nthe values that occur most frequently in a range of ranges.)\n)\n$(TR $(TDNW $(LREF largestPartialIntersectionWeighted)) $(TD\nCopies out the values that occur most frequently (multiplied by\nper-value weights) in a range of ranges.)\n)\n$(TR $(TDNW $(LREF nWayUnion)) $(TD Computes the union of a set\nof sets implemented as a range of sorted ranges.)\n)\n$(TR $(TDNW $(LREF setDifference)) $(TD Lazily computes the set\ndifference of two or more sorted ranges.)\n)\n$(TR $(TDNW $(LREF setIntersection)) $(TD Lazily computes the\nset difference of two or more sorted ranges.)\n)\n$(TR $(TDNW $(LREF setSymmetricDifference)) $(TD Lazily\ncomputes the symmetric set difference of two or more sorted ranges.)\n)\n$(TR $(TDNW $(LREF setUnion)) $(TD Lazily computes the set\nunion of two or more sorted ranges.)\n)\n$(LEADINGROW Mutation\n)\n$(TR $(TDNW $(LREF bringToFront)) $(TD If $(D a = [1, 2, 3])\nand $(D b = [4, 5, 6, 7]), $(D bringToFront(a, b)) leaves $(D a = [4,\n5, 6]) and $(D b = [7, 1, 2, 3]).)\n)\n$(TR $(TDNW $(LREF copy)) $(TD Copies a range to another. If\n$(D a = [1, 2, 3]) and $(D b = new int[5]), then $(D copy(a, b))\nleaves $(D b = [1, 2, 3, 0, 0]) and returns $(D b[3 .. $]).)\n)\n$(TR $(TDNW $(LREF fill)) $(TD Fills a range with a pattern,\ne.g., if $(D a = new int[3]), then $(D fill(a, 4)) leaves $(D a = [4,\n4, 4]) and $(D fill(a, [3, 4])) leaves $(D a = [3, 4, 3]).)\n)\n$(TR $(TDNW $(LREF initializeAll)) $(TD If $(D a = [1.2, 3.4]),\nthen $(D initializeAll(a)) leaves $(D a = [double.init,\ndouble.init]).)\n)\n$(TR $(TDNW $(LREF move)) $(TD $(D move(a, b)) moves $(D a)\ninto $(D b). $(D move(a)) reads $(D a) destructively.)\n)\n$(TR $(TDNW $(LREF moveAll)) $(TD Moves all elements from one\nrange to another.)\n)\n$(TR $(TDNW $(LREF moveSome)) $(TD Moves as many elements as\npossible from one range to another.)\n)\n$(TR $(TDNW $(LREF reverse)) $(TD If $(D a = [1, 2, 3]), $(D\nreverse(a)) changes it to $(D [3, 2, 1]).)\n)\n$(TR $(TDNW $(LREF swap)) $(TD Swaps two values.)\n)\n$(TR $(TDNW $(LREF swapRanges)) $(TD Swaps all elements of two\nranges.)\n)\n$(TR $(TDNW $(LREF uninitializedFill)) $(TD Fills a range\n(assumed uninitialized) with a value.)\n)\n)\n\nMacros:\nWIKI = Phobos\/StdAlgorithm\nMYREF = <font face='Consolas, \"Bitstream Vera Sans Mono\", \"Andale Mono\", Monaco, \"DejaVu Sans Mono\", \"Lucida Console\", monospace'><a href=\"#$1\">$1<\/a>&nbsp;<\/font>\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std\/_algorithm.d)\n \n",
"members" : [
{
"name" : "map(fun...) if (fun.length >= 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the homonym function (also known as $(D transform)) present\nin many languages of functional flavor. The call $(D map!(fun)(range))\nreturns a range of which elements are obtained by applying $(D fun(x))\nleft to right for all $(D x) in $(D range). The original ranges are\nnot changed. Evaluation is done lazily. The range returned by $(D map)\ncaches the last value such that evaluating $(D front) multiple times\ndoes not result in multiple calls to $(D fun).\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nauto squares = map!(\"a * a\")(chain(arr1, arr2));\nassert(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));\n----\n\nMultiple functions can be passed to $(D map). In that case, the\nelement type of $(D map) is a tuple containing one element for each\nfunction.\n\nExample:\n\n----\nauto arr1 = [ 1, 2, 3, 4 ];\nforeach (e; map!(\"a + a\", \"a * a\")(arr1))\n{\n    writeln(e[0], \" \", e[1]);\n}\n----\n\nYou may alias $(D map) with some function(s) to a symbol and use\nit separately:\n\n----\nalias map!(to!string) stringize;\nassert(equal(stringize([ 1, 2, 3, 4 ]), [ \"1\", \"2\", \"3\", \"4\" ]));\n----\n",
"line" : 367,
"members" : [
{
"name" : "map(Range) if (isInputRange!(Unqual!(Range)))",
"kind" : "template",
"protection" : "public",
"line" : 369,
"members" : [
{
"name" : "map",
"kind" : "function",
"type" : "(Range r)",
"line" : 369}
]
}
]
}
,
{
"name" : "MapResult(alias fun,Range)",
"kind" : "struct",
"protection" : "public",
"line" : 385,
"members" : [
{
"name" : "MapResult",
"kind" : "struct",
"protection" : "public",
"line" : 385,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "Unqual!(Range)",
"line" : 386}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 388}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R input)",
"line" : 403}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 421}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"line" : 427}
]
}
]
}
,
{
"name" : "reduce(fun...) if (fun.length >= 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the homonym function (also known as $(D accumulate), $(D\ncompress), $(D inject), or $(D foldl)) present in various programming\nlanguages of functional flavor. The call $(D reduce!(fun)(seed,\nrange)) first assigns $(D seed) to an internal variable $(D result),\nalso called the accumulator. Then, for each element $(D x) in $(D\nrange), $(D result = fun(result, x)) gets evaluated. Finally, $(D\nresult) is returned. The one-argument version $(D reduce!(fun)(range))\nworks similarly, but it uses the first element of the range as the\nseed (the range must be non-empty).\n\nMany aggregate range operations turn out to be solved with $(D reduce)\nquickly and easily. The example below illustrates $(D reduce)'s\nremarkable power and flexibility.\n\nExample:\n----\nint[] arr = [ 1, 2, 3, 4, 5 ];\n\/\/ Sum all elements\nauto sum = reduce!(\"a + b\")(0, arr);\nassert(sum == 15);\n\n\/\/ Compute the maximum of all elements\nauto largest = reduce!(max)(arr);\nassert(largest == 5);\n\n\/\/ Compute the number of odd elements\nauto odds = reduce!(\"a + (b & 1)\")(0, arr);\nassert(odds == 3);\n\n\/\/ Compute the sum of squares\nauto ssquares = reduce!(\"a + b * b\")(0, arr);\nassert(ssquares == 55);\n\n\/\/ Chain multiple ranges into seed\nint[] a = [ 3, 4 ];\nint[] b = [ 100 ];\nauto r = reduce!(\"a + b\")(chain(a, b));\nassert(r == 107);\n\n\/\/ Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = reduce!(\"a + b\")(chain(a, b, c));\nassert(r1 == 112.5);\n----\n\n$(DDOC_SECTION_H Multiple functions:) Sometimes it is very useful to\ncompute multiple aggregates in one pass. One advantage is that the\ncomputation is faster because the looping overhead is shared. That's\nwhy $(D reduce) accepts multiple functions. If two or more functions\nare passed, $(D reduce) returns a $(XREF typecons, Tuple) object with\none member per passed-in function. The number of seeds must be\ncorrespondingly increased.\n\nExample:\n----\ndouble[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];\n\/\/ Compute minimum and maximum in one pass\nauto r = reduce!(min, max)(a);\n\/\/ The type of r is Tuple!(double, double)\nassert(r[0] == 2);  \/\/ minimum\nassert(r[1] == 11); \/\/ maximum\n\n\/\/ Compute sum and sum of squares in one pass\nr = reduce!(\"a + b\", \"a + b * b\")(tuple(0.0, 0.0), a);\nassert(r[0] == 35);  \/\/ sum\nassert(r[1] == 233); \/\/ sum of squares\n\/\/ Compute average and standard deviation from the above\nauto avg = r[0] \/ a.length;\nauto stdev = sqrt(r[1] \/ a.length - avg * avg);\n----\n \n",
"line" : 636,
"members" : [
{
"name" : "reduce(Args...) if (Args.length > 0 && Args.length <= 2 && isIterable!(Args[__dollar - 1]))",
"kind" : "template",
"protection" : "public",
"line" : 638,
"members" : [
{
"name" : "reduce",
"kind" : "function",
"type" : "(Args args)",
"line" : 638}
]
}
]
}
,
{
"name" : "fill(Range,Value) if (isInputRange!(Range) && is(typeof(range.front = filler)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFills a range with a value.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4 ];\nfill(a, 5);\nassert(a == [ 5, 5, 5, 5 ]);\n----\n \n",
"line" : 850,
"members" : [
{
"name" : "fill",
"kind" : "function",
"type" : "void(Range range, Value filler)",
"comment" : "\nFills a range with a value.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4 ];\nfill(a, 5);\nassert(a == [ 5, 5, 5, 5 ]);\n----\n \n",
"line" : 850}
]
}
,
{
"name" : "fill(Range1,Range2) if (isInputRange!(Range1) && isForwardRange!(Range2) && is(typeof(Range1.init.front = Range2.init.front)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFills $(D range) with a pattern copied from $(D filler). The length of\n$(D range) does not have to be a multiple of the length of $(D\nfiller). If $(D filler) is empty, an exception is thrown.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = [ 8, 9 ];\nfill(a, b);\nassert(a == [ 8, 9, 8, 9, 8 ]);\n----\n \n",
"line" : 920,
"members" : [
{
"name" : "fill",
"kind" : "function",
"type" : "void(Range1 range, Range2 filler)",
"comment" : "\nFills $(D range) with a pattern copied from $(D filler). The length of\n$(D range) does not have to be a multiple of the length of $(D\nfiller). If $(D filler) is empty, an exception is thrown.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = [ 8, 9 ];\nfill(a, b);\nassert(a == [ 8, 9, 8, 9, 8 ]);\n----\n \n",
"line" : 920}
]
}
,
{
"name" : "uninitializedFill(Range,Value) if (isForwardRange!(Range) && is(typeof(range.front = filler)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFills a range with a value. Assumes that the range does not currently\ncontain meaningful content. This is of interest for structs that\ndefine copy constructors (for all other types, fill and\nuninitializedFill are equivalent).\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\nuninitializedFill(s, 42);\nassert(s == [ 42, 42, 42, 42, 42 ]);\n----\n \n",
"line" : 963,
"members" : [
{
"name" : "uninitializedFill",
"kind" : "function",
"type" : "void(Range range, Value filler)",
"comment" : "\nFills a range with a value. Assumes that the range does not currently\ncontain meaningful content. This is of interest for structs that\ndefine copy constructors (for all other types, fill and\nuninitializedFill are equivalent).\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\nuninitializedFill(s, 42);\nassert(s == [ 42, 42, 42, 42, 42 ]);\n----\n \n",
"line" : 963}
]
}
,
{
"name" : "initializeAll(Range) if (isForwardRange!(Range) && is(typeof(range.front = range.front)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nInitializes all elements of a range with their $(D .init)\nvalue. Assumes that the range does not currently contain meaningful\ncontent.\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\ninitializeAll(s);\nassert(s == [ 0, 0, 0, 0, 0 ]);\n----\n \n",
"line" : 1014,
"members" : [
{
"name" : "initializeAll",
"kind" : "function",
"type" : "void(Range range)",
"comment" : "\nInitializes all elements of a range with their $(D .init)\nvalue. Assumes that the range does not currently contain meaningful\ncontent.\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\ninitializeAll(s);\nassert(s == [ 0, 0, 0, 0, 0 ]);\n----\n \n",
"line" : 1014}
]
}
,
{
"name" : "filter(alias pred) if (is(typeof(unaryFun!(pred))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the homonym function present in various programming\nlanguages of functional flavor. The call $(D filter!(fun)(range))\nreturns a new range only containing elements $(D x) in $(D r) for\nwhich $(D predicate(x)) is $(D true).\n\nExample:\n----\nint[] arr = [ 1, 2, 3, 4, 5 ];\n\/\/ Sum all elements\nauto small = filter!(\"a < 3\")(arr);\nassert(equal(small, [ 1, 2 ]));\n\/\/ In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = filter!(\"a > 0\")(chain(a, b));\nassert(equal(r, [ 3, 400, 100, 102 ]));\n\/\/ Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = filter!(\"cast(int) a != a\")(chain(c, a, b));\nassert(equal(r1, [ 2.5 ]));\n----\n \n",
"line" : 1091,
"members" : [
{
"name" : "filter(Range) if (isInputRange!(Unqual!(Range)))",
"kind" : "template",
"protection" : "public",
"line" : 1093,
"members" : [
{
"name" : "filter",
"kind" : "function",
"type" : "(Range rs)",
"line" : 1093}
]
}
]
}
,
{
"name" : "FilterResult(alias pred,Range)",
"kind" : "struct",
"protection" : "public",
"line" : 1100,
"members" : [
{
"name" : "FilterResult",
"kind" : "struct",
"protection" : "public",
"line" : 1100,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "Unqual!(Range)",
"line" : 1101}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 1102}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R r)",
"line" : 1104}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "()",
"line" : 1113}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 1124}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"line" : 1133}
]
}
]
}
,
{
"name" : "filterBidirectional(alias pred)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Similar to $(D filter), except it defines a bidirectional\n range. There is a speed disadvantage - the constructor spends time\n finding the last element in the range that satisfies the filtering\n condition (in addition to finding the first one). The advantage is\n that the filtered range can be spanned from both directions. Also,\n $(XREF range, retro) can be applied against the filtered range.\n\nExample:\n----\nint[] arr = [ 1, 2, 3, 4, 5 ];\nauto small = filterBidirectional!(\"a < 3\")(arr);\nassert(small.back == 2);\nassert(equal(small, [ 1, 2 ]));\nassert(equal(retro(small), [ 2, 1 ]));\n\/\/ In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = filterBidirectional!(\"a > 0\")(chain(a, b));\nassert(r.back == 102);\n----\n \n",
"line" : 1255,
"members" : [
{
"name" : "filterBidirectional(Range) if (isBidirectionalRange!(Unqual!(Range)))",
"kind" : "template",
"protection" : "public",
"line" : 1257,
"members" : [
{
"name" : "filterBidirectional",
"kind" : "function",
"type" : "(Range r)",
"line" : 1257}
]
}
]
}
,
{
"name" : "FilterBidiResult(alias pred,Range)",
"kind" : "struct",
"protection" : "public",
"line" : 1264,
"members" : [
{
"name" : "FilterBidiResult",
"kind" : "struct",
"protection" : "public",
"line" : 1264,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "Unqual!(Range)",
"line" : 1265}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 1266}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R r)",
"line" : 1268}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 1275}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 1277}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"line" : 1286}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"line" : 1290}
,
{
"name" : "back",
"kind" : "function",
"type" : "@property ref ()",
"line" : 1299}
,
{
"name" : "save",
"kind" : "function",
"type" : "@property ()",
"line" : 1304}
]
}
]
}
,
{
"name" : "move(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nMoves $(D source) into $(D target) via a destructive\ncopy. Specifically: $(UL $(LI If $(D hasAliasing!T) is true (see\n$(XREF traits, hasAliasing)), then the representation of $(D source)\nis bitwise copied into $(D target) and then $(D source = T.init) is\nevaluated.)  $(LI Otherwise, $(D target = source) is evaluated.)) See\nalso $(XREF exception, pointsTo).\n\nPreconditions:\n$(D &source == &target || !pointsTo(source, source))\n",
"line" : 1336,
"members" : [
{
"name" : "move",
"kind" : "function",
"type" : "void(ref T source, ref T target)",
"comment" : "\nMoves $(D source) into $(D target) via a destructive\ncopy. Specifically: $(UL $(LI If $(D hasAliasing!T) is true (see\n$(XREF traits, hasAliasing)), then the representation of $(D source)\nis bitwise copied into $(D target) and then $(D source = T.init) is\nevaluated.)  $(LI Otherwise, $(D target = source) is evaluated.)) See\nalso $(XREF exception, pointsTo).\n\nPreconditions:\n$(D &source == &target || !pointsTo(source, source))\n",
"line" : 1336}
]
}
,
{
"name" : "move(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1429,
"members" : [
{
"name" : "move",
"kind" : "function",
"type" : "T(ref T source)",
"comment" : " Ditto\n",
"line" : 1429}
]
}
,
{
"name" : "moveAll(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2) && is(typeof(move(src.front,tgt.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Returns\nthe leftover portion of $(D tgt). Throws an exeption if there is not\nenough room in $(D tgt) to acommodate all of $(D src).\n\nPreconditions:\n$(D walkLength(src) <= walkLength(tgt))\n \n",
"line" : 1585,
"members" : [
{
"name" : "moveAll",
"kind" : "function",
"type" : "Range2(Range1 src, Range2 tgt)",
"comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Returns\nthe leftover portion of $(D tgt). Throws an exeption if there is not\nenough room in $(D tgt) to acommodate all of $(D src).\n\nPreconditions:\n$(D walkLength(src) <= walkLength(tgt))\n \n",
"line" : 1585}
]
}
,
{
"name" : "moveSome(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2) && is(typeof(move(src.front,tgt.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Stops\nwhen either $(D src) or $(D tgt) have been exhausted. Returns the\nleftover portions of the two ranges.\n \n",
"line" : 1615,
"members" : [
{
"name" : "moveSome",
"kind" : "function",
"type" : "Tuple!(Range1,Range2)(Range1 src, Range2 tgt)",
"comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Stops\nwhen either $(D src) or $(D tgt) have been exhausted. Returns the\nleftover portions of the two ranges.\n \n",
"line" : 1615}
]
}
,
{
"name" : "swap(T) if (isMutable!(T) && !is(typeof(T.init.proxySwap(T.init))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSwaps $(D lhs) and $(D rhs). See also $(XREF exception, pointsTo).\n\nPreconditions:\n\n$(D !pointsTo(lhs, lhs) && !pointsTo(lhs, rhs) && !pointsTo(rhs, lhs)\n&& !pointsTo(rhs, rhs))\n \n",
"line" : 1647,
"members" : [
{
"name" : "swap",
"kind" : "function",
"type" : "pure nothrow @trusted void(ref T lhs, ref T rhs)",
"comment" : "\nSwaps $(D lhs) and $(D rhs). See also $(XREF exception, pointsTo).\n\nPreconditions:\n\n$(D !pointsTo(lhs, lhs) && !pointsTo(lhs, rhs) && !pointsTo(rhs, lhs)\n&& !pointsTo(rhs, rhs))\n \n",
"line" : 1647}
]
}
,
{
"name" : "swap(T) if (is(typeof(T.init.proxySwap(T.init))))",
"kind" : "template",
"protection" : "public",
"line" : 1684,
"members" : [
{
"name" : "swap",
"kind" : "function",
"type" : "void(T lhs, T rhs)",
"line" : 1684}
]
}
,
{
"name" : "swapFront(R1,R2) if (isInputRange!(R1) && isInputRange!(R2))",
"kind" : "template",
"protection" : "public",
"line" : 1752,
"members" : [
{
"name" : "swapFront",
"kind" : "function",
"type" : "void(R1 r1, R2 r2)",
"line" : 1752}
]
}
,
{
"name" : "splitter(Range,Separator) if (is(typeof(ElementType!(Range).init == Separator.init)) && (hasSlicing!(Range) || isNarrowString!(Range)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSplits a range using an element as a separator. This can be used with\nany range type, but is most popular with string types.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range.\n\nIf the empty range is given, the result is a range with one empty\nelement. If a range with one separator is given, the result is a range\nwith two empty elements.\n\nExample:\n---\nassert(equal(splitter(\"hello  world\", ' '), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5] ];\nassert(equal(splitter(a, 0), w));\na = null;\nassert(equal(splitter(a, 0), [ (int[]).init ]));\na = [ 0 ];\nassert(equal(splitter(a, 0), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter(a, 0), [ [], [1] ]));\n----\n",
"line" : 1793,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "(Range r, Separator s)",
"comment" : "\nSplits a range using an element as a separator. This can be used with\nany range type, but is most popular with string types.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range.\n\nIf the empty range is given, the result is a range with one empty\nelement. If a range with one separator is given, the result is a range\nwith two empty elements.\n\nExample:\n---\nassert(equal(splitter(\"hello  world\", ' '), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5] ];\nassert(equal(splitter(a, 0), w));\na = null;\nassert(equal(splitter(a, 0), [ (int[]).init ]));\na = [ 0 ];\nassert(equal(splitter(a, 0), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter(a, 0), [ [], [1] ]));\n----\n",
"line" : 1793}
]
}
,
{
"name" : "splitter(Range,Separator) if (is(typeof(Range.init.front == Separator.init.front) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSplits a range using another range as a separator. This can be used\nwith any range type, but is most popular with string types.\n \n",
"line" : 2012,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "(Range r, Separator s)",
"comment" : "\nSplits a range using another range as a separator. This can be used\nwith any range type, but is most popular with string types.\n \n",
"line" : 2012}
]
}
,
{
"name" : "splitter(alias isTerminator,Range) if (is(typeof(unaryFun!(isTerminator)(ElementType!(Range).init))))",
"kind" : "template",
"protection" : "public",
"line" : 2208,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "(Range input)",
"line" : 2208}
]
}
,
{
"name" : "SplitterResult(alias isTerminator,Range)",
"kind" : "struct",
"protection" : "public",
"line" : 2215,
"members" : [
{
"name" : "SplitterResult",
"kind" : "struct",
"protection" : "public",
"line" : 2215,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 2216}
,
{
"name" : "_end",
"kind" : "variable",
"type" : "size_t",
"line" : 2217}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input)",
"line" : 2219}
,
{
"name" : "front",
"kind" : "function",
"type" : "Range()",
"line" : 2248}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2254}
]
}
]
}
,
{
"name" : "splitter(Range) if (isSomeString!(Range))",
"kind" : "template",
"protection" : "public",
"line" : 2348,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "(Range input)",
"line" : 2348}
]
}
,
{
"name" : "joiner(RoR,Separator) if (isInputRange!(RoR) && isInputRange!(ElementType!(RoR)) && isForwardRange!(Separator) && is(ElementType!(Separator) : ElementType!(ElementType!(RoR))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nLazily joins a range of ranges with a separator. The separator itself\nis a range. If you do not provide a separator, then the ranges are\njoined directly without anything in between them.\n\nExample:\n----\nassert(equal(joiner([\"\"], \"xyz\"), \"\"));\nassert(equal(joiner([\"\", \"\"], \"xyz\"), \"xyz\"));\nassert(equal(joiner([\"\", \"abc\"], \"xyz\"), \"xyzabc\"));\nassert(equal(joiner([\"abc\", \"\"], \"xyz\"), \"abcxyz\"));\nassert(equal(joiner([\"abc\", \"def\"], \"xyz\"), \"abcxyzdef\"));\nassert(equal(joiner([\"Mary\", \"has\", \"a\", \"little\", \"lamb\"], \"...\"),\n  \"Mary...has...a...little...lamb\"));\nassert(equal(joiner([\"abc\", \"def\"]), \"abcdef\"));\n----\n \n",
"line" : 2395,
"members" : [
{
"name" : "joiner",
"kind" : "function",
"type" : "(RoR r, Separator sep)",
"comment" : "\nLazily joins a range of ranges with a separator. The separator itself\nis a range. If you do not provide a separator, then the ranges are\njoined directly without anything in between them.\n\nExample:\n----\nassert(equal(joiner([\"\"], \"xyz\"), \"\"));\nassert(equal(joiner([\"\", \"\"], \"xyz\"), \"xyz\"));\nassert(equal(joiner([\"\", \"abc\"], \"xyz\"), \"xyzabc\"));\nassert(equal(joiner([\"abc\", \"\"], \"xyz\"), \"abcxyz\"));\nassert(equal(joiner([\"abc\", \"def\"], \"xyz\"), \"abcxyzdef\"));\nassert(equal(joiner([\"Mary\", \"has\", \"a\", \"little\", \"lamb\"], \"...\"),\n  \"Mary...has...a...little...lamb\"));\nassert(equal(joiner([\"abc\", \"def\"]), \"abcdef\"));\n----\n \n",
"line" : 2395}
]
}
,
{
"name" : "joiner(RoR) if (isInputRange!(RoR) && isInputRange!(ElementType!(RoR)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 2535,
"members" : [
{
"name" : "joiner",
"kind" : "function",
"type" : "(RoR r)",
"comment" : " Ditto\n",
"line" : 2535}
]
}
,
{
"name" : "uniq(alias pred = \"a == b\",Range) if (isInputRange!(Range) && is(typeof(binaryFun!(pred)(r.front,r.front)) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIterates unique consecutive elements of the given range (functionality\nakin to the $(WEB wikipedia.org\/wiki\/_Uniq, _uniq) system\nutility). Equivalence of elements is assessed by using the predicate\n$(D pred), by default $(D \"a == b\"). If the given range is\nbidirectional, $(D uniq) also yields a bidirectional range.\n\nExample:\n----\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));\n----\n",
"line" : 2636,
"members" : [
{
"name" : "uniq",
"kind" : "function",
"type" : "(Range r)",
"comment" : "\nIterates unique consecutive elements of the given range (functionality\nakin to the $(WEB wikipedia.org\/wiki\/_Uniq, _uniq) system\nutility). Equivalence of elements is assessed by using the predicate\n$(D pred), by default $(D \"a == b\"). If the given range is\nbidirectional, $(D uniq) also yields a bidirectional range.\n\nExample:\n----\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));\n----\n",
"line" : 2636}
]
}
,
{
"name" : "UniqResult(alias pred,Range)",
"kind" : "struct",
"protection" : "public",
"line" : 2643,
"members" : [
{
"name" : "UniqResult",
"kind" : "struct",
"protection" : "public",
"line" : 2643,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 2644}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input)",
"line" : 2646}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "()",
"line" : 2652}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2656}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType!(Range)()",
"line" : 2666}
]
}
]
}
,
{
"name" : "Group(alias pred,R) if (isInputRange!(R))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nSimilarly to $(D uniq), $(D group) iterates unique consecutive\nelements of the given range. The element type is $(D\nTuple!(ElementType!R, uint)) because it includes the count of\nequivalent elements seen. Equivalence of elements is assessed by using\nthe predicate $(D pred), by default $(D \"a == b\").\n\n$(D Group) is an input range if $(D R) is an input range, and a\nforward range in all other cases.\n\nExample:\n----\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),\n    tuple(4, 3u), tuple(5, 1u) ][]));\n----\n",
"line" : 2743,
"members" : [
{
"name" : "Group",
"kind" : "struct",
"protection" : "public",
"line" : 2743,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 2744}
,
{
"name" : "_current",
"kind" : "variable",
"type" : "Tuple!(ElementType!(R),uint)",
"line" : 2745}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(pred)",
"line" : 2746}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R input)",
"line" : 2748}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2754}
,
{
"name" : "front",
"kind" : "function",
"type" : "Tuple!(ElementType!(R),uint)()",
"line" : 2784}
]
}
]
}
,
{
"name" : "group(alias pred = \"a == b\",Range)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 2802,
"members" : [
{
"name" : "group",
"kind" : "function",
"type" : "Group!(pred,Range)(Range r)",
"comment" : " Ditto\n",
"line" : 2802}
]
}
,
{
"name" : "find(alias pred = \"a == b\",R,E) if (isInputRange!(R) && is(typeof(binaryFun!(pred)(haystack.front,needle)) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFinds an individual element in an input range. Elements of $(D\nhaystack) are compared with $(D needle) by using predicate $(D\npred). Performs $(BIGOH walkLength(haystack)) evaluations of $(D\npred). See also $(WEB sgi.com\/tech\/stl\/_find.html, STL's _find).\n\nTo _find the last occurence of $(D needle) in $(D haystack), call $(D\nfind(retro(haystack), needle)). See also $(XREF range, retro).\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The element searched for.\n\nConstraints:\n\n$(D isInputRange!R && is(typeof(binaryFun!pred(haystack.front, needle)\n: bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D binaryFun!pred(haystack.front,\nneedle)) is $(D true) (if no such position exists, returns $(D\nhaystack) after exhaustion).\n\nExample:\n\n----\nassert(find(\"hello, world\", ',') == \", world\");\nassert(find([1, 2, 3, 5], 4) == []);\nassert(find(SList!int(1, 2, 3, 4, 5)[], 4) == SList!int(4, 5)[]);\nassert(find!\"a > b\"([1, 2, 3, 5], 2) == [3, 5]);\n\nauto a = [ 1, 2, 3 ];\nassert(find(a, 5).empty);       \/\/ not found\nassert(!find(a, 2).empty);      \/\/ found\n\n\/\/ Case-insensitive find of a string\nstring[] s = [ \"Hello\", \"world\", \"!\" ];\nassert(!find!(\"toLower(a) == b\")(s, \"hello\").empty);\n----\n \n",
"line" : 2941,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "R(R haystack, E needle)",
"comment" : "\nFinds an individual element in an input range. Elements of $(D\nhaystack) are compared with $(D needle) by using predicate $(D\npred). Performs $(BIGOH walkLength(haystack)) evaluations of $(D\npred). See also $(WEB sgi.com\/tech\/stl\/_find.html, STL's _find).\n\nTo _find the last occurence of $(D needle) in $(D haystack), call $(D\nfind(retro(haystack), needle)). See also $(XREF range, retro).\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The element searched for.\n\nConstraints:\n\n$(D isInputRange!R && is(typeof(binaryFun!pred(haystack.front, needle)\n: bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D binaryFun!pred(haystack.front,\nneedle)) is $(D true) (if no such position exists, returns $(D\nhaystack) after exhaustion).\n\nExample:\n\n----\nassert(find(\"hello, world\", ',') == \", world\");\nassert(find([1, 2, 3, 5], 4) == []);\nassert(find(SList!int(1, 2, 3, 4, 5)[], 4) == SList!int(4, 5)[]);\nassert(find!\"a > b\"([1, 2, 3, 5], 2) == [3, 5]);\n\nauto a = [ 1, 2, 3 ];\nassert(find(a, 5).empty);       \/\/ not found\nassert(!find(a, 2).empty);      \/\/ found\n\n\/\/ Case-insensitive find of a string\nstring[] s = [ \"Hello\", \"world\", \"!\" ];\nassert(!find!(\"toLower(a) == b\")(s, \"hello\").empty);\n----\n \n",
"line" : 2941}
]
}
,
{
"name" : "find(alias pred = \"a == b\",R1,R2) if (isForwardRange!(R1) && isForwardRange!(R2) && is(typeof(binaryFun!(pred)(haystack.front,needle.front)) : bool) && !isRandomAccessRange!(R1))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFinds a forward range in another. Elements are compared for\nequality. Performs $(BIGOH walkLength(haystack) * walkLength(needle))\ncomparisons in the worst case. Specializations taking advantage of\nbidirectional or random access (where present) may accelerate search\ndepending on the statistics of the two ranges' content.\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The range searched for.\n\nConstraints:\n\n$(D isForwardRange!R1 && isForwardRange!R2 &&\nis(typeof(binaryFun!pred(haystack.front, needle.front) : bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D needle) is a prefix of it (if no\nsuch position exists, returns $(D haystack) advanced to termination).\n\n----\nassert(find(\"hello, world\", \"World\").empty);\nassert(find(\"hello, world\", \"wo\") == \"world\");\nassert(find([1, 2, 3, 4], SList!(2, 3)[]) == [2, 3, 4]);\n----\n \n",
"line" : 2992,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "R1(R1 haystack, R2 needle)",
"comment" : "\nFinds a forward range in another. Elements are compared for\nequality. Performs $(BIGOH walkLength(haystack) * walkLength(needle))\ncomparisons in the worst case. Specializations taking advantage of\nbidirectional or random access (where present) may accelerate search\ndepending on the statistics of the two ranges' content.\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The range searched for.\n\nConstraints:\n\n$(D isForwardRange!R1 && isForwardRange!R2 &&\nis(typeof(binaryFun!pred(haystack.front, needle.front) : bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D needle) is a prefix of it (if no\nsuch position exists, returns $(D haystack) advanced to termination).\n\n----\nassert(find(\"hello, world\", \"World\").empty);\nassert(find(\"hello, world\", \"wo\") == \"world\");\nassert(find([1, 2, 3, 4], SList!(2, 3)[]) == [2, 3, 4]);\n----\n \n",
"line" : 2992}
]
}
,
{
"name" : "find(alias pred = \"a == b\",R1,R2) if (isRandomAccessRange!(R1) && isBidirectionalRange!(R2) && is(typeof(binaryFun!(pred)(haystack.front,needle.front)) : bool))",
"kind" : "template",
"protection" : "public",
"line" : 3028,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "R1(R1 haystack, R2 needle)",
"line" : 3028}
]
}
,
{
"name" : "find(alias pred = \"a == b\",R1,R2) if (isRandomAccessRange!(R1) && isForwardRange!(R2) && !isBidirectionalRange!(R2) && is(typeof(binaryFun!(pred)(haystack.front,needle.front)) : bool))",
"kind" : "template",
"protection" : "public",
"line" : 3100,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "R1(R1 haystack, R2 needle)",
"line" : 3100}
]
}
,
{
"name" : "simpleMindedFind(alias pred,R1,R2)",
"kind" : "template",
"protection" : "public",
"line" : 3143,
"members" : [
{
"name" : "simpleMindedFind",
"kind" : "function",
"type" : "R1(R1 haystack, R2 needle)",
"line" : 3143}
]
}
,
{
"name" : "find(alias pred = \"a == b\",Range,Ranges...) if (Ranges.length > 1 && allSatisfy!(isForwardRange,Ranges))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFinds two or more $(D needles) into a $(D haystack). The predicate $(D\npred) is used throughout to compare elements. By default, elements are\ncompared for equality.\n\nParams:\n\nhaystack = The target of the search. Must be an $(GLOSSARY input\nrange). If any of $(D needles) is a range with elements comparable to\nelements in $(D haystack), then $(D haystack) must be a $(GLOSSARY\nforward range) such that the search can backtrack.\n\nneedles = One or more items to search for. Each of $(D needles) must\nbe either comparable to one element in $(D haystack), or be itself a\n$(GLOSSARY forward range) with elements comparable with elements in\n$(D haystack).\n\nReturns:\n\nA tuple containing $(D haystack) positioned to match one of the\nneedles and also the 1-based index of the matching element in $(D\nneedles) (0 if none of $(D needles) matched, 1 if $(D needles[0])\nmatched, 2 if $(D needles[1]) matched...). The first needle to be found\nwill be the one that matches. If multiple needles are found at the\nsame spot in the range, then the shortest one is the one which matches\n(if multiple needles of the same length are found at the same spot (e.g\n$(D \"a\") and $(D 'a')), then the left-most of them in the argument list\nmatches).\n\nThe relationship between $(D haystack) and $(D needles) simply means\nthat one can e.g. search for individual $(D int)s or arrays of $(D\nint)s in an array of $(D int)s. In addition, if elements are\nindividually comparable, searches of heterogeneous types are allowed\nas well: a $(D double[]) can be searched for an $(D int) or a $(D\nshort[]), and conversely a $(D long) can be searched for a $(D float)\nor a $(D double[]). This makes for efficient searches without the need\nto coerce one side of the comparison into the other's side type.\n\nExample:\n----\nint[] a = [ 1, 4, 2, 3 ];\nassert(find(a, 4) == [ 4, 2, 3 ]);\nassert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);\nassert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));\n\/\/ Mixed types allowed if comparable\nassert(find(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));\n----\n\nThe complexity of the search is $(BIGOH haystack.length *\nmax(needles.length)). (For needles that are individual items, length\nis considered to be 1.) The strategy used in searching several\nsubranges at once maximizes cache usage by moving in $(D haystack) as\nfew times as possible.\n \n",
"line" : 3265,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "Tuple!(Range,size_t)(Range haystack, Ranges needles)",
"comment" : "\nFinds two or more $(D needles) into a $(D haystack). The predicate $(D\npred) is used throughout to compare elements. By default, elements are\ncompared for equality.\n\nParams:\n\nhaystack = The target of the search. Must be an $(GLOSSARY input\nrange). If any of $(D needles) is a range with elements comparable to\nelements in $(D haystack), then $(D haystack) must be a $(GLOSSARY\nforward range) such that the search can backtrack.\n\nneedles = One or more items to search for. Each of $(D needles) must\nbe either comparable to one element in $(D haystack), or be itself a\n$(GLOSSARY forward range) with elements comparable with elements in\n$(D haystack).\n\nReturns:\n\nA tuple containing $(D haystack) positioned to match one of the\nneedles and also the 1-based index of the matching element in $(D\nneedles) (0 if none of $(D needles) matched, 1 if $(D needles[0])\nmatched, 2 if $(D needles[1]) matched...). The first needle to be found\nwill be the one that matches. If multiple needles are found at the\nsame spot in the range, then the shortest one is the one which matches\n(if multiple needles of the same length are found at the same spot (e.g\n$(D \"a\") and $(D 'a')), then the left-most of them in the argument list\nmatches).\n\nThe relationship between $(D haystack) and $(D needles) simply means\nthat one can e.g. search for individual $(D int)s or arrays of $(D\nint)s in an array of $(D int)s. In addition, if elements are\nindividually comparable, searches of heterogeneous types are allowed\nas well: a $(D double[]) can be searched for an $(D int) or a $(D\nshort[]), and conversely a $(D long) can be searched for a $(D float)\nor a $(D double[]). This makes for efficient searches without the need\nto coerce one side of the comparison into the other's side type.\n\nExample:\n----\nint[] a = [ 1, 4, 2, 3 ];\nassert(find(a, 4) == [ 4, 2, 3 ]);\nassert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);\nassert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));\n\/\/ Mixed types allowed if comparable\nassert(find(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));\n----\n\nThe complexity of the search is $(BIGOH haystack.length *\nmax(needles.length)). (For needles that are individual items, length\nis considered to be 1.) The strategy used in searching several\nsubranges at once maximizes cache usage by moving in $(D haystack) as\nfew times as possible.\n \n",
"line" : 3265}
]
}
,
{
"name" : "BoyerMooreFinder(alias pred,Range)",
"kind" : "struct",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3352,
"members" : [
{
"name" : "BoyerMooreFinder",
"kind" : "struct",
"protection" : "public",
"line" : 3352,
"members" : [
{
"name" : "skip",
"kind" : "variable",
"type" : "size_t[]",
"line" : 3354}
,
{
"name" : "occ",
"kind" : "variable",
"type" : "sizediff_t[ElementType!(Range)]",
"line" : 3355}
,
{
"name" : "needle",
"kind" : "variable",
"type" : "Range",
"line" : 3356}
,
{
"name" : "occurrence",
"kind" : "function",
"type" : "sizediff_t(ElementType!(Range) c)",
"line" : 3358}
,
{
"name" : "needlematch(R)",
"kind" : "template",
"protection" : "public",
"line" : 3372,
"members" : [
{
"name" : "needlematch",
"kind" : "function",
"type" : "bool(R needle, size_t portion, size_t offset)",
"line" : 3372}
]
}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range needle)",
"line" : 3391}
,
{
"name" : "beFound",
"kind" : "function",
"type" : "Range(Range haystack)",
"line" : 3417}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"line" : 3436}
,
{
"name" : "opDollar",
"kind" : "alias",
"type" : "length",
"line" : 3441}
]
}
]
}
,
{
"name" : "boyerMooreFinder(alias pred = \"a == b\",Range) if (isRandomAccessRange!(Range) || isSomeString!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3445,
"members" : [
{
"name" : "boyerMooreFinder",
"kind" : "function",
"type" : "BoyerMooreFinder!(binaryFun!(pred),Range)(Range needle)",
"comment" : " Ditto\n",
"line" : 3445}
]
}
,
{
"name" : "find(Range1,alias pred,Range2)",
"kind" : "template",
"protection" : "public",
"line" : 3453,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "Range1(Range1 haystack, BoyerMooreFinder!(pred,Range2) needle)",
"line" : 3453}
]
}
,
{
"name" : "find(alias pred,Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAdvances the input range $(D haystack) by calling $(D haystack.popFront)\nuntil either $(D pred(haystack.front)), or $(D\nhaystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D\npred). See also $(WEB sgi.com\/tech\/stl\/find_if.html, STL's find_if).\n\nTo find the last element of a bidirectional $(D haystack) satisfying\n$(D pred), call $(D find!(pred)(retro(haystack))). See also $(XREF\nrange, retro).\n\nExample:\n----\nauto arr = [ 1, 2, 3, 4, 1 ];\nassert(find!(\"a > 2\")(arr) == [ 3, 4, 1 ]);\n\n\/\/ with predicate alias\nbool pred(int x) { return x + 1 > 1.5; }\nassert(find!(pred)(arr) == arr);\n----\n",
"line" : 3499,
"members" : [
{
"name" : "find",
"kind" : "function",
"type" : "Range(Range haystack)",
"comment" : "\nAdvances the input range $(D haystack) by calling $(D haystack.popFront)\nuntil either $(D pred(haystack.front)), or $(D\nhaystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D\npred). See also $(WEB sgi.com\/tech\/stl\/find_if.html, STL's find_if).\n\nTo find the last element of a bidirectional $(D haystack) satisfying\n$(D pred), call $(D find!(pred)(retro(haystack))). See also $(XREF\nrange, retro).\n\nExample:\n----\nauto arr = [ 1, 2, 3, 4, 1 ];\nassert(find!(\"a > 2\")(arr) == [ 3, 4, 1 ]);\n\n\/\/ with predicate alias\nbool pred(int x) { return x + 1 > 1.5; }\nassert(find!(pred)(arr) == arr);\n----\n",
"line" : 3499}
]
}
,
{
"name" : "findSkip(alias pred = \"a == b\",R1,R2) if (isForwardRange!(R1) && isForwardRange!(R2) && is(typeof(binaryFun!(pred)(haystack.front,needle.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n If $(D needle) occurs in $(D haystack), positions $(D haystack)\n right after the first occurrence of $(D needle) and returns $(D\n true). Otherwise, leaves $(D haystack) as is and returns $(D\n false).\n\n Example:\n----\nstring s = \"abcdef\";\nassert(findSkip(s, \"cd\") && s == \"ef\");\ns = \"abcdef\";\nassert(!findSkip(s, \"cxd\") && s == \"abcdef\");\nassert(findSkip(s, \"def\") && s.empty);\n----\n \n",
"line" : 3533,
"members" : [
{
"name" : "findSkip",
"kind" : "function",
"type" : "bool(ref R1 haystack, R2 needle)",
"comment" : "\n If $(D needle) occurs in $(D haystack), positions $(D haystack)\n right after the first occurrence of $(D needle) and returns $(D\n true). Otherwise, leaves $(D haystack) as is and returns $(D\n false).\n\n Example:\n----\nstring s = \"abcdef\";\nassert(findSkip(s, \"cd\") && s == \"ef\");\ns = \"abcdef\";\nassert(!findSkip(s, \"cxd\") && s == \"abcdef\");\nassert(findSkip(s, \"def\") && s.empty);\n----\n \n",
"line" : 3533}
]
}
,
{
"name" : "findSplit(alias pred = \"a == b\",R1,R2) if (isForwardRange!(R1) && isForwardRange!(R2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThese functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2]\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\n\nExample:\n----\nauto a = [ 1, 2, 3, 4, 5, 6, 7, 8 ];\nauto r = findSplit(a, [9, 1]);\nassert(r[0] == a);\nassert(r[1].empty);\nassert(r[2].empty);\nr = findSplit(a, [ 3, 4 ]);\nassert(r[0] == a[0 .. 2]);\nassert(r[1] == a[2 .. 4]);\nassert(r[2] == a[4 .. $]);\nauto r1 = findSplitBefore(a, [ 7, 8 ]);\nassert(r1[0] == a[0 .. 6]);\nassert(r1[1] == a[6 .. $]);\nauto r1 = findSplitAfter(a, [ 7, 8 ]);\nassert(r1[0] == a);\nassert(r1[1].empty);\n----\n \n",
"line" : 3605,
"members" : [
{
"name" : "findSplit",
"kind" : "function",
"type" : "(R1 haystack, R2 needle)",
"comment" : "\nThese functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2]\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\n\nExample:\n----\nauto a = [ 1, 2, 3, 4, 5, 6, 7, 8 ];\nauto r = findSplit(a, [9, 1]);\nassert(r[0] == a);\nassert(r[1].empty);\nassert(r[2].empty);\nr = findSplit(a, [ 3, 4 ]);\nassert(r[0] == a[0 .. 2]);\nassert(r[1] == a[2 .. 4]);\nassert(r[2] == a[4 .. $]);\nauto r1 = findSplitBefore(a, [ 7, 8 ]);\nassert(r1[0] == a[0 .. 6]);\nassert(r1[1] == a[6 .. $]);\nauto r1 = findSplitAfter(a, [ 7, 8 ]);\nassert(r1[0] == a);\nassert(r1[1].empty);\n----\n \n",
"line" : 3605}
]
}
,
{
"name" : "findSplitBefore(alias pred = \"a == b\",R1,R2) if (isForwardRange!(R1) && isForwardRange!(R2))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3647,
"members" : [
{
"name" : "findSplitBefore",
"kind" : "function",
"type" : "(R1 haystack, R2 needle)",
"comment" : " Ditto\n",
"line" : 3647}
]
}
,
{
"name" : "findSplitAfter(alias pred = \"a == b\",R1,R2) if (isForwardRange!(R1) && isForwardRange!(R2))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3683,
"members" : [
{
"name" : "findSplitAfter",
"kind" : "function",
"type" : "(R1 haystack, R2 needle)",
"comment" : " Ditto\n",
"line" : 3683}
]
}
,
{
"name" : "countUntil(alias pred = \"a == b\",R,N) if (is(typeof(startsWith!(pred)(haystack,needle))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the number of elements which must be popped from the front of\n    $(D haystack) before reaching an element for which\n    $(D startsWith!pred(haystack, needle)) is $(D true). If\n    $(D startsWith!pred(haystack, needle)) is not $(D true) for any element in\n    $(D haystack), then -1 is returned.\n\n    $(D needle) may be either an element or a range.\n\n    Examples:\n--------------------\nassert(countUntil(\"hello world\", \"world\") == 6);\nassert(countUntil(\"hello world\", 'r') == 8);\nassert(countUntil(\"hello world\", \"programming\") == -1);\nassert(countUntil([0, 7, 12, 22, 9], [12, 22]) == 2);\nassert(countUntil([0, 7, 12, 22, 9], 9) == 4);\nassert(countUntil!\"a > b\"([0, 7, 12, 22, 9], 20) == 3);\n--------------------\n  \n",
"line" : 3798,
"members" : [
{
"name" : "countUntil",
"kind" : "function",
"type" : "sizediff_t(R haystack, N needle)",
"comment" : "\n    Returns the number of elements which must be popped from the front of\n    $(D haystack) before reaching an element for which\n    $(D startsWith!pred(haystack, needle)) is $(D true). If\n    $(D startsWith!pred(haystack, needle)) is not $(D true) for any element in\n    $(D haystack), then -1 is returned.\n\n    $(D needle) may be either an element or a range.\n\n    Examples:\n--------------------\nassert(countUntil(\"hello world\", \"world\") == 6);\nassert(countUntil(\"hello world\", 'r') == 8);\nassert(countUntil(\"hello world\", \"programming\") == -1);\nassert(countUntil([0, 7, 12, 22, 9], [12, 22]) == 2);\nassert(countUntil([0, 7, 12, 22, 9], 9) == 4);\nassert(countUntil!\"a > b\"([0, 7, 12, 22, 9], 20) == 3);\n--------------------\n  \n",
"line" : 3798}
]
}
,
{
"name" : "countUntil(alias pred,R) if (isForwardRange!(R) && is(typeof(unaryFun!(pred)(haystack.front)) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the number of elements which must be popped from $(D haystack)\n    before $(D pred(haystack.front)) is $(D true).\n\n    Examples:\n--------------------\nassert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\nassert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\nassert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n--------------------\n  \n",
"line" : 3846,
"members" : [
{
"name" : "countUntil",
"kind" : "function",
"type" : "sizediff_t(R haystack)",
"comment" : "\n    Returns the number of elements which must be popped from $(D haystack)\n    before $(D pred(haystack.front)) is $(D true).\n\n    Examples:\n--------------------\nassert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\nassert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\nassert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n--------------------\n  \n",
"line" : 3846}
]
}
,
{
"name" : "indexOf(alias pred = \"a == b\",R1,R2) if (is(typeof(startsWith!(pred)(haystack,needle))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n  $(RED Deprecated. It will be removed in January 2013.\n        Please use $(LREF countUntil) instead.)\n\n Same as $(D countUntil). This symbol has been deprecated\n because it is easily confused with the homonym function\n in $(D std.string).\n \n",
"line" : 3888,
"members" : [
{
"name" : "indexOf",
"kind" : "function",
"type" : "sizediff_t(R1 haystack, R2 needle)",
"line" : 3888}
]
}
,
{
"name" : "OpenRight",
"kind" : "enum",
"protection" : "public",
"comment" : "\nInterval option specifier for $(D until) (below) and others.\n \n",
"line" : 3898,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " Interval is closed to the right (last element included)\n",
"line" : 3899}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " Interval is open to the right (last element is not included)\n",
"line" : 3900}
]
}
,
{
"name" : "Until(alias pred,Range,Sentinel) if (isInputRange!(Range))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLazily iterates $(D range) until value $(D sentinel) is found, at\nwhich point it stops.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];\nassert(equal(a.until(7), [1, 2, 4][]));\nassert(equal(a.until(7, OpenRight.no), [1, 2, 4, 7][]));\n----\n \n",
"line" : 3915,
"members" : [
{
"name" : "Until",
"kind" : "struct",
"protection" : "public",
"line" : 3915,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 3916}
,
{
"name" : "_openRight",
"kind" : "variable",
"type" : "OpenRight",
"line" : 3925}
,
{
"name" : "_done",
"kind" : "variable",
"type" : "bool",
"line" : 3926}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 3945}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType!(Range)()",
"line" : 3950}
,
{
"name" : "predSatisfied",
"kind" : "function",
"type" : "bool()",
"line" : 3956}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 3964}
]
}
]
}
,
{
"name" : "until(alias pred = \"a == b\",Range,Sentinel) if (!is(Sentinel == OpenRight))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4014,
"members" : [
{
"name" : "until",
"kind" : "function",
"type" : "Until!(pred,Range,Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = OpenRight.yes)",
"comment" : " Ditto\n",
"line" : 4014}
]
}
,
{
"name" : "until(alias pred,Range)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4023,
"members" : [
{
"name" : "until",
"kind" : "function",
"type" : "Until!(pred,Range,void)(Range range, OpenRight openRight = OpenRight.yes)",
"comment" : " Ditto\n",
"line" : 4023}
]
}
,
{
"name" : "startsWith(alias pred = \"a == b\",Range,Ranges...) if (isInputRange!(Range) && Ranges.length > 1 && is(typeof(.startsWith!(pred)(doesThisStart,withOneOfThese[0])) : bool) && is(typeof(.startsWith!(pred)(doesThisStart,withOneOfThese[1..__dollar])) : uint))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the range $(D doesThisStart) starts with $(I any) of the $(D\nwithOneOfThese) ranges or elements, returns 1 if it starts with $(D\nwithOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so\non. If none match, returns 0. In the case where $(D doesThisStart) starts\nwith multiple of the ranges or elements in $(D withOneOfThese), then the\nshortest one matches (if there are two which match which are of the same\nlength (e.g. $(D \"a\") and $(D 'a')), then the left-most of them in the argument\nlist matches).\n\nExample:\n----\nassert(startsWith(\"abc\", \"\"));\nassert(startsWith(\"abc\", \"a\"));\nassert(!startsWith(\"abc\", \"b\"));\nassert(startsWith(\"abc\", 'a', \"b\") == 1);\nassert(startsWith(\"abc\", \"b\", \"a\") == 2);\nassert(startsWith(\"abc\", \"a\", \"a\") == 1);\nassert(startsWith(\"abc\", \"ab\", \"a\") == 2);\nassert(startsWith(\"abc\", \"x\", \"a\", \"b\") == 2);\nassert(startsWith(\"abc\", \"x\", \"aa\", \"ab\") == 3);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"a\", \"sab\") == 3);\n----\n \n",
"line" : 4068,
"members" : [
{
"name" : "startsWith",
"kind" : "function",
"type" : "uint(Range doesThisStart, Ranges withOneOfThese)",
"comment" : "\nIf the range $(D doesThisStart) starts with $(I any) of the $(D\nwithOneOfThese) ranges or elements, returns 1 if it starts with $(D\nwithOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so\non. If none match, returns 0. In the case where $(D doesThisStart) starts\nwith multiple of the ranges or elements in $(D withOneOfThese), then the\nshortest one matches (if there are two which match which are of the same\nlength (e.g. $(D \"a\") and $(D 'a')), then the left-most of them in the argument\nlist matches).\n\nExample:\n----\nassert(startsWith(\"abc\", \"\"));\nassert(startsWith(\"abc\", \"a\"));\nassert(!startsWith(\"abc\", \"b\"));\nassert(startsWith(\"abc\", 'a', \"b\") == 1);\nassert(startsWith(\"abc\", \"b\", \"a\") == 2);\nassert(startsWith(\"abc\", \"a\", \"a\") == 1);\nassert(startsWith(\"abc\", \"ab\", \"a\") == 2);\nassert(startsWith(\"abc\", \"x\", \"a\", \"b\") == 2);\nassert(startsWith(\"abc\", \"x\", \"aa\", \"ab\") == 3);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"a\", \"sab\") == 3);\n----\n \n",
"line" : 4068}
]
}
,
{
"name" : "startsWith(alias pred = \"a == b\",R1,R2) if (isInputRange!(R1) && isInputRange!(R2) && is(typeof(binaryFun!(pred)(doesThisStart.front,withThis.front)) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4138,
"members" : [
{
"name" : "startsWith",
"kind" : "function",
"type" : "bool(R1 doesThisStart, R2 withThis)",
"comment" : " Ditto\n",
"line" : 4138}
]
}
,
{
"name" : "startsWith(alias pred = \"a == b\",R,E) if (isInputRange!(R) && is(typeof(binaryFun!(pred)(doesThisStart.front,withThis)) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4193,
"members" : [
{
"name" : "startsWith",
"kind" : "function",
"type" : "bool(R doesThisStart, E withThis)",
"comment" : " Ditto\n",
"line" : 4193}
]
}
,
{
"name" : "skipOver(alias pred = \"a == b\",R1,R2) if (is(typeof(binaryFun!(pred)(r1.front,r2.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf $(D startsWith(r1, r2)), consume the corresponding elements off $(D\nr1) and return $(D true). Otherwise, leave $(D r1) unchanged and\nreturn $(D false).\n \n",
"line" : 4273,
"members" : [
{
"name" : "skipOver",
"kind" : "function",
"type" : "bool(ref R1 r1, R2 r2)",
"comment" : "\nIf $(D startsWith(r1, r2)), consume the corresponding elements off $(D\nr1) and return $(D true). Otherwise, leave $(D r1) unchanged and\nreturn $(D false).\n \n",
"line" : 4273}
]
}
,
{
"name" : "skipOver(alias pred = \"a == b\",R,E) if (is(typeof(binaryFun!(pred)(r.front,e))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nChecks whether a range starts with an element, and if so, consume that\nelement off $(D r) and return $(D true). Otherwise, leave $(D r)\nunchanged and return $(D false).\n \n",
"line" : 4306,
"members" : [
{
"name" : "skipOver",
"kind" : "function",
"type" : "bool(ref R r, E e)",
"comment" : "\nChecks whether a range starts with an element, and if so, consume that\nelement off $(D r) and return $(D true). Otherwise, leave $(D r)\nunchanged and return $(D false).\n \n",
"line" : 4306}
]
}
,
{
"name" : "skipAll(alias pred = \"a == b\",R,Es...)",
"kind" : "template",
"protection" : "public",
"line" : 4333,
"members" : [
{
"name" : "skipAll",
"kind" : "function",
"type" : "void(ref R r, Es es)",
"line" : 4333}
]
}
,
{
"name" : "endsWith(alias pred = \"a == b\",Range,Ranges...) if (isInputRange!(Range) && Ranges.length > 1 && is(typeof(.endsWith!(pred)(doesThisEnd,withOneOfThese[0])) : bool) && is(typeof(.endsWith!(pred)(doesThisEnd,withOneOfThese[1..__dollar])) : uint))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe reciprocal of $(D startsWith).\n\nExample:\n----\nassert(endsWith(\"abc\", \"\"));\nassert(!endsWith(\"abc\", \"b\"));\nassert(endsWith(\"abc\", \"a\", 'c') == 2);\nassert(endsWith(\"abc\", \"c\", \"a\") == 1);\nassert(endsWith(\"abc\", \"c\", \"c\") == 1);\nassert(endsWith(\"abc\", \"bc\", \"c\") == 2);\nassert(endsWith(\"abc\", \"x\", \"c\", \"b\") == 2);\nassert(endsWith(\"abc\", \"x\", \"aa\", \"bc\") == 3);\nassert(endsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(endsWith(\"abc\", \"x\", \"aaa\", 'c', \"sab\") == 3);\n----\n \n",
"line" : 4375,
"members" : [
{
"name" : "endsWith",
"kind" : "function",
"type" : "uint(Range doesThisEnd, Ranges withOneOfThese)",
"comment" : "\nThe reciprocal of $(D startsWith).\n\nExample:\n----\nassert(endsWith(\"abc\", \"\"));\nassert(!endsWith(\"abc\", \"b\"));\nassert(endsWith(\"abc\", \"a\", 'c') == 2);\nassert(endsWith(\"abc\", \"c\", \"a\") == 1);\nassert(endsWith(\"abc\", \"c\", \"c\") == 1);\nassert(endsWith(\"abc\", \"bc\", \"c\") == 2);\nassert(endsWith(\"abc\", \"x\", \"c\", \"b\") == 2);\nassert(endsWith(\"abc\", \"x\", \"aa\", \"bc\") == 3);\nassert(endsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(endsWith(\"abc\", \"x\", \"aaa\", 'c', \"sab\") == 3);\n----\n \n",
"line" : 4375}
]
}
,
{
"name" : "endsWith(alias pred = \"a == b\",R1,R2) if (isInputRange!(R1) && isInputRange!(R2) && is(typeof(binaryFun!(pred)(doesThisEnd.back,withThis.back)) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4443,
"members" : [
{
"name" : "endsWith",
"kind" : "function",
"type" : "bool(R1 doesThisEnd, R2 withThis)",
"comment" : " Ditto\n",
"line" : 4443}
]
}
,
{
"name" : "endsWith(alias pred = \"a == b\",R,E) if (isInputRange!(R) && is(typeof(binaryFun!(pred)(doesThisEnd.back,withThis)) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4497,
"members" : [
{
"name" : "endsWith",
"kind" : "function",
"type" : "bool(R doesThisEnd, E withThis)",
"comment" : " Ditto\n",
"line" : 4497}
]
}
,
{
"name" : "commonPrefix(alias pred = \"a == b\",R1,R2) if (isForwardRange!(R1) && isForwardRange!(R2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the common prefix of two ranges. Example:\n\n----\nassert(commonPrefix(\"hello, world\", \"hello, there\") == \"hello, \");\n----\n\nThe type of the result is the same as $(D takeExactly(r1, n)), where\n$(D n) is the number of elements that both ranges start with.\n \n",
"line" : 4597,
"members" : [
{
"name" : "commonPrefix",
"kind" : "function",
"type" : "(R1 r1, R2 r2)",
"comment" : "\nReturns the common prefix of two ranges. Example:\n\n----\nassert(commonPrefix(\"hello, world\", \"hello, there\") == \"hello, \");\n----\n\nThe type of the result is the same as $(D takeExactly(r1, n)), where\n$(D n) is the number of elements that both ranges start with.\n \n",
"line" : 4597}
]
}
,
{
"name" : "findAdjacent(alias pred = \"a == b\",Range) if (isForwardRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAdvances $(D r) until it finds the first two adjacent elements $(D a),\n$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)\nevaluations of $(D pred). See also $(WEB\nsgi.com\/tech\/stl\/adjacent_find.html, STL's adjacent_find).\n\nExample:\n----\nint[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];\nauto r = findAdjacent(a);\nassert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);\np = findAdjacent!(\"a < b\")(a);\nassert(p == [ 7, 8, 9 ]);\n----\n",
"line" : 4651,
"members" : [
{
"name" : "findAdjacent",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nAdvances $(D r) until it finds the first two adjacent elements $(D a),\n$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)\nevaluations of $(D pred). See also $(WEB\nsgi.com\/tech\/stl\/adjacent_find.html, STL's adjacent_find).\n\nExample:\n----\nint[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];\nauto r = findAdjacent(a);\nassert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);\np = findAdjacent!(\"a < b\")(a);\nassert(p == [ 7, 8, 9 ]);\n----\n",
"line" : 4651}
]
}
,
{
"name" : "findAmong(alias pred = \"a == b\",Range1,Range2) if (isInputRange!(Range1) && isForwardRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAdvances $(D seq) by calling $(D seq.popFront) until either $(D\nfind!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes\nempty. Performs $(BIGOH seq.length * choices.length) evaluations of\n$(D pred). See also $(WEB sgi.com\/tech\/stl\/find_first_of.html, STL's\nfind_first_of).\n\nExample:\n----\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 3, 1, 2 ];\nassert(findAmong(a, b) == a[2 .. $]);\n----\n",
"line" : 4700,
"members" : [
{
"name" : "findAmong",
"kind" : "function",
"type" : "Range1(Range1 seq, Range2 choices)",
"comment" : "\nAdvances $(D seq) by calling $(D seq.popFront) until either $(D\nfind!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes\nempty. Performs $(BIGOH seq.length * choices.length) evaluations of\n$(D pred). See also $(WEB sgi.com\/tech\/stl\/find_first_of.html, STL's\nfind_first_of).\n\nExample:\n----\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 3, 1, 2 ];\nassert(findAmong(a, b) == a[2 .. $]);\n----\n",
"line" : 4700}
]
}
,
{
"name" : "count(alias pred = \"a == b\",Range,E) if (isInputRange!(Range) && is(typeof(binaryFun!(pred)(r.front,value)) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe first version counts the number of elements $(D x) in $(D r) for\nwhich $(D pred(x, value)) is $(D true). $(D pred) defaults to\nequality. Performs $(BIGOH r.length) evaluations of $(D pred).\n\nThe second version returns the number of times $(D needle) occurs in\n$(D haystack). Throws an exception if $(D needle.empty), as the _count\nof the empty range in any range would be infinite. Overlapped counts\nare not considered, for example $(D count(\"aaa\", \"aa\")) is $(D 1), not\n$(D 2).\n\nThe third version counts the elements for which $(D pred(x)) is $(D\ntrue). Performs $(BIGOH r.length) evaluations of $(D pred).\n\nExample:\n----\n\/\/ count elements in range\nint[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];\nassert(count(a, 2) == 3);\nassert(count!(\"a > b\")(a, 2) == 5);\n\/\/ count range in range\nassert(count(\"abcadfabf\", \"ab\") == 2);\nassert(count(\"ababab\", \"abab\") == 1);\nassert(count(\"ababab\", \"abx\") == 0);\n\/\/ count predicate in range\nassert(count!(\"a > 1\")(a) == 8);\n----\n",
"line" : 4750,
"members" : [
{
"name" : "count",
"kind" : "function",
"type" : "size_t(Range r, E value)",
"comment" : "\nThe first version counts the number of elements $(D x) in $(D r) for\nwhich $(D pred(x, value)) is $(D true). $(D pred) defaults to\nequality. Performs $(BIGOH r.length) evaluations of $(D pred).\n\nThe second version returns the number of times $(D needle) occurs in\n$(D haystack). Throws an exception if $(D needle.empty), as the _count\nof the empty range in any range would be infinite. Overlapped counts\nare not considered, for example $(D count(\"aaa\", \"aa\")) is $(D 1), not\n$(D 2).\n\nThe third version counts the elements for which $(D pred(x)) is $(D\ntrue). Performs $(BIGOH r.length) evaluations of $(D pred).\n\nExample:\n----\n\/\/ count elements in range\nint[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];\nassert(count(a, 2) == 3);\nassert(count!(\"a > b\")(a, 2) == 5);\n\/\/ count range in range\nassert(count(\"abcadfabf\", \"ab\") == 2);\nassert(count(\"ababab\", \"abab\") == 1);\nassert(count(\"ababab\", \"abx\") == 0);\n\/\/ count predicate in range\nassert(count!(\"a > 1\")(a) == 8);\n----\n",
"line" : 4750}
]
}
,
{
"name" : "count(alias pred = \"a == b\",R1,R2) if (isInputRange!(R1) && isForwardRange!(R2) && is(typeof(binaryFun!(pred)(haystack,needle)) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4784,
"members" : [
{
"name" : "count",
"kind" : "function",
"type" : "size_t(R1 haystack, R2 needle)",
"comment" : " Ditto\n",
"line" : 4784}
]
}
,
{
"name" : "count(alias pred = \"true\",Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4803,
"members" : [
{
"name" : "count",
"kind" : "function",
"type" : "size_t(Range r)",
"comment" : " Ditto\n",
"line" : 4803}
]
}
,
{
"name" : "balancedParens(Range,E) if (isInputRange!(Range) && is(typeof(r.front == lPar)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nChecks whether $(D r) has \"balanced parentheses\", i.e. all instances\nof $(D lPar) are closed by corresponding instances of $(D rPar). The\nparameter $(D maxNestingLevel) controls the nesting level allowed. The\nmost common uses are the default or $(D 0). In the latter case, no\nnesting is allowed.\n\nExample:\n----\nauto s = \"1 + (2 * (3 + 1 \/ 2)\";\nassert(!balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) \/ 2)\";\nassert(balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) \/ 2)\";\nassert(!balancedParens(s, '(', ')', 1));\ns = \"1 + (2 * 3 + 1) \/ (2 - 5)\";\nassert(balancedParens(s, '(', ')', 1));\n----\n",
"line" : 4842,
"members" : [
{
"name" : "balancedParens",
"kind" : "function",
"type" : "bool(Range r, E lPar, E rPar, size_t maxNestingLevel = size_t.max)",
"comment" : "\nChecks whether $(D r) has \"balanced parentheses\", i.e. all instances\nof $(D lPar) are closed by corresponding instances of $(D rPar). The\nparameter $(D maxNestingLevel) controls the nesting level allowed. The\nmost common uses are the default or $(D 0). In the latter case, no\nnesting is allowed.\n\nExample:\n----\nauto s = \"1 + (2 * (3 + 1 \/ 2)\";\nassert(!balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) \/ 2)\";\nassert(balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) \/ 2)\";\nassert(!balancedParens(s, '(', ')', 1));\ns = \"1 + (2 * 3 + 1) \/ (2 - 5)\";\nassert(balancedParens(s, '(', ')', 1));\n----\n",
"line" : 4842}
]
}
,
{
"name" : "equal(alias pred = \"a == b\",Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2) && is(typeof(binaryFun!(pred)(r1.front,r2.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if the two ranges compare equal element\nfor element, according to binary predicate $(D pred). The ranges may\nhave different element types, as long as $(D pred(a, b)) evaluates to\n$(D bool) for $(D a) in $(D r1) and $(D b) in $(D r2). Performs\n$(BIGOH min(r1.length, r2.length)) evaluations of $(D pred). See also\n$(WEB sgi.com\/tech\/stl\/_equal.html, STL's _equal).\n\nExample:\n----\nint[] a = [ 1, 2, 4, 3 ];\nassert(!equal(a, a[1..$]));\nassert(equal(a, a));\n\n\/\/ different types\ndouble[] b = [ 1.0, 2, 4, 3];\nassert(!equal(a, b[1..$]));\nassert(equal(a, b));\n\n\/\/ predicated: ensure that two vectors are approximately equal\ndouble[] c = [ 1.005, 2, 4, 3];\nassert(equal!(approxEqual)(b, c));\n----\n",
"line" : 4900,
"members" : [
{
"name" : "equal",
"kind" : "function",
"type" : "bool(Range1 r1, Range2 r2)",
"comment" : "\nReturns $(D true) if and only if the two ranges compare equal element\nfor element, according to binary predicate $(D pred). The ranges may\nhave different element types, as long as $(D pred(a, b)) evaluates to\n$(D bool) for $(D a) in $(D r1) and $(D b) in $(D r2). Performs\n$(BIGOH min(r1.length, r2.length)) evaluations of $(D pred). See also\n$(WEB sgi.com\/tech\/stl\/_equal.html, STL's _equal).\n\nExample:\n----\nint[] a = [ 1, 2, 4, 3 ];\nassert(!equal(a, a[1..$]));\nassert(equal(a, a));\n\n\/\/ different types\ndouble[] b = [ 1.0, 2, 4, 3];\nassert(!equal(a, b[1..$]));\nassert(equal(a, b));\n\n\/\/ predicated: ensure that two vectors are approximately equal\ndouble[] c = [ 1.005, 2, 4, 3];\nassert(equal!(approxEqual)(b, c));\n----\n",
"line" : 4900}
]
}
,
{
"name" : "cmp(alias pred = \"a < b\",R1,R2) if (isInputRange!(R1) && isInputRange!(R2) && !(isSomeString!(R1) && isSomeString!(R2)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nPerforms three-way lexicographical comparison on two input ranges\naccording to predicate $(D pred). Iterating $(D r1) and $(D r2) in\nlockstep, $(D cmp) compares each element $(D e1) of $(D r1) with the\ncorresponding element $(D e2) in $(D r2). If $(D binaryFun!pred(e1,\ne2)), $(D cmp) returns a negative value. If $(D binaryFun!pred(e2,\ne1)), $(D cmp) returns a positive value. If one of the ranges has been\nfinished, $(D cmp) returns a negative value if $(D r1) has fewer\nelements than $(D r2), a positive value if $(D r1) has more elements\nthan $(D r2), and $(D 0) if the ranges have the same number of\nelements.\n\nIf the ranges are strings, $(D cmp) performs UTF decoding\nappropriately and compares the ranges one code point at a time.\n",
"line" : 4949,
"members" : [
{
"name" : "cmp",
"kind" : "function",
"type" : "int(R1 r1, R2 r2)",
"comment" : "\nPerforms three-way lexicographical comparison on two input ranges\naccording to predicate $(D pred). Iterating $(D r1) and $(D r2) in\nlockstep, $(D cmp) compares each element $(D e1) of $(D r1) with the\ncorresponding element $(D e2) in $(D r2). If $(D binaryFun!pred(e1,\ne2)), $(D cmp) returns a negative value. If $(D binaryFun!pred(e2,\ne1)), $(D cmp) returns a positive value. If one of the ranges has been\nfinished, $(D cmp) returns a negative value if $(D r1) has fewer\nelements than $(D r2), a positive value if $(D r1) has more elements\nthan $(D r2), and $(D 0) if the ranges have the same number of\nelements.\n\nIf the ranges are strings, $(D cmp) performs UTF decoding\nappropriately and compares the ranges one code point at a time.\n",
"line" : 4949}
]
}
,
{
"name" : "cmp(alias pred = \"a < b\",R1,R2) if (isSomeString!(R1) && isSomeString!(R2))",
"kind" : "template",
"protection" : "public",
"line" : 4963,
"members" : [
{
"name" : "cmp",
"kind" : "function",
"type" : "int(R1 r1, R2 r2)",
"line" : 4963}
]
}
,
{
"name" : "MinType(T...)",
"kind" : "template",
"protection" : "public",
"line" : 5058,
"members" : [
]
}
,
{
"name" : "min(T1,T2,T...) if (is(typeof(a < b)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the minimum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n",
"line" : 5090,
"members" : [
{
"name" : "min",
"kind" : "function",
"type" : "MinType!(T1,T2,T)(T1 a, T2 b, T xs)",
"comment" : "\nReturns the minimum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n",
"line" : 5090}
]
}
,
{
"name" : "MaxType(T...)",
"kind" : "template",
"protection" : "public",
"line" : 5145,
"members" : [
]
}
,
{
"name" : "max(T1,T2,T...) if (is(typeof(a < b)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the maximum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n\nExample:\n----\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = max(a, b);\nassert(is(typeof(d) == int));\nassert(d == 6);\nauto e = min(a, b, c);\nassert(is(typeof(e) == double));\nassert(e == 2);\n----\n",
"line" : 5181,
"members" : [
{
"name" : "max",
"kind" : "function",
"type" : "MaxType!(T1,T2,T)(T1 a, T2 b, T xs)",
"comment" : "\nReturns the maximum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n\nExample:\n----\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = max(a, b);\nassert(is(typeof(d) == int));\nassert(d == 6);\nauto e = min(a, b, c);\nassert(is(typeof(e) == double));\nassert(e == 2);\n----\n",
"line" : 5181}
]
}
,
{
"name" : "minCount(alias pred = \"a < b\",Range)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the minimum element of a range together with the number of\noccurrences. The function can actually be used for counting the\nmaximum or any other ordering predicate (that's why $(D maxCount) is\nnot provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n\/\/ Minimum is 1 and occurs 3 times\nassert(minCount(a) == tuple(1, 3));\n\/\/ Maximum is 4 and occurs 2 times\nassert(minCount!(\"a > b\")(a) == tuple(4, 2));\n----\n \n",
"line" : 5251,
"members" : [
{
"name" : "minCount",
"kind" : "function",
"type" : "Tuple!(ElementType!(Range),size_t)(Range range)",
"comment" : "\nReturns the minimum element of a range together with the number of\noccurrences. The function can actually be used for counting the\nmaximum or any other ordering predicate (that's why $(D maxCount) is\nnot provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n\/\/ Minimum is 1 and occurs 3 times\nassert(minCount(a) == tuple(1, 3));\n\/\/ Maximum is 4 and occurs 2 times\nassert(minCount!(\"a > b\")(a) == tuple(4, 2));\n----\n \n",
"line" : 5251}
]
}
,
{
"name" : "minPos(alias pred = \"a < b\",Range)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the position of the minimum element of forward range $(D\nrange), i.e. a subrange of $(D range) starting at the position of its\nsmallest element and with the same ending as $(D range). The function\ncan actually be used for counting the maximum or any other ordering\npredicate (that's why $(D maxPos) is not provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n\/\/ Minimum is 1 and first occurs in position 3\nassert(minPos(a) == [ 1, 2, 4, 1, 1, 2 ]);\n\/\/ Maximum is 4 and first occurs in position 2\nassert(minPos!(\"a > b\")(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);\n----\n \n",
"line" : 5302,
"members" : [
{
"name" : "minPos",
"kind" : "function",
"type" : "Range(Range range)",
"comment" : "\nReturns the position of the minimum element of forward range $(D\nrange), i.e. a subrange of $(D range) starting at the position of its\nsmallest element and with the same ending as $(D range). The function\ncan actually be used for counting the maximum or any other ordering\npredicate (that's why $(D maxPos) is not provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n\/\/ Minimum is 1 and first occurs in position 3\nassert(minPos(a) == [ 1, 2, 4, 1, 1, 2 ]);\n\/\/ Maximum is 4 and first occurs in position 2\nassert(minPos!(\"a > b\")(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);\n----\n \n",
"line" : 5302}
]
}
,
{
"name" : "mismatch(alias pred = \"a == b\",Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSequentially compares elements in $(D r1) and $(D r2) in lockstep, and\nstops at the first mismatch (according to $(D pred), by default\nequality). Returns a tuple with the reduced ranges that start with the\ntwo mismatched values. Performs $(BIGOH min(r1.length, r2.length))\nevaluations of $(D pred). See also $(WEB\nsgi.com\/tech\/stl\/_mismatch.html, STL's _mismatch).\n\nExample:\n----\nint[]    x = [ 1,  5, 2, 7,   4, 3 ];\ndouble[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];\nauto m = mismatch(x, y);\nassert(m[0] == x[3 .. $]);\nassert(m[1] == y[3 .. $]);\n----\n",
"line" : 5347,
"members" : [
{
"name" : "mismatch",
"kind" : "function",
"type" : "Tuple!(Range1,Range2)(Range1 r1, Range2 r2)",
"comment" : "\nSequentially compares elements in $(D r1) and $(D r2) in lockstep, and\nstops at the first mismatch (according to $(D pred), by default\nequality). Returns a tuple with the reduced ranges that start with the\ntwo mismatched values. Performs $(BIGOH min(r1.length, r2.length))\nevaluations of $(D pred). See also $(WEB\nsgi.com\/tech\/stl\/_mismatch.html, STL's _mismatch).\n\nExample:\n----\nint[]    x = [ 1,  5, 2, 7,   4, 3 ];\ndouble[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];\nauto m = mismatch(x, y);\nassert(m[0] == x[3 .. $]);\nassert(m[1] == y[3 .. $]);\n----\n",
"line" : 5347}
]
}
,
{
"name" : "EditOp",
"kind" : "enum",
"protection" : "public",
"comment" : "\nEncodes $(WEB realityinteractive.com\/rgrzywinski\/archives\/000249.html,\nedit operations) necessary to transform one sequence into\nanother. Given sequences $(D s) (source) and $(D t) (target), a\nsequence of $(D EditOp) encodes the steps that need to be taken to\nconvert $(D s) into $(D t). For example, if $(D s = \"cat\") and $(D\n\"cars\"), the minimal sequence that transforms $(D s) into $(D t) is:\nskip two characters, replace 't' with 'r', and insert an 's'. Working\nwith edit operations is useful in applications such as spell-checkers\n(to find the closest word to a given misspelled word), approximate\nsearches, diff-style programs that compute the difference between\nfiles, efficient encoding of patches, DNA sequence analysis, and\nplagiarism detection.\n",
"line" : 5391,
"base" : "char",
"members" : [
{
"name" : "none",
"kind" : "enum member",
"protection" : "public",
"comment" : " Current items are equal; no editing is necessary. \n",
"line" : 5394}
,
{
"name" : "substitute",
"kind" : "enum member",
"protection" : "public",
"comment" : " Substitute current item in target with current item in source. \n",
"line" : 5396}
,
{
"name" : "insert",
"kind" : "enum member",
"protection" : "public",
"comment" : " Insert current item from the source into the target. \n",
"line" : 5398}
,
{
"name" : "remove",
"kind" : "enum member",
"protection" : "public",
"comment" : " Remove current item from the target. \n",
"line" : 5400}
]
}
,
{
"name" : "Levenshtein(Range,alias equals,CostType = size_t)",
"kind" : "struct",
"protection" : "public",
"line" : 5404,
"members" : [
{
"name" : "Levenshtein",
"kind" : "struct",
"protection" : "public",
"line" : 5404,
"members" : [
{
"name" : "deletionIncrement",
"kind" : "function",
"type" : "void(CostType n)",
"line" : 5405}
,
{
"name" : "insertionIncrement",
"kind" : "function",
"type" : "void(CostType n)",
"line" : 5411}
,
{
"name" : "distance",
"kind" : "function",
"type" : "CostType(Range s, Range t)",
"line" : 5417}
,
{
"name" : "path",
"kind" : "function",
"type" : "EditOp[](Range s, Range t)",
"line" : 5449}
,
{
"name" : "path",
"kind" : "function",
"type" : "EditOp[]()",
"line" : 5455}
,
{
"name" : "_deletionIncrement",
"kind" : "variable",
"type" : "CostType",
"line" : 5489}
,
{
"name" : "_insertionIncrement",
"kind" : "variable",
"type" : "CostType",
"line" : 5490}
,
{
"name" : "_substitutionIncrement",
"kind" : "variable",
"type" : "CostType",
"line" : 5491}
,
{
"name" : "_matrix",
"kind" : "variable",
"type" : "CostType[][]",
"line" : 5492}
,
{
"name" : "rows",
"kind" : "variable",
"type" : "size_t",
"line" : 5493}
,
{
"name" : "cols",
"kind" : "variable",
"type" : "size_t",
"line" : 5493}
,
{
"name" : "AllocMatrix",
"kind" : "function",
"type" : "void(size_t r, size_t c)",
"line" : 5495}
,
{
"name" : "InitMatrix",
"kind" : "function",
"type" : "void()",
"line" : 5505}
,
{
"name" : "min_index",
"kind" : "function",
"type" : "uint(CostType i0, CostType i1, CostType i2)",
"line" : 5515}
]
}
]
}
,
{
"name" : "levenshteinDistance(alias equals = \"a == b\",Range1,Range2) if (isForwardRange!(Range1) && isForwardRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the $(WEB wikipedia.org\/wiki\/Levenshtein_distance, Levenshtein\ndistance) between $(D s) and $(D t). The Levenshtein distance computes\nthe minimal amount of edit operations necessary to transform $(D s)\ninto $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D\nequals) and occupies $(BIGOH s.length * t.length) storage.\n\nExample:\n----\nassert(levenshteinDistance(\"cat\", \"rat\") == 1);\nassert(levenshteinDistance(\"parks\", \"spark\") == 2);\nassert(levenshteinDistance(\"kitten\", \"sitting\") == 3);\n\/\/ ignore case\nassert(levenshteinDistance!(\"std.uni.toUpper(a) == std.uni.toUpper(b)\")\n    (\"parks\", \"SPARK\") == 2);\n----\n",
"line" : 5545,
"members" : [
{
"name" : "levenshteinDistance",
"kind" : "function",
"type" : "size_t(Range1 s, Range2 t)",
"comment" : "\nReturns the $(WEB wikipedia.org\/wiki\/Levenshtein_distance, Levenshtein\ndistance) between $(D s) and $(D t). The Levenshtein distance computes\nthe minimal amount of edit operations necessary to transform $(D s)\ninto $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D\nequals) and occupies $(BIGOH s.length * t.length) storage.\n\nExample:\n----\nassert(levenshteinDistance(\"cat\", \"rat\") == 1);\nassert(levenshteinDistance(\"parks\", \"spark\") == 2);\nassert(levenshteinDistance(\"kitten\", \"sitting\") == 3);\n\/\/ ignore case\nassert(levenshteinDistance!(\"std.uni.toUpper(a) == std.uni.toUpper(b)\")\n    (\"parks\", \"SPARK\") == 2);\n----\n",
"line" : 5545}
]
}
,
{
"name" : "levenshteinDistanceAndPath(alias equals = \"a == b\",Range1,Range2) if (isForwardRange!(Range1) && isForwardRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the Levenshtein distance and the edit path between $(D s) and\n$(D t).\n\nExample:\n---\nstring a = \"Saturday\", b = \"Sunday\";\nauto p = levenshteinDistanceAndPath(a, b);\nassert(p[0] == 3);\nassert(equal(p[1], \"nrrnsnnn\"));\n---\n",
"line" : 5576,
"members" : [
{
"name" : "levenshteinDistanceAndPath",
"kind" : "function",
"type" : "Tuple!(size_t,EditOp[])(Range1 s, Range2 t)",
"comment" : "\nReturns the Levenshtein distance and the edit path between $(D s) and\n$(D t).\n\nExample:\n---\nstring a = \"Saturday\", b = \"Sunday\";\nauto p = levenshteinDistanceAndPath(a, b);\nassert(p[0] == 3);\nassert(equal(p[1], \"nrrnsnnn\"));\n---\n",
"line" : 5576}
]
}
,
{
"name" : "copy(Range1,Range2) if (isInputRange!(Range1) && isOutputRange!(Range2,ElementType!(Range1)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nCopies the content of $(D source) into $(D target) and returns the\nremaining (unfilled) part of $(D target). See also $(WEB\nsgi.com\/tech\/stl\/_copy.html, STL's _copy). If a behavior similar to\n$(WEB sgi.com\/tech\/stl\/copy_backward.html, STL's copy_backward) is\nneeded, use $(D copy(retro(source), retro(target))). See also $(XREF\nrange, retro).\n\nExample:\n----\nint[] a = [ 1, 5 ];\nint[] b = [ 9, 8 ];\nint[] c = new int[a.length + b.length + 10];\nauto d = copy(b, copy(a, c));\nassert(c[0 .. a.length + b.length] == a ~ b);\nassert(d.length == 10);\n----\n\nAs long as the target range elements support assignment from source\nrange elements, different types of ranges are accepted.\n\nExample:\n----\nfloat[] a = [ 1.0f, 5 ];\ndouble[] b = new double[a.length];\nauto d = copy(a, b);\n----\n\nTo copy at most $(D n) elements from range $(D a) to range $(D b), you\nmay want to use $(D copy(take(a, n), b)). To copy those elements from\nrange $(D a) that satisfy predicate $(D pred) to range $(D b), you may\nwant to use $(D copy(filter!(pred)(a), b)).\n\nExample:\n----\nint[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];\nauto b = new int[a.length];\nauto c = copy(filter!(\"(a & 1) == 1\")(a), b);\nassert(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);\n----\n\n \n",
"line" : 5645,
"members" : [
{
"name" : "copy",
"kind" : "function",
"type" : "Range2(Range1 source, Range2 target)",
"comment" : "\nCopies the content of $(D source) into $(D target) and returns the\nremaining (unfilled) part of $(D target). See also $(WEB\nsgi.com\/tech\/stl\/_copy.html, STL's _copy). If a behavior similar to\n$(WEB sgi.com\/tech\/stl\/copy_backward.html, STL's copy_backward) is\nneeded, use $(D copy(retro(source), retro(target))). See also $(XREF\nrange, retro).\n\nExample:\n----\nint[] a = [ 1, 5 ];\nint[] b = [ 9, 8 ];\nint[] c = new int[a.length + b.length + 10];\nauto d = copy(b, copy(a, c));\nassert(c[0 .. a.length + b.length] == a ~ b);\nassert(d.length == 10);\n----\n\nAs long as the target range elements support assignment from source\nrange elements, different types of ranges are accepted.\n\nExample:\n----\nfloat[] a = [ 1.0f, 5 ];\ndouble[] b = new double[a.length];\nauto d = copy(a, b);\n----\n\nTo copy at most $(D n) elements from range $(D a) to range $(D b), you\nmay want to use $(D copy(take(a, n), b)). To copy those elements from\nrange $(D a) that satisfy predicate $(D pred) to range $(D b), you may\nwant to use $(D copy(filter!(pred)(a), b)).\n\nExample:\n----\nint[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];\nauto b = new int[a.length];\nauto c = copy(filter!(\"(a & 1) == 1\")(a), b);\nassert(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);\n----\n\n \n",
"line" : 5645}
]
}
,
{
"name" : "swapRanges(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2) && hasSwappableElements!(Range1) && hasSwappableElements!(Range2) && is(ElementType!(Range1) == ElementType!(Range2)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSwaps all elements of $(D r1) with successive elements in $(D r2).\nReturns a tuple containing the remainder portions of $(D r1) and $(D\nr2) that were not swapped (one of them will be empty). The ranges may\nbe of different types but must have the same element type and support\nswapping.\n\nExample:\n----\nint[] a = [ 100, 101, 102, 103 ];\nint[] b = [ 0, 1, 2, 3 ];\nauto c = swapRanges(a[1 .. 3], b[2 .. 4]);\nassert(c[0].empty && c[1].empty);\nassert(a == [ 100, 2, 3, 103 ]);\nassert(b == [ 0, 1, 101, 102 ]);\n----\n",
"line" : 5746,
"members" : [
{
"name" : "swapRanges",
"kind" : "function",
"type" : "Tuple!(Range1,Range2)(Range1 r1, Range2 r2)",
"comment" : "\nSwaps all elements of $(D r1) with successive elements in $(D r2).\nReturns a tuple containing the remainder portions of $(D r1) and $(D\nr2) that were not swapped (one of them will be empty). The ranges may\nbe of different types but must have the same element type and support\nswapping.\n\nExample:\n----\nint[] a = [ 100, 101, 102, 103 ];\nint[] b = [ 0, 1, 2, 3 ];\nauto c = swapRanges(a[1 .. 3], b[2 .. 4]);\nassert(c[0].empty && c[1].empty);\nassert(a == [ 100, 2, 3, 103 ]);\nassert(b == [ 0, 1, 101, 102 ]);\n----\n",
"line" : 5746}
]
}
,
{
"name" : "reverse(Range) if (isBidirectionalRange!(Range) && hasSwappableElements!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReverses $(D r) in-place.  Performs $(D r.length \/ 2) evaluations of $(D\nswap). See also $(WEB sgi.com\/tech\/stl\/_reverse.html, STL's _reverse).\n\nExample:\n----\nint[] arr = [ 1, 2, 3 ];\nreverse(arr);\nassert(arr == [ 3, 2, 1 ]);\n----\n",
"line" : 5782,
"members" : [
{
"name" : "reverse",
"kind" : "function",
"type" : "void(Range r)",
"comment" : "\nReverses $(D r) in-place.  Performs $(D r.length \/ 2) evaluations of $(D\nswap). See also $(WEB sgi.com\/tech\/stl\/_reverse.html, STL's _reverse).\n\nExample:\n----\nint[] arr = [ 1, 2, 3 ];\nreverse(arr);\nassert(arr == [ 3, 2, 1 ]);\n----\n",
"line" : 5782}
]
}
,
{
"name" : "reverse(Char) if (isNarrowString!(Char[]) && !is(Char == const) && !is(Char == immutable))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReverses $(D r) in-place, where $(D r) is a narrow string (having\nelements of type $(D char) or $(D wchar)). UTF sequences consisting of\nmultiple code units are preserved properly.\n\nExample:\n----\nchar[] arr = \"hello\\U00010143\\u0100\\U00010143\".dup;\nreverse(arr);\nassert(arr == \"\\U00010143\\u0100\\U00010143olleh\");\n----\n",
"line" : 5823,
"members" : [
{
"name" : "reverse",
"kind" : "function",
"type" : "void(Char[] s)",
"comment" : "\nReverses $(D r) in-place, where $(D r) is a narrow string (having\nelements of type $(D char) or $(D wchar)). UTF sequences consisting of\nmultiple code units are preserved properly.\n\nExample:\n----\nchar[] arr = \"hello\\U00010143\\u0100\\U00010143\".dup;\nreverse(arr);\nassert(arr == \"\\U00010143\\u0100\\U00010143olleh\");\n----\n",
"line" : 5823}
]
}
,
{
"name" : "bringToFront(Range1,Range2) if (isInputRange!(Range1) && isForwardRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe $(D bringToFront) function has considerable flexibility and\nusefulness. It can rotate elements in one buffer left or right, swap\nbuffers of equal length, and even move elements across disjoint\nbuffers of different types and different lengths.\n\n$(D bringToFront) takes two ranges $(D front) and $(D back), which may\nbe of different types. Considering the concatenation of $(D front) and\n$(D back) one unified range, $(D bringToFront) rotates that unified\nrange such that all elements in $(D back) are brought to the beginning\nof the unified range. The relative ordering of elements in $(D front)\nand $(D back), respectively, remains unchanged.\n\nThe simplest use of $(D bringToFront) is for rotating elements in a\nbuffer. For example:\n\n----\nauto arr = [4, 5, 6, 7, 1, 2, 3];\nbringToFront(arr[0 .. 4], arr[4 .. $]);\nassert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);\n----\n\nThe $(D front) range may actually \"step over\" the $(D back)\nrange. This is very useful with forward ranges that cannot compute\ncomfortably right-bounded subranges like $(D arr[0 .. 4]) above. In\nthe example below, $(D r2) is a right subrange of $(D r1).\n\n----\nauto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);\nauto r1 = list[];\nauto r2 = list[]; popFrontN(r2, 4);\nassert(equal(r2, [ 1, 2, 3 ]));\nbringToFront(r1, r2);\nassert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));\n----\n\nElements can be swapped across ranges of different types:\n\n----\nauto list = SList!(int)(4, 5, 6, 7);\nauto vec = [ 1, 2, 3 ];\nbringToFront(list[], vec);\nassert(equal(list[], [ 1, 2, 3, 4 ]));\nassert(equal(vec, [ 5, 6, 7 ]));\n----\n\nPerforms $(BIGOH max(front.length, back.length)) evaluations of $(D\nswap). See also $(WEB sgi.com\/tech\/stl\/_rotate.html, STL's rotate).\n\nPreconditions:\n\nEither $(D front) and $(D back) are disjoint, or $(D back) is\nreachable from $(D front) and $(D front) is not reachable from $(D\nback).\n\nReturns:\n\nThe number of elements brought to the front, i.e., the length of $(D\nback).\n",
"line" : 5923,
"members" : [
{
"name" : "bringToFront",
"kind" : "function",
"type" : "size_t(Range1 front, Range2 back)",
"comment" : "\nThe $(D bringToFront) function has considerable flexibility and\nusefulness. It can rotate elements in one buffer left or right, swap\nbuffers of equal length, and even move elements across disjoint\nbuffers of different types and different lengths.\n\n$(D bringToFront) takes two ranges $(D front) and $(D back), which may\nbe of different types. Considering the concatenation of $(D front) and\n$(D back) one unified range, $(D bringToFront) rotates that unified\nrange such that all elements in $(D back) are brought to the beginning\nof the unified range. The relative ordering of elements in $(D front)\nand $(D back), respectively, remains unchanged.\n\nThe simplest use of $(D bringToFront) is for rotating elements in a\nbuffer. For example:\n\n----\nauto arr = [4, 5, 6, 7, 1, 2, 3];\nbringToFront(arr[0 .. 4], arr[4 .. $]);\nassert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);\n----\n\nThe $(D front) range may actually \"step over\" the $(D back)\nrange. This is very useful with forward ranges that cannot compute\ncomfortably right-bounded subranges like $(D arr[0 .. 4]) above. In\nthe example below, $(D r2) is a right subrange of $(D r1).\n\n----\nauto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);\nauto r1 = list[];\nauto r2 = list[]; popFrontN(r2, 4);\nassert(equal(r2, [ 1, 2, 3 ]));\nbringToFront(r1, r2);\nassert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));\n----\n\nElements can be swapped across ranges of different types:\n\n----\nauto list = SList!(int)(4, 5, 6, 7);\nauto vec = [ 1, 2, 3 ];\nbringToFront(list[], vec);\nassert(equal(list[], [ 1, 2, 3, 4 ]));\nassert(equal(vec, [ 5, 6, 7 ]));\n----\n\nPerforms $(BIGOH max(front.length, back.length)) evaluations of $(D\nswap). See also $(WEB sgi.com\/tech\/stl\/_rotate.html, STL's rotate).\n\nPreconditions:\n\nEither $(D front) and $(D back) are disjoint, or $(D back) is\nreachable from $(D front) and $(D front) is not reachable from $(D\nback).\n\nReturns:\n\nThe number of elements brought to the front, i.e., the length of $(D\nback).\n",
"line" : 5923}
]
}
,
{
"name" : "SwapStrategy",
"kind" : "enum",
"protection" : "public",
"comment" : "\nDefines the swapping strategy for algorithms that need to swap\nelements in a range (such as partition and sort). The strategy\nconcerns the swapping of elements that are not the core concern of the\nalgorithm. For example, consider an algorithm that sorts $(D [ \"abc\",\n\"b\", \"aBc\" ]) according to $(D toUpper(a) < toUpper(b)). That\nalgorithm might choose to swap the two equivalent strings $(D \"abc\")\nand $(D \"aBc\"). That does not affect the sorting since both $(D [\n\"abc\", \"aBc\", \"b\" ]) and $(D [ \"aBc\", \"abc\", \"b\" ]) are valid\noutcomes.\n\nSome situations require that the algorithm must NOT ever change the\nrelative ordering of equivalent elements (in the example above, only\n$(D [ \"abc\", \"aBc\", \"b\" ]) would be the correct result). Such\nalgorithms are called $(B stable). If the ordering algorithm may swap\nequivalent elements discretionarily, the ordering is called $(B\nunstable).\n\nYet another class of algorithms may choose an intermediate tradeoff by\nbeing stable only on a well-defined subrange of the range. There is no\nestablished terminology for such behavior; this library calls it $(B\nsemistable).\n\nGenerally, the $(D stable) ordering strategy may be more costly in\ntime and\/or space than the other two because it imposes additional\nconstraints. Similarly, $(D semistable) may be costlier than $(D\nunstable). As (semi-)stability is not needed very often, the ordering\nalgorithms in this module parameterized by $(D SwapStrategy) all\nchoose $(D SwapStrategy.unstable) as the default.\n",
"line" : 6100,
"base" : "int",
"members" : [
{
"name" : "unstable",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Allows freely swapping of elements as long as the output\n       satisfies the algorithm's requirements.\n    \n",
"line" : 6105}
,
{
"name" : "semistable",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       In algorithms partitioning ranges in two, preserve relative\n       ordering of elements only to the left of the partition point.\n    \n",
"line" : 6110}
,
{
"name" : "stable",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Preserve the relative ordering of elements to the largest\n       extent allowed by the algorithm's requirements.\n    \n",
"line" : 6115}
]
}
,
{
"name" : "remove(SwapStrategy s = SwapStrategy.stable,Range,Offset...) if (isBidirectionalRange!(Range) && hasLength!(Range) && s != SwapStrategy.stable && Offset.length >= 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nEliminates elements at given offsets from $(D range) and returns the\nshortened range. In the simplest call, one element is removed.\n\n----\nint[] a = [ 3, 5, 7, 8 ];\nassert(remove(a, 1) == [ 3, 7, 8 ]);\nassert(a == [ 3, 7, 8, 8 ]);\n----\n\nIn the case above the element at offset $(D 1) is removed and $(D\nremove) returns the range smaller by one element. The original array\nhas remained of the same length because all functions in $(D\nstd.algorithm) only change $(I content), not $(I topology). The value\n$(D 8) is repeated because $(XREF algorithm, move) was invoked to move\nelements around and on integers $(D move) simply copies the source to\nthe destination. To replace $(D a) with the effect of the removal,\nsimply assign $(D a = remove(a, 1)). The slice will be rebound to the\nshorter array and the operation completes with maximal efficiency.\n\nMultiple indices can be passed into $(D remove). In that case,\nelements at the respective indices are all removed. The indices must\nbe passed in increasing order, otherwise an exception occurs.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, 3, 5) ==\n    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);\n----\n\n(Note how all indices refer to slots in the $(I original) array, not\nin the array as it is being progressively shortened.) Finally, any\ncombination of integral offsets and tuples composed of two integral\noffsets can be passed in.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);\n----\n\nIn this case, the slots at positions 1, 3, 4, and 9 are removed from\nthe array. The tuple passes in a range closed to the left and open to\nthe right (consistent with built-in slices), e.g. $(D tuple(3, 5))\nmeans indices $(D 3) and $(D 4) but not $(D 5).\n\nIf the need is to remove some elements in the range but the order of\nthe remaining elements does not have to be preserved, you may want to\npass $(D SwapStrategy.unstable) to $(D remove).\n\n----\nint[] a = [ 0, 1, 2, 3 ];\nassert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);\n----\n\nIn the case above, the element at slot $(D 1) is removed, but replaced\nwith the last element of the range. Taking advantage of the relaxation\nof the stability requirement, $(D remove) moved elements from the end\nof the array over the slots to be removed. This way there is less data\nmovement to be done which improves the execution time of the function.\n\nThe function $(D remove) works on any forward range. The moving\nstrategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==\nSwapStrategy.unstable && isRandomAccessRange!Range &&\nhasLength!Range), then elements are moved from the end of the range\ninto the slots to be filled. In this case, the absolute minimum of\nmoves is performed.)  $(LI Otherwise, if $(D s ==\nSwapStrategy.unstable && isBidirectionalRange!Range &&\nhasLength!Range), then elements are still moved from the end of the\nrange, but time is spent on advancing between slots by repeated calls\nto $(D range.popFront).)  $(LI Otherwise, elements are moved incrementally\ntowards the front of $(D range); a given element is never moved\nseveral times, but more elements are moved than in the previous\ncases.))\n \n",
"line" : 6192,
"members" : [
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Range range, Offset offset)",
"comment" : "\nEliminates elements at given offsets from $(D range) and returns the\nshortened range. In the simplest call, one element is removed.\n\n----\nint[] a = [ 3, 5, 7, 8 ];\nassert(remove(a, 1) == [ 3, 7, 8 ]);\nassert(a == [ 3, 7, 8, 8 ]);\n----\n\nIn the case above the element at offset $(D 1) is removed and $(D\nremove) returns the range smaller by one element. The original array\nhas remained of the same length because all functions in $(D\nstd.algorithm) only change $(I content), not $(I topology). The value\n$(D 8) is repeated because $(XREF algorithm, move) was invoked to move\nelements around and on integers $(D move) simply copies the source to\nthe destination. To replace $(D a) with the effect of the removal,\nsimply assign $(D a = remove(a, 1)). The slice will be rebound to the\nshorter array and the operation completes with maximal efficiency.\n\nMultiple indices can be passed into $(D remove). In that case,\nelements at the respective indices are all removed. The indices must\nbe passed in increasing order, otherwise an exception occurs.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, 3, 5) ==\n    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);\n----\n\n(Note how all indices refer to slots in the $(I original) array, not\nin the array as it is being progressively shortened.) Finally, any\ncombination of integral offsets and tuples composed of two integral\noffsets can be passed in.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);\n----\n\nIn this case, the slots at positions 1, 3, 4, and 9 are removed from\nthe array. The tuple passes in a range closed to the left and open to\nthe right (consistent with built-in slices), e.g. $(D tuple(3, 5))\nmeans indices $(D 3) and $(D 4) but not $(D 5).\n\nIf the need is to remove some elements in the range but the order of\nthe remaining elements does not have to be preserved, you may want to\npass $(D SwapStrategy.unstable) to $(D remove).\n\n----\nint[] a = [ 0, 1, 2, 3 ];\nassert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);\n----\n\nIn the case above, the element at slot $(D 1) is removed, but replaced\nwith the last element of the range. Taking advantage of the relaxation\nof the stability requirement, $(D remove) moved elements from the end\nof the array over the slots to be removed. This way there is less data\nmovement to be done which improves the execution time of the function.\n\nThe function $(D remove) works on any forward range. The moving\nstrategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==\nSwapStrategy.unstable && isRandomAccessRange!Range &&\nhasLength!Range), then elements are moved from the end of the range\ninto the slots to be filled. In this case, the absolute minimum of\nmoves is performed.)  $(LI Otherwise, if $(D s ==\nSwapStrategy.unstable && isBidirectionalRange!Range &&\nhasLength!Range), then elements are still moved from the end of the\nrange, but time is spent on advancing between slots by repeated calls\nto $(D range.popFront).)  $(LI Otherwise, elements are moved incrementally\ntowards the front of $(D range); a given element is never moved\nseveral times, but more elements are moved than in the previous\ncases.))\n \n",
"line" : 6192}
]
}
,
{
"name" : "remove(SwapStrategy s = SwapStrategy.stable,Range,Offset...) if ((isForwardRange!(Range) && !isBidirectionalRange!(Range) || !hasLength!(Range) || s == SwapStrategy.stable) && Offset.length >= 1)",
"kind" : "template",
"protection" : "public",
"line" : 6298,
"members" : [
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Range range, Offset offset)",
"line" : 6298}
]
}
,
{
"name" : "remove(alias pred,SwapStrategy s = SwapStrategy.stable,Range) if (isBidirectionalRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReduces the length of the bidirectional range $(D range) by removing\nelements that satisfy $(D pred). If $(D s = SwapStrategy.unstable),\nelements are moved from the right end of the range over the elements\nto eliminate. If $(D s = SwapStrategy.stable) (the default),\nelements are moved progressively to front such that their relative\norder is preserved. Returns the filtered range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];\nassert(remove!(\"a == 2\")(a) == [ 1, 3, 3, 4, 5, 5, 6 ]);\n----\n \n",
"line" : 6384,
"members" : [
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Range range)",
"comment" : "\nReduces the length of the bidirectional range $(D range) by removing\nelements that satisfy $(D pred). If $(D s = SwapStrategy.unstable),\nelements are moved from the right end of the range over the elements\nto eliminate. If $(D s = SwapStrategy.stable) (the default),\nelements are moved progressively to front such that their relative\norder is preserved. Returns the filtered range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];\nassert(remove!(\"a == 2\")(a) == [ 1, 3, 3, 4, 5, 5, 6 ]);\n----\n \n",
"line" : 6384}
]
}
,
{
"name" : "partition(alias predicate,SwapStrategy ss = SwapStrategy.unstable,Range) if (ss == SwapStrategy.stable && isRandomAccessRange!(Range) || ss != SwapStrategy.stable && isForwardRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nPartitions a range in two using $(D pred) as a\npredicate. Specifically, reorders the range $(D r = [left,\nright$(RPAREN)) using $(D swap) such that all elements $(D i) for\nwhich $(D pred(i)) is $(D true) come before all elements $(D j) for\nwhich $(D pred(j)) returns $(D false).\n\nPerforms $(BIGOH r.length) (if unstable or semistable) or $(BIGOH\nr.length * log(r.length)) (if stable) evaluations of $(D less) and $(D\nswap). The unstable version computes the minimum possible evaluations\nof $(D swap) (roughly half of those performed by the semistable\nversion).\n\nSee also STL's $(WEB sgi.com\/tech\/stl\/_partition.html, _partition) and\n$(WEB sgi.com\/tech\/stl\/stable_partition.html, stable_partition).\n\nReturns:\n\nThe right part of $(D r) after partitioning.\n\nIf $(D ss == SwapStrategy.stable), $(D partition) preserves the\nrelative ordering of all elements $(D a), $(D b) in $(D r) for which\n$(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D\npartition) preserves the relative ordering of all elements $(D a), $(D\nb) in the left part of $(D r) for which $(D pred(a) == pred(b)).\n\nExample:\n\n----\nauto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto arr = Arr.dup;\nstatic bool even(int a) { return (a & 1) == 0; }\n\/\/ Partition arr such that even numbers come first\nauto r = partition!(even)(arr);\n\/\/ Now arr is separated in evens and odds.\n\/\/ Numbers may have become shuffled due to instability\nassert(r == arr[5 .. $]);\nassert(count!(even)(arr[0 .. 5]) == 5);\nassert(find!(even)(r).empty);\n\n\/\/ Can also specify the predicate as a string.\n\/\/ Use 'a' as the predicate argument name\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0})(arr);\nassert(r == arr[5 .. $]);\n\n\/\/ Now for a stable partition:\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);\n\/\/ Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1\nassert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && r == arr[5 .. $]);\n\n\/\/ In case the predicate needs to hold its own state, use a delegate:\narr[] = Arr[];\nint x = 3;\n\/\/ Put stuff greater than 3 on the left\nbool fun(int a) { return a > x; }\nr = partition!(fun, SwapStrategy.semistable)(arr);\n\/\/ Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2\nassert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && r == arr[7 .. $]);\n----\n",
"line" : 6564,
"members" : [
{
"name" : "partition",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nPartitions a range in two using $(D pred) as a\npredicate. Specifically, reorders the range $(D r = [left,\nright$(RPAREN)) using $(D swap) such that all elements $(D i) for\nwhich $(D pred(i)) is $(D true) come before all elements $(D j) for\nwhich $(D pred(j)) returns $(D false).\n\nPerforms $(BIGOH r.length) (if unstable or semistable) or $(BIGOH\nr.length * log(r.length)) (if stable) evaluations of $(D less) and $(D\nswap). The unstable version computes the minimum possible evaluations\nof $(D swap) (roughly half of those performed by the semistable\nversion).\n\nSee also STL's $(WEB sgi.com\/tech\/stl\/_partition.html, _partition) and\n$(WEB sgi.com\/tech\/stl\/stable_partition.html, stable_partition).\n\nReturns:\n\nThe right part of $(D r) after partitioning.\n\nIf $(D ss == SwapStrategy.stable), $(D partition) preserves the\nrelative ordering of all elements $(D a), $(D b) in $(D r) for which\n$(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D\npartition) preserves the relative ordering of all elements $(D a), $(D\nb) in the left part of $(D r) for which $(D pred(a) == pred(b)).\n\nExample:\n\n----\nauto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto arr = Arr.dup;\nstatic bool even(int a) { return (a & 1) == 0; }\n\/\/ Partition arr such that even numbers come first\nauto r = partition!(even)(arr);\n\/\/ Now arr is separated in evens and odds.\n\/\/ Numbers may have become shuffled due to instability\nassert(r == arr[5 .. $]);\nassert(count!(even)(arr[0 .. 5]) == 5);\nassert(find!(even)(r).empty);\n\n\/\/ Can also specify the predicate as a string.\n\/\/ Use 'a' as the predicate argument name\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0})(arr);\nassert(r == arr[5 .. $]);\n\n\/\/ Now for a stable partition:\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);\n\/\/ Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1\nassert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && r == arr[5 .. $]);\n\n\/\/ In case the predicate needs to hold its own state, use a delegate:\narr[] = Arr[];\nint x = 3;\n\/\/ Put stuff greater than 3 on the left\nbool fun(int a) { return a > x; }\nr = partition!(fun, SwapStrategy.semistable)(arr);\n\/\/ Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2\nassert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && r == arr[7 .. $]);\n----\n",
"line" : 6564}
]
}
,
{
"name" : "isPartitioned(alias pred,Range) if (isForwardRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D r) is partitioned according to predicate $(D\npred).\n\nExample:\n----\nint[] r = [ 1, 3, 5, 7, 8, 2, 4, ];\nassert(isPartitioned!(\"a & 1\")(r));\n----\n \n",
"line" : 6694,
"members" : [
{
"name" : "isPartitioned",
"kind" : "function",
"type" : "bool(Range r)",
"comment" : "\nReturns $(D true) if $(D r) is partitioned according to predicate $(D\npred).\n\nExample:\n----\nint[] r = [ 1, 3, 5, 7, 8, 2, 4, ];\nassert(isPartitioned!(\"a & 1\")(r));\n----\n \n",
"line" : 6694}
]
}
,
{
"name" : "partition3(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range,E) if (ss == SwapStrategy.unstable && isRandomAccessRange!(Range) && hasSwappableElements!(Range) && hasLength!(Range) && is(typeof(binaryFun!(less)(r.front,pivot)) == bool) && is(typeof(binaryFun!(less)(pivot,r.front)) == bool) && is(typeof(binaryFun!(less)(r.front,r.front)) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\nRearranges elements in $(D r) in three adjacent ranges and returns\nthem. The first and leftmost range only contains elements in $(D r)\nless than $(D pivot). The second and middle range only contains\nelements in $(D r) that are equal to $(D pivot). Finally, the third\nand rightmost range only contains elements in $(D r) that are greater\nthan $(D pivot). The less-than test is defined by the binary function\n$(D less).\n\nExample:\n----\nauto a = [ 8, 3, 4, 1, 4, 7, 4 ];\nauto pieces = partition3(a, 4);\nassert(a == [ 1, 3, 4, 4, 4, 7, 8 ];\nassert(pieces[0] == [ 1, 3 ]);\nassert(pieces[1] == [ 4, 4, 4 ]);\nassert(pieces[2] == [ 7, 8 ]);\n----\n\nBUGS: stable $(D partition3) has not been implemented yet.\n \n",
"line" : 6740,
"members" : [
{
"name" : "partition3",
"kind" : "function",
"type" : "(Range r, E pivot)",
"comment" : "\nRearranges elements in $(D r) in three adjacent ranges and returns\nthem. The first and leftmost range only contains elements in $(D r)\nless than $(D pivot). The second and middle range only contains\nelements in $(D r) that are equal to $(D pivot). Finally, the third\nand rightmost range only contains elements in $(D r) that are greater\nthan $(D pivot). The less-than test is defined by the binary function\n$(D less).\n\nExample:\n----\nauto a = [ 8, 3, 4, 1, 4, 7, 4 ];\nauto pieces = partition3(a, 4);\nassert(a == [ 1, 3, 4, 4, 4, 7, 8 ];\nassert(pieces[0] == [ 1, 3 ]);\nassert(pieces[1] == [ 4, 4, 4 ]);\nassert(pieces[2] == [ 7, 8 ]);\n----\n\nBUGS: stable $(D partition3) has not been implemented yet.\n \n",
"line" : 6740}
]
}
,
{
"name" : "topN(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range) if (isRandomAccessRange!(Range) && hasLength!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReorders the range $(D r) using $(D swap) such that $(D r[nth]) refers\nto the element that would fall there if the range were fully\nsorted. In addition, it also partitions $(D r) such that all elements\n$(D e1) from $(D r[0]) to $(D r[nth]) satisfy $(D !less(r[nth], e1)),\nand all elements $(D e2) from $(D r[nth]) to $(D r[r.length]) satisfy\n$(D !less(e2, r[nth])). Effectively, it finds the nth smallest\n(according to $(D less)) elements in $(D r). Performs $(BIGOH\nr.length) (if unstable) or $(BIGOH r.length * log(r.length)) (if\nstable) evaluations of $(D less) and $(D swap). See also $(WEB\nsgi.com\/tech\/stl\/nth_element.html, STL's nth_element).\n\nExample:\n\n----\nint[] v = [ 25, 7, 9, 2, 0, 5, 21 ];\nauto n = 4;\ntopN!(less)(v, n);\nassert(v[n] == 9);\n\/\/ Equivalent form:\ntopN!(\"a < b\")(v, n);\nassert(v[n] == 9);\n----\n\nBUGS:\n\nStable topN has not been implemented yet.\n",
"line" : 6856,
"members" : [
{
"name" : "topN",
"kind" : "function",
"type" : "void(Range r, size_t nth)",
"comment" : "\nReorders the range $(D r) using $(D swap) such that $(D r[nth]) refers\nto the element that would fall there if the range were fully\nsorted. In addition, it also partitions $(D r) such that all elements\n$(D e1) from $(D r[0]) to $(D r[nth]) satisfy $(D !less(r[nth], e1)),\nand all elements $(D e2) from $(D r[nth]) to $(D r[r.length]) satisfy\n$(D !less(e2, r[nth])). Effectively, it finds the nth smallest\n(according to $(D less)) elements in $(D r). Performs $(BIGOH\nr.length) (if unstable) or $(BIGOH r.length * log(r.length)) (if\nstable) evaluations of $(D less) and $(D swap). See also $(WEB\nsgi.com\/tech\/stl\/nth_element.html, STL's nth_element).\n\nExample:\n\n----\nint[] v = [ 25, 7, 9, 2, 0, 5, 21 ];\nauto n = 4;\ntopN!(less)(v, n);\nassert(v[n] == 9);\n\/\/ Equivalent form:\ntopN!(\"a < b\")(v, n);\nassert(v[n] == 9);\n----\n\nBUGS:\n\nStable topN has not been implemented yet.\n",
"line" : 6856}
]
}
,
{
"name" : "topN(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range1,Range2) if (isRandomAccessRange!(Range1) && hasLength!(Range1) && isInputRange!(Range2) && is(ElementType!(Range1) == ElementType!(Range2)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nStores the smallest elements of the two ranges in the left-hand range.\n \n",
"line" : 6965,
"members" : [
{
"name" : "topN",
"kind" : "function",
"type" : "void(Range1 r1, Range2 r2)",
"comment" : "\nStores the smallest elements of the two ranges in the left-hand range.\n \n",
"line" : 6965}
]
}
,
{
"name" : "sort(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range)",
"kind" : "template",
"protection" : "public",
"comment" : "\nSorts a random-access range according to predicate $(D less). Performs\n$(BIGOH r.length * log(r.length)) (if unstable) or $(BIGOH r.length *\nlog(r.length) * log(r.length)) (if stable) evaluations of $(D less)\nand $(D swap). See also STL's $(WEB sgi.com\/tech\/stl\/_sort.html, _sort)\nand $(WEB sgi.com\/tech\/stl\/stable_sort.html, stable_sort).\n\nExample:\n\n----\nint[] array = [ 1, 2, 3, 4 ];\n\/\/ sort in descending order\nsort!(\"a > b\")(array);\nassert(array == [ 4, 3, 2, 1 ]);\n\/\/ sort in ascending order\nsort(array);\nassert(array == [ 1, 2, 3, 4 ]);\n\/\/ sort with a delegate\nbool myComp(int x, int y) { return x > y; }\nsort!(myComp)(array);\nassert(array == [ 4, 3, 2, 1 ]);\n\/\/ Showcase stable sorting\nstring[] words = [ \"aBc\", \"a\", \"abc\", \"b\", \"ABC\", \"c\" ];\nsort!(\"toUpper(a) < toUpper(b)\", SwapStrategy.stable)(words);\nassert(words == [ \"a\", \"aBc\", \"abc\", \"ABC\", \"b\", \"c\" ]);\n----\n",
"line" : 7022,
"members" : [
{
"name" : "sort",
"kind" : "function",
"type" : "SortedRange!(Range,less)(Range r)",
"comment" : "\nSorts a random-access range according to predicate $(D less). Performs\n$(BIGOH r.length * log(r.length)) (if unstable) or $(BIGOH r.length *\nlog(r.length) * log(r.length)) (if stable) evaluations of $(D less)\nand $(D swap). See also STL's $(WEB sgi.com\/tech\/stl\/_sort.html, _sort)\nand $(WEB sgi.com\/tech\/stl\/stable_sort.html, stable_sort).\n\nExample:\n\n----\nint[] array = [ 1, 2, 3, 4 ];\n\/\/ sort in descending order\nsort!(\"a > b\")(array);\nassert(array == [ 4, 3, 2, 1 ]);\n\/\/ sort in ascending order\nsort(array);\nassert(array == [ 1, 2, 3, 4 ]);\n\/\/ sort with a delegate\nbool myComp(int x, int y) { return x > y; }\nsort!(myComp)(array);\nassert(array == [ 4, 3, 2, 1 ]);\n\/\/ Showcase stable sorting\nstring[] words = [ \"aBc\", \"a\", \"abc\", \"b\", \"ABC\", \"c\" ];\nsort!(\"toUpper(a) < toUpper(b)\", SwapStrategy.stable)(words);\nassert(words == [ \"a\", \"aBc\", \"abc\", \"ABC\", \"b\", \"c\" ]);\n----\n",
"line" : 7022}
]
}
,
{
"name" : "validPredicates(E,less...)",
"kind" : "template",
"protection" : "public",
"line" : 7095,
"members" : [
]
}
,
{
"name" : "multiSort(less...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nSorts a range by multiple keys. The call $(D multiSort!(\"a.id < b.id\",\n\"a.date > b.date\")(r)) sorts the range $(D r) by $(D id) ascending,\nand sorts elements that have the same $(D id) by $(D date)\ndescending. Such a call is equivalent to $(D sort!\"a.id != b.id ? a.id\n< b.id : a.date > b.date\"(r)), but $(D multiSort) is faster because it\ndoes fewer comparisons (in addition to being more convenient).\n\nExample:\n----\nstatic struct Point { int x, y; }\nauto pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];\nauto pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];\nmultiSort!(\"a.x < b.x\", \"a.y < b.y\", SwapStrategy.unstable)(pts1);\nassert(pts1 == pts2);\n----\n \n",
"line" : 7123,
"members" : [
{
"name" : "multiSort(Range) if (validPredicates!(ElementType!(Range),less))",
"kind" : "template",
"protection" : "public",
"line" : 7125,
"members" : [
{
"name" : "multiSort",
"kind" : "function",
"type" : "void(Range r)",
"line" : 7125}
]
}
]
}
,
{
"name" : "getPivot(alias less,Range)",
"kind" : "template",
"protection" : "public",
"line" : 7181,
"members" : [
{
"name" : "getPivot",
"kind" : "function",
"type" : "size_t(Range r)",
"line" : 7181}
]
}
,
{
"name" : "optimisticInsertionSort(alias less,Range)",
"kind" : "template",
"protection" : "public",
"line" : 7221,
"members" : [
{
"name" : "optimisticInsertionSort",
"kind" : "function",
"type" : "void(Range r)",
"line" : 7221}
]
}
,
{
"name" : "swapAt(R)",
"kind" : "template",
"protection" : "public",
"line" : 7256,
"members" : [
{
"name" : "swapAt",
"kind" : "function",
"type" : "void(R r, size_t i1, size_t i2)",
"line" : 7256}
]
}
,
{
"name" : "sortImpl(alias less,SwapStrategy ss,Range)",
"kind" : "template",
"protection" : "public",
"line" : 7272,
"members" : [
{
"name" : "sortImpl",
"kind" : "function",
"type" : "void(Range r)",
"line" : 7272}
]
}
,
{
"name" : "schwartzSort(alias transform,alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range) if (isRandomAccessRange!(Range) && hasLength!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSorts a range using an algorithm akin to the $(WEB\nwikipedia.org\/wiki\/Schwartzian_transform, Schwartzian transform), also\nknown as the decorate-sort-undecorate pattern in Python and Lisp. (Not\nto be confused with $(WEB youtube.com\/watch?v=S25Zf8svHZQ, the other\nSchwartz).) This function is helpful when the sort comparison includes\nan expensive computation. The complexity is the same as that of the\ncorresponding $(D sort), but $(D schwartzSort) evaluates $(D\ntransform) only $(D r.length) times (less than half when compared to\nregular sorting). The usage can be best illustrated with an example.\n\nExample:\n\n----\nuint hashFun(string) { ... expensive computation ... }\nstring[] array = ...;\n\/\/ Sort strings by hash, slow\nsort!(\"hashFun(a) < hashFun(b)\")(array);\n\/\/ Sort strings by hash, fast (only computes arr.length hashes):\nschwartzSort!(hashFun, \"a < b\")(array);\n----\n\nThe $(D schwartzSort) function might require less temporary data and\nbe faster than the Perl idiom or the decorate-sort-undecorate idiom\npresent in Python and Lisp. This is because sorting is done in-place\nand only minimal extra data (one array of transformed elements) is\ncreated.\n\nTo check whether an array was sorted and benefit of the speedup of\nSchwartz sorting, a function $(D schwartzIsSorted) is not provided\nbecause the effect can be achieved by calling $(D\nisSorted!less(map!transform(r))).\n \n",
"line" : 7390,
"members" : [
{
"name" : "schwartzSort",
"kind" : "function",
"type" : "void(Range r)",
"comment" : "\nSorts a range using an algorithm akin to the $(WEB\nwikipedia.org\/wiki\/Schwartzian_transform, Schwartzian transform), also\nknown as the decorate-sort-undecorate pattern in Python and Lisp. (Not\nto be confused with $(WEB youtube.com\/watch?v=S25Zf8svHZQ, the other\nSchwartz).) This function is helpful when the sort comparison includes\nan expensive computation. The complexity is the same as that of the\ncorresponding $(D sort), but $(D schwartzSort) evaluates $(D\ntransform) only $(D r.length) times (less than half when compared to\nregular sorting). The usage can be best illustrated with an example.\n\nExample:\n\n----\nuint hashFun(string) { ... expensive computation ... }\nstring[] array = ...;\n\/\/ Sort strings by hash, slow\nsort!(\"hashFun(a) < hashFun(b)\")(array);\n\/\/ Sort strings by hash, fast (only computes arr.length hashes):\nschwartzSort!(hashFun, \"a < b\")(array);\n----\n\nThe $(D schwartzSort) function might require less temporary data and\nbe faster than the Perl idiom or the decorate-sort-undecorate idiom\npresent in Python and Lisp. This is because sorting is done in-place\nand only minimal extra data (one array of transformed elements) is\ncreated.\n\nTo check whether an array was sorted and benefit of the speedup of\nSchwartz sorting, a function $(D schwartzIsSorted) is not provided\nbecause the effect can be achieved by calling $(D\nisSorted!less(map!transform(r))).\n \n",
"line" : 7390}
]
}
,
{
"name" : "partialSort(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range) if (isRandomAccessRange!(Range) && hasLength!(Range) && hasSlicing!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReorders the random-access range $(D r) such that the range $(D r[0\n.. mid]) is the same as if the entire $(D r) were sorted, and leaves\nthe range $(D r[mid .. r.length]) in no particular order. Performs\n$(BIGOH r.length * log(mid)) evaluations of $(D pred). The\nimplementation simply calls $(D topN!(less, ss)(r, n)) and then $(D\nsort!(less, ss)(r[0 .. n])).\n\nExample:\n----\nint[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];\npartialSort(a, 5);\nassert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);\n----\n",
"line" : 7483,
"members" : [
{
"name" : "partialSort",
"kind" : "function",
"type" : "void(Range r, size_t n)",
"comment" : "\nReorders the random-access range $(D r) such that the range $(D r[0\n.. mid]) is the same as if the entire $(D r) were sorted, and leaves\nthe range $(D r[mid .. r.length]) in no particular order. Performs\n$(BIGOH r.length * log(mid)) evaluations of $(D pred). The\nimplementation simply calls $(D topN!(less, ss)(r, n)) and then $(D\nsort!(less, ss)(r[0 .. n])).\n\nExample:\n----\nint[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];\npartialSort(a, 5);\nassert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);\n----\n",
"line" : 7483}
]
}
,
{
"name" : "completeSort(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range1,Range2) if (hasLength!(Range2) && hasSlicing!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSorts the random-access range $(D chain(lhs, rhs)) according to\npredicate $(D less). The left-hand side of the range $(D lhs) is\nassumed to be already sorted; $(D rhs) is assumed to be unsorted. The\nexact strategy chosen depends on the relative sizes of $(D lhs) and\n$(D rhs).  Performs $(BIGOH lhs.length + rhs.length * log(rhs.length))\n(best case) to $(BIGOH (lhs.length + rhs.length) * log(lhs.length +\nrhs.length)) (worst-case) evaluations of $(D swap).\n\nExample:\n----\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 4, 0, 6, 5 ];\ncompleteSort(assumeSorted(a), b);\nassert(a == [ 0, 1, 2 ]);\nassert(b == [ 3, 4, 5, 6 ]);\n----\n",
"line" : 7519,
"members" : [
{
"name" : "completeSort",
"kind" : "function",
"type" : "void(SortedRange!(Range1,less) lhs, Range2 rhs)",
"comment" : "\nSorts the random-access range $(D chain(lhs, rhs)) according to\npredicate $(D less). The left-hand side of the range $(D lhs) is\nassumed to be already sorted; $(D rhs) is assumed to be unsorted. The\nexact strategy chosen depends on the relative sizes of $(D lhs) and\n$(D rhs).  Performs $(BIGOH lhs.length + rhs.length * log(rhs.length))\n(best case) to $(BIGOH (lhs.length + rhs.length) * log(lhs.length +\nrhs.length)) (worst-case) evaluations of $(D swap).\n\nExample:\n----\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 4, 0, 6, 5 ];\ncompleteSort(assumeSorted(a), b);\nassert(a == [ 0, 1, 2 ]);\nassert(b == [ 3, 4, 5, 6 ]);\n----\n",
"line" : 7519}
]
}
,
{
"name" : "isSorted(alias less = \"a < b\",Range) if (isForwardRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nChecks whether a forward range is sorted according to the comparison\noperation $(D less). Performs $(BIGOH r.length) evaluations of $(D\nless).\n\nExample:\n----\nint[] arr = [4, 3, 2, 1];\nassert(!isSorted(arr));\nsort(arr);\nassert(isSorted(arr));\nsort!(\"a > b\")(arr);\nassert(isSorted!(\"a > b\")(arr));\n----\n",
"line" : 7565,
"members" : [
{
"name" : "isSorted",
"kind" : "function",
"type" : "bool(Range r)",
"comment" : "\nChecks whether a forward range is sorted according to the comparison\noperation $(D less). Performs $(BIGOH r.length) evaluations of $(D\nless).\n\nExample:\n----\nint[] arr = [4, 3, 2, 1];\nassert(!isSorted(arr));\nsort(arr);\nassert(isSorted(arr));\nsort!(\"a > b\")(arr);\nassert(isSorted!(\"a > b\")(arr));\n----\n",
"line" : 7565}
]
}
,
{
"name" : "makeIndex(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range,RangeIndex) if (isForwardRange!(Range) && isRandomAccessRange!(RangeIndex) && is(ElementType!(RangeIndex) : ElementType!(Range)*))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes an index for $(D r) based on the comparison $(D less). The\nindex is a sorted array of pointers or indices into the original\nrange. This technique is similar to sorting, but it is more flexible\nbecause (1) it allows \"sorting\" of immutable collections, (2) allows\nbinary search even if the original collection does not offer random\naccess, (3) allows multiple indexes, each on a different predicate,\nand (4) may be faster when dealing with large objects. However, using\nan index may also be slower under certain circumstances due to the\nextra indirection, and is always larger than a sorting-based solution\nbecause it needs space for the index in addition to the original\ncollection. The complexity is the same as $(D sort)'s.\n\n$(D makeIndex) overwrites its second argument with the result, but\nnever reallocates it. If the second argument's length is less than\nthat of the range indexed, an exception is thrown.\n\nThe first overload of $(D makeIndex) writes to a range containing\npointers, and the second writes to a range containing offsets. The\nfirst overload requires $(D Range) to be a forward range, and the\nlatter requires it to be a random-access range.\n\nExample:\n----\nimmutable(int[]) arr = [ 2, 3, 1, 5, 0 ];\n\/\/ index using pointers\nauto index1 = new immutable(int)*[arr.length];\nmakeIndex!(\"a < b\")(arr, index1);\nassert(isSorted!(\"*a < *b\")(index1));\n\/\/ index using offsets\nauto index2 = new size_t[arr.length];\nmakeIndex!(\"a < b\")(arr, index2);\nassert(isSorted!\n    ((size_t a, size_t b){ return arr[a] < arr[b];})\n    (index2));\n----\n",
"line" : 7613,
"members" : [
{
"name" : "makeIndex",
"kind" : "function",
"type" : "void(Range r, RangeIndex index)",
"comment" : "\nComputes an index for $(D r) based on the comparison $(D less). The\nindex is a sorted array of pointers or indices into the original\nrange. This technique is similar to sorting, but it is more flexible\nbecause (1) it allows \"sorting\" of immutable collections, (2) allows\nbinary search even if the original collection does not offer random\naccess, (3) allows multiple indexes, each on a different predicate,\nand (4) may be faster when dealing with large objects. However, using\nan index may also be slower under certain circumstances due to the\nextra indirection, and is always larger than a sorting-based solution\nbecause it needs space for the index in addition to the original\ncollection. The complexity is the same as $(D sort)'s.\n\n$(D makeIndex) overwrites its second argument with the result, but\nnever reallocates it. If the second argument's length is less than\nthat of the range indexed, an exception is thrown.\n\nThe first overload of $(D makeIndex) writes to a range containing\npointers, and the second writes to a range containing offsets. The\nfirst overload requires $(D Range) to be a forward range, and the\nlatter requires it to be a random-access range.\n\nExample:\n----\nimmutable(int[]) arr = [ 2, 3, 1, 5, 0 ];\n\/\/ index using pointers\nauto index1 = new immutable(int)*[arr.length];\nmakeIndex!(\"a < b\")(arr, index1);\nassert(isSorted!(\"*a < *b\")(index1));\n\/\/ index using offsets\nauto index2 = new size_t[arr.length];\nmakeIndex!(\"a < b\")(arr, index2);\nassert(isSorted!\n    ((size_t a, size_t b){ return arr[a] < arr[b];})\n    (index2));\n----\n",
"line" : 7613}
]
}
,
{
"name" : "makeIndex(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range,RangeIndex) if (isRandomAccessRange!(Range) && !isInfinite!(Range) && isRandomAccessRange!(RangeIndex) && !isInfinite!(RangeIndex) && isIntegral!(ElementType!(RangeIndex)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 7637,
"members" : [
{
"name" : "makeIndex",
"kind" : "function",
"type" : "void(Range r, RangeIndex index)",
"comment" : " Ditto\n",
"line" : 7637}
]
}
,
{
"name" : "SortOutput",
"kind" : "enum",
"protection" : "public",
"comment" : "\nSpecifies whether the output of certain algorithm is desired in sorted\nformat.\n \n",
"line" : 7708,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " Don't sort output\n",
"line" : 7709}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " Sort output\n",
"line" : 7710}
]
}
,
{
"name" : "topNIndex(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range,RangeIndex) if (isIntegral!(ElementType!(RangeIndex)))",
"kind" : "template",
"protection" : "public",
"line" : 7713,
"members" : [
{
"name" : "topNIndex",
"kind" : "function",
"type" : "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
"line" : 7713}
]
}
,
{
"name" : "topNIndex(alias less = \"a < b\",SwapStrategy ss = SwapStrategy.unstable,Range,RangeIndex) if (is(ElementType!(RangeIndex) == ElementType!(Range)*))",
"kind" : "template",
"protection" : "public",
"line" : 7737,
"members" : [
{
"name" : "topNIndex",
"kind" : "function",
"type" : "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
"line" : 7737}
]
}
,
{
"name" : "canFind(alias pred = \"a == b\",Range,V) if (is(typeof(find!(pred)(range,value))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange). Performs $(BIGOH r.length) evaluations of $(D pred). \n",
"line" : 8057,
"members" : [
{
"name" : "canFind",
"kind" : "function",
"type" : "bool(Range range, V value)",
"comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange). Performs $(BIGOH r.length) evaluations of $(D pred). \n",
"line" : 8057}
]
}
,
{
"name" : "canFind(alias pred,Range)",
"kind" : "template",
"protection" : "public",
"comment" : "\nForwards to $(D any) for backwards compatibility.\n\n$(RED Scheduled for deprecation in September 2012. Please use $(D any) instead.)\n",
"line" : 8080,
"members" : [
{
"name" : "canFind",
"kind" : "function",
"type" : "bool(Range range)",
"comment" : "\nForwards to $(D any) for backwards compatibility.\n\n$(RED Scheduled for deprecation in September 2012. Please use $(D any) instead.)\n",
"line" : 8080}
]
}
,
{
"name" : "any(alias pred,Range) if (is(typeof(find!(pred)(range))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if a value $(D v) satisfying the\npredicate $(D pred) can be found in the forward range $(D\nrange). Performs $(BIGOH r.length) evaluations of $(D pred).\n \n",
"line" : 8090,
"members" : [
{
"name" : "any",
"kind" : "function",
"type" : "bool(Range range)",
"comment" : "\nReturns $(D true) if and only if a value $(D v) satisfying the\npredicate $(D pred) can be found in the forward range $(D\nrange). Performs $(BIGOH r.length) evaluations of $(D pred).\n \n",
"line" : 8090}
]
}
,
{
"name" : "all(alias pred,R) if (isInputRange!(R) && is(typeof(unaryFun!(pred)(range.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if all values in $(D range) satisfy the\npredicate $(D pred).  Performs $(BIGOH r.length) evaluations of $(D pred).\n\nExamples:\n---\nassert(all!\"a & 1\"([1, 3, 5, 7, 9]));\nassert(!all!\"a & 1\"([1, 2, 3, 5, 7, 9]));\n---\n",
"line" : 8115,
"members" : [
{
"name" : "all",
"kind" : "function",
"type" : "bool(R range)",
"comment" : "\nReturns $(D true) if and only if all values in $(D range) satisfy the\npredicate $(D pred).  Performs $(BIGOH r.length) evaluations of $(D pred).\n\nExamples:\n---\nassert(all!\"a & 1\"([1, 3, 5, 7, 9]));\nassert(!all!\"a & 1\"([1, 2, 3, 5, 7, 9]));\n---\n",
"line" : 8115}
]
}
,
{
"name" : "canFindSorted(alias pred = \"a < b\",Range,V)",
"kind" : "template",
"protection" : "public",
"line" : 8128,
"members" : [
{
"name" : "canFindSorted",
"kind" : "function",
"type" : "bool(Range range, V value)",
"line" : 8128}
]
}
,
{
"name" : "lowerBound(alias pred = \"a < b\",Range,V)",
"kind" : "template",
"protection" : "public",
"line" : 8135,
"members" : [
{
"name" : "lowerBound",
"kind" : "function",
"type" : "Range(Range range, V value)",
"line" : 8135}
]
}
,
{
"name" : "upperBound(alias pred = \"a < b\",Range,V)",
"kind" : "template",
"protection" : "public",
"line" : 8142,
"members" : [
{
"name" : "upperBound",
"kind" : "function",
"type" : "Range(Range range, V value)",
"line" : 8142}
]
}
,
{
"name" : "equalRange(alias pred = \"a < b\",Range,V)",
"kind" : "template",
"protection" : "public",
"line" : 8149,
"members" : [
{
"name" : "equalRange",
"kind" : "function",
"type" : "Range(Range range, V value)",
"line" : 8149}
]
}
,
{
"name" : "topNCopy(alias less = \"a < b\",SRange,TRange) if (isInputRange!(SRange) && isRandomAccessRange!(TRange) && hasLength!(TRange) && hasSlicing!(TRange))",
"kind" : "template",
"protection" : "public",
"comment" : "\nCopies the top $(D n) elements of the input range $(D source) into the\nrandom-access range $(D target), where $(D n =\ntarget.length). Elements of $(D source) are not touched. If $(D\nsorted) is $(D true), the target is sorted. Otherwise, the target\nrespects the $(WEB en.wikipedia.org\/wiki\/Binary_heap, heap property).\n\nExample:\n----\nint[] a = [ 10, 16, 2, 3, 1, 5, 0 ];\nint[] b = new int[3];\ntopNCopy(a, b, true);\nassert(b == [ 0, 1, 2 ]);\n----\n \n",
"line" : 8170,
"members" : [
{
"name" : "topNCopy",
"kind" : "function",
"type" : "TRange(SRange source, TRange target, SortOutput sorted = SortOutput.no)",
"comment" : "\nCopies the top $(D n) elements of the input range $(D source) into the\nrandom-access range $(D target), where $(D n =\ntarget.length). Elements of $(D source) are not touched. If $(D\nsorted) is $(D true), the target is sorted. Otherwise, the target\nrespects the $(WEB en.wikipedia.org\/wiki\/Binary_heap, heap property).\n\nExample:\n----\nint[] a = [ 10, 16, 2, 3, 1, 5, 0 ];\nint[] b = new int[3];\ntopNCopy(a, b, true);\nassert(b == [ 0, 1, 2 ]);\n----\n \n",
"line" : 8170}
]
}
,
{
"name" : "SetUnion(alias less = \"a < b\",Rs...) if (allSatisfy!(isInputRange,Rs))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLazily computes the union of two or more ranges $(D rs). The ranges\nare assumed to be sorted by $(D less). Elements in the output are not\nunique; the length of the output is the sum of the lengths of the\ninputs. (The $(D length) member is offered if all ranges also have\nlength.) The element types of all ranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nint[] c = [ 10 ];\nassert(setUnion(a, b).length == a.length + b.length);\nassert(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));\nassert(equal(setUnion(a, c, b),\n    [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10][]));\n----\n \n",
"line" : 8229,
"members" : [
{
"name" : "SetUnion",
"kind" : "struct",
"protection" : "public",
"line" : 8229,
"members" : [
{
"name" : "_r",
"kind" : "variable",
"type" : "Rs",
"line" : 8231}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 8232}
,
{
"name" : "_crt",
"kind" : "variable",
"type" : "uint",
"line" : 8233}
,
{
"name" : "adjustPosition(uint candidate = 0)",
"kind" : "template",
"protection" : "public",
"line" : 8235,
"members" : [
{
"name" : "adjustPosition",
"kind" : "function",
"type" : "void()",
"line" : 8235}
]
}
,
{
"name" : "ElementType",
"kind" : "alias",
"type" : "CommonType!(staticMap!(.ElementType,Rs))",
"line" : 8265}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Rs rs)",
"line" : 8267}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 8273}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 8278}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType()",
"line" : 8294}
]
}
]
}
,
{
"name" : "setUnion(alias less = \"a < b\",Rs...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 8338,
"members" : [
{
"name" : "setUnion",
"kind" : "function",
"type" : "SetUnion!(less,Rs)(Rs rs)",
"comment" : " Ditto\n",
"line" : 8338}
]
}
,
{
"name" : "SetIntersection(alias less = \"a < b\",Rs...) if (allSatisfy!(isInputRange,Rs))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLazily computes the intersection of two or more input ranges $(D\nrs). The ranges are assumed to be sorted by $(D less). The element\ntypes of all ranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nint[] c = [ 0, 1, 4, 5, 7, 8 ];\nassert(equal(setIntersection(a, a), a));\nassert(equal(setIntersection(a, b), [1, 2, 4, 7][]));\nassert(equal(setIntersection(a, b, c), [1, 4, 7][]));\n----\n \n",
"line" : 8377,
"members" : [
{
"name" : "SetIntersection",
"kind" : "struct",
"protection" : "public",
"line" : 8377,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Rs",
"line" : 8380}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 8381}
,
{
"name" : "ElementType",
"kind" : "alias",
"type" : "CommonType!(staticMap!(.ElementType,Rs))",
"line" : 8382}
,
{
"name" : "adjustPosition",
"kind" : "function",
"type" : "void()",
"line" : 8384}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Rs input)",
"line" : 8405}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 8412}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 8421}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType()",
"line" : 8431}
]
}
]
}
,
{
"name" : "setIntersection(alias less = \"a < b\",Rs...) if (allSatisfy!(isInputRange,Rs))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 8453,
"members" : [
{
"name" : "setIntersection",
"kind" : "function",
"type" : "SetIntersection!(less,Rs)(Rs ranges)",
"comment" : " Ditto\n",
"line" : 8453}
]
}
,
{
"name" : "SetDifference(alias less = \"a < b\",R1,R2) if (isInputRange!(R1) && isInputRange!(R2))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLazily computes the difference of $(D r1) and $(D r2). The two ranges\nare assumed to be sorted by $(D less). The element types of the two\nranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setDifference(a, b), [5, 9][]));\n----\n \n",
"line" : 8495,
"members" : [
{
"name" : "SetDifference",
"kind" : "struct",
"protection" : "public",
"line" : 8495,
"members" : [
{
"name" : "r1",
"kind" : "variable",
"type" : "R1",
"line" : 8497}
,
{
"name" : "r2",
"kind" : "variable",
"type" : "R2",
"line" : 8498}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 8499}
,
{
"name" : "adjustPosition",
"kind" : "function",
"type" : "void()",
"line" : 8501}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R1 r1, R2 r2)",
"line" : 8520}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 8528}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType!(R1)()",
"line" : 8534}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 8551}
]
}
]
}
,
{
"name" : "setDifference(alias less = \"a < b\",R1,R2)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 8555,
"members" : [
{
"name" : "setDifference",
"kind" : "function",
"type" : "SetDifference!(less,R1,R2)(R1 r1, R2 r2)",
"comment" : " Ditto\n",
"line" : 8555}
]
}
,
{
"name" : "SetSymmetricDifference(alias less = \"a < b\",R1,R2) if (isInputRange!(R1) && isInputRange!(R2))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLazily computes the symmetric difference of $(D r1) and $(D r2),\ni.e. the elements that are present in exactly one of $(D r1) and $(D\nr2). The two ranges are assumed to be sorted by $(D less), and the\noutput is also sorted by $(D less). The element types of the two\nranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));\n----\n \n",
"line" : 8588,
"members" : [
{
"name" : "SetSymmetricDifference",
"kind" : "struct",
"protection" : "public",
"line" : 8588,
"members" : [
{
"name" : "r1",
"kind" : "variable",
"type" : "R1",
"line" : 8590}
,
{
"name" : "r2",
"kind" : "variable",
"type" : "R2",
"line" : 8591}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 8593}
,
{
"name" : "adjustPosition",
"kind" : "function",
"type" : "void()",
"line" : 8595}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R1 r1, R2 r2)",
"line" : 8610}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 8618}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType!(R1)()",
"line" : 8639}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "ref ()",
"line" : 8661}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 8663}
]
}
]
}
,
{
"name" : "setSymmetricDifference(alias less = \"a < b\",R1,R2)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 8668,
"members" : [
{
"name" : "setSymmetricDifference",
"kind" : "function",
"type" : "SetSymmetricDifference!(less,R1,R2)(R1 r1, R2 r2)",
"comment" : " Ditto\n",
"line" : 8668}
]
}
,
{
"name" : "NWayUnion(alias less,RangeOfRanges)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nComputes the union of multiple sets. The input sets are passed as a\nrange of ranges and each is assumed to be sorted by $(D\nless). Computation is done lazily, one union element at a time. The\ncomplexity of one $(D popFront) operation is $(BIGOH\nlog(ror.length)). However, the length of $(D ror) decreases as ranges\nin it are exhausted, so the complexity of a full pass through $(D\nNWayUnion) is dependent on the distribution of the lengths of ranges\ncontained within $(D ror). If all ranges have the same length $(D n)\n(worst case scenario), the complexity of a full pass through $(D\nNWayUnion) is $(BIGOH n * ror.length * log(ror.length)), i.e., $(D\nlog(ror.length)) times worse than just spanning all ranges in\nturn. The output comes sorted (unstably) by $(D less).\n\nWarning: Because $(D NWayUnion) does not allocate extra memory, it\nwill leave $(D ror) modified. Namely, $(D NWayUnion) assumes ownership\nof $(D ror) and discretionarily swaps and advances elements of it. If\nyou want $(D ror) to preserve its contents after the call, you may\nwant to pass a duplicate to $(D NWayUnion) (and perhaps cache the\nduplicate in between calls).\n\nExample:\n----\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto witness = [\n    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8\n];\nassert(equal(nWayUnion(a), witness[]));\n----\n \n",
"line" : 8783,
"members" : [
{
"name" : "NWayUnion",
"kind" : "struct",
"protection" : "public",
"line" : 8783,
"members" : [
{
"name" : "ElementType",
"kind" : "alias",
"type" : ".ElementType!(.ElementType!(RangeOfRanges))",
"line" : 8784}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 8785}
,
{
"name" : "_ror",
"kind" : "variable",
"type" : "RangeOfRanges",
"line" : 8786}
,
{
"name" : "compFront",
"kind" : "function",
"type" : "bool(.ElementType!(RangeOfRanges) a, .ElementType!(RangeOfRanges) b)",
"line" : 8787}
,
{
"name" : "_heap",
"kind" : "variable",
"type" : "BinaryHeap!(RangeOfRanges,compFront)",
"line" : 8793}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(RangeOfRanges ror)",
"line" : 8795}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 8804}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType()",
"line" : 8806}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 8811}
]
}
]
}
,
{
"name" : "nWayUnion(alias less = \"a < b\",RangeOfRanges)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 8829,
"members" : [
{
"name" : "nWayUnion",
"kind" : "function",
"type" : "NWayUnion!(less,RangeOfRanges)(RangeOfRanges ror)",
"comment" : " Ditto\n",
"line" : 8829}
]
}
,
{
"name" : "largestPartialIntersection(alias less = \"a < b\",RangeOfRanges,Range)",
"kind" : "template",
"protection" : "public",
"comment" : "\nGiven a range of sorted forward ranges $(D ror), copies to $(D tgt)\nthe elements that are common to most ranges, along with their number\nof occurrences. All ranges in $(D ror) are assumed to be sorted by $(D\nless). Only the most frequent $(D tgt.length) elements are returned.\n\nExample:\n----\n\/\/ Figure which number can be found in most arrays of the set of\n\/\/ arrays below.\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\nlargestPartialIntersection(a, b);\n\/\/ First member is the item, second is the occurrence count\nassert(b[0] == tuple(7.0, 4u));\n----\n\n$(D 7.0) is the correct answer because it occurs in $(D 4) out of the\n$(D 5) inputs, more than any other number. The second member of the\nresulting tuple is indeed $(D 4) (recording the number of occurrences\nof $(D 7.0)). If more of the top-frequent numbers are needed, just\ncreate a larger $(D tgt) range. In the axample above, creating $(D b)\nwith length $(D 2) yields $(D tuple(1.0, 3u)) in the second position.\n\nThe function $(D largestPartialIntersection) is useful for\ne.g. searching an $(LUCKY inverted index) for the documents most\nlikely to contain some terms of interest. The complexity of the search\nis $(BIGOH n * log(tgt.length)), where $(D n) is the sum of lengths of\nall input ranges. This approach is faster than keeping an associative\narray of the occurrences and then selecting its top items, and also\nrequires less memory ($(D largestPartialIntersection) builds its\nresult directly in $(D tgt) and requires no extra memory).\n\nWarning: Because $(D largestPartialIntersection) does not allocate\nextra memory, it will leave $(D ror) modified. Namely, $(D\nlargestPartialIntersection) assumes ownership of $(D ror) and\ndiscretionarily swaps and advances elements of it. If you want $(D\nror) to preserve its contents after the call, you may want to pass a\nduplicate to $(D largestPartialIntersection) (and perhaps cache the\nduplicate in between calls).\n \n",
"line" : 8904,
"members" : [
{
"name" : "largestPartialIntersection",
"kind" : "function",
"type" : "void(RangeOfRanges ror, Range tgt, SortOutput sorted = SortOutput.no)",
"comment" : "\nGiven a range of sorted forward ranges $(D ror), copies to $(D tgt)\nthe elements that are common to most ranges, along with their number\nof occurrences. All ranges in $(D ror) are assumed to be sorted by $(D\nless). Only the most frequent $(D tgt.length) elements are returned.\n\nExample:\n----\n\/\/ Figure which number can be found in most arrays of the set of\n\/\/ arrays below.\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\nlargestPartialIntersection(a, b);\n\/\/ First member is the item, second is the occurrence count\nassert(b[0] == tuple(7.0, 4u));\n----\n\n$(D 7.0) is the correct answer because it occurs in $(D 4) out of the\n$(D 5) inputs, more than any other number. The second member of the\nresulting tuple is indeed $(D 4) (recording the number of occurrences\nof $(D 7.0)). If more of the top-frequent numbers are needed, just\ncreate a larger $(D tgt) range. In the axample above, creating $(D b)\nwith length $(D 2) yields $(D tuple(1.0, 3u)) in the second position.\n\nThe function $(D largestPartialIntersection) is useful for\ne.g. searching an $(LUCKY inverted index) for the documents most\nlikely to contain some terms of interest. The complexity of the search\nis $(BIGOH n * log(tgt.length)), where $(D n) is the sum of lengths of\nall input ranges. This approach is faster than keeping an associative\narray of the occurrences and then selecting its top items, and also\nrequires less memory ($(D largestPartialIntersection) builds its\nresult directly in $(D tgt) and requires no extra memory).\n\nWarning: Because $(D largestPartialIntersection) does not allocate\nextra memory, it will leave $(D ror) modified. Namely, $(D\nlargestPartialIntersection) assumes ownership of $(D ror) and\ndiscretionarily swaps and advances elements of it. If you want $(D\nror) to preserve its contents after the call, you may want to pass a\nduplicate to $(D largestPartialIntersection) (and perhaps cache the\nduplicate in between calls).\n \n",
"line" : 8904}
]
}
,
{
"name" : "largestPartialIntersectionWeighted(alias less = \"a < b\",RangeOfRanges,Range,WeightsAA)",
"kind" : "template",
"protection" : "public",
"comment" : "\nSimilar to $(D largestPartialIntersection), but associates a weight\nwith each distinct element in the intersection.\n\nExample:\n----\n\/\/ Figure which number can be found in most arrays of the set of\n\/\/ arrays below, with specific per-element weights\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\ndouble[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];\nlargestPartialIntersectionWeighted(a, b, weights);\n\/\/ First member is the item, second is the occurrence count\nassert(b[0] == tuple(4.0, 2u));\n----\n\nThe correct answer in this case is $(D 4.0), which, although only\nappears two times, has a total weight $(D 4.6) (three times its weight\n$(D 2.3)). The value $(D 7) is weighted with $(D 1.1) and occurs four\ntimes for a total weight $(D 4.4).\n \n",
"line" : 8945,
"members" : [
{
"name" : "largestPartialIntersectionWeighted",
"kind" : "function",
"type" : "void(RangeOfRanges ror, Range tgt, WeightsAA weights, SortOutput sorted = SortOutput.no)",
"comment" : "\nSimilar to $(D largestPartialIntersection), but associates a weight\nwith each distinct element in the intersection.\n\nExample:\n----\n\/\/ Figure which number can be found in most arrays of the set of\n\/\/ arrays below, with specific per-element weights\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\ndouble[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];\nlargestPartialIntersectionWeighted(a, b, weights);\n\/\/ First member is the item, second is the occurrence count\nassert(b[0] == tuple(4.0, 2u));\n----\n\nThe correct answer in this case is $(D 4.0), which, although only\nappears two times, has a total weight $(D 4.6) (three times its weight\n$(D 2.3)). The value $(D 7) is weighted with $(D 1.1) and occurs four\ntimes for a total weight $(D 4.4).\n \n",
"line" : 8945}
]
}
]
}
,
{
"name" : "std.array",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/array.d",
"comment" : "\nFunctions and types that manipulate built-in arrays.\n\nCopyright: Copyright Andrei Alexandrescu 2008- and Jonathan M Davis 2011-.\n\nLicense:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n\nSource: $(PHOBOSSRC std\/_array.d)\n",
"members" : [
{
"name" : "array(Range) if (isIterable!(Range) && !isNarrowString!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a newly-allocated dynamic array consisting of a copy of the\ninput range, static array, dynamic array, or class or struct with an\n$(D opApply) function $(D r).  Note that narrow strings are handled as\na special case in an overload.\n\nExample:\n\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = array([1, 2, 3, 4, 5][]);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 37,
"members" : [
{
"name" : "array",
"kind" : "function",
"type" : "ForeachType!(Range)[](Range r)",
"comment" : "\nReturns a newly-allocated dynamic array consisting of a copy of the\ninput range, static array, dynamic array, or class or struct with an\n$(D opApply) function $(D r).  Note that narrow strings are handled as\na special case in an overload.\n\nExample:\n\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = array([1, 2, 3, 4, 5][]);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 37}
]
}
,
{
"name" : "array(String) if (isNarrowString!(String))",
"kind" : "template",
"protection" : "public",
"comment" : "\nConvert a narrow string to an array type that fully supports random access.\nThis is handled as a special case and always returns a $(D dchar[]),\n$(D const(dchar)[]), or $(D immutable(dchar)[]) depending on the constness of\nthe input.\n",
"line" : 81,
"members" : [
{
"name" : "array",
"kind" : "function",
"type" : "ElementType!(String)[](String str)",
"comment" : "\nConvert a narrow string to an array type that fully supports random access.\nThis is handled as a special case and always returns a $(D dchar[]),\n$(D const(dchar)[]), or $(D immutable(dchar)[]) depending on the constness of\nthe input.\n",
"line" : 81}
]
}
,
{
"name" : "blockAttribute(T)",
"kind" : "template",
"protection" : "public",
"line" : 172,
"members" : [
]
}
,
{
"name" : "nDimensions(T)",
"kind" : "template",
"protection" : "public",
"line" : 188,
"members" : [
]
}
,
{
"name" : "uninitializedArray(T,I...) if (allSatisfy!(isIntegral,I))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap\nwithout initializing its elements.  This can be a useful optimization if every\nelement will be immediately initialized.  $(D T) may be a multidimensional\narray.  In this case sizes may be specified for any number of dimensions from 1\nto the number in $(D T).\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n---\ndouble[] arr = uninitializedArray!(double[])(100);\nassert(arr.length == 100);\n\ndouble[][] matrix = uninitializedArray!(double[][])(42, 31);\nassert(matrix.length == 42);\nassert(matrix[0].length == 31);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 225,
"members" : [
{
"name" : "uninitializedArray",
"kind" : "function",
"type" : "(I sizes)",
"comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap\nwithout initializing its elements.  This can be a useful optimization if every\nelement will be immediately initialized.  $(D T) may be a multidimensional\narray.  In this case sizes may be specified for any number of dimensions from 1\nto the number in $(D T).\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n---\ndouble[] arr = uninitializedArray!(double[])(100);\nassert(arr.length == 100);\n\ndouble[][] matrix = uninitializedArray!(double[][])(42, 31);\nassert(matrix.length == 42);\nassert(matrix[0].length == 31);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 225}
]
}
,
{
"name" : "minimallyInitializedArray(T,I...) if (allSatisfy!(isIntegral,I))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap.\nInitialization is guaranteed only for pointers, references and slices,\nfor preservation of memory safety.\n",
"line" : 246,
"members" : [
{
"name" : "minimallyInitializedArray",
"kind" : "function",
"type" : "@trusted (I sizes)",
"comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap.\nInitialization is guaranteed only for pointers, references and slices,\nfor preservation of memory safety.\n",
"line" : 246}
]
}
,
{
"name" : "arrayAllocImpl(bool minimallyInitialized,T,I...) if (allSatisfy!(isIntegral,I))",
"kind" : "template",
"protection" : "public",
"line" : 265,
"members" : [
{
"name" : "arrayAllocImpl",
"kind" : "function",
"type" : "(I sizes)",
"line" : 265}
]
}
,
{
"name" : "empty(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the range interface primitive $(D empty) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.empty) is\nequivalent to $(D empty(array)).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = [ 1, 2, 3 ];\nassert(!a.empty);\nassert(a[3 .. $].empty);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 312,
"members" : [
{
"name" : "empty",
"kind" : "function",
"type" : "pure nothrow @safe bool(in T[] a)",
"line" : 312}
]
}
,
{
"name" : "save(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the range interface primitive $(D save) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.save) is\nequivalent to $(D save(array)). The function does not duplicate the\ncontent of the array, it simply returns its argument.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = [ 1, 2, 3 ];\nauto b = a.save;\nassert(b is a);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 342,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "pure nothrow @safe T[](T[] a)",
"line" : 342}
]
}
,
{
"name" : "popFront(A) if (!isNarrowString!(A) && isDynamicArray!(A) && isMutable!(A) && !is(A == void[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the range interface primitive $(D popFront) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popFront) is\nequivalent to $(D popFront(array)). For $(GLOSSARY narrow strings),\n$(D popFront) automaticaly advances to the next $(GLOSSARY code\npoint).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popFront();\nassert(a == [ 2, 3 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 366,
"members" : [
{
"name" : "popFront",
"kind" : "function",
"type" : "void(ref A a)",
"comment" : "\nImplements the range interface primitive $(D popFront) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popFront) is\nequivalent to $(D popFront(array)). For $(GLOSSARY narrow strings),\n$(D popFront) automaticaly advances to the next $(GLOSSARY code\npoint).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popFront();\nassert(a == [ 2, 3 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 366}
]
}
,
{
"name" : "popFront(S) if (isNarrowString!(S) && isMutable!(S) && !isStaticArray!(S))",
"kind" : "template",
"protection" : "public",
"line" : 385,
"members" : [
{
"name" : "popFront",
"kind" : "function",
"type" : "pure nothrow @trusted void(ref S str)",
"line" : 385}
]
}
,
{
"name" : "popBack(A) if (isDynamicArray!(A) && !isNarrowString!(A) && isMutable!(A) && !is(A == void[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the range interface primitive $(D popBack) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popBack) is\nequivalent to $(D popBack(array)). For $(GLOSSARY narrow strings), $(D\npopFront) automaticaly eliminates the last $(GLOSSARY code point).\n\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popBack();\nassert(a == [ 1, 2 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 484,
"members" : [
{
"name" : "popBack",
"kind" : "function",
"type" : "void(ref A a)",
"comment" : "\nImplements the range interface primitive $(D popBack) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popBack) is\nequivalent to $(D popBack(array)). For $(GLOSSARY narrow strings), $(D\npopFront) automaticaly eliminates the last $(GLOSSARY code point).\n\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popBack();\nassert(a == [ 1, 2 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 484}
]
}
,
{
"name" : "popBack(A) if (isNarrowString!(A) && isMutable!(A))",
"kind" : "template",
"protection" : "public",
"line" : 501,
"members" : [
{
"name" : "popBack",
"kind" : "function",
"type" : "void(ref A a)",
"line" : 501}
]
}
,
{
"name" : "front(T) if (!isNarrowString!(T[]) && !is(T[] == void[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the range interface primitive $(D front) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.front) is\nequivalent to $(D front(array)). For $(GLOSSARY narrow strings), $(D\nfront) automaticaly returns the first $(GLOSSARY code point) as a $(D\ndchar).\n\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\nassert(a.front == 1);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 552,
"members" : [
{
"name" : "front",
"kind" : "function",
"type" : "T(T[] a)",
"line" : 552}
]
}
,
{
"name" : "front(A) if (isNarrowString!(A))",
"kind" : "template",
"protection" : "public",
"line" : 560,
"members" : [
{
"name" : "front",
"kind" : "function",
"type" : "dchar(A a)",
"line" : 560}
]
}
,
{
"name" : "back(T) if (!isNarrowString!(T[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the range interface primitive $(D back) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.back) is\nequivalent to $(D back(array)). For $(GLOSSARY narrow strings), $(D\nback) automaticaly returns the last $(GLOSSARY code point) as a $(D\ndchar).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\nassert(a.back == 3);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
"line" : 596,
"members" : [
{
"name" : "back",
"kind" : "function",
"type" : "T(T[] a)",
"line" : 596}
]
}
,
{
"name" : "back(A) if (isDynamicArray!(A) && isNarrowString!(A))",
"kind" : "template",
"protection" : "public",
"line" : 615,
"members" : [
{
"name" : "back",
"kind" : "function",
"type" : "dchar(A a)",
"line" : 615}
]
}
,
{
"name" : "overlap(T)",
"kind" : "template",
"protection" : "public",
"line" : 644,
"members" : [
{
"name" : "overlap",
"kind" : "function",
"type" : "pure nothrow @trusted inout(T)[](inout(T)[] r1, inout(T)[] r2)",
"line" : 644}
]
}
,
{
"name" : "insertInPlace(T,Range) if (isInputRange!(Range) && (is(ElementType!(Range) : T) || isSomeString!(T[]) && is(ElementType!(Range) : dchar)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Inserts $(D stuff) (which must be an input range or any number of\n    implicitly convertible items) in $(D array) at position $(D pos).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.insertInPlace(2, [ 1, 2 ]);\nassert(a == [ 1, 2, 1, 2, 3, 4 ]);\na.insertInPlace(3, 10u, 11);\nassert(a == [ 1, 2, 1, 10, 11, 2, 3, 4]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 810,
"members" : [
{
"name" : "insertInPlace",
"kind" : "function",
"type" : "void(ref T[] array, size_t pos, Range stuff)",
"comment" : "\n    Inserts $(D stuff) (which must be an input range or any number of\n    implicitly convertible items) in $(D array) at position $(D pos).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.insertInPlace(2, [ 1, 2 ]);\nassert(a == [ 1, 2, 1, 2, 3, 4 ]);\na.insertInPlace(3, 10u, 11);\nassert(a == [ 1, 2, 1, 10, 11, 2, 3, 4]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 810}
]
}
,
{
"name" : "insertInPlace(T,U...) if (isSomeString!(T[]) && allSatisfy!(isCharOrString,U))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 819,
"members" : [
{
"name" : "insertInPlace",
"kind" : "function",
"type" : "void(ref T[] array, size_t pos, U stuff)",
"comment" : " Ditto \n",
"line" : 819}
]
}
,
{
"name" : "insertInPlace(T,U...) if (!isSomeString!(T[]) && allSatisfy!(isInputRangeOrConvertible!(T),U))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 828,
"members" : [
{
"name" : "insertInPlace",
"kind" : "function",
"type" : "void(ref T[] array, size_t pos, U stuff)",
"comment" : " Ditto \n",
"line" : 828}
]
}
,
{
"name" : "staticFrontConvertible(E,U...)",
"kind" : "template",
"protection" : "public",
"line" : 837,
"members" : [
]
}
,
{
"name" : "staticConvertible(E,U...)",
"kind" : "template",
"protection" : "public",
"line" : 848,
"members" : [
]
}
,
{
"name" : "isCharOrString(T)",
"kind" : "template",
"protection" : "public",
"line" : 858,
"members" : [
{
"name" : "isCharOrString",
"kind" : "variable",
"line" : 860}
]
}
,
{
"name" : "isInputRangeOrConvertible(E)",
"kind" : "template",
"protection" : "public",
"line" : 863,
"members" : [
{
"name" : "isInputRangeOrConvertible(R)",
"kind" : "template",
"protection" : "public",
"line" : 865,
"members" : [
{
"name" : "isInputRangeOrConvertible",
"kind" : "variable",
"line" : 868}
]
}
]
}
,
{
"name" : "makeRangeTuple(E,U...) if (U.length > 0 && is(U[0] : E))",
"kind" : "template",
"protection" : "public",
"line" : 874,
"members" : [
{
"name" : "makeRangeTuple",
"kind" : "function",
"type" : "(E[] place, U stuff)",
"line" : 874}
]
}
,
{
"name" : "makeRangeTuple(E,U...) if (U.length > 0 && isInputRange!(U[0]) && is(ElementType!(U[0]) : E))",
"kind" : "template",
"protection" : "public",
"line" : 888,
"members" : [
{
"name" : "makeRangeTuple",
"kind" : "function",
"type" : "(E[] place, U stuff)",
"line" : 888}
]
}
,
{
"name" : "insertInPlaceImpl(T,Range) if (isInputRange!(Range) && (is(ElementType!(Range) : T) || isSomeString!(T[]) && is(ElementType!(Range) : dchar)))",
"kind" : "template",
"protection" : "public",
"line" : 898,
"members" : [
{
"name" : "insertInPlaceImpl",
"kind" : "function",
"type" : "void(ref T[] array, size_t pos, Range stuff)",
"line" : 898}
]
}
,
{
"name" : "sameHead(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns whether the $(D front)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    starts at index $(D 0).\n  \n",
"line" : 1031,
"members" : [
{
"name" : "sameHead",
"kind" : "function",
"type" : "bool(in T[] lhs, in T[] rhs)",
"line" : 1031}
]
}
,
{
"name" : "replicate(S) if (isDynamicArray!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns an array that consists of $(D s) (which must be an input\nrange) repeated $(D n) times. This function allocates, fills, and\nreturns a new array. For a lazy version, refer to $(XREF range, repeat).\n \n",
"line" : 1059,
"members" : [
{
"name" : "replicate",
"kind" : "function",
"type" : "ElementEncodingType!(S)[](S s, size_t n)",
"comment" : "\nReturns an array that consists of $(D s) (which must be an input\nrange) repeated $(D n) times. This function allocates, fills, and\nreturns a new array. For a lazy version, refer to $(XREF range, repeat).\n \n",
"line" : 1059}
]
}
,
{
"name" : "replicate(S) if (isInputRange!(S) && !isDynamicArray!(S))",
"kind" : "template",
"protection" : "public",
"line" : 1082,
"members" : [
{
"name" : "replicate",
"kind" : "function",
"type" : "ElementType!(S)[](S s, size_t n)",
"line" : 1082}
]
}
,
{
"name" : "split(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSplit the string $(D s) into an array of words, using whitespace as\ndelimiter. Runs of whitespace are merged together (no empty words are produced).\n \n",
"line" : 1111,
"members" : [
{
"name" : "split",
"kind" : "function",
"type" : "S[](S s)",
"comment" : "\nSplit the string $(D s) into an array of words, using whitespace as\ndelimiter. Runs of whitespace are merged together (no empty words are produced).\n \n",
"line" : 1111}
]
}
,
{
"name" : "splitter(C) if (isSomeString!(C[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSplits a string by whitespace.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = \" a     bcd   ef gh \";\nassert(equal(splitter(a), [\"\", \"a\", \"bcd\", \"ef\", \"gh\"][]));\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array, std.algorithm: equal;))\n \n",
"line" : 1170,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "(C[] s)",
"comment" : "\nSplits a string by whitespace.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = \" a     bcd   ef gh \";\nassert(equal(splitter(a), [\"\", \"a\", \"bcd\", \"ef\", \"gh\"][]));\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array, std.algorithm: equal;))\n \n",
"line" : 1170}
]
}
,
{
"name" : "split(S1,S2) if (isForwardRange!(Unqual!(S1)) && isForwardRange!(S2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Splits $(D s) into an array, using $(D delim) as the delimiter.\n \n",
"line" : 1193,
"members" : [
{
"name" : "split",
"kind" : "function",
"type" : "Unqual!(S1)[](S1 s, S2 delim)",
"comment" : "\n Splits $(D s) into an array, using $(D delim) as the delimiter.\n \n",
"line" : 1193}
]
}
,
{
"name" : "join(RoR,R) if (isInputRange!(RoR) && isInputRange!(ElementType!(RoR)) && isForwardRange!(R) && is(Unqual!(ElementType!(ElementType!(RoR))) == Unqual!(ElementType!(R))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Concatenates all of the ranges in $(D ror) together into one array using\n   $(D sep) as the separator if present.\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n--------------------\nassert(join([\"hello\", \"silly\", \"world\"], \" \") == \"hello silly world\");\nassert(join([\"hello\", \"silly\", \"world\"]) == \"hellosillyworld\");\n\nassert(join([[1, 2, 3], [4, 5]], [72, 73]) == [1, 2, 3, 72, 73, 4, 5]);\nassert(join([[1, 2, 3], [4, 5]]) == [1, 2, 3, 4, 5]);\n--------------------\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n  \n",
"line" : 1273,
"members" : [
{
"name" : "join",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror, R sep)",
"comment" : "\n   Concatenates all of the ranges in $(D ror) together into one array using\n   $(D sep) as the separator if present.\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n--------------------\nassert(join([\"hello\", \"silly\", \"world\"], \" \") == \"hello silly world\");\nassert(join([\"hello\", \"silly\", \"world\"]) == \"hellosillyworld\");\n\nassert(join([[1, 2, 3], [4, 5]], [72, 73]) == [1, 2, 3, 72, 73, 4, 5]);\nassert(join([[1, 2, 3], [4, 5]]) == [1, 2, 3, 4, 5]);\n--------------------\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n  \n",
"line" : 1273}
]
}
,
{
"name" : "join(RoR) if (isInputRange!(RoR) && isInputRange!(ElementType!(RoR)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1283,
"members" : [
{
"name" : "join",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror)",
"comment" : " Ditto\n",
"line" : 1283}
]
}
,
{
"name" : "joinImpl(RoR,R) if (isInputRange!(RoR) && isInputRange!(ElementType!(RoR)) && !isDynamicArray!(ElementType!(RoR)) && isForwardRange!(R) && is(Unqual!(ElementType!(ElementType!(RoR))) == Unqual!(ElementType!(R))))",
"kind" : "template",
"protection" : "public",
"line" : 1302,
"members" : [
{
"name" : "joinImpl",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror, R sep)",
"line" : 1302}
]
}
,
{
"name" : "joinImpl(RoR,R) if (isForwardRange!(RoR) && hasLength!(RoR) && isDynamicArray!(ElementType!(RoR)) && isForwardRange!(R) && is(Unqual!(ElementType!(ElementType!(RoR))) == Unqual!(ElementType!(R))))",
"kind" : "template",
"protection" : "public",
"line" : 1328,
"members" : [
{
"name" : "joinImpl",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror, R sep)",
"line" : 1328}
]
}
,
{
"name" : "joinImpl(RoR,R) if (isInputRange!(RoR) && (isForwardRange!(RoR) && !hasLength!(RoR) || !isForwardRange!(RoR)) && isDynamicArray!(ElementType!(RoR)) && isForwardRange!(R) && is(Unqual!(ElementType!(ElementType!(RoR))) == Unqual!(ElementType!(R))))",
"kind" : "template",
"protection" : "public",
"line" : 1363,
"members" : [
{
"name" : "joinImpl",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror, R sep)",
"line" : 1363}
]
}
,
{
"name" : "joinImpl(RoR) if (isInputRange!(RoR) && isInputRange!(ElementType!(RoR)) && !isDynamicArray!(ElementType!(RoR)))",
"kind" : "template",
"protection" : "public",
"line" : 1400,
"members" : [
{
"name" : "joinImpl",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror)",
"line" : 1400}
]
}
,
{
"name" : "joinImpl(RoR) if (isForwardRange!(RoR) && hasLength!(RoR) && isDynamicArray!(ElementType!(RoR)))",
"kind" : "template",
"protection" : "public",
"line" : 1420,
"members" : [
{
"name" : "joinImpl",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror)",
"line" : 1420}
]
}
,
{
"name" : "joinImpl(RoR) if (isInputRange!(RoR) && (isForwardRange!(RoR) && !hasLength!(RoR) || !isForwardRange!(RoR)) && isDynamicArray!(ElementType!(RoR)))",
"kind" : "template",
"protection" : "public",
"line" : 1444,
"members" : [
{
"name" : "joinImpl",
"kind" : "function",
"type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror)",
"line" : 1444}
]
}
,
{
"name" : "replace(E,R1,R2) if (isDynamicArray!(E[]) && isForwardRange!(R1) && isForwardRange!(R2) && (hasLength!(R2) || isSomeString!(R2)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replace occurrences of $(D from) with $(D to) in $(D subject). Returns a new\n    array without changing the contents of $(D subject), or the original array\n    if no match is found.\n \n",
"line" : 1539,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "E[](E[] subject, R1 from, R2 to)",
"comment" : "\n    Replace occurrences of $(D from) with $(D to) in $(D subject). Returns a new\n    array without changing the contents of $(D subject), or the original array\n    if no match is found.\n \n",
"line" : 1539}
]
}
,
{
"name" : "replaceInto(E,Sink,R1,R2) if (isOutputRange!(Sink,E) && isDynamicArray!(E[]) && isForwardRange!(R1) && isForwardRange!(R2) && (hasLength!(R2) || isSomeString!(R2)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Same as above, but outputs the result via OutputRange $(D sink).\n    If no match is found the original array is transfered to $(D sink) as is.\n",
"line" : 1561,
"members" : [
{
"name" : "replaceInto",
"kind" : "function",
"type" : "void(Sink sink, E[] subject, R1 from, R2 to)",
"comment" : "\n    Same as above, but outputs the result via OutputRange $(D sink).\n    If no match is found the original array is transfered to $(D sink) as is.\n",
"line" : 1561}
]
}
,
{
"name" : "replaceInPlace(T,Range) if (isDynamicArray!(Range) && is(ElementEncodingType!(Range) : T) && !is(T == const(T)) && !is(T == immutable(T)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Expands or\n    shrinks the array as needed.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.replaceInPlace(1, 3, [ 9, 9, 9 ]);\nassert(a == [ 1, 9, 9, 9, 4 ]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 1752,
"members" : [
{
"name" : "replaceInPlace",
"kind" : "function",
"type" : "void(ref T[] array, size_t from, size_t to, Range stuff)",
"comment" : "\n    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Expands or\n    shrinks the array as needed.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.replaceInPlace(1, 3, [ 9, 9, 9 ]);\nassert(a == [ 1, 9, 9, 9, 4 ]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 1752}
]
}
,
{
"name" : "replaceInPlace(T,Range) if (isInputRange!(Range) && (!isDynamicArray!(Range) && is(ElementType!(Range) : T) || isDynamicArray!(Range) && is(ElementType!(Range) : T) && (is(T == const(T)) || is(T == immutable(T))) || isSomeString!(T[]) && is(ElementType!(Range) : dchar)))",
"kind" : "template",
"protection" : "public",
"line" : 1780,
"members" : [
{
"name" : "replaceInPlace",
"kind" : "function",
"type" : "void(ref T[] array, size_t from, size_t to, Range stuff)",
"line" : 1780}
]
}
,
{
"name" : "replaceFirst(E,R1,R2) if (isDynamicArray!(E[]) && isForwardRange!(R1) && is(typeof(appender!(E[])().put(from[0..1]))) && isForwardRange!(R2) && is(typeof(appender!(E[])().put(to[0..1]))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replaces the first occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\n \n",
"line" : 1881,
"members" : [
{
"name" : "replaceFirst",
"kind" : "function",
"type" : "E[](E[] subject, R1 from, R2 to)",
"comment" : "\n    Replaces the first occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\n \n",
"line" : 1881}
]
}
,
{
"name" : "replaceSlice(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns an array that is $(D s) with $(D slice) replaced by\n    $(D replacement[]).\n \n",
"line" : 1935,
"members" : [
{
"name" : "replaceSlice",
"kind" : "function",
"type" : "inout(T)[](inout(T)[] s, in T[] slice, in T[] replacement)",
"comment" : "\n    Returns an array that is $(D s) with $(D slice) replaced by\n    $(D replacement[]).\n \n",
"line" : 1935}
]
}
,
{
"name" : "Appender(A : T[],T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nImplements an output range that appends data to an array. This is\nrecommended over $(D a ~= data) when appending many elements because it is more\nefficient.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto app = appender!string();\nstring b = \"abcdefg\";\nforeach (char c; b) app.put(c);\nassert(app.data == \"abcdefg\");\n\nint[] a = [ 1, 2 ];\nauto app2 = appender(a);\napp2.put(3);\napp2.put([ 4, 5, 6 ]);\nassert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
"line" : 1989,
"members" : [
{
"name" : "Appender",
"kind" : "struct",
"protection" : "public",
"line" : 1989,
"members" : [
{
"name" : "Data",
"kind" : "struct",
"protection" : "public",
"line" : 1991,
"members" : [
{
"name" : "capacity",
"kind" : "variable",
"type" : "size_t",
"line" : 1992}
,
{
"name" : "arr",
"kind" : "variable",
"type" : "Unqual!(T)[]",
"line" : 1993}
]
}
,
{
"name" : "_data",
"kind" : "variable",
"type" : "Data*",
"line" : 1996}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T[] arr)",
"comment" : "\nConstruct an appender with a given array.  Note that this does not copy the\ndata.  If the array has a larger capacity as determined by arr.capacity,\nit will be used by the appender.  After initializing an appender on an array,\nappending to the original array will reallocate.\n",
"line" : 2004}
,
{
"name" : "reserve",
"kind" : "function",
"type" : "void(size_t newCapacity)",
"comment" : "\nReserve at least newCapacity elements for appending.  Note that more elements\nmay be reserved than requested.  If newCapacity < capacity, then nothing is\ndone.\n",
"line" : 2029}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "const size_t()",
"comment" : "\nReturns the capacity of the array (the maximum number of elements the\nmanaged array can accommodate before triggering a reallocation).  If any\nappending will reallocate, $(D capacity) returns $(D 0).\n \n",
"line" : 2070}
,
{
"name" : "data",
"kind" : "function",
"type" : "inout inout(T)[]()",
"comment" : "\nReturns the managed array.\n \n",
"line" : 2078}
,
{
"name" : "ensureAddable",
"kind" : "function",
"type" : "void(size_t nelems)",
"line" : 2084}
,
{
"name" : "newCapacity",
"kind" : "function",
"type" : "size_t(size_t newlength)",
"line" : 2124}
,
{
"name" : "put(U) if (isImplicitlyConvertible!(U,T) || isSomeChar!(T) && isSomeChar!(U))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAppends one item to the managed array.\n \n",
"line" : 2137,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(U item)",
"comment" : "\nAppends one item to the managed array.\n \n",
"line" : 2137}
]
}
,
{
"name" : "put(Range) if (isInputRange!(Unqual!(Range)) && !isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"line" : 2157,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(Range items)",
"line" : 2157}
]
}
,
{
"name" : "put(Range) if (isInputRange!(Range) && is(typeof(Appender.init.put(items.front))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAppends an entire range to the managed array.\n \n",
"line" : 2166,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(Range items)",
"comment" : "\nAppends an entire range to the managed array.\n \n",
"line" : 2166}
]
}
]
}
]
}
,
{
"name" : "RefAppender(A : T[],T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nAn appender that can update an array in-place.  It forwards all calls to an\nunderlying appender implementation.  Any calls made to the appender also update\nthe pointer to the original array passed in.\n",
"line" : 2256,
"members" : [
{
"name" : "RefAppender",
"kind" : "struct",
"protection" : "public",
"line" : 2256,
"members" : [
{
"name" : "impl",
"kind" : "variable",
"type" : "Appender!(A,T)",
"line" : 2259}
,
{
"name" : "arr",
"kind" : "variable",
"type" : "T[]*",
"line" : 2260}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T[]* arr)",
"comment" : "\nConstruct a ref appender with a given array reference.  This does not copy the\ndata.  If the array has a larger capacity as determined by arr.capacity, it\nwill be used by the appender.  $(D RefAppender) assumes that arr is a non-null\nvalue.\n\nNote, do not use builtin appending (i.e. ~=) on the original array passed in\nuntil you are done with the appender, because calls to the appender override\nthose appends.\n",
"line" : 2273}
,
{
"name" : "opDispatch(string fn,Args...) if (is(typeof(mixin(\"impl.\" ~ fn ~ \"(args)\"))))",
"kind" : "template",
"protection" : "public",
"line" : 2279,
"members" : [
{
"name" : "opDispatch",
"kind" : "function",
"type" : "(Args args)",
"line" : 2279}
]
}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "const size_t()",
"comment" : "\nReturns the capacity of the array (the maximum number of elements the\nmanaged array can accommodate before triggering a reallocation).  If any\nappending will reallocate, $(D capacity) returns $(D 0).\n \n",
"line" : 2291}
,
{
"name" : "data",
"kind" : "function",
"type" : "inout inout(T)[]()",
"comment" : "\nReturns the managed array.\n \n",
"line" : 2299}
]
}
]
}
,
{
"name" : "appender(A : E[],E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Convenience function that returns an $(D Appender!(A)) object initialized\n    with $(D array).\n \n",
"line" : 2309,
"members" : [
{
"name" : "appender",
"kind" : "function",
"type" : "Appender!(E[])(A array = null)",
"comment" : "\n    Convenience function that returns an $(D Appender!(A)) object initialized\n    with $(D array).\n \n",
"line" : 2309}
]
}
,
{
"name" : "appender(A : E[]*,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Convenience function that returns a $(D RefAppender!(A)) object initialized\n    with $(D array).  Don't use null for the $(D array) pointer, use the other\n    version of $(D appender) instead.\n \n",
"line" : 2365,
"members" : [
{
"name" : "appender",
"kind" : "function",
"type" : "RefAppender!(E[])(A array)",
"comment" : "\n    Convenience function that returns a $(D RefAppender!(A)) object initialized\n    with $(D array).  Don't use null for the $(D array) pointer, use the other\n    version of $(D appender) instead.\n \n",
"line" : 2365}
]
}
,
{
"name" : "SimpleSlice(T)",
"kind" : "struct",
"protection" : "public",
"line" : 2406,
"members" : [
{
"name" : "SimpleSlice",
"kind" : "struct",
"protection" : "public",
"line" : 2406,
"members" : [
{
"name" : "_b",
"kind" : "variable",
"type" : "T*",
"line" : 2407}
,
{
"name" : "_e",
"kind" : "variable",
"type" : "T*",
"line" : 2407}
,
{
"name" : "__ctor(U...)",
"kind" : "template",
"protection" : "public",
"line" : 2409,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(U values)",
"line" : 2409}
]
}
,
{
"name" : "opAssign(R)",
"kind" : "template",
"protection" : "public",
"line" : 2416,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(R anotherSlice)",
"line" : 2416}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n   Range primitives.\n \n",
"line" : 2442}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 2449}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 2456}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 2463}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 2470}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t n)",
"comment" : " Ditto\n",
"line" : 2477}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "const const(T)(size_t n)",
"comment" : " Ditto\n",
"line" : 2484}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T value, size_t n)",
"comment" : " Ditto\n",
"line" : 2491}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "SimpleSliceLvalue!(T)()",
"comment" : " Ditto\n",
"line" : 2498}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "SimpleSliceLvalue!(T)(size_t x, size_t y)",
"comment" : " Ditto\n",
"line" : 2507}
,
{
"name" : "length",
"kind" : "function",
"type" : "const size_t()",
"comment" : " Returns the length of the slice.\n",
"line" : 2517}
,
{
"name" : "length",
"kind" : "function",
"type" : "void(size_t newLength)",
"comment" : "\n        Sets the length of the slice. Newly added elements will be filled with\n        $(D T.init).\n         \n",
"line" : 2526}
,
{
"name" : "opCat(R)",
"kind" : "template",
"protection" : "public",
"comment" : " Concatenation.\n",
"line" : 2536,
"members" : [
{
"name" : "opCat",
"kind" : "function",
"type" : "SimpleSlice(R another)",
"comment" : " Concatenation.\n",
"line" : 2536}
]
}
,
{
"name" : "opCatAssign(R)",
"kind" : "template",
"protection" : "public",
"comment" : " Concatenation with rebinding.\n",
"line" : 2549,
"members" : [
{
"name" : "opCatAssign",
"kind" : "function",
"type" : "void(R another)",
"comment" : " Concatenation with rebinding.\n",
"line" : 2549}
]
}
]
}
]
}
,
{
"name" : "SimpleSliceLvalue(T)",
"kind" : "struct",
"protection" : "public",
"line" : 2558,
"members" : [
{
"name" : "SimpleSliceLvalue",
"kind" : "struct",
"protection" : "public",
"line" : 2558,
"members" : [
{
"name" : "_s",
"kind" : "variable",
"type" : "SimpleSlice!(T)",
"line" : 2559}
,
{
"name" : "opAssign(R)",
"kind" : "template",
"protection" : "public",
"line" : 2562,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(R anotherSlice)",
"line" : 2562}
]
}
]
}
]
}
]
}
,
{
"name" : "std.ascii",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/ascii.d",
"comment" : "\n    Functions which operate on ASCII characters.\n\n    All of the functions in std.ascii accept unicode characters but effectively\n    ignore them. All $(D isX) functions return $(D false) for unicode\n    characters, and all $(D toX) functions do nothing to unicode characters.\n\n    For functions which operate on unicode characters, see\n    $(LINK2 std_uni.html, std.uni).\n\n    References:\n        $(LINK2 http:\/\/www.digitalmars.com\/d\/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org\/wiki\/Ascii, Wikipedia)\n\n    Macros:\n        WIKI=Phobos\/StdASCII\n\n    Copyright: Copyright 2000 -\n    License:   $(WEB www.boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std\/_ascii.d)\n  \n",
"members" : [
{
"name" : "hexDigits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " 0..9A..F\n",
"line" : 30}
,
{
"name" : "fullHexDigits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " 0..9A..Fa..f\n",
"line" : 31}
,
{
"name" : "digits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " 0..9\n",
"line" : 32}
,
{
"name" : "octalDigits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " 0..7\n",
"line" : 33}
,
{
"name" : "lowercase",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " a..z\n",
"line" : 34}
,
{
"name" : "letters",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " A..Za..z\n",
"line" : 36}
,
{
"name" : "uppercase",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " A..Z\n",
"line" : 37}
,
{
"name" : "whitespace",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " ASCII whitespace\n",
"line" : 38}
,
{
"name" : "newline",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " Newline sequence for this system.\n",
"line" : 49}
,
{
"name" : "isAlphaNum",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a letter or a number (0..9, a..z, A..Z).\n  \n",
"line" : 58}
,
{
"name" : "isAlpha",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is an ASCII letter (A..Z, a..z).\n  \n",
"line" : 76}
,
{
"name" : "isLower",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a lowercase ASCII letter (a..z).\n  \n",
"line" : 94}
,
{
"name" : "isUpper",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is an uppercase ASCII letter (A..Z).\n  \n",
"line" : 112}
,
{
"name" : "isDigit",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a digit (0..9).\n  \n",
"line" : 130}
,
{
"name" : "isOctalDigit",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a digit in base 8 (0..7).\n  \n",
"line" : 148}
,
{
"name" : "isHexDigit",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a digit in base 16 (0..9, A..F, a..f).\n  \n",
"line" : 166}
,
{
"name" : "isWhite",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Whether or not $(D c) is a whitespace character. That includes the space,\n    tab, vertical tab, form feed, carriage return, and linefeed characters.\n  \n",
"line" : 185}
,
{
"name" : "isControl",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a control character.\n  \n",
"line" : 203}
,
{
"name" : "isPunctuation",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Whether or not $(D c) is a punctuation character. That includes all ASCII\n    characters which are not control characters, letters, digits, or whitespace.\n  \n",
"line" : 223}
,
{
"name" : "isGraphical",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Whether or not $(D c) is a printable character other than the space\n    character.\n  \n",
"line" : 244}
,
{
"name" : "isPrintable",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Whether or not $(D c) is a printable character - including the space\n    character.\n  \n",
"line" : 264}
,
{
"name" : "isASCII",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Whether or not $(D c) is in the ASCII character set - i.e. in the range\n    0..0x7F.\n  \n",
"line" : 285}
,
{
"name" : "toLower",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe dchar(dchar c)",
"comment" : "\n    If $(D c) is an uppercase ASCII character, then its corresponding lowercase\n    letter is returned. Otherwise, $(D c) is returned.\n  \n",
"line" : 303}
,
{
"name" : "toUpper",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe dchar(dchar c)",
"comment" : "\n    If $(D c) is a lowercase ASCII character, then its corresponding uppercase\n    letter is returned. Otherwise, $(D c) is returned.\n  \n",
"line" : 330}
,
{
"name" : "_SPC",
"kind" : "enum member",
"protection" : "public",
"line" : 360}
,
{
"name" : "_CTL",
"kind" : "enum member",
"protection" : "public",
"line" : 361}
,
{
"name" : "_BLK",
"kind" : "enum member",
"protection" : "public",
"line" : 362}
,
{
"name" : "_HEX",
"kind" : "enum member",
"protection" : "public",
"line" : 363}
,
{
"name" : "_UC",
"kind" : "enum member",
"protection" : "public",
"line" : 364}
,
{
"name" : "_LC",
"kind" : "enum member",
"protection" : "public",
"line" : 365}
,
{
"name" : "_PNC",
"kind" : "enum member",
"protection" : "public",
"line" : 366}
,
{
"name" : "_DIG",
"kind" : "enum member",
"protection" : "public",
"line" : 367}
,
{
"name" : "_ALP",
"kind" : "enum member",
"protection" : "public",
"line" : 368}
,
{
"name" : "_ctype",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(ubyte[128LU])",
"line" : 371}
]
}
,
{
"name" : "std.base64",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/base64.d",
"comment" : "\n Encoding \/ Decoding Base64 format.\n\n Implemented according to $(WEB tools.ietf.org\/html\/rfc4648,\n RFC 4648 - The Base16, Base32, and Base64 Data Encodings).\n\n Example:\n $(D_RUN_CODE\n $(ARGS\n -----\nubyte[] data = [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e];\n\nconst(char)[] encoded = Base64.encode(data);\nassert(encoded == \"FPucA9l+\");\n\nubyte[] decoded = Base64.decode(\"FPucA9l+\");\nassert(decoded == [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e]);\n -----\n ), $(ARGS), $(ARGS), $(ARGS import std.base64;))\n Support Range interface using Encoder \/ Decoder.\n\n Example:\n $(D_RUN_CODE\n $(ARGS\n -----\n \/\/ Create MIME Base64 with CRLF, per line 76.\nFile f = File(\".\/text.txt\", \"r\");\nscope(exit) f.close();\n\nAppender!string mime64 = appender!string;\n\nforeach (encoded; Base64.encoder(f.byChunk(57)))\n{\n    mime64.put(encoded);\n    mime64.put(\"\\r\\n\");\n}\n\nwriteln(mime64.data);\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.array, std.stdio: File, writeln;))\n\n Copyright: Masahiro Nakagawa 2010-.\n License:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Masahiro Nakagawa, Daniel Murphy (Single value Encoder and Decoder)\n Source:    $(PHOBOSSRC std\/_base64.d)\n \n",
"members" : [
{
"name" : "Base64",
"kind" : "alias",
"protection" : "public",
"comment" : "\n The Base64\n \n",
"line" : 61}
,
{
"name" : "Base64URL",
"kind" : "alias",
"protection" : "public",
"comment" : "\n The \"URL and Filename safe\" Base64\n \n",
"line" : 67}
,
{
"name" : "Base64Impl(char Map62th,char Map63th,char Padding = '=')",
"kind" : "template",
"protection" : "public",
"comment" : "\n Core implementation for Base64 format.\n\n Example:\n -----\n alias Base64Impl!('+', '\/')                   Base64;    \/\/ The Base64 format(Already defined).\n alias Base64Impl!('!', '=', Base64.NoPadding) Base64Re;  \/\/ non-standard Base64 format for Regular expression\n -----\n\n NOTE:\n  encoded-string doesn't have padding character if set Padding parameter to NoPadding.\n \n",
"line" : 82,
"members" : [
{
"name" : "NoPadding",
"kind" : "variable",
"comment" : " represents no-padding encoding\n",
"line" : 84}
,
{
"name" : "EncodeMap",
"kind" : "variable",
"line" : 107}
,
{
"name" : "encodeLength",
"kind" : "function",
"type" : "size_t(in size_t sourceLength)",
"comment" : "\n Calculates the minimum length for encoding.\n\n Params:\n  sourceLength = the length of source array.\n\n Returns:\n  the calculated length using $(D_PARAM sourceLength).\n     \n",
"line" : 120}
,
{
"name" : "encode(R1,R2) if (isArray!(R1) && is(ElementType!(R1) : ubyte) && is(R2 == char[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes $(D_PARAM source) into $(D_PARAM buffer).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = a buffer to store encoded result.\n\n Returns:\n  the encoded string that slices buffer.\n     \n",
"line" : 143,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "char[](in R1 source, R2 buffer)",
"line" : 143}
]
}
,
{
"name" : "encode(R1,R2) if (!isArray!(R1) && isInputRange!(R1) && is(ElementType!(R1) : ubyte) && hasLength!(R1) && is(R2 == char[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n     \n",
"line" : 204,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "char[](R1 source, R2 buffer)",
"comment" : "\n ditto\n     \n",
"line" : 204}
]
}
,
{
"name" : "encode(R1,R2) if (isArray!(R1) && is(ElementType!(R1) : ubyte) && !is(R2 == char[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = an $(D OutputRange) to put encoded result.\n\n Returns:\n  the number of calling put.\n     \n",
"line" : 283,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "size_t(in R1 source, R2 range)",
"comment" : "\n Encodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = an $(D OutputRange) to put encoded result.\n\n Returns:\n  the number of calling put.\n     \n",
"line" : 283}
]
}
,
{
"name" : "encode(R1,R2) if (!isArray!(R1) && isInputRange!(R1) && is(ElementType!(R1) : ubyte) && hasLength!(R1) && !is(R2 == char[]) && isOutputRange!(R2,char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n     \n",
"line" : 346,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "size_t(R1 source, R2 range)",
"comment" : "\n ditto\n     \n",
"line" : 346}
]
}
,
{
"name" : "encode(Range) if (isArray!(Range) && is(ElementType!(Range) : ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes $(D_PARAM source) to new buffer.\n\n Shortcut to encode(source, buffer) function.\n     \n",
"line" : 420,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "char[](Range source)",
"line" : 420}
]
}
,
{
"name" : "encode(Range) if (!isArray!(Range) && isInputRange!(Range) && is(ElementType!(Range) : ubyte) && hasLength!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n     \n",
"line" : 429,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "char[](Range source)",
"comment" : "\n ditto\n     \n",
"line" : 429}
]
}
,
{
"name" : "Encoder(Range) if (isInputRange!(Range) && (is(ElementType!(Range) : const(ubyte)[]) || is(ElementType!(Range) : const(char)[])))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Range that encodes chunk data at a time.\n     \n",
"line" : 441,
"members" : [
{
"name" : "Encoder",
"kind" : "struct",
"protection" : "public",
"line" : 441,
"members" : [
{
"name" : "range_",
"kind" : "variable",
"type" : "Range",
"line" : 443}
,
{
"name" : "buffer_",
"kind" : "variable",
"type" : "char[]",
"line" : 444}
,
{
"name" : "encoded_",
"kind" : "variable",
"type" : "char[]",
"line" : 444}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range range)",
"line" : 448}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
"line" : 462}
,
{
"name" : "front",
"kind" : "function",
"type" : "char[]()",
"comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the encoded string.\n         \n",
"line" : 475}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
"line" : 487}
,
{
"name" : "doEncoding",
"kind" : "function",
"type" : "void()",
"line" : 526}
]
}
]
}
,
{
"name" : "Encoder(Range) if (isInputRange!(Range) && is(ElementType!(Range) : ubyte))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Range that encodes single character at a time.\n     \n",
"line" : 542,
"members" : [
{
"name" : "Encoder",
"kind" : "struct",
"protection" : "public",
"line" : 542,
"members" : [
{
"name" : "range_",
"kind" : "variable",
"type" : "Range",
"line" : 544}
,
{
"name" : "first",
"kind" : "variable",
"type" : "ubyte",
"line" : 545}
,
{
"name" : "pos",
"kind" : "variable",
"type" : "int",
"line" : 546}
,
{
"name" : "padding",
"kind" : "variable",
"type" : "int",
"line" : 546}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range range)",
"line" : 550}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
"line" : 570}
,
{
"name" : "front",
"kind" : "function",
"type" : "ubyte()",
"comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the encoded character.\n         \n",
"line" : 586}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
"line" : 598}
]
}
]
}
,
{
"name" : "encoder(Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Encoder).\n\n Default $(D Encoder) encodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nFile f = File(\"text.txt\", \"r\");\nscope(exit) f.close();\n\nuint line = 0;\nforeach (encoded; Base64.encoder(f.byLine()))\n{\n    writeln(++line, \". \", encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: File, writeln;))\n\n In addition, You can use $(D Encoder) that returns encoded single character.\n This $(D Encoder) performs Range-based and lazy encoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nubyte[] data = cast(ubyte[]) \"0123456789\";\n\n \/\/ The ElementType of data is not aggregation type\nforeach (encoded; Base64.encoder(data))\n{\n    writeln(encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;))\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Encoder) object instantiated and initialized according to the arguments.\n     \n",
"line" : 712,
"members" : [
{
"name" : "encoder",
"kind" : "function",
"type" : "Encoder!(Range)(Range range)",
"comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Encoder).\n\n Default $(D Encoder) encodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nFile f = File(\"text.txt\", \"r\");\nscope(exit) f.close();\n\nuint line = 0;\nforeach (encoded; Base64.encoder(f.byLine()))\n{\n    writeln(++line, \". \", encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: File, writeln;))\n\n In addition, You can use $(D Encoder) that returns encoded single character.\n This $(D Encoder) performs Range-based and lazy encoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nubyte[] data = cast(ubyte[]) \"0123456789\";\n\n \/\/ The ElementType of data is not aggregation type\nforeach (encoded; Base64.encoder(data))\n{\n    writeln(encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;))\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Encoder) object instantiated and initialized according to the arguments.\n     \n",
"line" : 712}
]
}
,
{
"name" : "DecodeMap",
"kind" : "variable",
"type" : "int[(char).max + 1]",
"line" : 721}
,
{
"name" : "decodeLength",
"kind" : "function",
"type" : "size_t(in size_t sourceLength)",
"comment" : "\n Calculates the minimum length for decoding.\n\n Params:\n  sourceLength = the length of source array.\n\n Returns:\n  calculated length using $(D_PARAM sourceLength).\n     \n",
"line" : 748}
,
{
"name" : "realDecodeLength(R)",
"kind" : "template",
"protection" : "public",
"line" : 760,
"members" : [
{
"name" : "realDecodeLength",
"kind" : "function",
"type" : "size_t(R source)",
"line" : 760}
]
}
,
{
"name" : "decode(R1,R2) if (isArray!(R1) && is(ElementType!(R1) : dchar) && is(R2 == ubyte[]) && isOutputRange!(R2,ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Decodes $(D_PARAM source) into $(D_PARAM buffer).\n\n Params:\n  source = an $(D InputRange) to decode.\n  buffer = a buffer to store decoded result.\n\n Returns:\n  the decoded string that slices buffer.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n     \n",
"line" : 793,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "ubyte[](in R1 source, R2 buffer)",
"line" : 793}
]
}
,
{
"name" : "decode(R1,R2) if (!isArray!(R1) && isInputRange!(R1) && is(ElementType!(R1) : dchar) && hasLength!(R1) && is(R2 == ubyte[]) && isOutputRange!(R2,ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n     \n",
"line" : 857,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "ubyte[](R1 source, R2 buffer)",
"comment" : "\n ditto\n     \n",
"line" : 857}
]
}
,
{
"name" : "decode(R1,R2) if (isArray!(R1) && is(ElementType!(R1) : dchar) && !is(R2 == ubyte[]) && isOutputRange!(R2,ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Decodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to decode.\n  range  = an $(D OutputRange) to put decoded result\n\n Returns:\n  the number of calling put.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n     \n",
"line" : 939,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "size_t(in R1 source, R2 range)",
"comment" : "\n Decodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to decode.\n  range  = an $(D OutputRange) to put decoded result\n\n Returns:\n  the number of calling put.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n     \n",
"line" : 939}
]
}
,
{
"name" : "decode(R1,R2) if (!isArray!(R1) && isInputRange!(R1) && is(ElementType!(R1) : dchar) && hasLength!(R1) && !is(R2 == ubyte[]) && isOutputRange!(R2,ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n     \n",
"line" : 1005,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "size_t(R1 source, R2 range)",
"comment" : "\n ditto\n     \n",
"line" : 1005}
]
}
,
{
"name" : "decode(Range) if (isArray!(Range) && is(ElementType!(Range) : dchar))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Decodes $(D_PARAM source) into new buffer.\n\n Shortcut to decode(source, buffer) function.\n     \n",
"line" : 1078,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "ubyte[](Range source)",
"line" : 1078}
]
}
,
{
"name" : "decode(Range) if (!isArray!(Range) && isInputRange!(Range) && is(ElementType!(Range) : dchar) && hasLength!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n     \n",
"line" : 1087,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "ubyte[](Range source)",
"comment" : "\n ditto\n     \n",
"line" : 1087}
]
}
,
{
"name" : "Decoder(Range) if (isInputRange!(Range) && (is(ElementType!(Range) : const(char)[]) || is(ElementType!(Range) : const(ubyte)[])))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Range that decodes chunk data at a time.\n     \n",
"line" : 1099,
"members" : [
{
"name" : "Decoder",
"kind" : "struct",
"protection" : "public",
"line" : 1099,
"members" : [
{
"name" : "range_",
"kind" : "variable",
"type" : "Range",
"line" : 1101}
,
{
"name" : "buffer_",
"kind" : "variable",
"type" : "ubyte[]",
"line" : 1102}
,
{
"name" : "decoded_",
"kind" : "variable",
"type" : "ubyte[]",
"line" : 1102}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range range)",
"line" : 1106}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
"line" : 1120}
,
{
"name" : "front",
"kind" : "function",
"type" : "ubyte[]()",
"comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the decoded result.\n         \n",
"line" : 1133}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
"line" : 1145}
,
{
"name" : "doDecoding",
"kind" : "function",
"type" : "void()",
"line" : 1181}
]
}
]
}
,
{
"name" : "Decoder(Range) if (isInputRange!(Range) && is(ElementType!(Range) : char))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Range that decodes single character at a time.\n     \n",
"line" : 1210,
"members" : [
{
"name" : "Decoder",
"kind" : "struct",
"protection" : "public",
"line" : 1210,
"members" : [
{
"name" : "range_",
"kind" : "variable",
"type" : "Range",
"line" : 1212}
,
{
"name" : "first",
"kind" : "variable",
"type" : "ubyte",
"line" : 1213}
,
{
"name" : "pos",
"kind" : "variable",
"type" : "int",
"line" : 1214}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range range)",
"line" : 1218}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
"line" : 1241}
,
{
"name" : "front",
"kind" : "function",
"type" : "ubyte()",
"comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the decoded result.\n         \n",
"line" : 1254}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
"line" : 1266}
]
}
]
}
,
{
"name" : "decoder(Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Decoder).\n\n Default $(D Decoder) decodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nforeach (decoded; Base64.decoder(stdin.byLine()))\n{\n    writeln(decoded);\n}\n -----\n), $(ARGS FPucA9l+), $(ARGS), $(ARGS import std.base64, std.stdio;))\n\n In addition, You can use $(D Decoder) that returns decoded single character.\n This $(D Decoder) performs Range-based and lazy decoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nauto encoded = Base64.encoder(cast(ubyte[])\"0123456789\");\nforeach (n; map!q{a - '0'}(Base64.decoder(encoded)))\n{\n    writeln(n);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;\nimport std.algorithm: map;))\n\n NOTE:\n  If you use $(D ByChunk), chunk-size should be the multiple of 4.\n  $(D Decoder) can't judge a encode-boundary.\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Decoder) object instantiated and initialized according to the arguments.\n     \n",
"line" : 1388,
"members" : [
{
"name" : "decoder",
"kind" : "function",
"type" : "Decoder!(Range)(Range range)",
"comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Decoder).\n\n Default $(D Decoder) decodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nforeach (decoded; Base64.decoder(stdin.byLine()))\n{\n    writeln(decoded);\n}\n -----\n), $(ARGS FPucA9l+), $(ARGS), $(ARGS import std.base64, std.stdio;))\n\n In addition, You can use $(D Decoder) that returns decoded single character.\n This $(D Decoder) performs Range-based and lazy decoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nauto encoded = Base64.encoder(cast(ubyte[])\"0123456789\");\nforeach (n; map!q{a - '0'}(Base64.decoder(encoded)))\n{\n    writeln(n);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;\nimport std.algorithm: map;))\n\n NOTE:\n  If you use $(D ByChunk), chunk-size should be the multiple of 4.\n  $(D Decoder) can't judge a encode-boundary.\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Decoder) object instantiated and initialized according to the arguments.\n     \n",
"line" : 1388}
]
}
,
{
"name" : "decodeChar()",
"kind" : "template",
"protection" : "public",
"line" : 1396,
"members" : [
{
"name" : "decodeChar",
"kind" : "function",
"type" : "int(char chr)",
"line" : 1396}
]
}
,
{
"name" : "decodeChar()",
"kind" : "template",
"protection" : "public",
"line" : 1409,
"members" : [
{
"name" : "decodeChar",
"kind" : "function",
"type" : "int(dchar chr)",
"line" : 1409}
]
}
]
}
]
}
,
{
"name" : "std.bigint",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/bigint.d",
"comment" : " Arbitrary-precision ('bignum') arithmetic\n\n Performance is optimized for numbers below ~1000 decimal digits.\n For X86 machines, highly optimised assembly routines are used.\n\n The following algorithms are currently implemented:\n $(UL\n $(LI Karatsuba multiplication)\n $(LI Squaring is optimized independently of multiplication)\n $(LI Divide-and-conquer division)\n $(LI Binary exponentiation)\n )\n\n For very large numbers, consider using the $(WEB gmplib.org, GMP library) instead.\n\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   Don Clugston\n Source: $(PHOBOSSRC std\/_bigint.d)\n \n",
"members" : [
{
"name" : "BigInt",
"kind" : "struct",
"protection" : "public",
"comment" : " A struct representing an arbitrary precision integer\n\n All arithmetic operations are supported, except\n unsigned shift right (>>>). Logical operations are not currently supported.\n\n BigInt implements value semantics using copy-on-write. This means that\n assignment is cheap, but operations such as x++ will cause heap\n allocation. (But note that for most bigint operations, heap allocation is\n inevitable anyway).\n\n Example:\n----------------------------------------------------\n        BigInt a = \"9588669891916142\";\n        BigInt b = \"7452469135154800\";\n        auto c = a * b;\n        assert(c == BigInt(\"71459266416693160362545788781600\"));\n        auto d = b * a;\n        assert(d == BigInt(\"71459266416693160362545788781600\"));\n        assert(d == c);\n        d = c * BigInt(\"794628672112\");\n        assert(d == BigInt(\"56783581982794522489042432639320434378739200\"));\n        auto e = c + d;\n        assert(e == BigInt(\"56783581982865981755459125799682980167520800\"));\n        auto f = d + c;\n        assert(f == e);\n        auto g = f - c;\n        assert(g == d);\n        g = f - d;\n        assert(g == c);\n        e = 12345678;\n        g = c + e;\n        auto h = g \/ b;\n        auto i = g % b;\n        assert(h == a);\n        assert(i == e);\n        BigInt j = \"-0x9A56_57f4_7B83_AB78\";\n        j ^^= 11;\n----------------------------------------------------\n\n \n",
"line" : 72,
"members" : [
{
"name" : "data",
"kind" : "variable",
"protection" : "private",
"type" : "BigUint",
"line" : 74}
,
{
"name" : "sign",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 75}
,
{
"name" : "__ctor(T : const(char)[])",
"kind" : "template",
"protection" : "public",
"comment" : " Construct a BigInt from a decimal or hexadecimal string.\n The number must be in the form of a D decimal or hex literal:\n It may have a leading + or - sign; followed by \"0x\" if hexadecimal.\n Underscores are permitted.\n BUG: Should throw a IllegalArgumentException\/ConvError if invalid character found\n",
"line" : 82,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(T s)",
"line" : 82}
]
}
,
{
"name" : "__ctor(T : long)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 108,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(T x)",
"line" : 108}
]
}
,
{
"name" : "opAssign(T : long)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 115,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "BigInt(T x)",
"comment" : "\n",
"line" : 115}
]
}
,
{
"name" : "opAssign(T : BigInt)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 123,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "BigInt(T x)",
"comment" : "\n",
"line" : 123}
]
}
,
{
"name" : "opOpAssign(string op,T) if ((op == \"+\" || op == \"-\" || op == \"*\" || op == \"\/\" || op == \"%\" || op == \">>\" || op == \"<<\" || op == \"^^\") && is(T : long))",
"kind" : "template",
"protection" : "public",
"line" : 131,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "BigInt(T y)",
"line" : 131}
]
}
,
{
"name" : "opOpAssign(string op,T) if ((op == \"+\" || op == \"-\" || op == \"*\" || op == \"\/\" || op == \"%\") && is(T : BigInt))",
"kind" : "template",
"protection" : "public",
"line" : 203,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "BigInt(T y)",
"line" : 203}
]
}
,
{
"name" : "opBinary(string op,T) if ((op == \"+\" || op == \"*\" || op == \"-\" || op == \"\/\" || op == \"%\") && is(T : BigInt))",
"kind" : "template",
"protection" : "public",
"line" : 245,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "BigInt(T y)",
"line" : 245}
]
}
,
{
"name" : "opBinary(string op,T) if ((op == \"+\" || op == \"*\" || op == \"-\" || op == \"\/\" || op == \">>\" || op == \"<<\" || op == \"^^\") && is(T : long))",
"kind" : "template",
"protection" : "public",
"line" : 253,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "BigInt(T y)",
"line" : 253}
]
}
,
{
"name" : "opBinary(string op,T : int) if (op == \"%\")",
"kind" : "template",
"protection" : "public",
"line" : 262,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "int(T y)",
"line" : 262}
]
}
,
{
"name" : "opBinaryRight(string op,T) if ((op == \"+\" || op == \"*\") && !is(T : BigInt))",
"kind" : "template",
"protection" : "public",
"line" : 274,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "BigInt(T y)",
"line" : 274}
]
}
,
{
"name" : "opBinaryRight(string op,T) if (op == \"-\" && is(T : long))",
"kind" : "template",
"protection" : "public",
"line" : 281,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "BigInt(T y)",
"line" : 281}
]
}
,
{
"name" : "opBinaryRight(string op,T) if ((op == \"%\" || op == \"\/\") && is(T : long))",
"kind" : "template",
"protection" : "public",
"line" : 296,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "T(T x)",
"line" : 296}
]
}
,
{
"name" : "opUnary(string op) if (op == \"+\" || op == \"-\")",
"kind" : "template",
"protection" : "public",
"line" : 319,
"members" : [
{
"name" : "opUnary",
"kind" : "function",
"type" : "BigInt()",
"line" : 319}
]
}
,
{
"name" : "opUnary(string op) if (op == \"++\" || op == \"--\")",
"kind" : "template",
"protection" : "public",
"line" : 332,
"members" : [
{
"name" : "opUnary",
"kind" : "function",
"type" : "BigInt()",
"line" : 332}
]
}
,
{
"name" : "opEquals()",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 347,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(auto ref const BigInt y)",
"comment" : "\n",
"line" : 347}
]
}
,
{
"name" : "opEquals(T : long)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 353,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(T y)",
"comment" : "\n",
"line" : 353}
]
}
,
{
"name" : "opCmp(T : long)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 361,
"members" : [
{
"name" : "opCmp",
"kind" : "function",
"type" : "int(T y)",
"comment" : "\n",
"line" : 361}
]
}
,
{
"name" : "opCmp(T : BigInt)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 369,
"members" : [
{
"name" : "opCmp",
"kind" : "function",
"type" : "int(T y)",
"comment" : "\n",
"line" : 369}
]
}
,
{
"name" : "toLong",
"kind" : "function",
"protection" : "public",
"type" : "const pure long()",
"comment" : " Returns the value of this BigInt as a long,\n or +- long.max if outside the representable range.\n",
"line" : 378}
,
{
"name" : "toInt",
"kind" : "function",
"protection" : "public",
"type" : "const pure int()",
"comment" : " Returns the value of this BigInt as an int,\n or +- int.max if outside the representable range.\n",
"line" : 387}
,
{
"name" : "uintLength",
"kind" : "function",
"protection" : "public",
"type" : "const pure @property ulong()",
"comment" : " Number of significant uints which are used in storing this number.\n The absolute value of this BigInt is always < 2^^(32*uintLength)\n",
"line" : 396}
,
{
"name" : "ulongLength",
"kind" : "function",
"protection" : "public",
"type" : "const pure @property ulong()",
"comment" : " Number of significant ulongs which are used in storing this number.\n The absolute value of this BigInt is always < 2^^(64*ulongLength)\n",
"line" : 402}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const void(scope void delegate(const(char)[]) sink, string formatString)",
"comment" : " Convert the BigInt to string, passing it to 'sink'.\n\n $(TABLE  The output format is controlled via formatString:\n $(TR $(TD \"d\") $(TD  Decimal))\n $(TR $(TD \"x\") $(TD  Hexadecimal, lower case))\n $(TR $(TD \"X\") $(TD  Hexadecimal, upper case))\n $(TR $(TD \"s\") $(TD  Default formatting (same as \"d\") ))\n $(TR $(TD null) $(TD Default formatting (same as \"d\") ))\n )\n     \n",
"line" : 417}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const void(scope void delegate(const(char)[]) sink, ref FormatSpec!(char) f)",
"line" : 423}
,
{
"name" : "negate",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 480}
,
{
"name" : "isZero",
"kind" : "function",
"protection" : "private",
"type" : "const pure bool()",
"line" : 485}
,
{
"name" : "isNegative",
"kind" : "function",
"protection" : "private",
"type" : "const pure bool()",
"line" : 489}
,
{
"name" : "checkDivByZero",
"kind" : "function",
"protection" : "private",
"type" : "const pure void()",
"line" : 494}
,
{
"name" : "__xopEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(void*) p, const(void*) q)",
"line" : 72}
]
}
,
{
"name" : "toDecimalString",
"kind" : "function",
"protection" : "public",
"type" : "string(BigInt x)",
"line" : 502}
,
{
"name" : "toHex",
"kind" : "function",
"protection" : "public",
"type" : "string(BigInt x)",
"line" : 510}
]
}
,
{
"name" : "std.bitmanip",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/bitmanip.d",
"comment" : "\nBit-level manipulation facilities.\n\nMacros:\n\nWIKI = StdBitarray\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis,\n           Alex Rnne Petersen\nSource: $(PHOBOSSRC std\/_bitmanip.d)\n",
"members" : [
{
"name" : "myToStringx",
"kind" : "function",
"protection" : "private",
"type" : "string(ulong n)",
"line" : 40}
,
{
"name" : "myToString",
"kind" : "function",
"protection" : "private",
"type" : "string(ulong n)",
"line" : 49}
,
{
"name" : "createAccessors(string store,T,string name,ulong len,ulong offset)",
"kind" : "template",
"protection" : "public",
"line" : 54,
"members" : [
]
}
,
{
"name" : "createStoreName(Ts...)",
"kind" : "template",
"protection" : "public",
"line" : 129,
"members" : [
]
}
,
{
"name" : "createFields(string store,ulong offset,Ts...)",
"kind" : "template",
"protection" : "public",
"line" : 137,
"members" : [
]
}
,
{
"name" : "bitfields(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nAllows creating bit fields inside $(D_PARAM struct)s and $(D_PARAM\nclass)es.\n\nExample:\n\n----\nstruct A\n{\n    int a;\n    mixin(bitfields!(\n        uint, \"x\",    2,\n        int,  \"y\",    3,\n        uint, \"z\",    2,\n        bool, \"flag\", 1));\n}\nA obj;\nobj.x = 2;\nobj.z = obj.x;\n----\n\nThe example above creates a bitfield pack of eight bits, which fit in\none $(D_PARAM ubyte). The bitfields are allocated starting from the\nleast significant bit, i.e. x occupies the two least significant bits\nof the bitfields storage.\n\nThe sum of all bit lengths in one $(D_PARAM bitfield) instantiation\nmust be exactly 8, 16, 32, or 64. If padding is needed, just allocate\none bitfield with an empty name.\n\nExample:\n\n----\nstruct A\n{\n    mixin(bitfields!(\n        bool, \"flag1\",    1,\n        bool, \"flag2\",    1,\n        uint, \"\",         6));\n}\n----\n\nThe type of a bit field can be any integral type or enumerated\ntype. The most efficient type to store in bitfields is $(D_PARAM\nbool), followed by unsigned types, followed by signed types.\n",
"line" : 211,
"members" : [
{
"name" : "bitfields",
"kind" : "enum member",
"protection" : "public",
"line" : 213}
]
}
,
{
"name" : "FloatRep",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM float) separately. The definition is:\n\n----\nstruct FloatRep\n{\n    union\n    {\n        float value;\n        mixin(bitfields!(\n                  uint,  \"fraction\", 23,\n                  ubyte, \"exponent\",  8,\n                  bool,  \"sign\",      1));\n    }\n    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;\n}\n----\n",
"line" : 313,
"members" : [
{
"name" : "value",
"kind" : "variable",
"protection" : "public",
"type" : "float",
"line" : 316}
,
{
"name" : "fraction",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe uint()",
"line" : 317}
,
{
"name" : "fraction",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(uint v)",
"line" : 318}
,
{
"name" : "fraction_min",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 319}
,
{
"name" : "fraction_max",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 319}
,
{
"name" : "exponent",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe ubyte()",
"line" : 319}
,
{
"name" : "exponent",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(ubyte v)",
"line" : 320}
,
{
"name" : "exponent_min",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte",
"line" : 321}
,
{
"name" : "exponent_max",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte",
"line" : 321}
,
{
"name" : "sign",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe bool()",
"line" : 321}
,
{
"name" : "sign",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(bool v)",
"line" : 322}
,
{
"name" : "_fraction_exponent_sign",
"kind" : "variable",
"protection" : "private",
"type" : "uint",
"line" : 323}
,
{
"name" : "bias",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 322}
,
{
"name" : "fractionBits",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 322}
,
{
"name" : "exponentBits",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 322}
,
{
"name" : "signBits",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 322}
]
}
,
{
"name" : "DoubleRep",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM double) separately. The definition is:\n\n----\nstruct DoubleRep\n{\n    union\n    {\n        double value;\n        mixin(bitfields!(\n                  ulong,   \"fraction\", 52,\n                  ushort,  \"exponent\", 11,\n                  bool,    \"sign\",      1));\n    }\n    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;\n}\n----\n",
"line" : 346,
"members" : [
{
"name" : "value",
"kind" : "variable",
"protection" : "public",
"type" : "double",
"line" : 349}
,
{
"name" : "fraction",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe ulong()",
"line" : 350}
,
{
"name" : "fraction",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(ulong v)",
"line" : 351}
,
{
"name" : "fraction_min",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 352}
,
{
"name" : "fraction_max",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 352}
,
{
"name" : "exponent",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe ushort()",
"line" : 352}
,
{
"name" : "exponent",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(ushort v)",
"line" : 353}
,
{
"name" : "exponent_min",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"line" : 354}
,
{
"name" : "exponent_max",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"line" : 354}
,
{
"name" : "sign",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe bool()",
"line" : 354}
,
{
"name" : "sign",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(bool v)",
"line" : 355}
,
{
"name" : "_fraction_exponent_sign",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 356}
,
{
"name" : "bias",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 355}
,
{
"name" : "signBits",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 355}
,
{
"name" : "fractionBits",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 355}
,
{
"name" : "exponentBits",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 355}
]
}
,
{
"name" : "BitArray",
"kind" : "struct",
"protection" : "public",
"comment" : "\n An array of bits.\n \n",
"line" : 391,
"members" : [
{
"name" : "len",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 392}
,
{
"name" : "ptr",
"kind" : "variable",
"protection" : "public",
"type" : "ulong*",
"line" : 393}
,
{
"name" : "bitsPerSizeT",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 394}
,
{
"name" : "dim",
"kind" : "function",
"protection" : "public",
"type" : "const @property ulong()",
"comment" : "\n Gets the amount of native words backing this $(D BitArray).\n     \n",
"line" : 399}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "const @property ulong()",
"comment" : "\n Gets the amount of bits in the $(D BitArray).\n     \n",
"line" : 407}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong(ulong newlen)",
"comment" : "\n Sets the amount of bits in the $(D BitArray).\n     \n",
"line" : 415}
,
{
"name" : "opIndex",
"kind" : "function",
"protection" : "public",
"type" : "const bool(ulong i)",
"comment" : "\n Gets the $(D i)'th bit in the $(D BitArray).\n     \n",
"line" : 442}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"protection" : "public",
"type" : "bool(bool b, ulong i)",
"comment" : "\n Sets the $(D i)'th bit in the $(D BitArray).\n     \n",
"line" : 469}
,
{
"name" : "dup",
"kind" : "function",
"protection" : "public",
"type" : "const @property BitArray()",
"comment" : "\n Duplicates the $(D BitArray) and its contents.\n     \n",
"line" : 486}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref bool) dg)",
"comment" : "\n Support for $(D foreach) loops for $(D BitArray).\n     \n",
"line" : 517}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "const int(scope int delegate(bool) dg)",
"comment" : " ditto \n",
"line" : 533}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref ulong, ref bool) dg)",
"comment" : " ditto \n",
"line" : 548}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "const int(scope int delegate(ulong, bool) dg)",
"comment" : " ditto \n",
"line" : 564}
,
{
"name" : "reverse",
"kind" : "function",
"protection" : "public",
"type" : "@property BitArray()",
"comment" : "\n Reverses the bits of the $(D BitArray).\n     \n",
"line" : 615}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "@property BitArray()",
"comment" : "\n Sorts the $(D BitArray)'s elements.\n     \n",
"line" : 659}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const bool(ref const(BitArray) a2)",
"comment" : "\n Support for operators == and != for $(D BitArray).\n     \n",
"line" : 721}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const int(BitArray a2)",
"comment" : "\n Supports comparison operators for $(D BitArray).\n     \n",
"line" : 769}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow ulong()",
"comment" : "\n Support for hashing for $(D BitArray).\n     \n",
"line" : 826}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void(bool[] ba)",
"comment" : "\n Set this $(D BitArray) to the contents of $(D ba).\n     \n",
"line" : 846}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void(void[] v, ulong numbits)",
"comment" : "\n Map the $(D BitArray) onto $(D v), with $(D numbits) being the number of bits\n in the array. Does not copy the data.\n\n This is the inverse of $(D opCast).\n     \n",
"line" : 862}
,
{
"name" : "opCast(T : void[])",
"kind" : "template",
"protection" : "public",
"comment" : "\n Convert to $(D void[]).\n     \n",
"line" : 902,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "void[]()",
"comment" : "\n Convert to $(D void[]).\n     \n",
"line" : 902}
]
}
,
{
"name" : "opCast(T : ulong[])",
"kind" : "template",
"protection" : "public",
"comment" : "\n Convert to $(D size_t[]).\n     \n",
"line" : 910,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "size_t[]()",
"comment" : "\n Convert to $(D size_t[]).\n     \n",
"line" : 910}
]
}
,
{
"name" : "opCom",
"kind" : "function",
"protection" : "public",
"type" : "BitArray()",
"comment" : "\n Support for unary operator ~ for $(D BitArray).\n     \n",
"line" : 930}
,
{
"name" : "opAnd",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(BitArray e2)",
"comment" : "\n Support for binary operator & for $(D BitArray).\n     \n",
"line" : 964}
,
{
"name" : "opOr",
"kind" : "function",
"protection" : "public",
"type" : "const BitArray(BitArray e2)",
"comment" : "\n Support for binary operator | for $(D BitArray).\n     \n",
"line" : 1004}
,
{
"name" : "opXor",
"kind" : "function",
"protection" : "public",
"type" : "const BitArray(BitArray e2)",
"comment" : "\n Support for binary operator ^ for $(D BitArray).\n     \n",
"line" : 1044}
,
{
"name" : "opSub",
"kind" : "function",
"protection" : "public",
"type" : "const BitArray(BitArray e2)",
"comment" : "\n Support for binary operator - for $(D BitArray).\n\n $(D a - b) for $(D BitArray) means the same thing as $(D a &amp; ~b).\n     \n",
"line" : 1086}
,
{
"name" : "opAndAssign",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(BitArray e2)",
"comment" : "\n Support for operator &= for $(D BitArray).\n     \n",
"line" : 1126}
,
{
"name" : "opOrAssign",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(BitArray e2)",
"comment" : "\n Support for operator |= for $(D BitArray).\n     \n",
"line" : 1162}
,
{
"name" : "opXorAssign",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(BitArray e2)",
"comment" : "\n Support for operator ^= for $(D BitArray).\n     \n",
"line" : 1197}
,
{
"name" : "opSubAssign",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(BitArray e2)",
"comment" : "\n Support for operator -= for $(D BitArray).\n\n $(D a -= b) for $(D BitArray) means the same thing as $(D a &amp;= ~b).\n     \n",
"line" : 1234}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(bool b)",
"comment" : "\n Support for operator ~= for $(D BitArray).\n     \n",
"line" : 1270}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "BitArray(BitArray b)",
"comment" : "\n ditto\n     \n",
"line" : 1301}
,
{
"name" : "opCat",
"kind" : "function",
"protection" : "public",
"type" : "const BitArray(bool b)",
"comment" : "\n Support for binary operator ~ for $(D BitArray).\n     \n",
"line" : 1335}
,
{
"name" : "opCat_r",
"kind" : "function",
"protection" : "public",
"type" : "const BitArray(bool b)",
"comment" : " ditto \n",
"line" : 1346}
,
{
"name" : "opCat",
"kind" : "function",
"protection" : "public",
"type" : "const BitArray(BitArray b)",
"comment" : " ditto \n",
"line" : 1358}
,
{
"name" : "__xopEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(void*) p, const(void*) q)",
"line" : 391}
]
}
,
{
"name" : "swapEndian(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Swaps the endianness of the given integral value or character.\n  \n",
"line" : 1404,
"members" : [
{
"name" : "swapEndian",
"kind" : "function",
"type" : "pure nothrow @safe T(T val)",
"comment" : "\n    Swaps the endianness of the given integral value or character.\n  \n",
"line" : 1404}
]
}
,
{
"name" : "swapEndianImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow @safe ushort(ushort val)",
"line" : 1421}
,
{
"name" : "swapEndianImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow @trusted uint(uint val)",
"line" : 1427}
,
{
"name" : "swapEndianImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow @trusted ulong(ulong val)",
"line" : 1432}
,
{
"name" : "EndianSwapper(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool) || is(Unqual!(T) == float) || is(Unqual!(T) == double))",
"kind" : "union",
"protection" : "public",
"line" : 1494,
"members" : [
{
"name" : "EndianSwapper",
"kind" : "union",
"protection" : "public",
"line" : 1494,
"members" : [
{
"name" : "value",
"kind" : "variable",
"type" : "Unqual!(T)",
"line" : 1495}
,
{
"name" : "array",
"kind" : "variable",
"type" : "ubyte[T.sizeof]",
"line" : 1496}
]
}
]
}
,
{
"name" : "nativeToBigEndian(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool) || is(Unqual!(T) == float) || is(Unqual!(T) == double))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Converts the given value from the native endianness to big endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToBigEndian(d);\nassert(d == bigEndianToNative!double(swappedD));\n--------------------\n  \n",
"line" : 1530,
"members" : [
{
"name" : "nativeToBigEndian",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"comment" : "\n    Converts the given value from the native endianness to big endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToBigEndian(d);\nassert(d == bigEndianToNative!double(swappedD));\n--------------------\n  \n",
"line" : 1530}
]
}
,
{
"name" : "nativeToBigEndianImpl(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool))",
"kind" : "template",
"protection" : "public",
"line" : 1552,
"members" : [
{
"name" : "nativeToBigEndianImpl",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"line" : 1552}
]
}
,
{
"name" : "nativeToBigEndianImpl(T) if (is(Unqual!(T) == float) || is(Unqual!(T) == double))",
"kind" : "template",
"protection" : "public",
"line" : 1565,
"members" : [
{
"name" : "nativeToBigEndianImpl",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"line" : 1565}
]
}
,
{
"name" : "bigEndianToNative(T,ulong n) if ((isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool) || is(Unqual!(T) == float) || is(Unqual!(T) == double)) && n == T.sizeof)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Converts the given value from big endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToBigEndian(c);\nassert(c == bigEndianToNative!dchar(swappedC));\n--------------------\n  \n",
"line" : 1666,
"members" : [
{
"name" : "bigEndianToNative",
"kind" : "function",
"type" : "pure nothrow @safe T(ubyte[n] val)",
"comment" : "\n    Converts the given value from big endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToBigEndian(c);\nassert(c == bigEndianToNative!dchar(swappedC));\n--------------------\n  \n",
"line" : 1666}
]
}
,
{
"name" : "bigEndianToNativeImpl(T,ulong n) if ((isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool)) && n == T.sizeof)",
"kind" : "template",
"protection" : "public",
"line" : 1689,
"members" : [
{
"name" : "bigEndianToNativeImpl",
"kind" : "function",
"type" : "pure nothrow @safe T(ubyte[n] val)",
"line" : 1689}
]
}
,
{
"name" : "bigEndianToNativeImpl(T,ulong n) if ((is(Unqual!(T) == float) || is(Unqual!(T) == double)) && n == T.sizeof)",
"kind" : "template",
"protection" : "public",
"line" : 1704,
"members" : [
{
"name" : "bigEndianToNativeImpl",
"kind" : "function",
"type" : "pure nothrow @safe T(ubyte[n] val)",
"line" : 1704}
]
}
,
{
"name" : "nativeToLittleEndian(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool) || is(Unqual!(T) == float) || is(Unqual!(T) == double))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Converts the given value from the native endianness to little endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToLittleEndian(d);\nassert(d == littleEndianToNative!double(swappedD));\n--------------------\n  \n",
"line" : 1735,
"members" : [
{
"name" : "nativeToLittleEndian",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"comment" : "\n    Converts the given value from the native endianness to little endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToLittleEndian(d);\nassert(d == littleEndianToNative!double(swappedD));\n--------------------\n  \n",
"line" : 1735}
]
}
,
{
"name" : "nativeToLittleEndianImpl(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool))",
"kind" : "template",
"protection" : "public",
"line" : 1757,
"members" : [
{
"name" : "nativeToLittleEndianImpl",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"line" : 1757}
]
}
,
{
"name" : "nativeToLittleEndianImpl(T) if (is(Unqual!(T) == float) || is(Unqual!(T) == double))",
"kind" : "template",
"protection" : "public",
"line" : 1770,
"members" : [
{
"name" : "nativeToLittleEndianImpl",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"line" : 1770}
]
}
,
{
"name" : "littleEndianToNative(T,ulong n) if ((isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool) || is(Unqual!(T) == float) || is(Unqual!(T) == double)) && n == T.sizeof)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Converts the given value from little endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToLittleEndian(c);\nassert(c == littleEndianToNative!dchar(swappedC));\n--------------------\n  \n",
"line" : 1844,
"members" : [
{
"name" : "littleEndianToNative",
"kind" : "function",
"type" : "pure nothrow @safe T(ubyte[n] val)",
"comment" : "\n    Converts the given value from little endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToLittleEndian(c);\nassert(c == littleEndianToNative!dchar(swappedC));\n--------------------\n  \n",
"line" : 1844}
]
}
,
{
"name" : "littleEndianToNativeImpl(T,ulong n) if ((isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool)) && n == T.sizeof)",
"kind" : "template",
"protection" : "public",
"line" : 1867,
"members" : [
{
"name" : "littleEndianToNativeImpl",
"kind" : "function",
"type" : "pure nothrow @safe T(ubyte[n] val)",
"line" : 1867}
]
}
,
{
"name" : "littleEndianToNativeImpl(T,ulong n) if ((is(Unqual!(T) == float) || is(Unqual!(T) == double)) && n == T.sizeof)",
"kind" : "template",
"protection" : "public",
"line" : 1882,
"members" : [
{
"name" : "littleEndianToNativeImpl",
"kind" : "function",
"type" : "pure nothrow @safe T(ubyte[n] val)",
"line" : 1882}
]
}
,
{
"name" : "floatEndianImpl(T,bool swap) if (is(Unqual!(T) == float) || is(Unqual!(T) == double))",
"kind" : "template",
"protection" : "public",
"line" : 1892,
"members" : [
{
"name" : "floatEndianImpl",
"kind" : "function",
"type" : "pure nothrow @safe (T val)",
"line" : 1892}
]
}
,
{
"name" : "floatEndianImpl(ulong n,bool swap) if (n == 4 || n == 8)",
"kind" : "template",
"protection" : "public",
"line" : 1904,
"members" : [
{
"name" : "floatEndianImpl",
"kind" : "function",
"type" : "pure nothrow @safe (ubyte[n] val)",
"line" : 1904}
]
}
,
{
"name" : "peek(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isForwardRange!(R) && is(ElementType!(R) : const(ubyte)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The range is not consumed.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n        index = The index to start reading from (instead of starting at the\n                front). If index is a pointer, then it is updated to the index\n                after the bytes read. The overloads with index are only\n                available if $(D hasSlicing!R) is $(D true).\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.peek!uint() == 17110537);\nassert(buffer.peek!ushort() == 261);\nassert(buffer.peek!ubyte() == 1);\n\nassert(buffer.peek!uint(2) == 369700095);\nassert(buffer.peek!ushort(2) == 5641);\nassert(buffer.peek!ubyte(2) == 22);\n\nsize_t index = 0;\nassert(buffer.peek!ushort(&index) == 261);\nassert(index == 2);\n\nassert(buffer.peek!uint(&index) == 369700095);\nassert(index == 6);\n\nassert(buffer.peek!ubyte(&index) == 8);\nassert(index == 7);\n--------------------\n  \n",
"line" : 1955,
"members" : [
{
"name" : "peek",
"kind" : "function",
"type" : "T(R range)",
"comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The range is not consumed.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n        index = The index to start reading from (instead of starting at the\n                front). If index is a pointer, then it is updated to the index\n                after the bytes read. The overloads with index are only\n                available if $(D hasSlicing!R) is $(D true).\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.peek!uint() == 17110537);\nassert(buffer.peek!ushort() == 261);\nassert(buffer.peek!ubyte() == 1);\n\nassert(buffer.peek!uint(2) == 369700095);\nassert(buffer.peek!ushort(2) == 5641);\nassert(buffer.peek!ubyte(2) == 22);\n\nsize_t index = 0;\nassert(buffer.peek!ushort(&index) == 261);\nassert(index == 2);\n\nassert(buffer.peek!uint(&index) == 369700095);\nassert(index == 6);\n\nassert(buffer.peek!ubyte(&index) == 8);\nassert(index == 7);\n--------------------\n  \n",
"line" : 1955}
]
}
,
{
"name" : "peek(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isForwardRange!(R) && hasSlicing!(R) && is(ElementType!(R) : const(ubyte)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 1980,
"members" : [
{
"name" : "peek",
"kind" : "function",
"type" : "T(R range, size_t index)",
"comment" : " Ditto \n",
"line" : 1980}
]
}
,
{
"name" : "peek(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isForwardRange!(R) && hasSlicing!(R) && is(ElementType!(R) : const(ubyte)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 1990,
"members" : [
{
"name" : "peek",
"kind" : "function",
"type" : "T(R range, size_t* index)",
"comment" : " Ditto \n",
"line" : 1990}
]
}
,
{
"name" : "read(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isInputRange!(R) && is(ElementType!(R) : const(ubyte)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The $(D T.sizeof) bytes which are read are consumed from\n    the range.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.length == 7);\n\nassert(buffer.read!ushort() == 261);\nassert(buffer.length == 5);\n\nassert(buffer.read!uint() == 369700095);\nassert(buffer.length == 1);\n\nassert(buffer.read!ubyte() == 8);\nassert(buffer.empty);\n--------------------\n  \n",
"line" : 2069,
"members" : [
{
"name" : "read",
"kind" : "function",
"type" : "T(ref R range)",
"comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The $(D T.sizeof) bytes which are read are consumed from\n    the range.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.length == 7);\n\nassert(buffer.read!ushort() == 261);\nassert(buffer.length == 5);\n\nassert(buffer.read!uint() == 369700095);\nassert(buffer.length == 1);\n\nassert(buffer.read!ubyte() == 8);\nassert(buffer.empty);\n--------------------\n  \n",
"line" : 2069}
]
}
,
{
"name" : "write(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isForwardRange!(R) && hasSlicing!(R) && is(ElementType!(R) : ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Takes an integral value, converts it to the given endianness, and writes it\n    to the given range of $(D ubyte)s as a sequence of $(D T.sizeof) $(D ubyte)s\n    starting at index. $(D hasSlicing!R) must be $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to write to.\n        index = The index to start writing to. If index is a pointer, then it\n                is updated to the index after the bytes read.\n\n        Examples:\n--------------------\n\/\/Bug# 8129 forces the casts. They shouldn't be necessary.\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(29110231u, 0);\n    assert(buffer == [1, 188, 47, 215, 0, 0, 0]);\n\n    buffer.write!ushort(cast(ushort)927, 0);\n    assert(buffer == [3, 159, 47, 215, 0, 0, 0]);\n\n    buffer.write!ubyte(cast(ubyte)42, 0);\n    assert(buffer == [42, 159, 47, 215, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(142700095u, 2);\n    assert(buffer == [0, 0, 8, 129, 110, 63, 0]);\n\n    buffer.write!ushort(cast(ushort)19839, 2);\n    assert(buffer == [0, 0, 77, 127, 110, 63, 0]);\n\n    buffer.write!ubyte(cast(ubyte)132, 2);\n    assert(buffer == [0, 0, 132, 127, 110, 63, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0];\n    size_t index = 0;\n    buffer.write!ushort(cast(ushort)261, &index);\n    assert(buffer == [1, 5, 0, 0, 0, 0, 0]);\n    assert(index == 2);\n\n    buffer.write!uint(369700095u, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 0]);\n    assert(index == 6);\n\n    buffer.write!ubyte(cast(ubyte)8, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 8]);\n    assert(index == 7);\n}\n--------------------\n  \n",
"line" : 2184,
"members" : [
{
"name" : "write",
"kind" : "function",
"type" : "void(R range, T value, size_t index)",
"comment" : "\n    Takes an integral value, converts it to the given endianness, and writes it\n    to the given range of $(D ubyte)s as a sequence of $(D T.sizeof) $(D ubyte)s\n    starting at index. $(D hasSlicing!R) must be $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to write to.\n        index = The index to start writing to. If index is a pointer, then it\n                is updated to the index after the bytes read.\n\n        Examples:\n--------------------\n\/\/Bug# 8129 forces the casts. They shouldn't be necessary.\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(29110231u, 0);\n    assert(buffer == [1, 188, 47, 215, 0, 0, 0]);\n\n    buffer.write!ushort(cast(ushort)927, 0);\n    assert(buffer == [3, 159, 47, 215, 0, 0, 0]);\n\n    buffer.write!ubyte(cast(ubyte)42, 0);\n    assert(buffer == [42, 159, 47, 215, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(142700095u, 2);\n    assert(buffer == [0, 0, 8, 129, 110, 63, 0]);\n\n    buffer.write!ushort(cast(ushort)19839, 2);\n    assert(buffer == [0, 0, 77, 127, 110, 63, 0]);\n\n    buffer.write!ubyte(cast(ubyte)132, 2);\n    assert(buffer == [0, 0, 132, 127, 110, 63, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0];\n    size_t index = 0;\n    buffer.write!ushort(cast(ushort)261, &index);\n    assert(buffer == [1, 5, 0, 0, 0, 0, 0]);\n    assert(index == 2);\n\n    buffer.write!uint(369700095u, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 0]);\n    assert(index == 6);\n\n    buffer.write!ubyte(cast(ubyte)8, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 8]);\n    assert(index == 7);\n}\n--------------------\n  \n",
"line" : 2184}
]
}
,
{
"name" : "write(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isForwardRange!(R) && hasSlicing!(R) && is(ElementType!(R) : ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 2194,
"members" : [
{
"name" : "write",
"kind" : "function",
"type" : "void(R range, T value, size_t* index)",
"comment" : " Ditto \n",
"line" : 2194}
]
}
,
{
"name" : "append(T,Endian endianness = Endian.bigEndian,R) if (isIntegral!(T) && isOutputRange!(R,ubyte))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Takes an integral value, converts it to the given endianness, and appends\n    it to the given range of $(D ubyte)s (using $(D put)) as a sequence of\n    $(D T.sizeof) $(D ubyte)s starting at index. $(D hasSlicing!R) must be\n    $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to append to.\n\n        Examples:\n--------------------\n\/\/Bug# 8129 forces the casts. They shouldn't be necessary.\nauto buffer = appender!(const ubyte[])();\nbuffer.append!ushort(cast(ushort)261);\nassert(buffer.data == [1, 5]);\n\nbuffer.append!uint(369700095u);\nassert(buffer.data == [1, 5, 22, 9, 44, 255]);\n\nbuffer.append!ubyte(cast(ubyte)8);\nassert(buffer.data == [1, 5, 22, 9, 44, 255, 8]);\n--------------------\n  \n",
"line" : 2284,
"members" : [
{
"name" : "append",
"kind" : "function",
"type" : "void(R range, T value)",
"comment" : "\n    Takes an integral value, converts it to the given endianness, and appends\n    it to the given range of $(D ubyte)s (using $(D put)) as a sequence of\n    $(D T.sizeof) $(D ubyte)s starting at index. $(D hasSlicing!R) must be\n    $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to append to.\n\n        Examples:\n--------------------\n\/\/Bug# 8129 forces the casts. They shouldn't be necessary.\nauto buffer = appender!(const ubyte[])();\nbuffer.append!ushort(cast(ushort)261);\nassert(buffer.data == [1, 5]);\n\nbuffer.append!uint(369700095u);\nassert(buffer.data == [1, 5, 22, 9, 44, 255]);\n\nbuffer.append!ubyte(cast(ubyte)8);\nassert(buffer.data == [1, 5, 22, 9, 44, 255, 8]);\n--------------------\n  \n",
"line" : 2284}
]
}
]
}
,
{
"name" : "std.compiler",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/compiler.d",
"comment" : "\n Identify the compiler used and its various features.\n\n Macros:\n      WIKI = Phobos\/StdCompiler\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright), Alex Rnne Petersen\n Source:    $(PHOBOSSRC std\/_compiler.d)\n \n",
"members" : [
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " Vendor specific string naming the compiler, for example: \"Digital Mars D\".\n",
"line" : 24}
,
{
"name" : "Vendor",
"kind" : "enum",
"protection" : "public",
"comment" : " Master list of D compiler vendors.\n",
"line" : 28,
"base" : "int",
"members" : [
{
"name" : "unknown",
"kind" : "enum member",
"protection" : "public",
"comment" : " Compiler vendor could not be detected\n",
"line" : 29}
,
{
"name" : "digitalMars",
"kind" : "enum member",
"protection" : "public",
"comment" : " Digital Mars D (DMD)\n",
"line" : 30}
,
{
"name" : "gnu",
"kind" : "enum member",
"protection" : "public",
"comment" : " GNU D Compiler (GDC)\n",
"line" : 31}
,
{
"name" : "llvm",
"kind" : "enum member",
"protection" : "public",
"comment" : " LLVM D Compiler (LDC)\n",
"line" : 32}
,
{
"name" : "dotNET",
"kind" : "enum member",
"protection" : "public",
"comment" : " D.NET\n",
"line" : 33}
,
{
"name" : "sdc",
"kind" : "enum member",
"protection" : "public",
"comment" : " Stupid D Compiler (SDC)\n",
"line" : 34}
]
}
,
{
"name" : "vendor",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(Vendor)",
"comment" : " Which vendor produced this compiler.\n",
"line" : 39}
,
{
"name" : "version_major",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(uint)",
"comment" : "\n The vendor specific version number, as in\n version_major.version_minor\n     \n",
"line" : 51}
,
{
"name" : "version_minor",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(uint)",
"comment" : " ditto\n",
"line" : 52}
,
{
"name" : "D_major",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(uint)",
"comment" : "\n The version of the D Programming Language Specification\n supported by the compiler.\n     \n",
"line" : 59}
,
{
"name" : "D_minor",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(uint)",
"line" : 60}
]
}
,
{
"name" : "std.complex",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/complex.d",
"comment" : " This module contains the $(LREF Complex) type, which is used to represent\n    _complex numbers, along with related mathematical operations and functions.\n\n    $(LREF Complex) will eventually $(LINK2 ..\/deprecate.html, replace)\n    the built-in types $(D cfloat), $(D cdouble), $(D creal), $(D ifloat),\n    $(D idouble), and $(D ireal).\n\n    Authors:    Lars Tandle Kyllingstad, Don Clugston\n    Copyright:  Copyright (c) 2010, Lars T. Kyllingstad.\n    License:    $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0)\n    Source:     $(PHOBOSSRC std\/_complex.d)\n",
"members" : [
{
"name" : "complex(T) if (is(T : double))",
"kind" : "template",
"protection" : "public",
"comment" : " Helper function that returns a _complex number with the specified\n    real and imaginary parts.\n\n    If neither $(D re) nor $(D im) are floating-point numbers, this\n    function returns a $(D Complex!double).  Otherwise, the return type\n    is deduced using $(D std.traits.CommonType!(R, I)).\n\n    Examples:\n    ---\n    auto c = complex(2.0);\n    static assert (is(typeof(c) == Complex!double));\n    assert (c.re == 2.0);\n    assert (c.im == 0.0);\n\n    auto w = complex(2);\n    static assert (is(typeof(w) == Complex!double));\n    assert (w == c);\n\n    auto z = complex(1, 3.14L);\n    static assert (is(typeof(z) == Complex!real));\n    assert (z.re == 1.0L);\n    assert (z.im == 3.14L);\n    ---\n",
"line" : 48,
"members" : [
{
"name" : "complex",
"kind" : "function",
"type" : "pure nothrow @safe (T re)",
"comment" : " Helper function that returns a _complex number with the specified\n    real and imaginary parts.\n\n    If neither $(D re) nor $(D im) are floating-point numbers, this\n    function returns a $(D Complex!double).  Otherwise, the return type\n    is deduced using $(D std.traits.CommonType!(R, I)).\n\n    Examples:\n    ---\n    auto c = complex(2.0);\n    static assert (is(typeof(c) == Complex!double));\n    assert (c.re == 2.0);\n    assert (c.im == 0.0);\n\n    auto w = complex(2);\n    static assert (is(typeof(w) == Complex!double));\n    assert (w == c);\n\n    auto z = complex(1, 3.14L);\n    static assert (is(typeof(z) == Complex!real));\n    assert (z.re == 1.0L);\n    assert (z.im == 3.14L);\n    ---\n",
"line" : 48}
]
}
,
{
"name" : "complex(R,I) if (is(R : double) && is(I : double))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 57,
"members" : [
{
"name" : "complex",
"kind" : "function",
"type" : "pure nothrow @safe (R re, I im)",
"comment" : " ditto\n",
"line" : 57}
]
}
,
{
"name" : "Complex(T) if (isFloatingPoint!(T))",
"kind" : "struct",
"protection" : "public",
"comment" : " A complex number parametrised by a type $(D T), which must be either\n    $(D float), $(D double) or $(D real).\n",
"line" : 109,
"members" : [
{
"name" : "Complex",
"kind" : "struct",
"protection" : "public",
"line" : 109,
"members" : [
{
"name" : "re",
"kind" : "variable",
"type" : "T",
"comment" : " The real part of the number. \n",
"line" : 111}
,
{
"name" : "im",
"kind" : "variable",
"type" : "T",
"comment" : " The imaginary part of the number. \n",
"line" : 114}
,
{
"name" : "toString",
"kind" : "function",
"type" : "const string(scope void delegate(const(char)[]) sink = null, string formatSpec = \"%s\")",
"comment" : " Converts the complex number to a string representation.\n\n        If a $(D sink) delegate is specified, the string is passed to it\n        and this function returns $(D null).  Otherwise, this function\n        returns the string representation directly.\n\n        The output format is controlled via $(D formatSpec), which should consist\n        of a single POSIX format specifier, including the percent (%) character.\n        Note that complex numbers are floating point numbers, so the only\n        valid format characters are 'e', 'f', 'g', 'a', and 's', where 's'\n        gives the default behaviour. Positional parameters are not valid\n        in this context.\n\n        See the $(LINK2 std_format.html, std.format documentation) for\n        more information.\n    \n",
"line" : 132}
,
{
"name" : "opAssign(R : T)",
"kind" : "template",
"protection" : "public",
"line" : 156,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "Complex(Complex!(R) z)",
"line" : 156}
]
}
,
{
"name" : "opAssign(R : T)",
"kind" : "template",
"protection" : "public",
"line" : 164,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "Complex(R r)",
"line" : 164}
]
}
,
{
"name" : "opEquals(R : T)",
"kind" : "template",
"protection" : "public",
"line" : 174,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(Complex!(R) z)",
"line" : 174}
]
}
,
{
"name" : "opEquals(R : T)",
"kind" : "template",
"protection" : "public",
"line" : 180,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(R r)",
"line" : 180}
]
}
,
{
"name" : "opUnary(string op) if (op == \"+\")",
"kind" : "template",
"protection" : "public",
"line" : 188,
"members" : [
{
"name" : "opUnary",
"kind" : "function",
"type" : "const Complex()",
"line" : 188}
]
}
,
{
"name" : "opUnary(string op) if (op == \"-\")",
"kind" : "template",
"protection" : "public",
"line" : 195,
"members" : [
{
"name" : "opUnary",
"kind" : "function",
"type" : "const Complex()",
"line" : 195}
]
}
,
{
"name" : "opBinary(string op,R)",
"kind" : "template",
"protection" : "public",
"line" : 204,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const Complex!(CommonType!(T,R))(Complex!(R) z)",
"line" : 204}
]
}
,
{
"name" : "opBinary(string op,R) if (isNumeric!(R))",
"kind" : "template",
"protection" : "public",
"line" : 212,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const Complex!(CommonType!(T,R))(R r)",
"line" : 212}
]
}
,
{
"name" : "opBinaryRight(string op,R) if ((op == \"+\" || op == \"*\") && isNumeric!(R))",
"kind" : "template",
"protection" : "public",
"line" : 221,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "const Complex!(CommonType!(T,R))(R r)",
"line" : 221}
]
}
,
{
"name" : "opBinaryRight(string op,R) if (op == \"-\" && isNumeric!(R))",
"kind" : "template",
"protection" : "public",
"line" : 228,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "const Complex!(CommonType!(T,R))(R r)",
"line" : 228}
]
}
,
{
"name" : "opBinaryRight(string op,R) if (op == \"\/\" && isNumeric!(R))",
"kind" : "template",
"protection" : "public",
"line" : 235,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "const Complex!(CommonType!(T,R))(R r)",
"line" : 235}
]
}
,
{
"name" : "opOpAssign(string op,C) if ((op == \"+\" || op == \"-\") && is(C R == Complex!(R)))",
"kind" : "template",
"protection" : "public",
"line" : 264,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(C z)",
"line" : 264}
]
}
,
{
"name" : "opOpAssign(string op,C) if (op == \"*\" && is(C R == Complex!(R)))",
"kind" : "template",
"protection" : "public",
"line" : 273,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(C z)",
"line" : 273}
]
}
,
{
"name" : "opOpAssign(string op,C) if (op == \"\/\" && is(C R == Complex!(R)))",
"kind" : "template",
"protection" : "public",
"line" : 283,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(C z)",
"line" : 283}
]
}
,
{
"name" : "opOpAssign(string op,C) if (op == \"^^\" && is(C R == Complex!(R)))",
"kind" : "template",
"protection" : "public",
"line" : 308,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(C z)",
"line" : 308}
]
}
,
{
"name" : "opOpAssign(string op,U : T) if (op == \"+\" || op == \"-\")",
"kind" : "template",
"protection" : "public",
"line" : 322,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(U a)",
"line" : 322}
]
}
,
{
"name" : "opOpAssign(string op,U : T) if (op == \"*\" || op == \"\/\")",
"kind" : "template",
"protection" : "public",
"line" : 330,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(U a)",
"line" : 330}
]
}
,
{
"name" : "opOpAssign(string op,R) if (op == \"^^\" && isFloatingPoint!(R))",
"kind" : "template",
"protection" : "public",
"line" : 339,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(R r)",
"line" : 339}
]
}
,
{
"name" : "opOpAssign(string op,U) if (op == \"^^\" && isIntegral!(U))",
"kind" : "template",
"protection" : "public",
"line" : 350,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Complex(U i)",
"line" : 350}
]
}
]
}
]
}
,
{
"name" : "Complex(T) if (is(T R == Complex!(R)))",
"kind" : "template",
"protection" : "public",
"line" : 531,
"members" : [
{
"name" : "Complex",
"kind" : "alias",
"type" : "T",
"line" : 533}
]
}
,
{
"name" : "abs(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Calculates the absolute value (or modulus) of a complex number. \n",
"line" : 555,
"members" : [
{
"name" : "abs",
"kind" : "function",
"type" : "pure nothrow @safe T(Complex!(T) z)",
"comment" : " Calculates the absolute value (or modulus) of a complex number. \n",
"line" : 555}
]
}
,
{
"name" : "arg(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Calculates the argument (or phase) of a complex number. \n",
"line" : 569,
"members" : [
{
"name" : "arg",
"kind" : "function",
"type" : "pure nothrow @safe T(Complex!(T) z)",
"comment" : " Calculates the argument (or phase) of a complex number. \n",
"line" : 569}
]
}
,
{
"name" : "conj(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the complex conjugate of a complex number. \n",
"line" : 583,
"members" : [
{
"name" : "conj",
"kind" : "function",
"type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
"comment" : " Returns the complex conjugate of a complex number. \n",
"line" : 583}
]
}
,
{
"name" : "fromPolar(T,U)",
"kind" : "template",
"protection" : "public",
"comment" : " Constructs a complex number given its absolute value and argument. \n",
"line" : 596,
"members" : [
{
"name" : "fromPolar",
"kind" : "function",
"type" : "pure nothrow @safe Complex!(CommonType!(T,U))(T modulus, U argument)",
"comment" : " Constructs a complex number given its absolute value and argument. \n",
"line" : 596}
]
}
,
{
"name" : "sin(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Trigonometric functions. \n",
"line" : 612,
"members" : [
{
"name" : "sin",
"kind" : "function",
"type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
"comment" : " Trigonometric functions. \n",
"line" : 612}
]
}
,
{
"name" : "cos(T)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 627,
"members" : [
{
"name" : "cos",
"kind" : "function",
"type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
"comment" : " ditto\n",
"line" : 627}
]
}
,
{
"name" : "expi",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted Complex!(real)(real y)",
"comment" : " Calculates cos(y) + i sin(y).\n\n    Note:\n    $(D expi) is included here for convenience and for easy migration of code\n    that uses $(XREF math,_expi).  Unlike $(XREF math,_expi), which uses the\n    x87 $(I fsincos) instruction when possible, this function is no faster\n    than calculating cos(y) and sin(y) separately.\n",
"line" : 649}
,
{
"name" : "sqrt(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Square root. \n",
"line" : 665,
"members" : [
{
"name" : "sqrt",
"kind" : "function",
"type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
"comment" : " Square root. \n",
"line" : 665}
]
}
]
}
,
{
"name" : "std.concurrency",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/concurrency.d",
"comment" : "\n This is a low-level messaging API upon which more structured or restrictive\n APIs may be built.  The general idea is that every messageable entity is\n represented by a common handle type (called a Cid in this implementation),\n which allows messages to be sent to in-process threads, on-host processes,\n and foreign-host processes using the same interface.  This is an important\n aspect of scalability because it allows the components of a program to be\n spread across available resources with few to no changes to the actual\n implementation.\n\n Right now, only in-process threads are supported and referenced by a more\n specialized handle called a Tid.  It is effectively a subclass of Cid, with\n additional features specific to in-process messaging.\n\n Synposis:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio;\n import std.concurrency;\n\n void spawnedFunc(Tid tid)\n {\n     \/\/ Receive a message from the owner thread.\n     receive(\n         (int i) { writeln(\"Received the number \", i);}\n     );\n\n     \/\/ Send a message back to the owner thread\n     \/\/ indicating success.\n     send(tid, true);\n }\n\n void main()\n {\n     \/\/ Start spawnedFunc in a new thread.\n     auto tid = spawn(&spawnedFunc, thisTid);\n\n     \/\/ Send the number 42 to this new thread.\n     send(tid, 42);\n\n     \/\/ Receive the result code.\n     auto wasSuccessful = receiveOnly!(bool);\n     assert(wasSuccessful);\n     writeln(\"Successfully printed number.\");\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n\n Copyright: Copyright Sean Kelly 2009 - 2010.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   Sean Kelly\n Source:    $(PHOBOSSRC std\/_concurrency.d)\n \n",
"members" : [
{
"name" : "hasLocalAliasing(T...)",
"kind" : "template",
"protection" : "public",
"line" : 80,
"members" : [
]
}
,
{
"name" : "MsgType",
"kind" : "enum",
"protection" : "public",
"line" : 90,
"base" : "int",
"members" : [
{
"name" : "standard",
"kind" : "enum member",
"protection" : "public",
"line" : 91}
,
{
"name" : "priority",
"kind" : "enum member",
"protection" : "public",
"line" : 92}
,
{
"name" : "linkDead",
"kind" : "enum member",
"protection" : "public",
"line" : 93}
]
}
,
{
"name" : "Message",
"kind" : "struct",
"protection" : "private",
"line" : 97,
"members" : [
{
"name" : "type",
"kind" : "variable",
"protection" : "public",
"type" : "MsgType",
"line" : 98}
,
{
"name" : "data",
"kind" : "variable",
"protection" : "public",
"type" : "VariantN!(32LU)",
"line" : 99}
,
{
"name" : "__ctor(T...) if (T.length < 1)",
"kind" : "template",
"protection" : "public",
"line" : 101,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(MsgType t, T vals)",
"line" : 101}
]
}
,
{
"name" : "__ctor(T...) if (T.length == 1)",
"kind" : "template",
"protection" : "public",
"line" : 107,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(MsgType t, T vals)",
"line" : 107}
]
}
,
{
"name" : "__ctor(T...) if (T.length > 1)",
"kind" : "template",
"protection" : "public",
"line" : 114,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(MsgType t, T vals)",
"line" : 114}
]
}
,
{
"name" : "convertsTo(T...)",
"kind" : "template",
"protection" : "public",
"line" : 121,
"members" : [
{
"name" : "convertsTo",
"kind" : "function",
"type" : "@property ()",
"line" : 121}
]
}
,
{
"name" : "get(T...)",
"kind" : "template",
"protection" : "public",
"line" : 130,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "@property ()",
"line" : 130}
]
}
,
{
"name" : "map(Op)",
"kind" : "template",
"protection" : "public",
"line" : 145,
"members" : [
{
"name" : "map",
"kind" : "function",
"type" : "(Op op)",
"line" : 145}
]
}
]
}
,
{
"name" : "checkops(T...)",
"kind" : "template",
"protection" : "public",
"line" : 163,
"members" : [
{
"name" : "checkops",
"kind" : "function",
"type" : "void(T ops)",
"line" : 163}
]
}
,
{
"name" : "mbox",
"kind" : "variable",
"protection" : "private",
"type" : "std.concurrency.MessageBox",
"line" : 190}
,
{
"name" : "links",
"kind" : "variable",
"protection" : "private",
"type" : "bool[Tid]",
"line" : 191}
,
{
"name" : "owner",
"kind" : "variable",
"protection" : "private",
"type" : "Tid",
"line" : 192}
,
{
"name" : "MessageMismatch",
"kind" : "class",
"protection" : "public",
"comment" : "\n\n\n Thrown on calls to $(D receiveOnly) if a message other than the type\n the receiving thread expected is sent.\n \n",
"line" : 230,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MessageMismatch(string msg = \"Unexpected message type\")",
"line" : 232}
]
}
,
{
"name" : "OwnerTerminated",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown on calls to $(D receive) if the thread that spawned the receiving\n thread has terminated and no more messages exist.\n \n",
"line" : 243,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OwnerTerminated(Tid t, string msg = \"Owner terminated\")",
"line" : 245}
,
{
"name" : "tid",
"kind" : "variable",
"protection" : "public",
"type" : "Tid",
"line" : 251}
]
}
,
{
"name" : "LinkTerminated",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown if a linked thread has terminated.\n \n",
"line" : 258,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "LinkTerminated(Tid t, string msg = \"Link terminated\")",
"line" : 260}
,
{
"name" : "tid",
"kind" : "variable",
"protection" : "public",
"type" : "Tid",
"line" : 266}
]
}
,
{
"name" : "PriorityMessageException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown if a message was sent to a thread via\n $(XREF concurrency, prioritySend) and the receiver does not have a handler\n for a message of this type.\n \n",
"line" : 275,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "PriorityMessageException(VariantN!(32LU) vals)",
"line" : 277}
,
{
"name" : "message",
"kind" : "variable",
"protection" : "public",
"type" : "VariantN!(32LU)",
"comment" : "\n The message that was sent.\n     \n",
"line" : 286}
]
}
,
{
"name" : "MailboxFull",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown on mailbox crowding if the mailbox is configured with\n $(D OnCrowding.throwException).\n \n",
"line" : 294,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MailboxFull(Tid t, string msg = \"Mailbox full\")",
"line" : 296}
,
{
"name" : "tid",
"kind" : "variable",
"protection" : "public",
"type" : "Tid",
"line" : 302}
]
}
,
{
"name" : "Tid",
"kind" : "struct",
"protection" : "public",
"comment" : "\n\n\n An opaque type used to represent a logical local process.\n \n",
"line" : 315,
"members" : [
{
"name" : "send(T...)",
"kind" : "template",
"protection" : "public",
"line" : 316,
"members" : [
{
"name" : "send",
"kind" : "function",
"type" : "void(T vals)",
"line" : 316}
]
}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "ref Tid(MessageBox m)",
"line" : 325}
,
{
"name" : "mbox",
"kind" : "variable",
"protection" : "private",
"type" : "std.concurrency.MessageBox",
"line" : 331}
]
}
,
{
"name" : "thisTid",
"kind" : "function",
"protection" : "public",
"type" : "@property Tid()",
"comment" : "\n Returns the caller's Tid.\n \n",
"line" : 338}
,
{
"name" : "spawn(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n\n\n Executes the supplied function in a new context represented by $(D Tid).  The\n calling context is designated as the owner of the new context.  When the\n owner context terminated an $(D OwnerTerminated) message will be sent to the\n new context, causing an $(D OwnerTerminated) exception to be thrown on\n $(D receive()).\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n\n Notes:\n  $(D args) must not have unshared aliasing.  In other words, all arguments\n  to $(D fn) must either be $(D shared) or $(D immutable) or have no\n  pointer indirection.  This is necessary for enforcing isolation among\n  threads.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio, std.concurrency;\n\n void f1(string str)\n {\n     writeln(str);\n }\n\n void f2(char[] str)\n {\n     writeln(str);\n }\n\n void main()\n {\n     auto str = \"Hello, world\";\n\n     \/\/ Works:  string is immutable.\n     auto tid1 = spawn(&f1, str);\n\n     \/\/ Fails:  char[] has mutable aliasing.\n     auto tid2 = spawn(&f2, str.dup);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
"line" : 401,
"members" : [
{
"name" : "spawn",
"kind" : "function",
"type" : "Tid(void function(T) fn, T args)",
"comment" : "\n\n\n Executes the supplied function in a new context represented by $(D Tid).  The\n calling context is designated as the owner of the new context.  When the\n owner context terminated an $(D OwnerTerminated) message will be sent to the\n new context, causing an $(D OwnerTerminated) exception to be thrown on\n $(D receive()).\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n\n Notes:\n  $(D args) must not have unshared aliasing.  In other words, all arguments\n  to $(D fn) must either be $(D shared) or $(D immutable) or have no\n  pointer indirection.  This is necessary for enforcing isolation among\n  threads.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio, std.concurrency;\n\n void f1(string str)\n {\n     writeln(str);\n }\n\n void f2(char[] str)\n {\n     writeln(str);\n }\n\n void main()\n {\n     auto str = \"Hello, world\";\n\n     \/\/ Works:  string is immutable.\n     auto tid1 = spawn(&f1, str);\n\n     \/\/ Fails:  char[] has mutable aliasing.\n     auto tid2 = spawn(&f2, str.dup);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
"line" : 401}
]
}
,
{
"name" : "spawnLinked(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Executes the supplied function in a new context represented by Tid.  This\n new context is linked to the calling context so that if either it or the\n calling context terminates a LinkTerminated message will be sent to the\n other, causing a LinkTerminated exception to be thrown on receive().  The\n owner relationship from spawn() is preserved as well, so if the link\n between threads is broken, owner termination will still result in an\n OwnerTerminated exception to be thrown on receive().\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n \n",
"line" : 425,
"members" : [
{
"name" : "spawnLinked",
"kind" : "function",
"type" : "Tid(void function(T) fn, T args)",
"comment" : "\n Executes the supplied function in a new context represented by Tid.  This\n new context is linked to the calling context so that if either it or the\n calling context terminates a LinkTerminated message will be sent to the\n other, causing a LinkTerminated exception to be thrown on receive().  The\n owner relationship from spawn() is preserved as well, so if the link\n between threads is broken, owner termination will still result in an\n OwnerTerminated exception to be thrown on receive().\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n \n",
"line" : 425}
]
}
,
{
"name" : "_spawn(T...)",
"kind" : "template",
"protection" : "public",
"line" : 436,
"members" : [
{
"name" : "_spawn",
"kind" : "function",
"type" : "Tid(bool linked, void function(T) fn, T args)",
"line" : 436}
]
}
,
{
"name" : "send(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n\n\n Sends the supplied value to the context represented by tid.  As with\n $(XREF concurrency, spawn), $(D T) must not have unshared aliasing.\n \n",
"line" : 465,
"members" : [
{
"name" : "send",
"kind" : "function",
"type" : "void(Tid tid, T vals)",
"comment" : "\n\n\n Sends the supplied value to the context represented by tid.  As with\n $(XREF concurrency, spawn), $(D T) must not have unshared aliasing.\n \n",
"line" : 465}
]
}
,
{
"name" : "prioritySend(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Send a message to $(D tid) but place it at the front of $(D tid)'s message\n queue instead of at the back.  This function is typically used for\n out-of-band communication, to signal exceptional conditions, etc.\n \n",
"line" : 478,
"members" : [
{
"name" : "prioritySend",
"kind" : "function",
"type" : "void(Tid tid, T vals)",
"comment" : "\n Send a message to $(D tid) but place it at the front of $(D tid)'s message\n queue instead of at the back.  This function is typically used for\n out-of-band communication, to signal exceptional conditions, etc.\n \n",
"line" : 478}
]
}
,
{
"name" : "_send(T...)",
"kind" : "template",
"protection" : "public",
"line" : 489,
"members" : [
{
"name" : "_send",
"kind" : "function",
"type" : "void(Tid tid, T vals)",
"line" : 489}
]
}
,
{
"name" : "_send(T...)",
"kind" : "template",
"protection" : "public",
"line" : 499,
"members" : [
{
"name" : "_send",
"kind" : "function",
"type" : "void(MsgType type, Tid tid, T vals)",
"line" : 499}
]
}
,
{
"name" : "receive(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Receive a message from another thread, or block if no messages of the\n specified types are available.  This function works by pattern matching\n a message against a set of delegates and executing the first match found.\n\n If a delegate that accepts a $(XREF variant, Variant) is included as\n the last argument to $(D receive), it will match any message that was not\n matched by an earlier delegate.  If more than one argument is sent,\n the $(D Variant) will contain a $(XREF typecons, Tuple) of all values\n sent.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio;\n import std.variant;\n import std.concurrency;\n\n void spawnedFunction()\n {\n     receive(\n         (int i) { writeln(\"Received an int.\"); },\n         (float f) { writeln(\"Received a float.\"); },\n         (Variant v) { writeln(\"Received some other type.\"); }\n     );\n }\n\n void main()\n {\n      auto tid = spawn(&spawnedFunction);\n      send(tid, 42);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
"line" : 542,
"members" : [
{
"name" : "receive",
"kind" : "function",
"type" : "void(T ops)",
"comment" : "\n Receive a message from another thread, or block if no messages of the\n specified types are available.  This function works by pattern matching\n a message against a set of delegates and executing the first match found.\n\n If a delegate that accepts a $(XREF variant, Variant) is included as\n the last argument to $(D receive), it will match any message that was not\n matched by an earlier delegate.  If more than one argument is sent,\n the $(D Variant) will contain a $(XREF typecons, Tuple) of all values\n sent.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio;\n import std.variant;\n import std.concurrency;\n\n void spawnedFunction()\n {\n     receive(\n         (int i) { writeln(\"Received an int.\"); },\n         (float f) { writeln(\"Received a float.\"); },\n         (Variant v) { writeln(\"Received some other type.\"); }\n     );\n }\n\n void main()\n {\n      auto tid = spawn(&spawnedFunction);\n      send(tid, 42);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
"line" : 542}
]
}
,
{
"name" : "receiveOnlyRet(T...)",
"kind" : "template",
"protection" : "public",
"line" : 583,
"members" : [
]
}
,
{
"name" : "receiveOnly(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Receives only messages with arguments of types $(D T).\n\n Throws:  $(D MessageMismatch) if a message of types other than $(D T)\n          is received.\n\n Returns: The received message.  If $(D T.length) is greater than one,\n          the message will be packed into a $(XREF typecons, Tuple).\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.concurrency;\n\n void spawnedFunc()\n {\n     auto msg = receiveOnly!(int, string)();\n     assert(msg[0] == 42);\n     assert(msg[1] == \"42\");\n }\n\n void main()\n {\n     auto tid = spawn(&spawnedFunc);\n     send(tid, 42, \"42\");\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
"line" : 621,
"members" : [
{
"name" : "receiveOnly",
"kind" : "function",
"type" : "receiveOnlyRet!(T)()",
"comment" : "\n Receives only messages with arguments of types $(D T).\n\n Throws:  $(D MessageMismatch) if a message of types other than $(D T)\n          is received.\n\n Returns: The received message.  If $(D T.length) is greater than one,\n          the message will be packed into a $(XREF typecons, Tuple).\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.concurrency;\n\n void spawnedFunc()\n {\n     auto msg = receiveOnly!(int, string)();\n     assert(msg[0] == 42);\n     assert(msg[1] == \"42\");\n }\n\n void main()\n {\n     auto tid = spawn(&spawnedFunc);\n     send(tid, 42, \"42\");\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
"line" : 621}
]
}
,
{
"name" : "receiveTimeout(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use the version\n       which takes a $(CXREF time, Duration) instead.)\n \n",
"line" : 653,
"members" : [
{
"name" : "receiveTimeout",
"kind" : "function",
"type" : "bool(long ms, T ops)",
"line" : 653}
]
}
,
{
"name" : "receiveTimeout(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Same as $(D receive) except that rather than wait forever for a message,\n    it waits until either it receives a message or the given\n    $(CXREF time, Duration) has passed. It returns $(D true) if it received a\n    message and $(D false) if it timed out waiting for one.\n  \n",
"line" : 664,
"members" : [
{
"name" : "receiveTimeout",
"kind" : "function",
"type" : "bool(Duration duration, T ops)",
"comment" : "\n    Same as $(D receive) except that rather than wait forever for a message,\n    it waits until either it receives a message or the given\n    $(CXREF time, Duration) has passed. It returns $(D true) if it received a\n    message and $(D false) if it timed out waiting for one.\n  \n",
"line" : 664}
]
}
,
{
"name" : "OnCrowding",
"kind" : "enum",
"protection" : "public",
"comment" : "\n\n\n These behaviors may be specified when a mailbox is full.\n \n",
"line" : 704,
"base" : "int",
"members" : [
{
"name" : "block",
"kind" : "enum member",
"protection" : "public",
"comment" : " Wait until room is available.\n",
"line" : 705}
,
{
"name" : "throwException",
"kind" : "enum member",
"protection" : "public",
"comment" : " Throw a MailboxFull exception.\n",
"line" : 706}
,
{
"name" : "ignore",
"kind" : "enum member",
"protection" : "public",
"comment" : " Abort the send and return.\n",
"line" : 707}
]
}
,
{
"name" : "onCrowdingBlock",
"kind" : "function",
"protection" : "private",
"type" : "bool(Tid tid)",
"line" : 713}
,
{
"name" : "onCrowdingThrow",
"kind" : "function",
"protection" : "private",
"type" : "bool(Tid tid)",
"line" : 719}
,
{
"name" : "onCrowdingIgnore",
"kind" : "function",
"protection" : "private",
"type" : "bool(Tid tid)",
"line" : 725}
,
{
"name" : "setMaxMailboxSize",
"kind" : "function",
"protection" : "public",
"type" : "void(Tid tid, ulong messages, OnCrowding doThis)",
"comment" : "\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute the behavior specified by doThis.  If messages is zero, the mailbox\n is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  doThis   = The behavior executed when a message is sent to a full\n             mailbox.\n \n",
"line" : 744}
,
{
"name" : "setMaxMailboxSize",
"kind" : "function",
"protection" : "public",
"type" : "void(Tid tid, ulong messages, bool function(Tid) onCrowdingDoThis)",
"comment" : "\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute onCrowdingDoThis.  If messages is zero, the mailbox is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  onCrowdingDoThis = The routine called when a message is sent to a full\n                     mailbox.\n \n",
"line" : 769}
,
{
"name" : "tidByName",
"kind" : "variable",
"protection" : "private",
"type" : "Tid[string]",
"comment" : "\n\n",
"line" : 782}
,
{
"name" : "namesByTid",
"kind" : "variable",
"protection" : "private",
"type" : "string[][Tid]",
"comment" : "\n\n",
"line" : 783}
,
{
"name" : "registryLock",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.mutex.Mutex",
"comment" : "\n\n",
"line" : 784}
,
{
"name" : "register",
"kind" : "function",
"protection" : "public",
"type" : "bool(string name, Tid tid)",
"comment" : "\n Associates name with tid in a process-local map.  When the thread\n represented by tid termiantes, any names associated with it will be\n automatically unregistered.\n\n Params:\n  name = The name to associate with tid.\n  tid  = The tid register by name.\n\n Returns:\n  true if the name is available and tid is not known to represent a\n  defunct thread.\n \n",
"line" : 823}
,
{
"name" : "unregister",
"kind" : "function",
"protection" : "public",
"type" : "bool(string name)",
"comment" : "\n Removes the registered name associated with a tid.\n\n Params:\n  name = The name to unregister.\n\n Returns:\n  true if the name is registered, false if not.\n \n",
"line" : 847}
,
{
"name" : "locate",
"kind" : "function",
"protection" : "public",
"type" : "Tid(string name)",
"comment" : "\n Gets the Tid associated with name.\n\n Params:\n  name = The name to locate within the registry.\n\n Returns:\n  The associated Tid or Tid.init if name is not registered.\n \n",
"line" : 873}
,
{
"name" : "MessageBox",
"kind" : "class",
"protection" : "private",
"comment" : "\n\n",
"line" : 899,
"base" : "Object",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MessageBox()",
"line" : 900}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"line" : 912}
,
{
"name" : "setMaxMsgs",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong num, bool function(Tid) call)",
"line" : 932}
,
{
"name" : "put",
"kind" : "function",
"protection" : "public",
"type" : "void(ref Message msg)",
"line" : 956}
,
{
"name" : "get(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1007,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "bool(scope T vals)",
"line" : 1007}
]
}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1208}
,
{
"name" : "mboxFull",
"kind" : "function",
"protection" : "private",
"type" : "bool()",
"comment" : "\n\n",
"line" : 1248}
,
{
"name" : "updateMsgCount",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1255}
,
{
"name" : "isControlMsg",
"kind" : "function",
"protection" : "private",
"type" : "pure bool(ref Message msg)",
"comment" : "\n\n",
"line" : 1267}
,
{
"name" : "isPriorityMsg",
"kind" : "function",
"protection" : "private",
"type" : "pure bool(ref Message msg)",
"line" : 1274}
,
{
"name" : "isLinkDeadMsg",
"kind" : "function",
"protection" : "private",
"type" : "pure bool(ref Message msg)",
"line" : 1280}
,
{
"name" : "OnMaxFn",
"kind" : "alias",
"protection" : "private",
"type" : "bool function(Tid)",
"comment" : "\n\n",
"line" : 1292}
,
{
"name" : "ListT",
"kind" : "alias",
"protection" : "private",
"type" : "List!(Message)",
"line" : 1293}
,
{
"name" : "m_localBox",
"kind" : "variable",
"protection" : "private",
"type" : "List!(Message)",
"comment" : "\n\n",
"line" : 1301}
,
{
"name" : "m_localPty",
"kind" : "variable",
"protection" : "private",
"type" : "List!(Message)",
"line" : 1302}
,
{
"name" : "m_lock",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.mutex.Mutex",
"comment" : "\n\n",
"line" : 1311}
,
{
"name" : "m_putMsg",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.condition.Condition",
"line" : 1312}
,
{
"name" : "m_notFull",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.condition.Condition",
"line" : 1313}
,
{
"name" : "m_putQueue",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 1314}
,
{
"name" : "m_sharedBox",
"kind" : "variable",
"protection" : "private",
"type" : "List!(Message)",
"line" : 1315}
,
{
"name" : "m_sharedPty",
"kind" : "variable",
"protection" : "private",
"type" : "List!(Message)",
"line" : 1316}
,
{
"name" : "m_onMaxMsgs",
"kind" : "variable",
"protection" : "private",
"type" : "bool function(Tid)",
"line" : 1317}
,
{
"name" : "m_localMsgs",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 1318}
,
{
"name" : "m_maxMsgs",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 1319}
,
{
"name" : "m_closed",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 1320}
]
}
,
{
"name" : "List(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n\n",
"line" : 1328,
"members" : [
{
"name" : "List",
"kind" : "struct",
"protection" : "public",
"line" : 1328,
"members" : [
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"line" : 1330,
"members" : [
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"line" : 1331}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"line" : 1336}
,
{
"name" : "front",
"kind" : "function",
"type" : "void(T val)",
"line" : 1342}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 1348}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Node* p)",
"line" : 1360}
,
{
"name" : "m_prev",
"kind" : "variable",
"type" : "Node*",
"line" : 1365}
]
}
,
{
"name" : "put",
"kind" : "function",
"type" : "void(T val)",
"line" : 1372}
,
{
"name" : "put",
"kind" : "function",
"type" : "void(ref List!(T) rhs)",
"line" : 1381}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"line" : 1401}
,
{
"name" : "removeAt",
"kind" : "function",
"type" : "void(Range r)",
"line" : 1410}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"line" : 1430}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"line" : 1439}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 1449}
,
{
"name" : "Node",
"kind" : "struct",
"protection" : "public",
"line" : 1457,
"members" : [
{
"name" : "next",
"kind" : "variable",
"type" : "Node*",
"line" : 1458}
,
{
"name" : "val",
"kind" : "variable",
"type" : "T",
"line" : 1459}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T v)",
"line" : 1461}
]
}
,
{
"name" : "put",
"kind" : "function",
"type" : "void(Node* n)",
"line" : 1471}
,
{
"name" : "m_first",
"kind" : "variable",
"type" : "Node*",
"line" : 1485}
,
{
"name" : "m_last",
"kind" : "variable",
"type" : "Node*",
"line" : 1486}
,
{
"name" : "m_count",
"kind" : "variable",
"type" : "size_t",
"line" : 1487}
]
}
]
}
]
}
,
{
"name" : "std.container",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/container.d",
"comment" : "\nDefines generic _containers.\n\nSource: $(PHOBOSSRC std\/_container.d)\nMacros:\nWIKI = Phobos\/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org\/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n\n$(BOOKTABLE $(TEXTWITHCOMMAS Container primitives. Below, $(D C) means\na _container type, $(D c) is a value of _container type, $(D n$(SUB\nx)) represents the effective length of value $(D x), which could be a\nsingle element (in which case $(D n$(SUB x)) is $(D 1)), a _container,\nor a range.),\n\n$(TR $(TH Syntax) $(TH $(BIGOH &middot;)) $(TH Description))\n\n$(TR $(TDNW $(D C(x))) $(TDNW $(D n$(SUB x))) $(TD Creates a\n_container of type $(D C) from either another _container or a range.))\n\n$(TR $(TDNW $(D c.dup)) $(TDNW $(D n$(SUB c))) $(TD Returns a\nduplicate of the _container.))\n\n$(TR $(TDNW $(D c ~ x)) $(TDNW $(D n$(SUB c) + n$(SUB x))) $(TD\nReturns the concatenation of $(D c) and $(D r). $(D x) may be a single\nelement or an input range.))\n\n$(TR $(TDNW $(D x ~ c)) $(TDNW $(D n$(SUB c) + n$(SUB x))) $(TD\nReturns the concatenation of $(D x) and $(D c).  $(D x) may be a\nsingle element or an input range type.))\n\n$(LEADINGROW Iteration)\n\n$(TR  $(TD $(D c.Range)) $(TD) $(TD The primary range\ntype associated with the _container.))\n\n$(TR $(TD $(D c[])) $(TDNW $(D log n$(SUB c))) $(TD Returns a range\niterating over the entire _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c[a .. b])) $(TDNW $(D log n$(SUB c))) $(TD Fetches a\nportion of the _container from key $(D a) to key $(D b).))\n\n$(LEADINGROW Capacity)\n\n$(TR $(TD $(D c.empty)) $(TD $(D 1)) $(TD Returns $(D true) if the\n_container has no elements, $(D false) otherwise.))\n\n$(TR  $(TD $(D c.length)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nnumber of elements in the _container.))\n\n$(TR $(TDNW $(D c.length = n)) $(TDNW $(D n$(SUB c) + n)) $(TD Forces\nthe number of elements in the _container to $(D n). If the _container\nends up growing, the added elements are initialized in a\n_container-dependent manner (usually with $(D T.init)).))\n\n$(TR $(TD $(D c.capacity)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nmaximum number of elements that can be stored in the _container\nwithout triggering a reallocation.))\n\n$(TR $(TD $(D c.reserve(x))) $(TD $(D n$(SUB c))) $(TD Forces $(D\ncapacity) to at least $(D x) without reducing it.))\n\n$(LEADINGROW Access)\n\n$(TR $(TDNW $(D c.front)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nfirst element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveFront)) $(TDNW $(D log n$(SUB c))) $(TD\nDestructively reads and returns the first element of the\n_container. The slot is not removed from the _container; it is left\ninitalized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.front = v)) $(TDNW $(D log n$(SUB c))) $(TD Assigns\n$(D v) to the first element of the _container.))\n\n$(TR $(TDNW $(D c.back)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nlast element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveBack)) $(TDNW $(D log n$(SUB c))) $(TD\nDestructively reads and returns the last element of the\ncontainer. The slot is not removed from the _container; it is left\ninitalized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.back = v)) $(TDNW $(D log n$(SUB c))) $(TD Assigns\n$(D v) to the last element of the _container.))\n\n$(TR $(TDNW $(D c[x])) $(TDNW $(D log n$(SUB c))) $(TD Provides\nindexed access into the _container. The index type is\n_container-defined. A container may define several index types (and\nconsequently overloaded indexing).))\n\n$(TR  $(TDNW $(D c.moveAt(x))) $(TDNW $(D log n$(SUB c))) $(TD\nDestructively reads and returns the value at position $(D x). The slot\nis not removed from the _container; it is left initialized with $(D\nT.init).))\n\n$(TR  $(TDNW $(D c[x] = v)) $(TDNW $(D log n$(SUB c))) $(TD Sets\nelement at specified index into the _container.))\n\n$(TR  $(TDNW $(D c[x] $(I op)= v)) $(TDNW $(D log n$(SUB c)))\n$(TD Performs read-modify-write operation at specified index into the\n_container.))\n\n$(LEADINGROW Operations)\n\n$(TR $(TDNW $(D e in c)) $(TDNW $(D log n$(SUB c))) $(TD\nReturns nonzero if e is found in $(D c).))\n\n$(TR  $(TDNW $(D c.lowerBound(v))) $(TDNW $(D log n$(SUB c))) $(TD\nReturns a range of all elements strictly less than $(D v).))\n\n$(TR  $(TDNW $(D c.upperBound(v))) $(TDNW $(D log n$(SUB c))) $(TD\nReturns a range of all elements strictly greater than $(D v).))\n\n$(TR  $(TDNW $(D c.equalRange(v))) $(TDNW $(D log n$(SUB c))) $(TD\nReturns a range of all elements in $(D c) that are equal to $(D v).))\n\n$(LEADINGROW Modifiers)\n\n$(TR $(TDNW $(D c ~= x)) $(TDNW $(D n$(SUB c) + n$(SUB x)))\n$(TD Appends $(D x) to $(D c). $(D x) may be a single element or an\ninput range type.))\n\n$(TR  $(TDNW $(D c.clear())) $(TDNW $(D n$(SUB c))) $(TD Removes all\nelements in $(D c).))\n\n$(TR  $(TDNW $(D c.insert(x))) $(TDNW $(D n$(SUB x) * log n$(SUB c)))\n$(TD Inserts $(D x) in $(D c) at a position (or positions) chosen by $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsert(x)))\n$(TDNW $(D n$(SUB x) * log n$(SUB c))) $(TD Same as $(D c.insert(x)),\nbut is guaranteed to not invalidate any ranges.))\n\n$(TR  $(TDNW $(D c.linearInsert(v))) $(TDNW $(D n$(SUB c))) $(TD Same\nas $(D c.insert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.stableLinearInsert(v))) $(TDNW $(D n$(SUB c)))\n$(TD Same as $(D c.stableInsert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.removeAny())) $(TDNW $(D log n$(SUB c)))\n$(TD Removes some element from $(D c) and returns it.))\n\n$(TR  $(TDNW $(D c.stableRemoveAny())) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.removeAny()), but is guaranteed to not invalidate any\niterators.))\n\n$(TR  $(TDNW $(D c.insertFront(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Inserts $(D v) at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertFront(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.insertFront(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.insertBack(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Inserts $(D v) at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertBack(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.insertBack(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeFront())) $(TDNW $(D log n$(SUB c)))\n$(TD Removes the element at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveFront())) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.removeFront()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeBack())) $(TDNW $(D log n$(SUB c)))\n$(TD Removes the value at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveBack())) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.removeBack()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.remove(r))) $(TDNW $(D n$(SUB r) * log n$(SUB c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemove(r)))\n$(TDNW $(D n$(SUB r) * log n$(SUB c)))\n$(TD Same as $(D c.remove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.linearRemove(r))) $(TDNW $(D n$(SUB c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableLinearRemove(r))) $(TDNW $(D n$(SUB c)))\n$(TD Same as $(D c.linearRemove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeKey(k))) $(TDNW $(D log n$(SUB c)))\n$(TD Removes an element from $(D c) by using its key $(D k).\nThe key's type is defined by the _container.))\n\n$(TR  $(TDNW $(D )) $(TDNW $(D )) $(TD ))\n\n)\n \n",
"members" : [
{
"name" : "TotalContainer(T)",
"kind" : "struct",
"protection" : "public",
"line" : 255,
"members" : [
{
"name" : "TotalContainer",
"kind" : "struct",
"protection" : "public",
"line" : 255,
"members" : [
{
"name" : "KeyType",
"kind" : "alias",
"type" : "T",
"comment" : "\nIf the container has a notion of key-value mapping, $(D KeyType)\ndefines the type of the key of the container.\n \n",
"line" : 260}
,
{
"name" : "KeyTypes",
"kind" : "alias",
"type" : "TypeTuple!(T)",
"comment" : "\nIf the container has a notion of multikey-value mapping, $(D\nKeyTypes[k]), where $(D k) is a zero-based unsigned number, defines\nthe type of the $(D k)th key of the container.\n\nA container may define both $(D KeyType) and $(D KeyTypes), e.g. in\nthe case it has the notion of primary\/preferred key.\n \n",
"line" : 270}
,
{
"name" : "ValueType",
"kind" : "alias",
"type" : "T",
"comment" : "\nIf the container has a notion of key-value mapping, $(D ValueType)\ndefines the type of the value of the container. Typically, a map-style\ncontainer mapping values of type $(D K) to values of type $(D V)\ndefines $(D KeyType) to be $(D K) and $(D ValueType) to be $(D V).\n \n",
"line" : 278}
,
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"comment" : "\nDefines the container's primary range, which embodies one of the\nranges defined in $(XREFMODULE range).\n\nGenerally a container may define several types of ranges.\n \n",
"line" : 287,
"members" : [
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : " Range primitives.\n",
"line" : 289}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 294}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 299}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 304}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 309}
,
{
"name" : "moveBack",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 314}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 319}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t i)",
"comment" : " Ditto\n",
"line" : 324}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T value, size_t i)",
"comment" : " Ditto\n",
"line" : 329}
,
{
"name" : "opIndexOpAssign(string op)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 334,
"members" : [
{
"name" : "opIndexOpAssign",
"kind" : "function",
"type" : "void(T value, uint i)",
"comment" : " Ditto\n",
"line" : 334}
]
}
,
{
"name" : "moveAt",
"kind" : "function",
"type" : "T(size_t i)",
"comment" : " Ditto\n",
"line" : 339}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : " Ditto\n",
"line" : 344}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n \n",
"line" : 356}
,
{
"name" : "dup",
"kind" : "function",
"type" : "TotalContainer()",
"comment" : "\nReturns a duplicate of the container. The elements themselves are not\ntransitively duplicated.\n\nComplexity: $(BIGOH n).\n \n",
"line" : 367}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : "\nReturns the number of elements in the container.\n\nComplexity: $(BIGOH log(n)).\n",
"line" : 377}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "size_t()",
"comment" : "\nReturns the maximum number of elements the container can store without\n(a) allocating memory, (b) invalidating iterators upon insertion.\n\nComplexity: $(BIGOH log(n)).\n \n",
"line" : 388}
,
{
"name" : "reserve",
"kind" : "function",
"type" : "void(size_t e)",
"comment" : "\nEnsures sufficient capacity to accommodate $(D n) elements.\n\nPostcondition: $(D capacity >= n)\n\nComplexity: $(BIGOH log(e - capacity)) if $(D e > capacity), otherwise\n$(BIGOH 1).\n \n",
"line" : 401}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"comment" : "\nReturns a range that iterates over all elements of the container, in a\ncontainer-defined order. The container should choose the most\nconvenient and fast method of iteration for $(D opSlice()).\n\nComplexity: $(BIGOH log(n))\n \n",
"line" : 413}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range(size_t a, size_t b)",
"comment" : "\n       Returns a range that iterates the container between two\n       specified positions.\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 424}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : "\nForward to $(D opSlice().front) and $(D opSlice().back), respectively.\n\nComplexity: $(BIGOH log(n))\n \n",
"line" : 434}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 439}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 444}
,
{
"name" : "moveBack",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 449}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "ValueType(KeyType)",
"comment" : "\nIndexing operators yield or modify the value at a specified index.\n \n\n       Indexing operators yield or modify the value at a specified index.\n     \n",
"line" : 460}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(KeyType)",
"comment" : " ditto\n",
"line" : 465}
,
{
"name" : "opIndexOpAssign(string op)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 470,
"members" : [
{
"name" : "opIndexOpAssign",
"kind" : "function",
"type" : "void(KeyType)",
"comment" : " ditto\n",
"line" : 470}
]
}
,
{
"name" : "moveAt",
"kind" : "function",
"type" : "T(size_t i)",
"line" : 474}
,
{
"name" : "opBinary(string op) if (op == \"in\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D k in container) returns true if the given key is in the container.\n \n",
"line" : 482,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "bool(KeyType k)",
"comment" : "\n$(D k in container) returns true if the given key is in the container.\n \n",
"line" : 482}
]
}
,
{
"name" : "equalRange",
"kind" : "function",
"type" : "Range(KeyType k)",
"comment" : "\nReturns a range of all elements containing $(D k) (could be empty or a\nsingleton range).\n \n",
"line" : 491}
,
{
"name" : "lowerBound",
"kind" : "function",
"type" : "Range(KeyType k)",
"comment" : "\nReturns a range of all elements with keys less than $(D k) (could be\nempty or a singleton range). Only defined by containers that store\ndata sorted at all times.\n \n",
"line" : 501}
,
{
"name" : "upperBound",
"kind" : "function",
"type" : "Range(KeyType k)",
"comment" : "\nReturns a range of all elements with keys larger than $(D k) (could be\nempty or a singleton range).  Only defined by containers that store\ndata sorted at all times.\n \n",
"line" : 511}
,
{
"name" : "opBinary(string op) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n \n",
"line" : 524,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "TotalContainer(Stuff rhs)",
"comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n \n",
"line" : 524}
]
}
,
{
"name" : "opBinaryRight(string op) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 530,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "TotalContainer(Stuff lhs)",
"comment" : " ditto\n",
"line" : 530}
]
}
,
{
"name" : "opOpAssign(string op) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : "\nForwards to $(D insertAfter(this[], stuff)).\n \n",
"line" : 538,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "void(Stuff stuff)",
"comment" : "\nForwards to $(D insertAfter(this[], stuff)).\n \n",
"line" : 538}
]
}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves all contents from the container. The container decides how $(D\ncapacity) is affected.\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH n)\n \n",
"line" : 551}
,
{
"name" : "length",
"kind" : "function",
"type" : "void(size_t newLength)",
"comment" : "\nSets the number of elements in the container to $(D newSize). If $(D\nnewSize) is greater than $(D length), the added elements are added to\nunspecified positions in the container and initialized with $(D\n.init).\n\nComplexity: $(BIGOH abs(n - newLength))\n\nPostcondition: $(D _length == newLength)\n \n",
"line" : 566}
,
{
"name" : "insert(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) in an unspecified position in the\ncontainer. Implementations should choose whichever insertion means is\nthe most advantageous for the container, but document the exact\nbehavior. $(D stuff) can be a value convertible to the element type of\nthe container, or a range of values convertible to it.\n\nThe $(D stable) version guarantees that ranges iterating over the\ncontainer are never invalidated. Client code that counts on\nnon-invalidating insertion should use $(D stableInsert). Such code would\nnot compile against containers that don't support it.\n\nReturns: The number of elements added.\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n \n",
"line" : 588,
"members" : [
{
"name" : "insert",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\nInserts $(D stuff) in an unspecified position in the\ncontainer. Implementations should choose whichever insertion means is\nthe most advantageous for the container, but document the exact\nbehavior. $(D stuff) can be a value convertible to the element type of\nthe container, or a range of values convertible to it.\n\nThe $(D stable) version guarantees that ranges iterating over the\ncontainer are never invalidated. Client code that counts on\nnon-invalidating insertion should use $(D stableInsert). Such code would\nnot compile against containers that don't support it.\n\nReturns: The number of elements added.\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n \n",
"line" : 588}
]
}
,
{
"name" : "stableInsert(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 593,
"members" : [
{
"name" : "stableInsert",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "ditto\n",
"line" : 593}
]
}
,
{
"name" : "linearInsert(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nSame as $(D insert(stuff)) and $(D stableInsert(stuff)) respectively,\nbut relax the complexity constraint to linear.\n \n",
"line" : 602,
"members" : [
{
"name" : "linearInsert",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\nSame as $(D insert(stuff)) and $(D stableInsert(stuff)) respectively,\nbut relax the complexity constraint to linear.\n \n",
"line" : 602}
]
}
,
{
"name" : "stableLinearInsert(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 607,
"members" : [
{
"name" : "stableLinearInsert",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "ditto\n",
"line" : 607}
]
}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "T()",
"comment" : "\nPicks one value in an unspecified position in the container, removes\nit from the container, and returns it. Implementations should pick the\nvalue that's the most advantageous for the container, but document the\nexact behavior. The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH log(n)).\n \n",
"line" : 625}
,
{
"name" : "stableRemoveAny",
"kind" : "function",
"type" : "T()",
"comment" : " ditto\n",
"line" : 630}
,
{
"name" : "insertFront(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof values convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n)).\n \n",
"line" : 646,
"members" : [
{
"name" : "insertFront",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof values convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n)).\n \n",
"line" : 646}
]
}
,
{
"name" : "stableInsertFront(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 651,
"members" : [
{
"name" : "stableInsertFront",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : " ditto\n",
"line" : 651}
]
}
,
{
"name" : "insertBack(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 656,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : " ditto\n",
"line" : 656}
]
}
,
{
"name" : "stableInsertBack",
"kind" : "function",
"type" : "size_t(T value)",
"comment" : " ditto\n",
"line" : 661}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves the value at the front or back of the container. The stable\nversion behaves the same, but guarantees that ranges iterating over\nthe container are never invalidated. The optional parameter $(D\nhowMany) instructs removal of that many elements. If $(D howMany > n),\nall elements are removed and no exception is thrown.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH log(n)).\n \n",
"line" : 677}
,
{
"name" : "stableRemoveFront",
"kind" : "function",
"type" : "void()",
"comment" : " ditto\n",
"line" : 682}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "void()",
"comment" : " ditto\n",
"line" : 687}
,
{
"name" : "stableRemoveBack",
"kind" : "function",
"type" : "void()",
"comment" : " ditto\n",
"line" : 692}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n \n",
"line" : 710}
,
{
"name" : "stableRemoveFront",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : " ditto\n",
"line" : 715}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : " ditto\n",
"line" : 720}
,
{
"name" : "stableRemoveBack",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : " ditto\n",
"line" : 725}
,
{
"name" : "removeKey",
"kind" : "function",
"type" : "size_t(KeyType k)",
"comment" : "\nRemoves all values corresponding to key $(D k).\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements with the same key.\n\nReturns: The number of elements removed.\n \n",
"line" : 738}
,
{
"name" : "insertBefore(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof objects convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n \n",
"line" : 755,
"members" : [
{
"name" : "insertBefore",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof objects convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n \n",
"line" : 755}
]
}
,
{
"name" : "stableInsertBefore(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 760,
"members" : [
{
"name" : "stableInsertBefore",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 760}
]
}
,
{
"name" : "insertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 765,
"members" : [
{
"name" : "insertAfter",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 765}
]
}
,
{
"name" : "stableInsertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 770,
"members" : [
{
"name" : "stableInsertAfter",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 770}
]
}
,
{
"name" : "replace(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 775,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 775}
]
}
,
{
"name" : "stableReplace(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 780,
"members" : [
{
"name" : "stableReplace",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 780}
]
}
,
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nRemoves all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves the\nsame, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D r)\n \n",
"line" : 797}
,
{
"name" : "stableRemove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : " ditto\n",
"line" : 802}
,
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nSame as $(D remove) above, but has complexity relaxed to linear.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH n)\n \n",
"line" : 815}
,
{
"name" : "stableLinearRemove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : " ditto\n",
"line" : 820}
]
}
]
}
,
{
"name" : "make(Container,T...) if (is(Container == struct))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns an initialized container. This function is mainly for\neliminating construction differences between $(D class) containers and\n$(D struct) containers.\n \n",
"line" : 835,
"members" : [
{
"name" : "make",
"kind" : "function",
"type" : "Container(T arguments)",
"comment" : "\nReturns an initialized container. This function is mainly for\neliminating construction differences between $(D class) containers and\n$(D struct) containers.\n \n",
"line" : 835}
]
}
,
{
"name" : "make(Container,T...) if (is(Container == class))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 844,
"members" : [
{
"name" : "make",
"kind" : "function",
"type" : "Container(T arguments)",
"comment" : " ditto\n",
"line" : 844}
]
}
,
{
"name" : "SList(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Implements a simple and fast singly-linked list.\n \n",
"line" : 853,
"members" : [
{
"name" : "SList",
"kind" : "struct",
"protection" : "public",
"line" : 853,
"members" : [
{
"name" : "Node",
"kind" : "struct",
"protection" : "public",
"line" : 855,
"members" : [
{
"name" : "_payload",
"kind" : "variable",
"type" : "T",
"line" : 856}
,
{
"name" : "_next",
"kind" : "variable",
"type" : "Node*",
"line" : 857}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T a, Node* b)",
"line" : 858}
]
}
,
{
"name" : "_root",
"kind" : "variable",
"type" : "Node*",
"line" : 860}
,
{
"name" : "findLastNode",
"kind" : "function",
"type" : "Node*(Node* n)",
"line" : 862}
,
{
"name" : "findLastNode",
"kind" : "function",
"type" : "Node*(Node* n, size_t limit)",
"line" : 874}
,
{
"name" : "findNode",
"kind" : "function",
"type" : "Node*(Node* n, Node* findMe)",
"line" : 887}
,
{
"name" : "__ctor(U) if (isImplicitlyConvertible!(U,T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor taking a number of nodes\n     \n",
"line" : 903,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(U[] values...)",
"line" : 903}
]
}
,
{
"name" : "__ctor(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T) && !is(Stuff == T[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor taking an input range\n     \n",
"line" : 911,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Stuff stuff)",
"line" : 911}
]
}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(const SList rhs)",
"comment" : "\nComparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n     \n",
"line" : 925}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(ref const SList rhs)",
"comment" : " ditto\n",
"line" : 931}
,
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"comment" : "\nDefines the container's primary range, which embodies a forward range.\n     \n",
"line" : 946,
"members" : [
{
"name" : "_head",
"kind" : "variable",
"type" : "Node*",
"line" : 947}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Node* p)",
"line" : 948}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : " Forward range primitives.\n",
"line" : 950}
,
{
"name" : "save",
"kind" : "function",
"type" : "Range()",
"comment" : " ditto\n",
"line" : 952}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : " ditto\n",
"line" : 954}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " ditto\n",
"line" : 965}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "T()",
"line" : 971}
,
{
"name" : "sameHead",
"kind" : "function",
"type" : "bool(Range rhs)",
"line" : 977}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 994}
,
{
"name" : "dup",
"kind" : "function",
"type" : "SList()",
"comment" : "\nDuplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n     \n",
"line" : 1005}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"comment" : "\nReturns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1016}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : "\nForward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1026}
,
{
"name" : "opBinary(string op,Stuff) if (op == \"~\" && is(typeof(SList(rhs))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a new $(D SList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n     \n",
"line" : 1058,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "SList(Stuff rhs)",
"comment" : "\nReturns a new $(D SList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n     \n",
"line" : 1058}
]
}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves all contents from the $(D SList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1081}
,
{
"name" : "insertFront(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) to the front of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n     \n",
"line" : 1096,
"members" : [
{
"name" : "insertFront",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\nInserts $(D stuff) to the front of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n     \n",
"line" : 1096}
]
}
,
{
"name" : "insertFront(Stuff) if (isImplicitlyConvertible!(Stuff,T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1116,
"members" : [
{
"name" : "insertFront",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : " ditto\n",
"line" : 1116}
]
}
,
{
"name" : "insert",
"kind" : "alias",
"type" : "insertFront",
"comment" : " ditto\n",
"line" : 1125}
,
{
"name" : "stableInsert",
"kind" : "alias",
"type" : "insert",
"comment" : " ditto\n",
"line" : 1128}
,
{
"name" : "stableInsertFront",
"kind" : "alias",
"type" : "insertFront",
"comment" : " ditto\n",
"line" : 1131}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "T()",
"comment" : "\nPicks one value from the front of the container, removes it from the\ncontainer, and returns it.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n     \n",
"line" : 1143}
,
{
"name" : "stableRemoveAny",
"kind" : "alias",
"type" : "removeAny",
"comment" : " ditto\n",
"line" : 1151}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves the value at the front of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n     \n",
"line" : 1162}
,
{
"name" : "stableRemoveFront",
"kind" : "alias",
"type" : "removeFront",
"comment" : " ditto\n",
"line" : 1169}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n     \n",
"line" : 1184}
,
{
"name" : "stableRemoveFront",
"kind" : "alias",
"type" : "removeFront",
"comment" : " ditto\n",
"line" : 1196}
,
{
"name" : "insertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) after range $(D r), which must be a range\npreviously extracted from this container. Given that all ranges for a\nlist end at the end of the list, this function essentially appends to\nthe list and uses $(D r) as a potentially fast way to reach the last\nnode in the list. Ideally $(D r) is positioned near or at the last\nelement of the list.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n\nExamples:\n--------------------\nauto sl = SList!string([\"a\", \"b\", \"d\"]);\nsl.insertAfter(sl[], \"e\"); \/\/ insert at the end (slowest)\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"d\", \"e\"]));\nsl.insertAfter(std.range.take(sl[], 2), \"c\"); \/\/ insert after \"b\"\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"c\", \"d\", \"e\"]));\n--------------------\n     \n",
"line" : 1226,
"members" : [
{
"name" : "insertAfter",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : "\nInserts $(D stuff) after range $(D r), which must be a range\npreviously extracted from this container. Given that all ranges for a\nlist end at the end of the list, this function essentially appends to\nthe list and uses $(D r) as a potentially fast way to reach the last\nnode in the list. Ideally $(D r) is positioned near or at the last\nelement of the list.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n\nExamples:\n--------------------\nauto sl = SList!string([\"a\", \"b\", \"d\"]);\nsl.insertAfter(sl[], \"e\"); \/\/ insert at the end (slowest)\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"d\", \"e\"]));\nsl.insertAfter(std.range.take(sl[], 2), \"c\"); \/\/ insert after \"b\"\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"c\", \"d\", \"e\"]));\n--------------------\n     \n",
"line" : 1226}
]
}
,
{
"name" : "insertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nSimilar to $(D insertAfter) above, but accepts a range bounded in\ncount. This is important for ensuring fast insertions in the middle of\nthe list.  For fast insertions after a specified position $(D r), use\n$(D insertAfter(take(r, 1), stuff)). The complexity of that operation\nonly depends on the number of elements in $(D stuff).\n\nPrecondition: $(D r.original.empty || r.maxLength > 0)\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
"line" : 1255,
"members" : [
{
"name" : "insertAfter",
"kind" : "function",
"type" : "size_t(Take!(Range) r, Stuff stuff)",
"comment" : "\nSimilar to $(D insertAfter) above, but accepts a range bounded in\ncount. This is important for ensuring fast insertions in the middle of\nthe list.  For fast insertions after a specified position $(D r), use\n$(D insertAfter(take(r, 1), stuff)). The complexity of that operation\nonly depends on the number of elements in $(D stuff).\n\nPrecondition: $(D r.original.empty || r.maxLength > 0)\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
"line" : 1255}
]
}
,
{
"name" : "stableInsertAfter",
"kind" : "alias",
"type" : "insertAfter",
"comment" : " ditto\n",
"line" : 1280}
,
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nRemoves a range from the list in linear time.\n\nReturns: An empty range.\n\nComplexity: $(BIGOH n)\n     \n",
"line" : 1289}
,
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(Take!(Range) r)",
"comment" : "\nRemoves a $(D Take!Range) from the list in linear time.\n\nReturns: A range comprehending the elements after the removed range.\n\nComplexity: $(BIGOH n)\n     \n",
"line" : 1308}
,
{
"name" : "stableLinearRemove",
"kind" : "alias",
"type" : "linearRemove",
"comment" : " ditto\n",
"line" : 1335}
]
}
]
}
,
{
"name" : "DList(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Implements a doubly-linked list.\n \n",
"line" : 1489,
"members" : [
{
"name" : "DList",
"kind" : "struct",
"protection" : "public",
"line" : 1489,
"members" : [
{
"name" : "Node",
"kind" : "struct",
"protection" : "public",
"line" : 1491,
"members" : [
{
"name" : "_payload",
"kind" : "variable",
"type" : "T",
"line" : 1492}
,
{
"name" : "_prev",
"kind" : "variable",
"type" : "Node*",
"line" : 1493}
,
{
"name" : "_next",
"kind" : "variable",
"type" : "Node*",
"line" : 1494}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T a, Node* p, Node* n)",
"line" : 1495}
]
}
,
{
"name" : "_first",
"kind" : "variable",
"type" : "Node*",
"line" : 1503}
,
{
"name" : "_last",
"kind" : "variable",
"type" : "Node*",
"line" : 1504}
,
{
"name" : "__ctor(U) if (isImplicitlyConvertible!(U,T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor taking a number of nodes\n     \n",
"line" : 1509,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(U[] values...)",
"line" : 1509}
]
}
,
{
"name" : "__ctor(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T) && !is(Stuff == T[]))",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor taking an input range\n     \n",
"line" : 1517,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Stuff stuff)",
"line" : 1517}
]
}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(ref const DList rhs)",
"comment" : "\nComparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n     \n",
"line" : 1531}
,
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Defines the container's primary range, which embodies a bidirectional range.\n     \n",
"line" : 1546,
"members" : [
{
"name" : "_first",
"kind" : "variable",
"type" : "Node*",
"line" : 1547}
,
{
"name" : "_last",
"kind" : "variable",
"type" : "Node*",
"line" : 1548}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Node* first, Node* last)",
"line" : 1549}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Node* n)",
"line" : 1550}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : " Forward range primitives.\n",
"line" : 1552}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"line" : 1553}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 1554}
,
{
"name" : "save",
"kind" : "function",
"type" : "Range()",
"line" : 1567}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " Bidirectional range primitives.\n",
"line" : 1569}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"line" : 1570}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1596}
,
{
"name" : "dup",
"kind" : "function",
"type" : "DList()",
"comment" : "\nDuplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n     \n",
"line" : 1607}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"comment" : "\nReturns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1618}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : "\nForward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1628}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"line" : 1634}
,
{
"name" : "opBinary(string op,Stuff) if (op == \"~\" && (is(Stuff == DList) || is(typeof(DList(rhs)))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a new $(D DList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n     \n",
"line" : 1645,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "DList(Stuff rhs)",
"comment" : "\nReturns a new $(D DList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n     \n",
"line" : 1645}
]
}
,
{
"name" : "opOpassign(string op,Stuff) if (op == \"~\" && is(Stuff == DList))",
"kind" : "template",
"protection" : "public",
"line" : 1653,
"members" : [
{
"name" : "opOpassign",
"kind" : "function",
"type" : "DList(Stuff rhs)",
"line" : 1653}
]
}
,
{
"name" : "opOpassign(string op,Stuff) if (op == \"~\" && is(typeof(DList(rhs))))",
"kind" : "template",
"protection" : "public",
"line" : 1660,
"members" : [
{
"name" : "opOpassign",
"kind" : "function",
"type" : "DList(Stuff rhs)",
"line" : 1660}
]
}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves all contents from the $(D DList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 1673}
,
{
"name" : "insertFront(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) to the front\/back of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n     \n",
"line" : 1688,
"members" : [
{
"name" : "insertFront",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\nInserts $(D stuff) to the front\/back of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n     \n",
"line" : 1688}
]
}
,
{
"name" : "insertBack(Stuff)",
"kind" : "template",
"protection" : "public",
"line" : 1694,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"line" : 1694}
]
}
,
{
"name" : "insert",
"kind" : "alias",
"type" : "insertBack",
"comment" : " ditto\n",
"line" : 1700}
,
{
"name" : "stableInsert",
"kind" : "alias",
"type" : "insert",
"comment" : " ditto\n",
"line" : 1703}
,
{
"name" : "stableInsertFront",
"kind" : "alias",
"type" : "insertFront",
"comment" : " ditto\n",
"line" : 1706}
,
{
"name" : "stableInsertBack",
"kind" : "alias",
"type" : "insertBack",
"comment" : " ditto\n",
"line" : 1709}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "T()",
"comment" : "\nPicks one value from the front of the container, removes it from the\ncontainer, and returns it.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n     \n",
"line" : 1721}
,
{
"name" : "stableRemoveAny",
"kind" : "alias",
"type" : "removeAny",
"comment" : " ditto\n",
"line" : 1729}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves the value at the front\/back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n     \n",
"line" : 1740}
,
{
"name" : "stableRemoveFront",
"kind" : "alias",
"type" : "removeFront",
"comment" : " ditto\n",
"line" : 1751}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "void()",
"comment" : " ditto\n",
"line" : 1754}
,
{
"name" : "stableRemoveBack",
"kind" : "alias",
"type" : "removeBack",
"comment" : " ditto\n",
"line" : 1765}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n     \n",
"line" : 1780}
,
{
"name" : "stableRemoveFront",
"kind" : "alias",
"type" : "removeFront",
"comment" : " ditto\n",
"line" : 1796}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : " ditto\n",
"line" : 1799}
,
{
"name" : "stableRemoveBack",
"kind" : "alias",
"type" : "removeBack",
"comment" : " ditto\n",
"line" : 1815}
,
{
"name" : "insertBefore(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) after range $(D r), which must be a non-empty range\npreviously extracted from this container.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
"line" : 1832,
"members" : [
{
"name" : "insertBefore",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : "\nInserts $(D stuff) after range $(D r), which must be a non-empty range\npreviously extracted from this container.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
"line" : 1832}
]
}
,
{
"name" : "stableInsertBefore",
"kind" : "alias",
"type" : "insertBefore",
"comment" : " ditto\n",
"line" : 1838}
,
{
"name" : "insertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"line" : 1841,
"members" : [
{
"name" : "insertAfter",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"line" : 1841}
]
}
,
{
"name" : "stableInsertAfter",
"kind" : "alias",
"type" : "insertAfter",
"comment" : " ditto\n",
"line" : 1848}
,
{
"name" : "insertBeforeNode(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T))",
"kind" : "template",
"protection" : "public",
"comment" : " Helper: insert $(D stuff) before Node $(D n). If $(D n) is $(D null) then insert at end.\n",
"line" : 1851,
"members" : [
{
"name" : "insertBeforeNode",
"kind" : "function",
"type" : "size_t(Node* n, Stuff stuff)",
"line" : 1851}
]
}
,
{
"name" : "insertBeforeNode(Stuff) if (isImplicitlyConvertible!(Stuff,T))",
"kind" : "template",
"protection" : "public",
"comment" : " Helper: insert $(D stuff) before Node $(D n). If $(D n) is $(D null) then insert at end.\n",
"line" : 1880,
"members" : [
{
"name" : "insertBeforeNode",
"kind" : "function",
"type" : "size_t(Node* n, Stuff stuff)",
"line" : 1880}
]
}
,
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nRemoves all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves the\nsame, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH 1)\n \n",
"line" : 1914}
,
{
"name" : "stableRemove",
"kind" : "alias",
"type" : "remove",
"comment" : " ditto\n",
"line" : 1943}
,
{
"name" : "linearRemove(R) if (is(R == Range))",
"kind" : "template",
"protection" : "public",
"line" : 1944,
"members" : [
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(R r)",
"line" : 1946}
]
}
,
{
"name" : "linearRemove(R) if (isInputRange!(R) && is(typeof(r.source)))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1950,
"members" : [
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(R r)",
"comment" : " ditto\n",
"line" : 1950}
]
}
,
{
"name" : "stableLinearRemove",
"kind" : "alias",
"type" : "linearRemove",
"comment" : " ditto\n",
"line" : 1969}
]
}
]
}
,
{
"name" : "Array(T) if (!is(T : const(bool)))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nArray type with deterministic control of memory. The memory allocated\nfor the array is reclaimed as soon as possible; there is no reliance\non the garbage collector. $(D Array) uses $(D malloc) and $(D free)\nfor managing its own memory.\n \n",
"line" : 2068,
"members" : [
{
"name" : "Array",
"kind" : "struct",
"protection" : "public",
"line" : 2068,
"members" : [
{
"name" : "Payload",
"kind" : "struct",
"protection" : "public",
"line" : 2071,
"members" : [
{
"name" : "_capacity",
"kind" : "variable",
"type" : "size_t",
"line" : 2072}
,
{
"name" : "_payload",
"kind" : "variable",
"type" : "T[]",
"line" : 2073}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T[] p)",
"line" : 2076}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(Array!(T).Payload rhs)",
"line" : 2092}
,
{
"name" : "length",
"kind" : "function",
"type" : "const size_t()",
"line" : 2108}
,
{
"name" : "length",
"kind" : "function",
"type" : "void(size_t newLength)",
"line" : 2114}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "const size_t()",
"line" : 2137}
,
{
"name" : "reserve",
"kind" : "function",
"type" : "void(size_t elements)",
"line" : 2143}
,
{
"name" : "insertBack(Stuff) if (isImplicitlyConvertible!(Stuff,T))",
"kind" : "template",
"protection" : "public",
"line" : 2182,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"line" : 2182}
]
}
,
{
"name" : "insertBack(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T))",
"kind" : "template",
"protection" : "public",
"comment" : " Insert a range of items\n",
"line" : 2196,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : " Insert a range of items\n",
"line" : 2196}
]
}
]
}
,
{
"name" : "Data",
"kind" : "alias",
"type" : "RefCounted!(Payload,RefCountedAutoInitialize.no)",
"line" : 2217}
,
{
"name" : "_data",
"kind" : "variable",
"type" : "Data",
"line" : 2218}
,
{
"name" : "__ctor(U) if (isImplicitlyConvertible!(U,T))",
"kind" : "template",
"protection" : "public",
"line" : 2220,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(U[] values...)",
"line" : 2220}
]
}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(const Array rhs)",
"comment" : "\nComparison for equality.\n     \n",
"line" : 2238}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(ref const Array rhs)",
"comment" : " ditto\n",
"line" : 2244}
,
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"comment" : "\nDefines the container's primary range, which is a random-access range.\n     \n",
"line" : 2255,
"members" : [
{
"name" : "_outer",
"kind" : "variable",
"type" : "Array",
"line" : 2256}
,
{
"name" : "_a",
"kind" : "variable",
"type" : "size_t",
"line" : 2257}
,
{
"name" : "_b",
"kind" : "variable",
"type" : "size_t",
"line" : 2257}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Array data, size_t a, size_t b)",
"line" : 2259}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"line" : 2266}
,
{
"name" : "save",
"kind" : "function",
"type" : "Range()",
"line" : 2272}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"line" : 2277}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"line" : 2283}
,
{
"name" : "front",
"kind" : "function",
"type" : "void(T value)",
"line" : 2289}
,
{
"name" : "back",
"kind" : "function",
"type" : "void(T value)",
"line" : 2295}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2301}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"line" : 2307}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "T()",
"line" : 2313}
,
{
"name" : "moveBack",
"kind" : "function",
"type" : "T()",
"line" : 2319}
,
{
"name" : "moveAt",
"kind" : "function",
"type" : "T(size_t i)",
"line" : 2325}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t i)",
"line" : 2332}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T value, size_t i)",
"line" : 2339}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "typeof(this)(size_t a, size_t b)",
"line" : 2346}
,
{
"name" : "opIndexOpAssign(string op)",
"kind" : "template",
"protection" : "public",
"line" : 2351,
"members" : [
{
"name" : "opIndexOpAssign",
"kind" : "function",
"type" : "void(T value, size_t i)",
"line" : 2351}
]
}
,
{
"name" : "length",
"kind" : "function",
"type" : "const size_t()",
"line" : 2357}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2368}
,
{
"name" : "dup",
"kind" : "function",
"type" : "Array()",
"comment" : "\nDuplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n     \n",
"line" : 2379}
,
{
"name" : "length",
"kind" : "function",
"type" : "const size_t()",
"comment" : "\nReturns the number of elements in the container.\n\nComplexity: $(BIGOH 1).\n     \n",
"line" : 2390}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "size_t()",
"comment" : "\nReturns the maximum number of elements the container can store without\n   (a) allocating memory, (b) invalidating iterators upon insertion.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2401}
,
{
"name" : "reserve",
"kind" : "function",
"type" : "void(size_t elements)",
"comment" : "\nEnsures sufficient capacity to accommodate $(D e) elements.\n\nPostcondition: $(D capacity >= e)\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2413}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"comment" : "\nReturns a range that iterates over elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2439}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range(size_t a, size_t b)",
"comment" : "\nReturns a range that iterates over elements of the container from\nindex $(D a) up to (excluding) index $(D b).\n\nPrecondition: $(D a <= b && b <= length)\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2455}
,
{
"name" : "opDollar",
"kind" : "function",
"type" : "const size_t()",
"comment" : "\n@@@BUG@@@ This doesn't work yet\n     \n",
"line" : 2467}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : "\nForward to $(D opSlice().front) and $(D opSlice().back), respectively.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2479}
,
{
"name" : "front",
"kind" : "function",
"type" : "void(T value)",
"comment" : " ditto\n",
"line" : 2486}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " ditto\n",
"line" : 2493}
,
{
"name" : "back",
"kind" : "function",
"type" : "void(T value)",
"comment" : " ditto\n",
"line" : 2500}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t i)",
"comment" : "\nIndexing operators yield or modify the value at a specified index.\n\nPrecondition: $(D i < length)\n\nComplexity: $(BIGOH 1)\n     \n",
"line" : 2513}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T value, size_t i)",
"comment" : " ditto\n",
"line" : 2520}
,
{
"name" : "opIndexOpAssign(string op)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2527,
"members" : [
{
"name" : "opIndexOpAssign",
"kind" : "function",
"type" : "void(T value, size_t i)",
"comment" : " ditto\n",
"line" : 2527}
]
}
,
{
"name" : "opBinary(string op,Stuff) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n     \n",
"line" : 2540,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "Array(Stuff stuff)",
"comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n     \n",
"line" : 2540}
]
}
,
{
"name" : "opOpAssign(string op,Stuff) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n       Forwards to $(D insertBack(stuff)).\n     \n",
"line" : 2555,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "void(Stuff stuff)",
"comment" : "\n       Forwards to $(D insertBack(stuff)).\n     \n",
"line" : 2555}
]
}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves all contents from the container. The container decides how $(D\ncapacity) is affected.\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH n)\n     \n",
"line" : 2575}
,
{
"name" : "length",
"kind" : "function",
"type" : "void(size_t newLength)",
"comment" : "\nSets the number of elements in the container to $(D newSize). If $(D\nnewSize) is greater than $(D length), the added elements are added to\nunspecified positions in the container and initialized with $(D\nT.init).\n\nComplexity: $(BIGOH abs(n - newLength))\n\nPostcondition: $(D length == newLength)\n     \n",
"line" : 2590}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "T()",
"comment" : "\nPicks one value in an unspecified position in the container, removes\nit from the container, and returns it. Implementations should pick the\nvalue that's the most advantageous for the container, but document the\nexact behavior. The stable version behaves the same, but guarantees\nthat ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH log(n)).\n     \n",
"line" : 2609}
,
{
"name" : "stableRemoveAny",
"kind" : "alias",
"type" : "removeAny",
"comment" : " ditto\n",
"line" : 2616}
,
{
"name" : "insertBack(Stuff) if (isImplicitlyConvertible!(Stuff,T) || isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n     \n",
"line" : 2629,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n     \n",
"line" : 2629}
]
}
,
{
"name" : "insert",
"kind" : "alias",
"type" : "insertBack",
"comment" : " ditto\n",
"line" : 2637}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves the value at the back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH log(n)).\n     \n",
"line" : 2648}
,
{
"name" : "stableRemoveBack",
"kind" : "alias",
"type" : "removeBack",
"comment" : " ditto\n",
"line" : 2659}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "size_t(size_t howMany)",
"comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany).\n     \n",
"line" : 2674}
,
{
"name" : "stableRemoveBack",
"kind" : "alias",
"type" : "removeBack",
"comment" : " ditto\n",
"line" : 2689}
,
{
"name" : "insertBefore(Stuff) if (isImplicitlyConvertible!(Stuff,T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
"line" : 2702,
"members" : [
{
"name" : "insertBefore",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
"line" : 2702}
]
}
,
{
"name" : "insertBefore(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2718,
"members" : [
{
"name" : "insertBefore",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 2718}
]
}
,
{
"name" : "insertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2756,
"members" : [
{
"name" : "insertAfter",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 2756}
]
}
,
{
"name" : "replace(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2769,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 2769}
]
}
,
{
"name" : "replace(Stuff) if (isImplicitlyConvertible!(Stuff,T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2791,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 2791}
]
}
,
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\nRemoves all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH n - m), where $(D m) is the number of elements in\n$(D r)\n     \n",
"line" : 2820}
,
{
"name" : "stableLinearRemove",
"kind" : "alias",
"type" : "remove",
"comment" : " ditto\n",
"line" : 2835}
]
}
]
}
,
{
"name" : "BinaryHeap(Store,alias less = \"a < b\") if (isRandomAccessRange!(Store) || isRandomAccessRange!(typeof(Store.init[])))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nImplements a $(WEB en.wikipedia.org\/wiki\/Binary_heap, binary heap)\ncontainer on top of a given random-access range type (usually $(D\nT[])) or a random-access container type (usually $(D Array!T)). The\ndocumentation of $(D BinaryHeap) will refer to the underlying range or\ncontainer as the $(I store) of the heap.\n\nThe binary heap induces structure over the underlying store such that\naccessing the largest element (by using the $(D front) property) is a\n$(BIGOH 1) operation and extracting it (by using the $(D\nremoveFront()) method) is done fast in $(BIGOH log n) time.\n\nIf $(D less) is the less-than operator, which is the default option,\nthen $(D BinaryHeap) defines a so-called max-heap that optimizes\nextraction of the $(I largest) elements. To define a min-heap,\ninstantiate BinaryHeap with $(D \"a > b\") as its predicate.\n\nSimply extracting elements from a $(D BinaryHeap) container is\ntantamount to lazily fetching elements of $(D Store) in descending\norder. Extracting elements from the $(D BinaryHeap) to completion\nleaves the underlying store sorted in ascending order but, again,\nyields elements in descending order.\n\nIf $(D Store) is a range, the $(D BinaryHeap) cannot grow beyond the\nsize of that range. If $(D Store) is a container that supports $(D\ninsertBack), the $(D BinaryHeap) may grow by adding elements to the\ncontainer.\n\nExample:\n----\n\/\/ Example from \"Introduction to Algorithms\" Cormen et al, p 146\nint[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];\nauto h = heapify(a);\n\/\/ largest element\nassert(h.front == 16);\n\/\/ a has the heap property\nassert(equal(a, [ 16, 14, 10, 9, 8, 7, 4, 3, 2, 1 ]));\n----\n     \n",
"line" : 3093,
"members" : [
{
"name" : "BinaryHeap",
"kind" : "struct",
"protection" : "public",
"line" : 3093,
"members" : [
{
"name" : "_payload",
"kind" : "variable",
"type" : "RefCounted!(Tuple!(Store,\"_store\",size_t,\"_length\"),RefCountedAutoInitialize.no)",
"line" : 3100}
,
{
"name" : "comp",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 3102}
,
{
"name" : "_store",
"kind" : "function",
"type" : "Store()",
"line" : 3104}
,
{
"name" : "_length",
"kind" : "function",
"type" : "size_t()",
"line" : 3109}
,
{
"name" : "assertValid",
"kind" : "function",
"type" : "void()",
"line" : 3116}
,
{
"name" : "percolateDown",
"kind" : "function",
"type" : "void(Store r, size_t i, size_t length)",
"line" : 3133}
,
{
"name" : "pop",
"kind" : "function",
"type" : "void(Store store)",
"line" : 3155}
,
{
"name" : "swap",
"kind" : "function",
"type" : "void(Store _store, size_t i, size_t j)",
"line" : 3166}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Store s, size_t initialSize = size_t.max)",
"comment" : "\n       Converts the store $(D s) into a heap. If $(D initialSize) is\n       specified, only the first $(D initialSize) elements in $(D s)\n       are transformed into a heap, after which the heap can grow up\n       to $(D r.length) (if $(D Store) is a range) or indefinitely (if\n       $(D Store) is a container with $(D insertBack)). Performs\n       $(BIGOH min(r.length, initialSize)) evaluations of $(D less).\n     \n",
"line" : 3198}
,
{
"name" : "acquire",
"kind" : "function",
"type" : "void(Store s, size_t initialSize = size_t.max)",
"comment" : "\nTakes ownership of a store. After this, manipulating $(D s) may make\nthe heap work incorrectly.\n     \n",
"line" : 3207}
,
{
"name" : "assume",
"kind" : "function",
"type" : "void(Store s, size_t initialSize = size_t.max)",
"comment" : "\nTakes ownership of a store assuming it already was organized as a\nheap.\n     \n",
"line" : 3225}
,
{
"name" : "release",
"kind" : "function",
"type" : "()",
"comment" : "\nClears the heap. Returns the portion of the store from $(D 0) up to\n$(D length), which satisfies the $(LUCKY heap property).\n     \n",
"line" : 3238}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\nReturns $(D true) if the heap is _empty, $(D false) otherwise.\n     \n",
"line" : 3252}
,
{
"name" : "dup",
"kind" : "function",
"type" : "BinaryHeap()",
"comment" : "\nReturns a duplicate of the heap. The underlying store must also\nsupport a $(D dup) method.\n     \n",
"line" : 3261}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : "\nReturns the _length of the heap.\n     \n",
"line" : 3272}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "size_t()",
"comment" : "\nReturns the _capacity of the heap, which is the length of the\nunderlying store (if the store is a range) or the _capacity of the\nunderlying store (if the store is a container).\n     \n",
"line" : 3282}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType!(Store)()",
"comment" : "\nReturns a copy of the _front of the heap, which is the largest element\naccording to $(D less).\n     \n",
"line" : 3299}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\nClears the heap by detaching it from the underlying store.\n     \n",
"line" : 3308}
,
{
"name" : "insert",
"kind" : "function",
"type" : "size_t(ElementType!(Store) value)",
"comment" : "\nInserts $(D value) into the store. If the underlying store is a range\nand $(D length == capacity), throws an exception.\n     \n",
"line" : 3317}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "void()",
"comment" : "\nRemoves the largest element from the heap.\n     \n",
"line" : 3358}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "ElementType!(Store)()",
"comment" : "\nRemoves the largest element from the heap and returns a copy of\nit. The element still resides in the heap's store. For performance\nreasons you may want to use $(D removeFront) with heaps of objects\nthat are expensive to copy.\n     \n",
"line" : 3378}
,
{
"name" : "replaceFront",
"kind" : "function",
"type" : "void(ElementType!(Store) value)",
"comment" : "\nReplaces the largest element in the store with $(D value).\n     \n",
"line" : 3387}
,
{
"name" : "conditionalInsert",
"kind" : "function",
"type" : "bool(ElementType!(Store) value)",
"comment" : "\nIf the heap has room to grow, inserts $(D value) into the store and\nreturns $(D true). Otherwise, if $(D less(value, front)), calls $(D\nreplaceFront(value)) and returns again $(D true). Otherwise, leaves\nthe heap unaffected and returns $(D false). This method is useful in\nscenarios where the smallest $(D k) elements of a set of candidates\nmust be collected.\n     \n",
"line" : 3404}
]
}
]
}
,
{
"name" : "heapify(Store)",
"kind" : "template",
"protection" : "public",
"comment" : "\nConvenience function that returns a $(D BinaryHeap!Store) object\ninitialized with $(D s) and $(D initialSize).\n \n",
"line" : 3426,
"members" : [
{
"name" : "heapify",
"kind" : "function",
"type" : "BinaryHeap!(Store)(Store s, size_t initialSize = size_t.max)",
"comment" : "\nConvenience function that returns a $(D BinaryHeap!Store) object\ninitialized with $(D s) and $(D initialSize).\n \n",
"line" : 3426}
]
}
,
{
"name" : "Array(T) if (is(T == bool))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n\n\n_Array specialized for $(D bool). Packs together values efficiently by\nallocating one bit per element.\n \n",
"line" : 3468,
"members" : [
{
"name" : "Array",
"kind" : "struct",
"protection" : "public",
"line" : 3468,
"members" : [
{
"name" : "bitsPerWord",
"kind" : "variable",
"type" : "uint",
"line" : 3469}
,
{
"name" : "Data",
"kind" : "alias",
"type" : "Tuple!(Array!(size_t).Payload,\"_backend\",ulong,\"_length\")",
"line" : 3471}
,
{
"name" : "_store",
"kind" : "variable",
"type" : "RefCounted!(Data,RefCountedAutoInitialize.no)",
"line" : 3472}
,
{
"name" : "data",
"kind" : "function",
"type" : "size_t[]()",
"line" : 3474}
,
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"comment" : "\n       Defines the container's primary range.\n     \n",
"line" : 3484,
"members" : [
{
"name" : "_outer",
"kind" : "variable",
"type" : "Array!(bool)",
"line" : 3485}
,
{
"name" : "_a",
"kind" : "variable",
"type" : "ulong",
"line" : 3486}
,
{
"name" : "_b",
"kind" : "variable",
"type" : "ulong",
"line" : 3486}
,
{
"name" : "save",
"kind" : "function",
"type" : "Range()",
"comment" : " Range primitives\n",
"line" : 3488}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : " Ditto\n",
"line" : 3501}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 3506}
,
{
"name" : "front",
"kind" : "function",
"type" : "void(bool value)",
"comment" : " Ditto\n",
"line" : 3512}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 3518}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 3524}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 3530}
,
{
"name" : "moveBack",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 3536}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 3542}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t i)",
"comment" : " Ditto\n",
"line" : 3548}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T value, size_t i)",
"comment" : " Ditto\n",
"line" : 3553}
,
{
"name" : "moveAt",
"kind" : "function",
"type" : "T(size_t i)",
"comment" : " Ditto\n",
"line" : 3558}
,
{
"name" : "length",
"kind" : "function",
"type" : "const ulong()",
"comment" : " Ditto\n",
"line" : 3563}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\n       Property returning $(D true) if and only if the container has\n       no elements.\n\n       Complexity: $(BIGOH 1)\n     \n",
"line" : 3576}
,
{
"name" : "dup",
"kind" : "function",
"type" : "Array!(bool)()",
"comment" : "\n       Returns a duplicate of the container. The elements themselves\n       are not transitively duplicated.\n\n       Complexity: $(BIGOH n).\n     \n",
"line" : 3596}
,
{
"name" : "length",
"kind" : "function",
"type" : "ulong()",
"comment" : "\n       Returns the number of elements in the container.\n\n       Complexity: $(BIGOH log(n)).\n    \n",
"line" : 3618}
,
{
"name" : "capacity",
"kind" : "function",
"type" : "ulong()",
"comment" : "\n       Returns the maximum number of elements the container can store\n       without (a) allocating memory, (b) invalidating iterators upon\n       insertion.\n\n       Complexity: $(BIGOH log(n)).\n     \n",
"line" : 3638}
,
{
"name" : "reserve",
"kind" : "function",
"type" : "void(ulong e)",
"comment" : "\n       Ensures sufficient capacity to accommodate $(D n) elements.\n\n       Postcondition: $(D capacity >= n)\n\n       Complexity: $(BIGOH log(e - capacity)) if $(D e > capacity),\n       otherwise $(BIGOH 1).\n     \n",
"line" : 3664}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"comment" : "\n       Returns a range that iterates over all elements of the\n       container, in a container-defined order. The container should\n       choose the most convenient and fast method of iteration for $(D\n       opSlice()).\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 3686}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range(ulong a, ulong b)",
"comment" : "\n       Returns a range that iterates the container between two\n       specified positions.\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 3704}
,
{
"name" : "front",
"kind" : "function",
"type" : "bool()",
"comment" : "\n       Equivalent to $(D opSlice().front) and $(D opSlice().back),\n       respectively.\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 3723}
,
{
"name" : "front",
"kind" : "function",
"type" : "void(bool value)",
"comment" : " Ditto\n",
"line" : 3730}
,
{
"name" : "back",
"kind" : "function",
"type" : "bool()",
"comment" : " Ditto\n",
"line" : 3747}
,
{
"name" : "back",
"kind" : "function",
"type" : "void(bool value)",
"comment" : " Ditto\n",
"line" : 3754}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "bool(ulong i)",
"comment" : "\n       Indexing operators yield or modify the value at a specified index.\n     \n",
"line" : 3780}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(bool value, ulong i)",
"comment" : " ditto\n",
"line" : 3788}
,
{
"name" : "opIndexOpAssign(string op)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 3797,
"members" : [
{
"name" : "opIndexOpAssign",
"kind" : "function",
"type" : "void(bool value, ulong i)",
"comment" : " ditto\n",
"line" : 3797}
]
}
,
{
"name" : "moveAt",
"kind" : "function",
"type" : "T(ulong i)",
"comment" : " Ditto\n",
"line" : 3813}
,
{
"name" : "opBinary(string op,Stuff) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n       Returns a new container that's the concatenation of $(D this)\n       and its argument.\n\n       Complexity: $(BIGOH n + m), where m is the number of elements\n       in $(D stuff)\n     \n",
"line" : 3834,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "Array!(bool)(Stuff rhs)",
"comment" : "\n       Returns a new container that's the concatenation of $(D this)\n       and its argument.\n\n       Complexity: $(BIGOH n + m), where m is the number of elements\n       in $(D stuff)\n     \n",
"line" : 3834}
]
}
,
{
"name" : "opOpAssign(string op,Stuff) if (op == \"~\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n       Forwards to $(D insertAfter(this[], stuff)).\n     \n",
"line" : 3861,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "Array!(bool)(Stuff stuff)",
"comment" : "\n       Forwards to $(D insertAfter(this[], stuff)).\n     \n",
"line" : 3861}
]
}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\n       Removes all contents from the container. The container decides\n       how $(D capacity) is affected.\n\n       Postcondition: $(D empty)\n\n       Complexity: $(BIGOH n)\n     \n",
"line" : 3888}
,
{
"name" : "length",
"kind" : "function",
"type" : "void(ulong newLength)",
"comment" : "\n       Sets the number of elements in the container to $(D\n       newSize). If $(D newSize) is greater than $(D length), the\n       added elements are added to the container and initialized with\n       $(D ElementType.init).\n\n       Complexity: $(BIGOH abs(n - newLength))\n\n       Postcondition: $(D _length == newLength)\n     \n",
"line" : 3911}
,
{
"name" : "insert",
"kind" : "alias",
"type" : "insertBack",
"comment" : "\n       Inserts $(D stuff) in the container. $(D stuff) can be a value\n       convertible to $(D ElementType) or a range of objects\n       convertible to $(D ElementType).\n\n       The $(D stable) version guarantees that ranges iterating over\n       the container are never invalidated. Client code that counts on\n       non-invalidating insertion should use $(D stableInsert).\n\n       Returns: The number of elements added.\n\n       Complexity: $(BIGOH m * log(n)), where $(D m) is the number of\n       elements in $(D stuff)\n     \n",
"line" : 3945}
,
{
"name" : "stableInsert",
"kind" : "alias",
"type" : "insertBack",
"comment" : "ditto\n",
"line" : 3947}
,
{
"name" : "linearInsert",
"kind" : "alias",
"type" : "insertBack",
"comment" : "\n       Same as $(D insert(stuff)) and $(D stableInsert(stuff))\n       respectively, but relax the complexity constraint to linear.\n     \n",
"line" : 3953}
,
{
"name" : "stableLinearInsert",
"kind" : "alias",
"type" : "insertBack",
"comment" : "ditto\n",
"line" : 3955}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "T()",
"comment" : "\n       Picks one value in the container, removes it from the\n       container, and returns it. The stable version behaves the same,\n       but guarantees that ranges iterating over the container are\n       never invalidated.\n\n       Precondition: $(D !empty)\n\n       Returns: The element removed.\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 3969}
,
{
"name" : "stableRemoveAny",
"kind" : "alias",
"type" : "removeAny",
"comment" : " ditto\n",
"line" : 3976}
,
{
"name" : "insertBack(Stuff) if (is(Stuff : bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\n       Inserts $(D value) to the back of the container. $(D stuff) can\n       be a value convertible to $(D ElementType) or a range of\n       objects convertible to $(D ElementType). The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: The number of elements inserted\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 4001,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "ulong(Stuff stuff)",
"comment" : "\n       Inserts $(D value) to the back of the container. $(D stuff) can\n       be a value convertible to $(D ElementType) or a range of\n       objects convertible to $(D ElementType). The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: The number of elements inserted\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 4001}
]
}
,
{
"name" : "insertBack(Stuff) if (isInputRange!(Stuff) && is(ElementType!(Stuff) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4026,
"members" : [
{
"name" : "insertBack",
"kind" : "function",
"type" : "ulong(Stuff stuff)",
"comment" : " Ditto\n",
"line" : 4026}
]
}
,
{
"name" : "stableInsertBack",
"kind" : "alias",
"type" : "insertBack",
"comment" : " ditto\n",
"line" : 4039}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "void()",
"comment" : "\n       Removes the value at the front or back of the container. The\n       stable version behaves the same, but guarantees that ranges\n       iterating over the container are never invalidated. The\n       optional parameter $(D howMany) instructs removal of that many\n       elements. If $(D howMany > n), all elements are removed and no\n       exception is thrown.\n\n       Precondition: $(D !empty)\n\n       Complexity: $(BIGOH log(n)).\n     \n",
"line" : 4053}
,
{
"name" : "stableRemoveBack",
"kind" : "alias",
"type" : "removeBack",
"comment" : " ditto\n",
"line" : 4069}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "ulong(ulong howMany)",
"comment" : "\n       Removes $(D howMany) values at the front or back of the\n       container. Unlike the unparameterized versions above, these\n       functions do not throw if they could not remove $(D howMany)\n       elements. Instead, if $(D howMany > n), all elements are\n       removed. The returned value is the effective number of elements\n       removed. The stable version behaves the same, but guarantees\n       that ranges iterating over the container are never invalidated.\n\n       Returns: The number of elements removed\n\n       Complexity: $(BIGOH howMany * log(n)).\n     \n ditto\n",
"line" : 4085}
,
{
"name" : "insertBefore(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : "\n       Inserts $(D stuff) before, after, or instead range $(D r),\n       which must be a valid range previously extracted from this\n       container. $(D stuff) can be a value convertible to $(D\n       ElementType) or a range of objects convertible to $(D\n       ElementType). The stable version behaves the same, but\n       guarantees that ranges iterating over the container are never\n       invalidated.\n\n       Returns: The number of values inserted.\n\n       Complexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
"line" : 4124,
"members" : [
{
"name" : "insertBefore",
"kind" : "function",
"type" : "ulong(Range r, Stuff stuff)",
"comment" : "\n       Inserts $(D stuff) before, after, or instead range $(D r),\n       which must be a valid range previously extracted from this\n       container. $(D stuff) can be a value convertible to $(D\n       ElementType) or a range of objects convertible to $(D\n       ElementType). The stable version behaves the same, but\n       guarantees that ranges iterating over the container are never\n       invalidated.\n\n       Returns: The number of values inserted.\n\n       Complexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
"line" : 4124}
]
}
,
{
"name" : "stableInsertBefore",
"kind" : "alias",
"type" : "insertBefore",
"comment" : " ditto\n",
"line" : 4135}
,
{
"name" : "insertAfter(Stuff)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 4151,
"members" : [
{
"name" : "insertAfter",
"kind" : "function",
"type" : "ulong(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 4151}
]
}
,
{
"name" : "stableInsertAfter",
"kind" : "alias",
"type" : "insertAfter",
"comment" : " ditto\n",
"line" : 4162}
,
{
"name" : "replace(Stuff) if (is(Stuff : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 4173,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "size_t(Range r, Stuff stuff)",
"comment" : " ditto\n",
"line" : 4173}
]
}
,
{
"name" : "stableReplace",
"kind" : "alias",
"type" : "replace",
"comment" : " ditto\n",
"line" : 4190}
,
{
"name" : "linearRemove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\n       Removes all elements belonging to $(D r), which must be a range\n       obtained originally from this container. The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: A range spanning the remaining elements in the container that\n       initially were right after $(D r).\n\n       Complexity: $(BIGOH n)\n     \n",
"line" : 4212}
,
{
"name" : "stableLinearRemove",
"kind" : "alias",
"type" : "linearRemove",
"comment" : " ditto\n",
"line" : 4219}
]
}
]
}
,
{
"name" : "RBNode(V)",
"kind" : "struct",
"protection" : "public",
"line" : 4241,
"members" : [
{
"name" : "RBNode",
"kind" : "struct",
"protection" : "public",
"line" : 4241,
"members" : [
{
"name" : "Node",
"kind" : "alias",
"type" : "RBNode*",
"line" : 4245}
,
{
"name" : "_left",
"kind" : "variable",
"type" : "Node",
"line" : 4247}
,
{
"name" : "_right",
"kind" : "variable",
"type" : "Node",
"line" : 4248}
,
{
"name" : "_parent",
"kind" : "variable",
"type" : "Node",
"line" : 4249}
,
{
"name" : "value",
"kind" : "variable",
"type" : "V",
"comment" : "\n The value held by this node\n     \n",
"line" : 4254}
,
{
"name" : "Color",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Enumeration determining what color the node is.  Null nodes are assumed\n to be black.\n     \n",
"line" : 4260,
"base" : "byte",
"members" : [
{
"name" : "Red",
"kind" : "enum member",
"protection" : "public",
"line" : 4262}
,
{
"name" : "Black",
"kind" : "enum member",
"protection" : "public",
"line" : 4263}
]
}
,
{
"name" : "color",
"kind" : "variable",
"type" : "Color",
"comment" : "\n The color of the node.\n     \n",
"line" : 4269}
,
{
"name" : "left",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Get the left child\n     \n",
"line" : 4274}
,
{
"name" : "right",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Get the right child\n     \n",
"line" : 4282}
,
{
"name" : "parent",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Get the parent\n     \n",
"line" : 4290}
,
{
"name" : "left",
"kind" : "function",
"type" : "Node(Node newNode)",
"comment" : "\n Set the left child.  Also updates the new child's parent node.  This\n does not update the previous child.\n\n Returns newNode\n     \n",
"line" : 4301}
,
{
"name" : "right",
"kind" : "function",
"type" : "Node(Node newNode)",
"comment" : "\n Set the right child.  Also updates the new child's parent node.  This\n does not update the previous child.\n\n Returns newNode\n     \n",
"line" : 4315}
,
{
"name" : "rotateR",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Rotate right.  This performs the following operations:\n  - The left child becomes the parent of this node.\n  - This node becomes the new parent's right child.\n  - The old right child of the new parent becomes the left child of this\n    node.\n     \n",
"line" : 4343}
,
{
"name" : "rotateL",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Rotate left.  This performs the following operations:\n  - The right child becomes the parent of this node.\n  - This node becomes the new parent's left child.\n  - The old left child of the new parent becomes the right child of this\n    node.\n     \n",
"line" : 4386}
,
{
"name" : "isLeftNode",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n Returns true if this node is a left child.\n\n Note that this should always return a value because the root has a\n parent which is the marker node.\n     \n",
"line" : 4415}
,
{
"name" : "setColor",
"kind" : "function",
"type" : "void(Node end)",
"comment" : "\n Set the color of the node after it is inserted.  This performs an\n update to the whole tree, possibly rotating nodes to keep the Red-Black\n properties correct.  This is an O(lg(n)) operation, where n is the\n number of nodes in the tree.\n\n end is the marker node, which is the parent of the topmost valid node.\n     \n",
"line" : 4433}
,
{
"name" : "remove",
"kind" : "function",
"type" : "Node(Node end)",
"comment" : "\n Remove this node from the tree.  The 'end' node is used as the marker\n which is root's parent.  Note that this cannot be null!\n\n Returns the next highest valued node in the tree after this one, or end\n if this was the highest-valued node.\n     \n",
"line" : 4534}
,
{
"name" : "leftmost",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Return the leftmost descendant of this node.\n     \n",
"line" : 4719}
,
{
"name" : "rightmost",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Return the rightmost descendant of this node\n     \n",
"line" : 4730}
,
{
"name" : "next",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Returns the next valued node in the tree.\n\n You should never call this on the marker node, as it is assumed that\n there is a valid next node.\n     \n",
"line" : 4744}
,
{
"name" : "prev",
"kind" : "function",
"type" : "Node()",
"comment" : "\n Returns the previous valued node in the tree.\n\n You should never call this on the leftmost node of the tree as it is\n assumed that there is a valid previous node.\n     \n",
"line" : 4763}
,
{
"name" : "dup",
"kind" : "function",
"type" : "Node(scope Node delegate(V v) alloc)",
"line" : 4776}
,
{
"name" : "dup",
"kind" : "function",
"type" : "Node()",
"line" : 4793}
]
}
]
}
,
{
"name" : "RedBlackTree(T,alias less = \"a < b\",bool allowDuplicates = false) if (is(typeof(binaryFun!(less)(T.init,T.init))))",
"kind" : "class",
"protection" : "public",
"comment" : "\n Implementation of a $(LUCKY red-black tree) container.\n\n All inserts, removes, searches, and any function in general has complexity\n of $(BIGOH lg(n)).\n\n To use a different comparison than $(D \"a < b\"), pass a different operator string\n that can be used by $(XREF functional, binaryFun), or pass in a\n function, delegate, functor, or any type where $(D less(a, b)) results in a $(D bool)\n value.\n\n Note that less should produce a strict ordering.  That is, for two unequal\n elements $(D a) and $(D b), $(D less(a, b) == !less(b, a)). $(D less(a, a)) should\n always equal $(D false).\n\n If $(D allowDuplicates) is set to $(D true), then inserting the same element more than\n once continues to add more elements.  If it is $(D false), duplicate elements are\n ignored on insertion.  If duplicates are allowed, then new elements are\n inserted after all existing duplicate elements.\n \n",
"line" : 4828,
"members" : [
{
"name" : "RedBlackTree",
"kind" : "class",
"protection" : "public",
"line" : 4828,
"members" : [
{
"name" : "_less",
"kind" : "alias",
"type" : "binaryFun!(less)",
"line" : 4829}
,
{
"name" : "_add",
"kind" : "function",
"type" : "(Elem n)",
"line" : 4837}
,
{
"name" : "Elem",
"kind" : "alias",
"type" : "T",
"comment" : "\n Element type for the tree\n      \n",
"line" : 4939}
,
{
"name" : "Node",
"kind" : "alias",
"type" : "RBNode!(Elem).Node",
"line" : 4942}
,
{
"name" : "_end",
"kind" : "variable",
"type" : "Node",
"line" : 4944}
,
{
"name" : "_begin",
"kind" : "variable",
"type" : "Node",
"line" : 4945}
,
{
"name" : "_length",
"kind" : "variable",
"type" : "size_t",
"line" : 4946}
,
{
"name" : "_setup",
"kind" : "function",
"type" : "void()",
"line" : 4948}
,
{
"name" : "allocate",
"kind" : "function",
"type" : "Node()",
"line" : 4954}
,
{
"name" : "allocate",
"kind" : "function",
"type" : "Node(Elem v)",
"line" : 4959}
,
{
"name" : "Range",
"kind" : "struct",
"protection" : "public",
"comment" : "\n The range type for $(D RedBlackTree)\n     \n",
"line" : 4970,
"members" : [
{
"name" : "_begin",
"kind" : "variable",
"type" : "Node",
"line" : 4971}
,
{
"name" : "_end",
"kind" : "variable",
"type" : "Node",
"line" : 4972}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Node b, Node e)",
"line" : 4974}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n Returns $(D true) if the range is _empty\n         \n",
"line" : 4983}
,
{
"name" : "front",
"kind" : "function",
"type" : "Elem()",
"comment" : "\n Returns the first element in the range\n         \n",
"line" : 4991}
,
{
"name" : "back",
"kind" : "function",
"type" : "Elem()",
"comment" : "\n Returns the last element in the range\n         \n",
"line" : 4999}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n pop the front element from the range\n\n complexity: amortized $(BIGOH 1)\n         \n",
"line" : 5009}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : "\n pop the back element from the range\n\n complexity: amortized $(BIGOH 1)\n         \n",
"line" : 5019}
,
{
"name" : "save",
"kind" : "function",
"type" : "Range()",
"comment" : "\n Trivial _save implementation, needed for $(D isForwardRange).\n         \n",
"line" : 5027}
]
}
,
{
"name" : "_find",
"kind" : "function",
"type" : "Node(Elem e)",
"line" : 5058}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\n Check if any elements exist in the container.  Returns $(D true) if at least\n one element exists.\n     \n",
"line" : 5099}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : "\n        Returns the number of elements in the container.\n\n        Complexity: $(BIGOH 1).\n    \n",
"line" : 5109}
,
{
"name" : "dup",
"kind" : "function",
"type" : "RedBlackTree()",
"comment" : "\n Duplicate this container.  The resulting container contains a shallow\n copy of the elements.\n\n Complexity: $(BIGOH n)\n     \n",
"line" : 5120}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "Range()",
"comment" : "\n Fetch a range that spans all the elements in the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5142}
,
{
"name" : "front",
"kind" : "function",
"type" : "Elem()",
"comment" : "\n The front element in the container\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5152}
,
{
"name" : "back",
"kind" : "function",
"type" : "Elem()",
"comment" : "\n The last element in the container\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5162}
,
{
"name" : "opBinaryRight(string op) if (op == \"in\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        $(D in) operator. Check to see if the given element exists in the\n        container.\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 5173,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "bool(Elem e)",
"comment" : "\n        $(D in) operator. Check to see if the given element exists in the\n        container.\n\n       Complexity: $(BIGOH log(n))\n     \n",
"line" : 5173}
]
}
,
{
"name" : "clear",
"kind" : "function",
"type" : "void()",
"comment" : "\n Removes all elements from the container.\n\n Complexity: $(BIGOH 1)\n     \n",
"line" : 5190}
,
{
"name" : "stableInsert(Stuff) if (isImplicitlyConvertible!(Stuff,Elem))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Insert a single element in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5211,
"members" : [
{
"name" : "stableInsert",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\n Insert a single element in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5211}
]
}
,
{
"name" : "stableInsert(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),Elem))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Insert a range of elements in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH m * log(n))\n     \n",
"line" : 5230,
"members" : [
{
"name" : "stableInsert",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : "\n Insert a range of elements in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH m * log(n))\n     \n",
"line" : 5230}
]
}
,
{
"name" : "insert",
"kind" : "alias",
"type" : "stableInsert",
"comment" : " ditto\n",
"line" : 5253}
,
{
"name" : "removeAny",
"kind" : "function",
"type" : "Elem()",
"comment" : "\n Remove an element from the container and return its value.\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5291}
,
{
"name" : "removeFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Remove the front element from the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5320}
,
{
"name" : "removeBack",
"kind" : "function",
"type" : "void()",
"comment" : "\n Remove the back element from the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5334}
,
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Range r)",
"comment" : "\n        Removes the given range from the container.\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n     \n",
"line" : 5372}
,
{
"name" : "remove",
"kind" : "function",
"type" : "Range(Take!(Range) r)",
"comment" : "\n        Removes the given $(D Take!Range) from the container\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n     \n",
"line" : 5415}
,
{
"name" : "removeKey(U...) if (allSatisfy!(isImplicitlyConvertibleToElem,U))",
"kind" : "template",
"protection" : "public",
"comment" : "\n       Removes elements from the container that are equal to the given values\n       according to the less comparator. One element is removed for each value\n       given which is in the container. If $(D allowDuplicates) is true,\n       duplicates are removed only if duplicate values are given.\n\n       Returns: The number of elements removed.\n\n       Complexity: $(BIGOH m log(n)) (where m is the number of elements to remove)\n\n        Examples:\n--------------------\nauto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);\nrbt.removeKey(1, 4, 7);\nassert(std.algorithm.equal(rbt[], [0, 1, 1, 5]));\nrbt.removeKey(1, 1, 0);\nassert(std.algorithm.equal(rbt[], [5]));\n--------------------\n      \n",
"line" : 5476,
"members" : [
{
"name" : "removeKey",
"kind" : "function",
"type" : "size_t(U elems)",
"comment" : "\n       Removes elements from the container that are equal to the given values\n       according to the less comparator. One element is removed for each value\n       given which is in the container. If $(D allowDuplicates) is true,\n       duplicates are removed only if duplicate values are given.\n\n       Returns: The number of elements removed.\n\n       Complexity: $(BIGOH m log(n)) (where m is the number of elements to remove)\n\n        Examples:\n--------------------\nauto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);\nrbt.removeKey(1, 4, 7);\nassert(std.algorithm.equal(rbt[], [0, 1, 1, 5]));\nrbt.removeKey(1, 1, 0);\nassert(std.algorithm.equal(rbt[], [5]));\n--------------------\n      \n",
"line" : 5476}
]
}
,
{
"name" : "removeKey(U) if (isImplicitlyConvertible!(U,Elem))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 5488,
"members" : [
{
"name" : "removeKey",
"kind" : "function",
"type" : "size_t(U[] elems)",
"comment" : " Ditto \n",
"line" : 5488}
]
}
,
{
"name" : "removeKey(Stuff) if (isInputRange!(Stuff) && isImplicitlyConvertible!(ElementType!(Stuff),Elem) && !isDynamicArray!(Stuff))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 5510,
"members" : [
{
"name" : "removeKey",
"kind" : "function",
"type" : "size_t(Stuff stuff)",
"comment" : " Ditto \n",
"line" : 5510}
]
}
,
{
"name" : "isImplicitlyConvertibleToElem(U)",
"kind" : "template",
"protection" : "public",
"line" : 5521,
"members" : [
{
"name" : "isImplicitlyConvertibleToElem",
"kind" : "variable",
"line" : 5523}
]
}
,
{
"name" : "_firstGreater",
"kind" : "function",
"type" : "Node(Elem e)",
"line" : 5570}
,
{
"name" : "_firstGreaterEqual",
"kind" : "function",
"type" : "Node(Elem e)",
"line" : 5589}
,
{
"name" : "upperBound",
"kind" : "function",
"type" : "Range(Elem e)",
"comment" : "\n Get a range from the container with all elements that are > e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5614}
,
{
"name" : "lowerBound",
"kind" : "function",
"type" : "Range(Elem e)",
"comment" : "\n Get a range from the container with all elements that are < e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5625}
,
{
"name" : "equalRange",
"kind" : "function",
"type" : "Range(Elem e)",
"comment" : "\n Get a range from the container with all elements that are == e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n     \n",
"line" : 5636}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "()",
"comment" : " \n",
"line" : 5784}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Elem[] elems...)",
"comment" : "\n       Constructor.  Pass in an array of elements, or individual elements to\n       initialize the tree with.\n     \n",
"line" : 5793}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Node end, size_t length)",
"line" : 5799}
]
}
]
}
,
{
"name" : "redBlackTree(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Convenience function for creating a $(D RedBlackTree!E) from a list of\n    values.\n\n        Examples:\n--------------------\nauto rbt1 = redBlackTree(0, 1, 5, 7);\nauto rbt2 = redBlackTree!string(\"hello\", \"world\");\nauto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);\nauto rbt4 = redBlackTree!\"a > b\"(0, 1, 5, 7);\nauto rbt5 = redBlackTree!(\"a > b\", true)(0.1, 1.3, 5.9, 7.2, 5.9);\n--------------------\n  \n",
"line" : 5880,
"members" : [
{
"name" : "redBlackTree",
"kind" : "function",
"type" : "(E[] elems...)",
"comment" : "\n    Convenience function for creating a $(D RedBlackTree!E) from a list of\n    values.\n\n        Examples:\n--------------------\nauto rbt1 = redBlackTree(0, 1, 5, 7);\nauto rbt2 = redBlackTree!string(\"hello\", \"world\");\nauto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);\nauto rbt4 = redBlackTree!\"a > b\"(0, 1, 5, 7);\nauto rbt5 = redBlackTree!(\"a > b\", true)(0.1, 1.3, 5.9, 7.2, 5.9);\n--------------------\n  \n",
"line" : 5880}
]
}
,
{
"name" : "redBlackTree(bool allowDuplicates,E)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 5886,
"members" : [
{
"name" : "redBlackTree",
"kind" : "function",
"type" : "(E[] elems...)",
"comment" : " Ditto \n",
"line" : 5886}
]
}
,
{
"name" : "redBlackTree(alias less,E)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 5892,
"members" : [
{
"name" : "redBlackTree",
"kind" : "function",
"type" : "(E[] elems...)",
"comment" : " Ditto \n",
"line" : 5892}
]
}
,
{
"name" : "redBlackTree(alias less,bool allowDuplicates,E) if (is(typeof(binaryFun!(less)(E.init,E.init))))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 5898,
"members" : [
{
"name" : "redBlackTree",
"kind" : "function",
"type" : "(E[] elems...)",
"comment" : " Ditto \n",
"line" : 5898}
]
}
]
}
,
{
"name" : "std.conv",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/conv.d",
"comment" : "\nA one-stop shop for converting values from one type to another.\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Shin Fujishiro,\n           Adam D. Ruppe,\n           Kenji Hara\n\nSource:    $(PHOBOSSRC std\/_conv.d)\n",
"members" : [
{
"name" : "ConvException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown on conversion errors.\n \n",
"line" : 35,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConvException(string s, string fn = __FILE__, ulong ln = cast(ulong)__LINE__)",
"line" : 37}
]
}
,
{
"name" : "convError_unexpected(S)",
"kind" : "template",
"protection" : "public",
"line" : 43,
"members" : [
{
"name" : "convError_unexpected",
"kind" : "function",
"type" : "string(S source)",
"line" : 43}
]
}
,
{
"name" : "convError(S,T)",
"kind" : "template",
"protection" : "public",
"line" : 47,
"members" : [
{
"name" : "convError",
"kind" : "function",
"type" : "void(S source, string fn = __FILE__, size_t ln = __LINE__)",
"line" : 47}
]
}
,
{
"name" : "convError(S,T)",
"kind" : "template",
"protection" : "public",
"line" : 55,
"members" : [
{
"name" : "convError",
"kind" : "function",
"type" : "void(S source, int radix, string fn = __FILE__, size_t ln = __LINE__)",
"line" : 55}
]
}
,
{
"name" : "parseError",
"kind" : "function",
"protection" : "private",
"type" : "void(lazy string msg, string fn = __FILE__, ulong ln = cast(ulong)__LINE__)",
"line" : 64}
,
{
"name" : "parseCheck(alias source)",
"kind" : "template",
"protection" : "public",
"line" : 69,
"members" : [
{
"name" : "parseCheck",
"kind" : "function",
"type" : "void(dchar c, string fn = __FILE__, size_t ln = __LINE__)",
"line" : 69}
]
}
,
{
"name" : "isImaginary(T)",
"kind" : "template",
"protection" : "public",
"line" : 78,
"members" : [
{
"name" : "isImaginary",
"kind" : "variable",
"type" : "bool",
"line" : 80}
]
}
,
{
"name" : "isComplex(T)",
"kind" : "template",
"protection" : "public",
"line" : 83,
"members" : [
{
"name" : "isComplex",
"kind" : "variable",
"type" : "bool",
"line" : 85}
]
}
,
{
"name" : "isNarrowInteger(T)",
"kind" : "template",
"protection" : "public",
"line" : 88,
"members" : [
{
"name" : "isNarrowInteger",
"kind" : "variable",
"type" : "bool",
"line" : 90}
]
}
,
{
"name" : "toStr(T,S) if (isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"line" : 94,
"members" : [
{
"name" : "toStr",
"kind" : "function",
"type" : "T(S src)",
"line" : 94}
]
}
,
{
"name" : "isEnumStrToStr(S,T)",
"kind" : "template",
"protection" : "public",
"line" : 103,
"members" : [
{
"name" : "isEnumStrToStr",
"kind" : "variable",
"line" : 106}
]
}
,
{
"name" : "isNullToStr(S,T)",
"kind" : "template",
"protection" : "public",
"line" : 108,
"members" : [
{
"name" : "isNullToStr",
"kind" : "variable",
"line" : 111}
]
}
,
{
"name" : "isRawStaticArray(T,A...)",
"kind" : "template",
"protection" : "public",
"line" : 114,
"members" : [
{
"name" : "isRawStaticArray",
"kind" : "variable",
"line" : 122}
]
}
,
{
"name" : "ConvOverflowException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown on conversion overflow errors.\n \n",
"line" : 129,
"base" : "ConvException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConvOverflowException(string s, string fn = __FILE__, ulong ln = cast(ulong)__LINE__)",
"line" : 131}
]
}
,
{
"name" : "to(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Entry point that dispatches to the appropriate conversion\n   primitive. Client code normally calls $(D _to!TargetType(value))\n   (and not some variant of $(D toImpl)).\n \n",
"line" : 263,
"members" : [
{
"name" : "to(A...) if (!isRawStaticArray!(A))",
"kind" : "template",
"protection" : "public",
"line" : 265,
"members" : [
{
"name" : "to",
"kind" : "function",
"type" : "T(A args)",
"line" : 265}
]
}
,
{
"name" : "to(S) if (isRawStaticArray!(S))",
"kind" : "template",
"protection" : "public",
"line" : 272,
"members" : [
{
"name" : "to",
"kind" : "function",
"type" : "T(ref S arg)",
"line" : 272}
]
}
]
}
,
{
"name" : "toImpl(T,S) if (isImplicitlyConvertible!(S,T) && !isEnumStrToStr!(S,T) && !isNullToStr!(S,T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the source type is implicitly convertible to the target type, $(D\nto) simply performs the implicit conversion.\n \n",
"line" : 299,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nIf the source type is implicitly convertible to the target type, $(D\nto) simply performs the implicit conversion.\n \n",
"line" : 299}
]
}
,
{
"name" : "isSignedInt(T)",
"kind" : "template",
"protection" : "public",
"line" : 320,
"members" : [
{
"name" : "isSignedInt",
"kind" : "variable",
"line" : 322}
]
}
,
{
"name" : "toImpl(T,S) if (isRawStaticArray!(S))",
"kind" : "template",
"protection" : "public",
"line" : 405,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(ref S s)",
"line" : 405}
]
}
,
{
"name" : "toImpl(T,S) if (is(S : Object) && !is(T : Object) && !isSomeString!(T) && hasMember!(S,\"to\") && is(typeof(S.init.to!(T)()) : T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(RED Deprecated. It will be removed in September 2012. Please define $(D opCast)\n      for user-defined types instead of a $(D to) function.\n      $(LREF to) will now use $(D opCast).)\n\nObject-_to-non-object conversions look for a method \"to\" of the source\nobject.\n\nExample:\n----\nclass Date\n{\n    T to(T)() if(is(T == long))\n    {\n        return timestamp;\n    }\n    ...\n}\n\nunittest\n{\n    debug(conv) scope(success) writeln(\"unittest @\", __FILE__, \":\", __LINE__, \" succeeded.\");\n    auto d = new Date;\n    auto ts = to!long(d); \/\/ same as d.to!long()\n}\n----\n \n",
"line" : 445,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"line" : 445}
]
}
,
{
"name" : "toImpl(T,S) if (is(typeof(S.init.opCast!(T)()) : T) && !isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nWhen source type supports member template function opCast, is is used.\n",
"line" : 466,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nWhen source type supports member template function opCast, is is used.\n",
"line" : 466}
]
}
,
{
"name" : "toImpl(T,S) if (!isImplicitlyConvertible!(S,T) && is(T == struct) && is(typeof(T(value))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nWhen target type supports 'converting construction', it is used.\n$(UL $(LI If target type is struct, $(D T(value)) is used.)\n     $(LI If target type is class, $(D new T(value)) is used.))\n",
"line" : 497,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nWhen target type supports 'converting construction', it is used.\n$(UL $(LI If target type is struct, $(D T(value)) is used.)\n     $(LI If target type is class, $(D new T(value)) is used.))\n",
"line" : 497}
]
}
,
{
"name" : "toImpl(T,S) if (!isImplicitlyConvertible!(S,T) && is(T == class) && is(typeof(new T(value))))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 547,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : " ditto\n",
"line" : 547}
]
}
,
{
"name" : "toImpl(T,S) if (!isImplicitlyConvertible!(S,T) && (is(S == class) || is(S == interface)) && !is(typeof(value.opCast!(T)()) : T) && (is(T == class) || is(T == interface)) && !is(typeof(new T(value))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nObject-to-object conversions by dynamic casting throw exception when the source is\nnon-null and the target is null.\n \n",
"line" : 619,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nObject-to-object conversions by dynamic casting throw exception when the source is\nnon-null and the target is null.\n \n",
"line" : 619}
]
}
,
{
"name" : "toImpl(T,S) if (!(isImplicitlyConvertible!(S,T) && !isEnumStrToStr!(S,T) && !isNullToStr!(S,T)) && isSomeString!(T) && !isAggregateType!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nStringnize conversion from all types is supported.\n$(UL\n  $(LI String _to string conversion works for any two string types having\n       ($(D char), $(D wchar), $(D dchar)) character widths and any\n       combination of qualifiers (mutable, $(D const), or $(D immutable)).)\n  $(LI Converts array (other than strings) to string.\n       Each element is converted by calling $(D to!T).)\n  $(LI Associative array to string conversion.\n       Each element is printed by calling $(D to!T).)\n  $(LI Object to string conversion calls $(D toString) against the object or\n       returns $(D \"null\") if the object is null.)\n  $(LI Struct to string conversion calls $(D toString) against the struct if\n       it is defined.)\n  $(LI For structs that do not define $(D toString), the conversion to string\n       produces the list of fields.)\n  $(LI Enumerated types are converted to strings as their symbolic names.)\n  $(LI Boolean values are printed as $(D \"true\") or $(D \"false\").)\n  $(LI $(D char), $(D wchar), $(D dchar) to a string type.)\n  $(LI Unsigned or signed integers to strings.\n       $(DL $(DT [special case])\n            $(DD Convert integral value to string in $(D_PARAM radix) radix.\n            radix must be a value from 2 to 36.\n            value is treated as a signed value only if radix is 10.\n            The characters A through Z are used to represent values 10 through 36.)))\n  $(LI All floating point types to all string types.)\n  $(LI Pointer to string conversions prints the pointer as a $(D size_t) value.\n       If pointer is $(D char*), treat it as C-style strings.))\n",
"line" : 780,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nStringnize conversion from all types is supported.\n$(UL\n  $(LI String _to string conversion works for any two string types having\n       ($(D char), $(D wchar), $(D dchar)) character widths and any\n       combination of qualifiers (mutable, $(D const), or $(D immutable)).)\n  $(LI Converts array (other than strings) to string.\n       Each element is converted by calling $(D to!T).)\n  $(LI Associative array to string conversion.\n       Each element is printed by calling $(D to!T).)\n  $(LI Object to string conversion calls $(D toString) against the object or\n       returns $(D \"null\") if the object is null.)\n  $(LI Struct to string conversion calls $(D toString) against the struct if\n       it is defined.)\n  $(LI For structs that do not define $(D toString), the conversion to string\n       produces the list of fields.)\n  $(LI Enumerated types are converted to strings as their symbolic names.)\n  $(LI Boolean values are printed as $(D \"true\") or $(D \"false\").)\n  $(LI $(D char), $(D wchar), $(D dchar) to a string type.)\n  $(LI Unsigned or signed integers to strings.\n       $(DL $(DT [special case])\n            $(DD Convert integral value to string in $(D_PARAM radix) radix.\n            radix must be a value from 2 to 36.\n            value is treated as a signed value only if radix is 10.\n            The characters A through Z are used to represent values 10 through 36.)))\n  $(LI All floating point types to all string types.)\n  $(LI Pointer to string conversions prints the pointer as a $(D size_t) value.\n       If pointer is $(D char*), treat it as C-style strings.))\n",
"line" : 780}
]
}
,
{
"name" : "toImpl(T,S) if (isIntegral!(S) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1065,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value, uint radix)",
"comment" : " ditto\n",
"line" : 1065}
]
}
,
{
"name" : "toImpl(T,S) if (!isSomeChar!(ElementType!(S)) && (isInputRange!(S) || isInputRange!(Unqual!(S))) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in January 2013.\n          Please use $(XREF format, formattedWrite) instead.)\n\n    Conversions to string with optional configures.\n",
"line" : 1129,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S s, in T leftBracket, in T separator = \", \", in T rightBracket = \"]\")",
"line" : 1129}
]
}
,
{
"name" : "toImpl(T,S) if ((is(S == void[]) || is(S == const(void)[]) || is(S == immutable(void)[])) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1166,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(ref S s, in T leftBracket, in T separator = \" \", in T rightBracket = \"]\")",
"line" : 1166}
]
}
,
{
"name" : "toImpl(T,S) if (isAssociativeArray!(S) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1177,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S s, in T leftBracket, in T keyval = \":\", in T separator = \", \", in T rightBracket = \"]\")",
"line" : 1177}
]
}
,
{
"name" : "toImpl(T,S) if (is(S : Object) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1203,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S s, in T nullstr)",
"line" : 1203}
]
}
,
{
"name" : "toImpl(T,S) if (is(S == struct) && !is(typeof(&S.init.toString)) && !isInputRange!(S) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1216,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S s, in T left, in T separator = \", \", in T right = \")\")",
"line" : 1216}
]
}
,
{
"name" : "toImpl(T,S) if (is(S == typedef) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"line" : 1250,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S s, in T left = to!(T)(S.stringof ~ \"(\"), in T right = \")\")",
"line" : 1250}
]
}
,
{
"name" : "toImpl(T,S) if (!isImplicitlyConvertible!(S,T) && (isNumeric!(S) || isSomeChar!(S)) && (isNumeric!(T) || isSomeChar!(T)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nNarrowing numeric-numeric conversions throw when the value does not\nfit in the narrower type.\n \n",
"line" : 1266,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nNarrowing numeric-numeric conversions throw when the value does not\nfit in the narrower type.\n \n",
"line" : 1266}
]
}
,
{
"name" : "toImpl(T,S) if (!isImplicitlyConvertible!(S,T) && !isSomeString!(S) && isDynamicArray!(S) && !isSomeString!(T) && isArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nArray-to-array conversion (except when target is a string type)\nconverts each element in turn by using $(D to).\n \n",
"line" : 1324,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nArray-to-array conversion (except when target is a string type)\nconverts each element in turn by using $(D to).\n \n",
"line" : 1324}
]
}
,
{
"name" : "toImpl(T,S) if (isAssociativeArray!(S) && isAssociativeArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAssociative array to associative array conversion converts each key\nand each value in turn.\n \n",
"line" : 1374,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nAssociative array to associative array conversion converts each key\nand each value in turn.\n \n",
"line" : 1374}
]
}
,
{
"name" : "testIntegralToFloating(Integral,Floating)",
"kind" : "template",
"protection" : "public",
"line" : 1398,
"members" : [
{
"name" : "testIntegralToFloating",
"kind" : "function",
"type" : "void()",
"line" : 1398}
]
}
,
{
"name" : "testFloatingToIntegral(Floating,Integral)",
"kind" : "template",
"protection" : "public",
"line" : 1406,
"members" : [
{
"name" : "testFloatingToIntegral",
"kind" : "function",
"type" : "void()",
"line" : 1406}
]
}
,
{
"name" : "toImpl(T,S) if (isDynamicArray!(S) && isSomeString!(S) && !isSomeString!(T) && is(typeof(parse!(T)(value))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nString to non-string conversion runs parsing.\n$(UL\n  $(LI When the source is a wide string, it is first converted to a narrow\n       string and then parsed.)\n  $(LI When the source is a narrow string, normal text parsing occurs.))\n",
"line" : 1581,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value)",
"comment" : "\nString to non-string conversion runs parsing.\n$(UL\n  $(LI When the source is a wide string, it is first converted to a narrow\n       string and then parsed.)\n  $(LI When the source is a narrow string, normal text parsing occurs.))\n",
"line" : 1581}
]
}
,
{
"name" : "toImpl(T,S) if (isDynamicArray!(S) && isSomeString!(S) && !isSomeString!(T) && is(typeof(parse!(T)(value,radix))))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1596,
"members" : [
{
"name" : "toImpl",
"kind" : "function",
"type" : "T(S value, uint radix)",
"comment" : " ditto\n",
"line" : 1596}
]
}
,
{
"name" : "roundTo(Target)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Rounded conversion from floating point to integral.\n\nExample:\n---------------\nassert(roundTo!int(3.14) == 3);\nassert(roundTo!int(3.49) == 3);\nassert(roundTo!int(3.5) == 4);\nassert(roundTo!int(3.999) == 4);\nassert(roundTo!int(-3.14) == -3);\nassert(roundTo!int(-3.49) == -3);\nassert(roundTo!int(-3.5) == -4);\nassert(roundTo!int(-3.999) == -4);\n---------------\nRounded conversions do not work with non-integral target types.\n \n",
"line" : 1642,
"members" : [
{
"name" : "roundTo(Source)",
"kind" : "template",
"protection" : "public",
"line" : 1644,
"members" : [
{
"name" : "roundTo",
"kind" : "function",
"type" : "Target(Source value)",
"line" : 1644}
]
}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeChar!(ElementType!(Source)) && isIntegral!(Target))",
"kind" : "template",
"protection" : "public",
"comment" : "\n The $(D_PARAM parse) family of functions works quite like the\n $(D_PARAM to) family, except that (1) it only works with character ranges\n as input, (2) takes the input by reference and advances it to\n the position following the conversion, and (3) does not throw if it\n could not convert the entire input. It still throws if an overflow\n occurred during conversion or if no character of the input\n was meaningfully converted.\n\n Example:\n--------------\nstring test = \"123 \\t  76.14\";\nauto a = parse!uint(test);\nassert(a == 123);\nassert(test == \" \\t  76.14\"); \/\/ parse bumps string\nmunch(test, \" \\t\\n\\r\"); \/\/ skip ws\nassert(test == \"76.14\");\nauto b = parse!double(test);\nassert(b == 76.14);\nassert(test == \"\");\n--------------\n \n",
"line" : 1698,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s)",
"comment" : "\n The $(D_PARAM parse) family of functions works quite like the\n $(D_PARAM to) family, except that (1) it only works with character ranges\n as input, (2) takes the input by reference and advances it to\n the position following the conversion, and (3) does not throw if it\n could not convert the entire input. It still throws if an overflow\n occurred during conversion or if no character of the input\n was meaningfully converted.\n\n Example:\n--------------\nstring test = \"123 \\t  76.14\";\nauto a = parse!uint(test);\nassert(a == 123);\nassert(test == \" \\t  76.14\"); \/\/ parse bumps string\nmunch(test, \" \\t\\n\\r\"); \/\/ skip ws\nassert(test == \"76.14\");\nauto b = parse!double(test);\nassert(b == 76.14);\nassert(test == \"\");\n--------------\n \n",
"line" : 1698}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeChar!(ElementType!(Source)) && isIntegral!(Target))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1959,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s, uint radix)",
"comment" : " ditto\n",
"line" : 1959}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && is(Target == enum))",
"kind" : "template",
"protection" : "public",
"line" : 2055,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 2055}
]
}
,
{
"name" : "parse(Target,Source) if (isInputRange!(Source) && isSomeChar!(ElementType!(Source)) && isFloatingPoint!(Target))",
"kind" : "template",
"protection" : "public",
"line" : 2114,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source p)",
"line" : 2114}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && staticIndexOf!(Unqual!(Target),dchar,Unqual!(ElementEncodingType!(Source))) >= 0)",
"kind" : "template",
"protection" : "public",
"comment" : "\nParsing one character off a string returns the character and bumps the\nstring up one position.\n \n",
"line" : 2594,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s)",
"comment" : "\nParsing one character off a string returns the character and bumps the\nstring up one position.\n \n",
"line" : 2594}
]
}
,
{
"name" : "parse(Target,Source) if (!isSomeString!(Source) && isInputRange!(Source) && isSomeChar!(ElementType!(Source)) && isSomeChar!(Target) && Target.sizeof >= ElementType!(Source).sizeof)",
"kind" : "template",
"protection" : "public",
"line" : 2630,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 2630}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && is(Unqual!(Target) == bool))",
"kind" : "template",
"protection" : "public",
"line" : 2640,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 2640}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && is(Unqual!(Target) == typeof(null)))",
"kind" : "template",
"protection" : "public",
"line" : 2688,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 2688}
]
}
,
{
"name" : "skipWS(R)",
"kind" : "template",
"protection" : "public",
"line" : 2720,
"members" : [
{
"name" : "skipWS",
"kind" : "function",
"type" : "void(ref R r)",
"line" : 2720}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && isDynamicArray!(Target))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Parses an array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), and element seprator (by\n default $(D ',')).\n \n",
"line" : 2730,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
"comment" : "\n Parses an array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), and element seprator (by\n default $(D ',')).\n \n",
"line" : 2730}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && isStaticArray!(Target))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2792,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
"comment" : " ditto\n",
"line" : 2792}
]
}
,
{
"name" : "parse(Target,Source) if (isSomeString!(Source) && isAssociativeArray!(Target))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Parses an associative array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), key-value separator (default $(D\n ':')), and element seprator (by default $(D ',')).\n \n",
"line" : 2858,
"members" : [
{
"name" : "parse",
"kind" : "function",
"type" : "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar keyval = ':', dchar comma = ',')",
"comment" : "\n Parses an associative array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), key-value separator (default $(D\n ':')), and element seprator (by default $(D ',')).\n \n",
"line" : 2858}
]
}
,
{
"name" : "parseEscape(Source) if (isInputRange!(Source) && isSomeChar!(ElementType!(Source)))",
"kind" : "template",
"protection" : "public",
"line" : 2905,
"members" : [
{
"name" : "parseEscape",
"kind" : "function",
"type" : "dchar(ref Source s)",
"line" : 2905}
]
}
,
{
"name" : "parseElement(Target,Source) if (isInputRange!(Source) && isSomeChar!(ElementType!(Source)) && isSomeString!(Target))",
"kind" : "template",
"protection" : "public",
"line" : 2963,
"members" : [
{
"name" : "parseElement",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 2963}
]
}
,
{
"name" : "parseElement(Target,Source) if (isInputRange!(Source) && isSomeChar!(ElementType!(Source)) && isSomeChar!(Target))",
"kind" : "template",
"protection" : "public",
"line" : 3001,
"members" : [
{
"name" : "parseElement",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 3001}
]
}
,
{
"name" : "parseElement(Target,Source) if (isInputRange!(Source) && isSomeChar!(ElementType!(Source)) && !isSomeString!(Target) && !isSomeChar!(Target))",
"kind" : "template",
"protection" : "public",
"line" : 3021,
"members" : [
{
"name" : "parseElement",
"kind" : "function",
"type" : "Target(ref Source s)",
"line" : 3021}
]
}
,
{
"name" : "text(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Convenience functions for converting any number and types of\n   arguments into _text (the three character widths).\n\n   Example:\n----\nassert(text(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\");\nassert(wtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"w);\nassert(dtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"d);\n----\n",
"line" : 3040,
"members" : [
{
"name" : "text",
"kind" : "function",
"type" : "string(T args)",
"comment" : "\n   Convenience functions for converting any number and types of\n   arguments into _text (the three character widths).\n\n   Example:\n----\nassert(text(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\");\nassert(wtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"w);\nassert(dtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"d);\n----\n",
"line" : 3040}
]
}
,
{
"name" : "wtext(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 3045,
"members" : [
{
"name" : "wtext",
"kind" : "function",
"type" : "wstring(T args)",
"comment" : "ditto\n",
"line" : 3045}
]
}
,
{
"name" : "dtext(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 3050,
"members" : [
{
"name" : "dtext",
"kind" : "function",
"type" : "dstring(T args)",
"comment" : "ditto\n",
"line" : 3050}
]
}
,
{
"name" : "textImpl(S,U...)",
"kind" : "template",
"protection" : "public",
"line" : 3055,
"members" : [
{
"name" : "textImpl",
"kind" : "function",
"type" : "S(U args)",
"line" : 3055}
]
}
,
{
"name" : "octal(string num) if (octalFitsInInt!(num) && !literalIsLong!(num) && !literalIsUnsigned!(num))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe $(D octal) facility is intended as an experimental facility to\nreplace _octal literals starting with $(D '0'), which many find\nconfusing. Using $(D octal!177) or $(D octal!\"177\") instead of $(D\n0177) as an _octal literal makes code clearer and the intent more\nvisible. If use of this facility becomes preponderent, a future\nversion of the language may deem old-style _octal literals deprecated.\n\nThe rules for strings are the usual for literals: If it can fit in an\n$(D int), it is an $(D int). Otherwise, it is a $(D long). But, if the\nuser specifically asks for a $(D long) with the $(D L) suffix, always\ngive the $(D long). Give an unsigned iff it is asked for with the $(D\nU) or $(D u) suffix. _Octals created from integers preserve the type\nof the passed-in integral.\n\nExample:\n----\n\/\/ same as 0177\nauto x = octal!177;\n\/\/ octal is a compile-time device\nenum y = octal!160;\n\/\/ Create an unsigned octal\nauto z = octal!\"1_000_000u\";\n----\n \n",
"line" : 3098,
"members" : [
{
"name" : "octal",
"kind" : "function",
"type" : "int()",
"line" : 3098}
]
}
,
{
"name" : "octal(string num) if ((!octalFitsInInt!(num) || literalIsLong!(num)) && !literalIsUnsigned!(num))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3105,
"members" : [
{
"name" : "octal",
"kind" : "function",
"type" : "long()",
"line" : 3105}
]
}
,
{
"name" : "octal(string num) if (octalFitsInInt!(num) && !literalIsLong!(num) && literalIsUnsigned!(num))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3112,
"members" : [
{
"name" : "octal",
"kind" : "function",
"type" : "uint()",
"line" : 3112}
]
}
,
{
"name" : "octal(string num) if ((!octalFitsInInt!(num) || literalIsLong!(num)) && literalIsUnsigned!(num))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3119,
"members" : [
{
"name" : "octal",
"kind" : "function",
"type" : "ulong()",
"line" : 3119}
]
}
,
{
"name" : "octal(alias s) if (isIntegral!(typeof(s)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3126,
"members" : [
{
"name" : "octal",
"kind" : "variable",
"line" : 3129}
]
}
,
{
"name" : "octal(T,string num) if (isOctalLiteral!(num))",
"kind" : "template",
"protection" : "public",
"line" : 3142,
"members" : [
{
"name" : "octal",
"kind" : "function",
"type" : "T()",
"line" : 3142}
]
}
,
{
"name" : "octalFitsInInt(string octalNum)",
"kind" : "template",
"protection" : "public",
"line" : 3167,
"members" : [
{
"name" : "octalFitsInInt",
"kind" : "variable",
"type" : "bool",
"line" : 3172}
]
}
,
{
"name" : "strippedOctalLiteral",
"kind" : "function",
"protection" : "public",
"type" : "string(string original)",
"line" : 3177}
,
{
"name" : "literalIsLong(string num)",
"kind" : "template",
"protection" : "public",
"line" : 3186,
"members" : [
]
}
,
{
"name" : "literalIsUnsigned(string num)",
"kind" : "template",
"protection" : "public",
"line" : 3195,
"members" : [
]
}
,
{
"name" : "isOctalLiteralString",
"kind" : "function",
"protection" : "public",
"type" : "bool(string num)",
"line" : 3212}
,
{
"name" : "isOctalLiteral(string num)",
"kind" : "template",
"protection" : "public",
"line" : 3254,
"members" : [
{
"name" : "isOctalLiteral",
"kind" : "variable",
"type" : "bool",
"line" : 3256}
]
}
,
{
"name" : "emplace(T) if (!is(T == class))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas $(D T)), constructs an object of non-$(D class) type $(D T) at that\naddress.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
"line" : 3328,
"members" : [
{
"name" : "emplace",
"kind" : "function",
"type" : "T*(T* chunk)",
"comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas $(D T)), constructs an object of non-$(D class) type $(D T) at that\naddress.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
"line" : 3328}
]
}
,
{
"name" : "emplace(T) if (is(T == class))",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 3337,
"members" : [
{
"name" : "emplace",
"kind" : "function",
"type" : "T*(T* chunk)",
"comment" : "ditto\n",
"line" : 3337}
]
}
,
{
"name" : "emplace(T,Args...) if (!is(T == struct) && Args.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas a non-class type $(D T)), constructs an object of type $(D T) at\nthat address from arguments $(D args).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
"line" : 3356,
"members" : [
{
"name" : "emplace",
"kind" : "function",
"type" : "T*(T* chunk, Args args)",
"comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas a non-class type $(D T)), constructs an object of type $(D T) at\nthat address from arguments $(D args).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
"line" : 3356}
]
}
,
{
"name" : "emplace(T,Args...) if (is(T == struct))",
"kind" : "template",
"protection" : "public",
"line" : 3364,
"members" : [
{
"name" : "emplace",
"kind" : "function",
"type" : "T*(T* chunk, Args args)",
"line" : 3364}
]
}
,
{
"name" : "emplace(T,Args...) if (is(T == class))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGiven a raw memory area $(D chunk), constructs an object of $(D class)\ntype $(D T) at that address. The constructor is passed the arguments\n$(D Args). The $(D chunk) must be as least as large as $(D T) needs\nand should have an alignment multiple of $(D T)'s alignment. (The size\nof a $(D class) instance is obtained by using $(D\n__traits(classInstanceSize, T))).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
"line" : 3411,
"members" : [
{
"name" : "emplace",
"kind" : "function",
"type" : "T(void[] chunk, Args args)",
"comment" : "\nGiven a raw memory area $(D chunk), constructs an object of $(D class)\ntype $(D T) at that address. The constructor is passed the arguments\n$(D Args). The $(D chunk) must be as least as large as $(D T) needs\nand should have an alignment multiple of $(D T)'s alignment. (The size\nof a $(D class) instance is obtained by using $(D\n__traits(classInstanceSize, T))).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
"line" : 3411}
]
}
,
{
"name" : "emplace(T,Args...) if (!is(T == class))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGiven a raw memory area $(D chunk), constructs an object of non-$(D\nclass) type $(D T) at that address. The constructor is passed the\narguments $(D args), if any. The $(D chunk) must be as least as large\nas $(D T) needs and should have an alignment multiple of $(D T)'s\nalignment.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
"line" : 3451,
"members" : [
{
"name" : "emplace",
"kind" : "function",
"type" : "T*(void[] chunk, Args args)",
"comment" : "\nGiven a raw memory area $(D chunk), constructs an object of non-$(D\nclass) type $(D T) at that address. The constructor is passed the\narguments $(D args), if any. The $(D chunk) must be as least as large\nas $(D T) needs and should have an alignment multiple of $(D T)'s\nalignment.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
"line" : 3451}
]
}
,
{
"name" : "toTextRange(T,W) if (isIntegral!(T) && isOutputRange!(W,char))",
"kind" : "template",
"protection" : "public",
"line" : 3569,
"members" : [
{
"name" : "toTextRange",
"kind" : "function",
"type" : "void(T value, W writer)",
"line" : 3569}
]
}
,
{
"name" : "hardDeprec(string vers,string date,string oldFunc,string newFunc)",
"kind" : "template",
"protection" : "public",
"line" : 3604,
"members" : [
{
"name" : "hardDeprec",
"kind" : "variable",
"line" : 3608}
]
}
]
}
,
{
"name" : "std.cpuid",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/cpuid.d",
"comment" : "\n $(RED Deprecated. It will be removed in January 2013. Please use core.cpuid instead.)\n\n Identify the characteristics of the host CPU.\n\n Implemented according to:\n\n- AP-485 Intel(C) Processor Identification and the CPUID Instruction\n        $(LINK http:\/\/www.intel.com\/design\/xeon\/applnots\/241618.htm)\n\n- Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Volume 2A: Instruction Set Reference, A-M\n        $(LINK http:\/\/developer.intel.com\/design\/pentium4\/manuals\/index_new.htm)\n\n- AMD CPUID Specification Publication # 25481\n        $(LINK http:\/\/www.amd.com\/us-en\/assets\/content_type\/white_papers_and_tech_docs\/25481.pdf)\n\nExample:\n---\nimport std.cpuid;\nimport std.stdio;\n\nvoid main()\n{\n    writefln(std.cpuid.toString());\n}\n---\n\nBUGS: Only works on x86 CPUs\n\nMacros:\n    WIKI = Phobos\/StdCpuid\n\nCopyright: Copyright Tomas Lindquist Olsen 2007 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   Tomas Lindquist Olsen &lt;tomas@famolsen.dk&gt;\nSource:    $(PHOBOSSRC std\/_cpuid.d)\n",
"members" : [
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 175}
,
{
"name" : "vendor",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 177}
,
{
"name" : "processor",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 178}
,
{
"name" : "mmx",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 182}
,
{
"name" : "fxsr",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 183}
,
{
"name" : "sse",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 184}
,
{
"name" : "sse2",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 185}
,
{
"name" : "sse3",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 186}
,
{
"name" : "ssse3",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 187}
,
{
"name" : "amd3dnow",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 189}
,
{
"name" : "amd3dnowExt",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 190}
,
{
"name" : "amdMmx",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 191}
,
{
"name" : "ia64",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 193}
,
{
"name" : "amd64",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 194}
,
{
"name" : "hyperThreading",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 196}
,
{
"name" : "threadsPerCPU",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 197}
,
{
"name" : "coresPerCPU",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 198}
,
{
"name" : "intel",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 200}
,
{
"name" : "amd",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 201}
,
{
"name" : "stepping",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 203}
,
{
"name" : "model",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 204}
,
{
"name" : "family",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 205}
]
}
,
{
"name" : "std.cstream",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/cstream.d",
"comment" : "\n $(RED Warning: This module is considered out-dated and not up to Phobos'\n       current standards. It will remain until we have a suitable replacement,\n       but be aware that it will not remain long term.)\n\n The std.cstream module bridges std.c.stdio (or std.stdio) and std.stream.\n Both std.c.stdio and std.stream are publicly imported by std.cstream.\n\n Macros:\n      WIKI=Phobos\/StdCstream\n\n Copyright: Copyright Ben Hinkle 2007 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   Ben Hinkle\n Source:    $(PHOBOSSRC std\/_cstream.d)\n \n",
"members" : [
{
"name" : "CFile",
"kind" : "class",
"protection" : "public",
"comment" : "\n A Stream wrapper for a C file of type FILE*.\n \n",
"line" : 33,
"base" : "Stream",
"members" : [
{
"name" : "cfile",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 34}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CFile(shared(_iobuf)* cfile, FileMode mode, bool seekable = false)",
"comment" : "\n Create the stream wrapper for the given C file.\n Params:\n   mode = a bitwise combination of $(B FileMode.In) for a readable file\n          and $(B FileMode.Out) for a writeable file.\n   seekable = indicates if the stream should be _seekable.\n   \n",
"line" : 43}
,
{
"name" : "file",
"kind" : "function",
"protection" : "public",
"type" : "@property shared(_iobuf)*()",
"comment" : "\n Property to get or set the underlying file for this stream.\n Setting the file marks the stream as open.\n   \n",
"line" : 60}
,
{
"name" : "file",
"kind" : "function",
"protection" : "public",
"type" : "@property void(shared(_iobuf)* cfile)",
"comment" : "\n Ditto\n   \n",
"line" : 65}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Overrides of the $(B Stream) methods to call the underlying $(B FILE*)\n C functions.\n   \n",
"line" : 74}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Ditto\n   \n",
"line" : 79}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"comment" : "\n Ditto\n   \n",
"line" : 88}
,
{
"name" : "getc",
"kind" : "function",
"protection" : "public",
"type" : "char()",
"comment" : "\n Ditto\n   \n",
"line" : 95}
,
{
"name" : "ungetc",
"kind" : "function",
"protection" : "public",
"type" : "char(char c)",
"comment" : "\n Ditto\n   \n",
"line" : 102}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* buffer, ulong size)",
"comment" : "\n Ditto\n   \n",
"line" : 109}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) buffer, ulong size)",
"comment" : "\n Ditto\n   \n",
"line" : 118}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos rel)",
"comment" : "\n Ditto\n   \n",
"line" : 125}
,
{
"name" : "writeLine",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"comment" : "\n Ditto\n   \n",
"line" : 135}
,
{
"name" : "writeLineW",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"comment" : "\n Ditto\n   \n",
"line" : 143}
]
}
,
{
"name" : "din",
"kind" : "variable",
"protection" : "public",
"type" : "std.cstream.CFile",
"comment" : "\n CFile wrapper of std.c.stdio.stdin (not seekable).\n \n",
"line" : 225}
,
{
"name" : "dout",
"kind" : "variable",
"protection" : "public",
"type" : "std.cstream.CFile",
"comment" : "\n CFile wrapper of std.c.stdio.stdout (not seekable).\n \n",
"line" : 230}
,
{
"name" : "derr",
"kind" : "variable",
"protection" : "public",
"type" : "std.cstream.CFile",
"comment" : "\n CFile wrapper of std.c.stdio.stderr (not seekable).\n \n",
"line" : 235}
]
}
,
{
"name" : "std.csv",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/csv.d",
"comment" : "\n Implements functionality to read Comma Separated Values and its variants\n from a input range of $(D dchar).\n\n Comma Separated Values provide a simple means to transfer and store\n tabular data. It has been common for programs to use their own\n variant of the CSV format. This parser will loosely follow the\n $(WEB tools.ietf.org\/html\/rfc4180, RFC-4180). CSV input should adhered\n to the following criteria, differences from RFC-4180 in parentheses.\n\n $(UL\n     $(LI A record is separated by a new line (CRLF,LF,CR))\n     $(LI A final record may end with a new line)\n     $(LI A header may be provided as the first record in input)\n     $(LI A record has fields separated by a comma (customizable))\n     $(LI A field containing new lines, commas, or double quotes\n          should be enclosed in double quotes (customizable))\n     $(LI Double quotes in a field are escaped with a double quote)\n     $(LI Each record should contain the same number of fields)\n   )\n\n Example:\n\n -------\n import std.algorithm;\n import std.array;\n import std.csv;\n import std.stdio;\n import std.typecons;\n\n void main()\n {\n     auto text = \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n     foreach(record; csvReader!(Tuple!(string,string,int))(text))\n     {\n         writefln(\"%s works as a %s and earns $%d per year\",\n                  record[0], record[1], record[2]);\n     }\n }\n -------\n\n When an input contains a header the $(D Contents) can be specified as an\n associative array. Passing null to signify that a header is present.\n\n -------\n auto text = \"Name,Occupation,Salary\\r\"\n     \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n foreach(record; csvReader!(string[string])\n         (text, null))\n {\n     writefln(\"%s works as a %s and earns $%s per year.\",\n              record[\"Name\"], record[\"Occupation\"],\n              record[\"Salary\"]);\n }\n -------\n\n This module allows content to be iterated by record stored in a struct,\n class, associative array, or as a range of fields. Upon detection of an\n error an CSVException is thrown (can be disabled). csvNextToken has been\n made public to allow for attempted recovery.\n\n Disabling exceptions will lift many restrictions specified above. A quote\n can appear in a field if the field was not quoted. If in a quoted field any\n quote by itself, not at the end of a field, will end processing for that\n field. The field is ended when there is no input, even if the quote was not\n closed.\n\n   See_Also:\n      $(WEB en.wikipedia.org\/wiki\/Comma-separated_values, Wikipedia\n      Comma-separated values)\n\n   Copyright: Copyright 2011\n   License:   $(WEB www.boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n   Authors:   Jesse Phillips\n   Source:    $(PHOBOSSRC std\/_csv.d)\n \n",
"members" : [
{
"name" : "CSVException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Exception containing the row and column for when an exception was thrown.\n\n Numbering of both row and col start at one and corresponds to the location\n in the file rather than any specified header. Special consideration should\n be made when there is failure to match the header see $(LREF\n HeaderMismatchException) for details.\n\n When performing type conversions, $(XREF ConvException) is stored in the $(D\n next) field.\n \n",
"line" : 102,
"base" : "Exception",
"members" : [
{
"name" : "row",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"comment" : "\n",
"line" : 105}
,
{
"name" : "col",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"comment" : "\n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CSVException(string msg, string file = __FILE__, ulong line = cast(ulong)__LINE__, Throwable next = null)",
"line" : 107}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CSVException(string msg, Throwable next, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CSVException(string msg, ulong row, ulong col, Throwable next = null, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"line" : 119}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 127}
]
}
,
{
"name" : "IncompleteCellException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Exception thrown when a Token is identified to not be completed: a quote is\n found in an unquoted field, data continues after a closing quote, or the\n quoted field was not closed before data was empty.\n \n",
"line" : 138,
"base" : "CSVException",
"members" : [
{
"name" : "partialData",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(dchar)[]",
"comment" : " Data pulled from input before finding a problem\n\n This field is populated when using $(LREF csvReader)\n but not by $(LREF csvNextToken) as this data will have\n already been fed to the output range.\n",
"line" : 145}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IncompleteCellException(string msg, string file = __FILE__, ulong line = cast(ulong)__LINE__, Throwable next = null)",
"line" : 147}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IncompleteCellException(string msg, Throwable next, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"line" : 152}
]
}
,
{
"name" : "HeaderMismatchException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Exception thrown under different conditions based on the type of $(D\n Contents).\n\n Structure, Class, and Associative Array\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n  )\n\n Other\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n     $(LI Order did not match that found in the input)\n  )\n\n Since a row and column is not meaningful when a column specified by the\n header is not found in the data, both row and col will be zero. Otherwise\n row is always one and col is the first instance found in header that\n occurred before the previous starting at one.\n \n",
"line" : 178,
"base" : "CSVException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HeaderMismatchException(string msg, string file = __FILE__, ulong line = cast(ulong)__LINE__, Throwable next = null)",
"line" : 180}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HeaderMismatchException(string msg, Throwable next, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"line" : 185}
]
}
,
{
"name" : "Malformed",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Determines the behavior for when an error is detected.\n\n Disabling exception will follow these rules:\n $(UL\n     $(LI A quote can appear in a field if the field was not quoted.)\n     $(LI If in a quoted field any quote by itself, not at the end of a\n     field, will end processing for that field.)\n     $(LI The field is ended when there is no input, even if the quote was\n     not closed.)\n     $(LI If the given header does not match the order in the input, the\n     content will return as it is found in the input.)\n     $(LI If the given header contains columns not found in the input they\n     will be ignored.)\n  )\n",
"line" : 208,
"base" : "int",
"members" : [
{
"name" : "ignore",
"kind" : "enum member",
"protection" : "public",
"comment" : " No exceptions are thrown due to incorrect CSV.\n",
"line" : 210}
,
{
"name" : "throwException",
"kind" : "enum member",
"protection" : "public",
"comment" : " Use exceptions when input has incorrect CSV.\n",
"line" : 212}
]
}
,
{
"name" : "csvReader(Contents = string,Malformed ErrorLevel = Malformed.throwException,Range,Separator = char) if (isInputRange!(Range) && is(ElementType!(Range) == dchar) && isSomeChar!(Separator) && !is(Contents T : T[U],U : string))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns an input range for iterating over records found in $(D\n input).\n\n The $(D Contents) of the input can be provided if all the records are the\n same type such as all integer data:\n\n -------\n string str = `76,26,22`;\n int[] ans = [76,26,22];\n auto records = csvReader!int(str);\n\n foreach(record; records)\n {\n     assert(equal(record, ans));\n }\n -------\n\n Example using a struct with modified delimiter:\n\n -------\n string str = \"Hello;65;63.63\\nWorld;123;3673.562\";\n struct Layout\n {\n     string name;\n     int value;\n     double other;\n }\n\n auto records = csvReader!Layout(str,';');\n\n foreach(record; records)\n {\n     writeln(record.name);\n     writeln(record.value);\n     writeln(record.other);\n }\n -------\n\n Specifying $(D ErrorLevel) as Malformed.ignore will lift restrictions\n on the format. This example shows that an exception is not thrown when\n finding a quote in a field not quoted.\n\n -------\n string str = \"A \\\" is now part of the data\";\n auto records = csvReader!(string,Malformed.ignore)(str);\n auto record = records.front;\n\n assert(record.front == str);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
"line" : 283,
"members" : [
{
"name" : "csvReader",
"kind" : "function",
"type" : "(Range input, Separator delimiter = ',', Separator quote = '\"')",
"comment" : "\n Returns an input range for iterating over records found in $(D\n input).\n\n The $(D Contents) of the input can be provided if all the records are the\n same type such as all integer data:\n\n -------\n string str = `76,26,22`;\n int[] ans = [76,26,22];\n auto records = csvReader!int(str);\n\n foreach(record; records)\n {\n     assert(equal(record, ans));\n }\n -------\n\n Example using a struct with modified delimiter:\n\n -------\n string str = \"Hello;65;63.63\\nWorld;123;3673.562\";\n struct Layout\n {\n     string name;\n     int value;\n     double other;\n }\n\n auto records = csvReader!Layout(str,';');\n\n foreach(record; records)\n {\n     writeln(record.name);\n     writeln(record.value);\n     writeln(record.other);\n }\n -------\n\n Specifying $(D ErrorLevel) as Malformed.ignore will lift restrictions\n on the format. This example shows that an exception is not thrown when\n finding a quote in a field not quoted.\n\n -------\n string str = \"A \\\" is now part of the data\";\n auto records = csvReader!(string,Malformed.ignore)(str);\n auto record = records.front;\n\n assert(record.front == str);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
"line" : 283}
]
}
,
{
"name" : "csvReader(Contents = string,Malformed ErrorLevel = Malformed.throwException,Range,Header,Separator = char) if (isInputRange!(Range) && is(ElementType!(Range) == dchar) && isSomeChar!(Separator) && isForwardRange!(Header) && isSomeString!(ElementType!(Header)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n An optional $(D header) can be provided. The first record will be read in\n as the header. If $(D Contents) is a struct then the header provided is\n expected to correspond to the fields in the struct. When $(D Contents) is\n not a type which can contain the entire record, the $(D header) must be\n provided in the same order as the input or an exception is thrown.\n\n Read only column \"b\":\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader!int(str, [\"b\"]);\n\n auto ans = [[65],[123]];\n foreach(record; records)\n {\n     assert(equal(record, ans.front));\n     ans.popFront();\n }\n -------\n\n Read from header of different order:\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n struct Layout\n {\n     int value;\n     double other;\n     string name;\n }\n\n auto records = csvReader!Layout(str, [\"b\",\"c\",\"a\"]);\n -------\n\n The header can also be left empty if the input contains a header but\n all columns should be iterated. The header from the input can always\n be accessed from the header field.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader(str, null);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n        The returned range provides a header field for accessing the header\n        from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
"line" : 370,
"members" : [
{
"name" : "csvReader",
"kind" : "function",
"type" : "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
"comment" : "\n An optional $(D header) can be provided. The first record will be read in\n as the header. If $(D Contents) is a struct then the header provided is\n expected to correspond to the fields in the struct. When $(D Contents) is\n not a type which can contain the entire record, the $(D header) must be\n provided in the same order as the input or an exception is thrown.\n\n Read only column \"b\":\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader!int(str, [\"b\"]);\n\n auto ans = [[65],[123]];\n foreach(record; records)\n {\n     assert(equal(record, ans.front));\n     ans.popFront();\n }\n -------\n\n Read from header of different order:\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n struct Layout\n {\n     int value;\n     double other;\n     string name;\n }\n\n auto records = csvReader!Layout(str, [\"b\",\"c\",\"a\"]);\n -------\n\n The header can also be left empty if the input contains a header but\n all columns should be iterated. The header from the input can always\n be accessed from the header field.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader(str, null);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n        The returned range provides a header field for accessing the header\n        from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
"line" : 370}
]
}
,
{
"name" : "csvReader(Contents = string,Malformed ErrorLevel = Malformed.throwException,Range,Header,Separator = char) if (isInputRange!(Range) && is(ElementType!(Range) == dchar) && isSomeChar!(Separator) && is(Header : typeof(null)))",
"kind" : "template",
"protection" : "public",
"line" : 385,
"members" : [
{
"name" : "csvReader",
"kind" : "function",
"type" : "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
"line" : 385}
]
}
,
{
"name" : "Input(Range,Malformed ErrorLevel)",
"kind" : "struct",
"protection" : "public",
"line" : 719,
"members" : [
{
"name" : "Input",
"kind" : "struct",
"protection" : "public",
"line" : 719,
"members" : [
{
"name" : "range",
"kind" : "variable",
"type" : "Range",
"line" : 720}
,
{
"name" : "row",
"kind" : "variable",
"type" : "size_t",
"line" : 721}
,
{
"name" : "col",
"kind" : "variable",
"type" : "size_t",
"line" : 721}
]
}
]
}
,
{
"name" : "CsvReader(Contents,Malformed ErrorLevel,Range,Separator,Header) if (isSomeChar!(Separator) && isInputRange!(Range) && is(ElementType!(Range) == dchar) && isForwardRange!(Header) && isSomeString!(ElementType!(Header)))",
"kind" : "struct",
"protection" : "public",
"line" : 751,
"members" : [
{
"name" : "CsvReader",
"kind" : "struct",
"protection" : "public",
"line" : 751,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Input!(Range,ErrorLevel)*",
"line" : 753}
,
{
"name" : "_separator",
"kind" : "variable",
"type" : "Separator",
"line" : 754}
,
{
"name" : "_quote",
"kind" : "variable",
"type" : "Separator",
"line" : 755}
,
{
"name" : "indices",
"kind" : "variable",
"type" : "size_t[]",
"line" : 756}
,
{
"name" : "_empty",
"kind" : "variable",
"type" : "bool",
"line" : 757}
,
{
"name" : "header",
"kind" : "variable",
"type" : "string[]",
"comment" : "\n Header from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n     \n",
"line" : 781}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input, Separator delimiter, Separator quote)",
"comment" : "\n Constructor to initialize the input, delimiter and quote for input\n without a header.\n\n -------\n string str = `76;^26^;22`;\n int[] ans = [76,26,22];\n auto records = CsvReader!(int,Malformed.ignore,string,char,string[])\n       (str, ';', '^');\n\n foreach(record; records) {\n    assert(equal(record, ans));\n }\n -------\n     \n",
"line" : 798}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input, Header colHeaders, Separator delimiter, Separator quote)",
"comment" : "\n Constructor to initialize the input, delimiter and quote for input\n with a header.\n\n -------\n string str = `high;mean;low\\n76;^26^;22`;\n auto records = CsvReader!(int,Malformed.ignore,string,char,string[])\n       (str, [\"high\",\"low\"], ';', '^');\n\n int[] ans = [76,22];\n foreach(record; records) {\n    assert(equal(record, ans));\n }\n -------\n\n Throws:\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found\n       in the input (non-struct).\n     \n",
"line" : 828}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ()",
"comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n\n Returns:\n      If $(D Contents) is a struct, will be filled with record data.\n\n      If $(D Contents) is a class, will be filled with record data.\n\n      If $(D Contents) is a associative array, will be filled\n      with record data.\n\n      If $(D Contents) is non-struct, a $(LREF CsvRecord) will be\n      returned.\n     \n",
"line" : 911}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n     \n",
"line" : 930}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the\n       row's length does not match the previous length.\n     \n",
"line" : 944}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void()",
"line" : 978}
]
}
]
}
,
{
"name" : "CsvRecord(Contents,Malformed ErrorLevel,Range,Separator) if (!is(Contents == class) && !is(Contents == struct))",
"kind" : "struct",
"protection" : "public",
"line" : 1072,
"members" : [
{
"name" : "CsvRecord",
"kind" : "struct",
"protection" : "public",
"line" : 1072,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Input!(Range,ErrorLevel)*",
"line" : 1074}
,
{
"name" : "_separator",
"kind" : "variable",
"type" : "Separator",
"line" : 1075}
,
{
"name" : "_quote",
"kind" : "variable",
"type" : "Separator",
"line" : 1076}
,
{
"name" : "curContentsoken",
"kind" : "variable",
"type" : "Contents",
"line" : 1077}
,
{
"name" : "_front",
"kind" : "variable",
"type" : "typeof(appender!(dchar[])())",
"line" : 1078}
,
{
"name" : "_empty",
"kind" : "variable",
"type" : "bool",
"line" : 1079}
,
{
"name" : "_popCount",
"kind" : "variable",
"type" : "size_t[]",
"line" : 1080}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Input!(Range,ErrorLevel)* input, Separator delimiter, Separator quote, size_t[] indices)",
"line" : 1090}
,
{
"name" : "front",
"kind" : "function",
"type" : "Contents()",
"comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n     \n",
"line" : 1122}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n     \n",
"line" : 1131}
,
{
"name" : "recordEnd",
"kind" : "function",
"type" : "bool()",
"line" : 1140}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the\n       row's length does not match the previous length.\n     \n",
"line" : 1161}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void(size_t skipNum)",
"line" : 1205}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void()",
"line" : 1231}
]
}
]
}
,
{
"name" : "csvNextToken(Range,Malformed ErrorLevel = Malformed.throwException,Separator,Output) if (isSomeChar!(Separator) && isInputRange!(Range) && is(ElementType!(Range) == dchar) && isOutputRange!(Output,dchar))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Lower level control over parsing CSV\n\n This function consumes the input. After each call the input will\n start with either a delimiter or record break (\\n, \\r\\n, \\r) which\n must be removed for subsequent calls.\n\n -------\n string str = \"65,63\\n123,3673\";\n\n auto a = appender!(char[])();\n\n csvNextToken(str,a,',','\"');\n assert(a.data == \"65\");\n assert(str == \",63\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"63\");\n assert(str == \"\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"123\");\n assert(str == \",3673\");\n -------\n\n params:\n       input = Any CSV input\n       ans   = The first field in the input\n       sep   = The character to represent a comma in the specification\n       quote = The character to represent a quote in the specification\n       startQuoted = Whether the input should be considered to already be in\n quotes\n\n Throws:\n       $(LREF IncompleteCellException) When a quote is found in an unquoted\n       field, data continues after a closing quote, or the quoted field was\n       not closed before data was empty.\n \n",
"line" : 1311,
"members" : [
{
"name" : "csvNextToken",
"kind" : "function",
"type" : "void(ref Range input, ref Output ans, Separator sep, Separator quote, bool startQuoted = false)",
"comment" : "\n Lower level control over parsing CSV\n\n This function consumes the input. After each call the input will\n start with either a delimiter or record break (\\n, \\r\\n, \\r) which\n must be removed for subsequent calls.\n\n -------\n string str = \"65,63\\n123,3673\";\n\n auto a = appender!(char[])();\n\n csvNextToken(str,a,',','\"');\n assert(a.data == \"65\");\n assert(str == \",63\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"63\");\n assert(str == \"\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"123\");\n assert(str == \",3673\");\n -------\n\n params:\n       input = Any CSV input\n       ans   = The first field in the input\n       sep   = The character to represent a comma in the specification\n       quote = The character to represent a quote in the specification\n       startQuoted = Whether the input should be considered to already be in\n quotes\n\n Throws:\n       $(LREF IncompleteCellException) When a quote is found in an unquoted\n       field, data continues after a closing quote, or the quoted field was\n       not closed before data was empty.\n \n",
"line" : 1311}
]
}
]
}
,
{
"name" : "std.ctype",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/ctype.d",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n  $(LINK2 std_ascii.html, std.ascii) instead.)\n\n Simple ASCII character classification functions.\n For Unicode classification, see $(LINK2 std_uni.html, std.uni).\n References:\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/ascii-table.html, ASCII Table),\n      $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Ascii, Wikipedia)\n Macros:\n      WIKI=Phobos\/StdCtype\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n Source:    $(PHOBOSSRC std\/_ctype.d)\n \n",
"members" : [
{
"name" : "isalnum",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n       $(D std.ascii.isAlphaNum) instead.)\n\n Returns !=0 if c is a letter in the range (0..9, a..z, A..Z).\n \n",
"line" : 36}
,
{
"name" : "isalpha",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n       $(D std.ascii.isAlpha) instead.)\n\n Returns !=0 if c is an ascii upper or lower case letter.\n \n",
"line" : 44}
,
{
"name" : "iscntrl",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ctype.ascii.isControl) instead.)\n\n Returns !=0 if c is a control character.\n \n",
"line" : 52}
,
{
"name" : "isdigit",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isDigit) instead.)\n\n Returns !=0 if c is a digit.\n \n",
"line" : 60}
,
{
"name" : "islower",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isLower) instead.)\n\n Returns !=0 if c is lower case ascii letter.\n \n",
"line" : 68}
,
{
"name" : "ispunct",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isPunctuation) instead.)\n\n Returns !=0 if c is a punctuation character.\n \n",
"line" : 76}
,
{
"name" : "isspace",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isWhite) instead.)\n\n Returns !=0 if c is a space, tab, vertical tab, form feed,\n carriage return, or linefeed.\n \n",
"line" : 85}
,
{
"name" : "isupper",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isUpper) instead.)\n\n Returns !=0 if c is an upper case ascii character.\n \n",
"line" : 93}
,
{
"name" : "isxdigit",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isHexDigit) instead.)\n\n Returns !=0 if c is a hex digit (0..9, a..f, A..F).\n \n",
"line" : 101}
,
{
"name" : "isgraph",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isGraphical) instead.)\n\n Returns !=0 if c is a printing character except for the space character.\n \n",
"line" : 109}
,
{
"name" : "isprint",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isPrintable) instead.)\n\n Returns !=0 if c is a printing character including the space character.\n \n",
"line" : 117}
,
{
"name" : "isascii",
"kind" : "function",
"protection" : "public",
"type" : "pure int(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.isASCII) instead.)\n\n Returns !=0 if c is in the ascii character set, i.e. in the range 0..0x7F.\n \n",
"line" : 125}
,
{
"name" : "tolower",
"kind" : "function",
"protection" : "public",
"type" : "pure dchar(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.toLower) instead.)\n\n If c is an upper case ascii character,\n return the lower case equivalent, otherwise return c.\n \n",
"line" : 135}
,
{
"name" : "toupper",
"kind" : "function",
"protection" : "public",
"type" : "pure dchar(dchar c)",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012. Please use\n $(D std.ascii.toUpper) instead.)\n\n If c is a lower case ascii character,\n return the upper case equivalent, otherwise return c.\n \n",
"line" : 148}
,
{
"name" : "_SPC",
"kind" : "enum member",
"protection" : "public",
"line" : 161}
,
{
"name" : "_CTL",
"kind" : "enum member",
"protection" : "public",
"line" : 162}
,
{
"name" : "_BLK",
"kind" : "enum member",
"protection" : "public",
"line" : 163}
,
{
"name" : "_HEX",
"kind" : "enum member",
"protection" : "public",
"line" : 164}
,
{
"name" : "_UC",
"kind" : "enum member",
"protection" : "public",
"line" : 165}
,
{
"name" : "_LC",
"kind" : "enum member",
"protection" : "public",
"line" : 166}
,
{
"name" : "_PNC",
"kind" : "enum member",
"protection" : "public",
"line" : 167}
,
{
"name" : "_DIG",
"kind" : "enum member",
"protection" : "public",
"line" : 168}
,
{
"name" : "_ALP",
"kind" : "enum member",
"protection" : "public",
"line" : 169}
,
{
"name" : "_ctype",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(ubyte[128LU])",
"line" : 172}
]
}
,
{
"name" : "std.datetime",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/datetime.d",
"comment" : "\n    Module containing Date\/Time functionality.\n\n    This module provides:\n    $(UL\n        $(LI Types to represent points in time: $(D SysTime), $(D Date),\n             $(D TimeOfDay), and $(D DateTime).)\n        $(LI Types to represent intervals of time.)\n        $(LI Types to represent ranges over intervals of time.)\n        $(LI Types to represent time zones (used by $(D SysTime)).)\n        $(LI A platform-independent, high precision stopwatch type:\n             $(D StopWatch))\n        $(LI Benchmarking functions.)\n        $(LI Various helper functions.)\n    )\n\n    Closely related to std.datetime is <a href=\"core_time.html\">$(D core.time)<\/a>,\n    and some of the time types used in std.datetime come from there - such as\n    $(CXREF time, Duration), $(CXREF time, TickDuration), and\n    $(CXREF time, FracSec).\n    core.time is publically imported into std.datetime, it isn't necessary\n    to import it separately.\n\n    Three of the main concepts used in this module are time points, time\n    durations, and time intervals.\n\n    A time point is a specific point in time. e.g. January 5th, 2010\n    or 5:00.\n\n    A time duration is a length of time with units. e.g. 5 days or 231 seconds.\n\n    A time interval indicates a period of time associated with a fixed point in\n    time. It is either two time points associated with each other,\n    indicating the time starting at the first point up to, but not including,\n    the second point - e.g. [January 5th, 2010 - March 10th, 2010$(RPAREN) - or\n    it is a time point and a time duration associated with one another. e.g.\n    January 5th, 2010 and 5 days, indicating [January 5th, 2010 -\n    January 10th, 2010$(RPAREN).\n\n    Various arithmetic operations are supported between time points and\n    durations (e.g. the difference between two time points is a time duration),\n    and ranges can be gotten from time intervals, so range-based operations may\n    be done on a series of time points.\n\n    The types that the typical user is most likely to be interested in are\n    $(D Date) (if they want dates but don't care about time), $(D DateTime)\n    (if they want dates and times but don't care about time zones), $(D SysTime)\n    (if they want the date and time from the OS and\/or do care about time\n    zones), and StopWatch (a platform-independent, high precision stop watch).\n    $(D Date) and $(D DateTime) are optimized for calendar-based operations,\n    while $(D SysTime) is designed for dealing with time from the OS. Check out\n    their specific documentation for more details.\n\n    To get the current time, use $(D Clock.currTime). It will return the current\n    time as a $(D SysTime). To print it, $(D toString) is\n    sufficient, but if using $(D toISOString), $(D toISOExtString), or\n    $(D toSimpleString), use the corresponding $(D fromISOString),\n    $(D fromISOExtString), or $(D fromISOExtString) to create a\n    $(D SysTime) from the string.\n\n--------------------\nauto currentTime = Clock.currTime();\nauto timeString = currentTime.toISOExtString();\nauto restoredTime = SysTime.fromISOExtString(timeString);\n--------------------\n\n    Various functions take a string (or strings) to represent a unit of time\n    (e.g. $(D convert!(\"days\", \"hours\")(numDays))). The valid strings to use\n    with such functions are $(D \"years\"), $(D \"months\"), $(D \"weeks\"),\n    $(D \"days\"), $(D \"hours\"), $(D \"minutes\"), $(D \"seconds\"),\n    $(D \"msecs\") (milliseconds), $(D \"usecs\") (microseconds),\n    $(D \"hnsecs\") (hecto-nanoseconds - i.e. 100 ns), or some subset thereof.\n    There are a few functions in core.time which take $(D \"nsecs\"), but because\n    nothing in std.datetime has precision greater than hnsecs, and very little\n    in core.time does, no functions in std.datetime accept $(D \"nsecs\").\n    To remember which units are abbreviated and which aren't,\n    all units seconds and greater use their full names, and all\n    sub-second units are abbreviated (since they'd be rather long if they\n    weren't).\n\n    Note:\n        $(D DateTimeException) is an alias for core.time's $(D TimeException),\n        so you don't need to worry about core.time functions and std.datetime\n        functions throwing different exception types (except in the rare case\n        that they throw something other than $(D TimeException) or\n        $(D DateTimeException)).\n\n    See_Also:\n        <a href=\"..\/intro-to-datetime.html\">Introduction to std&#46;_datetime <\/a><br>\n        $(WEB en.wikipedia.org\/wiki\/ISO_8601, ISO 8601)<br>\n        $(WEB en.wikipedia.org\/wiki\/Tz_database,\n              Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org\/wiki\/List_of_tz_database_time_zones,\n              List of Time Zones)<br>\n\n    Copyright: Copyright 2010 - 2011\n    License:   $(WEB www.boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Jonathan M Davis and Kato Shoichi\n    Source:    $(PHOBOSSRC std\/_datetime.d)\n",
"members" : [
{
"name" : "stds_indexOf",
"kind" : "alias",
"protection" : "private",
"line" : 155}
,
{
"name" : "Month",
"kind" : "enum",
"protection" : "public",
"comment" : "\n    Represents the 12 months of the Gregorian year (January is 1).\n  \n",
"line" : 194,
"base" : "ubyte",
"members" : [
{
"name" : "jan",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 194}
,
{
"name" : "feb",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 195}
,
{
"name" : "mar",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 196}
,
{
"name" : "apr",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 197}
,
{
"name" : "may",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 198}
,
{
"name" : "jun",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 199}
,
{
"name" : "jul",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 200}
,
{
"name" : "aug",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 201}
,
{
"name" : "sep",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 202}
,
{
"name" : "oct",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 203}
,
{
"name" : "nov",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 204}
,
{
"name" : "dec",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 205}
]
}
,
{
"name" : "DayOfWeek",
"kind" : "enum",
"protection" : "public",
"comment" : "\n    Represents the 7 days of the Gregorian week (Sunday is 0).\n  \n",
"line" : 211,
"base" : "ubyte",
"members" : [
{
"name" : "sun",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 211}
,
{
"name" : "mon",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 212}
,
{
"name" : "tue",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 213}
,
{
"name" : "wed",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 214}
,
{
"name" : "thu",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 215}
,
{
"name" : "fri",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 216}
,
{
"name" : "sat",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 217}
]
}
,
{
"name" : "AllowDayOverflow",
"kind" : "enum",
"protection" : "public",
"comment" : "\n    In some date calculations, adding months or years can cause the date to fall\n    on a day of the month which is not valid (e.g. February 29th 2001 or\n    June 31st 2000). If overflow is allowed (as is the default), then the month\n    will be incremented accordingly (so, February 29th 2001 would become\n    March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow\n    is not allowed, then the day will be adjusted to the last valid day in that\n    month (so, February 29th 2001 would become February 28th 2001 and\n    June 31st 2000 would become June 30th 2000).\n\n    AllowDayOverflow only applies to calculations involving months or years.\n  \n",
"line" : 233,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " No, don't allow day overflow.\n",
"line" : 235}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " Yes, allow day overflow.\n",
"line" : 238}
]
}
,
{
"name" : "Direction",
"kind" : "enum",
"protection" : "public",
"comment" : "\n    Indicates a direction in time. One example of its use is $(D Interval)'s\n    $(D expand) function which uses it to indicate whether the interval should\n    be expanded backwards (into the past), forwards (into the future), or both.\n  \n",
"line" : 247,
"base" : "int",
"members" : [
{
"name" : "bwd",
"kind" : "enum member",
"protection" : "public",
"comment" : " Backward.\n",
"line" : 249}
,
{
"name" : "fwd",
"kind" : "enum member",
"protection" : "public",
"comment" : " Forward.\n",
"line" : 252}
,
{
"name" : "both",
"kind" : "enum member",
"protection" : "public",
"comment" : " Both backward and forward.\n",
"line" : 255}
]
}
,
{
"name" : "PopFirst",
"kind" : "enum",
"protection" : "public",
"comment" : "\n    Used to indicate whether $(D popFront) should be called immediately upon\n    creating a range. The idea is that for some functions used to generate a\n    range for an interval, $(D front) is not necessarily a time point which\n    would ever be generated by the range. To get the first time point\n    in the range to match what the function generates, then use\n    $(D PopFirst.yes) to indicate that the range should have $(D popFront)\n    called on it before the range is returned so that $(D front) is a time point\n    which the function would generate.\n\n    For instance, if the function used to generate a range of time points\n    generated successive Easters (i.e. you're iterating over all of the Easters\n    within the interval), the initial date probably isn't an Easter. Using\n    $(D PopFirst.yes) would tell the function which returned the\n    range that $(D popFront) was to be called so that front would then be\n    an Easter - the next one generated by the function (which when\n    iterating forward would be the Easter following the original $(D front),\n    while when iterating backward, it would be the Easter prior to the\n    original $(D front)). If $(D PopFirst.no) were used, then $(D front) would\n    remain the original time point and it would not necessarily be a time point\n    which would be generated by the range-generating function (which in many\n    cases is exactly what is desired -\n    e.g. if iterating over every day starting at the beginning\n    of the interval).\n  \n",
"line" : 284,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " No, don't call popFront() before returning the range.\n",
"line" : 286}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " Yes, call popFront() before returning the range.\n",
"line" : 289}
]
}
,
{
"name" : "AutoStart",
"kind" : "enum",
"protection" : "public",
"comment" : "\n   Used by StopWatch to indicate whether it should start immediately upon\n   construction.\n  \n",
"line" : 297,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " No, don't start the StopWatch when it is constructed.\n",
"line" : 299}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " Yes, do start the StopWatch when it is constructed.\n",
"line" : 302}
]
}
,
{
"name" : "timeStrings",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[][])",
"comment" : "\n    Array of the strings representing time units, starting with the smallest\n    unit and going to the largest. It does not include $(D \"nsecs\").\n\n   Includes $(D \"hnsecs\") (hecto-nanoseconds (100 ns)),\n   $(D \"usecs\") (microseconds), $(D \"msecs\") (milliseconds), $(D \"seconds\"),\n   $(D \"minutes\"), $(D \"hours\"), $(D \"days\"), $(D \"weeks\"), $(D \"months\"), and\n   $(D \"years\")\n  \n",
"line" : 314}
,
{
"name" : "lastDayNonLeap",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[13LU])",
"comment" : "\n    Array of integers representing the last days of each month in a year.\n  \n",
"line" : 325}
,
{
"name" : "lastDayLeap",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[13LU])",
"comment" : "\n    Array of integers representing the last days of each month in a leap year.\n  \n",
"line" : 330}
,
{
"name" : "longMonthNames",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(char[][12LU])",
"comment" : "\n    Array of the long names of each month.\n  \n",
"line" : 335}
,
{
"name" : "shortMonthNames",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(char[][12LU])",
"comment" : "\n    Array of the short (three letter) names of each month.\n  \n",
"line" : 353}
,
{
"name" : "DateTimeException",
"kind" : "alias",
"protection" : "public",
"type" : "core.time.TimeException",
"comment" : "\n    Exception type used by std.datetime. It's an alias to TimeException, which\n    is what core.time uses. Either can be caught without concern about which\n    module it came from.\n  \n",
"line" : 377}
,
{
"name" : "Clock",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Effectively a namespace to make it clear that the methods it contains are\n    getting the time from the system clock. It cannot be instantiated.\n \n",
"line" : 384,
"base" : "Object",
"members" : [
{
"name" : "currTime",
"kind" : "function",
"protection" : "public",
"type" : "SysTime(immutable(TimeZone) tz = cast(immutable(TimeZone))opCall())",
"comment" : "\n        Returns the current time in the given time zone.\n\n        Throws:\n            $(D ErrnoException) (on Posix) or $(D Exception) (on Windows)\n            if it fails to get the time of day.\n      \n",
"line" : 394}
,
{
"name" : "currStdTime",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted long()",
"comment" : "\n        Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the\n        current time.\n\n        Throws:\n            $(D DateTimeException) if it fails to get the time.\n      \n",
"line" : 431}
,
{
"name" : "currSystemTick",
"kind" : "function",
"protection" : "public",
"type" : "@property @safe TickDuration()",
"comment" : "\n        The current system tick. The number of ticks per second varies from\n        system to system. currSystemTick uses a monotonic clock, so it's\n        intended for precision timing by comparing relative time values, not\n        for getting the current system time.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or Linux.\n\n        Throws:\n            $(D DateTimeException) if it fails to get the time.\n      \n",
"line" : 486}
,
{
"name" : "currAppTick",
"kind" : "function",
"protection" : "public",
"type" : "@property @safe TickDuration()",
"comment" : "\n        The current number of system ticks since the application started.\n        The number of ticks per second varies from system to system.\n        This uses a monotonic clock.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or on Linux.\n\n        Throws:\n            $(D DateTimeException) if it fails to get the time.\n      \n",
"line" : 512}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "Clock()",
"line" : 528}
]
}
,
{
"name" : "SysTime",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    $(D SysTime) is the type used to get the current time from the\n    system or doing anything that involves time zones. Unlike\n    $(D DateTime), the time zone is an integral part of $(D SysTime) (though for\n    local time applications, time zones can be ignored and\n    it will work, since it defaults to using the local time zone). It holds its\n    internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC),\n    so it interfaces well with the system time. However, that means that, unlike\n    $(D DateTime), it is not optimized for calendar-based operations, and\n    getting individual units from it such as years or days is going to involve\n    conversions and be less efficient.\n\n    For calendar-based operations that don't\n    care about time zones, then $(D DateTime) would be the type to\n    use. For system time, use $(D SysTime).\n\n    $(D Clock.currTime) will return the current time as a $(D SysTime).\n    To convert a $(D SysTime) to a $(D Date) or $(D DateTime), simply cast\n    it. To convert a $(D Date) or $(D DateTime) to a\n    $(D SysTime), use $(D SysTime)'s constructor, and pass in the\n    intended time zone with it (or don't pass in a $(D TimeZone), and the local\n    time zone will be used). Be aware, however, that converting from a\n    $(D DateTime) to a $(D SysTime) will not necessarily be 100% accurate due to\n    DST (one hour of the year doesn't exist and another occurs twice).\n    To not risk any conversion errors, keep times as\n    $(D SysTime)s. Aside from DST though, there shouldn't be any conversion\n    problems.\n\n    For using time zones other than local time or UTC, use\n    $(D PosixTimeZone) on Posix systems (or on Windows, if providing the TZ\n    Database files), and use $(D WindowsTimeZone) on Windows systems.\n    The time in $(D SysTime) is kept internally in hnsecs from midnight,\n    January 1st, 1 A.D. UTC. Conversion error cannot happen when changing\n    the time zone of a $(D SysTime). $(D LocalTime) is the $(D TimeZone) class\n    which represents the local time, and $(D UTC) is the $(D TimeZone) class\n    which represents UTC. $(D SysTime) uses $(D LocalTime) if no $(D TimeZone)\n    is provided. For more details on time zones, see the documentation for\n    $(D TimeZone), $(D PosixTimeZone), and $(D WindowsTimeZone).\n\n    $(D SysTime)'s range is from approximately 29,000 B.C. to approximately\n    29,000 A.D.\n  \n",
"line" : 578,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "nothrow ref SysTime(const(DateTime) dateTime, immutable(TimeZone) tz = null)",
"comment" : "\n        Params:\n            dateTime = The $(D DateTime) to use to set this $(D SysTime)'s\n                       internal std time. As $(D DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            tz       = The $(D TimeZone) to use for this $(D SysTime). If null,\n                       $(D LocalTime) will be used. The given $(D DateTime) is\n                       assumed to be in the given time zone.\n      \n",
"line" : 590}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref SysTime(const(DateTime) dateTime, const(FracSec) fracSec, immutable(TimeZone) tz = null)",
"comment" : "\n        Params:\n            dateTime = The $(D DateTime) to use to set this $(D SysTime)'s\n                       internal std time. As $(D DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            fracSec  = The fractional seconds portion of the time.\n            tz       = The $(D TimeZone) to use for this $(D SysTime). If null,\n                       $(D LocalTime) will be used. The given $(D DateTime) is\n                       assumed to be in the given time zone.\n\n        Throws:\n            $(D DateTimeException) if $(D fracSec) is negative.\n      \n",
"line" : 635}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "nothrow ref SysTime(const(Date) date, immutable(TimeZone) tz = null)",
"comment" : "\n        Params:\n            date = The $(D Date) to use to set this $(D SysTime)'s internal std\n                   time. As $(D Date) has no concept of time zone, tz is used as\n                   its time zone.\n            tz   = The $(D TimeZone) to use for this $(D SysTime). If null,\n                   $(D LocalTime) will be used. The given $(D Date) is assumed\n                   to be in the given time zone.\n      \n",
"line" : 693}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "pure nothrow ref SysTime(long stdTime, immutable(TimeZone) tz = null)",
"comment" : "\n        Note:\n            Whereas the other constructors take in the given date\/time, assume\n            that it's in the given time zone, and convert it to hnsecs in UTC\n            since midnight, January 1st, 1 A.D. UTC - i.e. std time - this\n            constructor takes a std time, which is specifically already in UTC,\n            so no conversion takes place. Of course, the various getter\n            properties and functions will use the given time zone's conversion\n            function to convert the results to that time zone, but no conversion\n            of the arguments to this constructor takes place.\n\n        Params:\n            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D. UTC.\n            tz      = The $(D TimeZone) to use for this $(D SysTime). If null,\n                      $(D LocalTime) will be used.\n      \n",
"line" : 740}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow ref SysTime(ref const(SysTime) rhs)",
"comment" : "\n        Params:\n            rhs = The $(D SysTime) to assign to this one.\n      \n",
"line" : 767}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow ref SysTime(SysTime rhs)",
"comment" : "\n        Params:\n            rhs = The $(D SysTime) to assign to this one.\n      \n",
"line" : 779}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow bool(const(SysTime) rhs)",
"comment" : "\n        Checks for equality between this $(D SysTime) and the given\n        $(D SysTime).\n\n        Note that the time zone is ignored. Only the internal\n        std times (which are in UTC) are compared.\n     \n",
"line" : 794}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow bool(ref const(SysTime) rhs)",
"comment" : " ditto\n",
"line" : 800}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow int(const(SysTime) rhs)",
"comment" : "\n        Compares this $(D SysTime) with the given $(D SysTime).\n\n        Time zone is irrelevant when comparing $(D SysTime)s.\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
"line" : 860}
,
{
"name" : "year",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property short()",
"comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n     \n",
"line" : 933}
,
{
"name" : "year",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int year)",
"comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(D SysTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).year == 1999);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).year == 2010);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).year == -7);\n--------------------\n     \n",
"line" : 991}
,
{
"name" : "yearBC",
"kind" : "function",
"protection" : "public",
"type" : "const @property ushort()",
"comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(D DateTimeException) if $(D isAD) is true.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(0, 1, 1, 12, 30, 33)).yearBC == 1);\nassert(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).yearBC == 2);\nassert(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).yearBC == 101);\n--------------------\n     \n",
"line" : 1077}
,
{
"name" : "yearBC",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int year)",
"comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(D SysTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if a non-positive value is given.\n\n        Examples:\n--------------------\nauto st = SysTime(DateTime(2010, 1, 1, 7, 30, 0));\nst.yearBC = 1;\nassert(st == SysTime(DateTime(0, 1, 1, 7, 30, 0)));\n\nst.yearBC = 10;\nassert(st == SysTime(DateTime(-9, 1, 1, 7, 30, 0)));\n--------------------\n     \n",
"line" : 1130}
,
{
"name" : "month",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property Month()",
"comment" : "\n        Month of a Gregorian Year.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).month == 7);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).month == 10);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).month == 4);\n--------------------\n     \n",
"line" : 1226}
,
{
"name" : "month",
"kind" : "function",
"protection" : "public",
"type" : "@property void(Month month)",
"comment" : "\n        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(D SysTime)'s month to.\n\n        Throws:\n            $(D DateTimeException) if the given month is not a valid month.\n     \n",
"line" : 1284}
,
{
"name" : "day",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        Day of a Gregorian Month.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).day == 6);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).day == 4);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).day == 5);\n--------------------\n     \n",
"line" : 1391}
,
{
"name" : "day",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int day)",
"comment" : "\n        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(D SysTime)'s day to.\n\n        Throws:\n            $(D DateTimeException) if the given day is not a valid day of the\n            current month.\n     \n",
"line" : 1450}
,
{
"name" : "hour",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        Hours past midnight.\n     \n",
"line" : 1542}
,
{
"name" : "hour",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int hour)",
"comment" : "\n        Hours past midnight.\n\n        Params:\n            hour = The hours to set this $(D SysTime)'s hour to.\n\n        Throws:\n            $(D DateTimeException) if the given hour are not a valid hour of\n            the day.\n     \n",
"line" : 1609}
,
{
"name" : "minute",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        Minutes past the current hour.\n     \n",
"line" : 1660}
,
{
"name" : "minute",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int minute)",
"comment" : "\n        Minutes past the current hour.\n\n        Params:\n            minutes = The minute to set this $(D SysTime)'s minute to.\n\n        Throws:\n            $(D DateTimeException) if the given minute are not a valid minute\n            of an hour.\n     \n",
"line" : 1729}
,
{
"name" : "second",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        Seconds past the current minute.\n     \n",
"line" : 1783}
,
{
"name" : "second",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int second)",
"comment" : "\n        Seconds past the current minute.\n\n        Params:\n            second = The second to set this $(D SysTime)'s second to.\n\n        Throws:\n            $(D DateTimeException) if the given second are not a valid second\n            of a minute.\n     \n",
"line" : 1853}
,
{
"name" : "fracSec",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property FracSec()",
"comment" : "\n        Fractional seconds passed the second.\n     \n",
"line" : 1909}
,
{
"name" : "fracSec",
"kind" : "function",
"protection" : "public",
"type" : "@property void(FracSec fracSec)",
"comment" : "\n        Fractional seconds passed the second.\n\n        Params:\n            fracSec = The fractional seconds to set this $(D SysTimes)'s\n                      fractional seconds to.\n\n        Throws:\n            $(D DateTimeException) if $(D fracSec) is negative.\n     \n",
"line" : 1979}
,
{
"name" : "stdTime",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property long()",
"comment" : "\n        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(D SysTime).\n     \n",
"line" : 2037}
,
{
"name" : "stdTime",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property void(long stdTime)",
"comment" : "\n        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(D SysTime).\n\n        Params:\n            stdTime = The number of hnsecs since January 1st, 1 A.D. UTC.\n     \n",
"line" : 2066}
,
{
"name" : "timezone",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property immutable(TimeZone)()",
"comment" : "\n        The current time zone of this $(D SysTime). Its internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(D SysTime)'s time zone before returning.\n      \n",
"line" : 2099}
,
{
"name" : "timezone",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property void(immutable(TimeZone) timezone)",
"comment" : "\n        The current time zone of this $(D SysTime). It's internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(D SysTime)'s time zone before returning.\n\n        Params:\n            tz = The $(D TimeZone) to set this $(D SysTime)'s time zone to.\n      \n",
"line" : 2114}
,
{
"name" : "dstInEffect",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Returns whether DST is in effect for this $(D SysTime).\n      \n",
"line" : 2126}
,
{
"name" : "utcOffset",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property Duration()",
"comment" : "\n        Returns what the offset from UTC is for this $(D SysTime).\n        It includes the DST offset in effect at that time (if any).\n      \n",
"line" : 2137}
,
{
"name" : "toLocalTime",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow SysTime()",
"comment" : "\n        Returns a $(D SysTime) with the same std time as this one, but with\n        $(D LocalTime) as its time zone.\n      \n",
"line" : 2147}
,
{
"name" : "toUTC",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow SysTime()",
"comment" : "\n        Returns a $(D SysTime) with the same std time as this one, but with\n        $(D UTC) as its time zone.\n      \n",
"line" : 2182}
,
{
"name" : "toOtherTZ",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow SysTime(immutable(TimeZone) tz)",
"comment" : "\n        Returns a $(D SysTime) with the same std time as this one, but with\n        given time zone as its time zone.\n      \n",
"line" : 2205}
,
{
"name" : "toUnixTime",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow long()",
"comment" : "\n        Returns a $(D time_t) which represents the same time as this\n        $(D SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D time_t) is 32 bits, rather than 64, and the result can't fit in a\n        32-bit value, then the closest value that can be held in 32 bits will be\n        used (so $(D time_t.max) if it goes over and $(D time_t.min) if it goes\n        under).\n      \n",
"line" : 2240}
,
{
"name" : "toTimeVal",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow timeval()",
"comment" : "\n        Returns a $(D timeval) which represents this $(D SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D time_t) is 32 bits, rather than 64, and the result can't fit in a\n        32-bit value, then the closest value that can be held in 32 bits will be\n        used for $(D tv_sec). (so $(D time_t.max) if it goes over and\n        $(D time_t.min) if it goes under).\n      \n",
"line" : 2273}
,
{
"name" : "toTM",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow tm()",
"comment" : "\n        Returns a $(D tm) which represents this $(D SysTime).\n      \n",
"line" : 2318}
,
{
"name" : "add(string units) if (units == \"years\" || units == \"months\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of years or months to this $(D SysTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year\/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 30, 33));\nst1.add!\"months\"(11);\nassert(st1 == SysTime(DateTime(2010, 12, 1, 12, 30, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 30, 33));\nst2.add!\"months\"(-11);\nassert(st2 == SysTime(DateTime(2009, 2, 1, 12, 30, 33)));\n\nauto st3 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst3.add!\"years\"(1);\nassert(st3 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st4 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst4.add!\"years\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n--------------------\n      \n",
"line" : 2449,
"members" : [
{
"name" : "add",
"kind" : "function",
"type" : "nothrow SysTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"line" : 2449}
]
}
,
{
"name" : "roll(string units) if (units == \"years\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of years or months to this $(D SysTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D SysTime) 12 months\n        gets the exact same $(D SysTime). However, the days can still be affected\n        due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst1.roll!\"months\"(1);\nassert(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst2.roll!\"months\"(-1);\nassert(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));\n\nauto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst3.roll!\"months\"(1);\nassert(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));\n\nauto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));\n\nauto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst5.roll!\"years\"(1);\nassert(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n--------------------\n      \n",
"line" : 3631,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"comment" : "\n        Adds the given number of years or months to this $(D SysTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D SysTime) 12 months\n        gets the exact same $(D SysTime). However, the days can still be affected\n        due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst1.roll!\"months\"(1);\nassert(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst2.roll!\"months\"(-1);\nassert(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));\n\nauto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst3.roll!\"months\"(1);\nassert(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));\n\nauto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));\n\nauto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst5.roll!\"years\"(1);\nassert(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n--------------------\n      \n",
"line" : 3631}
]
}
,
{
"name" : "roll(string units) if (units == \"months\")",
"kind" : "template",
"protection" : "public",
"line" : 3683,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"line" : 3683}
]
}
,
{
"name" : "roll(string units) if (units == \"days\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of units to this $(D SysTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D SysTime) one\n        year's worth of days gets the exact same $(D SysTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\"), $(D \"usecs\"), and\n        $(D \"hnsecs\").\n\n        Note that when rolling msecs, usecs or hnsecs, they all add up to a\n        second. So, for example, rolling 1000 msecs is exactly the same as\n        rolling 100,000 usecs.\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D SysTime).\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));\nst1.roll!\"days\"(1);\nassert(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));\nst1.roll!\"days\"(365);\nassert(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));\nst1.roll!\"days\"(-32);\nassert(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));\n\nauto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));\nst2.roll!\"hours\"(1);\nassert(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));\n\nauto st3 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst3.roll!\"seconds\"(-1);\nassert(st3 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));\n\nauto st4 = SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                   FracSec.from!\"usecs\"(2_400));\nst4.roll!\"usecs\"(-1_200_000);\nassert(st4 == SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                      FracSec.from!\"usecs\"(802_400)));\n--------------------\n      \n",
"line" : 4518,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "nothrow void(long value)",
"comment" : "\n        Adds the given number of units to this $(D SysTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D SysTime) one\n        year's worth of days gets the exact same $(D SysTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\"), $(D \"usecs\"), and\n        $(D \"hnsecs\").\n\n        Note that when rolling msecs, usecs or hnsecs, they all add up to a\n        second. So, for example, rolling 1000 msecs is exactly the same as\n        rolling 100,000 usecs.\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D SysTime).\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));\nst1.roll!\"days\"(1);\nassert(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));\nst1.roll!\"days\"(365);\nassert(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));\nst1.roll!\"days\"(-32);\nassert(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));\n\nauto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));\nst2.roll!\"hours\"(1);\nassert(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));\n\nauto st3 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst3.roll!\"seconds\"(-1);\nassert(st3 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));\n\nauto st4 = SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                   FracSec.from!\"usecs\"(2_400));\nst4.roll!\"usecs\"(-1_200_000);\nassert(st4 == SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                      FracSec.from!\"usecs\"(802_400)));\n--------------------\n      \n",
"line" : 4518}
]
}
,
{
"name" : "roll(string units) if (units == \"hours\" || units == \"minutes\" || units == \"seconds\")",
"kind" : "template",
"protection" : "public",
"line" : 4856,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "nothrow void(long value)",
"line" : 4856}
]
}
,
{
"name" : "roll(string units) if (units == \"msecs\" || units == \"usecs\" || units == \"hnsecs\")",
"kind" : "template",
"protection" : "public",
"line" : 5519,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "nothrow void(long value)",
"line" : 5519}
]
}
,
{
"name" : "opBinary(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
"line" : 5907,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow SysTime(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
"line" : 5907}
]
}
,
{
"name" : "opOpAssign(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime), as well as assigning the result to this $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
"line" : 6133,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "pure nothrow SysTime(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime), as well as assigning the result to this $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
"line" : 6133}
]
}
,
{
"name" : "opBinary(string op) if (op == \"-\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the difference between two $(D SysTime)s.\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD -) $(TD SysTime) $(TD -->) $(TD duration))\n        )\n      \n",
"line" : 6336,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow Duration(in SysTime rhs)",
"comment" : "\n        Gives the difference between two $(D SysTime)s.\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD -) $(TD SysTime) $(TD -->) $(TD duration))\n        )\n      \n",
"line" : 6336}
]
}
,
{
"name" : "diffMonths",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow int(const(SysTime) rhs)",
"comment" : "\n        Returns the difference between the two $(D SysTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(D SysTime)s. To get the difference in days or weeks,\n        subtract the $(D SysTime)s themselves and use the $(D Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(D Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(D SysTime) to subtract from this one.\n\n        Examples:\n--------------------\nassert(SysTime(Date(1999, 2, 1)).diffMonths(SysTime(Date(1999, 1, 31))) == 1);\nassert(SysTime(Date(1999, 1, 31)).diffMonths(SysTime(Date(1999, 2, 1))) == -1);\nassert(SysTime(Date(1999, 3, 1)).diffMonths(SysTime(Date(1999, 1, 1))) == 2);\nassert(SysTime(Date(1999, 1, 1)).diffMonths(SysTime(Date(1999, 3, 31))) == -2);\n--------------------\n      \n",
"line" : 6462}
,
{
"name" : "isLeapYear",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Whether this $(D SysTime) is in a leap year.\n     \n",
"line" : 6498}
,
{
"name" : "dayOfWeek",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property DayOfWeek()",
"comment" : "\n        Day of the week this $(D SysTime) is on.\n      \n",
"line" : 6520}
,
{
"name" : "dayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ushort()",
"comment" : "\n        Day of the year this $(D SysTime) is on.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 1, 1, 12, 22, 7)).dayOfYear == 1);\nassert(SysTime(DateTime(1999, 12, 31, 7, 2, 59)).dayOfYear == 365);\nassert(SysTime(DateTime(2000, 12, 31, 21, 20, 0)).dayOfYear == 366);\n--------------------\n      \n",
"line" : 6549}
,
{
"name" : "dayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "@property void(int day)",
"comment" : "\n        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(D SysTime) is on.\n      \n",
"line" : 6580}
,
{
"name" : "dayOfGregorianCal",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property int()",
"comment" : "\n        The Xth day of the Gregorian Calendar that this $(D SysTime) is on.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1, 1, 1, 0, 0, 0)).dayOfGregorianCal == 1);\nassert(SysTime(DateTime(1, 12, 31, 23, 59, 59)).dayOfGregorianCal == 365);\nassert(SysTime(DateTime(2, 1, 1, 2, 2, 2)).dayOfGregorianCal == 366);\n\nassert(SysTime(DateTime(0, 12, 31, 7, 7, 7)).dayOfGregorianCal == 0);\nassert(SysTime(DateTime(0, 1, 1, 19, 30, 0)).dayOfGregorianCal == -365);\nassert(SysTime(DateTime(-1, 12, 31, 4, 7, 0)).dayOfGregorianCal == -366);\n\nassert(SysTime(DateTime(2000, 1, 1, 9, 30, 20)).dayOfGregorianCal == 730_120);\nassert(SysTime(DateTime(2010, 12, 31, 15, 45, 50)).dayOfGregorianCal == 734_137);\n--------------------\n     \n",
"line" : 6625}
,
{
"name" : "dayOfGregorianCal",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @property void(int days)",
"comment" : "\n        The Xth day of the Gregorian Calendar that this $(D SysTime) is on.\n        Setting this property does not affect the time portion of $(D SysTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(D SysTime)\n                   to.\n\n        Examples:\n--------------------\nauto st = SysTime(DateTime(0, 0, 0, 12, 0, 0));\nst.dayOfGregorianCal = 1;\nassert(st == SysTime(DateTime(1, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 365;\nassert(st == SysTime(DateTime(1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 366;\nassert(st == SysTime(DateTime(2, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 0;\nassert(st == SysTime(DateTime(0, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = -365;\nassert(st == SysTime(DateTime(-0, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = -366;\nassert(st == SysTime(DateTime(-1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 730_120;\nassert(st == SysTime(DateTime(2000, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 734_137;\nassert(st == SysTime(DateTime(2010, 12, 31, 12, 0, 0)));\n--------------------\n     \n",
"line" : 7015}
,
{
"name" : "isoWeek",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        The ISO 8601 week of the year that this $(D SysTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org\/wiki\/ISO_week_date, ISO Week Date).\n      \n",
"line" : 7261}
,
{
"name" : "endOfMonth",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property SysTime()",
"comment" : "\n        $(D SysTime) for the last day in the month that this Date is in.\n        The time portion of endOfMonth is always 23:59:59.9999999.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).endOfMonth ==\n       SysTime(DateTime(1999, 1, 31, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0),\n               FracSec.from!\"msecs\"(24)).endOfMonth ==\n       SysTime(DateTime(1999, 2, 28, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27),\n               FracSec.from!\"usecs\"(5203)).endOfMonth ==\n       SysTime(DateTime(2000, 2, 29, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9),\n               FracSec.from!\"hnsecs\"(12345)).endOfMonth ==\n       SysTime(DateTime(2000, 6, 30, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n--------------------\n      \n",
"line" : 7306}
,
{
"name" : "daysInMonth",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        The last day in the month that this $(D SysTime) is in.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).daysInMonth == 31);\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0)).daysInMonth == 28);\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27)).daysInMonth == 29);\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9)).daysInMonth == 30);\n--------------------\n      \n",
"line" : 7390}
,
{
"name" : "endOfMonthDay",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property ubyte()",
"comment" : "\n        $(RED Deprecated. It will be removed in September 2012.\n              Please use daysInMonth instead.)\n      \n",
"line" : 7399}
,
{
"name" : "isAD",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Whether the current year is a date in A.D.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1, 1, 1, 12, 7, 0)).isAD);\nassert(SysTime(DateTime(2010, 12, 31, 0, 0, 0)).isAD);\nassert(!SysTime(DateTime(0, 12, 31, 23, 59, 59)).isAD);\nassert(!SysTime(DateTime(-2010, 1, 1, 2, 2, 2)).isAD);\n--------------------\n      \n",
"line" : 7463}
,
{
"name" : "julianDay",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property long()",
"comment" : "\n        The julian day for this $(D SysTime) at the given time. For example,\n        prior to noon, 1996-03-31 would be the julian day number 2_450_173, so\n        this function returns 2_450_173, while from noon onward, the julian\n        day number would be 2_450_174, so this function returns 2_450_174.\n      \n",
"line" : 7499}
,
{
"name" : "modJulianDay",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property long()",
"comment" : "\n        The modified julian day for any time on this date (since, the modified\n        julian day changes at midnight).\n      \n",
"line" : 7546}
,
{
"name" : "opCast(T) if (is(Unqual!(T) == Date))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Returns a $(D Date) equivalent to this $(D SysTime).\n      \n",
"line" : 7572,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "const nothrow Date()",
"comment" : "\n        Returns a $(D Date) equivalent to this $(D SysTime).\n      \n",
"line" : 7572}
]
}
,
{
"name" : "opCast(T) if (is(Unqual!(T) == DateTime))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Returns a $(D DateTime) equivalent to this $(D SysTime).\n      \n",
"line" : 7609,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "const nothrow DateTime()",
"comment" : "\n        Returns a $(D DateTime) equivalent to this $(D SysTime).\n      \n",
"line" : 7609}
]
}
,
{
"name" : "opCast(T) if (is(Unqual!(T) == TimeOfDay))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Returns a $(D TimeOfDay) equivalent to this $(D SysTime).\n      \n",
"line" : 7671,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "const nothrow TimeOfDay()",
"comment" : "\n        Returns a $(D TimeOfDay) equivalent to this $(D SysTime).\n      \n",
"line" : 7671}
]
}
,
{
"name" : "opCast(T) if (is(Unqual!(T) == SysTime))",
"kind" : "template",
"protection" : "public",
"line" : 7725,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "const pure nothrow SysTime()",
"line" : 7725}
]
}
,
{
"name" : "toISOString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D SysTime) to a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time\n        zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(D SysTime)'s time zone is $(D LocalTime), then TZ is empty.\n        If its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the\n        offset from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC\n        is $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               FracSec.from!\"msecs\"(24)).toISOString() ==\n       \"19981225T021500.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               FracSec.from!\"hnsecs\"(520_920)).toISOString() ==\n       \"-00040105T000002.052092\");\n--------------------\n      \n",
"line" : 7767}
,
{
"name" : "toISOExtString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D SysTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(D SysTime)'s time zone is $(D LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               FracSec.from!\"msecs\"(24)).toISOExtString() ==\n       \"1998-12-25T02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               FracSec.from!\"hnsecs\"(520_920)).toISOExtString() ==\n       \"-0004-01-05T00:00:02.052092\");\n--------------------\n      \n",
"line" : 7909}
,
{
"name" : "toSimpleString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D SysTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(D SysTime)'s time zone is $(D LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               FracSec.from!\"msecs\"(24)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               FracSec.from!\"hnsecs\"(520_920)).toSimpleString() ==\n        \"-0004-Jan-05 00:00:02.052092\");\n--------------------\n      \n",
"line" : 8049}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 8161}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D SysTime) to a string.\n      \n",
"line" : 8172}
,
{
"name" : "fromISOString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D SysTime) from a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time\n        zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOString) except that\n        trailing zeroes are permitted - including having fractional seconds with\n        all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(D LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(D SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(D SysTime) to be a particular time\n        zone, pass in that time zone and the $(D SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n            tz        = The time zone to convert the given time to (no\n                        conversion occurs if null).\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D SysTime) would not be valid.\n\n        Examples:\n--------------------\nassert(SysTime.fromISOString(\"20100704T070612\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOString(\"19981225T021500.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!\"msecs\"(7)));\nassert(SysTime.fromISOString(\"00000105T230959.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!\"usecs\"(20)));\nassert(SysTime.fromISOString(\"-00040105T000002\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOString(\" 20100704T070612 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOString(\"20100704T070612Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOString(\"20100704T070612-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), new SimpleTimeZone(-480)));\nassert(SysTime.fromISOString(\"20100704T070612+8:00\") ==\n       SysTime(DateTime(2010, 7, 3, 7, 6, 12), new SimpleTimeZone(480)));\n--------------------\n      \n",
"line" : 8242,
"members" : [
{
"name" : "fromISOString",
"kind" : "function",
"type" : "SysTime(in S isoString, immutable TimeZone tz = null)",
"line" : 8242}
]
}
,
{
"name" : "fromISOExtString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D SysTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOExtString)\n        except that trailing zeroes are permitted - including having fractional\n        seconds with all zeroes. However, a decimal point with nothing following\n        it is invalid.\n\n        If there is no time zone in the string, then $(D LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(D SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(D SysTime) to be a particular time\n        zone, pass in that time zone and the $(D SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoString = A string formatted in the ISO Extended format for dates\n                        and times.\n            tz        = The time zone to convert the given time to (no\n                        conversion occurs if null).\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D SysTime) would not be valid.\n\n        Examples:\n--------------------\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOExtString(\"1998-12-25T02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!\"msecs\"(7)));\nassert(SysTime.fromISOExtString(\"0000-01-05T23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!\"usecs\"(20)));\nassert(SysTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), new SimpleTimeZone(-480)));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), new SimpleTimeZone(480)));\n--------------------\n      \n",
"line" : 8438,
"members" : [
{
"name" : "fromISOExtString",
"kind" : "function",
"type" : "SysTime(in S isoExtString, immutable TimeZone tz = null)",
"line" : 8438}
]
}
,
{
"name" : "fromSimpleString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D SysTime) from a string with the format\n        YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toSimpleString) except\n        that trailing zeroes are permitted - including having fractional seconds\n        with all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(D LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(D SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(D SysTime) to be a particular time\n        zone, pass in that time zone and the $(D SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n\n        Params:\n            simpleString = A string formatted in the way that\n                           $(D toSimpleString) formats dates and times.\n            tz           = The time zone to convert the given time to (no\n                           conversion occurs if null).\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D SysTime) would not be valid.\n\n        Examples:\n--------------------\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromSimpleString(\"1998-Dec-25 02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!\"msecs\"(7)));\nassert(SysTime.fromSimpleString(\"0000-Jan-05 23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!\"usecs\"(20)));\nassert(SysTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), new SimpleTimeZone(-480)));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), new SimpleTimeZone(480)));\n--------------------\n      \n",
"line" : 8638,
"members" : [
{
"name" : "fromSimpleString",
"kind" : "function",
"type" : "SysTime(in S simpleString, immutable TimeZone tz = null)",
"line" : 8638}
]
}
,
{
"name" : "min",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property SysTime()",
"comment" : "\n        Returns the $(D SysTime) farthest in the past which is representable\n        by $(D SysTime).\n\n        The $(D SysTime) which is returned is in UTC.\n      \n",
"line" : 8798}
,
{
"name" : "max",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property SysTime()",
"comment" : "\n        Returns the $(D SysTime) farthest in the future which is representable\n        by $(D SysTime).\n\n        The $(D SysTime) which is returned is in UTC.\n      \n",
"line" : 8819}
,
{
"name" : "adjTime",
"kind" : "function",
"protection" : "private",
"type" : "const nothrow @property long()",
"line" : 8839}
,
{
"name" : "adjTime",
"kind" : "function",
"protection" : "private",
"type" : "nothrow @property void(long adjTime)",
"line" : 8848}
,
{
"name" : "_stdTime",
"kind" : "variable",
"protection" : "private",
"type" : "long",
"line" : 8863}
,
{
"name" : "_timezone",
"kind" : "variable",
"protection" : "private",
"type" : "Rebindable!(immutable(TimeZone))",
"line" : 8864}
,
{
"name" : "__xopEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(void*) p, const(void*) q)",
"line" : 578}
]
}
,
{
"name" : "Date",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Represents a date in the Proleptic Gregorian Calendar ranging from\n    32,768 B.C. to 32,767 A.D. Positive years are A.D. Non-positive years are\n    B.C.\n\n    Year, month, and day are kept separately internally so that $(D Date) is\n    optimized for calendar-based operations.\n\n    $(D Date) uses the Proleptic Gregorian Calendar, so it assumes the Gregorian\n    leap year calculations for its entire length. And, as per\n    $(WEB en.wikipedia.org\/wiki\/ISO_8601, ISO 8601), it also treats 1 B.C. as\n    year 0. So, 1 B.C. is 0, 2 B.C. is -1, etc. Use $(D yearBC) if want B.C. as\n    a positive integer with 1 B.C. being the year prior to 1 A.D.\n\n    Year 0 is a leap year.\n \n",
"line" : 8885,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "pure ref Date(int year, int month, int day)",
"comment" : "\n        Throws:\n            $(D DateTimeException) if the resulting $(D Date) would not be valid.\n\n        Params:\n            year  = Year of the Gregorian Calendar. Positive values are A.D.\n                    Non-positive values are B.C. with year 0 being the year\n                    prior to 1 A.D.\n            month = Month of the year.\n            day   = Day of the month.\n     \n",
"line" : 8899}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "pure nothrow ref Date(int day)",
"comment" : "\n        Params:\n            day = The Xth day of the Gregorian Calendar that the constructed\n                  $(D Date) will be for.\n     \n",
"line" : 8977}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow int(const(Date) rhs)",
"comment" : "\n        Compares this $(D Date) with the given $(D Date).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
"line" : 9118}
,
{
"name" : "year",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property short()",
"comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Examples:\n--------------------\nassert(Date(1999, 7, 6).year == 1999);\nassert(Date(2010, 10, 4).year == 2010);\nassert(Date(-7, 4, 5).year == -7);\n--------------------\n     \n",
"line" : 9236}
,
{
"name" : "year",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int year)",
"comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this Date's year to.\n\n        Throws:\n            $(D DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\n     \n",
"line" : 9272}
,
{
"name" : "yearBC",
"kind" : "function",
"protection" : "public",
"type" : "const pure @property ushort()",
"comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(D DateTimeException) if $(D isAD) is true.\n\n        Examples:\n--------------------\nassert(Date(0, 1, 1).yearBC == 1);\nassert(Date(-1, 1, 1).yearBC == 2);\nassert(Date(-100, 1, 1).yearBC == 101);\n--------------------\n     \n",
"line" : 9325}
,
{
"name" : "yearBC",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int year)",
"comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(D Date)'s year to.\n\n        Throws:\n            $(D DateTimeException) if a non-positive value is given.\n\n        Examples:\n--------------------\nauto date = Date(2010, 1, 1);\ndate.yearBC = 1;\nassert(date == Date(0, 1, 1));\n\ndate.yearBC = 10;\nassert(date == Date(-9, 1, 1));\n--------------------\n     \n",
"line" : 9375}
,
{
"name" : "month",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property Month()",
"comment" : "\n        Month of a Gregorian Year.\n\n        Examples:\n--------------------\nassert(Date(1999, 7, 6).month == 7);\nassert(Date(2010, 10, 4).month == 10);\nassert(Date(-7, 4, 5).month == 4);\n--------------------\n     \n",
"line" : 9421}
,
{
"name" : "month",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(Month month)",
"comment" : "\n        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(D Date)'s month to.\n\n        Throws:\n            $(D DateTimeException) if the given month is not a valid month or if\n            the current day would not be valid in the given month.\n     \n",
"line" : 9456}
,
{
"name" : "day",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Day of a Gregorian Month.\n\n        Examples:\n--------------------\nassert(Date(1999, 7, 6).day == 6);\nassert(Date(2010, 10, 4).day == 4);\nassert(Date(-7, 4, 5).day == 5);\n--------------------\n     \n",
"line" : 9500}
,
{
"name" : "day",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int day)",
"comment" : "\n        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(D Date)'s day to.\n\n        Throws:\n            $(D DateTimeException) if the given day is not a valid day of the\n            current month.\n     \n",
"line" : 9543}
,
{
"name" : "add(string units) if (units == \"years\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year\/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.add!\"months\"(11);\nassert(d1 == Date(2010, 12, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.add!\"months\"(-11);\nassert(d2 == Date(2009, 2, 1));\n\nauto d3 = Date(2000, 2, 29);\nd3.add!\"years\"(1);\nassert(d3 == Date(2001, 3, 1));\n\nauto d4 = Date(2000, 2, 29);\nd4.add!\"years\"(1, AllowDayOverflow.no);\nassert(d4 == Date(2001, 2, 28));\n--------------------\n      \n",
"line" : 9676,
"members" : [
{
"name" : "add",
"kind" : "function",
"type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year\/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.add!\"months\"(11);\nassert(d1 == Date(2010, 12, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.add!\"months\"(-11);\nassert(d2 == Date(2009, 2, 1));\n\nauto d3 = Date(2000, 2, 29);\nd3.add!\"years\"(1);\nassert(d3 == Date(2001, 3, 1));\n\nauto d4 = Date(2000, 2, 29);\nd4.add!\"years\"(1, AllowDayOverflow.no);\nassert(d4 == Date(2001, 2, 28));\n--------------------\n      \n",
"line" : 9676}
]
}
,
{
"name" : "add(string units) if (units == \"months\")",
"kind" : "template",
"protection" : "public",
"line" : 9913,
"members" : [
{
"name" : "add",
"kind" : "function",
"type" : "pure nothrow void(long months, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"line" : 9913}
]
}
,
{
"name" : "roll(string units) if (units == \"years\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D Date) 12 months gets\n        the exact same $(D Date). However, the days can still be affected due to\n        the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.roll!\"months\"(1);\nassert(d1 == Date(2010, 2, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.roll!\"months\"(-1);\nassert(d2 == Date(2010, 12, 1));\n\nauto d3 = Date(1999, 1, 29);\nd3.roll!\"months\"(1);\nassert(d3 == Date(1999, 3, 1));\n\nauto d4 = Date(1999, 1, 29);\nd4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(d4 == Date(1999, 2, 28));\n\nauto d5 = Date(2000, 2, 29);\nd5.roll!\"years\"(1);\nassert(d5 == Date(2001, 3, 1));\n\nauto d6 = Date(2000, 2, 29);\nd6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(d6 == Date(2001, 2, 28));\n--------------------\n      \n",
"line" : 10470,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D Date) 12 months gets\n        the exact same $(D Date). However, the days can still be affected due to\n        the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.roll!\"months\"(1);\nassert(d1 == Date(2010, 2, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.roll!\"months\"(-1);\nassert(d2 == Date(2010, 12, 1));\n\nauto d3 = Date(1999, 1, 29);\nd3.roll!\"months\"(1);\nassert(d3 == Date(1999, 3, 1));\n\nauto d4 = Date(1999, 1, 29);\nd4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(d4 == Date(1999, 2, 28));\n\nauto d5 = Date(2000, 2, 29);\nd5.roll!\"years\"(1);\nassert(d5 == Date(2001, 3, 1));\n\nauto d6 = Date(2000, 2, 29);\nd6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(d6 == Date(2001, 2, 28));\n--------------------\n      \n",
"line" : 10470}
]
}
,
{
"name" : "roll(string units) if (units == \"months\")",
"kind" : "template",
"protection" : "public",
"line" : 10520,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long months, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"line" : 10520}
]
}
,
{
"name" : "roll(string units) if (units == \"days\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of units to this $(D Date). A negative number will\n        subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D Date) one\n        year's worth of days gets the exact same $(D Date).\n\n        The only accepted units are $(D \"days\").\n\n        Params:\n            units = The units to add. Must be $(D \"days\").\n            value = The number of days to add to this $(D Date).\n\n        Examples:\n--------------------\nauto d = Date(2010, 1, 1);\nd.roll!\"days\"(1);\nassert(d == Date(2010, 1, 2));\nd.roll!\"days\"(365);\nassert(d == Date(2010, 1, 26));\nd.roll!\"days\"(-32);\nassert(d == Date(2010, 1, 25));\n--------------------\n      \n",
"line" : 11134,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long days)",
"comment" : "\n        Adds the given number of units to this $(D Date). A negative number will\n        subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D Date) one\n        year's worth of days gets the exact same $(D Date).\n\n        The only accepted units are $(D \"days\").\n\n        Params:\n            units = The units to add. Must be $(D \"days\").\n            value = The number of days to add to this $(D Date).\n\n        Examples:\n--------------------\nauto d = Date(2010, 1, 1);\nd.roll!\"days\"(1);\nassert(d == Date(2010, 1, 2));\nd.roll!\"days\"(365);\nassert(d == Date(2010, 1, 26));\nd.roll!\"days\"(-32);\nassert(d == Date(2010, 1, 25));\n--------------------\n      \n",
"line" : 11134}
]
}
,
{
"name" : "opBinary(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date).\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
"line" : 11379,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow Date(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date).\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
"line" : 11379}
]
}
,
{
"name" : "opOpAssign(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date), as well as assigning the result to this $(D Date).\n\n        The legal types of arithmetic for $(D Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
"line" : 11491,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "pure nothrow Date(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date), as well as assigning the result to this $(D Date).\n\n        The legal types of arithmetic for $(D Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
"line" : 11491}
]
}
,
{
"name" : "opBinary(string op) if (op == \"-\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the difference between two $(D Date)s.\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD -) $(TD Date) $(TD -->) $(TD duration))\n        )\n      \n",
"line" : 11579,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow Duration(in Date rhs)",
"comment" : "\n        Gives the difference between two $(D Date)s.\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD -) $(TD Date) $(TD -->) $(TD duration))\n        )\n      \n",
"line" : 11579}
]
}
,
{
"name" : "diffMonths",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow int(const(Date) rhs)",
"comment" : "\n        Returns the difference between the two $(D Date)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(D SysTime)s. To get the difference in days or weeks,\n        subtract the $(D SysTime)s themselves and use the $(D Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(D Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either $(D Date) is is irrelevant. It is the difference in the month\n        property combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(D Date) to subtract from this one.\n\n        Examples:\n--------------------\nassert(Date(1999, 2, 1).diffMonths(Date(1999, 1, 31)) == 1);\nassert(Date(1999, 1, 31).diffMonths(Date(1999, 2, 1)) == -1);\nassert(Date(1999, 3, 1).diffMonths(Date(1999, 1, 1)) == 2);\nassert(Date(1999, 1, 1).diffMonths(Date(1999, 3, 31)) == -2);\n--------------------\n      \n",
"line" : 11644}
,
{
"name" : "isLeapYear",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property bool()",
"comment" : "\n        Whether this $(D Date) is in a leap year.\n     \n",
"line" : 11882}
,
{
"name" : "dayOfWeek",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property DayOfWeek()",
"comment" : "\n        Day of the week this $(D Date) is on.\n      \n",
"line" : 11904}
,
{
"name" : "dayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ushort()",
"comment" : "\n        Day of the year this $(D Date) is on.\n\n        Examples:\n--------------------\nassert(Date(1999, 1, 1).dayOfYear == 1);\nassert(Date(1999, 12, 31).dayOfYear == 365);\nassert(Date(2000, 12, 31).dayOfYear == 366);\n--------------------\n      \n",
"line" : 11933}
,
{
"name" : "dayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int day)",
"comment" : "\n        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(D Date) is on.\n\n        Throws:\n            $(D DateTimeException) if the given day is an invalid day of the\n            year.\n      \n",
"line" : 11992}
,
{
"name" : "dayOfGregorianCal",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property int()",
"comment" : "\n        The Xth day of the Gregorian Calendar that this $(D Date) is on.\n\n        Examples:\n--------------------\nassert(Date(1, 1, 1).dayOfGregorianCal == 1);\nassert(Date(1, 12, 31).dayOfGregorianCal == 365);\nassert(Date(2, 1, 1).dayOfGregorianCal == 366);\n\nassert(Date(0, 12, 31).dayOfGregorianCal == 0);\nassert(Date(0, 1, 1).dayOfGregorianCal == -365);\nassert(Date(-1, 12, 31).dayOfGregorianCal == -366);\n\nassert(Date(2000, 1, 1).dayOfGregorianCal == 730_120);\nassert(Date(2010, 12, 31).dayOfGregorianCal == 734_137);\n--------------------\n     \n",
"line" : 12056}
,
{
"name" : "dayOfGregorianCal",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property void(int day)",
"comment" : "\n        The Xth day of the Gregorian Calendar that this $(D Date) is on.\n\n        Params:\n            day = The day of the Gregorian Calendar to set this $(D Date) to.\n\n        Examples:\n--------------------\nauto date = Date.init;\ndate.dayOfGregorianCal = 1;\nassert(date == Date(1, 1, 1));\n\ndate.dayOfGregorianCal = 365;\nassert(date == Date(1, 12, 31));\n\ndate.dayOfGregorianCal = 366;\nassert(date == Date(2, 1, 1));\n\ndate.dayOfGregorianCal = 0;\nassert(date == Date(0, 12, 31));\n\ndate.dayOfGregorianCal = -365;\nassert(date == Date(-0, 1, 1));\n\ndate.dayOfGregorianCal = -366;\nassert(date == Date(-1, 12, 31));\n\ndate.dayOfGregorianCal = 730_120;\nassert(date == Date(2000, 1, 1));\n\ndate.dayOfGregorianCal = 734_137;\nassert(date == Date(2010, 12, 31));\n--------------------\n     \n",
"line" : 12171}
,
{
"name" : "isoWeek",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        The ISO 8601 week of the year that this $(D Date) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org\/wiki\/ISO_week_date, ISO Week Date)\n      \n",
"line" : 12226}
,
{
"name" : "endOfMonth",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property Date()",
"comment" : "\n        $(D Date) for the last day in the month that this $(D Date) is in.\n\n        Examples:\n--------------------\nassert(Date(1999, 1, 6).endOfMonth == Date(1999, 1, 31));\nassert(Date(1999, 2, 7).endOfMonth == Date(1999, 2, 28));\nassert(Date(2000, 2, 7).endOfMonth == Date(1999, 2, 29));\nassert(Date(2000, 6, 4).endOfMonth == Date(1999, 6, 30));\n--------------------\n      \n",
"line" : 12336}
,
{
"name" : "daysInMonth",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        The last day in the month that this $(D Date) is in.\n\n        Examples:\n--------------------\nassert(Date(1999, 1, 6).daysInMonth == 31);\nassert(Date(1999, 2, 7).daysInMonth == 28);\nassert(Date(2000, 2, 7).daysInMonth == 29);\nassert(Date(2000, 6, 4).daysInMonth == 30);\n--------------------\n      \n",
"line" : 12403}
,
{
"name" : "endOfMonthDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        $(RED Deprecated. It will be removed in September 2012.\n              Please use daysInMonth instead.)\n      \n",
"line" : 12412}
,
{
"name" : "isAD",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property bool()",
"comment" : "\n        Whether the current year is a date in A.D.\n\n        Examples:\n--------------------\nassert(Date(1, 1, 1).isAD);\nassert(Date(2010, 12, 31).isAD);\nassert(!Date(0, 12, 31).isAD);\nassert(!Date(-2010, 1, 1).isAD);\n--------------------\n      \n",
"line" : 12476}
,
{
"name" : "julianDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property long()",
"comment" : "\n        The julian day for this $(D Date) at noon (since the julian day changes\n        at noon).\n      \n",
"line" : 12509}
,
{
"name" : "modJulianDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property long()",
"comment" : "\n        The modified julian day for any time on this date (since, the modified\n        julian day changes at midnight).\n      \n",
"line" : 12539}
,
{
"name" : "toISOString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D Date) to a string with the format YYYYMMDD.\n\n        Examples:\n--------------------\nassert(Date(2010, 7, 4).toISOString() == \"20100704\");\nassert(Date(1998, 12, 25).toISOString() == \"19981225\");\nassert(Date(0, 1, 5).toISOString() == \"00000105\");\nassert(Date(-4, 1, 5).toISOString() == \"-00040105\");\n--------------------\n      \n",
"line" : 12570}
,
{
"name" : "toISOExtString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D Date) to a string with the format YYYY-MM-DD.\n\n        Examples:\n--------------------\nassert(Date(2010, 7, 4).toISOExtString() == \"2010-07-04\");\nassert(Date(1998, 12, 25).toISOExtString() == \"1998-12-25\");\nassert(Date(0, 1, 5).toISOExtString() == \"0000-01-05\");\nassert(Date(-4, 1, 5).toISOExtString() == \"-0004-01-05\");\n--------------------\n      \n",
"line" : 12633}
,
{
"name" : "toSimpleString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D Date) to a string with the format YYYY-Mon-DD.\n\n        Examples:\n--------------------\nassert(Date(2010, 7, 4).toSimpleString() == \"2010-Jul-04\");\nassert(Date(1998, 12, 25).toSimpleString() == \"1998-Dec-25\");\nassert(Date(0, 1, 5).toSimpleString() == \"0000-Jan-05\");\nassert(Date(-4, 1, 5).toSimpleString() == \"-0004-Jan-05\");\n--------------------\n      \n",
"line" : 12696}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 12757}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D Date) to a string.\n      \n",
"line" : 12768}
,
{
"name" : "fromISOString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D Date) from a string with the format YYYYMMDD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D Date) would not be valid.\n\n        Examples:\n--------------------\nassert(Date.fromISOString(\"20100704\") == Date(2010, 7, 4));\nassert(Date.fromISOString(\"19981225\") == Date(1998, 12, 25));\nassert(Date.fromISOString(\"00000105\") == Date(0, 1, 5));\nassert(Date.fromISOString(\"-00040105\") == Date(-4, 1, 5));\nassert(Date.fromISOString(\" 20100704 \") == Date(2010, 7, 4));\n--------------------\n      \n",
"line" : 12807,
"members" : [
{
"name" : "fromISOString",
"kind" : "function",
"type" : "Date(in S isoString)",
"line" : 12807}
]
}
,
{
"name" : "fromISOExtString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D Date) from a string with the format YYYY-MM-DD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for\n                           dates.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(D Date) would not be valid.\n\n        Examples:\n--------------------\nassert(Date.fromISOExtString(\"2010-07-04\") == Date(2010, 7, 4));\nassert(Date.fromISOExtString(\"1998-12-25\") == Date(1998, 12, 25));\nassert(Date.fromISOExtString(\"0000-01-05\") == Date(0, 1, 5));\nassert(Date.fromISOExtString(\"-0004-01-05\") == Date(-4, 1, 5));\nassert(Date.fromISOExtString(\" 2010-07-04 \") == Date(2010, 7, 4));\n--------------------\n      \n",
"line" : 12932,
"members" : [
{
"name" : "fromISOExtString",
"kind" : "function",
"type" : "Date(in S isoExtString)",
"line" : 12932}
]
}
,
{
"name" : "fromSimpleString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D Date) from a string with the format YYYY-Mon-DD.\n        Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the correct\n            format or if the resulting $(D Date) would not be valid.\n\n        Examples:\n--------------------\nassert(Date.fromSimpleString(\"2010-Jul-04\") == Date(2010, 7, 4));\nassert(Date.fromSimpleString(\"1998-Dec-25\") == Date(1998, 12, 25));\nassert(Date.fromSimpleString(\"0000-Jan-05\") == Date(0, 1, 5));\nassert(Date.fromSimpleString(\"-0004-Jan-05\") == Date(-4, 1, 5));\nassert(Date.fromSimpleString(\" 2010-Jul-04 \") == Date(2010, 7, 4));\n--------------------\n      \n",
"line" : 13062,
"members" : [
{
"name" : "fromSimpleString",
"kind" : "function",
"type" : "Date(in S simpleString)",
"line" : 13062}
]
}
,
{
"name" : "min",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property Date()",
"comment" : "\n        Returns the $(D Date) farthest in the past which is representable by\n        $(D Date).\n      \n",
"line" : 13179}
,
{
"name" : "max",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property Date()",
"comment" : "\n        Returns the $(D Date) farthest in the future which is representable by\n        $(D Date).\n      \n",
"line" : 13203}
,
{
"name" : "_valid",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow bool(int year, int month, int day)",
"line" : 13233}
,
{
"name" : "addDays",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow ref Date(long days)",
"line" : 13257}
,
{
"name" : "_year",
"kind" : "variable",
"protection" : "private",
"type" : "short",
"line" : 13445}
,
{
"name" : "_month",
"kind" : "variable",
"protection" : "private",
"type" : "Month",
"line" : 13446}
,
{
"name" : "_day",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 13447}
]
}
,
{
"name" : "TimeOfDay",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Represents a time of day with hours, minutes, and seconds. It uses 24 hour\n    time.\n",
"line" : 13457,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "pure ref TimeOfDay(int hour, int minute, int second = 0)",
"comment" : "\n        Params:\n            hour   = Hour of the day [0 - 24$(RPAREN).\n            minute = Minute of the hour [0 - 60$(RPAREN).\n            second = Second of the minute [0 - 60$(RPAREN).\n\n        Throws:\n            $(D DateTimeException) if the resulting $(D TimeOfDay) would be not\n            be valid.\n     \n",
"line" : 13470}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow int(const(TimeOfDay) rhs)",
"comment" : "\n        Compares this $(D TimeOfDay) with the given $(D TimeOfDay).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
"line" : 13525}
,
{
"name" : "hour",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Hours passed midnight.\n     \n",
"line" : 13588}
,
{
"name" : "hour",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int hour)",
"comment" : "\n        Hours passed midnight.\n\n        Params:\n            hour = The hour of the day to set this $(D TimeOfDay)'s hour to.\n\n        Throws:\n            $(D DateTimeException) if the given hour would result in an invalid\n            $(D TimeOfDay).\n     \n",
"line" : 13618}
,
{
"name" : "minute",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Minutes passed the hour.\n     \n",
"line" : 13645}
,
{
"name" : "minute",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int minute)",
"comment" : "\n        Minutes passed the hour.\n\n        Params:\n            minute = The minute to set this $(D TimeOfDay)'s minute to.\n\n        Throws:\n            $(D DateTimeException) if the given minute would result in an\n            invalid $(D TimeOfDay).\n     \n",
"line" : 13675}
,
{
"name" : "second",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Seconds passed the minute.\n     \n",
"line" : 13702}
,
{
"name" : "second",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int second)",
"comment" : "\n        Seconds passed the minute.\n\n        Params:\n            second = The second to set this $(D TimeOfDay)'s second to.\n\n        Throws:\n            $(D DateTimeException) if the given second would result in an\n            invalid $(D TimeOfDay).\n     \n",
"line" : 13732}
,
{
"name" : "roll(string units) if (units == \"hours\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of units to this $(D TimeOfDay). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D TimeOfDay)\n        one hours's worth of minutes gets the exact same\n        $(D TimeOfDay).\n\n        Accepted units are $(D \"hours\"), $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this\n                    $(D TimeOfDay).\n\n        Examples:\n--------------------\nauto tod1 = TimeOfDay(7, 12, 0);\ntod1.roll!\"hours\"(1);\nassert(tod1 == TimeOfDay(8, 12, 0));\n\nauto tod2 = TimeOfDay(7, 12, 0);\ntod2.roll!\"hours\"(-1);\nassert(tod2 == TimeOfDay(6, 12, 0));\n\nauto tod3 = TimeOfDay(23, 59, 0);\ntod3.roll!\"minutes\"(1);\nassert(tod3 == TimeOfDay(23, 0, 0));\n\nauto tod4 = TimeOfDay(0, 0, 0);\ntod4.roll!\"minutes\"(-1);\nassert(tod4 == TimeOfDay(0, 59, 0));\n\nauto tod5 = TimeOfDay(23, 59, 59);\ntod5.roll!\"seconds\"(1);\nassert(tod5 == TimeOfDay(23, 59, 0));\n\nauto tod6 = TimeOfDay(0, 0, 0);\ntod6.roll!\"seconds\"(-1);\nassert(tod6 == TimeOfDay(0, 0, 59));\n--------------------\n      \n",
"line" : 13799,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long value)",
"comment" : "\n        Adds the given number of units to this $(D TimeOfDay). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D TimeOfDay)\n        one hours's worth of minutes gets the exact same\n        $(D TimeOfDay).\n\n        Accepted units are $(D \"hours\"), $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this\n                    $(D TimeOfDay).\n\n        Examples:\n--------------------\nauto tod1 = TimeOfDay(7, 12, 0);\ntod1.roll!\"hours\"(1);\nassert(tod1 == TimeOfDay(8, 12, 0));\n\nauto tod2 = TimeOfDay(7, 12, 0);\ntod2.roll!\"hours\"(-1);\nassert(tod2 == TimeOfDay(6, 12, 0));\n\nauto tod3 = TimeOfDay(23, 59, 0);\ntod3.roll!\"minutes\"(1);\nassert(tod3 == TimeOfDay(23, 0, 0));\n\nauto tod4 = TimeOfDay(0, 0, 0);\ntod4.roll!\"minutes\"(-1);\nassert(tod4 == TimeOfDay(0, 59, 0));\n\nauto tod5 = TimeOfDay(23, 59, 59);\ntod5.roll!\"seconds\"(1);\nassert(tod5 == TimeOfDay(23, 59, 0));\n\nauto tod6 = TimeOfDay(0, 0, 0);\ntod6.roll!\"seconds\"(-1);\nassert(tod6 == TimeOfDay(0, 0, 59));\n--------------------\n      \n",
"line" : 13799}
]
}
,
{
"name" : "roll(string units) if (units == \"minutes\" || units == \"seconds\")",
"kind" : "template",
"protection" : "public",
"line" : 13849,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long value)",
"line" : 13849}
]
}
,
{
"name" : "opBinary(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
"line" : 14078,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow TimeOfDay(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
"line" : 14078}
]
}
,
{
"name" : "opOpAssign(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay), as well as assigning the result to this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
"line" : 14184,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "pure nothrow TimeOfDay(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay), as well as assigning the result to this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
"line" : 14184}
]
}
,
{
"name" : "opBinary(string op) if (op == \"-\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the difference between two $(D TimeOfDay)s.\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD -) $(TD TimeOfDay) $(TD -->) $(TD duration))\n        )\n\n        Params:\n            rhs = The $(D TimeOfDay) to subtract from this one.\n      \n",
"line" : 14264,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow Duration(in TimeOfDay rhs)",
"comment" : "\n        Gives the difference between two $(D TimeOfDay)s.\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD -) $(TD TimeOfDay) $(TD -->) $(TD duration))\n        )\n\n        Params:\n            rhs = The $(D TimeOfDay) to subtract from this one.\n      \n",
"line" : 14264}
]
}
,
{
"name" : "toISOString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D TimeOfDay) to a string with the format HHMMSS.\n\n        Examples:\n--------------------\nassert(TimeOfDay(0, 0, 0).toISOString() == \"000000\");\nassert(TimeOfDay(12, 30, 33).toISOString() == \"123033\");\n--------------------\n      \n",
"line" : 14314}
,
{
"name" : "toISOExtString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D TimeOfDay) to a string with the format HH:MM:SS.\n\n        Examples:\n--------------------\nassert(TimeOfDay(0, 0, 0).toISOExtString() == \"000000\");\nassert(TimeOfDay(12, 30, 33).toISOExtString() == \"123033\");\n--------------------\n      \n",
"line" : 14349}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 14381}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this TimeOfDay to a string.\n      \n",
"line" : 14393}
,
{
"name" : "fromISOString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D TimeOfDay) from a string with the format HHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D TimeOfDay) would not be valid.\n\n        Examples:\n--------------------\nassert(TimeOfDay.fromISOString(\"000000\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOString(\"123033\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOString(\" 123033 \") == TimeOfDay(12, 30, 33));\n--------------------\n      \n",
"line" : 14433,
"members" : [
{
"name" : "fromISOString",
"kind" : "function",
"type" : "TimeOfDay(in S isoString)",
"line" : 14433}
]
}
,
{
"name" : "fromISOExtString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D TimeOfDay) from a string with the format HH:MM:SS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO Extended format for times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(D TimeOfDay) would not be\n            valid.\n\n        Examples:\n--------------------\nassert(TimeOfDay.fromISOExtString(\"00:00:00\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOExtString(\"12:30:33\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOExtString(\" 12:30:33 \") == TimeOfDay(12, 30, 33));\n--------------------\n      \n",
"line" : 14542,
"members" : [
{
"name" : "fromISOExtString",
"kind" : "function",
"type" : "TimeOfDay(in S isoExtString)",
"line" : 14542}
]
}
,
{
"name" : "min",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property TimeOfDay()",
"comment" : "\n        Returns midnight.\n      \n",
"line" : 14647}
,
{
"name" : "max",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property TimeOfDay()",
"comment" : "\n        Returns one second short of midnight.\n      \n",
"line" : 14667}
,
{
"name" : "addSeconds",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow ref TimeOfDay(long seconds)",
"line" : 14702}
,
{
"name" : "_valid",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow bool(int hour, int minute, int second)",
"line" : 14807}
,
{
"name" : "_hour",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 14825}
,
{
"name" : "_minute",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 14826}
,
{
"name" : "_second",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 14827}
,
{
"name" : "maxHour",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 14829}
,
{
"name" : "maxMinute",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 14830}
,
{
"name" : "maxSecond",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 14831}
]
}
,
{
"name" : "DateTime",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Combines the $(D Date) and $(D TimeOfDay) structs to give an object\n   which holds both the date and the time. It is optimized for calendar-based\n   operations and has no concept of time zone. For an object which is\n   optimized for time operations based on the system time, use\n   $(D SysTime). $(D SysTime) has a concept of time zone and has much higher\n   precision (hnsecs). $(D DateTime) is intended primarily for calendar-based\n   uses rather than precise time operations.\n  \n",
"line" : 14845,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "pure nothrow ref DateTime(const(Date) date, const(TimeOfDay) tod = TimeOfDay(cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u))",
"comment" : "\n        Params:\n            date = The date portion of $(D DateTime).\n            tod  = The time portion of $(D DateTime).\n      \n",
"line" : 14853}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "pure ref DateTime(int year, int month, int day, int hour = 0, int minute = 0, int second = 0)",
"comment" : "\n        Params:\n            year   = The year portion of the date.\n            month  = The month portion of the date.\n            day    = The day portion of the date.\n            hour   = The hour portion of the time;\n            minute = The minute portion of the time;\n            second = The second portion of the time;\n      \n",
"line" : 14893}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow int(const(DateTime) rhs)",
"comment" : "\n        Compares this $(D DateTime) with the given $(D DateTime.).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
"line" : 14929}
,
{
"name" : "date",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property Date()",
"comment" : "\n        The date portion of $(D DateTime).\n      \n",
"line" : 15142}
,
{
"name" : "date",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property void(const(Date) date)",
"comment" : "\n        The date portion of $(D DateTime).\n\n        Params:\n            date = The Date to set this $(D DateTime)'s date portion to.\n      \n",
"line" : 15175}
,
{
"name" : "timeOfDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property TimeOfDay()",
"comment" : "\n        The time portion of $(D DateTime).\n      \n",
"line" : 15200}
,
{
"name" : "timeOfDay",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property void(const(TimeOfDay) tod)",
"comment" : "\n        The time portion of $(D DateTime).\n\n        Params:\n            tod = The $(D TimeOfDay) to set this $(D DateTime)'s time portion\n                  to.\n      \n",
"line" : 15234}
,
{
"name" : "year",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property short()",
"comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n     \n",
"line" : 15260}
,
{
"name" : "year",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int year)",
"comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(D DateTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if the new year is not a leap year and if the\n            resulting date would be on February 29th.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).year == 1999);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).year == 2010);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).year == -7);\n--------------------\n     \n",
"line" : 15299}
,
{
"name" : "yearBC",
"kind" : "function",
"protection" : "public",
"type" : "const pure @property short()",
"comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(D DateTimeException) if $(D isAD) is true.\n\n        Examples:\n--------------------\nassert(DateTime(Date(0, 1, 1), TimeOfDay(12, 30, 33)).yearBC == 1);\nassert(DateTime(Date(-1, 1, 1), TimeOfDay(10, 7, 2)).yearBC == 2);\nassert(DateTime(Date(-100, 1, 1), TimeOfDay(4, 59, 0)).yearBC == 101);\n--------------------\n     \n",
"line" : 15344}
,
{
"name" : "yearBC",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int year)",
"comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(D DateTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if a non-positive value is given.\n\n        Examples:\n--------------------\nauto dt = DateTime(Date(2010, 1, 1), TimeOfDay(7, 30, 0));\ndt.yearBC = 1;\nassert(dt == DateTime(Date(0, 1, 1), TimeOfDay(7, 30, 0)));\n\ndt.yearBC = 10;\nassert(dt == DateTime(Date(-9, 1, 1), TimeOfDay(7, 30, 0)));\n--------------------\n     \n",
"line" : 15389}
,
{
"name" : "month",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property Month()",
"comment" : "\n        Month of a Gregorian Year.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).month == 7);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).month == 10);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).month == 4);\n--------------------\n     \n",
"line" : 15432}
,
{
"name" : "month",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(Month month)",
"comment" : "\n        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(D DateTime)'s month to.\n\n        Throws:\n            $(D DateTimeException) if the given month is not a valid month.\n     \n",
"line" : 15467}
,
{
"name" : "day",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Day of a Gregorian Month.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).day == 6);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).day == 4);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).day == 5);\n--------------------\n     \n",
"line" : 15507}
,
{
"name" : "day",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int day)",
"comment" : "\n        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(D DateTime)'s day to.\n\n        Throws:\n            $(D DateTimeException) if the given day is not a valid day of the\n            current month.\n     \n",
"line" : 15554}
,
{
"name" : "hour",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Hours passed midnight.\n     \n",
"line" : 15649}
,
{
"name" : "hour",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int hour)",
"comment" : "\n        Hours passed midnight.\n\n        Params:\n            hour = The hour of the day to set this $(D DateTime)'s hour to.\n\n        Throws:\n            $(D DateTimeException) if the given hour would result in an invalid\n            $(D DateTime).\n     \n",
"line" : 15679}
,
{
"name" : "minute",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Minutes passed the hour.\n     \n",
"line" : 15705}
,
{
"name" : "minute",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int minute)",
"comment" : "\n        Minutes passed the hour.\n\n        Params:\n            minute = The minute to set this $(D DateTime)'s minute to.\n\n        Throws:\n            $(D DateTimeException) if the given minute would result in an\n            invalid $(D DateTime).\n     \n",
"line" : 15735}
,
{
"name" : "second",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        Seconds passed the minute.\n     \n",
"line" : 15761}
,
{
"name" : "second",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int second)",
"comment" : "\n        Seconds passed the minute.\n\n        Params:\n            second = The second to set this $(D DateTime)'s second to.\n\n        Throws:\n            $(D DateTimeException) if the given seconds would result in an\n            invalid $(D DateTime).\n     \n",
"line" : 15791}
,
{
"name" : "add(string units) if (units == \"years\" || units == \"months\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year\/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 30, 33);\ndt1.add!\"months\"(11);\nassert(dt1 == DateTime(2010, 12, 1, 12, 30, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 30, 33);\ndt2.add!\"months\"(-11);\nassert(dt2 == DateTime(2009, 2, 1, 12, 30, 33));\n\nauto dt3 = DateTime(2000, 2, 29, 12, 30, 33);\ndt3.add!\"years\"(1);\nassert(dt3 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt4 = DateTime(2000, 2, 29, 12, 30, 33);\ndt4.add!\"years\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
"line" : 15852,
"members" : [
{
"name" : "add",
"kind" : "function",
"type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year\/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 30, 33);\ndt1.add!\"months\"(11);\nassert(dt1 == DateTime(2010, 12, 1, 12, 30, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 30, 33);\ndt2.add!\"months\"(-11);\nassert(dt2 == DateTime(2009, 2, 1, 12, 30, 33));\n\nauto dt3 = DateTime(2000, 2, 29, 12, 30, 33);\ndt3.add!\"years\"(1);\nassert(dt3 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt4 = DateTime(2000, 2, 29, 12, 30, 33);\ndt4.add!\"years\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
"line" : 15852}
]
}
,
{
"name" : "roll(string units) if (units == \"years\" || units == \"months\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D DateTime) 12 months\n        gets the exact same $(D DateTime). However, the days can still be\n        affected due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 33, 33);\ndt1.roll!\"months\"(1);\nassert(dt1 == DateTime(2010, 2, 1, 12, 33, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 33, 33);\ndt2.roll!\"months\"(-1);\nassert(dt2 == DateTime(2010, 12, 1, 12, 33, 33));\n\nauto dt3 = DateTime(1999, 1, 29, 12, 33, 33);\ndt3.roll!\"months\"(1);\nassert(dt3 == DateTime(1999, 3, 1, 12, 33, 33));\n\nauto dt4 = DateTime(1999, 1, 29, 12, 33, 33);\ndt4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(1999, 2, 28, 12, 33, 33));\n\nauto dt5 = DateTime(2000, 2, 29, 12, 30, 33);\ndt5.roll!\"years\"(1);\nassert(dt5 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt6 = DateTime(2000, 2, 29, 12, 30, 33);\ndt6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(dt6 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
"line" : 15942,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
"comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D DateTime) 12 months\n        gets the exact same $(D DateTime). However, the days can still be\n        affected due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 33, 33);\ndt1.roll!\"months\"(1);\nassert(dt1 == DateTime(2010, 2, 1, 12, 33, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 33, 33);\ndt2.roll!\"months\"(-1);\nassert(dt2 == DateTime(2010, 12, 1, 12, 33, 33));\n\nauto dt3 = DateTime(1999, 1, 29, 12, 33, 33);\ndt3.roll!\"months\"(1);\nassert(dt3 == DateTime(1999, 3, 1, 12, 33, 33));\n\nauto dt4 = DateTime(1999, 1, 29, 12, 33, 33);\ndt4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(1999, 2, 28, 12, 33, 33));\n\nauto dt5 = DateTime(2000, 2, 29, 12, 30, 33);\ndt5.roll!\"years\"(1);\nassert(dt5 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt6 = DateTime(2000, 2, 29, 12, 30, 33);\ndt6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(dt6 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
"line" : 15942}
]
}
,
{
"name" : "roll(string units) if (units == \"days\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Adds the given number of units to this $(D DateTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D DateTime) one\n        year's worth of days gets the exact same $(D DateTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D DateTime).\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 11, 23, 12);\ndt1.roll!\"days\"(1);\nassert(dt1 == DateTime(2010, 1, 2, 11, 23, 12));\ndt1.roll!\"days\"(365);\nassert(dt1 == DateTime(2010, 1, 26, 11, 23, 12));\ndt1.roll!\"days\"(-32);\nassert(dt1 == DateTime(2010, 1, 25, 11, 23, 12));\n\nauto dt2 = DateTime(2010, 7, 4, 12, 0, 0);\ndt2.roll!\"hours\"(1);\nassert(dt2 == DateTime(2010, 7, 4, 13, 0, 0));\n\nauto dt3 = DateTime(2010, 1, 1, 0, 0, 0);\ndt3.roll!\"seconds\"(-1);\nassert(dt3 == DateTime(2010, 1, 1, 0, 0, 59));\n--------------------\n      \n",
"line" : 16030,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long days)",
"comment" : "\n        Adds the given number of units to this $(D DateTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D DateTime) one\n        year's worth of days gets the exact same $(D DateTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D DateTime).\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 11, 23, 12);\ndt1.roll!\"days\"(1);\nassert(dt1 == DateTime(2010, 1, 2, 11, 23, 12));\ndt1.roll!\"days\"(365);\nassert(dt1 == DateTime(2010, 1, 26, 11, 23, 12));\ndt1.roll!\"days\"(-32);\nassert(dt1 == DateTime(2010, 1, 25, 11, 23, 12));\n\nauto dt2 = DateTime(2010, 7, 4, 12, 0, 0);\ndt2.roll!\"hours\"(1);\nassert(dt2 == DateTime(2010, 7, 4, 13, 0, 0));\n\nauto dt3 = DateTime(2010, 1, 1, 0, 0, 0);\ndt3.roll!\"seconds\"(-1);\nassert(dt3 == DateTime(2010, 1, 1, 0, 0, 59));\n--------------------\n      \n",
"line" : 16030}
]
}
,
{
"name" : "roll(string units) if (units == \"hours\" || units == \"minutes\" || units == \"seconds\")",
"kind" : "template",
"protection" : "public",
"line" : 16072,
"members" : [
{
"name" : "roll",
"kind" : "function",
"type" : "pure nothrow void(long value)",
"line" : 16072}
]
}
,
{
"name" : "opBinary(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
"line" : 16603,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow DateTime(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
"line" : 16603}
]
}
,
{
"name" : "opOpAssign(string op,D) if ((op == \"+\" || op == \"-\") && (is(Unqual!(D) == Duration) || is(Unqual!(D) == TickDuration)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime), as well as assigning the result to this $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
"line" : 16713,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "pure nothrow DateTime(in D duration)",
"comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime), as well as assigning the result to this $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
"line" : 16713}
]
}
,
{
"name" : "opBinary(string op) if (op == \"-\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Gives the difference between two $(D DateTime)s.\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD -) $(TD DateTime) $(TD -->) $(TD duration))\n        )\n      \n",
"line" : 16799,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "const pure nothrow Duration(in DateTime rhs)",
"comment" : "\n        Gives the difference between two $(D DateTime)s.\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD -) $(TD DateTime) $(TD -->) $(TD duration))\n        )\n      \n",
"line" : 16799}
]
}
,
{
"name" : "diffMonths",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow int(const(DateTime) rhs)",
"comment" : "\n        Returns the difference between the two $(D DateTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(D SysTime)s. To get the difference in days or weeks,\n        subtract the $(D SysTime)s themselves and use the $(D Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(D Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(D DateTime) to subtract from this one.\n\n        Examples:\n--------------------\nassert(DateTime(1999, 2, 1, 12, 2, 3).diffMonths(\n            DateTime(1999, 1, 31, 23, 59, 59)) == 1);\n\nassert(DateTime(1999, 1, 31, 0, 0, 0).diffMonths(\n            DateTime(1999, 2, 1, 12, 3, 42)) == -1);\n\nassert(DateTime(1999, 3, 1, 5, 30, 0).diffMonths(\n            DateTime(1999, 1, 1, 2, 4, 7)) == 2);\n\nassert(DateTime(1999, 1, 1, 7, 2, 4).diffMonths(\n            DateTime(1999, 3, 31, 0, 30, 58)) == -2);\n--------------------\n      \n",
"line" : 16914}
,
{
"name" : "isLeapYear",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property bool()",
"comment" : "\n        Whether this $(D DateTime) is in a leap year.\n     \n",
"line" : 16950}
,
{
"name" : "dayOfWeek",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property DayOfWeek()",
"comment" : "\n        Day of the week this $(D DateTime) is on.\n      \n",
"line" : 16972}
,
{
"name" : "dayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ushort()",
"comment" : "\n        Day of the year this $(D DateTime) is on.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 1, 1), TimeOfDay(12, 22, 7)).dayOfYear == 1);\nassert(DateTime(Date(1999, 12, 31), TimeOfDay(7, 2, 59)).dayOfYear == 365);\nassert(DateTime(Date(2000, 12, 31), TimeOfDay(21, 20, 0)).dayOfYear == 366);\n--------------------\n      \n",
"line" : 17001}
,
{
"name" : "dayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "pure @property void(int day)",
"comment" : "\n        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(D DateTime) is on.\n      \n",
"line" : 17032}
,
{
"name" : "dayOfGregorianCal",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property int()",
"comment" : "\n        The Xth day of the Gregorian Calendar that this $(D DateTime) is on.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1, 1, 1), TimeOfDay(0, 0, 0)).dayOfGregorianCal ==\n       1);\nassert(DateTime(Date(1, 12, 31), TimeOfDay(23, 59, 59)).dayOfGregorianCal ==\n       365);\nassert(DateTime(Date(2, 1, 1), TimeOfDay(2, 2, 2)).dayOfGregorianCal ==\n       366);\n\nassert(DateTime(Date(0, 12, 31), TimeOfDay(7, 7, 7)).dayOfGregorianCal ==\n       0);\nassert(DateTime(Date(0, 1, 1), TimeOfDay(19, 30, 0)).dayOfGregorianCal ==\n       -365);\nassert(DateTime(Date(-1, 12, 31), TimeOfDay(4, 7, 0)).dayOfGregorianCal ==\n       -366);\n\nassert(DateTime(Date(2000, 1, 1), TimeOfDay(9, 30, 20)).dayOfGregorianCal ==\n       730_120);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(15, 45, 50)).dayOfGregorianCal ==\n       734_137);\n--------------------\n     \n",
"line" : 17076}
,
{
"name" : "dayOfGregorianCal",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property void(int days)",
"comment" : "\n        The Xth day of the Gregorian Calendar that this $(D DateTime) is on.\n        Setting this property does not affect the time portion of\n        $(D DateTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(D DateTime)\n                   to.\n\n        Examples:\n--------------------\nauto dt = DateTime(Date.init, TimeOfDay(12, 0, 0));\ndt.dayOfGregorianCal = 1;\nassert(dt == DateTime(Date(1, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 365;\nassert(dt == DateTime(Date(1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 366;\nassert(dt == DateTime(Date(2, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 0;\nassert(dt == DateTime(Date(0, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -365;\nassert(dt == DateTime(Date(-0, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -366;\nassert(dt == DateTime(Date(-1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 730_120;\nassert(dt == DateTime(Date(2000, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 734_137;\nassert(dt == DateTime(Date(2010, 12, 31), TimeOfDay(12, 0, 0)));\n--------------------\n     \n",
"line" : 17142}
,
{
"name" : "isoWeek",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        The ISO 8601 week of the year that this $(D DateTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org\/wiki\/ISO_week_date, ISO Week Date)\n      \n",
"line" : 17191}
,
{
"name" : "endOfMonth",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property DateTime()",
"comment" : "\n        $(D DateTime) for the last day in the month that this $(D DateTime) is\n        in. The time portion of endOfMonth is always 23:59:59.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).endOfMonth ==\n       DateTime(Date(1999, 1, 31), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).endOfMonth ==\n       DateTime(Date(1999, 2, 28), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).endOfMonth ==\n       DateTime(Date(2000, 2, 29), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).endOfMonth ==\n       DateTime(Date(2000, 6, 30), TimeOfDay(23, 59, 59)));\n--------------------\n      \n",
"line" : 17229}
,
{
"name" : "daysInMonth",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        The last day in the month that this $(D DateTime) is in.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).daysInMonth == 31);\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).daysInMonth == 28);\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).daysInMonth == 29);\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).daysInMonth == 30);\n--------------------\n      \n",
"line" : 17296}
,
{
"name" : "endOfMonthDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property ubyte()",
"comment" : "\n        $(RED Deprecated. It will be removed in September 2012.\n              Please use daysInMonth instead.)\n      \n",
"line" : 17305}
,
{
"name" : "isAD",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property bool()",
"comment" : "\n        Whether the current year is a date in A.D.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1, 1, 1), TimeOfDay(12, 7, 0)).isAD);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(0, 0, 0)).isAD);\nassert(!DateTime(Date(0, 12, 31), TimeOfDay(23, 59, 59)).isAD);\nassert(!DateTime(Date(-2010, 1, 1), TimeOfDay(2, 2, 2)).isAD);\n--------------------\n      \n",
"line" : 17339}
,
{
"name" : "julianDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property long()",
"comment" : "\n        The julian day for this $(D DateTime) at the given time. For example,\n        prior to noon, 1996-03-31 would be the julian day number 2_450_173, so\n        this function returns 2_450_173, while from noon onward, the julian\n        day number would be 2_450_174, so this function returns 2_450_174.\n      \n",
"line" : 17368}
,
{
"name" : "modJulianDay",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property long()",
"comment" : "\n        The modified julian day for any time on this date (since, the modified\n        julian day changes at midnight).\n      \n",
"line" : 17416}
,
{
"name" : "toISOString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D DateTime) to a string with the format YYYYMMDDTHHMMSS.\n\n        Examples:\n--------------------\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOString() ==\n       \"19981225T021500\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOString() ==\n       \"-00040105T000002\");\n--------------------\n      \n",
"line" : 17457}
,
{
"name" : "toISOExtString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D DateTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.\n\n        Examples:\n--------------------\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOExtString() ==\n       \"1998-12-25T02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOExtString() ==\n       \"-0004-01-05T00:00:02\");\n--------------------\n      \n",
"line" : 17517}
,
{
"name" : "toSimpleString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D DateTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.\n\n        Examples:\n--------------------\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(DateTime(Dte(-4, 1, 5), TimeOfDay(0, 0, 2)).toSimpleString() ==\n       \"-0004-Jan-05 00:00:02\");\n--------------------\n      \n",
"line" : 17576}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 17623}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow string()",
"comment" : "\n        Converts this $(D DateTime) to a string.\n      \n",
"line" : 17634}
,
{
"name" : "fromISOString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D DateTime) from a string with the format YYYYMMDDTHHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D DateTime) would not be valid.\n\n        Examples:\n--------------------\nassert(DateTime.fromISOString(\"20100704T070612\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOString(\"19981225T021500\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOString(\"00000105T230959\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOString(\"-00040105T000002\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOString(\" 20100704T070612 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n--------------------\n      \n",
"line" : 17683,
"members" : [
{
"name" : "fromISOString",
"kind" : "function",
"type" : "DateTime(in S isoString)",
"line" : 17683}
]
}
,
{
"name" : "fromISOExtString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D DateTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO Extended format for dates\n                        and times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(D DateTime) would not be\n            valid.\n\n        Examples:\n--------------------\nassert(DateTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOExtString(\"1998-12-25T02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOExtString(\"0000-01-05T23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n--------------------\n      \n",
"line" : 17775,
"members" : [
{
"name" : "fromISOExtString",
"kind" : "function",
"type" : "DateTime(in S isoExtString)",
"line" : 17775}
]
}
,
{
"name" : "fromSimpleString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Creates a $(D DateTime) from a string with the format\n        YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates and times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the correct\n            format or if the resulting $(D DateTime) would not be valid.\n\n        Examples:\n--------------------\nassert(DateTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\nassert(DateTime.fromSimpleString(\"1998-Dec-25 02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\nassert(DateTime.fromSimpleString(\"0000-Jan-05 23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\nassert(DateTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\nassert(DateTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n--------------------\n      \n",
"line" : 17861,
"members" : [
{
"name" : "fromSimpleString",
"kind" : "function",
"type" : "DateTime(in S simpleString)",
"line" : 17861}
]
}
,
{
"name" : "min",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property DateTime()",
"comment" : "\n        Returns the $(D DateTime) farthest in the past which is representable by\n        $(D DateTime).\n      \n",
"line" : 17933}
,
{
"name" : "max",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property DateTime()",
"comment" : "\n        Returns the $(D DateTime) farthest in the future which is representable\n        by $(D DateTime).\n      \n",
"line" : 17963}
,
{
"name" : "addSeconds",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow ref DateTime(long seconds)",
"line" : 18003}
,
{
"name" : "_date",
"kind" : "variable",
"protection" : "private",
"type" : "Date",
"line" : 18205}
,
{
"name" : "_tod",
"kind" : "variable",
"protection" : "private",
"type" : "TimeOfDay",
"line" : 18206}
]
}
,
{
"name" : "Interval(TP)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Represents an interval of time.\n\n    An $(D Interval) has a starting point and an end point. The interval of time\n    is therefore the time starting at the starting point up to, but not\n    including, the end point. e.g.\n\n    $(BOOKTABLE,\n    $(TR $(TD [January 5th, 2010 - March 10th, 2010$(RPAREN)))\n    $(TR $(TD [05:00:30 - 12:00:00$(RPAREN)))\n    $(TR $(TD [1982-01-04T08:59:00 - 2010-07-04T12:00:00$(RPAREN)))\n    )\n\n    A range can be obtained from an $(D Interval), allowing iteration over\n    that interval, with the exact time points which are iterated over depending\n    on the function which generates the range.\n  \n",
"line" : 18232,
"members" : [
{
"name" : "Interval",
"kind" : "struct",
"protection" : "public",
"line" : 18232,
"members" : [
{
"name" : "__ctor(U) if (is(Unqual!(TP) == Unqual!(U)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Params:\n            begin = The time point which begins the interval.\n            end   = The time point which ends (but is not included in) the\n                    interval.\n\n        Throws:\n            $(D DateTimeException) if $(D_PARAM end) is before $(D_PARAM begin).\n\n        Examples:\n--------------------\nInterval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n--------------------\n      \n",
"line" : 18249,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "pure (in TP begin, in U end)",
"line" : 18249}
]
}
,
{
"name" : "__ctor(D) if (__traits(compiles,begin + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Params:\n            begin    = The time point which begins the interval.\n            duration = The duration from the starting point to the end point.\n\n        Throws:\n            $(D DateTimeException) if the resulting $(D end) is before\n            $(D begin).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), dur!\"years\"(3)) ==\n       Interval!Date(Date(1996, 1, 2), Date(1999, 1, 2)));\n--------------------\n      \n",
"line" : 18275,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "pure (in TP begin, in D duration)",
"line" : 18275}
]
}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow Interval(ref const Interval rhs)",
"comment" : "\n        Params:\n            rhs = The $(D Interval) to assign to this one.\n      \n",
"line" : 18290}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow Interval(Interval rhs)",
"comment" : "\n        Params:\n            rhs = The $(D Interval) to assign to this one.\n      \n",
"line" : 18303}
,
{
"name" : "begin",
"kind" : "function",
"type" : "const pure nothrow TP()",
"comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).begin ==\n       Date(1996, 1, 2));\n--------------------\n      \n",
"line" : 18321}
,
{
"name" : "begin",
"kind" : "function",
"type" : "pure void(TP timePoint)",
"comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n\n        Throws:\n            $(D DateTimeException) if the resulting interval would be invalid.\n      \n",
"line" : 18336}
,
{
"name" : "end",
"kind" : "function",
"type" : "const pure nothrow TP()",
"comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).end ==\n       Date(2012, 3, 1));\n--------------------\n      \n",
"line" : 18354}
,
{
"name" : "end",
"kind" : "function",
"type" : "pure void(TP timePoint)",
"comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n\n        Throws:\n            $(D DateTimeException) if the resulting interval would be invalid.\n      \n",
"line" : 18369}
,
{
"name" : "length",
"kind" : "function",
"type" : "const pure nothrow typeof(end - begin)()",
"comment" : "\n        Returns the duration between $(D begin) and $(D end).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).length ==\n       dur!\"days\"(5903));\n--------------------\n      \n",
"line" : 18387}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const pure nothrow bool()",
"comment" : "\n        Whether the interval's length is 0, that is, whether $(D begin == end).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).empty);\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).empty);\n--------------------\n      \n",
"line" : 18402}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure bool(in TP timePoint)",
"comment" : "\n        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(1994, 12, 24)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2000, 1, 5)));\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 18428}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure bool(in Interval interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n      \n",
"line" : 18457}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval going to positive infinity can never be contained in a finite\n        interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
"line" : 18487}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval beginning at negative infinity can never be contained in a\n        finite interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
"line" : 18514}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure bool(in TP timePoint)",
"comment" : "\n        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2000, 1, 5)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 18544}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure bool(in Interval interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));\n--------------------\n      \n",
"line" : 18574}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n      \n",
"line" : 18602}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be before an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
"line" : 18629}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure bool(in TP timePoint)",
"comment" : "\n        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2000, 1, 5)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 18659}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure bool(in Interval interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
"line" : 18689}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be after an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
"line" : 18717}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n      \n",
"line" : 18741}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure bool(in Interval interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
"line" : 18770}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 18797}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n      \n",
"line" : 18823}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval(in Interval interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n      \n",
"line" : 18852}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval(in PosInfInterval!(TP) interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 18884}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval(in NegInfInterval!(TP) interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 18913}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure bool(in Interval interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 18943}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 18971}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n      \n",
"line" : 18998}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const Interval(in Interval interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n      \n",
"line" : 19027}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const PosInfInterval!(TP)(in PosInfInterval!(TP) interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(2012, 3, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
"line" : 19060}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const NegInfInterval!(TP)(in NegInfInterval!(TP) interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are not\n            adjacent or if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1996, 1, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
"line" : 19090}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure Interval(in Interval interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n      \n",
"line" : 19121}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure PosInfInterval!(TP)(in PosInfInterval!(TP) interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(2050, 1, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
"line" : 19155}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure NegInfInterval!(TP)(in NegInfInterval!(TP) interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1602, 5, 21))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
"line" : 19185}
,
{
"name" : "shift(D) if (__traits(compiles,begin + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Shifts the interval forward or backwards in time by the given duration\n        (a positive duration shifts the interval forward; a negative duration\n        shifts it backward). Effectively, it does $(D begin += duration) and\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));\n--------------------\n      \n",
"line" : 19218,
"members" : [
{
"name" : "shift",
"kind" : "function",
"type" : "pure void(D duration)",
"comment" : "\n        Shifts the interval forward or backwards in time by the given duration\n        (a positive duration shifts the interval forward; a negative duration\n        shifts it backward). Effectively, it does $(D begin += duration) and\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));\n--------------------\n      \n",
"line" : 19218}
]
}
,
{
"name" : "expand(D) if (__traits(compiles,begin + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Expands the interval forwards and\/or backwards in time. Effectively,\n        it does $(D begin -= duration) and\/or $(D end += duration). Whether\n        it expands forwards and\/or backwards in time is determined by\n        $(D_PARAM dir).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n\ninterval1.expand(2);\nassert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));\n\ninterval2.expand(-2);\nassert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));\n--------------------\n      \n",
"line" : 19315,
"members" : [
{
"name" : "expand",
"kind" : "function",
"type" : "pure void(D duration, Direction dir = Direction.both)",
"comment" : "\n        Expands the interval forwards and\/or backwards in time. Effectively,\n        it does $(D begin -= duration) and\/or $(D end += duration). Whether\n        it expands forwards and\/or backwards in time is determined by\n        $(D_PARAM dir).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n\ninterval1.expand(2);\nassert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));\n\ninterval2.expand(-2);\nassert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));\n--------------------\n      \n",
"line" : 19315}
]
}
,
{
"name" : "fwdRange",
"kind" : "function",
"type" : "const IntervalRange!(TP,Direction.fwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
"comment" : "\n        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(D DateTimeException) will be\n        thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or beyond the $(D end)\n        of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant if when creating a custom delegate.\n\n        Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) \/\/For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n \/\/An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n      \n",
"line" : 19526}
,
{
"name" : "bwdRange",
"kind" : "function",
"type" : "const IntervalRange!(TP,Direction.bwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
"comment" : "\n        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(D DateTimeException) will\n        be thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or less than the\n        $(D begin) of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) \/\/For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\n\/\/An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\nassert(range.front == Date(2010, 9, 9));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n      \n",
"line" : 19619}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"line" : 19638}
,
{
"name" : "toString",
"kind" : "function",
"type" : "const nothrow string()",
"comment" : "\n        Converts this interval to a string.\n      \n",
"line" : 19650}
,
{
"name" : "_toStringImpl",
"kind" : "function",
"type" : "const nothrow string()",
"line" : 19662}
,
{
"name" : "_enforceNotEmpty",
"kind" : "function",
"type" : "const pure void(size_t line = __LINE__)",
"line" : 19675}
,
{
"name" : "_valid",
"kind" : "function",
"type" : "pure nothrow bool(in TP begin, in TP end)",
"line" : 19689}
,
{
"name" : "_begin",
"kind" : "variable",
"type" : "TP",
"line" : 19701}
,
{
"name" : "_end",
"kind" : "variable",
"type" : "TP",
"line" : 19702}
]
}
]
}
,
{
"name" : "PosInfInterval(TP)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Represents an interval of time which has positive infinity as its end point.\n\n    Any ranges which iterate over a $(D PosInfInterval) are infinite. So, the\n    main purpose of using $(D PosInfInterval) is to create an infinite range\n    which starts at a fixed point in time and goes to positive infinity.\n  \n",
"line" : 21200,
"members" : [
{
"name" : "PosInfInterval",
"kind" : "struct",
"protection" : "public",
"line" : 21200,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow (in TP begin)",
"comment" : "\n        Params:\n            begin = The time point which begins the interval.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n      \n",
"line" : 21212}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow PosInfInterval(ref const PosInfInterval rhs)",
"comment" : "\n        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n      \n",
"line" : 21222}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow PosInfInterval(PosInfInterval rhs)",
"comment" : "\n        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n      \n",
"line" : 21234}
,
{
"name" : "begin",
"kind" : "function",
"type" : "const pure nothrow TP()",
"comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).begin == Date(1996, 1, 2));\n--------------------\n      \n",
"line" : 21250}
,
{
"name" : "begin",
"kind" : "function",
"type" : "pure nothrow void(TP timePoint)",
"comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n      \n",
"line" : 21262}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const pure nothrow bool()",
"comment" : "\n        Whether the interval's length is 0. Always returns false.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n      \n",
"line" : 21276}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure nothrow bool(TP timePoint)",
"comment" : "\n        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(1994, 12, 24)));\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(2000, 1, 5)));\n--------------------\n      \n",
"line" : 21294}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n      \n",
"line" : 21321}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1995, 7, 2))));\n--------------------\n      \n",
"line" : 21344}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval going to positive infinity\n        can never contain an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
"line" : 21365}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure nothrow bool(in TP timePoint)",
"comment" : "\n        Whether this interval is before the given time point.\n\n        Always returns false because an interval going to positive infinity\n        can never be before any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(2000, 1, 5)));\n--------------------\n      \n",
"line" : 21387}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval going to positive infinity can never be before any other\n        interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n      \n",
"line" : 21416}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(1992, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n      \n",
"line" : 21443}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
"line" : 21465}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure nothrow bool(in TP timePoint)",
"comment" : "\n        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(2000, 1, 5)));\n--------------------\n      \n",
"line" : 21484}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
"line" : 21512}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval going to positive infinity can\n        never be after another interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
"line" : 21539}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n      \n",
"line" : 21561}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
"line" : 21588}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals going to positive infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
"line" : 21615}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n      \n",
"line" : 21637}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval!(TP)(in Interval!(TP) interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n      \n",
"line" : 21664}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const pure nothrow PosInfInterval(in PosInfInterval interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1999, 1 , 12)));\n--------------------\n      \n",
"line" : 21691}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval!(TP)(in NegInfInterval!(TP) interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));\n--------------------\n      \n",
"line" : 21717}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1999, 1, 12)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n      \n",
"line" : 21744}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals going to positive infinity\n        can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n      \n",
"line" : 21771}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n      \n",
"line" : 21793}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const PosInfInterval(in Interval!(TP) interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
"line" : 21826}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const pure nothrow PosInfInterval(in PosInfInterval interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
"line" : 21858}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure PosInfInterval(in Interval!(TP) interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==\n       PosInfInterval!Date(Date(500, 8, 9)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
"line" : 21897}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure nothrow PosInfInterval(in PosInfInterval interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
"line" : 21931}
,
{
"name" : "shift(D) if (__traits(compiles,begin + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Shifts the $(D begin) of this interval forward or backwards in time by\n        the given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D begin += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));\n--------------------\n      \n",
"line" : 21958,
"members" : [
{
"name" : "shift",
"kind" : "function",
"type" : "pure nothrow void(D duration)",
"comment" : "\n        Shifts the $(D begin) of this interval forward or backwards in time by\n        the given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D begin += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));\n--------------------\n      \n",
"line" : 21958}
]
}
,
{
"name" : "expand(D) if (__traits(compiles,begin + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Expands the interval backwards in time. Effectively, it does\n        $(D begin -= duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));\n--------------------\n      \n",
"line" : 22032,
"members" : [
{
"name" : "expand",
"kind" : "function",
"type" : "pure nothrow void(D duration)",
"comment" : "\n        Expands the interval backwards in time. Effectively, it does\n        $(D begin -= duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));\n--------------------\n      \n",
"line" : 22032}
]
}
,
{
"name" : "fwdRange",
"kind" : "function",
"type" : "const PosInfIntervalRange!(TP)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
"comment" : "\n        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(D DateTimeException) will be\n        thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(2010, 9, 1));\nauto func = (in Date date) \/\/For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n\/\/An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n      \n",
"line" : 22161}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"line" : 22178}
,
{
"name" : "toString",
"kind" : "function",
"type" : "const nothrow string()",
"comment" : "\n        Converts this interval to a string.\n      \n",
"line" : 22190}
,
{
"name" : "_toStringImpl",
"kind" : "function",
"type" : "const nothrow string()",
"line" : 22201}
,
{
"name" : "_begin",
"kind" : "variable",
"type" : "TP",
"line" : 22210}
]
}
]
}
,
{
"name" : "NegInfInterval(TP)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Represents an interval of time which has negative infinity as its starting\n    point.\n\n    Any ranges which iterate over a $(D NegInfInterval) are infinite. So, the\n    main purpose of using $(D NegInfInterval) is to create an infinite range\n    which starts at negative infinity and goes to a fixed end point.\n    Iterate over it in reverse.\n  \n",
"line" : 23448,
"members" : [
{
"name" : "NegInfInterval",
"kind" : "struct",
"protection" : "public",
"line" : 23448,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow (in TP end)",
"comment" : "\n        Params:\n            begin = The time point which begins the interval.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n      \n",
"line" : 23460}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow NegInfInterval(ref const NegInfInterval rhs)",
"comment" : "\n        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n      \n",
"line" : 23470}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow NegInfInterval(NegInfInterval rhs)",
"comment" : "\n        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n      \n",
"line" : 23482}
,
{
"name" : "end",
"kind" : "function",
"type" : "const pure nothrow TP()",
"comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).end == Date(2012, 3, 1));\n--------------------\n      \n",
"line" : 23498}
,
{
"name" : "end",
"kind" : "function",
"type" : "pure nothrow void(TP timePoint)",
"comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n      \n",
"line" : 23510}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const pure nothrow bool()",
"comment" : "\n        Whether the interval's length is 0. Always returns false.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n      \n",
"line" : 23524}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure nothrow bool(TP timePoint)",
"comment" : "\n        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(1994, 12, 24)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 23543}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n      \n",
"line" : 23570}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval beginning at negative\n        infinity can never contain an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
"line" : 23593}
,
{
"name" : "contains",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval interval)",
"comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
"line" : 23614}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure nothrow bool(in TP timePoint)",
"comment" : "\n        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is\n                        before it.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2000, 1, 5)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 23634}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
"line" : 23662}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 23686}
,
{
"name" : "isBefore",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval interval)",
"comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval beginning at negative\n        infinity can never be before another interval beginning at negative\n        infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
"line" : 23712}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure nothrow bool(in TP timePoint)",
"comment" : "\n        Whether this interval is after the given time point.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 23735}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether this interval is after the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval beginning at negative infinity can never be after any other\n        interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
"line" : 23767}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 23794}
,
{
"name" : "isAfter",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval interval)",
"comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
"line" : 23819}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
"line" : 23846}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 23870}
,
{
"name" : "intersects",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals beginning at negative infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
"line" : 23894}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval!(TP)(in Interval!(TP) interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 23921}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const Interval!(TP)(in PosInfInterval!(TP) interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n      \n",
"line" : 23951}
,
{
"name" : "intersection",
"kind" : "function",
"type" : "const nothrow NegInfInterval(in NegInfInterval interval)",
"comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(1999, 7 , 6)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n--------------------\n      \n",
"line" : 23976}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure bool(in Interval!(TP) interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
"line" : 24007}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 24031}
,
{
"name" : "isAdjacent",
"kind" : "function",
"type" : "const pure nothrow bool(in NegInfInterval interval)",
"comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals beginning at negative\n        infinity can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
"line" : 24056}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const NegInfInterval(in Interval!(TP) interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n--------------------\n      \n",
"line" : 24089}
,
{
"name" : "merge",
"kind" : "function",
"type" : "const pure nothrow NegInfInterval(in NegInfInterval interval)",
"comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
"line" : 24121}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure NegInfInterval(in Interval!(TP) interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n\nassert(NegInfInterval!Date(Date(1600, 1, 7)).span(\n            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==\n       NegInfInterval!Date(Date(2017, 7 , 1)));\n--------------------\n      \n",
"line" : 24160}
,
{
"name" : "span",
"kind" : "function",
"type" : "const pure nothrow NegInfInterval(in NegInfInterval interval)",
"comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
"line" : 24194}
,
{
"name" : "shift(D) if (__traits(compiles,end + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Shifts the $(D end) of this interval forward or backwards in time by the\n        given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 4, 5));\nauto interval2 = NegInfInterval!Date(Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));\n--------------------\n      \n",
"line" : 24221,
"members" : [
{
"name" : "shift",
"kind" : "function",
"type" : "pure nothrow void(D duration)",
"comment" : "\n        Shifts the $(D end) of this interval forward or backwards in time by the\n        given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 4, 5));\nauto interval2 = NegInfInterval!Date(Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));\n--------------------\n      \n",
"line" : 24221}
]
}
,
{
"name" : "expand(D) if (__traits(compiles,end + duration))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Expands the interval forwards in time. Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 3, 1));\nauto interval2 = NegInfInterval!Date(Date(2012, 3, 1));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));\n--------------------\n      \n",
"line" : 24294,
"members" : [
{
"name" : "expand",
"kind" : "function",
"type" : "pure nothrow void(D duration)",
"comment" : "\n        Expands the interval forwards in time. Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 3, 1));\nauto interval2 = NegInfInterval!Date(Date(2012, 3, 1));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));\n--------------------\n      \n",
"line" : 24294}
]
}
,
{
"name" : "bwdRange",
"kind" : "function",
"type" : "const NegInfIntervalRange!(TP)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
"comment" : "\n        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(D DateTimeException) will\n        be thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = NegInfInterval!Date(Date(2010, 9, 9));\nauto func = (in Date date) \/\/For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\nassert(range.front == Date(2010, 9, 9)); \/\/An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n      \n",
"line" : 24422}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"line" : 24439}
,
{
"name" : "toString",
"kind" : "function",
"type" : "const nothrow string()",
"comment" : "\n        Converts this interval to a string.\n      \n",
"line" : 24451}
,
{
"name" : "_toStringImpl",
"kind" : "function",
"type" : "const nothrow string()",
"line" : 24462}
,
{
"name" : "_end",
"kind" : "variable",
"type" : "TP",
"line" : 24471}
]
}
]
}
,
{
"name" : "everyDayOfWeek(TP,Direction dir = Direction.fwd) if (isTimePoint!(TP) && (dir == Direction.fwd || dir == Direction.bwd) && __traits(hasMember,TP,\"dayOfWeek\") && !__traits(isStaticFunction,TP.dayOfWeek) && is(ReturnType!(TP.dayOfWeek) == DayOfWeek) && functionAttributes!(TP.dayOfWeek) & FunctionAttribute.property && functionAttributes!(TP.dayOfWeek) & FunctionAttribute.nothrow_)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given\n    $(D DayOfWeek) in a range.\n\n    Using this delegate allows iteration over successive time points which\n    are all the same day of the week. e.g. passing $(D DayOfWeek.mon) to\n    $(D everyDayOfWeek) would result in a delegate which could be used to\n    iterate over all of the Mondays in a range.\n\n    Params:\n        dir       = The direction to iterate in. If passing the return value to\n                    $(D fwdRange), use $(D Direction.fwd). If passing it to\n                    $(D bwdRange), use $(D Direction.bwd).\n        dayOfWeek = The week that each time point in the range will be.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDayOfWeek!Date(DayOfWeek.mon);\nauto range = interval.fwdRange(func);\n\n\/\/A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 13));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 20));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
"line" : 25747,
"members" : [
{
"name" : "everyDayOfWeek",
"kind" : "function",
"type" : "nothrow TP delegate(in TP)(DayOfWeek dayOfWeek)",
"line" : 25747}
]
}
,
{
"name" : "everyMonth(TP,Direction dir = Direction.fwd) if (isTimePoint!(TP) && (dir == Direction.fwd || dir == Direction.bwd) && __traits(hasMember,TP,\"month\") && !__traits(isStaticFunction,TP.month) && is(ReturnType!(TP.month) == Month) && functionAttributes!(TP.month) & FunctionAttribute.property && functionAttributes!(TP.month) & FunctionAttribute.nothrow_)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given month\n    which would be reached by adding months to the given time point.\n\n    So, using this delegate allows iteration over successive time points\n    which are in the same month but different years. For example,\n    iterate over each successive December 25th in an interval by starting with a\n    date which had the 25th as its day and passed $(D Month.dec) to\n    $(D everyMonth) to create the delegate.\n\n    Since it wouldn't really make sense to be iterating over a specific month\n    and end up with some of the time points in the succeeding month or two years\n    after the previous time point, $(D AllowDayOverflow.no) is always used when\n    calculating the next time point.\n\n    Params:\n        dir   = The direction to iterate in. If passing the return value to\n                $(D fwdRange), use $(D Direction.fwd). If passing it to\n                $(D bwdRange), use $(D Direction.bwd).\n        month = The month that each time point in the range will be in.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));\nauto func = everyMonth!(Date)(Month.feb);\nauto range = interval.fwdRange(func);\n\n\/\/Using PopFirst.yes would have made this Date(2010, 2, 29).\nassert(range.front == Date(2000, 1, 30));\n\nrange.popFront();\nassert(range.front == Date(2000, 2, 29));\n\nrange.popFront();\nassert(range.front == Date(2001, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2002, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2003, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2004, 2, 28));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
"line" : 25881,
"members" : [
{
"name" : "everyMonth",
"kind" : "function",
"type" : "TP delegate(in TP)(int month)",
"line" : 25881}
]
}
,
{
"name" : "everyDuration(TP,Direction dir = Direction.fwd,D) if (isTimePoint!(TP) && __traits(compiles,TP.init + duration) && (dir == Direction.fwd || dir == Direction.bwd))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    duration later.\n\n    Using this delegate allows iteration over successive time points which\n    are apart by the given duration e.g. passing $(D dur!\"days\"(3)) to\n    $(D everyDuration) would result in a delegate which could be used to iterate\n    over a range of days which are each 3 days apart.\n\n    Params:\n        dir      = The direction to iterate in. If passing the return value to\n                   $(D fwdRange), use $(D Direction.fwd). If passing it to\n                   $(D bwdRange), use $(D Direction.bwd).\n        duration = The duration which separates each successive time point in\n                   the range.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDuration!Date(dur!\"days\"(8));\nauto range = interval.fwdRange(func);\n\n\/\/Using PopFirst.yes would have made this Date(2010, 9, 10).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 10));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 18));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 26));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
"line" : 26028,
"members" : [
{
"name" : "everyDuration",
"kind" : "function",
"type" : "nothrow TP delegate(in TP)(D duration)",
"line" : 26028}
]
}
,
{
"name" : "everyDuration(TP,Direction dir = Direction.fwd,D) if (isTimePoint!(TP) && __traits(compiles,TP.init + duration) && __traits(compiles,TP.init.add!(\"years\")(years)) && __traits(compiles,TP.init.add!(\"months\")(months)) && (dir == Direction.fwd || dir == Direction.bwd))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    number of years, month, and duration later.\n\n    The difference between this version of $(D everyDuration) and the version\n    which just takes a $(D Duration) is that this one also takes the number of\n    years and months (along with an $(D AllowDayOverflow) to indicate whether\n    adding years and months should allow the days to overflow).\n\n    Note that if iterating forward, $(D add!\"years\"()) is called on the given\n    time point, then $(D add!\"months\"()), and finally the duration is added\n    to it. However, if iterating backwards, the duration is added first, then\n    $(D add!\"months\"()) is called, and finally $(D add!\"years\"()) is called.\n    That way, going backwards generates close to the same time points that\n    iterating forward does, but since adding years and months is not entirely\n    reversible (due to possible day overflow, regardless of whether\n    $(D AllowDayOverflow.yes) or $(D AllowDayOverflow.no) is used), it can't be\n    guaranteed that iterating backwards will give the same time points as\n    iterating forward would have (even assuming that the end of the range is a\n    time point which would be returned by the delegate when iterating forward\n    from $(D begin)).\n\n    Params:\n        dir           = The direction to iterate in. If passing the return\n                        value to $(D fwdRange), use $(D Direction.fwd). If\n                        passing it to $(D bwdRange), use $(D Direction.bwd).\n        years         = The number of years to add to the time point passed to\n                        the delegate.\n        months        = The number of months to add to the time point passed to\n                        the delegate.\n        allowOverflow = Whether the days should be allowed to overflow on\n                        $(D begin) and $(D end), causing their month to\n                        increment.\n        duration      = The duration to add to the time point passed to the\n                        delegate.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));\nauto func = everyDuration!Date(4, 1, AllowDayOverflow.yes, dur!\"days\"(2));\nauto range = interval.fwdRange(func);\n\n\/\/Using PopFirst.yes would have made this Date(2014, 10, 12).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2014, 10, 4));\n\nrange.popFront();\nassert(range.front == Date(2018, 11, 6));\n\nrange.popFront();\nassert(range.front == Date(2022, 12, 8));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
"line" : 26150,
"members" : [
{
"name" : "everyDuration",
"kind" : "function",
"type" : "nothrow TP delegate(in TP)(int years, int months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, D duration = dur!(\"days\")(0))",
"line" : 26150}
]
}
,
{
"name" : "IntervalRange(TP,Direction dir) if (isTimePoint!(TP) && dir != Direction.both)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    A range over an $(D Interval).\n\n    $(D IntervalRange) is only ever constructed by $(D Interval). However, when\n    it is constructed, it is given a function, $(D func), which is used to\n    generate the time points which are iterated over. $(D func) takes a time\n    point and returns a time point of the same type. For instance,\n    to iterate over all of the days in\n    the interval $(D Interval!Date), pass a function to $(D Interval)'s $(D fwdRange)\n    where that function took a $(D Date) and returned a $(D Date) which was one\n    day later. That function would then be used by $(D IntervalRange)'s\n    $(D popFront) to iterate over the $(D Date)s in the interval.\n\n    If $(D dir == Direction.fwd), then a range iterates forward in time, whereas\n    if $(D dir == Direction.bwd), then it iterates backwards in time. So, if\n    $(D dir == Direction.fwd) then $(D front == interval.begin), whereas if\n    $(D dir == Direction.bwd) then $(D front == interval.end). $(D func) must\n    generate a time point going in the proper direction of iteration, or a\n    $(D DateTimeException) will be thrown. So, to iterate forward in\n    time, the time point that $(D func) generates must be later in time than the\n    one passed to it. If it's either identical or earlier in time, then a\n    $(D DateTimeException) will be thrown. To iterate backwards, then\n    the generated time point must be before the time point which was passed in.\n\n    If the generated time point is ever passed the edge of the range in the\n    proper direction, then the edge of that range will be used instead. So, if\n    iterating forward, and the generated time point is past the interval's\n    $(D end), then $(D front) becomes $(D end). If iterating backwards, and the\n    generated time point is before $(D begin), then $(D front) becomes\n    $(D begin). In either case, the range would then be empty.\n\n    Also note that while normally the $(D begin) of an interval is included in\n    it and its $(D end) is excluded from it, if $(D dir == Direction.bwd), then\n    $(D begin) is treated as excluded and $(D end) is treated as included. This\n    allows for the same behavior in both directions. This works because none of\n    $(D Interval)'s functions which care about whether $(D begin) or $(D end) is\n    included or excluded are ever called by $(D IntervalRange). $(D interval)\n    returns a normal interval, regardless of whether $(D dir == Direction.fwd)\n    or if $(D dir == Direction.bwd), so any $(D Interval) functions which are\n    called on it which care about whether $(D begin) or $(D end) are included or\n    excluded will treat $(D begin) as included and $(D end) as excluded.\n  \n",
"line" : 26309,
"members" : [
{
"name" : "IntervalRange",
"kind" : "struct",
"protection" : "public",
"line" : 26309,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow IntervalRange(ref IntervalRange rhs)",
"comment" : "\n        Params:\n            rhs = The $(D IntervalRange) to assign to this one.\n      \n",
"line" : 26316}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const pure nothrow bool()",
"comment" : "\n        Whether this $(D IntervalRange) is empty.\n      \n",
"line" : 26328}
,
{
"name" : "front",
"kind" : "function",
"type" : "const pure TP()",
"comment" : "\n        The first time point in the range.\n\n        Throws:\n            $(D DateTimeException) if the range is empty.\n      \n",
"line" : 26340}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range. If the generated time point is beyond the edge\n        of the range, then $(D front) is set to that edge, and the range is then\n        empty. So, if iterating forwards, and the generated time point is\n        greater than the interval's $(D end), then $(D front) is set to\n        $(D end). If iterating backwards, and the generated time point is less\n        than the interval's $(D begin), then $(D front) is set to $(D begin).\n\n        Throws:\n            $(D DateTimeException) if the range is empty or if the generated\n            time point is in the wrong direction (i.e. if iterating\n            forward and the generated time point is before $(D front), or if\n            iterating backwards and the generated time point is after\n            $(D front)).\n      \n",
"line" : 26367}
,
{
"name" : "save",
"kind" : "function",
"type" : "pure nothrow IntervalRange()",
"comment" : "\n        Returns a copy of $(D this).\n      \n",
"line" : 26399}
,
{
"name" : "interval",
"kind" : "function",
"type" : "const pure nothrow Interval!(TP)()",
"comment" : "\n        The interval that this $(D IntervalRange) currently covers.\n      \n",
"line" : 26408}
,
{
"name" : "func",
"kind" : "function",
"type" : "pure nothrow @property TP delegate(in TP)()",
"comment" : "\n        The function used to generate the next time point in the range.\n      \n",
"line" : 26417}
,
{
"name" : "direction",
"kind" : "function",
"type" : "const pure nothrow Direction()",
"comment" : "\n        The $(D Direction) that this range iterates in.\n      \n",
"line" : 26426}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow (in Interval!(TP) interval, TP delegate(in TP) func)",
"line" : 26440}
,
{
"name" : "_enforceNotEmpty",
"kind" : "function",
"type" : "const pure void(size_t line = __LINE__)",
"line" : 26451}
,
{
"name" : "_enforceCorrectDirection",
"kind" : "function",
"type" : "const void(in TP newTP, size_t line = __LINE__)",
"line" : 26463}
,
{
"name" : "_interval",
"kind" : "variable",
"type" : "Interval!(TP)",
"line" : 26486}
,
{
"name" : "_func",
"kind" : "variable",
"type" : "TP delegate(in TP)",
"line" : 26487}
]
}
]
}
,
{
"name" : "PosInfIntervalRange(TP) if (isTimePoint!(TP))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    A range over a $(D PosInfInterval). It is an infinite range.\n\n    $(D PosInfIntervalRange) is only ever constructed by $(D PosInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D PosInfInterval!Date), pass a function to\n    $(D PosInfInterval)'s $(D fwdRange) where that function took a $(D Date) and\n    returned a $(D Date) which was one day later. That function would then be\n    used by $(D PosInfIntervalRange)'s $(D popFront) to iterate over the\n    $(D Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to positive infinity, the range is always iterated over\n    forwards, never backwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(D DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be later in time\n    than the one passed to it. If it's either identical or earlier in time, then\n    a $(D DateTimeException) will be thrown.\n  \n",
"line" : 26826,
"members" : [
{
"name" : "PosInfIntervalRange",
"kind" : "struct",
"protection" : "public",
"line" : 26826,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow PosInfIntervalRange(ref PosInfIntervalRange rhs)",
"comment" : "\n        Params:\n            rhs = The $(D PosInfIntervalRange) to assign to this one.\n      \n",
"line" : 26833}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"comment" : "\n        This is an infinite range, so it is never empty.\n      \n",
"line" : 26845}
,
{
"name" : "front",
"kind" : "function",
"type" : "const pure nothrow TP()",
"comment" : "\n        The first time point in the range.\n      \n",
"line" : 26851}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(D DateTimeException) if the generated time point is less than\n            $(D front).\n      \n",
"line" : 26865}
,
{
"name" : "save",
"kind" : "function",
"type" : "pure nothrow PosInfIntervalRange()",
"comment" : "\n        Returns a copy of $(D this).\n      \n",
"line" : 26878}
,
{
"name" : "interval",
"kind" : "function",
"type" : "const pure nothrow PosInfInterval!(TP)()",
"comment" : "\n        The interval that this range currently covers.\n      \n",
"line" : 26887}
,
{
"name" : "func",
"kind" : "function",
"type" : "pure nothrow @property TP delegate(in TP)()",
"comment" : "\n        The function used to generate the next time point in the range.\n      \n",
"line" : 26896}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow (in PosInfInterval!(TP) interval, TP delegate(in TP) func)",
"line" : 26910}
,
{
"name" : "_enforceCorrectDirection",
"kind" : "function",
"type" : "const void(in TP newTP, size_t line = __LINE__)",
"line" : 26922}
,
{
"name" : "_interval",
"kind" : "variable",
"type" : "PosInfInterval!(TP)",
"line" : 26933}
,
{
"name" : "_func",
"kind" : "variable",
"type" : "TP delegate(in TP)",
"line" : 26934}
]
}
]
}
,
{
"name" : "NegInfIntervalRange(TP) if (isTimePoint!(TP))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    A range over a $(D NegInfInterval). It is an infinite range.\n\n    $(D NegInfIntervalRange) is only ever constructed by $(D NegInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D NegInfInterval!Date), pass a function to\n    $(D NegInfInterval)'s $(D bwdRange) where that function took a $(D Date) and\n    returned a $(D Date) which was one day earlier. That function would then be\n    used by $(D NegInfIntervalRange)'s $(D popFront) to iterate over the\n    $(D Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to negative infinity, the range is always iterated over\n    backwards, never forwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(D DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be earlier in time\n    than the one passed to it. If it's either identical or later in time, then a\n    $(D DateTimeException) will be thrown.\n\n    Also note that while normally the $(D end) of an interval is excluded from\n    it, $(D NegInfIntervalRange) treats it as if it were included. This allows\n    for the same behavior as with $(D PosInfIntervalRange). This works\n    because none of $(D NegInfInterval)'s functions which care about whether\n    $(D end) is included or excluded are ever called by\n    $(D NegInfIntervalRange). $(D interval) returns a normal interval, so any\n    $(D NegInfInterval) functions which are called on it which care about\n    whether $(D end) is included or excluded will treat $(D end) as excluded.\n  \n",
"line" : 27125,
"members" : [
{
"name" : "NegInfIntervalRange",
"kind" : "struct",
"protection" : "public",
"line" : 27125,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "pure nothrow NegInfIntervalRange(ref NegInfIntervalRange rhs)",
"comment" : "\n        Params:\n            rhs = The $(D NegInfIntervalRange) to assign to this one.\n      \n",
"line" : 27132}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"comment" : "\n        This is an infinite range, so it is never empty.\n      \n",
"line" : 27144}
,
{
"name" : "front",
"kind" : "function",
"type" : "const pure nothrow TP()",
"comment" : "\n        The first time point in the range.\n      \n",
"line" : 27150}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(D DateTimeException) if the generated time point is greater than\n            $(D front).\n      \n",
"line" : 27164}
,
{
"name" : "save",
"kind" : "function",
"type" : "pure nothrow NegInfIntervalRange()",
"comment" : "\n        Returns a copy of $(D this).\n      \n",
"line" : 27177}
,
{
"name" : "interval",
"kind" : "function",
"type" : "const pure nothrow NegInfInterval!(TP)()",
"comment" : "\n        The interval that this range currently covers.\n      \n",
"line" : 27186}
,
{
"name" : "func",
"kind" : "function",
"type" : "pure nothrow @property TP delegate(in TP)()",
"comment" : "\n        The function used to generate the next time point in the range.\n      \n",
"line" : 27195}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow (in NegInfInterval!(TP) interval, TP delegate(in TP) func)",
"line" : 27209}
,
{
"name" : "_enforceCorrectDirection",
"kind" : "function",
"type" : "const void(in TP newTP, size_t line = __LINE__)",
"line" : 27221}
,
{
"name" : "_interval",
"kind" : "variable",
"type" : "NegInfInterval!(TP)",
"line" : 27232}
,
{
"name" : "_func",
"kind" : "variable",
"type" : "TP delegate(in TP)",
"line" : 27233}
]
}
]
}
,
{
"name" : "TimeZone",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Represents a time zone. It is used with $(D SysTime) to indicate the time\n    zone of a $(D SysTime).\n  \n",
"line" : 27398,
"base" : "Object",
"members" : [
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property string()",
"comment" : "\n        The name of the time zone per the TZ Database. This is the name used to\n        get a $(D TimeZone) by name with $(D TimeZone.getTimeZone).\n\n        See_Also:\n            $(WEB en.wikipedia.org\/wiki\/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org\/wiki\/List_of_tz_database_time_zones, List of\n              Time Zones)\n      \n",
"line" : 27411}
,
{
"name" : "stdName",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property string()",
"comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n      \n",
"line" : 27424}
,
{
"name" : "dstName",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property string()",
"comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n      \n",
"line" : 27437}
,
{
"name" : "hasDST",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current dates\n        but will still return true for $(D hasDST) because the time zone did at\n        some point have DST.\n      \n",
"line" : 27449}
,
{
"name" : "dstInEffect",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow bool(long stdTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n      \n",
"line" : 27461}
,
{
"name" : "utcToTZ",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long stdTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n      \n",
"line" : 27472}
,
{
"name" : "tzToUTC",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long adjTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
"line" : 27483}
,
{
"name" : "utcOffsetAt",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow Duration(long stdTime)",
"comment" : "\n        Returns what the offset from UTC is at the given std time.\n        It includes the DST offset in effect at that time (if any).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n      \n",
"line" : 27494}
,
{
"name" : "getTimeZone",
"kind" : "function",
"protection" : "public",
"type" : "immutable(TimeZone)(string name)",
"comment" : "\n        Returns a $(D TimeZone) with the give name per the TZ Database.\n\n        This returns a $(D PosixTimeZone) on Posix systems and a\n        $(D WindowsTimeZone) on Windows systems. For\n        $(D PosixTimeZone) on Windows, call $(D PosixTimeZone.getTimeZone)\n        directly and give it the location of the TZ Database time zone files on\n        disk.\n\n        On Windows, the given TZ Database name is converted to the corresponding\n        time zone name on Windows prior to calling\n        $(D WindowsTimeZone.getTimeZone). This function allows for\n        the same time zone names on both Windows and Posix systems.\n\n        See_Also:\n            $(WEB en.wikipedia.org\/wiki\/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org\/wiki\/List_of_tz_database_time_zones, List of\n              Time Zones)<br>\n            $(WEB unicode.org\/repos\/cldr-tmp\/trunk\/diff\/supplemental\/zone_tzid.html,\n                  Windows <-> TZ Database Name Conversion Table)\n\n        Params:\n            name = The TZ Database name of the desired time zone\n\n        Throws:\n            $(D DateTimeException) if the given time zone could not be found.\n\n        Examples:\n--------------------\nauto tz = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n--------------------\n      \n",
"line" : 27533}
,
{
"name" : "getInstalledTZNames",
"kind" : "function",
"protection" : "public",
"type" : "string[](string subName = \"\")",
"comment" : "\n        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        On Windows, this function will convert the Windows time zone names to\n        the corresponding TZ Database names with\n        $(D windowsTZNameToTZDatabaseName). To get the actual Windows time\n        zone names, use $(D WindowsTimeZone.getInstalledTZNames) directly.\n\n        Params:\n            subName = The first part of the time zones desired.\n\n        Throws:\n            $(D FileException) on Posix systems if it fails to read from disk.\n            $(D DateTimeException) on Windows systems if it fails to read the\n            registry.\n      \n",
"line" : 27839}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "immutable pure immutable(TimeZone)(string name, string stdName, string dstName)",
"line" : 27889}
,
{
"name" : "_name",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(char[])",
"line" : 27897}
,
{
"name" : "_stdName",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(char[])",
"line" : 27898}
,
{
"name" : "_dstName",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(char[])",
"line" : 27899}
]
}
,
{
"name" : "LocalTime",
"kind" : "class",
"protection" : "public",
"comment" : "\n    A TimeZone which represents the current local time zone on\n    the system running your program.\n\n    This uses the underlying C calls to adjust the time rather than using\n    specific D code based off of system settings to calculate the time such as\n    $(D PosixTimeZone) and $(D WindowsTimeZone) do. That also means that it will\n    use whatever the current time zone is on the system, even if the system's\n    time zone changes while the program is running.\n  \n",
"line" : 27913,
"base" : "TimeZone",
"members" : [
{
"name" : "opCall",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow immutable(LocalTime)()",
"comment" : "\n        $(D LocalTime) is a singleton class. $(D LocalTime) returns its only\n        instance.\n      \n",
"line" : 27921}
,
{
"name" : "stdName",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property string()",
"comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n      \n",
"line" : 27962}
,
{
"name" : "dstName",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property string()",
"comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n      \n",
"line" : 28035}
,
{
"name" : "hasDST",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n      \n",
"line" : 28102}
,
{
"name" : "dstInEffect",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow bool(long stdTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n      \n",
"line" : 28170}
,
{
"name" : "utcToTZ",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long stdTime)",
"comment" : "\n        Returns hnsecs in the local time zone using the standard C function\n        calls on Posix systems and the standard Windows system calls on Windows\n        systems to adjust the time to the appropriate time zone from std time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n      \n",
"line" : 28224}
,
{
"name" : "tzToUTC",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long adjTime)",
"comment" : "\n        Returns std time using the standard C function calls on Posix systems\n        and the standard Windows system calls on Windows systems to adjust the\n        time to UTC from the appropriate time zone.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
"line" : 28267}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "immutable immutable(LocalTime)()",
"line" : 28451}
,
{
"name" : "_localTime",
"kind" : "variable",
"protection" : "private",
"type" : "shared(LocalTime)",
"line" : 28458}
,
{
"name" : "_initialized",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 28459}
,
{
"name" : "singleton",
"kind" : "function",
"protection" : "private",
"type" : "immutable(LocalTime)()",
"line" : 28462}
]
}
,
{
"name" : "UTC",
"kind" : "class",
"protection" : "public",
"comment" : "\n    A $(D TimeZone) which represents UTC.\n  \n",
"line" : 28485,
"base" : "TimeZone",
"members" : [
{
"name" : "opCall",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow immutable(UTC)()",
"comment" : "\n        $(D UTC) is a singleton class. $(D UTC) returns its only instance.\n      \n",
"line" : 28492}
,
{
"name" : "hasDST",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Always returns false.\n      \n",
"line" : 28502}
,
{
"name" : "dstInEffect",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow bool(long stdTime)",
"comment" : "\n        Always returns false.\n      \n",
"line" : 28511}
,
{
"name" : "utcToTZ",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long stdTime)",
"comment" : "\n        Returns the given hnsecs without changing them at all.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n      \n",
"line" : 28527}
,
{
"name" : "tzToUTC",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long adjTime)",
"comment" : "\n        Returns the given hnsecs without changing them at all.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
"line" : 28562}
,
{
"name" : "utcOffsetAt",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow Duration(long stdTime)",
"comment" : "\n        Returns a $(CXREF time, Duration) of 0.\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n      \n",
"line" : 28594}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "immutable pure immutable(UTC)()",
"line" : 28602}
,
{
"name" : "_utc",
"kind" : "variable",
"protection" : "private",
"type" : "shared(UTC)",
"line" : 28608}
,
{
"name" : "_initialized",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 28609}
,
{
"name" : "singleton",
"kind" : "function",
"protection" : "private",
"type" : "immutable(UTC)()",
"line" : 28612}
]
}
,
{
"name" : "SimpleTimeZone",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Represents a time zone with an offset (in minutes, west is negative) from\n    UTC but no DST.\n\n    It's primarily used as the time zone in the result of $(D SysTime)'s\n    $(D fromISOString), $(D fromISOExtString), and $(D fromSimpleString).\n\n    $(D name) and $(D dstName) are always the empty string since this time zone\n    has no DST, and while it may be meant to represent a time zone which is in\n    the TZ Database, obviously it's not likely to be following the exact rules\n    of any of the time zones in the TZ Database, so it makes no sense to set it.\n  \n",
"line" : 28644,
"base" : "TimeZone",
"members" : [
{
"name" : "hasDST",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Always returns false.\n      \n",
"line" : 28651}
,
{
"name" : "dstInEffect",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow bool(long stdTime)",
"comment" : "\n        Always returns false.\n      \n",
"line" : 28660}
,
{
"name" : "utcToTZ",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long stdTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n      \n",
"line" : 28674}
,
{
"name" : "tzToUTC",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long adjTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
"line" : 28702}
,
{
"name" : "utcOffsetAt",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow Duration(long stdTime)",
"comment" : "\n        Returns utcOffset as a $(CXREF time, Duration).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n      \n",
"line" : 28730}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "immutable immutable(SimpleTimeZone)(int utcOffset, string stdName = \"\")",
"comment" : "\n        Params:\n            utcOffset = This time zone's offset from UTC in minutes with west of\n                        UTC being negative (it is added to UTC to get the\n                        adjusted time).\n            stdName   = The $(D stdName) for this time zone.\n      \n",
"line" : 28743}
,
{
"name" : "utcOffset",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(int)",
"comment" : "\n        The number of minutes the offset from UTC is (negative is west of UTC,\n        positive is east).\n      \n",
"line" : 28771}
,
{
"name" : "toISOString",
"kind" : "function",
"protection" : "private",
"type" : "string(int utcOffset)",
"line" : 28784}
,
{
"name" : "fromISOString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"line" : 28842,
"members" : [
{
"name" : "fromISOString",
"kind" : "function",
"type" : "immutable(SimpleTimeZone)(S isoString)",
"line" : 28842}
]
}
]
}
,
{
"name" : "PosixTimeZone",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Represents a time zone from a TZ Database time zone file. Files from the TZ\n    Database are how Posix systems hold their time zone information.\n    Unfortunately, Windows does not use the TZ Database. To use the TZ Database,\n    use $(LREF PosixTimeZone) (which reads its information from the TZ Database\n    files on disk) on Windows by providing the TZ Database files and telling\n    $(D PosixTimeZone.getTimeZone) where the directory holding them is.\n\n    To get a $(D PosixTimeZone), either call $(D PosixTimeZone.getTimeZone)\n    (which allows specifying the location the time zone files) or call\n    $(D TimeZone.getTimeZone) (which will give a $(D PosixTimeZone) on Posix\n    systems and a $(D WindowsTimeZone) on Windows systems).\n\n    Note:\n        Unless your system's local time zone deals with leap seconds (which is\n        highly unlikely), then the only way to get a time zone which\n        takes leap seconds into account is to use $(D PosixTimeZone) with a\n        time zone whose name starts with \"right\/\". Those time zone files do\n        include leap seconds, and $(D PosixTimeZone) will take them into account\n        (though posix systems which use a \"right\/\" time zone as their local time\n        zone will $(I not) take leap seconds into account even though they're\n        in the file).\n\n    See_Also:\n        $(WEB www.iana.org\/time-zones, Home of the TZ Database files)<br>\n        $(WEB en.wikipedia.org\/wiki\/Tz_database, Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org\/wiki\/List_of_tz_database_time_zones, List of Time\n          Zones)\n  \n",
"line" : 29003,
"base" : "TimeZone",
"members" : [
{
"name" : "hasDST",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property bool()",
"comment" : "\n        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n      \n",
"line" : 29013}
,
{
"name" : "dstInEffect",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow bool(long stdTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n      \n",
"line" : 29028}
,
{
"name" : "utcToTZ",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long stdTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n      \n",
"line" : 29057}
,
{
"name" : "tzToUTC",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow long(long adjTime)",
"comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
"line" : 29087}
,
{
"name" : "defaultTZDatabaseDir",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n            The default directory where the TZ Database files are. It's empty\n            for Windows, since Windows doesn't have them.\n          \n",
"line" : 29137}
,
{
"name" : "getTimeZone",
"kind" : "function",
"protection" : "public",
"type" : "immutable(PosixTimeZone)(string name, string tzDatabaseDir = \"\/usr\/share\/zoneinfo\/\")",
"comment" : "\n        Returns a $(D TimeZone) with the give name per the TZ Database. The time\n        zone information is fetched from the TZ Database time zone files in the\n        given directory.\n\n        See_Also:\n            $(WEB en.wikipedia.org\/wiki\/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org\/wiki\/List_of_tz_database_time_zones, List of\n              Time Zones)\n\n        Params:\n            name          = The TZ Database name of the desired time zone\n            tzDatabaseDir = The directory where the TZ Database files are\n                            located. Because these files are not located on\n                            Windows systems, provide them\n                            and give their location here to\n                            use $(D PosixTimeZone)s.\n\n        Throws:\n            $(D DateTimeException) if the given time zone could not be found or\n            $(D FileException) if the TZ Database file could not be opened.\n\n        Examples:\n--------------------\nauto tz = PosixTimeZone.getTimeZone(\"America\/Los_Angeles\");\n\nassert(tz.name == \"America\/Los_Angeles\");\nassert(tz.stdName == \"PST\");\nassert(tz.dstName == \"PDT\");\n--------------------\n      \n",
"line" : 29182}
,
{
"name" : "getInstalledTZNames",
"kind" : "function",
"protection" : "public",
"type" : "string[](string subName = \"\", string tzDatabaseDir = \"\/usr\/share\/zoneinfo\/\")",
"comment" : "\n        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        Params:\n            subName = The first part of the desired time zones.\n\n        Throws:\n            $(D FileException) if it fails to read from disk.\n      \n",
"line" : 29496}
,
{
"name" : "Transition",
"kind" : "struct",
"protection" : "private",
"line" : 29581,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref Transition(long timeT, immutable(TTInfo)* ttInfo)",
"line" : 29582}
,
{
"name" : "timeT",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 29588}
,
{
"name" : "ttInfo",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(TTInfo)*",
"line" : 29589}
]
}
,
{
"name" : "LeapSecond",
"kind" : "struct",
"protection" : "private",
"line" : 29597,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref LeapSecond(long timeT, int total)",
"line" : 29598}
,
{
"name" : "timeT",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 29604}
,
{
"name" : "total",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 29605}
]
}
,
{
"name" : "TTInfo",
"kind" : "struct",
"protection" : "private",
"line" : 29613,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "immutable ref immutable(TTInfo)(const(TempTTInfo) tempTTInfo, string abbrev)",
"line" : 29614}
,
{
"name" : "utcOffset",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(int)",
"comment" : " Offset from UTC.\n",
"line" : 29621}
,
{
"name" : "isDST",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(bool)",
"comment" : " Whether DST is in effect.\n",
"line" : 29622}
,
{
"name" : "abbrev",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : " The current abbreviation for the time zone.\n",
"line" : 29623}
]
}
,
{
"name" : "TempTTInfo",
"kind" : "struct",
"protection" : "private",
"line" : 29632,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref TempTTInfo(int gmtOff, bool isDST, ubyte abbrInd)",
"line" : 29633}
,
{
"name" : "tt_gmtoff",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 29640}
,
{
"name" : "tt_isdst",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"line" : 29641}
,
{
"name" : "tt_abbrind",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte",
"line" : 29642}
]
}
,
{
"name" : "TempTransition",
"kind" : "struct",
"protection" : "private",
"line" : 29652,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref TempTransition(long timeT, immutable(TTInfo)* ttInfo, TransitionType* ttype)",
"line" : 29653}
,
{
"name" : "timeT",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 29660}
,
{
"name" : "ttInfo",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(TTInfo)*",
"line" : 29661}
,
{
"name" : "ttype",
"kind" : "variable",
"protection" : "public",
"type" : "TransitionType*",
"line" : 29662}
]
}
,
{
"name" : "TransitionType",
"kind" : "struct",
"protection" : "private",
"line" : 29672,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref TransitionType(bool isStd, bool inUTC)",
"line" : 29673}
,
{
"name" : "isStd",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"comment" : " Whether the transition is in std time (as opposed to wall clock time).\n",
"line" : 29680}
,
{
"name" : "inUTC",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"comment" : " Whether the transition is in UTC (as opposed to local time).\n",
"line" : 29683}
]
}
,
{
"name" : "readVal(T) if (isIntegral!(T) || isSomeChar!(T) || is(Unqual!(T) == bool))",
"kind" : "template",
"protection" : "public",
"line" : 29690,
"members" : [
{
"name" : "readVal",
"kind" : "function",
"type" : "T(ref File tzFile)",
"line" : 29690}
]
}
,
{
"name" : "readVal(T) if (isArray!(T))",
"kind" : "template",
"protection" : "public",
"line" : 29705,
"members" : [
{
"name" : "readVal",
"kind" : "function",
"type" : "T(ref File tzFile, size_t length)",
"line" : 29705}
]
}
,
{
"name" : "readVal(T) if (is(T == TempTTInfo))",
"kind" : "template",
"protection" : "public",
"line" : 29720,
"members" : [
{
"name" : "readVal",
"kind" : "function",
"type" : "T(ref File tzFile)",
"line" : 29720}
]
}
,
{
"name" : "_enforceValidTZFile",
"kind" : "function",
"protection" : "private",
"type" : "void(bool result, ulong line = cast(ulong)__LINE__)",
"line" : 29733}
,
{
"name" : "calculateLeapSeconds",
"kind" : "function",
"protection" : "private",
"type" : "const nothrow int(long stdTime)",
"line" : 29740}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "immutable immutable(PosixTimeZone)(immutable(Transition[]) transitions, immutable(LeapSecond[]) leapSeconds, string name, string stdName, string dstName, bool hasDST)",
"line" : 29766}
,
{
"name" : "_transitions",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(Transition[])",
"comment" : " List of times when the utc offset changes.\n",
"line" : 29795}
,
{
"name" : "_leapSeconds",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(LeapSecond[])",
"comment" : " List of leap second occurrences.\n",
"line" : 29798}
,
{
"name" : "_hasDST",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(bool)",
"comment" : " Whether DST is in effect for this time zone at any point in time.\n",
"line" : 29801}
]
}
,
{
"name" : "setTZEnvVar",
"kind" : "function",
"protection" : "public",
"type" : "nothrow void(string tzDatabaseName)",
"line" : 30293}
,
{
"name" : "clearTZEnvVar",
"kind" : "function",
"protection" : "public",
"type" : "nothrow void()",
"line" : 30307}
,
{
"name" : "tzDatabaseNameToWindowsTZName",
"kind" : "function",
"protection" : "public",
"type" : "string(string tzName)",
"comment" : "\n    Converts the given TZ Database name to the corresponding Windows time zone\n    name.\n\n    Note that in a few cases, a TZ Dabatase name corresponds to two different\n    Windows time zone names. So, while in most cases converting from one to the\n    other and back again will result in the same time zone name started\n    with, in a few case, it'll get a different name.\n\n    Also, there are far more TZ Database names than Windows time zones, so some\n    of the more exotic TZ Database names don't have corresponding Windows time\n    zone names.\n\n    See_Also:\n        $(WEB unicode.org\/repos\/cldr-tmp\/trunk\/diff\/supplemental\/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n\n    Throws:\n        $(D DateTimeException) if the given $(D_PARAM tzName) cannot be\n        converted.\n  \n",
"line" : 30344}
,
{
"name" : "windowsTZNameToTZDatabaseName",
"kind" : "function",
"protection" : "public",
"type" : "string(string tzName)",
"comment" : "\n    Converts the given Windows time zone name to a corresponding TZ Database\n    name.\n\n    See_Also:\n        $(WEB unicode.org\/repos\/cldr-tmp\/trunk\/diff\/supplemental\/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n\n    Throws:\n        $(D DateTimeException) if the given $(D_PARAM tzName) cannot be\n        converted.\n  \n",
"line" : 30493}
,
{
"name" : "StopWatch",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   $(D StopWatch) measures time as precisely as possible.\n\n   This class uses a high-performance counter. On Windows systems, it uses\n   $(D QueryPerformanceCounter), and on Posix systems, it uses\n   $(D clock_gettime) if available, and $(D gettimeofday) otherwise.\n\n   But the precision of $(D StopWatch) differs from system to system. It is\n   impossible to for it to be the same from system to system since the precision\n   of the system clock varies from system to system, and other system-dependent\n   and situation-dependent stuff (such as the overhead of a context switch\n   between threads) can also affect $(D StopWatch)'s accuracy.\n\n   Examples:\n--------------------\nvoid foo()\n{\n    StopWatch sw;\n    enum n = 100;\n    TickDuration[n] times;\n    TickDuration last = TickDuration.from!\"seconds\"(0);\n    foreach(i; 0..n)\n    {\n       sw.start(); \/\/start\/resume mesuring.\n       foreach(unused; 0..1_000_000)\n           bar();\n       sw.stop();  \/\/stop\/pause measuring.\n       \/\/Return value of peek() after having stopped are the always same.\n       writeln((i + 1) * 1_000_000, \" times done, lap time: \",\n               sw.peek().msecs, \"[ms]\");\n       times[i] = sw.peek() - last;\n       last = sw.peek();\n    }\n    real sum = 0;\n    \/\/ To know the number of seconds,\n    \/\/ use properties of TickDuration.\n    \/\/ (seconds, mseconds, useconds, hnsecs)\n    foreach(t; times)\n       sum += t.hnsecs;\n    writeln(\"Average time: \", sum\/n, \" hnsecs\");\n}\n--------------------\n  \n",
"line" : 30678,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref @safe StopWatch(AutoStart autostart)",
"comment" : "\n       Auto start with constructor.\n      \n",
"line" : 30714}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe bool(const(StopWatch) rhs)",
"comment" : "\n",
"line" : 30728}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe bool(ref const(StopWatch) rhs)",
"comment" : " ditto\n",
"line" : 30734}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "@safe void()",
"comment" : "\n       Resets the stop watch.\n      \n",
"line" : 30744}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "@safe void()",
"comment" : "\n       Starts the stop watch.\n      \n",
"line" : 30773}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "@safe void()",
"comment" : "\n       Stops the stop watch.\n      \n",
"line" : 30799}
,
{
"name" : "peek",
"kind" : "function",
"protection" : "public",
"type" : "const @safe TickDuration()",
"comment" : "\n       Peek at the amount of time which has passed since the stop watch was\n       started.\n      \n",
"line" : 30826}
,
{
"name" : "_flagStarted",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 30849}
,
{
"name" : "_timeStart",
"kind" : "variable",
"protection" : "private",
"type" : "TickDuration",
"line" : 30852}
,
{
"name" : "_timeMeasured",
"kind" : "variable",
"protection" : "private",
"type" : "TickDuration",
"line" : 30855}
]
}
,
{
"name" : "lengthof(aliases...)",
"kind" : "template",
"protection" : "public",
"line" : 30860,
"members" : [
{
"name" : "lengthof",
"kind" : "function",
"type" : "pure nothrow size_t()",
"line" : 30860}
]
}
,
{
"name" : "benchmark(fun...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Benchmarks code for speed assessment and comparison.\n\n    Params:\n        fun = aliases of callable objects (e.g. function names). Each should\n              take no arguments.\n        n   = The number of times each function is to be executed.\n\n    Returns:\n        The amount of time (as a $(CXREF time, TickDuration)) that it took to\n        call each function $(D n) times. The first value is the length of time\n        that it took to call $(D fun[0]) $(D n) times. The second value is the\n        length of time it took to call $(D fun[1]) $(D n) times. Etc.\n\n   Examples:\n--------------------\nint a;\nvoid f0() {}\nvoid f1() {auto b = a;}\nvoid f2() {auto b = to!(string)(a);}\nauto r = benchmark!(f0, f1, f2)(10_000);\nwritefln(\"Milliseconds to call fun[0] n times: %s\", r[0].to!(\"msecs\", int));\n--------------------\n  \n",
"line" : 30890,
"members" : [
{
"name" : "benchmark",
"kind" : "function",
"type" : "TickDuration[lengthof!(fun)()](uint n)",
"comment" : "\n    Benchmarks code for speed assessment and comparison.\n\n    Params:\n        fun = aliases of callable objects (e.g. function names). Each should\n              take no arguments.\n        n   = The number of times each function is to be executed.\n\n    Returns:\n        The amount of time (as a $(CXREF time, TickDuration)) that it took to\n        call each function $(D n) times. The first value is the length of time\n        that it took to call $(D fun[0]) $(D n) times. The second value is the\n        length of time it took to call $(D fun[1]) $(D n) times. Etc.\n\n   Examples:\n--------------------\nint a;\nvoid f0() {}\nvoid f1() {auto b = a;}\nvoid f2() {auto b = to!(string)(a);}\nauto r = benchmark!(f0, f1, f2)(10_000);\nwritefln(\"Milliseconds to call fun[0] n times: %s\", r[0].to!(\"msecs\", int));\n--------------------\n  \n",
"line" : 30890}
]
}
,
{
"name" : "ComparingBenchmarkResult",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Return value of benchmark with two functions comparing.\n  \n",
"line" : 30934,
"members" : [
{
"name" : "point",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe real()",
"comment" : "\n       Evaluation value\n\n       This returns the evaluation value of performance as the ratio of\n       baseFunc's time over targetFunc's time. If performance is high, this\n       returns a high value.\n      \n",
"line" : 30942}
,
{
"name" : "baseTime",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe TickDuration()",
"comment" : "\n       The time required of the base function\n      \n",
"line" : 30951}
,
{
"name" : "targetTime",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe TickDuration()",
"comment" : "\n       The time required of the target function\n      \n",
"line" : 30960}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "pure nothrow ref @safe ComparingBenchmarkResult(TickDuration baseTime, TickDuration targetTime)",
"line" : 30967}
,
{
"name" : "_baseTime",
"kind" : "variable",
"protection" : "private",
"type" : "TickDuration",
"line" : 30973}
,
{
"name" : "_targetTime",
"kind" : "variable",
"protection" : "private",
"type" : "TickDuration",
"line" : 30974}
]
}
,
{
"name" : "comparingBenchmark(alias baseFunc,alias targetFunc,int times = 4095)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Benchmark with two functions comparing.\n\n   Params:\n       baseFunc   = The function to become the base of the speed.\n       targetFunc = The function that wants to measure speed.\n       times      = The number of times each function is to be executed.\n\n   Examples:\n--------------------\nvoid f1() {\n   \/\/ ...\n}\nvoid f2() {\n   \/\/ ...\n}\n\nvoid main() {\n   auto b = comparingBenchmark!(f1, f2, 0x80);\n   writeln(b.point);\n}\n--------------------\n  \n",
"line" : 31001,
"members" : [
{
"name" : "comparingBenchmark",
"kind" : "function",
"type" : "ComparingBenchmarkResult()",
"comment" : "\n   Benchmark with two functions comparing.\n\n   Params:\n       baseFunc   = The function to become the base of the speed.\n       targetFunc = The function that wants to measure speed.\n       times      = The number of times each function is to be executed.\n\n   Examples:\n--------------------\nvoid f1() {\n   \/\/ ...\n}\nvoid f2() {\n   \/\/ ...\n}\n\nvoid main() {\n   auto b = comparingBenchmark!(f1, f2, 0x80);\n   writeln(b.point);\n}\n--------------------\n  \n",
"line" : 31001}
]
}
,
{
"name" : "isTimePoint(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Whether the given type defines all of the necessary functions for it to\n    function as a time point.\n  \n",
"line" : 31053,
"members" : [
{
"name" : "isTimePoint",
"kind" : "variable",
"line" : 31059}
]
}
,
{
"name" : "yearIsLeapYear",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow bool(int year)",
"comment" : "\n    Whether the given Gregorian Year is a leap year.\n\n    Params:\n        year = The year to to be tested.\n \n",
"line" : 31087}
,
{
"name" : "unixTimeToStdTime",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow long(long unixTime)",
"comment" : "\n    Converts a $(D time_t) (which uses midnight, January 1st, 1970 UTC as its\n    epoch and seconds as its units) to std time (which uses midnight,\n    January 1st, 1 A.D. UTC and hnsecs as its units).\n\n    Params:\n        unixTime = The $(D time_t) to convert.\n  \n",
"line" : 31122}
,
{
"name" : "stdTimeToUnixTime",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow long(long stdTime)",
"comment" : "\n    Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch\n    and hnsecs as its units) to $(D time_t) (which uses midnight, January 1st,\n    1970 UTC as its epoch and seconds as its units). If $(D time_t) is 32 bits,\n    rather than 64, and the result can't fit in a 32-bit value, then the closest\n    value that can be held in 32 bits will be used (so $(D time_t.max) if it\n    goes over and $(D time_t.min) if it goes under).\n\n    Note:\n        While Windows systems require that $(D time_t) be non-negative (in spite\n        of $(D time_t) being signed), this function still returns negative\n        numbers on Windows, since it's more flexible to allow negative time_t\n        for those who need it. If on Windows and using the\n        standard C functions or Win32 API functions which take a $(D time_t),\n        check whether the return value of\n        $(D stdTimeToUnixTime) is non-negative.\n\n    Params:\n        stdTime = The std time to convert.\n  \n",
"line" : 31162}
,
{
"name" : "DosFileTime",
"kind" : "alias",
"protection" : "public",
"type" : "uint",
"comment" : "\n    Type representing the DOS file date\/time format.\n  \n",
"line" : 31505}
,
{
"name" : "DosFileTimeToSysTime",
"kind" : "function",
"protection" : "public",
"type" : "SysTime(uint dft, immutable(TimeZone) tz = cast(immutable(TimeZone))opCall())",
"comment" : "\n    Converts from DOS file date\/time to $(D SysTime).\n\n    Params:\n        dft = The DOS file time to convert.\n        tz  = The time zone which the DOS file time is assumed to be in.\n\n    Throws:\n        $(D DateTimeException) if the $(D DosFileTime) is invalid.\n  \n",
"line" : 31517}
,
{
"name" : "SysTimeToDosFileTime",
"kind" : "function",
"protection" : "public",
"type" : "uint(SysTime sysTime)",
"comment" : "\n    Converts from $(D SysTime) to DOS file date\/time.\n\n    Params:\n        sysTime = The $(D SysTime) to convert.\n\n    Throws:\n        $(D DateTimeException) if the given $(D SysTime) cannot be converted to\n        a $(D DosFileTime).\n  \n",
"line" : 31565}
,
{
"name" : "validTimeUnits",
"kind" : "function",
"protection" : "public",
"type" : "bool(string[] units...)",
"comment" : "\n    Whether all of the given strings are valid units of time.\n\n    $(D \"nsecs\") is not considered a valid unit of time. Nothing in std.datetime\n    can handle precision greater than hnsecs, and the few functions in core.time\n    which deal with \"nsecs\" deal with it explicitly.\n  \n",
"line" : 31610}
,
{
"name" : "cmpTimeUnits",
"kind" : "function",
"protection" : "public",
"type" : "int(string lhs, string rhs)",
"comment" : "\n    Compares two time unit strings. $(D \"years\") are the largest units and\n    $(D \"hnsecs\") are the smallest.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n\n    Throws:\n        $(D DateTimeException) if either of the given strings is not a valid\n        time unit string.\n \n",
"line" : 31637}
,
{
"name" : "CmpTimeUnits(string lhs,string rhs) if (validTimeUnits(lhs,rhs))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Compares two time unit strings at compile time. $(D \"years\") are the largest\n    units and $(D \"hnsecs\") are the smallest.\n\n    This template is used instead of $(D cmpTimeUnits) because exceptions\n    can't be thrown at compile time and $(D cmpTimeUnits) must enforce that\n    the strings it's given are valid time unit strings. This template uses a\n    template constraint instead.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n \n",
"line" : 31692,
"members" : [
{
"name" : "CmpTimeUnits",
"kind" : "variable",
"line" : 31695}
]
}
,
{
"name" : "cmpTimeUnitsCTFE",
"kind" : "function",
"protection" : "private",
"type" : "int(string lhs, string rhs)",
"line" : 31702}
,
{
"name" : "valid(string units) if (units == \"months\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns whether the given value is valid for the given unit type when in a\n    time point. Naturally, a duration is not held to a particular range, but\n    the values in a time point are (e.g. a month must be in the range of\n    1 - 12 inclusive).\n\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n\n    Examples:\n--------------------\nassert(valid!\"hours\"(12));\nassert(!valid!\"hours\"(32));\nassert(valid!\"months\"(12));\nassert(!valid!\"months\"(13));\n--------------------\n  \n",
"line" : 31767,
"members" : [
{
"name" : "valid",
"kind" : "function",
"type" : "pure nothrow bool(int value)",
"comment" : "\n    Returns whether the given value is valid for the given unit type when in a\n    time point. Naturally, a duration is not held to a particular range, but\n    the values in a time point are (e.g. a month must be in the range of\n    1 - 12 inclusive).\n\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n\n    Examples:\n--------------------\nassert(valid!\"hours\"(12));\nassert(!valid!\"hours\"(32));\nassert(valid!\"months\"(12));\nassert(!valid!\"months\"(13));\n--------------------\n  \n",
"line" : 31767}
]
}
,
{
"name" : "valid(string units) if (units == \"days\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns whether the given day is valid for the given year and month.\n\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n  \n",
"line" : 31805,
"members" : [
{
"name" : "valid",
"kind" : "function",
"type" : "pure nothrow bool(int year, int month, int day)",
"comment" : "\n    Returns whether the given day is valid for the given year and month.\n\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n  \n",
"line" : 31805}
]
}
,
{
"name" : "enforceValid(string units) if (units == \"months\" || units == \"hours\" || units == \"minutes\" || units == \"seconds\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!units(value)) is false.\n  \n",
"line" : 31823,
"members" : [
{
"name" : "enforceValid",
"kind" : "function",
"type" : "pure void(int value, string file = __FILE__, size_t line = __LINE__)",
"comment" : "\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!units(value)) is false.\n  \n",
"line" : 31823}
]
}
,
{
"name" : "enforceValid(string units) if (units == \"days\")",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!\"days\"(year, month, day)) is false.\n  \n",
"line" : 31865,
"members" : [
{
"name" : "enforceValid",
"kind" : "function",
"type" : "pure void(int year, Month month, int day, string file = __FILE__, size_t line = __LINE__)",
"comment" : "\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!\"days\"(year, month, day)) is false.\n  \n",
"line" : 31865}
]
}
,
{
"name" : "monthsToMonth",
"kind" : "function",
"protection" : "public",
"type" : "pure int(int currMonth, int month)",
"comment" : "\n    Returns the number of months from the current months of the year to the\n    given month of the year. If they are the same, then the result is 0.\n\n    Params:\n        currMonth = The current month of the year.\n        month     = The month of the year to get the number of months to.\n  \n",
"line" : 31887}
,
{
"name" : "daysToDayOfWeek",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow int(DayOfWeek currDoW, DayOfWeek dow)",
"comment" : "\n    Returns the number of days from the current day of the week to the given\n    day of the week. If they are the same, then the result is 0.\n\n    Params:\n        currDoW = The current day of the week.\n        dow     = The day of the week to get the number of days to.\n  \n",
"line" : 31968}
,
{
"name" : "measureTime(alias func) if (isSafe!(delegate ()\n{\nStopWatch sw;\nunaryFun!(func)(sw.peek());\n}\n))",
"kind" : "template",
"protection" : "public",
"line" : 32066,
"members" : [
{
"name" : "measureTime",
"kind" : "function",
"type" : "@safe ()",
"line" : 32066}
]
}
,
{
"name" : "measureTime(alias func) if (!isSafe!(delegate ()\n{\nStopWatch sw;\nunaryFun!(func)(sw.peek());\n}\n))",
"kind" : "template",
"protection" : "public",
"line" : 32084,
"members" : [
{
"name" : "measureTime",
"kind" : "function",
"type" : "()",
"line" : 32084}
]
}
,
{
"name" : "daysInYear",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"comment" : " The number of days in a non-leap year.\n",
"line" : 32159}
,
{
"name" : "daysInLeapYear",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"comment" : " The numbef or days in a leap year.\n",
"line" : 32160}
,
{
"name" : "daysIn4Years",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"comment" : " Number of days in 4 years.\n",
"line" : 32161}
,
{
"name" : "daysIn100Years",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"comment" : " The number of days in 100 years.\n",
"line" : 32162}
,
{
"name" : "daysIn400Years",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"comment" : " The number of days in 400 years.\n",
"line" : 32163}
,
{
"name" : "hnsecsPer(string units) if (CmpTimeUnits!(units,\"months\") < 0)",
"kind" : "template",
"protection" : "public",
"line" : 32173,
"members" : [
]
}
,
{
"name" : "splitUnitsFromHNSecs(string units) if (validTimeUnits(units) && CmpTimeUnits!(units,\"months\") < 0)",
"kind" : "template",
"protection" : "public",
"line" : 32220,
"members" : [
{
"name" : "splitUnitsFromHNSecs",
"kind" : "function",
"type" : "pure nothrow long(ref long hnsecs)",
"line" : 32220}
]
}
,
{
"name" : "getUnitsFromHNSecs(string units) if (validTimeUnits(units) && CmpTimeUnits!(units,\"months\") < 0)",
"kind" : "template",
"protection" : "public",
"line" : 32269,
"members" : [
{
"name" : "getUnitsFromHNSecs",
"kind" : "function",
"type" : "pure nothrow long(long hnsecs)",
"line" : 32269}
]
}
,
{
"name" : "removeUnitsFromHNSecs(string units) if (validTimeUnits(units) && CmpTimeUnits!(units,\"months\") < 0)",
"kind" : "template",
"protection" : "public",
"line" : 32311,
"members" : [
{
"name" : "removeUnitsFromHNSecs",
"kind" : "function",
"type" : "pure nothrow long(long hnsecs)",
"line" : 32311}
]
}
,
{
"name" : "maxDay",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow ubyte(int year, int month)",
"line" : 32340}
,
{
"name" : "getDayOfWeek",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow DayOfWeek(int day)",
"line" : 32428}
,
{
"name" : "monthToString",
"kind" : "function",
"protection" : "private",
"type" : "pure string(Month month, bool useLongName = true)",
"line" : 32497}
,
{
"name" : "monthFromString",
"kind" : "function",
"protection" : "private",
"type" : "Month(string monthStr)",
"line" : 32566}
,
{
"name" : "nextSmallerTimeUnits(string units) if (validTimeUnits(units) && timeStrings.front != units)",
"kind" : "template",
"protection" : "public",
"line" : 32672,
"members" : [
{
"name" : "nextSmallerTimeUnits",
"kind" : "variable",
"line" : 32676}
]
}
,
{
"name" : "nextLargerTimeUnits(string units) if (validTimeUnits(units) && timeStrings.back != units)",
"kind" : "template",
"protection" : "public",
"line" : 32709,
"members" : [
{
"name" : "nextLargerTimeUnits",
"kind" : "variable",
"line" : 32713}
]
}
,
{
"name" : "fracSecToISOString",
"kind" : "function",
"protection" : "private",
"type" : "nothrow string(int hnsecs)",
"line" : 32740}
,
{
"name" : "fracSecFromISOString(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"line" : 32798,
"members" : [
{
"name" : "fracSecFromISOString",
"kind" : "function",
"type" : "FracSec(in S isoString)",
"line" : 32798}
]
}
,
{
"name" : "hasMin(T)",
"kind" : "template",
"protection" : "public",
"line" : 32885,
"members" : [
{
"name" : "hasMin",
"kind" : "variable",
"line" : 32891}
]
}
,
{
"name" : "hasMax(T)",
"kind" : "template",
"protection" : "public",
"line" : 32918,
"members" : [
{
"name" : "hasMax",
"kind" : "variable",
"line" : 32924}
]
}
,
{
"name" : "hasOverloadedOpBinaryWithDuration(T)",
"kind" : "template",
"protection" : "public",
"line" : 32957,
"members" : [
{
"name" : "hasOverloadedOpBinaryWithDuration",
"kind" : "variable",
"line" : 32966}
]
}
,
{
"name" : "hasOverloadedOpAssignWithDuration(T)",
"kind" : "template",
"protection" : "public",
"line" : 32998,
"members" : [
{
"name" : "hasOverloadedOpAssignWithDuration",
"kind" : "variable",
"line" : 33007}
]
}
,
{
"name" : "hasOverloadedOpBinaryWithSelf(T)",
"kind" : "template",
"protection" : "public",
"line" : 33038,
"members" : [
{
"name" : "hasOverloadedOpBinaryWithSelf",
"kind" : "variable",
"line" : 33041}
]
}
,
{
"name" : "numToString",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow string(long value)",
"line" : 33069}
,
{
"name" : "_assertPred(string op,L,R) if ((op == \"<\" || op == \"<=\" || op == \"==\" || op == \"!=\" || op == \">=\" || op == \">\") && __traits(compiles,mixin(\"lhs \" ~ op ~ \" rhs\")) && _isPrintable!(L) && _isPrintable!(R))",
"kind" : "template",
"protection" : "public",
"line" : 33447,
"members" : [
{
"name" : "_assertPred",
"kind" : "function",
"type" : "void(L lhs, R rhs, lazy string msg = null, string file = __FILE__, size_t line = __LINE__)",
"line" : 33447}
]
}
,
{
"name" : "_assertPred(string func,string expected,L,R) if (func == \"opCmp\" && (expected == \"<\" || expected == \"==\" || expected == \">\") && __traits(compiles,lhs.opCmp(rhs)) && _isPrintable!(L) && _isPrintable!(R))",
"kind" : "template",
"protection" : "public",
"line" : 33565,
"members" : [
{
"name" : "_assertPred",
"kind" : "function",
"type" : "void(L lhs, R rhs, lazy string msg = null, string file = __FILE__, size_t line = __LINE__)",
"line" : 33565}
]
}
,
{
"name" : "_assertPred(string op,L,R,E) if ((op == \"+=\" || op == \"-=\" || op == \"*=\" || op == \"\/=\" || op == \"%=\" || op == \"^^=\" || op == \"&=\" || op == \"|=\" || op == \"^=\" || op == \"<<=\" || op == \">>=\" || op == \">>>=\" || op == \"~=\") && __traits(compiles,mixin(\"lhs \" ~ op ~ \" rhs\")) && __traits(compiles,mixin(\"(lhs \" ~ op ~ \" rhs) == expected\")) && _isPrintable!(L) && _isPrintable!(R))",
"kind" : "template",
"protection" : "public",
"line" : 33641,
"members" : [
{
"name" : "_assertPred",
"kind" : "function",
"type" : "void(L lhs, R rhs, E expected, lazy string msg = null, string file = __FILE__, size_t line = __LINE__)",
"line" : 33641}
]
}
,
{
"name" : "_isPrintable(T...)",
"kind" : "template",
"protection" : "public",
"line" : 33877,
"members" : [
]
}
]
}
,
{
"name" : "std.demangle",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/demangle.d",
"comment" : "\n Demangle D mangled names.\n\n Macros:\n  WIKI = Phobos\/StdDemangle\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Thomas Kuehne, Frits van Bommel\n Source:    $(PHOBOSSRC std\/_demangle.d)\n \n",
"members" : [
{
"name" : "MangleException",
"kind" : "class",
"protection" : "private",
"line" : 26,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MangleException()",
"line" : 28}
]
}
,
{
"name" : "demangle",
"kind" : "function",
"protection" : "public",
"type" : "string(string name)",
"comment" : "\n Demangle D mangled names.\n\n If it is not a D mangled name, it returns its argument name.\n Example:\n        This program reads standard in and writes it to standard out,\n        pretty-printing any found D mangled names.\n-------------------\nimport std.stdio;\nimport std.ascii;\nimport std.demangle;\n\nint main()\n{   char[] buffer;\n    bool inword;\n    int c;\n\n    while ((c = fgetc(stdin)) != EOF)\n    {\n        if (inword)\n        {\n            if (c == '_' || isAlphaNum(c))\n                buffer ~= cast(char) c;\n            else\n            {\n                inword = false;\n                writef(demangle(buffer), cast(char) c);\n            }\n        }\n        else\n        {   if (c == '_' || isAlpha(c))\n            {        inword = true;\n                buffer.length = 0;\n                buffer ~= cast(char) c;\n            }\n            else\n                writef(cast(char) c);\n        }\n    }\n    if (inword)\n        writef(demangle(buffer));\n    return 0;\n}\n-------------------\n \n",
"line" : 80}
]
}
,
{
"name" : "std.encoding",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/encoding.d",
"comment" : "\nClasses and functions for handling and transcoding between various encodings.\n\nFor cases where the _encoding is known at compile-time, functions are provided\nfor arbitrary _encoding and decoding of characters, arbitrary transcoding\nbetween strings of different type, as well as validation and sanitization.\n\nEncodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1\n(also known as LATIN-1), and WINDOWS-1252.\n\n$(UL\n$(LI The type $(D AsciiChar) represents an ASCII character.)\n$(LI The type $(D AsciiString) represents an ASCII string.)\n$(LI The type $(D Latin1Char) represents an ISO-8859-1 character.)\n$(LI The type $(D Latin1String) represents an ISO-8859-1 string.)\n$(LI The type $(D Windows1252Char) represents a Windows-1252 character.)\n$(LI The type $(D Windows1252String) represents a Windows-1252 string.))\n\nFor cases where the _encoding is not known at compile-time, but is\nknown at run-time, we provide the abstract class $(D EncodingScheme)\nand its subclasses.  To construct a run-time encoder\/decoder, one does\ne.g.\n\n----------------------------------------------------\n    auto e = EncodingScheme.create(\"utf-8\");\n----------------------------------------------------\n\nThis library supplies $(D EncodingScheme) subclasses for ASCII,\nISO-8859-1 (also known as LATIN-1), WINDOWS-1252, UTF-8, and (on\nlittle-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian\narchitectures) UTF-16BE and UTF-32BE.\n\nThis library provides a mechanism whereby other modules may add $(D\nEncodingScheme) subclasses for any other _encoding.\n\nMacros:\n    WIKI=Phobos\/StdEncoding\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std\/_encoding.d)\n",
"members" : [
{
"name" : "INVALID_SEQUENCE",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : " Special value returned by $(D safeDecode) \n",
"line" : 364}
,
{
"name" : "EncoderFunctions()",
"kind" : "template",
"protection" : "public",
"line" : 366,
"members" : [
{
"name" : "ReadFromString()",
"kind" : "template",
"protection" : "public",
"line" : 370,
"members" : [
{
"name" : "canRead",
"kind" : "function",
"type" : "bool()",
"line" : 372}
,
{
"name" : "peek",
"kind" : "function",
"type" : "E()",
"line" : 373}
,
{
"name" : "read",
"kind" : "function",
"type" : "E()",
"line" : 374}
]
}
,
{
"name" : "ReverseReadFromString()",
"kind" : "template",
"protection" : "public",
"line" : 377,
"members" : [
{
"name" : "canRead",
"kind" : "function",
"type" : "bool()",
"line" : 379}
,
{
"name" : "peek",
"kind" : "function",
"type" : "E()",
"line" : 380}
,
{
"name" : "read",
"kind" : "function",
"type" : "E()",
"line" : 381}
]
}
,
{
"name" : "WriteToString()",
"kind" : "template",
"protection" : "public",
"line" : 386,
"members" : [
{
"name" : "s",
"kind" : "variable",
"type" : "E[]",
"line" : 388}
,
{
"name" : "write",
"kind" : "function",
"type" : "void(E c)",
"line" : 389}
]
}
,
{
"name" : "WriteToArray()",
"kind" : "template",
"protection" : "public",
"line" : 392,
"members" : [
{
"name" : "write",
"kind" : "function",
"type" : "void(E c)",
"line" : 394}
]
}
,
{
"name" : "WriteToDelegate()",
"kind" : "template",
"protection" : "public",
"line" : 397,
"members" : [
{
"name" : "write",
"kind" : "function",
"type" : "void(E c)",
"line" : 399}
]
}
,
{
"name" : "EncodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 404,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 407}
]
}
,
{
"name" : "SkipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 410,
"members" : [
{
"name" : "skip",
"kind" : "function",
"type" : "void()",
"line" : 413}
]
}
,
{
"name" : "DecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 416,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "dchar()",
"line" : 419}
]
}
,
{
"name" : "SafeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 422,
"members" : [
{
"name" : "safeDecode",
"kind" : "function",
"type" : "dchar()",
"line" : 425}
]
}
,
{
"name" : "DecodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 428,
"members" : [
{
"name" : "decodeReverse",
"kind" : "function",
"type" : "dchar()",
"line" : 431}
]
}
,
{
"name" : "EncodeToString()",
"kind" : "template",
"protection" : "public",
"line" : 436,
"members" : [
]
}
,
{
"name" : "EncodeToArray()",
"kind" : "template",
"protection" : "public",
"line" : 442,
"members" : [
]
}
,
{
"name" : "EncodeToDelegate()",
"kind" : "template",
"protection" : "public",
"line" : 448,
"members" : [
]
}
,
{
"name" : "SkipFromString()",
"kind" : "template",
"protection" : "public",
"line" : 456,
"members" : [
]
}
,
{
"name" : "DecodeFromString()",
"kind" : "template",
"protection" : "public",
"line" : 462,
"members" : [
]
}
,
{
"name" : "SafeDecodeFromString()",
"kind" : "template",
"protection" : "public",
"line" : 468,
"members" : [
]
}
,
{
"name" : "DecodeReverseFromString()",
"kind" : "template",
"protection" : "public",
"line" : 474,
"members" : [
]
}
,
{
"name" : "encode",
"kind" : "function",
"type" : "E[](dchar c)",
"line" : 484}
,
{
"name" : "encode",
"kind" : "function",
"type" : "void(dchar c, ref E[] array)",
"line" : 491}
,
{
"name" : "encode",
"kind" : "function",
"type" : "void(dchar c, void delegate(E) dg)",
"line" : 497}
,
{
"name" : "skip",
"kind" : "function",
"type" : "void(ref const(E)[] s)",
"line" : 503}
,
{
"name" : "decode(S)",
"kind" : "template",
"protection" : "public",
"line" : 509,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "dchar(ref S s)",
"line" : 509}
]
}
,
{
"name" : "safeDecode(S)",
"kind" : "template",
"protection" : "public",
"line" : 515,
"members" : [
{
"name" : "safeDecode",
"kind" : "function",
"type" : "dchar(ref S s)",
"line" : 515}
]
}
,
{
"name" : "decodeReverse",
"kind" : "function",
"type" : "dchar(ref const(E)[] s)",
"line" : 521}
]
}
,
{
"name" : "CodePoints(E)",
"kind" : "struct",
"protection" : "public",
"line" : 531,
"members" : [
{
"name" : "CodePoints",
"kind" : "struct",
"protection" : "public",
"line" : 531,
"members" : [
{
"name" : "s",
"kind" : "variable",
"type" : "const(E)[]",
"line" : 532}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(const(E)[] s)",
"line" : 534}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope int delegate(ref dchar) dg)",
"line" : 544}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope int delegate(ref size_t, ref dchar) dg)",
"line" : 556}
,
{
"name" : "opApplyReverse",
"kind" : "function",
"type" : "int(scope int delegate(ref dchar) dg)",
"line" : 572}
,
{
"name" : "opApplyReverse",
"kind" : "function",
"type" : "int(scope int delegate(ref size_t, ref dchar) dg)",
"line" : 584}
]
}
]
}
,
{
"name" : "CodeUnits(E)",
"kind" : "struct",
"protection" : "public",
"line" : 599,
"members" : [
{
"name" : "CodeUnits",
"kind" : "struct",
"protection" : "public",
"line" : 599,
"members" : [
{
"name" : "s",
"kind" : "variable",
"type" : "E[]",
"line" : 600}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(dchar d)",
"line" : 602}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope int delegate(ref E) dg)",
"line" : 612}
,
{
"name" : "opApplyReverse",
"kind" : "function",
"type" : "int(scope int delegate(ref E) dg)",
"line" : 623}
]
}
]
}
,
{
"name" : "EncoderInstance(E)",
"kind" : "template",
"protection" : "public",
"line" : 637,
"members" : [
]
}
,
{
"name" : "AsciiChar",
"kind" : "enum",
"protection" : "public",
"comment" : " Defines various character sets. \n",
"line" : 648,
"base" : "ubyte",
"members" : [
{
"name" : "init",
"kind" : "enum member",
"protection" : "public",
"line" : 648}
]
}
,
{
"name" : "AsciiString",
"kind" : "alias",
"protection" : "public",
"type" : "immutable(AsciiChar)[]",
"comment" : " Ditto\n",
"line" : 650}
,
{
"name" : "EncoderInstance(CharType : AsciiChar)",
"kind" : "template",
"protection" : "public",
"line" : 652,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "AsciiChar",
"line" : 654}
,
{
"name" : "EString",
"kind" : "alias",
"type" : "AsciiString",
"line" : 655}
,
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 657}
,
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 662}
,
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(AsciiChar c)",
"line" : 667}
,
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"line" : 672}
,
{
"name" : "encodeX(Range)",
"kind" : "template",
"protection" : "public",
"line" : 682,
"members" : [
{
"name" : "encodeX",
"kind" : "function",
"type" : "void(dchar c, Range r)",
"line" : 682}
]
}
,
{
"name" : "encodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 688,
"members" : [
{
"name" : "encodeViaWrite",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 688}
]
}
,
{
"name" : "skipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 694,
"members" : [
{
"name" : "skipViaRead",
"kind" : "function",
"type" : "void()",
"line" : 694}
]
}
,
{
"name" : "decodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 699,
"members" : [
{
"name" : "decodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 699}
]
}
,
{
"name" : "safeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 704,
"members" : [
{
"name" : "safeDecodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 704}
]
}
,
{
"name" : "decodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 710,
"members" : [
{
"name" : "decodeReverseViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 710}
]
}
,
{
"name" : "replacementSequence",
"kind" : "function",
"type" : "EString()",
"line" : 715}
]
}
,
{
"name" : "Latin1Char",
"kind" : "enum",
"protection" : "public",
"comment" : " Defines an Latin1-encoded character. \n",
"line" : 728,
"base" : "ubyte",
"members" : [
{
"name" : "init",
"kind" : "enum member",
"protection" : "public",
"line" : 728}
]
}
,
{
"name" : "Latin1String",
"kind" : "alias",
"protection" : "public",
"type" : "immutable(Latin1Char)[]",
"comment" : "\nDefines an Latin1-encoded string (as an array of $(D\nimmutable(Latin1Char))).\n \n\n",
"line" : 733}
,
{
"name" : "EncoderInstance(CharType : Latin1Char)",
"kind" : "template",
"protection" : "public",
"line" : 735,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "Latin1Char",
"line" : 737}
,
{
"name" : "EString",
"kind" : "alias",
"type" : "Latin1String",
"line" : 738}
,
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 740}
,
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 745}
,
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(Latin1Char c)",
"line" : 750}
,
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"line" : 755}
,
{
"name" : "encodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 765,
"members" : [
{
"name" : "encodeViaWrite",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 765}
]
}
,
{
"name" : "skipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 771,
"members" : [
{
"name" : "skipViaRead",
"kind" : "function",
"type" : "void()",
"line" : 771}
]
}
,
{
"name" : "decodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 776,
"members" : [
{
"name" : "decodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 776}
]
}
,
{
"name" : "safeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 781,
"members" : [
{
"name" : "safeDecodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 781}
]
}
,
{
"name" : "decodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 786,
"members" : [
{
"name" : "decodeReverseViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 786}
]
}
,
{
"name" : "replacementSequence",
"kind" : "function",
"type" : "EString()",
"line" : 791}
]
}
,
{
"name" : "Windows1252Char",
"kind" : "enum",
"protection" : "public",
"comment" : " Defines a Windows1252-encoded character. \n",
"line" : 804,
"base" : "ubyte",
"members" : [
{
"name" : "init",
"kind" : "enum member",
"protection" : "public",
"line" : 804}
]
}
,
{
"name" : "Windows1252String",
"kind" : "alias",
"protection" : "public",
"type" : "immutable(Windows1252Char)[]",
"comment" : "\nDefines an Windows1252-encoded string (as an array of $(D\nimmutable(Windows1252Char))).\n \n\n",
"line" : 809}
,
{
"name" : "EncoderInstance(CharType : Windows1252Char)",
"kind" : "template",
"protection" : "public",
"line" : 811,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "Windows1252Char",
"line" : 813}
,
{
"name" : "EString",
"kind" : "alias",
"type" : "Windows1252String",
"line" : 814}
,
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 816}
,
{
"name" : "charMap",
"kind" : "variable",
"type" : "wstring",
"line" : 821}
,
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 828}
,
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(Windows1252Char c)",
"line" : 836}
,
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"line" : 842}
,
{
"name" : "encodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 852,
"members" : [
{
"name" : "encodeViaWrite",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 852}
]
}
,
{
"name" : "skipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 872,
"members" : [
{
"name" : "skipViaRead",
"kind" : "function",
"type" : "void()",
"line" : 872}
]
}
,
{
"name" : "decodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 877,
"members" : [
{
"name" : "decodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 877}
]
}
,
{
"name" : "safeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 883,
"members" : [
{
"name" : "safeDecodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 883}
]
}
,
{
"name" : "decodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 890,
"members" : [
{
"name" : "decodeReverseViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 890}
]
}
,
{
"name" : "replacementSequence",
"kind" : "function",
"type" : "EString()",
"line" : 896}
]
}
,
{
"name" : "EncoderInstance(CharType : char)",
"kind" : "template",
"protection" : "public",
"line" : 908,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "char",
"line" : 910}
,
{
"name" : "EString",
"kind" : "alias",
"type" : "immutable(char)[]",
"line" : 911}
,
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 913}
,
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 918}
,
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(char c)",
"line" : 923}
,
{
"name" : "tailTable",
"kind" : "variable",
"type" : "ubyte[128]",
"line" : 928}
,
{
"name" : "tails",
"kind" : "function",
"type" : "int(char c)",
"line" : 940}
,
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"line" : 950}
,
{
"name" : "encodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 963,
"members" : [
{
"name" : "encodeViaWrite",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 963}
]
}
,
{
"name" : "skipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 989,
"members" : [
{
"name" : "skipViaRead",
"kind" : "function",
"type" : "void()",
"line" : 989}
]
}
,
{
"name" : "decodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1000,
"members" : [
{
"name" : "decodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1000}
]
}
,
{
"name" : "safeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1013,
"members" : [
{
"name" : "safeDecodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1013}
]
}
,
{
"name" : "decodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1044,
"members" : [
{
"name" : "decodeReverseViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1044}
]
}
,
{
"name" : "replacementSequence",
"kind" : "function",
"type" : "EString()",
"line" : 1062}
]
}
,
{
"name" : "EncoderInstance(CharType : wchar)",
"kind" : "template",
"protection" : "public",
"line" : 1074,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "wchar",
"line" : 1076}
,
{
"name" : "EString",
"kind" : "alias",
"type" : "immutable(wchar)[]",
"line" : 1077}
,
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 1079}
,
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 1084}
,
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(wchar c)",
"line" : 1089}
,
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"line" : 1094}
,
{
"name" : "encodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 1104,
"members" : [
{
"name" : "encodeViaWrite",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 1104}
]
}
,
{
"name" : "skipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1118,
"members" : [
{
"name" : "skipViaRead",
"kind" : "function",
"type" : "void()",
"line" : 1118}
]
}
,
{
"name" : "decodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1125,
"members" : [
{
"name" : "decodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1125}
]
}
,
{
"name" : "safeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1135,
"members" : [
{
"name" : "safeDecodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1135}
]
}
,
{
"name" : "decodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1149,
"members" : [
{
"name" : "decodeReverseViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1149}
]
}
,
{
"name" : "replacementSequence",
"kind" : "function",
"type" : "EString()",
"line" : 1159}
]
}
,
{
"name" : "EncoderInstance(CharType : dchar)",
"kind" : "template",
"protection" : "public",
"line" : 1171,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "dchar",
"line" : 1173}
,
{
"name" : "EString",
"kind" : "alias",
"type" : "immutable(dchar)[]",
"line" : 1174}
,
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 1176}
,
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 1181}
,
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(dchar c)",
"line" : 1186}
,
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"line" : 1191}
,
{
"name" : "encodeViaWrite()",
"kind" : "template",
"protection" : "public",
"line" : 1201,
"members" : [
{
"name" : "encodeViaWrite",
"kind" : "function",
"type" : "void(dchar c)",
"line" : 1201}
]
}
,
{
"name" : "skipViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1206,
"members" : [
{
"name" : "skipViaRead",
"kind" : "function",
"type" : "void()",
"line" : 1206}
]
}
,
{
"name" : "decodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1211,
"members" : [
{
"name" : "decodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1211}
]
}
,
{
"name" : "safeDecodeViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1216,
"members" : [
{
"name" : "safeDecodeViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1216}
]
}
,
{
"name" : "decodeReverseViaRead()",
"kind" : "template",
"protection" : "public",
"line" : 1222,
"members" : [
{
"name" : "decodeReverseViaRead",
"kind" : "function",
"type" : "dchar()",
"line" : 1222}
]
}
,
{
"name" : "replacementSequence",
"kind" : "function",
"type" : "EString()",
"line" : 1227}
]
}
,
{
"name" : "isValidCodePoint",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\nReturns true if c is a valid code point\n\n Note that this includes the non-character code points U+FFFE and U+FFFF,\n since these are valid code points (even though they are not valid\n characters).\n\n Supercedes:\n This function supercedes $(D std.utf.startsValidDchar()).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be tested\n \n",
"line" : 1253}
,
{
"name" : "encodingName(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the name of an encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Examples:\n -----------------------------------\n assert(encodingName!(Latin1Char) == \"ISO-8859-1\");\n -----------------------------------\n \n",
"line" : 1271,
"members" : [
{
"name" : "encodingName",
"kind" : "function",
"type" : "string()",
"line" : 1271}
]
}
,
{
"name" : "canEncode(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns true iff it is possible to represent the specifed codepoint\n in the encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Examples:\n -----------------------------------\n assert(canEncode!(Latin1Char)('A'));\n -----------------------------------\n \n",
"line" : 1300,
"members" : [
{
"name" : "canEncode",
"kind" : "function",
"type" : "bool(dchar c)",
"comment" : "\n Returns true iff it is possible to represent the specifed codepoint\n in the encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Examples:\n -----------------------------------\n assert(canEncode!(Latin1Char)('A'));\n -----------------------------------\n \n",
"line" : 1300}
]
}
,
{
"name" : "isValidCodeUnit(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns true if the code unit is legal. For example, the byte 0x80 would\n not be legal in ASCII, because ASCII code units must always be in the range\n 0x00 to 0x7F.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code unit to be tested\n \n",
"line" : 1325,
"members" : [
{
"name" : "isValidCodeUnit",
"kind" : "function",
"type" : "bool(E c)",
"comment" : "\n Returns true if the code unit is legal. For example, the byte 0x80 would\n not be legal in ASCII, because ASCII code units must always be in the range\n 0x00 to 0x7F.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code unit to be tested\n \n",
"line" : 1325}
]
}
,
{
"name" : "isValid(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns true if the string is encoded correctly\n\n Supercedes:\n This function supercedes std.utf.validate(), however note that this\n function returns a bool indicating whether the input was valid or not,\n wheras the older funtion would throw an exception.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
"line" : 1354,
"members" : [
{
"name" : "isValid",
"kind" : "function",
"type" : "bool(const(E)[] s)",
"comment" : "\n Returns true if the string is encoded correctly\n\n Supercedes:\n This function supercedes std.utf.validate(), however note that this\n function returns a bool indicating whether the input was valid or not,\n wheras the older funtion would throw an exception.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
"line" : 1354}
]
}
,
{
"name" : "validLength(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the length of the longest possible substring, starting from\n the first code unit, which is validly encoded.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
"line" : 1373,
"members" : [
{
"name" : "validLength",
"kind" : "function",
"type" : "size_t(const(E)[] s)",
"comment" : "\n Returns the length of the longest possible substring, starting from\n the first code unit, which is validly encoded.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
"line" : 1373}
]
}
,
{
"name" : "sanitize(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Sanitizes a string by replacing malformed code unit sequences with valid\n code unit sequences. The result is guaranteed to be valid for this encoding.\n\n If the input string is already valid, this function returns the original,\n otherwise it constructs a new string by replacing all illegal code unit\n sequences with the encoding's replacement character, Invalid sequences will\n be replaced with the Unicode replacement character (U+FFFD) if the\n character repertoire contains it, otherwise invalid sequences will be\n replaced with '?'.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sanitized\n \n",
"line" : 1401,
"members" : [
{
"name" : "sanitize",
"kind" : "function",
"type" : "immutable(E)[](immutable(E)[] s)",
"comment" : "\n Sanitizes a string by replacing malformed code unit sequences with valid\n code unit sequences. The result is guaranteed to be valid for this encoding.\n\n If the input string is already valid, this function returns the original,\n otherwise it constructs a new string by replacing all illegal code unit\n sequences with the encoding's replacement character, Invalid sequences will\n be replaced with the Unicode replacement character (U+FFFD) if the\n character repertoire contains it, otherwise invalid sequences will be\n replaced with '?'.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sanitized\n \n",
"line" : 1401}
]
}
,
{
"name" : "firstSequence(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the length of the first encoded sequence.\n\nThe input to this function MUST be validly encoded.\nThis is enforced by the function's in-contract.\n\nStandards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\nParams:\ns = the string to be sliced\n \n",
"line" : 1456,
"members" : [
{
"name" : "firstSequence",
"kind" : "function",
"type" : "size_t(const(E)[] s)",
"comment" : "\nReturns the length of the first encoded sequence.\n\nThe input to this function MUST be validly encoded.\nThis is enforced by the function's in-contract.\n\nStandards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\nParams:\ns = the string to be sliced\n \n",
"line" : 1456}
]
}
,
{
"name" : "lastSequence(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the length the last encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sliced\n \n",
"line" : 1486,
"members" : [
{
"name" : "lastSequence",
"kind" : "function",
"type" : "size_t(const(E)[] s)",
"comment" : "\n Returns the length the last encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sliced\n \n",
"line" : 1486}
]
}
,
{
"name" : "index(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTFindex().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be counted\n \n",
"line" : 1518,
"members" : [
{
"name" : "index",
"kind" : "function",
"type" : "sizediff_t(const(E)[] s, int n)",
"comment" : "\n Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTFindex().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be counted\n \n",
"line" : 1518}
]
}
,
{
"name" : "decode(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Decodes a single code point.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.decode(), however, note that the\n function codePoints() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
"line" : 1554,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "dchar(ref S s)",
"comment" : "\n Decodes a single code point.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.decode(), however, note that the\n function codePoints() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
"line" : 1554}
]
}
,
{
"name" : "decodeReverse(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Decodes a single code point from the end of a string.\n\n This function removes one or more code units from the end of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
"line" : 1580,
"members" : [
{
"name" : "decodeReverse",
"kind" : "function",
"type" : "dchar(ref const(E)[] s)",
"comment" : "\n Decodes a single code point from the end of a string.\n\n This function removes one or more code units from the end of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
"line" : 1580}
]
}
,
{
"name" : "safeDecode(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n This function will accept an invalidly encoded string as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
"line" : 1606,
"members" : [
{
"name" : "safeDecode",
"kind" : "function",
"type" : "dchar(ref S s)",
"comment" : "\n Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n This function will accept an invalidly encoded string as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
"line" : 1606}
]
}
,
{
"name" : "encodedLength(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the number of code units required to encode a single code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
"line" : 1630,
"members" : [
{
"name" : "encodedLength",
"kind" : "function",
"type" : "size_t(dchar c)",
"comment" : "\n Returns the number of code units required to encode a single code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
"line" : 1630}
]
}
,
{
"name" : "encode(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes a single code point.\n\n This function encodes a single code point into one or more code units.\n It returns a string containing those code units.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
"line" : 1661,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "E[](dchar c)",
"comment" : "\n Encodes a single code point.\n\n This function encodes a single code point into one or more code units.\n It returns a string containing those code units.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
"line" : 1661}
]
}
,
{
"name" : "encode(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes a single code point into an array.\n\n This function encodes a single code point into one or more code units\n The code units are stored in a user-supplied fixed-size array,\n which must be passed by reference.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n          the number of code units written to the array\n \n",
"line" : 1696,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "size_t(dchar c, E[] array)",
"comment" : "\n Encodes a single code point into an array.\n\n This function encodes a single code point into one or more code units\n The code units are stored in a user-supplied fixed-size array,\n which must be passed by reference.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n          the number of code units written to the array\n \n",
"line" : 1696}
]
}
,
{
"name" : "encode(E,R)",
"kind" : "template",
"protection" : "public",
"line" : 1744,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "size_t(dchar c, R range)",
"line" : 1744}
]
}
,
{
"name" : "encode(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes a single code point to a delegate.\n\n This function encodes a single code point into one or more code units.\n The code units are passed one at a time to the supplied delegate.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
"line" : 1822,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "void(dchar c, void delegate(E) dg)",
"comment" : "\n Encodes a single code point to a delegate.\n\n This function encodes a single code point into one or more code units.\n The code units are passed one at a time to the supplied delegate.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
"line" : 1822}
]
}
,
{
"name" : "codePoints(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code points in a string.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n You can foreach either\n with or without an index. If an index is specified, it will be initialized\n at each iteration with the offset into the string at which the code point\n begins.\n\n Supercedes:\n This function supercedes std.utf.decode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be decoded\n\n Examples:\n --------------------------------------------------------\n string s = \"hello world\";\n foreach(c;codePoints(s))\n {\n     \/\/ do something with c (which will always be a dchar)\n }\n --------------------------------------------------------\n\n Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)\n in that the latter will fall over on encountering U+FFFF.\n \n",
"line" : 1864,
"members" : [
{
"name" : "codePoints",
"kind" : "function",
"type" : "CodePoints!(E)(immutable(E)[] s)",
"comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code points in a string.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n You can foreach either\n with or without an index. If an index is specified, it will be initialized\n at each iteration with the offset into the string at which the code point\n begins.\n\n Supercedes:\n This function supercedes std.utf.decode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be decoded\n\n Examples:\n --------------------------------------------------------\n string s = \"hello world\";\n foreach(c;codePoints(s))\n {\n     \/\/ do something with c (which will always be a dchar)\n }\n --------------------------------------------------------\n\n Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)\n in that the latter will fall over on encountering U+FFFF.\n \n",
"line" : 1864}
]
}
,
{
"name" : "codeUnits(E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code units in a code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type in the template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    d = the code point to be encoded\n\n Examples:\n --------------------------------------------------------\n dchar d = '\\u20AC';\n foreach(c;codeUnits!(char)(d))\n {\n     writefln(\"%X\",c)\n }\n \/\/ will print\n \/\/ E2\n \/\/ 82\n \/\/ AC\n --------------------------------------------------------\n \n",
"line" : 1916,
"members" : [
{
"name" : "codeUnits",
"kind" : "function",
"type" : "CodeUnits!(E)(dchar c)",
"comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code units in a code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type in the template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    d = the code point to be encoded\n\n Examples:\n --------------------------------------------------------\n dchar d = '\\u20AC';\n foreach(c;codeUnits!(char)(d))\n {\n     writefln(\"%X\",c)\n }\n \/\/ will print\n \/\/ E2\n \/\/ 82\n \/\/ AC\n --------------------------------------------------------\n \n",
"line" : 1916}
]
}
,
{
"name" : "encode(Tgt,Src,R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nEncodes $(D c) in units of type $(D E) and writes the result to the\noutput range $(D R). Returns the number of $(D E)s written.\n \n",
"line" : 1944,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "size_t(in Src[] s, R range)",
"comment" : "\nEncodes $(D c) in units of type $(D E) and writes the result to the\noutput range $(D R). Returns the number of $(D E)s written.\n \n",
"line" : 1944}
]
}
,
{
"name" : "transcode(Src,Dst)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Convert a string from one encoding to another. (See also to!() below).\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and\n std.utf.toUTF32()\n (but note that to!() supercedes it more conveniently).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the source string\n    r = the destination string\n\n Examples:\n --------------------------------------------------------\n wstring ws;\n transcode(\"hello world\",ws);\n     \/\/ transcode from UTF-8 to UTF-16\n\n Latin1String ls;\n transcode(ws, ls);\n     \/\/ transcode from UTF-16 to ISO-8859-1\n  --------------------------------------------------------\n \n",
"line" : 1982,
"members" : [
{
"name" : "transcode",
"kind" : "function",
"type" : "void(immutable(Src)[] s, out immutable(Dst)[] r)",
"comment" : "\n Convert a string from one encoding to another. (See also to!() below).\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and\n std.utf.toUTF32()\n (but note that to!() supercedes it more conveniently).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the source string\n    r = the destination string\n\n Examples:\n --------------------------------------------------------\n wstring ws;\n transcode(\"hello world\",ws);\n     \/\/ transcode from UTF-8 to UTF-16\n\n Latin1String ls;\n transcode(ws, ls);\n     \/\/ transcode from UTF-16 to ISO-8859-1\n  --------------------------------------------------------\n \n",
"line" : 1982}
]
}
,
{
"name" : "EncodingException",
"kind" : "class",
"protection" : "public",
"comment" : " The base class for exceptions thrown by this module \n",
"line" : 2045,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "EncodingException(string msg)",
"line" : 2045}
]
}
,
{
"name" : "UnrecognizedEncodingException",
"kind" : "class",
"protection" : "public",
"line" : 2047,
"base" : "EncodingException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "UnrecognizedEncodingException(string msg)",
"line" : 2049}
]
}
,
{
"name" : "EncodingScheme",
"kind" : "class",
"protection" : "public",
"comment" : " Abstract base class of all encoding schemes \n",
"line" : 2054,
"base" : "Object",
"members" : [
{
"name" : "register",
"kind" : "function",
"protection" : "public",
"type" : "void(string className)",
"comment" : "\n Registers a subclass of EncodingScheme.\n\n This function allows user-defined subclasses of EncodingScheme to\n be declared in other modules.\n\n Examples:\n ----------------------------------------------\n class Amiga1251 : EncodingScheme\n {\n     shared static this()\n     {\n         EncodingScheme.register(\"path.to.Amiga1251\");\n     }\n }\n ----------------------------------------------\n     \n",
"line" : 2072}
,
{
"name" : "create",
"kind" : "function",
"protection" : "public",
"type" : "EncodingScheme(string encodingName)",
"comment" : "\n Obtains a subclass of EncodingScheme which is capable of encoding\n and decoding the named encoding scheme.\n\n This function is only aware of EncodingSchemes which have been\n registered with the register() function.\n\n Examples:\n ---------------------------------------------------\n auto scheme = EncodingScheme.create(\"Amiga-1251\");\n ---------------------------------------------------\n     \n",
"line" : 2095}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns the standard name of the encoding scheme\n         \n",
"line" : 2111}
,
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"comment" : "\n Returns an array of all known names for this encoding scheme\n         \n",
"line" : 2116}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"comment" : "\n Returns true if the character c can be represented\n in this encoding scheme.\n         \n",
"line" : 2122}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"comment" : "\n Returns the number of ubytes required to encode this code point.\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n    the number of ubytes required.\n         \n",
"line" : 2135}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"comment" : "\n Encodes a single code point into a user-supplied, fixed-size buffer.\n\n This function encodes a single code point into one or more ubytes.\n The supplied buffer must be code unit aligned.\n (For example, UTF-16LE or UTF-16BE must be wchar-aligned,\n UTF-32LE or UTF-32BE must be dchar-aligned, etc.)\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n    the number of ubytes written.\n         \n",
"line" : 2153}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"comment" : "\n Decodes a single code point.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n The input to this function MUST be validly encoded.\n\n Params:\n    s = the array whose first code point is to be decoded\n         \n",
"line" : 2166}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"comment" : "\n Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n This function will accept an invalidly encoded array as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Params:\n    s = the array whose first code point is to be decoded\n         \n",
"line" : 2181}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"comment" : "\n Returns the sequence of ubytes to be used to represent\n any character which cannot be represented in the encoding scheme.\n\n Normally this will be a representation of some substitution\n character, such as U+FFFD or '?'.\n         \n",
"line" : 2190}
,
{
"name" : "isValid",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(ubyte)[] s)",
"comment" : "\n Returns true if the array is encoded correctly\n\n Params:\n    s = the array to be tested\n     \n",
"line" : 2199}
,
{
"name" : "validLength",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(ubyte)[] s)",
"comment" : "\n Returns the length of the longest possible substring, starting from\n the first element, which is validly encoded.\n\n Params:\n    s = the array to be tested\n     \n",
"line" : 2217}
,
{
"name" : "sanitize",
"kind" : "function",
"protection" : "public",
"type" : "immutable(ubyte)[](immutable(ubyte)[] s)",
"comment" : "\n Sanitizes an array by replacing malformed ubyte sequences with valid\n ubyte sequences. The result is guaranteed to be valid for this\n encoding scheme.\n\n If the input array is already valid, this function returns the\n original, otherwise it constructs a new array by replacing all illegal\n sequences with the encoding scheme's replacement sequence.\n\n Params:\n    s = the string to be sanitized\n     \n",
"line" : 2241}
,
{
"name" : "firstSequence",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(ubyte)[] s)",
"comment" : "\n Returns the length of the first encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the array to be sliced\n     \n",
"line" : 2289}
,
{
"name" : "count",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(ubyte)[] s)",
"comment" : "\n Returns the total number of code points encoded in a ubyte array.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n     \n",
"line" : 2312}
,
{
"name" : "index",
"kind" : "function",
"protection" : "public",
"type" : "long(const(ubyte)[] s, ulong n)",
"comment" : "\n Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n     \n",
"line" : 2337}
,
{
"name" : "supported",
"kind" : "variable",
"protection" : "public",
"type" : "string[string]",
"line" : 2350}
]
}
,
{
"name" : "EncodingSchemeASCII",
"kind" : "class",
"protection" : "public",
"comment" : "\n EncodingScheme to handle ASCII\n\n This scheme recognises the following names:\n                 \"ANSI_X3.4-1968\",\n                 \"ANSI_X3.4-1986\",\n                 \"ASCII\",\n                 \"IBM367\",\n                 \"ISO646-US\",\n                 \"ISO_646.irv:1991\",\n                 \"US-ASCII\",\n                 \"cp367\",\n                 \"csASCII\"\n                 \"iso-ir-6\",\n                 \"us\"\n \n",
"line" : 2369,
"base" : "EncodingScheme",
"members" : [
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"line" : 2378}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2397}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"line" : 2402}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"line" : 2407}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"line" : 2412}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2418}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2426}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"line" : 2434}
]
}
,
{
"name" : "EncodingSchemeLatin1",
"kind" : "class",
"protection" : "public",
"comment" : "\n EncodingScheme to handle Latin-1\n\n This scheme recognises the following names:\n                 \"CP819\",\n                 \"IBM819\",\n                 \"ISO-8859-1\",\n                 \"ISO_8859-1\",\n                 \"ISO_8859-1:1987\",\n                 \"csISOLatin1\",\n                 \"iso-ir-100\",\n                 \"l1\",\n                 \"latin1\"\n \n",
"line" : 2455,
"base" : "EncodingScheme",
"members" : [
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"line" : 2464}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2481}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"line" : 2486}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"line" : 2491}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"line" : 2496}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2502}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2510}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"line" : 2518}
]
}
,
{
"name" : "EncodingSchemeWindows1252",
"kind" : "class",
"protection" : "public",
"comment" : "\n EncodingScheme to handle Windows-1252\n\n This scheme recognises the following names:\n                 \"windows-1252\"\n \n",
"line" : 2531,
"base" : "EncodingScheme",
"members" : [
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"line" : 2540}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2549}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"line" : 2554}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"line" : 2559}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"line" : 2564}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2570}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2578}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"line" : 2586}
]
}
,
{
"name" : "EncodingSchemeUtf8",
"kind" : "class",
"protection" : "public",
"comment" : "\n EncodingScheme to handle UTF-8\n\n This scheme recognises the following names:\n                 \"UTF-8\"\n \n",
"line" : 2599,
"base" : "EncodingScheme",
"members" : [
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"line" : 2608}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2617}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"line" : 2622}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"line" : 2627}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"line" : 2632}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2638}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2646}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"line" : 2654}
]
}
,
{
"name" : "EncodingSchemeUtf16Native",
"kind" : "class",
"protection" : "public",
"comment" : "\n EncodingScheme to handle UTF-16 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-16LE\" (little-endian architecture only)\n                 \"UTF-16BE\" (big-endian architecture only)\n \n",
"line" : 2668,
"base" : "EncodingScheme",
"members" : [
{
"name" : "NAME",
"kind" : "variable",
"protection" : "public",
"type" : "const(immutable(char)[])",
"line" : 2677}
,
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"line" : 2680}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2685}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"line" : 2690}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"line" : 2695}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"line" : 2700}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2706}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2719}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"line" : 2732}
]
}
,
{
"name" : "EncodingSchemeUtf32Native",
"kind" : "class",
"protection" : "public",
"comment" : "\n EncodingScheme to handle UTF-32 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-32LE\" (little-endian architecture only)\n                 \"UTF-32BE\" (big-endian architecture only)\n \n",
"line" : 2746,
"base" : "EncodingScheme",
"members" : [
{
"name" : "NAME",
"kind" : "variable",
"protection" : "public",
"type" : "const(immutable(char)[])",
"line" : 2755}
,
{
"name" : "names",
"kind" : "function",
"protection" : "public",
"type" : "const string[]()",
"line" : 2758}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2763}
,
{
"name" : "canEncode",
"kind" : "function",
"protection" : "public",
"type" : "const bool(dchar c)",
"line" : 2768}
,
{
"name" : "encodedLength",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c)",
"line" : 2773}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "const ulong(dchar c, ubyte[] buffer)",
"line" : 2778}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2784}
,
{
"name" : "safeDecode",
"kind" : "function",
"protection" : "public",
"type" : "const dchar(ref const(ubyte)[] s)",
"line" : 2797}
,
{
"name" : "replacementSequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property immutable(ubyte)[]()",
"line" : 2810}
]
}
]
}
,
{
"name" : "std.exception",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/exception.d",
"comment" : "\n    This module defines functions related to exceptions and general error\n    handling. It also defines functions intended to aid in unit testing.\n\n    Synopsis of some of std.exception's functions:\n--------------------\nstring synopsis()\n{\n   FILE* f = enforce(fopen(\"some\/file\"));\n   \/\/ f is not null from here on\n   FILE* g = enforceEx!WriteException(fopen(\"some\/other\/file\", \"w\"));\n   \/\/ g is not null from here on\n\n   Exception e = collectException(write(g, readln(f)));\n   if (e)\n   {\n       ... an exception occurred...\n       ... We have the exception to play around with...\n   }\n\n   string msg = collectExceptionMsg(write(g, readln(f)));\n   if (msg)\n   {\n       ... an exception occurred...\n       ... We have the message from the exception but not the exception...\n   }\n\n   char[] line;\n   enforce(readln(f, line));\n   return assumeUnique(line);\n}\n--------------------\n\n    Macros:\n        WIKI = Phobos\/StdException\n\n    Copyright: Copyright Andrei Alexandrescu 2008-, Jonathan M Davis 2011-.\n    License:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0)\n    Authors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std\/_exception.d)\n\n \n",
"members" : [
{
"name" : "assertNotThrown(T : Throwable = Exception,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Asserts that the given expression does $(I not) throw the given type\n    of $(D Throwable). If a $(D Throwable) of the given type is thrown,\n    it is caught and does not escape assertNotThrown. Rather, an\n    $(D AssertError) is thrown. However, any other $(D Throwable)s will escape.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is thrown.\n\n    Examples:\n--------------------\nassertNotThrown!StringException(enforceEx!StringException(true, \"Error!\"));\n\n\/\/Exception is the default.\nassertNotThrown(enforceEx!StringException(true, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertNotThrown!StringException(\n           enforceEx!StringException(false, \"Error!\"))) ==\n       `assertNotThrown failed: StringException was thrown.`);\n--------------------\n  \n",
"line" : 76,
"members" : [
{
"name" : "assertNotThrown",
"kind" : "function",
"type" : "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
"comment" : "\n    Asserts that the given expression does $(I not) throw the given type\n    of $(D Throwable). If a $(D Throwable) of the given type is thrown,\n    it is caught and does not escape assertNotThrown. Rather, an\n    $(D AssertError) is thrown. However, any other $(D Throwable)s will escape.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is thrown.\n\n    Examples:\n--------------------\nassertNotThrown!StringException(enforceEx!StringException(true, \"Error!\"));\n\n\/\/Exception is the default.\nassertNotThrown(enforceEx!StringException(true, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertNotThrown!StringException(\n           enforceEx!StringException(false, \"Error!\"))) ==\n       `assertNotThrown failed: StringException was thrown.`);\n--------------------\n  \n",
"line" : 76}
]
}
,
{
"name" : "assertThrown(T : Throwable = Exception,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Asserts that the given expression throws the given type of $(D Throwable).\n    The $(D Throwable) is caught and does not escape assertThrown. However,\n    any other $(D Throwable)s $(I will) escape, and if no $(D Throwable)\n    of the given type is thrown, then an $(D AssertError) is thrown.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is not thrown.\n\n    Examples:\n--------------------\nassertThrown!StringException(enforceEx!StringException(false, \"Error!\"));\n\n\/\/Exception is the default.\nassertThrown(enforceEx!StringException(false, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertThrown!StringException(\n           enforceEx!StringException(true, \"Error!\"))) ==\n       `assertThrown failed: No StringException was thrown.`);\n--------------------\n  \n",
"line" : 219,
"members" : [
{
"name" : "assertThrown",
"kind" : "function",
"type" : "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
"comment" : "\n    Asserts that the given expression throws the given type of $(D Throwable).\n    The $(D Throwable) is caught and does not escape assertThrown. However,\n    any other $(D Throwable)s $(I will) escape, and if no $(D Throwable)\n    of the given type is thrown, then an $(D AssertError) is thrown.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is not thrown.\n\n    Examples:\n--------------------\nassertThrown!StringException(enforceEx!StringException(false, \"Error!\"));\n\n\/\/Exception is the default.\nassertThrown(enforceEx!StringException(false, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertThrown!StringException(\n           enforceEx!StringException(true, \"Error!\"))) ==\n       `assertThrown failed: No StringException was thrown.`);\n--------------------\n  \n",
"line" : 219}
]
}
,
{
"name" : "enforce(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new Exception(msg)) is thrown.\n\n    Note:\n        $(D enforce) is used to throw exceptions and is therefore intended to\n        aid in error handling. It is $(I not) intended for verifying the logic\n        of your program. That is what $(D assert) is for. Also, do not use\n        $(D enforce) inside of contracts (i.e. inside of $(D in) and $(D out)\n        blocks and $(D invariant)s), because they will be compiled out when\n        compiling with $(I -release). Use $(D assert) in contracts.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, \"Expected a non-empty line.\");\n--------------------\n \n",
"line" : 356,
"members" : [
{
"name" : "enforce",
"kind" : "function",
"type" : "pure @safe T(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__)",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new Exception(msg)) is thrown.\n\n    Note:\n        $(D enforce) is used to throw exceptions and is therefore intended to\n        aid in error handling. It is $(I not) intended for verifying the logic\n        of your program. That is what $(D assert) is for. Also, do not use\n        $(D enforce) inside of contracts (i.e. inside of $(D in) and $(D out)\n        blocks and $(D invariant)s), because they will be compiled out when\n        compiling with $(I -release). Use $(D assert) in contracts.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, \"Expected a non-empty line.\");\n--------------------\n \n",
"line" : 356}
]
}
,
{
"name" : "enforce(T,string file,ulong line = __LINE__)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   $(RED Scheduled for deprecation in January 2013. If passing the file or line\n         number explicitly, please use the version of enforce which takes them as\n         function arguments. Taking them as template arguments causes\n         unnecessary template bloat.)\n \n",
"line" : 368,
"members" : [
{
"name" : "enforce",
"kind" : "function",
"type" : "pure @safe T(T value, lazy const(char)[] msg = null)",
"comment" : "\n   $(RED Scheduled for deprecation in January 2013. If passing the file or line\n         number explicitly, please use the version of enforce which takes them as\n         function arguments. Taking them as template arguments causes\n         unnecessary template bloat.)\n \n",
"line" : 368}
]
}
,
{
"name" : "enforce(T,Dg,string file = __FILE__,ulong line = __LINE__) if (is(Dg : void delegate()) || is(Dg : void function()))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, the given\n    delegate is called.\n\n    The whole safety and purity are inferred from $(D Dg)'s safety and purity.\n \n",
"line" : 381,
"members" : [
{
"name" : "enforce",
"kind" : "function",
"type" : "T(T value, scope Dg dg)",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, the given\n    delegate is called.\n\n    The whole safety and purity are inferred from $(D Dg)'s safety and purity.\n \n",
"line" : 381}
]
}
,
{
"name" : "bailOut",
"kind" : "function",
"protection" : "private",
"type" : "pure @safe void(string file, ulong line, const(char[]) msg)",
"line" : 389}
,
{
"name" : "enforce(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, $(D ex) is thrown.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, new IOException); \/\/ expect a non-empty line\n--------------------\n \n",
"line" : 457,
"members" : [
{
"name" : "enforce",
"kind" : "function",
"type" : "pure @safe T(T value, lazy Throwable ex)",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, $(D ex) is thrown.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, new IOException); \/\/ expect a non-empty line\n--------------------\n \n",
"line" : 457}
]
}
,
{
"name" : "errnoEnforce(T,string file = __FILE__,ulong line = __LINE__)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new ErrnoException(msg)) is thrown. $(D ErrnoException) assumes that the\n    last operation set $(D errno) to an error code.\n\n   Example:\n--------------------\nauto f = errnoEnforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length); \/\/ expect a non-empty line\n--------------------\n \n",
"line" : 481,
"members" : [
{
"name" : "errnoEnforce",
"kind" : "function",
"type" : "pure @safe T(T value, lazy string msg = null)",
"comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new ErrnoException(msg)) is thrown. $(D ErrnoException) assumes that the\n    last operation set $(D errno) to an error code.\n\n   Example:\n--------------------\nauto f = errnoEnforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length); \/\/ expect a non-empty line\n--------------------\n \n",
"line" : 481}
]
}
,
{
"name" : "enforceEx(E) if (is(typeof(new E(\"\",\"\/usr\/include\/dmd\/phobos\/std\/exception.d\",503))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D !!value) is $(D true), $(D value) is returned. Otherwise,\n    $(D new E(msg, file, line)) is thrown. Or if $(D E) doesn't take a message\n    and can be constructed with $(D new E(file, line)), then\n    $(D new E(file, line)) will be thrown.\n\n   Example:\n--------------------\n auto f = enforceEx!FileMissingException(fopen(\"data.txt\"));\n auto line = readln(f);\n enforceEx!DataCorruptionException(line.length);\n--------------------\n \n",
"line" : 502,
"members" : [
{
"name" : "enforceEx(T)",
"kind" : "template",
"protection" : "public",
"line" : 505,
"members" : [
{
"name" : "enforceEx",
"kind" : "function",
"type" : "pure @safe T(T value, lazy string msg = \"\", string file = __FILE__, size_t line = __LINE__)",
"line" : 505}
]
}
]
}
,
{
"name" : "enforceEx(E) if (is(typeof(new E(\"\/usr\/include\/dmd\/phobos\/std\/exception.d\",513))) && !is(typeof(new E(\"\",\"\/usr\/include\/dmd\/phobos\/std\/exception.d\",513))))",
"kind" : "template",
"protection" : "public",
"line" : 512,
"members" : [
{
"name" : "enforceEx(T)",
"kind" : "template",
"protection" : "public",
"line" : 515,
"members" : [
{
"name" : "enforceEx",
"kind" : "function",
"type" : "pure @safe T(T value, string file = __FILE__, size_t line = __LINE__)",
"line" : 515}
]
}
]
}
,
{
"name" : "enforceEx(E) if (is(typeof(new E(\"\"))) && !is(typeof(new E(\"\",\"\/usr\/include\/dmd\/phobos\/std\/exception.d\",531))) && !is(typeof(new E(\"\/usr\/include\/dmd\/phobos\/std\/exception.d\",531))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in October 2012. Please use the version\n          of $(D enforceEx) which takes an exception that constructs with\n          $(D new E(msg, file, line)).)\n\n    If $(D !!value) is $(D true), $(D value) is returned. Otherwise,\n    $(D new E(msg)) is thrown.\n  \n",
"line" : 530,
"members" : [
{
"name" : "enforceEx(T)",
"kind" : "template",
"protection" : "public",
"line" : 533,
"members" : [
{
"name" : "enforceEx",
"kind" : "function",
"type" : "pure @safe T(T value, lazy string msg = \"\")",
"line" : 533}
]
}
]
}
,
{
"name" : "collectException(T = Exception,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned and $(D result) is\n    set to the result of the expression.\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n        result     = The result of the expression if no exception is thrown.\n\n    Example:\n--------------------\nint[] a = new int[3];\nint b;\nassert(collectException(a[4], b));\n--------------------\n",
"line" : 595,
"members" : [
{
"name" : "collectException",
"kind" : "function",
"type" : "T(lazy E expression, ref E result)",
"comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned and $(D result) is\n    set to the result of the expression.\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n        result     = The result of the expression if no exception is thrown.\n\n    Example:\n--------------------\nint[] a = new int[3];\nint b;\nassert(collectException(a[4], b));\n--------------------\n",
"line" : 595}
]
}
,
{
"name" : "collectException(T : Throwable = Exception,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned. $(D E) can be\n    $(D void).\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n",
"line" : 632,
"members" : [
{
"name" : "collectException",
"kind" : "function",
"type" : "T(lazy E expression)",
"comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned. $(D E) can be\n    $(D void).\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n",
"line" : 632}
]
}
,
{
"name" : "collectExceptionMsg(T = Exception,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Catches the exception thrown from the given expression and returns the\n    msg property of that exception. If no exception is thrown, then null is\n    returned. $(D E) can be $(D void).\n\n    If an exception is thrown but it has an empty message, then\n    $(D emptyExceptionMsg) is returned.\n\n    Note that while $(D collectExceptionMsg) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectExceptionMsg) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n\n    Examples:\n--------------------\nvoid throwFunc() {throw new Exception(\"My Message.\");}\nassert(collectExceptionMsg(throwFunc()) == \"My Message.\");\n\nvoid nothrowFunc() {}\nassert(collectExceptionMsg(nothrowFunc()) is null);\n\nvoid throwEmptyFunc() {throw new Exception(\"\");}\nassert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);\n--------------------\n",
"line" : 682,
"members" : [
{
"name" : "collectExceptionMsg",
"kind" : "function",
"type" : "string(lazy E expression)",
"comment" : "\n    Catches the exception thrown from the given expression and returns the\n    msg property of that exception. If no exception is thrown, then null is\n    returned. $(D E) can be $(D void).\n\n    If an exception is thrown but it has an empty message, then\n    $(D emptyExceptionMsg) is returned.\n\n    Note that while $(D collectExceptionMsg) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectExceptionMsg) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n\n    Examples:\n--------------------\nvoid throwFunc() {throw new Exception(\"My Message.\");}\nassert(collectExceptionMsg(throwFunc()) == \"My Message.\");\n\nvoid nothrowFunc() {}\nassert(collectExceptionMsg(nothrowFunc()) is null);\n\nvoid throwEmptyFunc() {throw new Exception(\"\");}\nassert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);\n--------------------\n",
"line" : 682}
]
}
,
{
"name" : "emptyExceptionMsg",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n    Value that collectExceptionMsg returns when it catches an exception\n    with an empty exception message.\n \n",
"line" : 711}
,
{
"name" : "assumeUnique(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Casts a mutable array to an immutable array in an idiomatic\n manner. Technically, $(D assumeUnique) just inserts a cast,\n but its name documents assumptions on the part of the\n caller. $(D assumeUnique(arr)) should only be called when\n there are no more active mutable aliases to elements of $(D\n arr). To strenghten this assumption, $(D assumeUnique(arr))\n also clears $(D arr) before returning. Essentially $(D\n assumeUnique(arr)) indicates commitment from the caller that there\n is no more mutable access to any of $(D arr)'s elements\n (transitively), and that all future accesses will be done through\n the immutable array returned by $(D assumeUnique).\n\n Typically, $(D assumeUnique) is used to return arrays from\n functions that have allocated and built them.\n\n Example:\n\n ----\n string letters()\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(result);\n }\n ----\n\n The use in the example above is correct because $(D result)\n was private to $(D letters) and is unaccessible in writing\n after the function returns. The following example shows an\n incorrect use of $(D assumeUnique).\n\n Bad:\n\n ----\n private char[] buffer;\n string letters(char first, char last)\n {\n   if (first >= last) return null; \/\/ fine\n   auto sneaky = buffer;\n   sneaky.length = last - first + 1;\n   foreach (i, ref e; sneaky)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(sneaky); \/\/ BAD\n }\n ----\n\n The example above wreaks havoc on client code because it is\n modifying arrays that callers considered immutable. To obtain an\n immutable array from the writable array $(D buffer), replace\n the last line with:\n ----\n return to!(string)(sneaky); \/\/ not that sneaky anymore\n ----\n\n The call will duplicate the array appropriately.\n\n Checking for uniqueness during compilation is possible in certain\n cases (see the $(D unique) and $(D lent) keywords in\n the $(WEB archjava.fluid.cs.cmu.edu\/papers\/oopsla02.pdf, ArchJava)\n language), but complicates the language considerably. The downside\n of $(D assumeUnique)'s convention-based usage is that at this\n time there is no formal checking of the correctness of the\n assumption; on the upside, the idiomatic use of $(D\n assumeUnique) is simple and rare enough to be tolerable.\n\n \n",
"line" : 786,
"members" : [
{
"name" : "assumeUnique",
"kind" : "function",
"type" : "pure nothrow immutable(T)[](ref T[] array)",
"comment" : "\n Casts a mutable array to an immutable array in an idiomatic\n manner. Technically, $(D assumeUnique) just inserts a cast,\n but its name documents assumptions on the part of the\n caller. $(D assumeUnique(arr)) should only be called when\n there are no more active mutable aliases to elements of $(D\n arr). To strenghten this assumption, $(D assumeUnique(arr))\n also clears $(D arr) before returning. Essentially $(D\n assumeUnique(arr)) indicates commitment from the caller that there\n is no more mutable access to any of $(D arr)'s elements\n (transitively), and that all future accesses will be done through\n the immutable array returned by $(D assumeUnique).\n\n Typically, $(D assumeUnique) is used to return arrays from\n functions that have allocated and built them.\n\n Example:\n\n ----\n string letters()\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(result);\n }\n ----\n\n The use in the example above is correct because $(D result)\n was private to $(D letters) and is unaccessible in writing\n after the function returns. The following example shows an\n incorrect use of $(D assumeUnique).\n\n Bad:\n\n ----\n private char[] buffer;\n string letters(char first, char last)\n {\n   if (first >= last) return null; \/\/ fine\n   auto sneaky = buffer;\n   sneaky.length = last - first + 1;\n   foreach (i, ref e; sneaky)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(sneaky); \/\/ BAD\n }\n ----\n\n The example above wreaks havoc on client code because it is\n modifying arrays that callers considered immutable. To obtain an\n immutable array from the writable array $(D buffer), replace\n the last line with:\n ----\n return to!(string)(sneaky); \/\/ not that sneaky anymore\n ----\n\n The call will duplicate the array appropriately.\n\n Checking for uniqueness during compilation is possible in certain\n cases (see the $(D unique) and $(D lent) keywords in\n the $(WEB archjava.fluid.cs.cmu.edu\/papers\/oopsla02.pdf, ArchJava)\n language), but complicates the language considerably. The downside\n of $(D assumeUnique)'s convention-based usage is that at this\n time there is no formal checking of the correctness of the\n assumption; on the upside, the idiomatic use of $(D\n assumeUnique) is simple and rare enough to be tolerable.\n\n \n",
"line" : 786}
]
}
,
{
"name" : "assumeUnique(T,U)",
"kind" : "template",
"protection" : "public",
"line" : 800,
"members" : [
{
"name" : "assumeUnique",
"kind" : "function",
"type" : "pure nothrow immutable(T[U])(ref T[U] array)",
"line" : 800}
]
}
,
{
"name" : "pointsTo(S,T,Tdummy = void)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D source)'s representation embeds a pointer\nthat points to $(D target)'s representation or somewhere inside\nit. Note that evaluating $(D pointsTo(x, x)) checks whether $(D x) has\ninternal pointers.\n",
"line" : 821,
"members" : [
{
"name" : "pointsTo",
"kind" : "function",
"type" : "pure nothrow @trusted bool(ref const S source, ref const T target)",
"comment" : "\nReturns $(D true) if $(D source)'s representation embeds a pointer\nthat points to $(D target)'s representation or somewhere inside\nit. Note that evaluating $(D pointsTo(x, x)) checks whether $(D x) has\ninternal pointers.\n",
"line" : 821}
]
}
,
{
"name" : "pointsTo(S,T)",
"kind" : "template",
"protection" : "public",
"line" : 848,
"members" : [
{
"name" : "pointsTo",
"kind" : "function",
"type" : "pure nothrow @trusted bool(ref const shared S source, ref const shared T target)",
"line" : 848}
]
}
,
{
"name" : "ErrnoException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown if errors that set $(D errno) occur.\n \n",
"line" : 907,
"base" : "Exception",
"members" : [
{
"name" : "errno",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 909}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ErrnoException(string msg, string file = null, ulong line = cast(ulong)0)",
"line" : 910}
]
}
,
{
"name" : "structuralCast(Target,Source) if (is(Source == class) || is(Target == class))",
"kind" : "template",
"protection" : "public",
"line" : 928,
"members" : [
{
"name" : "structuralCast",
"kind" : "function",
"type" : "Target(Source obj)",
"line" : 928}
]
}
,
{
"name" : "structuralCast(Target,Source) if (is(Source == interface) || is(Target == interface))",
"kind" : "template",
"protection" : "public",
"line" : 938,
"members" : [
{
"name" : "structuralCast",
"kind" : "function",
"type" : "Target(Source obj)",
"line" : 938}
]
}
,
{
"name" : "structurallyCompatible(S,T) if (!isArray!(S) || !isArray!(T))",
"kind" : "template",
"protection" : "public",
"line" : 1003,
"members" : [
{
"name" : "structurallyCompatible",
"kind" : "variable",
"line" : 1008}
]
}
,
{
"name" : "structurallyCompatible(S,T) if (isArray!(S) && isArray!(T))",
"kind" : "template",
"protection" : "public",
"line" : 1011,
"members" : [
{
"name" : "structurallyCompatible",
"kind" : "variable",
"line" : 1015}
]
}
]
}
,
{
"name" : "std.file",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/file.d",
"comment" : "\nUtilities for manipulating files and scanning directories. Functions\nin this module handle files as a unit, e.g., read or write one _file\nat a time. For opening files and manipulating them via handles refer\nto module $(D $(LINK2 std_stdio.html,std.stdio)).\n\nMacros:\nWIKI = Phobos\/StdFile\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis\nSource:    $(PHOBOSSRC std\/_file.d)\n \n",
"members" : [
{
"name" : "struct_stat64",
"kind" : "struct",
"protection" : "public",
"line" : 126,
"members" : [
{
"name" : "st_dev",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 127}
,
{
"name" : "st_ino",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 128}
,
{
"name" : "st_nlink",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 129}
,
{
"name" : "st_mode",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 130}
,
{
"name" : "st_uid",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 131}
,
{
"name" : "st_gid",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 132}
,
{
"name" : "__pad0",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 133}
,
{
"name" : "st_rdev",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 134}
,
{
"name" : "st_size",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 135}
,
{
"name" : "st_blksize",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 136}
,
{
"name" : "st_blocks",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 137}
,
{
"name" : "st_atime",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 138}
,
{
"name" : "st_atimensec",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 139}
,
{
"name" : "st_mtime",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 140}
,
{
"name" : "st_mtimensec",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 141}
,
{
"name" : "st_ctime",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 142}
,
{
"name" : "st_ctimensec",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 143}
,
{
"name" : "__unused",
"kind" : "variable",
"protection" : "public",
"type" : "long[3LU]",
"line" : 144}
]
}
,
{
"name" : "fstat64",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(int, struct_stat64*)",
"line" : 176}
,
{
"name" : "stat64",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(const(char*), struct_stat64*)",
"line" : 177}
,
{
"name" : "lstat64",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(const(char*), struct_stat64*)",
"line" : 178}
,
{
"name" : "FileException",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Exception thrown for file I\/O errors.\n \n",
"line" : 187,
"base" : "Exception",
"members" : [
{
"name" : "errno",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(uint)",
"comment" : "\n        OS error code.\n     \n",
"line" : 192}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileException(const(char[]) name, const(char[]) msg, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"comment" : "\n        Constructor which takes an error message.\n\n        Params:\n            name = Name of file for which the error occurred.\n            msg  = Message describing the error.\n            file = The file where the error occurred.\n            line = The line where the error occurred.\n     \n",
"line" : 203}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileException(const(char[]) name, uint errno = cast(uint)errno(), string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"comment" : "\n        Constructor which takes the error number ($(LUCKY GetLastError)\n        in Windows, $(D_PARAM errno) in Posix).\n\n        Params:\n            name = Name of file for which the error occurred.\n            msg  = Message describing the error.\n            file = The file where the error occurred.\n            line = The line where the error occurred.\n     \n",
"line" : 231}
]
}
,
{
"name" : "cenforce(T)",
"kind" : "template",
"protection" : "public",
"line" : 242,
"members" : [
{
"name" : "cenforce",
"kind" : "function",
"type" : "T(T condition, lazy const(char)[] name, string file = __FILE__, size_t line = __LINE__)",
"line" : 242}
]
}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void[](const(char[]) name, ulong upTo = 18446744073709551615LU)",
"comment" : "\nRead entire contents of file $(D name) and returns it as an untyped\narray. If the file size is larger than $(D upTo), only $(D upTo)\nbytes are read.\n\nExample:\n\n----\nimport std.file, std.stdio;\nvoid main()\n{\n   auto bytes = cast(ubyte[]) read(\"filename\", 5);\n   if (bytes.length == 5)\n       writefln(\"The fifth byte of the file is 0x%x\", bytes[4]);\n}\n----\n\nReturns: Untyped array of bytes _read.\n\nThrows: $(D FileException) on error.\n \n",
"line" : 283}
,
{
"name" : "readText(S = string)",
"kind" : "template",
"protection" : "public",
"comment" : "\nRead and validates (using $(XREF utf, validate)) a text file. $(D S)\ncan be a type of array of characters of any width and constancy. No\nwidth conversion is performed; if the width of the characters in file\n$(D name) is different from the width of elements of $(D S),\nvalidation will fail.\n\nReturns: Array of characters read.\n\nThrows: $(D FileException) on file error, $(D UTFException) on UTF\ndecoding error.\n\nExample:\n\n----\nenforce(system(\"echo abc>deleteme\") == 0);\nscope(exit) remove(\"deleteme\");\nenforce(chomp(readText(\"deleteme\")) == \"abc\");\n----\n \n",
"line" : 389,
"members" : [
{
"name" : "readText",
"kind" : "function",
"type" : "S(in char[] name)",
"comment" : "\nRead and validates (using $(XREF utf, validate)) a text file. $(D S)\ncan be a type of array of characters of any width and constancy. No\nwidth conversion is performed; if the width of the characters in file\n$(D name) is different from the width of elements of $(D S),\nvalidation will fail.\n\nReturns: Array of characters read.\n\nThrows: $(D FileException) on file error, $(D UTFException) on UTF\ndecoding error.\n\nExample:\n\n----\nenforce(system(\"echo abc>deleteme\") == 0);\nscope(exit) remove(\"deleteme\");\nenforce(chomp(readText(\"deleteme\")) == \"abc\");\n----\n \n",
"line" : 389}
]
}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name, const(void[]) buffer)",
"comment" : "\nWrite $(D buffer) to file $(D name).\nThrows: $(D FileException) on error.\n\nExample:\n\n----\nimport std.file;\nvoid main()\n{\n   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\n   write(\"filename\", a);\n   assert(cast(int[]) read(\"filename\") == a);\n}\n----\n \n",
"line" : 419}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name, const(void[]) buffer)",
"comment" : "\nAppends $(D buffer) to file $(D name).\nThrows: $(D FileException) on error.\n\nExample:\n\n----\nimport std.file;\nvoid main()\n{\n   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\n   write(\"filename\", a);\n   int[] b = [ 13, 21 ];\n   append(\"filename\", b);\n   assert(cast(int[]) read(\"filename\") == a ~ b);\n}\n----\n \n",
"line" : 458}
,
{
"name" : "writeImpl",
"kind" : "function",
"protection" : "private",
"type" : "void(const(char[]) name, const(void[]) buffer, const(uint) mode)",
"line" : 482}
,
{
"name" : "rename",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) from, const(char[]) to)",
"comment" : "\n Rename file $(D from) to $(D to).\n Throws: $(D FileException) on error.\n \n",
"line" : 502}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name)",
"comment" : "\nDelete file $(D name).\nThrows: $(D FileException) on error.\n \n",
"line" : 519}
,
{
"name" : "getSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(char[]) name)",
"comment" : "\nGet size of file $(D name) in bytes.\n\nThrows: $(D FileException) on error (e.g., file not found).\n \n",
"line" : 550}
,
{
"name" : "getTimes",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name, out SysTime fileAccessTime, out SysTime fileModificationTime)",
"comment" : "\n    Get the access and modified times of file $(D name).\n\n    Params:\n        name                 = File name to get times for.\n        fileAccessTime       = Time the file was last accessed.\n        fileModificationTime = Time the file was last modified.\n\n    Throws:\n        $(D FileException) on error.\n \n",
"line" : 588}
,
{
"name" : "timeLastModified",
"kind" : "function",
"protection" : "public",
"type" : "SysTime(const(char[]) name)",
"comment" : "\n    Returns the time that the given file was last modified.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
"line" : 767}
,
{
"name" : "timeLastModified",
"kind" : "function",
"protection" : "public",
"type" : "SysTime(const(char[]) name, SysTime returnIfMissing)",
"comment" : "\n    Returns the time that the given file was last modified. If the\n    file does not exist, returns $(D returnIfMissing).\n\n    A frequent usage pattern occurs in build automation tools such as\n    $(WEB gnu.org\/software\/make, make) or $(WEB\n    en.wikipedia.org\/wiki\/Apache_Ant, ant). To check whether file $(D\n    target) must be rebuilt from file $(D source) (i.e., $(D target) is\n    older than $(D source) or does not exist), use the comparison\n    below. The code throws a $(D FileException) if $(D source) does not\n    exist (as it should). On the other hand, the $(D SysTime.min) default\n    makes a non-existing $(D target) seem infinitely old so the test\n    correctly prompts building it.\n\n    Params:\n        name            = The name of the file to get the modification time for.\n        returnIfMissing = The time to return if the given file does not exist.\n\nExamples:\n--------------------\nif(timeLastModified(source) >= timeLastModified(target, SysTime.min))\n{\n    \/\/ must (re)build\n}\nelse\n{\n    \/\/ target is up-to-date\n}\n--------------------\n",
"line" : 819}
,
{
"name" : "exists",
"kind" : "function",
"protection" : "public",
"type" : "@property bool(const(char[]) name)",
"comment" : "\n    Returns whether the given file (or directory) exists.\n \n",
"line" : 866}
,
{
"name" : "getAttributes",
"kind" : "function",
"protection" : "public",
"type" : "uint(const(char[]) name)",
"comment" : "\n Returns the attributes of the given file.\n\n Note that the file attributes on Windows and Posix systems are\n completely different. On Windows, they're what is returned by $(WEB\n msdn.microsoft.com\/en-us\/library\/aa364944(v=vs.85).aspx,\n GetFileAttributes), whereas on Posix systems, they're the $(LUCKY\n st_mode) value which is part of the $(D stat struct) gotten by\n calling the $(WEB en.wikipedia.org\/wiki\/Stat_%28Unix%29, $(D stat))\n function.\n\n On Posix systems, if the given file is a symbolic link, then\n attributes are the attributes of the file pointed to by the symbolic\n link.\n\n Params:\n name = The file to get the attributes of.\n  \n",
"line" : 929}
,
{
"name" : "getLinkAttributes",
"kind" : "function",
"protection" : "public",
"type" : "uint(const(char[]) name)",
"comment" : "\n    If the given file is a symbolic link, then this returns the attributes of the\n    symbolic link itself rather than file that it points to. If the given file\n    is $(I not) a symbolic link, then this function returns the same result\n    as getAttributes.\n\n    On Windows, getLinkAttributes is identical to getAttributes. It exists on\n    Windows so that you don't have to special-case code for Windows when dealing\n    with symbolic links.\n\n    Params:\n        name = The file to get the symbolic link attributes of.\n\n    Throws:\n        $(D FileException) on error.\n \n",
"line" : 966}
,
{
"name" : "isDir",
"kind" : "function",
"protection" : "public",
"type" : "@property bool(const(char[]) name)",
"comment" : "\n    Returns whether the given file is a directory.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExamples:\n--------------------\nassert(!\"\/etc\/fonts\/fonts.conf\".isDir);\nassert(\"\/usr\/share\/include\".isDir);\n--------------------\n  \n",
"line" : 996}
,
{
"name" : "attrIsDir",
"kind" : "function",
"protection" : "public",
"type" : "nothrow bool(uint attributes)",
"comment" : "\n    Returns whether the given file attributes are for a directory.\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\nassert(!attrIsDir(getAttributes(\"\/etc\/fonts\/fonts.conf\")));\nassert(!attrIsDir(getLinkAttributes(\"\/etc\/fonts\/fonts.conf\")));\n--------------------\n  \n",
"line" : 1041}
,
{
"name" : "isFile",
"kind" : "function",
"protection" : "public",
"type" : "@property bool(const(char[]) name)",
"comment" : "\n    Returns whether the given file (or directory) is a file.\n\n    On Windows, if a file is not a directory, then it's a file. So,\n    either $(D isFile) or $(D isDir) will return true for any given file.\n\n    On Posix systems, if $(D isFile) is $(D true), that indicates that the file\n    is a regular file (e.g. not a block not device). So, on Posix systems, it's\n    possible for both $(D isFile) and $(D isDir) to be $(D false) for a\n    particular file (in which case, it's a special file). You can use\n    $(D getAttributes) to get the attributes to figure out what type of special\n    it is, or you can use $(D dirEntry) to get at its $(D statBuf), which is the\n    result from $(D stat). In either case, see the man page for $(D stat) for\n    more information.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExamples:\n--------------------\nassert(\"\/etc\/fonts\/fonts.conf\".isFile);\nassert(!\"\/usr\/share\/include\".isFile);\n--------------------\n  \n",
"line" : 1113}
,
{
"name" : "attrIsFile",
"kind" : "function",
"protection" : "public",
"type" : "nothrow bool(uint attributes)",
"comment" : "\n    Returns whether the given file attributes are for a file.\n\n    On Windows, if a file is not a directory, it's a file. So, either\n    $(D attrIsFile) or $(D attrIsDir) will return $(D true) for the\n    attributes of any given file.\n\n    On Posix systems, if $(D attrIsFile) is $(D true), that indicates that the\n    file is a regular file (e.g. not a block not device). So, on Posix systems,\n    it's possible for both $(D attrIsFile) and $(D attrIsDir) to be $(D false)\n    for a particular file (in which case, it's a special file). If a file is a\n    special file, you can use the attributes to check what type of special file\n    it is (see the man page for $(D stat) for more information).\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\nassert(attrIsFile(getAttributes(\"\/etc\/fonts\/fonts.conf\")));\nassert(attrIsFile(getLinkAttributes(\"\/etc\/fonts\/fonts.conf\")));\n--------------------\n  \n",
"line" : 1165}
,
{
"name" : "isSymlink(C)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns whether the given file is a symbolic link.\n\n    On Windows, returns $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n  \n",
"line" : 1222,
"members" : [
{
"name" : "isSymlink",
"kind" : "function",
"type" : "bool(const(C)[] name)",
"line" : 1222}
]
}
,
{
"name" : "attrIsSymlink",
"kind" : "function",
"protection" : "public",
"type" : "nothrow bool(uint attributes)",
"comment" : "\n    Returns whether the given file attributes are for a symbolic link.\n\n    On Windows, return $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\ncore.sys.posix.unistd.symlink(\"\/etc\/fonts\/fonts.conf\", \"\/tmp\/alink\");\n\nassert(!getAttributes(\"\/tmp\/alink\").isSymlink);\nassert(getLinkAttributes(\"\/tmp\/alink\").isSymlink);\n--------------------\n  \n",
"line" : 1319}
,
{
"name" : "chdir",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) pathname)",
"comment" : "\n Change directory to $(D pathname).\n Throws: $(D FileException) on error.\n \n",
"line" : 1332}
,
{
"name" : "mkdir",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) pathname)",
"comment" : "\nMake directory $(D pathname).\n\nThrows: $(D FileException) on error.\n \n",
"line" : 1351}
,
{
"name" : "mkdirRecurse",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) pathname)",
"comment" : "\n Make directory and all parent directories as needed.\n \n",
"line" : 1369}
,
{
"name" : "rmdir",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) pathname)",
"comment" : "\nRemove directory $(D pathname).\n\nThrows: $(D FileException) on error.\n \n",
"line" : 1415}
,
{
"name" : "symlink(C1,C2)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(BLUE This function is Posix-Only.)\n\n    Creates a symlink.\n\n    Params:\n        original = The file to link from.\n        link     = The symlink to create.\n\n    Note:\n        Relative paths are relative to the current working directory,\n        not the files being linked to or from.\n\n    Throws:\n        $(D FileException) on error (which includes if the symlink already\n        exists).\n  \n",
"line" : 1447,
"members" : [
{
"name" : "symlink",
"kind" : "function",
"type" : "void(const(C1)[] original, const(C2)[] link)",
"line" : 1447}
]
}
,
{
"name" : "readLink(C)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(BLUE This function is Posix-Only.)\n\n    Returns the path to the file pointed to by a symlink. Note that the\n    path could be either relative or absolute depending on the symlink.\n    If the path is relative, it's relative to the symlink, not the current\n    working directory.\n\n    Throws:\n        $(D FileException) on error.\n  \n",
"line" : 1510,
"members" : [
{
"name" : "readLink",
"kind" : "function",
"type" : "string(const(C)[] link)",
"line" : 1510}
]
}
,
{
"name" : "getcwd",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Get current directory.\n Throws: $(D FileException) on error.\n \n",
"line" : 1593}
,
{
"name" : "DirEntry",
"kind" : "struct",
"protection" : "public",
"line" : 1877,
"members" : [
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property string()",
"line" : 1881}
,
{
"name" : "isDir",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 1886}
,
{
"name" : "isFile",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 1893}
,
{
"name" : "isSymlink",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 1900}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 1907}
,
{
"name" : "timeStatusChanged",
"kind" : "function",
"protection" : "public",
"type" : "@property SysTime()",
"line" : 1913}
,
{
"name" : "timeLastAccessed",
"kind" : "function",
"protection" : "public",
"type" : "@property SysTime()",
"line" : 1920}
,
{
"name" : "timeLastModified",
"kind" : "function",
"protection" : "public",
"type" : "@property SysTime()",
"line" : 1927}
,
{
"name" : "attributes",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 1934}
,
{
"name" : "linkAttributes",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"line" : 1941}
,
{
"name" : "statBuf",
"kind" : "function",
"protection" : "public",
"type" : "@property struct_stat64()",
"line" : 1948}
,
{
"name" : "_init",
"kind" : "function",
"protection" : "private",
"type" : "void(const(char[]) path)",
"line" : 1957}
,
{
"name" : "_init",
"kind" : "function",
"protection" : "private",
"type" : "void(const(char[]) path, dirent* fd)",
"line" : 1966}
,
{
"name" : "_ensureStatDone",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"comment" : "\n            This is to support lazy evaluation, because doing stat's is\n            expensive and not always needed.\n         \n",
"line" : 1995}
,
{
"name" : "_ensureLStatDone",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"comment" : "\n            This is to support lazy evaluation, because doing stat's is\n            expensive and not always needed.\n         \n",
"line" : 2010}
,
{
"name" : "_name",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"comment" : " The file or directory represented by this DirEntry.\n",
"line" : 2027}
,
{
"name" : "_statBuf",
"kind" : "variable",
"protection" : "private",
"type" : "struct_stat64",
"comment" : " The result of stat().\n",
"line" : 2029}
,
{
"name" : "_lstatMode",
"kind" : "variable",
"protection" : "private",
"type" : "uint",
"comment" : " The stat mode from lstat().\n",
"line" : 2030}
,
{
"name" : "_dType",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"comment" : " The type of the file.\n",
"line" : 2031}
,
{
"name" : "_didLStat",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"comment" : " Whether lstat() has been called for this DirEntry.\n",
"line" : 2033}
,
{
"name" : "_didStat",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"comment" : " Whether stat() has been called for this DirEntry.\n",
"line" : 2034}
,
{
"name" : "_dTypeSet",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"comment" : " Whether the dType of the file has been set.\n",
"line" : 2035}
]
}
,
{
"name" : "listdir",
"kind" : "alias",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in November 2012.\n       Please use $(LREF dirEntries) instead.)\n\n For each file and directory $(D DirEntry) in $(D pathname[])\n pass it to the callback delegate.\n\n Params:\n        callback =        Delegate that processes each\n                        DirEntry in turn. Returns true to\n                        continue, false to stop.\n Example:\n        This program lists all the files in its\n        path argument and all subdirectories thereof.\n ----\n import std.stdio;\n import std.file;\n\n void main(string[] args)\n {\n    bool callback(DirEntry* de)\n    {\n      if(de.isDir)\n        listdir(de.name, &callback);\n      else\n        writefln(de.name);\n\n      return true;\n    }\n\n    listdir(args[1], &callback);\n }\n ----\n \n",
"line" : 2134}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) from, const(char[]) to)",
"comment" : "\nCopy file $(D from) to file $(D to). File timestamps are preserved.\n \n",
"line" : 2140}
,
{
"name" : "setTimes",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name, SysTime fileAccessTime, SysTime fileModificationTime)",
"comment" : "\n    Set access\/modified times of file $(D name).\n\n    Params:\n        fileAccessTime       = Time the file was last accessed.\n        fileModificationTime = Time the file was last modified.\n\n    Throws:\n        $(D FileException) on error.\n \n",
"line" : 2208}
,
{
"name" : "rmdirRecurse",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) pathname)",
"comment" : "\n    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n \n",
"line" : 2267}
,
{
"name" : "rmdirRecurse",
"kind" : "function",
"protection" : "public",
"type" : "void(ref DirEntry de)",
"comment" : "\n    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n \n",
"line" : 2283}
,
{
"name" : "SpanMode",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Dictates directory spanning policy for $(D_PARAM dirEntries) (see below).\n \n",
"line" : 2385,
"base" : "int",
"members" : [
{
"name" : "shallow",
"kind" : "enum member",
"protection" : "public",
"comment" : " Only spans one directory. \n",
"line" : 2387}
,
{
"name" : "depth",
"kind" : "enum member",
"protection" : "public",
"comment" : " Spans the directory depth-first, i.e. the content of any\n     subdirectory is spanned before that subdirectory itself. Useful\n     e.g. when recursively deleting files.  \n",
"line" : 2391}
,
{
"name" : "breadth",
"kind" : "enum member",
"protection" : "public",
"comment" : " Spans the directory breadth-first, i.e. the content of any\n     subdirectory is spanned right after that subdirectory itself. \n",
"line" : 2394}
]
}
,
{
"name" : "DirIteratorImpl",
"kind" : "struct",
"protection" : "private",
"line" : 2398,
"members" : [
{
"name" : "_mode",
"kind" : "variable",
"protection" : "public",
"type" : "SpanMode",
"line" : 2399}
,
{
"name" : "_followSymlink",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"line" : 2404}
,
{
"name" : "_cur",
"kind" : "variable",
"protection" : "public",
"type" : "DirEntry",
"line" : 2405}
,
{
"name" : "_stack",
"kind" : "variable",
"protection" : "public",
"type" : "Appender!(DirHandle[])",
"line" : 2406}
,
{
"name" : "_stashed",
"kind" : "variable",
"protection" : "public",
"type" : "Appender!(DirEntry[])",
"line" : 2407}
,
{
"name" : "pushExtra",
"kind" : "function",
"protection" : "public",
"type" : "void(DirEntry de)",
"line" : 2409}
,
{
"name" : "hasExtra",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 2411}
,
{
"name" : "popExtra",
"kind" : "function",
"protection" : "public",
"type" : "DirEntry()",
"line" : 2413}
,
{
"name" : "DirHandle",
"kind" : "struct",
"protection" : "public",
"line" : 2518,
"members" : [
{
"name" : "dirpath",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2519}
,
{
"name" : "h",
"kind" : "variable",
"protection" : "public",
"type" : "DIR*",
"line" : 2520}
]
}
,
{
"name" : "stepIn",
"kind" : "function",
"protection" : "public",
"type" : "bool(string directory)",
"line" : 2523}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 2530}
,
{
"name" : "popDirStack",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 2548}
,
{
"name" : "releaseDirStack",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 2555}
,
{
"name" : "mayStepIn",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 2561}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref DirIteratorImpl(string pathname, SpanMode mode, bool followSymlink)",
"line" : 2567}
,
{
"name" : "empty",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 2589}
,
{
"name" : "front",
"kind" : "function",
"protection" : "public",
"type" : "@property DirEntry()",
"line" : 2590}
,
{
"name" : "popFront",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 2591}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref DirIteratorImpl(DirIteratorImpl p)",
"line" : 2398}
]
}
,
{
"name" : "DirIterator",
"kind" : "struct",
"protection" : "public",
"line" : 2633,
"members" : [
{
"name" : "impl",
"kind" : "variable",
"protection" : "private",
"type" : "RefCounted!(DirIteratorImpl,cast(RefCountedAutoInitialize)0)",
"line" : 2635}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "ref DirIterator(string pathname, SpanMode mode, bool followSymlink)",
"line" : 2636}
,
{
"name" : "empty",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 2641}
,
{
"name" : "front",
"kind" : "function",
"protection" : "public",
"type" : "@property DirEntry()",
"line" : 2642}
,
{
"name" : "popFront",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 2643}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(DirIterator) p)",
"line" : 2633}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref DirIterator(DirIterator p)",
"line" : 2633}
]
}
,
{
"name" : "dirEntries",
"kind" : "function",
"protection" : "public",
"type" : "DirIterator(string path, SpanMode mode, bool followSymlink = true)",
"comment" : "\n    Returns an input range of DirEntry that lazily iterates a given directory,\n    also provides two ways of foreach iteration. The iteration variable can be of\n    type $(D_PARAM string) if only the name is needed, or $(D_PARAM DirEntry)\n    if additional details are needed. The span mode dictates the how the\n    directory is traversed. The name of the each directory entry iterated\n    contains the absolute path.\n\n    Params:\n        path = The directory to iterate over.\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\nExamples:\n--------------------\n\/\/ Iterate a directory in depth\nforeach (string name; dirEntries(\"destroy\/me\", SpanMode.depth))\n{\n remove(name);\n}\n\/\/ Iterate a directory in breadth\nforeach (string name; dirEntries(\".\", SpanMode.breadth))\n{\n writeln(name);\n}\n\/\/ Iterate a directory and get detailed info about it\nforeach (DirEntry e; dirEntries(\"dmd-testing\", SpanMode.breadth))\n{\n writeln(e.name, \"\\t\", e.size);\n}\n\/\/ Iterate over all *.d files in current directory and all its subdirectories\nauto dFiles = filter!`endsWith(a.name,\".d\")`(dirEntries(\".\",SpanMode.depth));\nforeach(d; dFiles)\n    writeln(d.name);\n\/\/ Hook it up with std.parallelism to compile them all in parallel:\nforeach(d; parallel(dFiles, 1)) \/\/passes by 1 file to each thread\n{\n    string cmd = \"dmd -c \"  ~ d.name;\n    writeln(cmd);\n    std.process.system(cmd);\n}\n--------------------\n\/\/\n \n",
"line" : 2695}
,
{
"name" : "dirEntries",
"kind" : "function",
"protection" : "public",
"type" : "FilterResult!(f,DirIterator)(string path, string pattern, SpanMode mode, bool followSymlink = true)",
"comment" : "\n    Convenience wrapper for filtering file names with a glob pattern.\n\n    Params:\n        path = The directory to iterate over.\n        pattern  = String with wildcards, such as $(RED \"*.d\"). The supported\n                   wildcard strings are described under\n                   $(XREF path, globMatch).\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\nExamples:\n--------------------\n\/\/ Iterate over all D source files in current directory and all its\n\/\/ subdirectories\nauto dFiles = dirEntries(\".\",\"*.{d,di}\",SpanMode.depth);\nforeach(d; dFiles)\n    writeln(d.name);\n--------------------\n\/\/\n \n",
"line" : 2777}
,
{
"name" : "dirEntry",
"kind" : "function",
"protection" : "public",
"type" : "DirEntry(const(char[]) name)",
"comment" : "\n    Returns a DirEntry for the given file (or directory).\n\n    Params:\n        name = The file (or directory) to get a DirEntry for.\n\n    Throws:\n        $(D FileException) if the file does not exist.\n \n",
"line" : 2791}
,
{
"name" : "slurp(Types...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReads an entire file into an array.\n\nExample:\n----\n\/\/ Load file; each line is an int followed by comma, whitespace and a\n\/\/ double.\nauto a = slurp!(int, double)(\"filename\", \"%s, %s\");\n----\n \n",
"line" : 3005,
"members" : [
{
"name" : "slurp",
"kind" : "function",
"type" : "Select!(Types.length == 1,Types[0][],Tuple!(Types)[])(string filename, in char[] format)",
"comment" : "\nReads an entire file into an array.\n\nExample:\n----\n\/\/ Load file; each line is an int followed by comma, whitespace and a\n\/\/ double.\nauto a = slurp!(int, double)(\"filename\", \"%s, %s\");\n----\n \n",
"line" : 3005}
]
}
,
{
"name" : "tempDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\nReturns the path to a directory for temporary files.\n\nOn Windows, this function returns the result of calling the Windows API function\n$(D $(LINK2 http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/desktop\/aa364992.aspx, GetTempPath)).\n\nOn POSIX platforms, it searches through the following list of directories\nand returns the first one which is found to exist:\n$(OL\n    $(LI The directory given by the $(D TMPDIR) environment variable.)\n    $(LI The directory given by the $(D TEMP) environment variable.)\n    $(LI The directory given by the $(D TMP) environment variable.)\n    $(LI $(D \/tmp))\n    $(LI $(D \/var\/tmp))\n    $(LI $(D \/usr\/tmp))\n)\n\nOn all platforms, $(D tempDir) returns $(D \".\") on failure, representing\nthe current working directory.\n\nThe return value of the function is cached, so the procedures described\nabove will only be performed the first time the function is called.  All\nsubsequent runs will return the same string, regardless of whether\nenvironment variables and directory structures have changed in the\nmeantime.\n\nThe POSIX $(D tempDir) algorithm is inspired by Python's\n$(D $(LINK2 http:\/\/docs.python.org\/library\/tempfile.html#tempfile.tempdir, tempfile.tempdir)).\n",
"line" : 3065}
,
{
"name" : "listDir(C)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in November 2012.\n          Please use $(LREF dirEntries) instead.)\n\n    Returns the contents of the given directory.\n\n    The names in the contents do not include the pathname.\n\n    Throws:\n        $(D FileException) on error.\n\nExamples:\n    This program lists all the files and subdirectories in its\n    path argument.\n--------------------\nimport std.stdio;\nimport std.file;\n\nvoid main(string[] args)\n{\n    auto dirs = std.file.listDir(args[1]);\n\n    foreach(d; dirs)\n        writefln(d);\n}\n--------------------\n \n",
"line" : 3129,
"members" : [
{
"name" : "listDir",
"kind" : "function",
"type" : "string[](in C[] pathname)",
"line" : 3129}
]
}
,
{
"name" : "listDir(C,U) if (is(C : char) && !is(U : bool delegate(string filename)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in November 2012.\n          Please use $(LREF dirEntries) instead.)\n\n    Returns all the files in the directory and its sub-directories\n    which match pattern or regular expression r.\n\n    Params:\n        pathname = The path of the directory to search.\n        pattern  = String with wildcards, such as $(RED \"*.d\"). The supported\n                   wildcard strings are described under fnmatch() in\n                   $(LINK2 std_path.html, std.path).\n        r        = Regular expression, for more powerful pattern matching.\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over. Ignored on Windows.\n\nExamples:\n    This program lists all the files with a \"d\" extension in\n    the path passed as the first argument.\n--------------------\nimport std.stdio;\nimport std.file;\n\nvoid main(string[] args)\n{\n  auto d_source_files = std.file.listDir(args[1], \"*.d\");\n\n  foreach(d; d_source_files)\n      writefln(d);\n}\n--------------------\n\n    A regular expression version that searches for all files with \"d\" or\n    \"obj\" extensions:\n--------------------\nimport std.stdio;\nimport std.file;\nimport std.regexp;\n\nvoid main(string[] args)\n{\n  auto d_source_files = std.file.listDir(args[1], RegExp(r\"\\.(d|obj)$\"));\n\n  foreach(d; d_source_files)\n      writefln(d);\n}\n--------------------\n \n",
"line" : 3199,
"members" : [
{
"name" : "listDir",
"kind" : "function",
"type" : "string[](in C[] pathname, U filter, bool followSymlink = true)",
"line" : 3199}
]
}
,
{
"name" : "listDir(C,U) if (is(C : char) && is(U : bool delegate(string filename)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in November 2012.\n       Please use $(LREF dirEntries) instead.)\n\n For each file and directory name in pathname[],\n pass it to the callback delegate.\n\n Params:\n        callback =        Delegate that processes each\n                        filename in turn. Returns true to\n                        continue, false to stop.\n Example:\n        This program lists all the files in its\n        path argument, including the path.\n ----\n import std.stdio;\n import std.path;\n import std.file;\n\n void main(string[] args)\n {\n    auto pathname = args[1];\n    string[] result;\n\n    bool listing(string filename)\n    {\n      result ~= buildPath(pathname, filename);\n      return true; \/\/ continue\n    }\n\n    listdir(pathname, &listing);\n\n    foreach (name; result)\n      writefln(\"%s\", name);\n }\n ----\n \n",
"line" : 3271,
"members" : [
{
"name" : "listDir",
"kind" : "function",
"type" : "void(in C[] pathname, U callback)",
"line" : 3271}
]
}
,
{
"name" : "_listDir",
"kind" : "function",
"protection" : "private",
"type" : "void(const(char[]) pathname, bool delegate(string filename) callback)",
"line" : 3284}
,
{
"name" : "_listDir",
"kind" : "function",
"protection" : "private",
"type" : "void(const(char[]) pathname, bool delegate(DirEntry* de) callback)",
"line" : 3329}
]
}
,
{
"name" : "std.format",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/format.d",
"comment" : "\n   This module implements the formatting functionality for strings and\n   I\/O. It's comparable to C99's $(D vsprintf()) and uses a similar\n   format encoding scheme.\n\n   Macros: WIKI = Phobos\/StdFormat\n\n   Copyright: Copyright Digital Mars 2000-.\n\n   License: $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\n   Authors: $(WEB digitalmars.com, Walter Bright), $(WEB erdani.com,\n   Andrei Alexandrescu), and Kenji Hara\n\n   Source: $(PHOBOSSRC std\/_format.d)\n \n",
"members" : [
{
"name" : "snprintf",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(char* s, ulong n, const(char*) format,...)",
"line" : 52}
,
{
"name" : "FormatException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Signals a mismatch between a format and its corresponding argument.\n \n",
"line" : 58,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FormatException()",
"line" : 60}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FormatException(string msg, string fn = __FILE__, ulong ln = cast(ulong)__LINE__, Throwable next = null)",
"line" : 65}
]
}
,
{
"name" : "FormatError",
"kind" : "alias",
"protection" : "public",
"type" : "std.format.FormatException",
"comment" : "\n    $(RED Deprecated. It will be removed In January 2013.\n          Please use $(D FormatException) instead.)\n \n",
"line" : 75}
,
{
"name" : "formattedWrite(Writer,Char,A...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Interprets variadic argument list $(D args), formats them according\n   to $(D fmt), and sends the resulting characters to $(D w). The\n   encoding of the output is the same as $(D Char). type $(D Writer)\n   must satisfy $(XREF range,isOutputRange!(Writer, Char)).\n\n   The variadic arguments are normally consumed in order. POSIX-style\n   $(WEB opengroup.org\/onlinepubs\/009695399\/functions\/printf.html,\n   positional parameter syntax) is also supported. Each argument is\n   formatted into a sequence of chars according to the format\n   specification, and the characters are passed to $(D w). As many\n   arguments as specified in the format string are consumed and\n   formatted. If there are fewer arguments than format specifiers, a\n   $(D FormatException) is thrown. If there are more remaining arguments\n   than needed by the format specification, they are ignored but only\n   if at least one argument was formatted.\n\n   The format string supports the formatting of array and nested array elements\n   via the grouping format specifiers $(B %&#40;) and $(B %&#41;). Each\n   matching pair of $(B %&#40;) and $(B %&#41;) corresponds with a single array\n   argument. The enclosed sub-format string is applied to individual array\n   elements.  The trailing portion of the sub-format string following the\n   conversion specifier for the array element is interpreted as the array\n   delimiter, and is therefore omitted following the last array element. The\n   $(B %|) specifier may be used to explicitly indicate the start of the\n   delimiter, so that the preceding portion of the string will be included\n   following the last array element.  (See below for explicit examples.)\n\n   Params:\n\n   w = Output is sent to this writer. Typical output writers include\n   $(XREF array,Appender!string) and $(XREF stdio,LockingTextWriter).\n\n   fmt = Format string.\n\n   args = Variadic argument list.\n\n   Returns: Formatted number of arguments.\n\n   Throws: Mismatched arguments and formats result in a $(D\n   FormatException) being thrown.\n\n   Format_String: <a name=\"format-string\">$(I Format strings)<\/a>\n   consist of characters interspersed with $(I format\n   specifications). Characters are simply copied to the output (such\n   as putc) after any necessary conversion to the corresponding UTF-8\n   sequence.\n\n   The format string has the following grammar:\n\n$(PRE\n$(I FormatString):\n    $(I FormatStringItem)*\n$(I FormatStringItem):\n    $(B '%%')\n    $(B '%') $(I Position) $(I Flags) $(I Width) $(I Precision) $(I FormatChar)\n    $(B '%$(LPAREN)') $(I FormatString) $(B '%$(RPAREN)')\n    $(I OtherCharacterExceptPercent)\n$(I Position):\n    $(I empty)\n    $(I Integer) $(B '$')\n$(I Flags):\n    $(I empty)\n    $(B '-') $(I Flags)\n    $(B '+') $(I Flags)\n    $(B '#') $(I Flags)\n    $(B '0') $(I Flags)\n    $(B ' ') $(I Flags)\n$(I Width):\n    $(I empty)\n    $(I Integer)\n    $(B '*')\n$(I Precision):\n    $(I empty)\n    $(B '.')\n    $(B '.') $(I Integer)\n    $(B '.*')\n$(I Integer):\n    $(I Digit)\n    $(I Digit) $(I Integer)\n$(I Digit):\n    $(B '0')|$(B '1')|$(B '2')|$(B '3')|$(B '4')|$(B '5')|$(B '6')|$(B '7')|$(B '8')|$(B '9')\n$(I FormatChar):\n    $(B 's')|$(B 'b')|$(B 'd')|$(B 'o')|$(B 'x')|$(B 'X')|$(B 'e')|$(B 'E')|$(B 'f')|$(B 'F')|$(B 'g')|$(B 'G')|$(B 'a')|$(B 'A')\n)\n\n    $(BOOKTABLE Flags affect formatting depending on the specifier as\n    follows., $(TR $(TH Flag) $(TH Types&nbsp;affected) $(TH Semantics))\n\n    $(TR $(TD $(B '-')) $(TD numeric) $(TD Left justify the result in\n        the field.  It overrides any $(B 0) flag.))\n\n    $(TR $(TD $(B '+')) $(TD numeric) $(TD Prefix positive numbers in\n    a signed conversion with a $(B +).  It overrides any $(I space)\n    flag.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'o'))) $(TD Add to\n    precision as necessary so that the first digit of the octal\n    formatting is a '0', even if both the argument and the $(I\n    Precision) are zero.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'x'), $(B 'X'))) $(TD If\n       non-zero, prefix result with $(B 0x) ($(B 0X)).))\n\n    $(TR $(TD $(B '#')) $(TD floating) $(TD Always insert the decimal\n       point and print trailing zeros.))\n\n    $(TR $(TD $(B '#')) $(TD numeric ($(B '0'))) $(TD Use leading\n    zeros to pad rather than spaces (except for the floating point\n    values $(D nan) and $(D infinity)).  Ignore if there's a $(I\n    Precision).))\n\n    $(TR $(TD $(B ' ')) $(TD integral ($(B 'd'))) $(TD Prefix positive\n    numbers in a signed conversion with a space.)))\n\n    <dt>$(I Width)\n    <dd>\n    Specifies the minimum field width.\n    If the width is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the width.\n    If the width is negative, it is as if the $(B -) was given\n    as a $(I Flags) character.\n\n    <dt>$(I Precision)\n    <dd> Gives the precision for numeric conversions.\n    If the precision is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the precision. If it is negative,\n    it is as if there was no $(I Precision).\n\n    <dt>$(I FormatChar)\n    <dd>\n    <dl>\n        <dt>$(B 's')\n        <dd>The corresponding argument is formatted in a manner consistent\n        with its type:\n        <dl>\n            <dt>$(B bool)\n            <dd>The result is <tt>'true'<\/tt> or <tt>'false'<\/tt>.\n            <dt>integral types\n            <dd>The $(B %d) format is used.\n            <dt>floating point types\n            <dd>The $(B %g) format is used.\n            <dt>string types\n            <dd>The result is the string converted to UTF-8.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>classes derived from $(B Object)\n            <dd>The result is the string returned from the class instance's\n            $(B .toString()) method.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>non-string static and dynamic arrays\n            <dd>The result is [s<sub>0<\/sub>, s<sub>1<\/sub>, ...]\n            where s<sub>k<\/sub> is the kth element\n            formatted with the default format.\n        <\/dl>\n\n        <dt>$(B 'c')\n        <dd>The corresponding argument must be a character type.\n\n        <dt>$(B 'b','d','o','x','X')\n        <dd> The corresponding argument must be an integral type\n        and is formatted as an integer. If the argument is a signed type\n        and the $(I FormatChar) is $(B d) it is converted to\n        a signed string of characters, otherwise it is treated as\n        unsigned. An argument of type $(B bool) is formatted as '1'\n        or '0'. The base used is binary for $(B b), octal for $(B o),\n        decimal\n        for $(B d), and hexadecimal for $(B x) or $(B X).\n        $(B x) formats using lower case letters, $(B X) uppercase.\n        If there are fewer resulting digits than the $(I Precision),\n        leading zeros are used as necessary.\n        If the $(I Precision) is 0 and the number is 0, no digits\n        result.\n\n        <dt>$(B 'e','E')\n        <dd> A floating point number is formatted as one digit before\n        the decimal point, $(I Precision) digits after, the $(I FormatChar),\n        &plusmn;, followed by at least a two digit exponent: $(I d.dddddd)e$(I &plusmn;dd).\n        If there is no $(I Precision), six\n        digits are generated after the decimal point.\n        If the $(I Precision) is 0, no decimal point is generated.\n\n        <dt>$(B 'f','F')\n        <dd> A floating point number is formatted in decimal notation.\n        The $(I Precision) specifies the number of digits generated\n        after the decimal point. It defaults to six. At least one digit\n        is generated before the decimal point. If the $(I Precision)\n        is zero, no decimal point is generated.\n\n        <dt>$(B 'g','G')\n        <dd> A floating point number is formatted in either $(B e) or\n        $(B f) format for $(B g); $(B E) or $(B F) format for\n        $(B G).\n        The $(B f) format is used if the exponent for an $(B e) format\n        is greater than -5 and less than the $(I Precision).\n        The $(I Precision) specifies the number of significant\n        digits, and defaults to six.\n        Trailing zeros are elided after the decimal point, if the fractional\n        part is zero then no decimal point is generated.\n\n        <dt>$(B 'a','A')\n        <dd> A floating point number is formatted in hexadecimal\n        exponential notation 0x$(I h.hhhhhh)p$(I &plusmn;d).\n        There is one hexadecimal digit before the decimal point, and as\n        many after as specified by the $(I Precision).\n        If the $(I Precision) is zero, no decimal point is generated.\n        If there is no $(I Precision), as many hexadecimal digits as\n        necessary to exactly represent the mantissa are generated.\n        The exponent is written in as few digits as possible,\n        but at least one, is in decimal, and represents a power of 2 as in\n        $(I h.hhhhhh)*2<sup>$(I &plusmn;d)<\/sup>.\n        The exponent for zero is zero.\n        The hexadecimal digits, x and p are in upper case if the\n        $(I FormatChar) is upper case.\n    <\/dl>\n\n    Floating point NaN's are formatted as $(B nan) if the\n    $(I FormatChar) is lower case, or $(B NAN) if upper.\n    Floating point infinities are formatted as $(B inf) or\n    $(B infinity) if the\n    $(I FormatChar) is lower case, or $(B INF) or $(B INFINITY) if upper.\n    <\/dl>\n\nExamples:\n\n-------------------------\nimport std.c.stdio;\nimport std.format;\n\nvoid main()\n{\n    auto writer = appender!string();\n    formattedWrite(writer, \"%s is the ultimate %s.\", 42, \"answer\");\n    assert(writer.data == \"42 is the ultimate answer.\");\n    \/\/ Clear the writer\n    writer = appender!string();\n    formattedWrite(writer, \"Date: %2$s %1$s\", \"October\", 5);\n    assert(writer.data == \"Date: 5 October\");\n}\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the next parameter after\nthe largest positional parameter already used.\n\nExample using array and nested array formatting:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(%s %).\", [1,2,3]);\n    writefln(\"My items are %(%s, %).\", [1,2,3]);\n}\n-------------------------\n   The output is:\n<pre class=console>\nMy items are 1 2 3.\nMy items are 1, 2, 3.\n<\/pre>\n\n   The trailing end of the sub-format string following the specifier for each\n   item is interpreted as the array delimiter, and is therefore omitted\n   following the last array item. The $(B %|) delimiter specifier may be used\n   to indicate where the delimiter begins, so that the portion of the format\n   string prior to it will be retained in the last array element:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(-%s-%|, %).\", [1,2,3]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy items are -1-, -2-, -3-.\n<\/pre>\n\n   These compound format specifiers may be nested in the case of a nested\n   array argument:\n-------------------------\nimport std.stdio;\nvoid main() {\n     auto mat = [[1, 2, 3],\n                 [4, 5, 6],\n                 [7, 8, 9]];\n\n     writefln(\"%(%(%d %)\\n%)\", mat);\n     writeln();\n\n     writefln(\"[%(%(%d %)\\n %)]\", mat);\n     writeln();\n\n     writefln(\"[%([%(%d %)]%|\\n %)]\", mat);\n     writeln();\n}\n-------------------------\n   The output is:\n<pre class=console>\n1 2 3\n4 5 6\n7 8 9\n\n[1 2 3\n 4 5 6\n 7 8 9]\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n<\/pre>\n\n   Inside a compound format specifier, strings and characters are escaped\n   automatically. To avoid this behavior, add $(B '-') flag to\n   $(D \"%$(LPAREN)\").\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My friends are %s.\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %(%s, %).\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %-(%s, %).\", [\"John\", \"Nancy\"]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy friends are [\"John\", \"Nancy\"].\nMy friends are \"John\", \"Nancy\".\nMy friends are John, Nancy.\n<\/pre>\n \n",
"line" : 412,
"members" : [
{
"name" : "formattedWrite",
"kind" : "function",
"type" : "uint(Writer w, in Char[] fmt, A args)",
"comment" : "\n   Interprets variadic argument list $(D args), formats them according\n   to $(D fmt), and sends the resulting characters to $(D w). The\n   encoding of the output is the same as $(D Char). type $(D Writer)\n   must satisfy $(XREF range,isOutputRange!(Writer, Char)).\n\n   The variadic arguments are normally consumed in order. POSIX-style\n   $(WEB opengroup.org\/onlinepubs\/009695399\/functions\/printf.html,\n   positional parameter syntax) is also supported. Each argument is\n   formatted into a sequence of chars according to the format\n   specification, and the characters are passed to $(D w). As many\n   arguments as specified in the format string are consumed and\n   formatted. If there are fewer arguments than format specifiers, a\n   $(D FormatException) is thrown. If there are more remaining arguments\n   than needed by the format specification, they are ignored but only\n   if at least one argument was formatted.\n\n   The format string supports the formatting of array and nested array elements\n   via the grouping format specifiers $(B %&#40;) and $(B %&#41;). Each\n   matching pair of $(B %&#40;) and $(B %&#41;) corresponds with a single array\n   argument. The enclosed sub-format string is applied to individual array\n   elements.  The trailing portion of the sub-format string following the\n   conversion specifier for the array element is interpreted as the array\n   delimiter, and is therefore omitted following the last array element. The\n   $(B %|) specifier may be used to explicitly indicate the start of the\n   delimiter, so that the preceding portion of the string will be included\n   following the last array element.  (See below for explicit examples.)\n\n   Params:\n\n   w = Output is sent to this writer. Typical output writers include\n   $(XREF array,Appender!string) and $(XREF stdio,LockingTextWriter).\n\n   fmt = Format string.\n\n   args = Variadic argument list.\n\n   Returns: Formatted number of arguments.\n\n   Throws: Mismatched arguments and formats result in a $(D\n   FormatException) being thrown.\n\n   Format_String: <a name=\"format-string\">$(I Format strings)<\/a>\n   consist of characters interspersed with $(I format\n   specifications). Characters are simply copied to the output (such\n   as putc) after any necessary conversion to the corresponding UTF-8\n   sequence.\n\n   The format string has the following grammar:\n\n$(PRE\n$(I FormatString):\n    $(I FormatStringItem)*\n$(I FormatStringItem):\n    $(B '%%')\n    $(B '%') $(I Position) $(I Flags) $(I Width) $(I Precision) $(I FormatChar)\n    $(B '%$(LPAREN)') $(I FormatString) $(B '%$(RPAREN)')\n    $(I OtherCharacterExceptPercent)\n$(I Position):\n    $(I empty)\n    $(I Integer) $(B '$')\n$(I Flags):\n    $(I empty)\n    $(B '-') $(I Flags)\n    $(B '+') $(I Flags)\n    $(B '#') $(I Flags)\n    $(B '0') $(I Flags)\n    $(B ' ') $(I Flags)\n$(I Width):\n    $(I empty)\n    $(I Integer)\n    $(B '*')\n$(I Precision):\n    $(I empty)\n    $(B '.')\n    $(B '.') $(I Integer)\n    $(B '.*')\n$(I Integer):\n    $(I Digit)\n    $(I Digit) $(I Integer)\n$(I Digit):\n    $(B '0')|$(B '1')|$(B '2')|$(B '3')|$(B '4')|$(B '5')|$(B '6')|$(B '7')|$(B '8')|$(B '9')\n$(I FormatChar):\n    $(B 's')|$(B 'b')|$(B 'd')|$(B 'o')|$(B 'x')|$(B 'X')|$(B 'e')|$(B 'E')|$(B 'f')|$(B 'F')|$(B 'g')|$(B 'G')|$(B 'a')|$(B 'A')\n)\n\n    $(BOOKTABLE Flags affect formatting depending on the specifier as\n    follows., $(TR $(TH Flag) $(TH Types&nbsp;affected) $(TH Semantics))\n\n    $(TR $(TD $(B '-')) $(TD numeric) $(TD Left justify the result in\n        the field.  It overrides any $(B 0) flag.))\n\n    $(TR $(TD $(B '+')) $(TD numeric) $(TD Prefix positive numbers in\n    a signed conversion with a $(B +).  It overrides any $(I space)\n    flag.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'o'))) $(TD Add to\n    precision as necessary so that the first digit of the octal\n    formatting is a '0', even if both the argument and the $(I\n    Precision) are zero.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'x'), $(B 'X'))) $(TD If\n       non-zero, prefix result with $(B 0x) ($(B 0X)).))\n\n    $(TR $(TD $(B '#')) $(TD floating) $(TD Always insert the decimal\n       point and print trailing zeros.))\n\n    $(TR $(TD $(B '#')) $(TD numeric ($(B '0'))) $(TD Use leading\n    zeros to pad rather than spaces (except for the floating point\n    values $(D nan) and $(D infinity)).  Ignore if there's a $(I\n    Precision).))\n\n    $(TR $(TD $(B ' ')) $(TD integral ($(B 'd'))) $(TD Prefix positive\n    numbers in a signed conversion with a space.)))\n\n    <dt>$(I Width)\n    <dd>\n    Specifies the minimum field width.\n    If the width is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the width.\n    If the width is negative, it is as if the $(B -) was given\n    as a $(I Flags) character.\n\n    <dt>$(I Precision)\n    <dd> Gives the precision for numeric conversions.\n    If the precision is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the precision. If it is negative,\n    it is as if there was no $(I Precision).\n\n    <dt>$(I FormatChar)\n    <dd>\n    <dl>\n        <dt>$(B 's')\n        <dd>The corresponding argument is formatted in a manner consistent\n        with its type:\n        <dl>\n            <dt>$(B bool)\n            <dd>The result is <tt>'true'<\/tt> or <tt>'false'<\/tt>.\n            <dt>integral types\n            <dd>The $(B %d) format is used.\n            <dt>floating point types\n            <dd>The $(B %g) format is used.\n            <dt>string types\n            <dd>The result is the string converted to UTF-8.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>classes derived from $(B Object)\n            <dd>The result is the string returned from the class instance's\n            $(B .toString()) method.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>non-string static and dynamic arrays\n            <dd>The result is [s<sub>0<\/sub>, s<sub>1<\/sub>, ...]\n            where s<sub>k<\/sub> is the kth element\n            formatted with the default format.\n        <\/dl>\n\n        <dt>$(B 'c')\n        <dd>The corresponding argument must be a character type.\n\n        <dt>$(B 'b','d','o','x','X')\n        <dd> The corresponding argument must be an integral type\n        and is formatted as an integer. If the argument is a signed type\n        and the $(I FormatChar) is $(B d) it is converted to\n        a signed string of characters, otherwise it is treated as\n        unsigned. An argument of type $(B bool) is formatted as '1'\n        or '0'. The base used is binary for $(B b), octal for $(B o),\n        decimal\n        for $(B d), and hexadecimal for $(B x) or $(B X).\n        $(B x) formats using lower case letters, $(B X) uppercase.\n        If there are fewer resulting digits than the $(I Precision),\n        leading zeros are used as necessary.\n        If the $(I Precision) is 0 and the number is 0, no digits\n        result.\n\n        <dt>$(B 'e','E')\n        <dd> A floating point number is formatted as one digit before\n        the decimal point, $(I Precision) digits after, the $(I FormatChar),\n        &plusmn;, followed by at least a two digit exponent: $(I d.dddddd)e$(I &plusmn;dd).\n        If there is no $(I Precision), six\n        digits are generated after the decimal point.\n        If the $(I Precision) is 0, no decimal point is generated.\n\n        <dt>$(B 'f','F')\n        <dd> A floating point number is formatted in decimal notation.\n        The $(I Precision) specifies the number of digits generated\n        after the decimal point. It defaults to six. At least one digit\n        is generated before the decimal point. If the $(I Precision)\n        is zero, no decimal point is generated.\n\n        <dt>$(B 'g','G')\n        <dd> A floating point number is formatted in either $(B e) or\n        $(B f) format for $(B g); $(B E) or $(B F) format for\n        $(B G).\n        The $(B f) format is used if the exponent for an $(B e) format\n        is greater than -5 and less than the $(I Precision).\n        The $(I Precision) specifies the number of significant\n        digits, and defaults to six.\n        Trailing zeros are elided after the decimal point, if the fractional\n        part is zero then no decimal point is generated.\n\n        <dt>$(B 'a','A')\n        <dd> A floating point number is formatted in hexadecimal\n        exponential notation 0x$(I h.hhhhhh)p$(I &plusmn;d).\n        There is one hexadecimal digit before the decimal point, and as\n        many after as specified by the $(I Precision).\n        If the $(I Precision) is zero, no decimal point is generated.\n        If there is no $(I Precision), as many hexadecimal digits as\n        necessary to exactly represent the mantissa are generated.\n        The exponent is written in as few digits as possible,\n        but at least one, is in decimal, and represents a power of 2 as in\n        $(I h.hhhhhh)*2<sup>$(I &plusmn;d)<\/sup>.\n        The exponent for zero is zero.\n        The hexadecimal digits, x and p are in upper case if the\n        $(I FormatChar) is upper case.\n    <\/dl>\n\n    Floating point NaN's are formatted as $(B nan) if the\n    $(I FormatChar) is lower case, or $(B NAN) if upper.\n    Floating point infinities are formatted as $(B inf) or\n    $(B infinity) if the\n    $(I FormatChar) is lower case, or $(B INF) or $(B INFINITY) if upper.\n    <\/dl>\n\nExamples:\n\n-------------------------\nimport std.c.stdio;\nimport std.format;\n\nvoid main()\n{\n    auto writer = appender!string();\n    formattedWrite(writer, \"%s is the ultimate %s.\", 42, \"answer\");\n    assert(writer.data == \"42 is the ultimate answer.\");\n    \/\/ Clear the writer\n    writer = appender!string();\n    formattedWrite(writer, \"Date: %2$s %1$s\", \"October\", 5);\n    assert(writer.data == \"Date: 5 October\");\n}\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the next parameter after\nthe largest positional parameter already used.\n\nExample using array and nested array formatting:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(%s %).\", [1,2,3]);\n    writefln(\"My items are %(%s, %).\", [1,2,3]);\n}\n-------------------------\n   The output is:\n<pre class=console>\nMy items are 1 2 3.\nMy items are 1, 2, 3.\n<\/pre>\n\n   The trailing end of the sub-format string following the specifier for each\n   item is interpreted as the array delimiter, and is therefore omitted\n   following the last array item. The $(B %|) delimiter specifier may be used\n   to indicate where the delimiter begins, so that the portion of the format\n   string prior to it will be retained in the last array element:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(-%s-%|, %).\", [1,2,3]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy items are -1-, -2-, -3-.\n<\/pre>\n\n   These compound format specifiers may be nested in the case of a nested\n   array argument:\n-------------------------\nimport std.stdio;\nvoid main() {\n     auto mat = [[1, 2, 3],\n                 [4, 5, 6],\n                 [7, 8, 9]];\n\n     writefln(\"%(%(%d %)\\n%)\", mat);\n     writeln();\n\n     writefln(\"[%(%(%d %)\\n %)]\", mat);\n     writeln();\n\n     writefln(\"[%([%(%d %)]%|\\n %)]\", mat);\n     writeln();\n}\n-------------------------\n   The output is:\n<pre class=console>\n1 2 3\n4 5 6\n7 8 9\n\n[1 2 3\n 4 5 6\n 7 8 9]\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n<\/pre>\n\n   Inside a compound format specifier, strings and characters are escaped\n   automatically. To avoid this behavior, add $(B '-') flag to\n   $(D \"%$(LPAREN)\").\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My friends are %s.\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %(%s, %).\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %-(%s, %).\", [\"John\", \"Nancy\"]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy friends are [\"John\", \"Nancy\"].\nMy friends are \"John\", \"Nancy\".\nMy friends are John, Nancy.\n<\/pre>\n \n",
"line" : 412}
]
}
,
{
"name" : "formattedRead(R,Char,S...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Reads characters from input range $(D r), converts them according\n   to $(D fmt), and writes them to $(D args).\n\n   Example:\n----\nstring s = \"hello!124:34.5\";\nstring a;\nint b;\ndouble c;\nformattedRead(s, \"%s!%s:%s\", &a, &b, &c);\nassert(a == \"hello\" && b == 124 && c == 34.5);\n----\n \n",
"line" : 526,
"members" : [
{
"name" : "formattedRead",
"kind" : "function",
"type" : "uint(ref R r, const(Char)[] fmt, S args)",
"comment" : "\n   Reads characters from input range $(D r), converts them according\n   to $(D fmt), and writes them to $(D args).\n\n   Example:\n----\nstring s = \"hello!124:34.5\";\nstring a;\nint b;\ndouble c;\nformattedRead(s, \"%s!%s:%s\", &a, &b, &c);\nassert(a == \"hello\" && b == 124 && c == 34.5);\n----\n \n",
"line" : 526}
]
}
,
{
"name" : "FormatSpec(Char) if (!is(Unqual!(Char) == Char))",
"kind" : "template",
"protection" : "public",
"line" : 584,
"members" : [
{
"name" : "FormatSpec",
"kind" : "alias",
"type" : "FormatSpec!(Unqual!(Char))",
"line" : 587}
]
}
,
{
"name" : "FormatSpec(Char) if (is(Unqual!(Char) == Char))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   A General handler for $(D printf) style format specifiers. Used for building more\n   specific formatting functions.\n\n   Example:\n----\nauto a = appender!(string)();\nauto fmt = \"Number: %2.4e\\nString: %s\";\nauto f = FormatSpec!char(fmt);\n\nf.writeUpToNextSpec(a);\n\nassert(a.data == \"Number: \");\nassert(f.trailing == \"\\nString: %s\");\nassert(f.spec == 'e');\nassert(f.width == 2);\nassert(f.precision == 4);\n\nf.writeUpToNextSpec(a);\n\nassert(a.data == \"Number: \\nString: \");\nassert(f.trailing == \"\");\nassert(f.spec == 's');\n----\n \n",
"line" : 617,
"members" : [
{
"name" : "FormatSpec",
"kind" : "struct",
"protection" : "public",
"line" : 617,
"members" : [
{
"name" : "width",
"kind" : "variable",
"type" : "int",
"comment" : "\n       Minimum _width, default $(D 0).\n     \n",
"line" : 621}
,
{
"name" : "precision",
"kind" : "variable",
"type" : "int",
"comment" : "\n       Precision. Its semantics depends on the argument type. For\n       floating point numbers, _precision dictates the number of\n       decimals printed.\n     \n",
"line" : 627}
,
{
"name" : "DYNAMIC",
"kind" : "variable",
"type" : "int",
"comment" : "\n       Special value for width and precision. $(D DYNAMIC) width or\n       precision means that they were specified with $(D '*') in the\n       format string and are passed at runtime through the varargs.\n     \n",
"line" : 633}
,
{
"name" : "UNSPECIFIED",
"kind" : "variable",
"type" : "int",
"comment" : "\n       Special value for precision, meaning the format specifier\n       contained no explicit precision.\n     \n",
"line" : 638}
,
{
"name" : "spec",
"kind" : "variable",
"type" : "char",
"comment" : "\n       The actual format specifier, $(D 's') by default.\n    \n",
"line" : 642}
,
{
"name" : "indexStart",
"kind" : "variable",
"type" : "ubyte",
"comment" : "\n       Index of the argument for positional parameters, from $(D 1) to\n       $(D ubyte.max). ($(D 0) means not used).\n    \n",
"line" : 647}
,
{
"name" : "indexEnd",
"kind" : "variable",
"type" : "ubyte",
"comment" : "\n       Index of the last argument for positional parameter range, from\n       $(D 1) to $(D ubyte.max). ($(D 0) means not used).\n    \n",
"line" : 652}
,
{
"name" : "allFlags",
"kind" : "variable",
"type" : "ubyte",
"line" : 686}
,
{
"name" : "nested",
"kind" : "variable",
"type" : "const(Char)[]",
"comment" : "\n       In case of a compound format specifier starting with $(D\n       \"%$(LPAREN)\") and ending with $(D \"%$(RPAREN)\"), $(D _nested)\n       contains the string contained within the two separators.\n     \n",
"line" : 702}
,
{
"name" : "sep",
"kind" : "variable",
"type" : "const(Char)[]",
"comment" : "\n       In case of a compound format specifier, $(D _sep) contains the\n       string positioning after $(D \"%|\").\n     \n",
"line" : 708}
,
{
"name" : "trailing",
"kind" : "variable",
"type" : "const(Char)[]",
"comment" : "\n       $(D _trailing) contains the rest of the format string.\n     \n",
"line" : 713}
,
{
"name" : "seqBefore",
"kind" : "variable",
"type" : "immutable(Char)[]",
"line" : 719}
,
{
"name" : "seqAfter",
"kind" : "variable",
"type" : "immutable(Char)[]",
"line" : 725}
,
{
"name" : "keySeparator",
"kind" : "variable",
"type" : "immutable(Char)[]",
"line" : 731}
,
{
"name" : "seqSeparator",
"kind" : "variable",
"type" : "immutable(Char)[]",
"line" : 737}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(in Char[] fmt)",
"comment" : "\n       Construct a new $(D FormatSpec) using the format string $(D fmt), no\n       processing is done until needed.\n     \n",
"line" : 743}
,
{
"name" : "writeUpToNextSpec(OutputRange)",
"kind" : "template",
"protection" : "public",
"line" : 748,
"members" : [
{
"name" : "writeUpToNextSpec",
"kind" : "function",
"type" : "bool(OutputRange writer)",
"line" : 748}
]
}
,
{
"name" : "fillUp",
"kind" : "function",
"type" : "void()",
"line" : 802}
,
{
"name" : "readUpToNextSpec(R)",
"kind" : "template",
"protection" : "public",
"line" : 1000,
"members" : [
{
"name" : "readUpToNextSpec",
"kind" : "function",
"type" : "bool(ref R r)",
"line" : 1000}
]
}
,
{
"name" : "getCurFmtStr",
"kind" : "function",
"type" : "string()",
"line" : 1063}
,
{
"name" : "headUpToNextSpec",
"kind" : "function",
"type" : "const(Char)[]()",
"line" : 1095}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"line" : 1121}
]
}
]
}
,
{
"name" : "singleSpec(Char)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Helper function that returns a $(D FormatSpec) for a single specifier given\n   in $(D fmt)\n\n   Returns a $(D FormatSpec) with the specifier parsed.\n\n   Enforces giving only one specifier to the function.\n  \n",
"line" : 1168,
"members" : [
{
"name" : "singleSpec",
"kind" : "function",
"type" : "FormatSpec!(Char)(Char[] fmt)",
"comment" : "\n   Helper function that returns a $(D FormatSpec) for a single specifier given\n   in $(D fmt)\n\n   Returns a $(D FormatSpec) with the specifier parsed.\n\n   Enforces giving only one specifier to the function.\n  \n",
"line" : 1168}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isBoolean!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   $(D bool)s are formatted as \"true\" or \"false\" with %s and as \"1\" or\n   \"0\" with integral-specific format specs.\n \n",
"line" : 1204,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   $(D bool)s are formatted as \"true\" or \"false\" with %s and as \"1\" or\n   \"0\" with integral-specific format specs.\n \n",
"line" : 1204}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && is(T == typeof(null)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   $(D null) literal is formatted as $(D \"null\").\n \n",
"line" : 1240,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   $(D null) literal is formatted as $(D \"null\").\n \n",
"line" : 1240}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isIntegral!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Integrals are formatted like $(D printf) does.\n \n",
"line" : 1256,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   Integrals are formatted like $(D printf) does.\n \n",
"line" : 1256}
]
}
,
{
"name" : "formatIntegral(Writer,T,Char)",
"kind" : "template",
"protection" : "public",
"line" : 1288,
"members" : [
{
"name" : "formatIntegral",
"kind" : "function",
"type" : "void(Writer w, const(T) val, ref FormatSpec!(Char) f, ulong mask)",
"line" : 1288}
]
}
,
{
"name" : "formatUnsigned(Writer,Char)",
"kind" : "template",
"protection" : "public",
"line" : 1314,
"members" : [
{
"name" : "formatUnsigned",
"kind" : "function",
"type" : "void(Writer w, ulong arg, ref FormatSpec!(Char) fs, uint base, bool negative)",
"line" : 1314}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isFloatingPoint!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Floating-point values are formatted like $(D printf) does.\n \n",
"line" : 1435,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n Floating-point values are formatted like $(D printf) does.\n \n",
"line" : 1435}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && is(Unqual!(T) : creal) && !is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 1521,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"line" : 1521}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && is(Unqual!(T) : ireal) && !is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 1562,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"line" : 1562}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Individual characters ($(D char), $(D wchar), or $(D dchar)) are\n   formatted as Unicode characters with %s and as integers with\n   integral-specific format specs.\n \n",
"line" : 1603,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   Individual characters ($(D char), $(D wchar), or $(D dchar)) are\n   formatted as Unicode characters with %s and as integers with\n   integral-specific format specs.\n \n",
"line" : 1603}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isSomeString!(T) && !isStaticArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Strings are formatted like $(D printf) does.\n \n",
"line" : 1638,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   Strings are formatted like $(D printf) does.\n \n",
"line" : 1638}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isStaticArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Static-size arrays are formatted as dynamic arrays.\n \n",
"line" : 1679,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, auto ref T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   Static-size arrays are formatted as dynamic arrays.\n \n",
"line" : 1679}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && !isSomeString!(T) && isDynamicArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Dynamic arrays are formatted as input ranges.\n\n   Specializations:\n     $(UL $(LI $(D void[]) is formatted like $(D ubyte[]).)\n          $(LI Const array is converted to input range by removing its qualifier.))\n \n",
"line" : 1704,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   Dynamic arrays are formatted as input ranges.\n\n   Specializations:\n     $(UL $(LI $(D void[]) is formatted like $(D ubyte[]).)\n          $(LI Const array is converted to input range by removing its qualifier.))\n \n",
"line" : 1704}
]
}
,
{
"name" : "formatRange(Writer,T,Char) if (isInputRange!(T))",
"kind" : "template",
"protection" : "public",
"line" : 1901,
"members" : [
{
"name" : "formatRange",
"kind" : "function",
"type" : "void(ref Writer w, ref T val, ref FormatSpec!(Char) f)",
"line" : 1901}
]
}
,
{
"name" : "formatChar(Writer)",
"kind" : "template",
"protection" : "public",
"line" : 2051,
"members" : [
{
"name" : "formatChar",
"kind" : "function",
"type" : "void(Writer w, in dchar c, in char quote)",
"line" : 2051}
]
}
,
{
"name" : "formatElement(Writer,T,Char) if (isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"line" : 2084,
"members" : [
{
"name" : "formatElement",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"line" : 2084}
]
}
,
{
"name" : "formatElement(Writer,T,Char) if (isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"line" : 2154,
"members" : [
{
"name" : "formatElement",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"line" : 2154}
]
}
,
{
"name" : "formatElement(Writer,T,Char) if (!isSomeString!(T) && !isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"line" : 2169,
"members" : [
{
"name" : "formatElement",
"kind" : "function",
"type" : "void(Writer w, auto ref T val, ref FormatSpec!(Char) f)",
"line" : 2169}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isAssociativeArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Associative arrays are formatted by using $(D ':') and $(D ', ') as\n   separators, and enclosed by $(D '[') and $(D ']').\n \n",
"line" : 2179,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
"comment" : "\n   Associative arrays are formatted by using $(D ':') and $(D ', ') as\n   separators, and enclosed by $(D '[') and $(D ']').\n \n",
"line" : 2179}
]
}
,
{
"name" : "hasToString(T,Char)",
"kind" : "template",
"protection" : "public",
"line" : 2266,
"members" : [
]
}
,
{
"name" : "formatObject(Writer,T,Char) if (hasToString!(T,Char))",
"kind" : "template",
"protection" : "public",
"line" : 2296,
"members" : [
{
"name" : "formatObject",
"kind" : "function",
"type" : "void(ref Writer w, ref T val, ref FormatSpec!(Char) f)",
"line" : 2296}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (is(T == class) && !is(T == enum))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Aggregates ($(D struct), $(D union), $(D class), and $(D interface)) are\n   basically formatted by calling $(D toString).\n   $(D toString) should have one of the following signatures:\n\n---\nconst void toString(scope void delegate(const(char)[]) sink, FormatSpec fmt);\nconst void toString(scope void delegate(const(char)[]) sink, string fmt);\nconst void toString(scope void delegate(const(char)[]) sink);\nconst string toString();\n---\n\n   For the class objects which have input range interface,\n   $(UL $(LI If the instance $(D toString) has overridden\n             $(D Object.toString), it is used.)\n        $(LI Otherwise, the objects are formatted as input range.))\n\n   For the struct and union objects which does not have $(D toString),\n   $(UL $(LI If they have range interface, formatted as input range.)\n        $(LI Otherwise, they are formatted like $(D Type(field1, filed2, ...)).))\n\n   Otherwise, are formatted just as their type name.\n \n",
"line" : 2342,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"comment" : "\n   Aggregates ($(D struct), $(D union), $(D class), and $(D interface)) are\n   basically formatted by calling $(D toString).\n   $(D toString) should have one of the following signatures:\n\n---\nconst void toString(scope void delegate(const(char)[]) sink, FormatSpec fmt);\nconst void toString(scope void delegate(const(char)[]) sink, string fmt);\nconst void toString(scope void delegate(const(char)[]) sink);\nconst string toString();\n---\n\n   For the class objects which have input range interface,\n   $(UL $(LI If the instance $(D toString) has overridden\n             $(D Object.toString), it is used.)\n        $(LI Otherwise, the objects are formatted as input range.))\n\n   For the struct and union objects which does not have $(D toString),\n   $(UL $(LI If they have range interface, formatted as input range.)\n        $(LI Otherwise, they are formatted like $(D Type(field1, filed2, ...)).))\n\n   Otherwise, are formatted just as their type name.\n \n",
"line" : 2342}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (is(T == interface) && (hasToString!(T,Char) || !isBuiltinType!(T)) && !is(T == enum))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2443,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"comment" : " ditto\n",
"line" : 2443}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if ((is(T == struct) || is(T == union)) && (hasToString!(T,Char) || !isBuiltinType!(T)) && !is(T == enum))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2486,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, auto ref T val, ref FormatSpec!(Char) f)",
"comment" : " ditto\n",
"line" : 2486}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (is(T == enum))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   $(D enum) is formatted like its base value.\n \n",
"line" : 2613,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"comment" : "\n   $(D enum) is formatted like its base value.\n \n",
"line" : 2613}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && isPointer!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Pointers are formatted as hex integers.\n \n",
"line" : 2667,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"comment" : "\n   Pointers are formatted as hex integers.\n \n",
"line" : 2667}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (!hasToString!(T,Char) && is(T == delegate))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Delegates are formatted by 'Attributes ReturnType delegate(Parameters)'\n \n",
"line" : 2741,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"comment" : "\n   Delegates are formatted by 'Attributes ReturnType delegate(Parameters)'\n \n",
"line" : 2741}
]
}
,
{
"name" : "formatValue(Writer,T,Char) if (is(T == typedef))",
"kind" : "template",
"protection" : "public",
"line" : 2765,
"members" : [
{
"name" : "formatValue",
"kind" : "function",
"type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
"line" : 2765}
]
}
,
{
"name" : "formatGeneric(Writer,D,Char)",
"kind" : "template",
"protection" : "public",
"line" : 2780,
"members" : [
{
"name" : "formatGeneric",
"kind" : "function",
"type" : "void(Writer w, const(void)* arg, ref FormatSpec!(Char) f)",
"line" : 2780}
]
}
,
{
"name" : "formatNth(Writer,Char,A...)",
"kind" : "template",
"protection" : "public",
"line" : 2785,
"members" : [
{
"name" : "formatNth",
"kind" : "function",
"type" : "void(Writer w, ref FormatSpec!(Char) f, size_t index, A args)",
"line" : 2785}
]
}
,
{
"name" : "getNthInt(A...)",
"kind" : "template",
"protection" : "public",
"line" : 2825,
"members" : [
{
"name" : "getNthInt",
"kind" : "function",
"type" : "int(uint index, A args)",
"line" : 2825}
]
}
,
{
"name" : "skipData(Range,Char)",
"kind" : "template",
"protection" : "public",
"line" : 3561,
"members" : [
{
"name" : "skipData",
"kind" : "function",
"type" : "void(ref Range input, ref FormatSpec!(Char) spec)",
"line" : 3561}
]
}
,
{
"name" : "acceptedSpecs(T)",
"kind" : "template",
"protection" : "public",
"line" : 3578,
"members" : [
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && is(Unqual!(T) == bool))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Reads a boolean value and returns it.\n \n",
"line" : 3589,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n Reads a boolean value and returns it.\n \n",
"line" : 3589}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && is(T == typeof(null)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Reads null literal and returns it.\n \n",
"line" : 3644,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n Reads null literal and returns it.\n \n",
"line" : 3644}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && isIntegral!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Reads an integral value and returns it.\n \n",
"line" : 3656,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n   Reads an integral value and returns it.\n \n",
"line" : 3656}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isFloatingPoint!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Reads a floating-point value and returns it.\n \n",
"line" : 3676,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n   Reads a floating-point value and returns it.\n \n",
"line" : 3676}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Reads one character and returns it.\n \n",
"line" : 3752,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n Reads one character and returns it.\n \n",
"line" : 3752}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Reads a string and returns it.\n \n",
"line" : 3789,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n   Reads a string and returns it.\n \n",
"line" : 3789}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && isArray!(T) && !isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Reads an array (except for string types) and returns it.\n \n",
"line" : 3865,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n   Reads an array (except for string types) and returns it.\n \n",
"line" : 3865}
]
}
,
{
"name" : "unformatValue(T,Range,Char) if (isInputRange!(Range) && isAssociativeArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Reads an associative array and returns it.\n \n",
"line" : 3958,
"members" : [
{
"name" : "unformatValue",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"comment" : "\n Reads an associative array and returns it.\n \n",
"line" : 3958}
]
}
,
{
"name" : "unformatRange(T,Range,Char)",
"kind" : "template",
"protection" : "public",
"line" : 3993,
"members" : [
{
"name" : "unformatRange",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"line" : 3993}
]
}
,
{
"name" : "unformatElement(T,Range,Char) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"line" : 4093,
"members" : [
{
"name" : "unformatElement",
"kind" : "function",
"type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
"line" : 4093}
]
}
,
{
"name" : "Mangle",
"kind" : "enum",
"protection" : "public",
"line" : 4117,
"base" : "char",
"members" : [
{
"name" : "Tvoid",
"kind" : "enum member",
"protection" : "public",
"line" : 4119}
,
{
"name" : "Tbool",
"kind" : "enum member",
"protection" : "public",
"line" : 4120}
,
{
"name" : "Tbyte",
"kind" : "enum member",
"protection" : "public",
"line" : 4121}
,
{
"name" : "Tubyte",
"kind" : "enum member",
"protection" : "public",
"line" : 4122}
,
{
"name" : "Tshort",
"kind" : "enum member",
"protection" : "public",
"line" : 4123}
,
{
"name" : "Tushort",
"kind" : "enum member",
"protection" : "public",
"line" : 4124}
,
{
"name" : "Tint",
"kind" : "enum member",
"protection" : "public",
"line" : 4125}
,
{
"name" : "Tuint",
"kind" : "enum member",
"protection" : "public",
"line" : 4126}
,
{
"name" : "Tlong",
"kind" : "enum member",
"protection" : "public",
"line" : 4127}
,
{
"name" : "Tulong",
"kind" : "enum member",
"protection" : "public",
"line" : 4128}
,
{
"name" : "Tfloat",
"kind" : "enum member",
"protection" : "public",
"line" : 4129}
,
{
"name" : "Tdouble",
"kind" : "enum member",
"protection" : "public",
"line" : 4130}
,
{
"name" : "Treal",
"kind" : "enum member",
"protection" : "public",
"line" : 4131}
,
{
"name" : "Tifloat",
"kind" : "enum member",
"protection" : "public",
"line" : 4133}
,
{
"name" : "Tidouble",
"kind" : "enum member",
"protection" : "public",
"line" : 4134}
,
{
"name" : "Tireal",
"kind" : "enum member",
"protection" : "public",
"line" : 4135}
,
{
"name" : "Tcfloat",
"kind" : "enum member",
"protection" : "public",
"line" : 4136}
,
{
"name" : "Tcdouble",
"kind" : "enum member",
"protection" : "public",
"line" : 4137}
,
{
"name" : "Tcreal",
"kind" : "enum member",
"protection" : "public",
"line" : 4138}
,
{
"name" : "Tchar",
"kind" : "enum member",
"protection" : "public",
"line" : 4140}
,
{
"name" : "Twchar",
"kind" : "enum member",
"protection" : "public",
"line" : 4141}
,
{
"name" : "Tdchar",
"kind" : "enum member",
"protection" : "public",
"line" : 4142}
,
{
"name" : "Tarray",
"kind" : "enum member",
"protection" : "public",
"line" : 4144}
,
{
"name" : "Tsarray",
"kind" : "enum member",
"protection" : "public",
"line" : 4145}
,
{
"name" : "Taarray",
"kind" : "enum member",
"protection" : "public",
"line" : 4146}
,
{
"name" : "Tpointer",
"kind" : "enum member",
"protection" : "public",
"line" : 4147}
,
{
"name" : "Tfunction",
"kind" : "enum member",
"protection" : "public",
"line" : 4148}
,
{
"name" : "Tident",
"kind" : "enum member",
"protection" : "public",
"line" : 4149}
,
{
"name" : "Tclass",
"kind" : "enum member",
"protection" : "public",
"line" : 4150}
,
{
"name" : "Tstruct",
"kind" : "enum member",
"protection" : "public",
"line" : 4151}
,
{
"name" : "Tenum",
"kind" : "enum member",
"protection" : "public",
"line" : 4152}
,
{
"name" : "Ttypedef",
"kind" : "enum member",
"protection" : "public",
"line" : 4153}
,
{
"name" : "Tdelegate",
"kind" : "enum member",
"protection" : "public",
"line" : 4154}
,
{
"name" : "Tconst",
"kind" : "enum member",
"protection" : "public",
"line" : 4156}
,
{
"name" : "Timmutable",
"kind" : "enum member",
"protection" : "public",
"line" : 4157}
]
}
,
{
"name" : "primitiveTypeInfo",
"kind" : "function",
"protection" : "private",
"type" : "TypeInfo(Mangle m)",
"line" : 4164}
,
{
"name" : "doFormat",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(dchar) putc, TypeInfo[] arguments, void* argptr)",
"line" : 4457}
]
}
,
{
"name" : "std.functional",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/functional.d",
"comment" : "\nFunctions that manipulate other functions.\n\nMacros:\n\nWIKI = Phobos\/StdFunctional\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nSource:    $(PHOBOSSRC std\/_functional.d)\n",
"members" : [
{
"name" : "unaryFun(alias fun,bool byRef = false,string parmName = \"a\")",
"kind" : "template",
"protection" : "public",
"comment" : "\nTransforms a string representing an expression into a unary\nfunction. The string must use symbol name $(D a) as the parameter.\n\nExample:\n\n----\nalias unaryFun!(\"(a & 1) == 0\") isEven;\nassert(isEven(2) && !isEven(1));\n----\n",
"line" : 39,
"members" : [
]
}
,
{
"name" : "binaryFun(alias fun,string parm1Name = \"a\",string parm2Name = \"b\")",
"kind" : "template",
"protection" : "public",
"comment" : "\nTransforms a string representing an expression into a Boolean binary\npredicate. The string must use symbol names $(D a) and $(D b) as the\ncompared elements.\n\n   Example:\n\n----\nalias binaryFun!(\"a < b\") less;\nassert(less(1, 2) && !less(2, 1));\nalias binaryFun!(\"a > b\") greater;\nassert(!greater(\"1\", \"2\") && greater(\"2\", \"1\"));\n----\n",
"line" : 96,
"members" : [
]
}
,
{
"name" : "binaryReverseArgs(alias pred)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Binary predicate that reverses the order of arguments, e.g., given\n   $(D pred(a, b)), returns $(D pred(b, a)).\n",
"line" : 152,
"members" : [
{
"name" : "binaryReverseArgs(ElementType1,ElementType2)",
"kind" : "template",
"protection" : "public",
"line" : 155,
"members" : [
{
"name" : "binaryReverseArgs",
"kind" : "function",
"type" : "(ElementType1 a, ElementType2 b)",
"line" : 155}
]
}
]
}
,
{
"name" : "not(alias pred)",
"kind" : "template",
"protection" : "public",
"comment" : "\nNegates predicate $(D pred).\n\nExample:\n----\nstring a = \"   Hello, world!\";\nassert(find!(not!isWhite)(a) == \"Hello, world!\");\n----\n \n",
"line" : 182,
"members" : [
{
"name" : "not(T...) if (is(typeof(!unaryFun!(pred)(args))) || is(typeof(!binaryFun!(pred)(args))))",
"kind" : "template",
"protection" : "public",
"line" : 184,
"members" : [
{
"name" : "not",
"kind" : "function",
"type" : "(T args)",
"line" : 184}
]
}
]
}
,
{
"name" : "curry(alias fun,alias arg)",
"kind" : "template",
"protection" : "public",
"comment" : "\nCurries $(D fun) by tying its first argument to a particular value.\n\nExample:\n\n----\nint fun(int a, int b) { return a + b; }\nalias curry!(fun, 5) fun5;\nassert(fun5(6) == 11);\n----\n\nNote that in most cases you'd use an alias instead of a value\nassignment. Using an alias allows you to curry template functions\nwithout committing to a particular type of the function.\n \n",
"line" : 211,
"members" : [
]
}
,
{
"name" : "adjoin(F...) if (F.length)",
"kind" : "template",
"protection" : "public",
"comment" : "\nTakes multiple functions and adjoins them together. The result is a\n$(XREF typecons, Tuple) with one element per passed-in function. Upon\ninvocation, the returned tuple is the adjoined results of all\nfunctions.\n\nExample:\n\n----\nstatic bool f1(int a) { return a != 0; }\nstatic int f2(int a) { return a \/ 2; }\nauto x = adjoin!(f1, f2)(5);\nassert(is(typeof(x) == Tuple!(bool, int)));\nassert(x[0] == true && x[1] == 2);\n----\n",
"line" : 353,
"members" : [
{
"name" : "adjoin(V...)",
"kind" : "template",
"protection" : "public",
"line" : 355,
"members" : [
{
"name" : "adjoin",
"kind" : "function",
"type" : "(V a)",
"line" : 355}
]
}
]
}
,
{
"name" : "compose(fun...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Composes passed-in functions $(D fun[0], fun[1], ...) returning a\n   function $(D f(x)) that in turn returns $(D\n   fun[0](fun[1](...(x)))...). Each function can be a regular\n   functions, a delegate, or a string.\n\n   Example:\n\n----\n\/\/ First split a string in whitespace-separated tokens and then\n\/\/ convert each token into an integer\nassert(compose!(map!(to!(int)), split)(\"1 2 3\") == [1, 2, 3]);\n----\n",
"line" : 457,
"members" : [
]
}
,
{
"name" : "pipe(fun...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Pipes functions in sequence. Offers the same functionality as $(D\n   compose), but with functions specified in reverse order. This may\n   lead to more readable code in some situation because the order of\n   execution is the same as lexical order.\n\n   Example:\n\n----\n\/\/ Read an entire text file, split the resulting string in\n\/\/ whitespace-separated tokens, and then convert each token into an\n\/\/ integer\nint[] a = pipe!(readText, split, map!(to!(int)))(\"file.txt\");\n----\n \n",
"line" : 497,
"members" : [
{
"name" : "pipe",
"kind" : "alias",
"type" : "compose!(Reverse!(fun))",
"line" : 499}
]
}
,
{
"name" : "memoize(alias fun,uint maxSize = (uint).max)",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(LUCKY Memoizes) a function so as to avoid repeated\n computation. The memoization structure is a hash table keyed by a\n tuple of the function's arguments. There is a speed gain if the\n function is repeatedly called with the same arguments and is more\n expensive than a hash table lookup. For more information on memoization, refer to $(WEB docs.google.com\/viewer?url=http%3A%2F%2Fhop.perl.plover.com%2Fbook%2Fpdf%2F03CachingAndMemoization.pdf, this book chapter).\n\nExample:\n----\ndouble transmogrify(int a, string b)\n{\n   ... expensive computation ...\n}\nalias memoize!transmogrify fastTransmogrify;\nunittest\n{\n    auto slow = transmogrify(2, \"hello\");\n    auto fast = fastTransmogrify(2, \"hello\");\n    assert(slow == fast);\n}\n----\n\nTechnically the memoized function should be pure because $(D memoize) assumes it will\nalways return the same result for a given tuple of arguments. However, $(D memoize) does not\nenforce that because sometimes it\nis useful to memoize an impure function, too.\n\nTo _memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call.\nFor example, to transform the exponential-time Fibonacci implementation into a linear-time computation:\n\nExample:\n----\nulong fib(ulong n)\n{\n    alias memoize!fib mfib;\n    return n < 2 ? 1 : mfib(n - 2) + mfib(n - 1);\n}\n...\nassert(fib(10) == 89);\n----\n\nTo improve the speed of the factorial function,\n\nExample:\n----\nulong fact(ulong n)\n{\n    alias memoize!fact mfact;\n    return n < 2 ? 1 : n * mfact(n - 1);\n}\n...\nassert(fact(10) == 3628800);\n----\n\nThis memoizes all values of $(D fact) up to the largest argument. To only cache the final\nresult, move $(D memoize) outside the function as shown below.\n\nExample:\n----\nulong factImpl(ulong n)\n{\n    return n < 2 ? 1 : n * mfact(n - 1);\n}\nalias memoize!factImpl fact;\n...\nassert(fact(10) == 3628800);\n----\n\nThe $(D maxSize) parameter is a cutoff for the cache size. If upon a miss the length of the hash\ntable is found to be $(D maxSize), the table is simply cleared.\n\nExample:\n----\n\/\/ Memoize no more than 128 values of transmogrify\nalias memoize!(transmogrify, 128) fastTransmogrify;\n----\n",
"line" : 596,
"members" : [
{
"name" : "memoize",
"kind" : "function",
"type" : "ReturnType!(fun)(ParameterTypeTuple!(fun) args)",
"line" : 598}
]
}
,
{
"name" : "DelegateFaker(F)",
"kind" : "struct",
"protection" : "public",
"line" : 646,
"members" : [
{
"name" : "DelegateFaker",
"kind" : "struct",
"protection" : "public",
"line" : 646,
"members" : [
{
"name" : "castToF(THIS)",
"kind" : "template",
"protection" : "public",
"line" : 648,
"members" : [
{
"name" : "castToF",
"kind" : "function",
"type" : "@trusted F(THIS x)",
"line" : 648}
]
}
,
{
"name" : "GeneratingPolicy()",
"kind" : "template",
"protection" : "public",
"line" : 669,
"members" : [
{
"name" : "WITHOUT_SYMBOL",
"kind" : "variable",
"line" : 672}
,
{
"name" : "generateFunctionBody(unused...)",
"kind" : "template",
"protection" : "public",
"line" : 675,
"members" : [
{
"name" : "generateFunctionBody",
"kind" : "variable",
"line" : 687}
]
}
]
}
,
{
"name" : "FuncInfo_doIt",
"kind" : "alias",
"type" : "FuncInfo!(F)",
"line" : 691}
]
}
]
}
,
{
"name" : "toDelegate(F) if (isCallable!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Convert a callable to a delegate with the same parameter list and\n return type, avoiding heap allocations and use of auxiliary storage.\n\n Examples:\n ----\n void doStuff() {\n     writeln(\"Hello, world.\");\n }\n\n void runDelegate(void delegate() myDelegate) {\n     myDelegate();\n }\n\n auto delegateToPass = toDelegate(&doStuff);\n runDelegate(delegateToPass);  \/\/ Calls doStuff, prints \"Hello, world.\"\n ----\n\n BUGS:\n $(UL\n   $(LI Does not work with $(D @safe) functions.)\n   $(LI Ignores C-style \/ D-style variadic arguments.)\n )\n \n",
"line" : 722,
"members" : [
{
"name" : "toDelegate",
"kind" : "function",
"type" : "(auto ref F fp)",
"comment" : "\n Convert a callable to a delegate with the same parameter list and\n return type, avoiding heap allocations and use of auxiliary storage.\n\n Examples:\n ----\n void doStuff() {\n     writeln(\"Hello, world.\");\n }\n\n void runDelegate(void delegate() myDelegate) {\n     myDelegate();\n }\n\n auto delegateToPass = toDelegate(&doStuff);\n runDelegate(delegateToPass);  \/\/ Calls doStuff, prints \"Hello, world.\"\n ----\n\n BUGS:\n $(UL\n   $(LI Does not work with $(D @safe) functions.)\n   $(LI Ignores C-style \/ D-style variadic arguments.)\n )\n \n",
"line" : 722}
]
}
]
}
,
{
"name" : "std.getopt",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/getopt.d",
"comment" : "\nProcessing of command line options.\n\nThe getopt module implements a $(D getopt) function, which adheres to\nthe POSIX syntax for command line options. GNU extensions are\nsupported in the form of long options introduced by a double dash\n(\"--\"). Support for bundling of command line options, as was the case\nwith the more traditional single-letter approach, is provided but not\nenabled by default.\n\nMacros:\n\nWIKI = Phobos\/StdGetopt\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nCredits:   This module and its documentation are inspired by Perl's $(WEB\n                   perldoc.perl.org\/Getopt\/Long.html, Getopt::Long) module. The syntax of\n                   D's $(D getopt) is simpler than its Perl counterpart because $(D\n                   getopt) infers the expected parameter types from the static types of\n                   the passed-in pointers.\nSource:    $(PHOBOSSRC std\/_getopt.d)\n",
"members" : [
{
"name" : "getopt(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Synopsis:\n\n---------\nimport std.getopt;\n\nstring data = \"file.dat\";\nint length = 24;\nbool verbose;\nenum Color { no, yes };\nColor color;\n\nvoid main(string[] args)\n{\n  getopt(\n    args,\n    \"length\",  &length,    \/\/ numeric\n    \"file\",    &data,      \/\/ string\n    \"verbose\", &verbose,   \/\/ flag\n    \"color\",   &color);    \/\/ enum\n  ...\n}\n---------\n\n The $(D getopt) function takes a reference to the command line\n (as received by $(D main)) as its first argument, and an\n unbounded number of pairs of strings and pointers. Each string is an\n option meant to \"fill\" the value pointed-to by the pointer to its\n right (the \"bound\" pointer). The option string in the call to\n $(D getopt) should not start with a dash.\n\n In all cases, the command-line options that were parsed and used by\n $(D getopt) are removed from $(D args). Whatever in the\n arguments did not look like an option is left in $(D args) for\n further processing by the program. Values that were unaffected by the\n options are not touched, so a common idiom is to initialize options\n to their defaults and then invoke $(D getopt). If a\n command-line argument is recognized as an option with a parameter and\n the parameter cannot be parsed properly (e.g. a number is expected\n but not present), a $(D ConvException) exception is thrown.\n\n Depending on the type of the pointer being bound, $(D getopt)\n recognizes the following kinds of options:\n\n $(OL $(LI $(I Boolean options). These are the simplest options; all\n they do is set a Boolean to $(D true):\n\n---------\n  bool verbose, debugging;\n  getopt(args, \"verbose\", &verbose, \"debug\", &debugging);\n---------\n\n )$(LI $(I Numeric options.) If an option is bound to a numeric type, a\n number is expected as the next option, or right within the option\n separated with an \"=\" sign:\n\n---------\n  uint timeout;\n  getopt(args, \"timeout\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), invoke the program with either $(D\n--timeout=5) or $(D --timeout 5).\n\n $(UL $(LI $(I Incremental options.) If an option name has a \"+\" suffix and\n is bound to a numeric type, then the option's value tracks the number\n of times the option occurred on the command line:\n\n---------\n  uint paranoid;\n  getopt(args, \"paranoid+\", &paranoid);\n---------\n\n Invoking the program with \"--paranoid --paranoid --paranoid\" will set\n $(D paranoid) to 3. Note that an incremental option never\n expects a parameter, e.g. in the command line \"--paranoid 42\n --paranoid\", the \"42\" does not set $(D paranoid) to 42;\n instead, $(D paranoid) is set to 2 and \"42\" is not considered\n as part of the normal program arguments.)))\n\n $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as a\n string is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\n  enum Color { no, yes };\n  Color color; \/\/ default initialized to Color.no\n  getopt(args, \"color\", &color);\n---------\n\nTo set $(D color) to $(D Color.yes), invoke the program with either $(D\n--color=yes) or $(D --color yes).)\n\n $(LI $(I String options.) If an option is bound to a string, a string\n is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\nstring outputFile;\ngetopt(args, \"output\", &outputFile);\n---------\n\n Invoking the program with \"--output=myfile.txt\" or \"--output\n myfile.txt\" will set $(D outputFile) to \"myfile.txt\". If you want to\n pass a string containing spaces, you need to use the quoting that is\n appropriate to your shell, e.g. --output='my file.txt'.)\n\n $(LI $(I Array options.) If an option is bound to an array, a new\n element is appended to the array each time the option occurs:\n\n---------\nstring[] outputFiles;\ngetopt(args, \"output\", &outputFiles);\n---------\n\n Invoking the program with \"--output=myfile.txt --output=yourfile.txt\"\n or \"--output myfile.txt --output yourfile.txt\" will set $(D\n outputFiles) to [ \"myfile.txt\", \"yourfile.txt\" ] .)\n\n $(LI $(I Hash options.) If an option is bound to an associative\n array, a string of the form \"name=value\" is expected as the next\n option, or right within the option separated with an \"=\" sign:\n\n---------\ndouble[string] tuningParms;\ngetopt(args, \"tune\", &tuningParms);\n---------\n\nInvoking the program with e.g. \"--tune=alpha=0.5 --tune beta=0.6\" will\nset $(D tuningParms) to [ \"alpha\" : 0.5, \"beta\" : 0.6 ]. In general,\nkeys and values can be of any parsable types.)\n\n$(LI $(I Delegate options.) An option can be bound to a delegate with\nthe signature $(D void delegate()), $(D void delegate(string option))\nor $(D void delegate(string option, string value)).\n\n$(UL $(LI In the $(D void delegate()) case, the delegate is invoked\nwhenever the option is seen.) $(LI In the $(D void delegate(string\noption)) case, the option string (without the leading dash(es)) is\npassed to the delegate. After that, the option string is considered\nhandled and removed from the options array.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option)\n  {\n    if (option == \"quiet\")\n    {\n      verbosityLevel = 0;\n    }\n    else\n    {\n      assert(option == \"verbose\");\n      verbosityLevel = 2;\n    }\n  }\n  getopt(args, \"verbose\", &myHandler, \"quiet\", &myHandler);\n}\n---------\n\n)$(LI In the $(D void delegate(string option, string value)) case, the\noption string is handled as an option with one argument, and parsed\naccordingly. The option and its value are passed to the\ndelegate. After that, whatever was passed to the delegate is\nconsidered handled and removed from the list.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option, string value)\n  {\n    switch (value)\n    {\n      case \"quiet\": verbosityLevel = 0; break;\n      case \"verbose\": verbosityLevel = 2; break;\n      case \"shouting\": verbosityLevel = verbosityLevel.max; break;\n      default :\n        stderr.writeln(\"Dunno how verbose you want me to be by saying \",\n          value);\n        exit(1);\n    }\n  }\n  getopt(args, \"verbosity\", &myHandler);\n}\n---------\n))))\n\n$(B Options with multiple names)\n\nSometimes option synonyms are desirable, e.g. \"--verbose\",\n\"--loquacious\", and \"--garrulous\" should have the same effect. Such\nalternate option names can be included in the option specification,\nusing \"|\" as a separator:\n\n---------\nbool verbose;\ngetopt(args, \"verbose|loquacious|garrulous\", &verbose);\n---------\n\n$(B Case)\n\nBy default options are case-insensitive. You can change that behavior\nby passing $(D getopt) the $(D caseSensitive) directive like this:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nIn the example above, \"--foo\", \"--bar\", \"--FOo\", \"--bAr\" etc. are recognized.\nThe directive is active til the end of $(D getopt), or until the\nconverse directive $(D caseInsensitive) is encountered:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    std.getopt.config.caseInsensitive,\n    \"bar\", &bar);\n---------\n\nThe option \"--Foo\" is rejected due to $(D\nstd.getopt.config.caseSensitive), but not \"--Bar\", \"--bAr\"\netc. because the directive $(D\nstd.getopt.config.caseInsensitive) turned sensitivity off before\noption \"bar\" was parsed.\n\n$(B \"Short\" versus \"long\" options)\n\nTraditionally, programs accepted single-letter options preceded by\nonly one dash (e.g. $(D -t)). $(D getopt) accepts such parameters\nseamlessly. When used with a double-dash (e.g. $(D --t)), a\nsingle-letter option behaves the same as a multi-letter option. When\nused with a single dash, a single-letter option is accepted. If the\noption has a parameter, that must be \"stuck\" to the option without\nany intervening space or \"=\":\n\n---------\nuint timeout;\ngetopt(args, \"timeout|t\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), use either of the following: $(D --timeout=5),\n$(D --timeout 5), $(D --t=5), $(D --t 5), or $(D -t5). Forms such as $(D -t 5)\nand $(D -timeout=5) will be not accepted.\n\nFor more details about short options, refer also to the next section.\n\n$(B Bundling)\n\nSingle-letter options can be bundled together, i.e. \"-abc\" is the same as\n$(D \"-a -b -c\"). By default, this confusing option is turned off. You can\nturn it on with the $(D std.getopt.config.bundling) directive:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.bundling,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nIn case you want to only enable bundling for some of the parameters,\nbundling can be turned off with $(D std.getopt.config.noBundling).\n\n$(B Passing unrecognized options through)\n\nIf an application needs to do its own processing of whichever arguments\n$(D getopt) did not understand, it can pass the\n$(D std.getopt.config.passThrough) directive to $(D getopt):\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.passThrough,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nAn unrecognized option such as \"--baz\" will be found untouched in\n$(D args) after $(D getopt) returns.\n\n$(B Options Terminator)\n\nA lonesome double-dash terminates $(D getopt) gathering. It is used to\nseparate program options from other parameters (e.g. options to be passed\nto another program). Invoking the example above with $(D \"--foo -- --bar\")\nparses foo but leaves \"--bar\" in $(D args). The double-dash itself is\nremoved from the argument array.\n",
"line" : 341,
"members" : [
{
"name" : "getopt",
"kind" : "function",
"type" : "void(ref string[] args, T opts)",
"comment" : "\n Synopsis:\n\n---------\nimport std.getopt;\n\nstring data = \"file.dat\";\nint length = 24;\nbool verbose;\nenum Color { no, yes };\nColor color;\n\nvoid main(string[] args)\n{\n  getopt(\n    args,\n    \"length\",  &length,    \/\/ numeric\n    \"file\",    &data,      \/\/ string\n    \"verbose\", &verbose,   \/\/ flag\n    \"color\",   &color);    \/\/ enum\n  ...\n}\n---------\n\n The $(D getopt) function takes a reference to the command line\n (as received by $(D main)) as its first argument, and an\n unbounded number of pairs of strings and pointers. Each string is an\n option meant to \"fill\" the value pointed-to by the pointer to its\n right (the \"bound\" pointer). The option string in the call to\n $(D getopt) should not start with a dash.\n\n In all cases, the command-line options that were parsed and used by\n $(D getopt) are removed from $(D args). Whatever in the\n arguments did not look like an option is left in $(D args) for\n further processing by the program. Values that were unaffected by the\n options are not touched, so a common idiom is to initialize options\n to their defaults and then invoke $(D getopt). If a\n command-line argument is recognized as an option with a parameter and\n the parameter cannot be parsed properly (e.g. a number is expected\n but not present), a $(D ConvException) exception is thrown.\n\n Depending on the type of the pointer being bound, $(D getopt)\n recognizes the following kinds of options:\n\n $(OL $(LI $(I Boolean options). These are the simplest options; all\n they do is set a Boolean to $(D true):\n\n---------\n  bool verbose, debugging;\n  getopt(args, \"verbose\", &verbose, \"debug\", &debugging);\n---------\n\n )$(LI $(I Numeric options.) If an option is bound to a numeric type, a\n number is expected as the next option, or right within the option\n separated with an \"=\" sign:\n\n---------\n  uint timeout;\n  getopt(args, \"timeout\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), invoke the program with either $(D\n--timeout=5) or $(D --timeout 5).\n\n $(UL $(LI $(I Incremental options.) If an option name has a \"+\" suffix and\n is bound to a numeric type, then the option's value tracks the number\n of times the option occurred on the command line:\n\n---------\n  uint paranoid;\n  getopt(args, \"paranoid+\", &paranoid);\n---------\n\n Invoking the program with \"--paranoid --paranoid --paranoid\" will set\n $(D paranoid) to 3. Note that an incremental option never\n expects a parameter, e.g. in the command line \"--paranoid 42\n --paranoid\", the \"42\" does not set $(D paranoid) to 42;\n instead, $(D paranoid) is set to 2 and \"42\" is not considered\n as part of the normal program arguments.)))\n\n $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as a\n string is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\n  enum Color { no, yes };\n  Color color; \/\/ default initialized to Color.no\n  getopt(args, \"color\", &color);\n---------\n\nTo set $(D color) to $(D Color.yes), invoke the program with either $(D\n--color=yes) or $(D --color yes).)\n\n $(LI $(I String options.) If an option is bound to a string, a string\n is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\nstring outputFile;\ngetopt(args, \"output\", &outputFile);\n---------\n\n Invoking the program with \"--output=myfile.txt\" or \"--output\n myfile.txt\" will set $(D outputFile) to \"myfile.txt\". If you want to\n pass a string containing spaces, you need to use the quoting that is\n appropriate to your shell, e.g. --output='my file.txt'.)\n\n $(LI $(I Array options.) If an option is bound to an array, a new\n element is appended to the array each time the option occurs:\n\n---------\nstring[] outputFiles;\ngetopt(args, \"output\", &outputFiles);\n---------\n\n Invoking the program with \"--output=myfile.txt --output=yourfile.txt\"\n or \"--output myfile.txt --output yourfile.txt\" will set $(D\n outputFiles) to [ \"myfile.txt\", \"yourfile.txt\" ] .)\n\n $(LI $(I Hash options.) If an option is bound to an associative\n array, a string of the form \"name=value\" is expected as the next\n option, or right within the option separated with an \"=\" sign:\n\n---------\ndouble[string] tuningParms;\ngetopt(args, \"tune\", &tuningParms);\n---------\n\nInvoking the program with e.g. \"--tune=alpha=0.5 --tune beta=0.6\" will\nset $(D tuningParms) to [ \"alpha\" : 0.5, \"beta\" : 0.6 ]. In general,\nkeys and values can be of any parsable types.)\n\n$(LI $(I Delegate options.) An option can be bound to a delegate with\nthe signature $(D void delegate()), $(D void delegate(string option))\nor $(D void delegate(string option, string value)).\n\n$(UL $(LI In the $(D void delegate()) case, the delegate is invoked\nwhenever the option is seen.) $(LI In the $(D void delegate(string\noption)) case, the option string (without the leading dash(es)) is\npassed to the delegate. After that, the option string is considered\nhandled and removed from the options array.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option)\n  {\n    if (option == \"quiet\")\n    {\n      verbosityLevel = 0;\n    }\n    else\n    {\n      assert(option == \"verbose\");\n      verbosityLevel = 2;\n    }\n  }\n  getopt(args, \"verbose\", &myHandler, \"quiet\", &myHandler);\n}\n---------\n\n)$(LI In the $(D void delegate(string option, string value)) case, the\noption string is handled as an option with one argument, and parsed\naccordingly. The option and its value are passed to the\ndelegate. After that, whatever was passed to the delegate is\nconsidered handled and removed from the list.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option, string value)\n  {\n    switch (value)\n    {\n      case \"quiet\": verbosityLevel = 0; break;\n      case \"verbose\": verbosityLevel = 2; break;\n      case \"shouting\": verbosityLevel = verbosityLevel.max; break;\n      default :\n        stderr.writeln(\"Dunno how verbose you want me to be by saying \",\n          value);\n        exit(1);\n    }\n  }\n  getopt(args, \"verbosity\", &myHandler);\n}\n---------\n))))\n\n$(B Options with multiple names)\n\nSometimes option synonyms are desirable, e.g. \"--verbose\",\n\"--loquacious\", and \"--garrulous\" should have the same effect. Such\nalternate option names can be included in the option specification,\nusing \"|\" as a separator:\n\n---------\nbool verbose;\ngetopt(args, \"verbose|loquacious|garrulous\", &verbose);\n---------\n\n$(B Case)\n\nBy default options are case-insensitive. You can change that behavior\nby passing $(D getopt) the $(D caseSensitive) directive like this:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nIn the example above, \"--foo\", \"--bar\", \"--FOo\", \"--bAr\" etc. are recognized.\nThe directive is active til the end of $(D getopt), or until the\nconverse directive $(D caseInsensitive) is encountered:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    std.getopt.config.caseInsensitive,\n    \"bar\", &bar);\n---------\n\nThe option \"--Foo\" is rejected due to $(D\nstd.getopt.config.caseSensitive), but not \"--Bar\", \"--bAr\"\netc. because the directive $(D\nstd.getopt.config.caseInsensitive) turned sensitivity off before\noption \"bar\" was parsed.\n\n$(B \"Short\" versus \"long\" options)\n\nTraditionally, programs accepted single-letter options preceded by\nonly one dash (e.g. $(D -t)). $(D getopt) accepts such parameters\nseamlessly. When used with a double-dash (e.g. $(D --t)), a\nsingle-letter option behaves the same as a multi-letter option. When\nused with a single dash, a single-letter option is accepted. If the\noption has a parameter, that must be \"stuck\" to the option without\nany intervening space or \"=\":\n\n---------\nuint timeout;\ngetopt(args, \"timeout|t\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), use either of the following: $(D --timeout=5),\n$(D --timeout 5), $(D --t=5), $(D --t 5), or $(D -t5). Forms such as $(D -t 5)\nand $(D -timeout=5) will be not accepted.\n\nFor more details about short options, refer also to the next section.\n\n$(B Bundling)\n\nSingle-letter options can be bundled together, i.e. \"-abc\" is the same as\n$(D \"-a -b -c\"). By default, this confusing option is turned off. You can\nturn it on with the $(D std.getopt.config.bundling) directive:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.bundling,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nIn case you want to only enable bundling for some of the parameters,\nbundling can be turned off with $(D std.getopt.config.noBundling).\n\n$(B Passing unrecognized options through)\n\nIf an application needs to do its own processing of whichever arguments\n$(D getopt) did not understand, it can pass the\n$(D std.getopt.config.passThrough) directive to $(D getopt):\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.passThrough,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nAn unrecognized option such as \"--baz\" will be found untouched in\n$(D args) after $(D getopt) returns.\n\n$(B Options Terminator)\n\nA lonesome double-dash terminates $(D getopt) gathering. It is used to\nseparate program options from other parameters (e.g. options to be passed\nto another program). Invoking the example above with $(D \"--foo -- --bar\")\nparses foo but leaves \"--bar\" in $(D args). The double-dash itself is\nremoved from the argument array.\n",
"line" : 341}
]
}
,
{
"name" : "config",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Configuration options for $(D getopt). You can pass them to $(D\n getopt) in any position, except in between an option string and its\n bound pointer.\n \n",
"line" : 354,
"base" : "int",
"members" : [
{
"name" : "caseSensitive",
"kind" : "enum member",
"protection" : "public",
"comment" : " Turns case sensitivity on\n",
"line" : 356}
,
{
"name" : "caseInsensitive",
"kind" : "enum member",
"protection" : "public",
"comment" : " Turns case sensitivity off\n",
"line" : 358}
,
{
"name" : "bundling",
"kind" : "enum member",
"protection" : "public",
"comment" : " Turns bundling on\n",
"line" : 360}
,
{
"name" : "noBundling",
"kind" : "enum member",
"protection" : "public",
"comment" : " Turns bundling off\n",
"line" : 362}
,
{
"name" : "passThrough",
"kind" : "enum member",
"protection" : "public",
"comment" : " Pass unrecognized arguments through\n",
"line" : 364}
,
{
"name" : "noPassThrough",
"kind" : "enum member",
"protection" : "public",
"comment" : " Signal unrecognized arguments as errors\n",
"line" : 366}
,
{
"name" : "stopOnFirstNonOption",
"kind" : "enum member",
"protection" : "public",
"comment" : " Stop at first argument that does not look like an option\n",
"line" : 368}
]
}
,
{
"name" : "getoptImpl(T...)",
"kind" : "template",
"protection" : "public",
"line" : 371,
"members" : [
{
"name" : "getoptImpl",
"kind" : "function",
"type" : "void(ref string[] args, ref configuration cfg, T opts)",
"line" : 371}
]
}
,
{
"name" : "handleOption(R)",
"kind" : "template",
"protection" : "public",
"line" : 417,
"members" : [
{
"name" : "handleOption",
"kind" : "function",
"type" : "void(string option, R receiver, ref string[] args, ref configuration cfg, bool incremental)",
"line" : 417}
]
}
,
{
"name" : "optionChar",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : "\n   The option character. Defaults to '-' but it can be assigned to\n   prior to calling $(D getopt).\n \n",
"line" : 535}
,
{
"name" : "endOfOptions",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n   The string that conventionally marks the end of all\n   options. Defaults to \"--\" but can be assigned to prior to calling\n   $(D getopt). Assigning an empty string to $(D endOfOptions)\n   effectively disables it.\n \n",
"line" : 543}
,
{
"name" : "assignChar",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : "\n   The assignment character used in options with parameters. Defaults\n   to '=' but can be assigned to prior to calling $(D getopt).\n \n",
"line" : 549}
,
{
"name" : "autoIncrementChar",
"kind" : "variable",
"protection" : "public",
"type" : "char",
"line" : 551}
,
{
"name" : "configuration",
"kind" : "struct",
"protection" : "private",
"line" : 554,
"members" : [
{
"name" : "caseSensitive",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe bool()",
"line" : 555}
,
{
"name" : "caseSensitive",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(bool v)",
"line" : 556}
,
{
"name" : "bundling",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe bool()",
"line" : 557}
,
{
"name" : "bundling",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(bool v)",
"line" : 558}
,
{
"name" : "passThrough",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe bool()",
"line" : 559}
,
{
"name" : "passThrough",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(bool v)",
"line" : 560}
,
{
"name" : "stopOnFirstNonOption",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe bool()",
"line" : 561}
,
{
"name" : "stopOnFirstNonOption",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @property @safe void(bool v)",
"line" : 562}
,
{
"name" : "_caseSensitive_bundling_passThrough_stopOnFirstNonOption_",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte",
"line" : 563}
]
}
,
{
"name" : "optMatch",
"kind" : "function",
"protection" : "private",
"type" : "bool(string arg, string optPattern, ref string value, configuration cfg)",
"line" : 563}
,
{
"name" : "setConfig",
"kind" : "function",
"protection" : "private",
"type" : "void(ref configuration cfg, config option)",
"line" : 614}
]
}
,
{
"name" : "std.json",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/json.d",
"comment" : "\nJavaScript Object Notation\n\nCopyright: Copyright Jeremie Pelletier 2008 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   Jeremie Pelletier\nReferences: $(LINK http:\/\/json.org\/)\nSource:    $(PHOBOSSRC std\/_json.d)\n",
"members" : [
{
"name" : "UTFStride",
"kind" : "alias",
"protection" : "private",
"line" : 27}
,
{
"name" : "toUnicode",
"kind" : "alias",
"protection" : "private",
"line" : 28}
,
{
"name" : "JSON_TYPE",
"kind" : "enum",
"protection" : "public",
"comment" : "\n JSON type enumeration\n",
"line" : 34,
"base" : "byte",
"members" : [
{
"name" : "STRING",
"kind" : "enum member",
"protection" : "public",
"comment" : " Indicates the type of a $(D JSONValue).\n",
"line" : 36}
,
{
"name" : "INTEGER",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 37}
,
{
"name" : "UINTEGER",
"kind" : "enum member",
"protection" : "public",
"comment" : " integers > 2^63-1\n",
"line" : 38}
,
{
"name" : "FLOAT",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 39}
,
{
"name" : "OBJECT",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 40}
,
{
"name" : "ARRAY",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 41}
,
{
"name" : "TRUE",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 42}
,
{
"name" : "FALSE",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 43}
,
{
"name" : "NULL",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 44}
]
}
,
{
"name" : "JSONValue",
"kind" : "struct",
"protection" : "public",
"comment" : "\n JSON value node\n",
"line" : 50,
"members" : [
{
"name" : "str",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Value when $(D type) is $(D JSON_TYPE.STRING)\n",
"line" : 53}
,
{
"name" : "integer",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"comment" : " Value when $(D type) is $(D JSON_TYPE.INTEGER)\n",
"line" : 55}
,
{
"name" : "uinteger",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"comment" : " Value when $(D type) is $(D JSON_TYPE.UINTEGER)\n",
"line" : 57}
,
{
"name" : "floating",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " Value when $(D type) is $(D JSON_TYPE.FLOAT)\n",
"line" : 59}
,
{
"name" : "object",
"kind" : "variable",
"protection" : "public",
"type" : "JSONValue[string]",
"comment" : " Value when $(D type) is $(D JSON_TYPE.OBJECT)\n",
"line" : 61}
,
{
"name" : "array",
"kind" : "variable",
"protection" : "public",
"type" : "JSONValue[]",
"comment" : " Value when $(D type) is $(D JSON_TYPE.ARRAY)\n",
"line" : 63}
,
{
"name" : "type",
"kind" : "variable",
"protection" : "public",
"type" : "JSON_TYPE",
"comment" : " Specifies the _type of the value stored in this structure.\n",
"line" : 66}
,
{
"name" : "opIndex",
"kind" : "function",
"protection" : "public",
"type" : "ref JSONValue(ulong i)",
"comment" : " array syntax for json arrays\n",
"line" : 69}
,
{
"name" : "opIndex",
"kind" : "function",
"protection" : "public",
"type" : "ref JSONValue(string k)",
"comment" : " hash syntax for json objects\n",
"line" : 77}
]
}
,
{
"name" : "parseJSON(T) if (isInputRange!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Parses a serialized string and returns a tree of JSON values.\n",
"line" : 88,
"members" : [
{
"name" : "parseJSON",
"kind" : "function",
"type" : "JSONValue(T json, int maxDepth = -1)",
"comment" : "\n Parses a serialized string and returns a tree of JSON values.\n",
"line" : 88}
]
}
,
{
"name" : "toJSON",
"kind" : "function",
"protection" : "public",
"type" : "string(const(JSONValue*) root)",
"comment" : "\n Takes a tree of JSON values and returns the serialized string.\n",
"line" : 344}
,
{
"name" : "appendJSONChar",
"kind" : "function",
"protection" : "private",
"type" : "void(Appender!(string)* dst, dchar c, scope void delegate(string) error)",
"line" : 428}
,
{
"name" : "JSONException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Exception thrown on JSON errors\n",
"line" : 452,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "JSONException(string msg, int line = 0, int pos = 0)",
"line" : 453}
]
}
]
}
,
{
"name" : "std.math",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/math.d",
"comment" : "\n Elementary mathematical functions\n\n Contains the elementary mathematical functions (powers, roots,\n and trignometric functions), and low-level floating-point operations.\n Mathematical special functions are available in std.mathspecial.\n\n The functionality closely follows the IEEE754-2008 standard for\n floating-point arithmetic, including the use of camelCase names rather\n than C99-style lower case names. All of these functions behave correctly\n when presented with an infinity or NaN.\n\n Unlike C, there is no global 'errno' variable. Consequently, almost all of\n these functions are pure nothrow.\n\n Status:\n The semantics and names of feqrel and approxEqual will be revised.\n\n Source: $(PHOBOSSRC std\/_math.d)\n Macros:\n      WIKI = Phobos\/StdMath\n\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values<\/caption>\n              $0<\/table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0<\/span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)<\/sub><sup>$2<\/sup>)\n      POWER = $1<sup>$2<\/sup>\n      SUB = $1<sub>$2<\/sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2<\/sup><sub>$(SMALL $1)<\/sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)<\/sup><sub>$(SMALL $2)<\/sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Don Clugston\n Source: $(PHOBOSSRC std\/_math.d)\n \n",
"members" : [
{
"name" : "floatTraits(T)",
"kind" : "template",
"protection" : "public",
"line" : 116,
"members" : [
{
"name" : "RECIP_EPSILON",
"kind" : "variable",
"type" : "T",
"line" : 121}
]
}
,
{
"name" : "MANTISSA_LSB",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 193}
,
{
"name" : "MANTISSA_MSB",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 194}
,
{
"name" : "E",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " e = 2.718281... \n",
"line" : 206}
,
{
"name" : "LOG2T",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(SUB log, 2)10 = 3.321928... \n",
"line" : 207}
,
{
"name" : "LOG2E",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(SUB log, 2)e = 1.442695... \n",
"line" : 208}
,
{
"name" : "LOG2",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(SUB log, 10)2 = 0.301029... \n",
"line" : 209}
,
{
"name" : "LOG10E",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(SUB log, 10)e = 0.434294... \n",
"line" : 210}
,
{
"name" : "LN2",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " ln 2  = 0.693147... \n",
"line" : 211}
,
{
"name" : "LN10",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " ln 10 = 2.302585... \n",
"line" : 212}
,
{
"name" : "PI",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(_PI) = 3.141592... \n",
"line" : 213}
,
{
"name" : "PI_2",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(PI) \/ 2 = 1.570796... \n",
"line" : 214}
,
{
"name" : "PI_4",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(PI) \/ 4 = 0.785398... \n",
"line" : 215}
,
{
"name" : "M_1_PI",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " 1 \/ $(PI) = 0.318309... \n",
"line" : 216}
,
{
"name" : "M_2_PI",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " 2 \/ $(PI) = 0.636619... \n",
"line" : 217}
,
{
"name" : "M_2_SQRTPI",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " 2 \/ $(SQRT)$(PI) = 1.128379... \n",
"line" : 218}
,
{
"name" : "SQRT2",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(SQRT)2 = 1.414213... \n",
"line" : 219}
,
{
"name" : "SQRT1_2",
"kind" : "variable",
"protection" : "public",
"type" : "real",
"comment" : " $(SQRT)$(HALF) = 0.707106... \n",
"line" : 220}
,
{
"name" : "abs(Num) if (is(typeof(Num.init >= 0)) && is(typeof(-Num.init)) && !(is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Calculates the absolute value\n\n For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )\n = hypot(z.re, z.im).\n \n",
"line" : 243,
"members" : [
{
"name" : "abs",
"kind" : "function",
"type" : "pure nothrow @safe Num(Num x)",
"comment" : "\n Calculates the absolute value\n\n For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )\n = hypot(z.re, z.im).\n \n",
"line" : 243}
]
}
,
{
"name" : "abs(Num) if (is(Num* : const(cfloat*)) || is(Num* : const(cdouble*)) || is(Num* : const(creal*)))",
"kind" : "template",
"protection" : "public",
"line" : 254,
"members" : [
{
"name" : "abs",
"kind" : "function",
"type" : "pure nothrow @safe (Num z)",
"line" : 254}
]
}
,
{
"name" : "abs(Num) if (is(Num* : const(ifloat*)) || is(Num* : const(idouble*)) || is(Num* : const(ireal*)))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto \n",
"line" : 262,
"members" : [
{
"name" : "abs",
"kind" : "function",
"type" : "pure nothrow @safe real(Num y)",
"comment" : " ditto \n",
"line" : 262}
]
}
,
{
"name" : "conj",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe creal(creal z)",
"comment" : "\n Complex conjugate\n\n  conj(x + iy) = x - iy\n\n Note that z * conj(z) = $(POWER z.re, 2) - $(POWER z.im, 2)\n is always a real number\n \n",
"line" : 290}
,
{
"name" : "conj",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe ireal(ireal y)",
"comment" : " ditto \n",
"line" : 296}
,
{
"name" : "cos",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Returns cosine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cos(x)) $(TH invalid?))\n      $(TR $(TD $(NAN))            $(TD $(NAN)) $(TD yes)     )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN)) $(TD yes)     )\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n \n",
"line" : 321}
,
{
"name" : "sin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Returns sine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)               $(TH sin(x))      $(TH invalid?))\n      $(TR $(TD $(NAN))          $(TD $(NAN))      $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))    $(TD $(NAN))      $(TD yes))\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n \n",
"line" : 336}
,
{
"name" : "sin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe creal(creal z)",
"comment" : "\n  sine, complex and imaginary\n\n  sin(z) = sin(z.re)*cosh(z.im) + cos(z.re)*sinh(z.im)i\n\n If both sin($(THETA)) and cos($(THETA)) are required,\n it is most efficient to use expi($(THETA)).\n \n",
"line" : 347}
,
{
"name" : "sin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe ireal(ireal y)",
"comment" : " ditto \n",
"line" : 355}
,
{
"name" : "cos",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe creal(creal z)",
"comment" : "\n  cosine, complex and imaginary\n\n  cos(z) = cos(z.re)*cosh(z.im) - sin(z.re)*sinh(z.im)i\n \n",
"line" : 371}
,
{
"name" : "cos",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(ireal y)",
"comment" : " ditto \n",
"line" : 379}
,
{
"name" : "tan",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real x)",
"comment" : "\n Returns tangent of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)             $(TH tan(x))       $(TH invalid?))\n      $(TR $(TD $(NAN))        $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))  $(TD $(NAN))       $(TD yes))\n      )\n \n",
"line" : 401}
,
{
"name" : "acos",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the arc cosine of x,\n returning a value ranging from 0 to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH acos(x)) $(TH invalid?))\n      $(TR $(TD $(GT)1.0)  $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(LT)-1.0) $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(NAN))    $(TD $(NAN))  $(TD yes))\n  )\n \n",
"line" : 543}
,
{
"name" : "acos",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 549}
,
{
"name" : "acos",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 551}
,
{
"name" : "asin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the arc sine of x,\n returning a value ranging from -$(PI)\/2 to $(PI)\/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH asin(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(GT)1.0)     $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD yes))\n  )\n \n",
"line" : 564}
,
{
"name" : "asin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 569}
,
{
"name" : "asin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 571}
,
{
"name" : "atan",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the arc tangent of x,\n returning a value ranging from -$(PI)\/2 to $(PI)\/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH atan(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN))       $(TD yes))\n  )\n \n",
"line" : 583}
,
{
"name" : "atan",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 585}
,
{
"name" : "atan",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 587}
,
{
"name" : "atan2",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real y, real x)",
"comment" : "\n Calculates the arc tangent of y \/ x,\n returning a value ranging from -$(PI) to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH y)                 $(TH x)            $(TH atan(y, x)))\n      $(TR $(TD $(NAN))            $(TD anything)     $(TD $(NAN)) )\n      $(TR $(TD anything)          $(TD $(NAN))       $(TD $(NAN)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(GT)0.0)     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0)         $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(LT)0.0)     $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -0.0)         $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(GT)0.0)          $(TD $(PLUSMN)0.0) $(TD $(PI)\/2) )\n      $(TR $(TD $(LT)0.0)          $(TD $(PLUSMN)0.0) $(TD -$(PI)\/2) )\n      $(TR $(TD $(GT)0.0)          $(TD $(INFIN))     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD anything)     $(TD $(PLUSMN)$(PI)\/2))\n      $(TR $(TD $(GT)0.0)          $(TD -$(INFIN))    $(TD $(PLUSMN)$(PI)) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(INFIN))     $(TD $(PLUSMN)$(PI)\/4))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD -$(INFIN))    $(TD $(PLUSMN)3$(PI)\/4))\n      )\n \n",
"line" : 610}
,
{
"name" : "atan2",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double y, double x)",
"comment" : " ditto\n",
"line" : 627}
,
{
"name" : "atan2",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float y, float x)",
"comment" : " ditto\n",
"line" : 633}
,
{
"name" : "cosh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the hyperbolic cosine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cosh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)0.0) $(TD no) )\n      )\n \n",
"line" : 646}
,
{
"name" : "cosh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 654}
,
{
"name" : "cosh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 656}
,
{
"name" : "sinh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the hyperbolic sine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH sinh(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no))\n      )\n \n",
"line" : 668}
,
{
"name" : "sinh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 681}
,
{
"name" : "sinh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 683}
,
{
"name" : "tanh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the hyperbolic tangent of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH tanh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)1.0) $(TD no))\n      )\n \n",
"line" : 695}
,
{
"name" : "tanh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 705}
,
{
"name" : "tanh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 707}
,
{
"name" : "coshisinh",
"kind" : "function",
"protection" : "package",
"type" : "pure nothrow @safe creal(real x)",
"line" : 713}
,
{
"name" : "acosh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the inverse hyperbolic cosine of x.\n\n  Mathematically, acosh(x) = log(x + sqrt( x*x - 1))\n\n $(TABLE_DOMRG\n  $(DOMAIN 1..$(INFIN))\n  $(RANGE  1..log(real.max), $(INFIN)) )\n      $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(LT)1,     $(NAN) )\n    $(SV  1,      0       )\n    $(SV  +$(INFIN),+$(INFIN))\n  )\n \n",
"line" : 749}
,
{
"name" : "acosh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 757}
,
{
"name" : "acosh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 759}
,
{
"name" : "asinh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the inverse hyperbolic sine of x.\n\n  Mathematically,\n  ---------------\n  asinh(x) =  log( x + sqrt( x*x + 1 )) \/\/ if x >= +0\n  asinh(x) = -log(-x + sqrt( x*x + 1 )) \/\/ if x <= -0\n  -------------\n\n    $(TABLE_SV\n    $(SVH x,                asinh(x)       )\n    $(SV  $(NAN),           $(NAN)         )\n    $(SV  $(PLUSMN)0,       $(PLUSMN)0      )\n    $(SV  $(PLUSMN)$(INFIN),$(PLUSMN)$(INFIN))\n    )\n \n",
"line" : 786}
,
{
"name" : "asinh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 795}
,
{
"name" : "asinh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 797}
,
{
"name" : "atanh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the inverse hyperbolic tangent of x,\n returning a value from ranging from -1 to 1.\n\n Mathematically, atanh(x) = log( (1+x)\/(1-x) ) \/ 2\n\n\n $(TABLE_DOMRG\n  $(DOMAIN -$(INFIN)..$(INFIN))\n  $(RANGE  -1..1) )\n $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(PLUSMN)0, $(PLUSMN)0)\n    $(SV  -$(INFIN), -0)\n )\n \n",
"line" : 825}
,
{
"name" : "atanh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 831}
,
{
"name" : "atanh",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 833}
,
{
"name" : "rndtol",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe long(real x)",
"comment" : "\n Returns x rounded to a long value using the current rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n \n",
"line" : 850}
,
{
"name" : "rndtonl",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) real(real x)",
"comment" : "\n Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n \n",
"line" : 859}
,
{
"name" : "sqrt",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : "\n Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n \n",
"line" : 871}
,
{
"name" : "sqrt",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 872}
,
{
"name" : "sqrt",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : " ditto\n",
"line" : 873}
,
{
"name" : "sqrt",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe creal(creal z)",
"line" : 875}
,
{
"name" : "exp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real x)",
"comment" : "\n Calculates e$(SUP x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUP x)) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\n \n",
"line" : 926}
,
{
"name" : "exp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto\n",
"line" : 946}
,
{
"name" : "exp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto\n",
"line" : 948}
,
{
"name" : "expm1",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real x)",
"comment" : "\n Calculates the value of the natural logarithm base (e)\n raised to the power of x, minus 1.\n\n For very small x, expm1(x) is more accurate\n than exp(x)-1.\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUP x)-1)  )\n    $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN))    )\n    $(TR $(TD -$(INFIN))     $(TD -1.0)         )\n    $(TR $(TD $(NAN))        $(TD $(NAN))       )\n  )\n \n",
"line" : 966}
,
{
"name" : "exp2",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real x)",
"comment" : "\n Calculates 2$(SUP x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH exp2(x))   )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\n \n",
"line" : 1124}
,
{
"name" : "expi",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted creal(real y)",
"comment" : "\n Calculate cos(y) + i sin(y).\n\n On many CPUs (such as x86), this is a very efficient operation;\n almost twice as fast as calculating sin(y) and cos(y) separately,\n and is the preferred method when both are required.\n \n",
"line" : 1374}
,
{
"name" : "frexp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real value, out int exp)",
"comment" : "\n Separate floating point value into significand and exponent.\n\n Returns:\n      Calculate and return $(I x) and $(I exp) such that\n      value =$(I x)*2$(SUP exp) and\n      .5 $(LT)= |$(I x)| $(LT) 1.0\n\n      $(I x) has same sign as value.\n\n      $(TABLE_SV\n      $(TR $(TH value)           $(TH returns)         $(TH exp))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0)    $(TD 0))\n      $(TR $(TD +$(INFIN))       $(TD +$(INFIN))       $(TD int.max))\n      $(TR $(TD -$(INFIN))       $(TD -$(INFIN))       $(TD int.min))\n      $(TR $(TD $(PLUSMN)$(NAN)) $(TD $(PLUSMN)$(NAN)) $(TD int.min))\n      )\n \n",
"line" : 1415}
,
{
"name" : "ilogb",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted int(real x)",
"comment" : "\n Extracts the exponent of x as a signed integral value.\n\n If x is not a special value, the result is the same as\n $(D cast(int)logb(x)).\n\n      $(TABLE_SV\n      $(TR $(TH x)                $(TH ilogb(x))     $(TH Range error?))\n      $(TR $(TD 0)                 $(TD FP_ILOGB0)   $(TD yes))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD int.max)     $(TD no))\n      $(TR $(TD $(NAN))            $(TD FP_ILOGBNAN) $(TD no))\n      )\n \n",
"line" : 1573}
,
{
"name" : "FP_ILOGB0",
"kind" : "alias",
"protection" : "public",
"line" : 1575}
,
{
"name" : "FP_ILOGBNAN",
"kind" : "alias",
"protection" : "public",
"line" : 1576}
,
{
"name" : "ldexp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real n, int exp)",
"comment" : "\n Compute n * 2$(SUP exp)\n References: frexp\n \n",
"line" : 1584}
,
{
"name" : "log",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculate the natural logarithm of x.\n\n    $(TABLE_SV\n    $(TR $(TH x)            $(TH log(x))    $(TH divide by 0?) $(TH invalid?))\n    $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n    $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n    $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n    )\n \n",
"line" : 1608}
,
{
"name" : "log10",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculate the base-10 logarithm of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH log10(x))  $(TH divide by 0?) $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n      $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n      $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n      )\n \n",
"line" : 1632}
,
{
"name" : "log1p",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n      Calculates the natural logarithm of 1 + x.\n\n      For very small x, log1p(x) will be more accurate than\n      log(1 + x).\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log1p(x))     $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no)           $(TD no))\n  $(TR $(TD -1.0)         $(TD -$(INFIN))    $(TD yes)          $(TD no))\n  $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD no)           $(TD yes))\n  $(TR $(TD +$(INFIN))    $(TD -$(INFIN))    $(TD no)           $(TD no))\n  )\n \n",
"line" : 1661}
,
{
"name" : "log2",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculates the base-2 logarithm of x:\n $(SUB log, 2)x\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log2(x))   $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no) )\n  $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes) )\n  $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no) )\n  )\n \n",
"line" : 1686}
,
{
"name" : "logb",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Extracts the exponent of x as a signed integral value.\n\n If x is subnormal, it is treated as if it were normalized.\n For a positive, finite x:\n\n 1 $(LT)= $(I x) * FLT_RADIX$(SUP -logb(x)) $(LT) FLT_RADIX\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH logb(x))   $(TH divide by 0?) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -$(INFIN)) $(TD yes) )\n      )\n \n",
"line" : 1708}
,
{
"name" : "fmod",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x, real y)",
"comment" : "\n Calculates the remainder from the calculation x\/y.\n Returns:\n The value of x - i * y, where i is the number of times that y can\n be completely subtracted from x. The result has the same sign as x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH y)             $(TH fmod(x, y))   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)   $(TD not 0.0)       $(TD $(PLUSMN)0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(NAN))       $(TD yes))\n  $(TR $(TD anything)       $(TD $(PLUSMN)0.0)  $(TD $(NAN))       $(TD yes))\n  $(TR $(TD !=$(PLUSMNINF)) $(TD $(PLUSMNINF))  $(TD x)            $(TD no))\n )\n \n",
"line" : 1724}
,
{
"name" : "modf",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x, ref real i)",
"comment" : "\n Breaks x into an integral part and a fractional part, each of which has\n the same sign as x. The integral part is stored in i.\n Returns:\n The fractional part of x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH i (on input))  $(TH modf(x, i))   $(TH i (on return)))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(PLUSMN)0.0) $(TD $(PLUSMNINF)))\n )\n \n",
"line" : 1737}
,
{
"name" : "scalbn",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x, int n)",
"comment" : "\n Efficiently calculates x * 2$(SUP n).\n\n scalbn handles underflow and overflow in\n the same fashion as the basic arithmetic operators.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH scalb(x)))\n      $(TR $(TD $(PLUSMNINF))      $(TD $(PLUSMNINF)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) )\n      )\n \n",
"line" : 1751}
,
{
"name" : "cbrt",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Calculates the cube root of x.\n\n      $(TABLE_SV\n      $(TR $(TH $(I x))            $(TH cbrt(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no) )\n      $(TR $(TD $(NAN))            $(TD $(NAN))            $(TD yes) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no) )\n      )\n \n",
"line" : 1780}
,
{
"name" : "fabs",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Returns |x|\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH fabs(x)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n      )\n \n",
"line" : 1792}
,
{
"name" : "hypot",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y)",
"comment" : "\n Calculates the length of the\n hypotenuse of a right-angled triangle with sides of length x and y.\n The hypotenuse is the value of the square root of\n the sums of the squares of x and y:\n\n      sqrt($(POWER x, 2) + $(POWER y, 2))\n\n Note that hypot(x, y), hypot(y, x) and\n hypot(x, -y) are equivalent.\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH y)            $(TH hypot(x, y)) $(TH invalid?))\n  $(TR $(TD x)            $(TD $(PLUSMN)0.0) $(TD |x|)         $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD y)            $(TD +$(INFIN))   $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD $(NAN))       $(TD +$(INFIN))   $(TD no))\n  )\n \n",
"line" : 1814}
,
{
"name" : "ceil",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Returns the value of x rounded upward to the next integer\n (toward positive infinity).\n \n",
"line" : 1899}
,
{
"name" : "floor",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Returns the value of x rounded downward to the next integer\n (toward negative infinity).\n \n",
"line" : 1905}
,
{
"name" : "nearbyint",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Rounds x to the nearest integer value, using the current rounding\n mode.\n\n Unlike the rint functions, nearbyint does not raise the\n FE_INEXACT exception.\n \n",
"line" : 1914}
,
{
"name" : "rint",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Rounds x to the nearest integer value, using the current rounding\n mode.\n If the return value is not equal to x, the FE_INEXACT\n exception is raised.\n $(B nearbyint) performs\n the same operation, but does not set the FE_INEXACT exception.\n \n",
"line" : 1924}
,
{
"name" : "lrint",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted long(real x)",
"comment" : "\n Rounds x to the nearest integer value, using the current rounding\n mode.\n\n This is generally the fastest method to convert a floating-point number\n to an integer. Note that the results from this function\n depend on the rounding mode, if the fractional part of x is exactly 0.5.\n If using the default rounding mode (ties round to even integers)\n lrint(4.5) == 4, lrint(5.5)==6.\n \n",
"line" : 1936}
,
{
"name" : "round",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Return the value of x rounded to the nearest integer.\n If the fractional part of x is exactly 0.5, the return value is rounded to\n the even integer.\n \n",
"line" : 1957}
,
{
"name" : "lround",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted long(real x)",
"comment" : "\n Return the value of x rounded to the nearest integer.\n\n If the fractional part of x is exactly 0.5, the return value is rounded\n away from zero.\n \n",
"line" : 1965}
,
{
"name" : "trunc",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x)",
"comment" : "\n Returns the integer portion of x, dropping the fractional portion.\n\n This is also known as \"chop\" rounding.\n \n",
"line" : 1988}
,
{
"name" : "remainder",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x, real y)",
"comment" : "\n Calculate the remainder x REM y, following IEC 60559.\n\n REM is the value of x - y * n, where n is the integer nearest the exact\n value of x \/ y.\n If |n - x \/ y| == 0.5, n is even.\n If the result is zero, it has the same sign as x.\n Otherwise, the sign of the result is the sign of x \/ y.\n Precision mode has no effect on the remainder functions.\n\n remquo returns n in the parameter n.\n\n $(TABLE_SV\n  $(TR $(TH x)               $(TH y)            $(TH remainder(x, y)) $(TH n)   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)    $(TD not 0.0)      $(TD $(PLUSMN)0.0)    $(TD 0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))    $(TD anything)     $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD anything)        $(TD $(PLUSMN)0.0) $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD != $(PLUSMNINF)) $(TD $(PLUSMNINF)) $(TD x)               $(TD ?)   $(TD no))\n )\n\n Note: remquo not supported on windows\n \n",
"line" : 2012}
,
{
"name" : "remquo",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted real(real x, real y, out int n)",
"comment" : " ditto\n",
"line" : 2014}
,
{
"name" : "IeeeFlags",
"kind" : "struct",
"protection" : "public",
"comment" : " IEEE exception status flags ('sticky bits')\n\n These flags indicate that an exceptional floating-point condition has occurred.\n They indicate that a NaN or an infinity has been generated, that a result\n is inexact, or that a signalling NaN has been encountered. If floating-point\n exceptions are enabled (unmasked), a hardware exception will be generated\n instead of setting these flags.\n\n Example:\n ----\n    real a=3.5;\n    \/\/ Set all the flags to zero\n    resetIeeeFlags();\n    assert(!ieeeFlags.divByZero);\n    \/\/ Perform a division by zero.\n    a\/=0.0L;\n    assert(a==real.infinity);\n    assert(ieeeFlags.divByZero);\n    \/\/ Create a NaN\n    a*=0.0L;\n    assert(ieeeFlags.invalid);\n    assert(isNaN(a));\n\n    \/\/ Check that calling func() has no effect on the\n    \/\/ status flags.\n    IeeeFlags f = ieeeFlags;\n    func();\n    assert(ieeeFlags == f);\n\n ----\n \n",
"line" : 2054,
"members" : [
{
"name" : "flags",
"kind" : "variable",
"protection" : "private",
"type" : "uint",
"line" : 2058}
,
{
"name" : "INEXACT_MASK",
"kind" : "enum member",
"protection" : "public",
"line" : 2062}
,
{
"name" : "UNDERFLOW_MASK",
"kind" : "enum member",
"protection" : "public",
"line" : 2063}
,
{
"name" : "OVERFLOW_MASK",
"kind" : "enum member",
"protection" : "public",
"line" : 2064}
,
{
"name" : "DIVBYZERO_MASK",
"kind" : "enum member",
"protection" : "public",
"line" : 2065}
,
{
"name" : "INVALID_MASK",
"kind" : "enum member",
"protection" : "public",
"line" : 2066}
,
{
"name" : "getIeeeFlags",
"kind" : "function",
"protection" : "private",
"type" : "uint()",
"line" : 2093}
,
{
"name" : "resetIeeeFlags",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 2123}
,
{
"name" : "inexact",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " The result cannot be represented exactly, so rounding occured.\n (example: x = sin(0.1); )\n",
"line" : 2143}
,
{
"name" : "underflow",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " A zero was generated by underflow (example: x = real.min*real.epsilon\/2;)\n",
"line" : 2145}
,
{
"name" : "overflow",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " An infinity was generated by overflow (example: x = real.max*2;)\n",
"line" : 2147}
,
{
"name" : "divByZero",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " An infinity was generated by division by zero (example: x = 3\/0.0; )\n",
"line" : 2149}
,
{
"name" : "invalid",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " A machine NaN was generated. (example: x = real.infinity * 0.0; )\n",
"line" : 2151}
]
}
,
{
"name" : "resetIeeeFlags",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " Set all of the floating-point status flags to false.\n",
"line" : 2157}
,
{
"name" : "ieeeFlags",
"kind" : "function",
"protection" : "public",
"type" : "@property IeeeFlags()",
"comment" : " Return a snapshot of the current state of the floating-point status flags.\n",
"line" : 2160}
,
{
"name" : "FloatingPointControl",
"kind" : "struct",
"protection" : "public",
"comment" : " Control the Floating point hardware\n\n  Change the IEEE754 floating-point rounding mode and the floating-point\n  hardware exceptions.\n\n  By default, the rounding mode is roundToNearest and all hardware exceptions\n  are disabled. For most applications, debugging is easier if the $(I division\n  by zero), $(I overflow), and $(I invalid operation) exceptions are enabled.\n  These three are combined into a $(I severeExceptions) value for convenience.\n  Note in particular that if $(I invalidException) is enabled, a hardware trap\n  will be generated whenever an uninitialized floating-point variable is used.\n\n  All changes are temporary. The previous state is restored at the\n  end of the scope.\n\n\nExample:\n ----\n  {\n    \/\/ Enable hardware exceptions for division by zero, overflow to infinity,\n    \/\/ invalid operations, and uninitialized floating-point variables.\n\n    FloatingPointControl fpctrl;\n    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);\n\n    double y = x*3.0; \/\/ will generate a hardware exception, if x is uninitialized.\n    \/\/\n    fpctrl.rounding = FloatingPointControl.roundUp;\n\n    \/\/ The hardware exceptions will be disabled when leaving this scope.\n    \/\/ The original rounding mode will also be restored.\n  }\n\n ----\n\n \n",
"line" : 2202,
"members" : [
{
"name" : "RoundingMode",
"kind" : "alias",
"protection" : "public",
"type" : "uint",
"line" : 2203}
,
{
"name" : "roundToNearest",
"kind" : "enum member",
"protection" : "public",
"line" : 2210}
,
{
"name" : "roundDown",
"kind" : "enum member",
"protection" : "public",
"line" : 2211}
,
{
"name" : "roundUp",
"kind" : "enum member",
"protection" : "public",
"line" : 2212}
,
{
"name" : "roundToZero",
"kind" : "enum member",
"protection" : "public",
"line" : 2213}
,
{
"name" : "inexactException",
"kind" : "enum member",
"protection" : "public",
"line" : 2220}
,
{
"name" : "underflowException",
"kind" : "enum member",
"protection" : "public",
"line" : 2221}
,
{
"name" : "overflowException",
"kind" : "enum member",
"protection" : "public",
"line" : 2222}
,
{
"name" : "divByZeroException",
"kind" : "enum member",
"protection" : "public",
"line" : 2223}
,
{
"name" : "subnormalException",
"kind" : "enum member",
"protection" : "public",
"line" : 2224}
,
{
"name" : "invalidException",
"kind" : "enum member",
"protection" : "public",
"line" : 2225}
,
{
"name" : "severeExceptions",
"kind" : "enum member",
"protection" : "public",
"comment" : " Severe = The overflow, division by zero, and invalid exceptions.\n",
"line" : 2227}
,
{
"name" : "allExceptions",
"kind" : "enum member",
"protection" : "public",
"line" : 2229}
,
{
"name" : "EXCEPTION_MASK",
"kind" : "variable",
"protection" : "private",
"type" : "ushort",
"line" : 2233}
,
{
"name" : "ROUNDING_MASK",
"kind" : "variable",
"protection" : "private",
"type" : "ushort",
"line" : 2234}
,
{
"name" : "enableExceptions",
"kind" : "function",
"protection" : "public",
"type" : "void(uint exceptions)",
"comment" : " Enable (unmask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
"line" : 2237}
,
{
"name" : "disableExceptions",
"kind" : "function",
"protection" : "public",
"type" : "void(uint exceptions)",
"comment" : " Disable (mask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
"line" : 2243}
,
{
"name" : "rounding",
"kind" : "function",
"protection" : "public",
"type" : "@property void(uint newMode)",
"comment" : " Change the floating-point hardware rounding mode\n",
"line" : 2249}
,
{
"name" : "enabledExceptions",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"comment" : " Return the exceptions which are currently enabled (unmasked)\n",
"line" : 2255}
,
{
"name" : "rounding",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"comment" : " Return the currently active rounding mode\n",
"line" : 2260}
,
{
"name" : "savedState",
"kind" : "variable",
"protection" : "private",
"type" : "ushort",
"line" : 2271}
,
{
"name" : "initialized",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 2273}
,
{
"name" : "initialize",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 2274}
,
{
"name" : "clearExceptions",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 2283}
,
{
"name" : "getControlState",
"kind" : "function",
"protection" : "private",
"type" : "ushort()",
"line" : 2296}
,
{
"name" : "setControlState",
"kind" : "function",
"protection" : "private",
"type" : "void(ushort newState)",
"line" : 2323}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref FloatingPointControl(FloatingPointControl p)",
"line" : 2202}
]
}
,
{
"name" : "isNaN",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted bool(real x)",
"comment" : "\n Returns !=0 if e is a NaN.\n \n",
"line" : 2361}
,
{
"name" : "isFinite",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted int(real e)",
"comment" : "\n Returns !=0 if e is finite (not infinite or $(NAN)).\n \n",
"line" : 2398}
,
{
"name" : "isNormal(X)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns !=0 if x is normalized (not zero, subnormal, infinite, or $(NAN)).\n \n",
"line" : 2421,
"members" : [
{
"name" : "isNormal",
"kind" : "function",
"type" : "pure nothrow @trusted int(X x)",
"comment" : "\n Returns !=0 if x is normalized (not zero, subnormal, infinite, or $(NAN)).\n \n",
"line" : 2421}
]
}
,
{
"name" : "isSubnormal",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted int(float f)",
"comment" : "\n Is number subnormal? (Also called \"denormal\".)\n Subnormals have a 0 exponent and a 0 most significant mantissa bit.\n \n",
"line" : 2463}
,
{
"name" : "isSubnormal",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted int(double d)",
"comment" : " ditto\n",
"line" : 2479}
,
{
"name" : "isSubnormal",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted int(real x)",
"comment" : " ditto\n",
"line" : 2496}
,
{
"name" : "isInfinity",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted bool(real x)",
"comment" : "\n Return !=0 if e is $(PLUSMN)$(INFIN).\n \n",
"line" : 2528}
,
{
"name" : "isIdentical",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted bool(real x, real y)",
"comment" : "\n Is the binary representation of x identical to y?\n\n Same as ==, except that positive and negative zero are not identical,\n and two $(NAN)s are identical if they have the same 'payload'.\n \n",
"line" : 2566}
,
{
"name" : "signbit",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted int(real x)",
"comment" : "\n Return 1 if sign bit of e is set, 0 if not.\n \n",
"line" : 2592}
,
{
"name" : "copysign",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real to, real from)",
"comment" : "\n Return a value composed of to with from's sign bit.\n \n",
"line" : 2614}
,
{
"name" : "sgn(F)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if\n$(D x > 0), and $(NAN) if x==$(NAN).\n \n",
"line" : 2649,
"members" : [
{
"name" : "sgn",
"kind" : "function",
"type" : "pure nothrow @safe F(F x)",
"comment" : "\nReturns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if\n$(D x > 0), and $(NAN) if x==$(NAN).\n \n",
"line" : 2649}
]
}
,
{
"name" : "NaN",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(ulong payload)",
"comment" : "\n Create a quiet $(NAN), storing an integer inside the payload.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n \n",
"line" : 2678}
,
{
"name" : "getNaNPayload",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted ulong(real x)",
"comment" : "\n Extract an integral payload from a $(NAN).\n\n Returns:\n the integer payload as a ulong.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n \n",
"line" : 2738}
,
{
"name" : "nextUp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real x)",
"comment" : "\n Calculate the next largest floating point value after x.\n\n Return the least number greater than x that is representable as a real;\n thus, it gives the next point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextUp(x)   )\n    $(SV  -$(INFIN),    -real.max   )\n    $(SV  $(PLUSMN)0.0, real.min_normal*real.epsilon )\n    $(SV  real.max,     $(INFIN) )\n    $(SV  $(INFIN),     $(INFIN) )\n    $(SV  $(NAN),       $(NAN)   )\n )\n \n",
"line" : 2801}
,
{
"name" : "nextUp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted double(double x)",
"comment" : " ditto \n",
"line" : 2872}
,
{
"name" : "nextUp",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted float(float x)",
"comment" : " ditto \n",
"line" : 2894}
,
{
"name" : "nextDown",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x)",
"comment" : "\n Calculate the next smallest floating point value before x.\n\n Return the greatest number less than x that is representable as a real;\n thus, it gives the previous point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextDown(x)   )\n    $(SV  $(INFIN),     real.max  )\n    $(SV  $(PLUSMN)0.0, -real.min_normal*real.epsilon )\n    $(SV  -real.max,    -$(INFIN) )\n    $(SV  -$(INFIN),    -$(INFIN) )\n    $(SV  $(NAN),       $(NAN)    )\n )\n \n",
"line" : 2930}
,
{
"name" : "nextDown",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe double(double x)",
"comment" : " ditto \n",
"line" : 2936}
,
{
"name" : "nextDown",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe float(float x)",
"comment" : " ditto \n",
"line" : 2942}
,
{
"name" : "nextafter(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Calculates the next representable value after x in the direction of y.\n\n If y > x, the result will be the next largest floating-point value;\n if y < x, the result will be the next smallest value.\n If x == y, the result is y.\n\n Remarks:\n This function is not generally very useful; it's almost always better to use\n the faster functions nextUp() or nextDown() instead.\n\n The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and\n the function result is infinite. The FE_INEXACT and FE_UNDERFLOW\n exceptions will be raised if the function value is subnormal, and x is\n not equal to y.\n \n",
"line" : 3032,
"members" : [
{
"name" : "nextafter",
"kind" : "function",
"type" : "pure nothrow @safe T(T x, T y)",
"comment" : "\n Calculates the next representable value after x in the direction of y.\n\n If y > x, the result will be the next largest floating-point value;\n if y < x, the result will be the next smallest value.\n If x == y, the result is y.\n\n Remarks:\n This function is not generally very useful; it's almost always better to use\n the faster functions nextUp() or nextDown() instead.\n\n The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and\n the function result is infinite. The FE_INEXACT and FE_UNDERFLOW\n exceptions will be raised if the function value is subnormal, and x is\n not equal to y.\n \n",
"line" : 3032}
]
}
,
{
"name" : "fdim",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y)",
"comment" : "\n Returns the positive difference between x and y.\n Returns:\n      $(TABLE_SV\n      $(TR $(TH x, y)       $(TH fdim(x, y)))\n      $(TR $(TD x $(GT) y)  $(TD x - y))\n      $(TR $(TD x $(LT)= y) $(TD +0.0))\n      )\n \n",
"line" : 3064}
,
{
"name" : "fmax",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y)",
"comment" : "\n Returns the larger of x and y.\n \n",
"line" : 3069}
,
{
"name" : "fmin",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y)",
"comment" : "\n Returns the smaller of x and y.\n \n",
"line" : 3074}
,
{
"name" : "fma",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y, real z)",
"comment" : "\n Returns (x * y) + z, rounding only once according to the\n current rounding mode.\n\n BUGS: Not currently implemented - rounds twice.\n \n",
"line" : 3082}
,
{
"name" : "pow(F,G) if (isFloatingPoint!(F) && isIntegral!(G))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Compute the value of x $(SUP n), where n is an integer\n \n",
"line" : 3087,
"members" : [
{
"name" : "pow",
"kind" : "function",
"type" : "pure nothrow @trusted Unqual!(F)(F x, G n)",
"comment" : "\n Compute the value of x $(SUP n), where n is an integer\n \n",
"line" : 3087}
]
}
,
{
"name" : "pow(F,G) if (isIntegral!(F) && isIntegral!(G))",
"kind" : "template",
"protection" : "public",
"comment" : " Compute the value of an integer x, raised to the power of a positive\n integer n.\n\n  If both x and n are 0, the result is 1.\n  If n is negative, an integer divide error will occur at runtime,\n regardless of the value of x.\n \n",
"line" : 3181,
"members" : [
{
"name" : "pow",
"kind" : "function",
"type" : "pure nothrow @trusted typeof(Unqual!(F).init * Unqual!(G).init)(F x, G n)",
"comment" : " Compute the value of an integer x, raised to the power of a positive\n integer n.\n\n  If both x and n are 0, the result is 1.\n  If n is negative, an integer divide error will occur at runtime,\n regardless of the value of x.\n \n",
"line" : 3181}
]
}
,
{
"name" : "pow(I,F) if (isIntegral!(I) && isFloatingPoint!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "Computes integer to floating point powers.\n",
"line" : 3236,
"members" : [
{
"name" : "pow",
"kind" : "function",
"type" : "pure nothrow @trusted real(I x, F y)",
"comment" : "Computes integer to floating point powers.\n",
"line" : 3236}
]
}
,
{
"name" : "pow(F,G) if (isFloatingPoint!(F) && isFloatingPoint!(G))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Calculates x$(SUP y).\n\n $(TABLE_SV\n $(TR $(TH x) $(TH y) $(TH pow(x, y))\n      $(TH div 0) $(TH invalid?))\n $(TR $(TD anything)      $(TD $(PLUSMN)0.0)                $(TD 1.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD +$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD +$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD -$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD -$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(GT) 0.0)                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(LT) 0.0)                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD odd integer $(GT) 0.0)      $(TD -$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(GT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD no)        $(TD no))\n $(TR $(TD -$(INFIN))      $(TD odd integer $(LT) 0.0)      $(TD -0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(LT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)1.0)   $(TD $(PLUSMN)$(INFIN))          $(TD $(NAN))\n      $(TD no)        $(TD yes) )\n $(TR $(TD $(LT) 0.0)      $(TD finite, nonintegral)        $(TD $(NAN))\n      $(TD no)        $(TD yes))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(LT) 0.0)      $(TD $(PLUSMNINF))\n      $(TD yes)       $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(LT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD yes)       $(TD no))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(GT) 0.0)      $(TD $(PLUSMN)0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(GT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n )\n \n",
"line" : 3285,
"members" : [
{
"name" : "pow",
"kind" : "function",
"type" : "pure nothrow @trusted Unqual!(Largest!(F,G))(F x, G y)",
"comment" : "\n Calculates x$(SUP y).\n\n $(TABLE_SV\n $(TR $(TH x) $(TH y) $(TH pow(x, y))\n      $(TH div 0) $(TH invalid?))\n $(TR $(TD anything)      $(TD $(PLUSMN)0.0)                $(TD 1.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD +$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD +$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD -$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD -$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(GT) 0.0)                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(LT) 0.0)                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD odd integer $(GT) 0.0)      $(TD -$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(GT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD no)        $(TD no))\n $(TR $(TD -$(INFIN))      $(TD odd integer $(LT) 0.0)      $(TD -0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(LT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)1.0)   $(TD $(PLUSMN)$(INFIN))          $(TD $(NAN))\n      $(TD no)        $(TD yes) )\n $(TR $(TD $(LT) 0.0)      $(TD finite, nonintegral)        $(TD $(NAN))\n      $(TD no)        $(TD yes))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(LT) 0.0)      $(TD $(PLUSMNINF))\n      $(TD yes)       $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(LT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD yes)       $(TD no))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(GT) 0.0)      $(TD $(PLUSMN)0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(GT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n )\n \n",
"line" : 3285}
]
}
,
{
"name" : "feqrel(X) if (isFloatingPoint!(X))",
"kind" : "template",
"protection" : "public",
"comment" : "\n To what precision is x equal to y?\n\n Returns: the number of mantissa bits which are equal in x and y.\n eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.\n\n      $(TABLE_SV\n      $(TR $(TH x)      $(TH y)          $(TH feqrel(x, y)))\n      $(TR $(TD x)      $(TD x)          $(TD real.mant_dig))\n      $(TR $(TD x)      $(TD $(GT)= 2*x) $(TD 0))\n      $(TR $(TD x)      $(TD $(LT)= x\/2) $(TD 0))\n      $(TR $(TD $(NAN)) $(TD any)        $(TD 0))\n      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))\n      )\n \n",
"line" : 3479,
"members" : [
{
"name" : "feqrel",
"kind" : "function",
"type" : "pure nothrow @trusted int(X x, X y)",
"comment" : "\n To what precision is x equal to y?\n\n Returns: the number of mantissa bits which are equal in x and y.\n eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.\n\n      $(TABLE_SV\n      $(TR $(TH x)      $(TH y)          $(TH feqrel(x, y)))\n      $(TR $(TD x)      $(TD x)          $(TD real.mant_dig))\n      $(TR $(TD x)      $(TD $(GT)= 2*x) $(TD 0))\n      $(TR $(TD x)      $(TD $(LT)= x\/2) $(TD 0))\n      $(TR $(TD $(NAN)) $(TD any)        $(TD 0))\n      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))\n      )\n \n",
"line" : 3479}
]
}
,
{
"name" : "ieeeMean(T)",
"kind" : "template",
"protection" : "public",
"line" : 3639,
"members" : [
{
"name" : "ieeeMean",
"kind" : "function",
"type" : "pure nothrow @trusted T(T x, T y)",
"line" : 3639}
]
}
,
{
"name" : "poly",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted real(real x, const(real[]) A)",
"comment" : "\n Evaluate polynomial A(x) = $(SUB a, 0) + $(SUB a, 1)x + $(SUB a, 2)$(POWER x,2)\n                          + $(SUB a,3)$(POWER x,3); ...\n\n Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2)\n                         + x($(SUB a, 3) + ...)))\n Params:\n      A =     array of coefficients $(SUB a, 0), $(SUB a, 1), etc.\n \n",
"line" : 3755}
,
{
"name" : "approxEqual(T,U,V)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Computes whether $(D lhs) is approximately equal to $(D rhs)\n   admitting a maximum relative difference $(D maxRelDiff) and a\n   maximum absolute difference $(D maxAbsDiff).\n\n   If the two inputs are ranges, $(D approxEqual) returns true if and\n   only if the ranges have the same number of elements and if $(D\n   approxEqual) evaluates to $(D true) for each pair of elements.\n \n",
"line" : 3913,
"members" : [
{
"name" : "approxEqual",
"kind" : "function",
"type" : "bool(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 1e-05)",
"comment" : "\n   Computes whether $(D lhs) is approximately equal to $(D rhs)\n   admitting a maximum relative difference $(D maxRelDiff) and a\n   maximum absolute difference $(D maxAbsDiff).\n\n   If the two inputs are ranges, $(D approxEqual) returns true if and\n   only if the ranges have the same number of elements and if $(D\n   approxEqual) evaluates to $(D true) for each pair of elements.\n \n",
"line" : 3913}
]
}
,
{
"name" : "approxEqual(T,U)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Returns $(D approxEqual(lhs, rhs, 1e-2, 1e-5)).\n \n",
"line" : 3968,
"members" : [
{
"name" : "approxEqual",
"kind" : "function",
"type" : "bool(T lhs, U rhs)",
"comment" : "\n   Returns $(D approxEqual(lhs, rhs, 1e-2, 1e-5)).\n \n",
"line" : 3968}
]
}
,
{
"name" : "isnan",
"kind" : "alias",
"protection" : "public",
"line" : 3990}
,
{
"name" : "isfinite",
"kind" : "alias",
"protection" : "public",
"line" : 3991}
,
{
"name" : "isnormal",
"kind" : "alias",
"protection" : "public",
"line" : 3992}
,
{
"name" : "issubnormal",
"kind" : "alias",
"protection" : "public",
"line" : 3993}
,
{
"name" : "isinf",
"kind" : "alias",
"protection" : "public",
"line" : 3994}
,
{
"name" : "yl2x",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y)",
"line" : 4001}
,
{
"name" : "yl2xp1",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe real(real x, real y)",
"line" : 4002}
]
}
,
{
"name" : "std.mathspecial",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/mathspecial.d",
"comment" : "\n Mathematical Special Functions\n\n The technical term 'Special Functions' includes several families of\n transcendental functions, which have important applications in particular\n branches of mathematics and physics.\n\n The gamma and related functions, and the error function are crucial for\n mathematical statistics.\n The Bessel and related functions arise in problems involving wave propagation\n (especially in optics).\n Other major categories of special functions include the elliptic integrals\n (related to the arc length of an ellipse), and the hypergeometric functions.\n\n Status:\n  Many more functions will be added to this module.\n  The naming convention for the distribution functions (gammaIncomplete, etc)\n  is not yet finalized and will probably change.\n\n Macros:\n      WIKI = Phobos\/StdMathSpecial\n\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values<\/caption>\n              $0<\/table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0<\/span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)<\/sub><sup>$2<\/sup>)\n      POWER = $1<sup>$2<\/sup>\n      SUB = $1<sub>$2<\/sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2<\/sup><sub>$(SMALL $1)<\/sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)<\/sup><sub>$(SMALL $2)<\/sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n\n Copyright: Based on the CEPHES math library, which is\n            Copyright (C) 1994 Stephen L. Moshier (moshier@world.std.com).\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   Stephen L. Moshier (original C code). Conversion to D by Don Clugston\n Source:    $(PHOBOSSRC std\/_mathspecial.d)\n \n",
"members" : [
{
"name" : "gamma",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " The Gamma function, $(GAMMA)(x)\n\n  $(GAMMA)(x) is a generalisation of the factorial function\n  to real and complex numbers.\n  Like x!, $(GAMMA)(x+1) = x * $(GAMMA)(x).\n\n  Mathematically, if z.re > 0 then\n   $(GAMMA)(z) = $(INTEGRATE 0, $(INFIN)) $(POWER t, z-1)$(POWER e, -t) dt\n\n  $(TABLE_SV\n    $(SVH  x,           $(GAMMA)(x) )\n    $(SV  $(NAN),       $(NAN)      )\n    $(SV  $(PLUSMN)0.0, $(PLUSMNINF))\n    $(SV integer > 0,   (x-1)!      )\n    $(SV integer < 0,   $(NAN)      )\n    $(SV +$(INFIN),      +$(INFIN)   )\n    $(SV -$(INFIN),      $(NAN)      )\n  )\n \n",
"line" : 85}
,
{
"name" : "logGamma",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " Natural logarithm of the gamma function, $(GAMMA)(x)\n\n Returns the base e (2.718...) logarithm of the absolute\n value of the gamma function of the argument.\n\n For reals, logGamma is equivalent to log(fabs(gamma(x))).\n\n  $(TABLE_SV\n    $(SVH  x,             logGamma(x)   )\n    $(SV  $(NAN),         $(NAN)      )\n    $(SV integer <= 0,    +$(INFIN)    )\n    $(SV $(PLUSMNINF),    +$(INFIN)    )\n  )\n \n",
"line" : 104}
,
{
"name" : "sgnGamma",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " The sign of $(GAMMA)(x).\n\n Returns -1 if $(GAMMA)(x) < 0,  +1 if $(GAMMA)(x) > 0,\n $(NAN) if sign is indeterminate.\n\n Note that this function can be used in conjunction with logGamma(x) to\n evaluate gamma for very large values of x.\n \n",
"line" : 117}
,
{
"name" : "beta",
"kind" : "function",
"protection" : "public",
"type" : "real(real x, real y)",
"comment" : " Beta function\n\n The beta function is defined as\n\n beta(x, y) = ($(GAMMA)(x) * $(GAMMA)(y)) \/ $(GAMMA)(x + y)\n \n",
"line" : 149}
,
{
"name" : "digamma",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " Digamma function\n\n  The digamma function is the logarithmic derivative of the gamma function.\n\n  digamma(x) = d\/dx logGamma(x)\n \n",
"line" : 167}
,
{
"name" : "betaIncomplete",
"kind" : "function",
"protection" : "public",
"type" : "real(real a, real b, real x)",
"comment" : " Incomplete beta integral\n\n Returns incomplete beta integral of the arguments, evaluated\n from zero to x. The regularized incomplete beta function is defined as\n\n betaIncomplete(a, b, x) = $(GAMMA)(a + b) \/ ( $(GAMMA)(a) $(GAMMA)(b) ) *\n $(INTEGRATE 0, x) $(POWER t, a-1)$(POWER (1-t), b-1) dt\n\n and is the same as the the cumulative distribution function.\n\n The domain of definition is 0 <= x <= 1.  In this\n implementation a and b are restricted to positive values.\n The integral from x to 1 may be obtained by the symmetry\n relation\n\n    betaIncompleteCompl(a, b, x )  =  betaIncomplete( b, a, 1-x )\n\n The integral is evaluated by a continued fraction expansion\n or, when b * x is small, by a power series.\n \n",
"line" : 192}
,
{
"name" : "betaIncompleteInverse",
"kind" : "function",
"protection" : "public",
"type" : "real(real a, real b, real y)",
"comment" : " Inverse of incomplete beta integral\n\n Given y, the function finds x such that\n\n  betaIncomplete(a, b, x) == y\n\n  Newton iterations or interval halving is used.\n \n",
"line" : 205}
,
{
"name" : "gammaIncomplete",
"kind" : "function",
"protection" : "public",
"type" : "real(real a, real x)",
"comment" : " Incomplete gamma integral and its complement\n\n These functions are defined by\n\n   gammaIncomplete = ( $(INTEGRATE 0, x) $(POWER e, -t) $(POWER t, a-1) dt )\/ $(GAMMA)(a)\n\n  gammaIncompleteCompl(a,x)   =   1 - gammaIncomplete(a,x)\n = ($(INTEGRATE x, $(INFIN)) $(POWER e, -t) $(POWER t, a-1) dt )\/ $(GAMMA)(a)\n\n In this implementation both arguments must be positive.\n The integral is evaluated by either a power series or\n continued fraction expansion, depending on the relative\n values of a and x.\n \n",
"line" : 224}
,
{
"name" : "gammaIncompleteCompl",
"kind" : "function",
"protection" : "public",
"type" : "real(real a, real x)",
"comment" : " ditto \n",
"line" : 234}
,
{
"name" : "gammaIncompleteComplInverse",
"kind" : "function",
"protection" : "public",
"type" : "real(real a, real p)",
"comment" : " Inverse of complemented incomplete gamma integral\n\n Given a and p, the function finds x such that\n\n  gammaIncompleteCompl( a, x ) = p.\n \n",
"line" : 249}
,
{
"name" : "erf",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " Error function\n\n The integral is\n\n  erf(x) =  2\/ $(SQRT)($(PI))\n     $(INTEGRATE 0, x) exp( - $(POWER t, 2)) dt\n\n The magnitude of x is limited to about 106.56 for IEEE 80-bit\n arithmetic; 1 or -1 is returned outside this range.\n \n",
"line" : 273}
,
{
"name" : "erfc",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " Complementary error function\n\n erfc(x) = 1 - erf(x)\n         = 2\/ $(SQRT)($(PI))\n     $(INTEGRATE x, $(INFIN)) exp( - $(POWER t, 2)) dt\n\n This function has high relative accuracy for\n values of x far from zero. (For values near zero, use erf(x)).\n \n",
"line" : 287}
,
{
"name" : "normalDistribution",
"kind" : "function",
"protection" : "public",
"type" : "real(real x)",
"comment" : " Normal distribution function.\n\n The normal (or Gaussian, or bell-shaped) distribution is\n defined as:\n\n normalDist(x) = 1\/$(SQRT) $(PI) $(INTEGRATE -$(INFIN), x) exp( - $(POWER t, 2)\/2) dt\n   = 0.5 + 0.5 * erf(x\/sqrt(2))\n   = 0.5 * erfc(- x\/sqrt(2))\n\n To maintain accuracy at values of x near 1.0, use\n      normalDistribution(x) = 1.0 - normalDistribution(-x).\n\n References:\n $(LINK http:\/\/www.netlib.org\/cephes\/ldoubdoc.html),\n G. Marsaglia, \"Evaluating the Normal Distribution\",\n Journal of Statistical Software <b>11<\/b>, (July 2004).\n \n",
"line" : 310}
,
{
"name" : "normalDistributionInverse",
"kind" : "function",
"protection" : "public",
"type" : "real(real p)",
"comment" : " Inverse of Normal distribution function\n\n Returns the argument, x, for which the area under the\n Normal probability density function (integrated from\n minus infinity to x) is equal to p.\n \n",
"line" : 321}
]
}
,
{
"name" : "std.md5",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/md5.d",
"comment" : "\n Computes MD5 digests of arbitrary data. MD5 digests are 16 byte quantities that are like a checksum or crc, but are more robust.\n\n There are two ways to do this. The first does it all in one function call to\n sum(). The second is for when the data is buffered.\n\n Bugs:\n MD5 digests have been demonstrated to not be unique.\n\n Author:\n The routines and algorithms are derived from the\n $(I RSA Data Security, Inc. MD5 Message-Digest Algorithm).\n\n References:\n      $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Md5, Wikipedia on MD5)\n\n Source: $(PHOBOSSRC std\/_md5.d)\n\n Macros:\n      WIKI = Phobos\/StdMd5\n \n\n Example:\n\n--------------------\n\/\/ This code is derived from the\n\/\/ RSA Data Security, Inc. MD5 Message-Digest Algorithm.\n\nimport std.md5;\nimport std.stdio;\n\nvoid main(string[] args)\n{\n    foreach (arg; args)\n        mdFile(arg);\n}\n\n\/\/\/ Digests a file and prints the result.\nvoid mdFile(string filename)\n{\n    ubyte[16] digest;\n\n    MD5_CTX context;\n    context.start();\n    foreach (buffer; File(filename).byChunk(64 * 1024))\n        context.update(buffer);\n    context.finish(digest);\n    writefln(\"MD5 (%s) = %s\", filename, digestToString(digest));\n}\n--------------------\n \n",
"members" : [
{
"name" : "sum",
"kind" : "function",
"protection" : "public",
"type" : "void(ref ubyte[16LU] digest, const(void[][]) data...)",
"comment" : "\n Computes MD5 digest of several arrays of data.\n \n",
"line" : 94}
,
{
"name" : "digestToString",
"kind" : "function",
"protection" : "public",
"type" : "string(const(ubyte[16LU]) digest)",
"comment" : "\n Converts MD5 digest to a string.\n \n",
"line" : 118}
,
{
"name" : "getDigestString",
"kind" : "function",
"protection" : "public",
"type" : "string(const(void[][]) data...)",
"comment" : "\n   Gets the digest of all $(D data) items passed in.\n\nExample:\n\n----\nstring a = \"Mary has \", b = \"a little lamb\";\nint[] c = [ 1, 2, 3, 4, 5 ];\nstring d = getDigestString(a, b, c);\n----\n",
"line" : 143}
,
{
"name" : "MD5_CTX",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Holds context of MD5 computation.\n\n Used when data to be digested is buffered.\n \n",
"line" : 170,
"members" : [
{
"name" : "state",
"kind" : "variable",
"protection" : "public",
"type" : "uint[4LU]",
"line" : 171}
,
{
"name" : "count",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 175}
,
{
"name" : "buffer",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[64LU]",
"line" : 176}
,
{
"name" : "PADDING",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[64LU]",
"line" : 178}
,
{
"name" : "F",
"kind" : "function",
"protection" : "private",
"type" : "uint(uint x, uint y, uint z)",
"line" : 189}
,
{
"name" : "G",
"kind" : "function",
"protection" : "private",
"type" : "uint(uint x, uint y, uint z)",
"line" : 190}
,
{
"name" : "H",
"kind" : "function",
"protection" : "private",
"type" : "uint(uint x, uint y, uint z)",
"line" : 191}
,
{
"name" : "I",
"kind" : "function",
"protection" : "private",
"type" : "uint(uint x, uint y, uint z)",
"line" : 192}
,
{
"name" : "ROTATE_LEFT",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint x, uint n)",
"line" : 197}
,
{
"name" : "FF",
"kind" : "function",
"protection" : "public",
"type" : "void(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)",
"line" : 207}
,
{
"name" : "GG",
"kind" : "function",
"protection" : "public",
"type" : "void(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)",
"line" : 214}
,
{
"name" : "HH",
"kind" : "function",
"protection" : "public",
"type" : "void(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)",
"line" : 221}
,
{
"name" : "II",
"kind" : "function",
"protection" : "public",
"type" : "void(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)",
"line" : 228}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n MD5 initialization. Begins an MD5 operation, writing a new context.\n     \n",
"line" : 238}
,
{
"name" : "update",
"kind" : "function",
"protection" : "public",
"type" : "void(const(void[]) input)",
"comment" : " MD5 block update operation. Continues an MD5 message-digest\n      operation, processing another message block, and updating the\n      context.\n     \n",
"line" : 247}
,
{
"name" : "finish",
"kind" : "function",
"protection" : "public",
"type" : "void(ref ubyte[16LU] digest)",
"comment" : " MD5 finalization. Ends an MD5 message-digest operation, writing the\n the message to digest and zeroing the context.\n     \n",
"line" : 282}
,
{
"name" : "S11",
"kind" : "enum member",
"protection" : "public",
"line" : 311}
,
{
"name" : "S12",
"kind" : "enum member",
"protection" : "public",
"line" : 312}
,
{
"name" : "S13",
"kind" : "enum member",
"protection" : "public",
"line" : 313}
,
{
"name" : "S14",
"kind" : "enum member",
"protection" : "public",
"line" : 314}
,
{
"name" : "S21",
"kind" : "enum member",
"protection" : "public",
"line" : 315}
,
{
"name" : "S22",
"kind" : "enum member",
"protection" : "public",
"line" : 316}
,
{
"name" : "S23",
"kind" : "enum member",
"protection" : "public",
"line" : 317}
,
{
"name" : "S24",
"kind" : "enum member",
"protection" : "public",
"line" : 318}
,
{
"name" : "S31",
"kind" : "enum member",
"protection" : "public",
"line" : 319}
,
{
"name" : "S32",
"kind" : "enum member",
"protection" : "public",
"line" : 320}
,
{
"name" : "S33",
"kind" : "enum member",
"protection" : "public",
"line" : 321}
,
{
"name" : "S34",
"kind" : "enum member",
"protection" : "public",
"line" : 322}
,
{
"name" : "S41",
"kind" : "enum member",
"protection" : "public",
"line" : 323}
,
{
"name" : "S42",
"kind" : "enum member",
"protection" : "public",
"line" : 324}
,
{
"name" : "S43",
"kind" : "enum member",
"protection" : "public",
"line" : 325}
,
{
"name" : "S44",
"kind" : "enum member",
"protection" : "public",
"line" : 326}
,
{
"name" : "transform",
"kind" : "function",
"protection" : "private",
"type" : "void(const(ubyte*) block)",
"line" : 329}
,
{
"name" : "Encode",
"kind" : "function",
"protection" : "private",
"type" : "void(ubyte* output, const(uint*) input, uint len)",
"line" : 423}
,
{
"name" : "Decode",
"kind" : "function",
"protection" : "private",
"type" : "void(uint* output, const(ubyte*) input, uint len)",
"line" : 443}
]
}
]
}
,
{
"name" : "std.metastrings",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/metastrings.d",
"comment" : "\nTemplates with which to do compile-time manipulation of strings.\n\nMacros:\n WIKI = Phobos\/StdMetastrings\n\nCopyright: Copyright Digital Mars 2007 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           Don Clugston\nSource:    $(PHOBOSSRC std\/_metastrings.d)\n",
"members" : [
{
"name" : "Format(A...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nFormats constants into a string at compile time.  Analogous to $(XREF\nstring,format).\n\nParameters:\n\nA = tuple of constants, which can be strings, characters, or integral\n    values.\n\nFormats:\n    The formats supported are %s for strings, and %%\n    for the % character.\nExample:\n---\nimport std.metastrings;\nimport std.stdio;\n\nvoid main()\n{\n  string s = Format!(\"Arg %s = %s\", \"foo\", 27);\n  writefln(s); \/\/ \"Arg foo = 27\"\n}\n ---\n \n",
"line" : 48,
"members" : [
]
}
,
{
"name" : "FormatString(const(char)[] F,A...)",
"kind" : "template",
"protection" : "public",
"line" : 58,
"members" : [
]
}
,
{
"name" : "toStringNow(ulong v)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Convert constant argument to a string.\n \n",
"line" : 86,
"members" : [
]
}
,
{
"name" : "toStringNow(long v)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 100,
"members" : [
]
}
,
{
"name" : "toStringNow(uint U)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 115,
"members" : [
{
"name" : "toStringNow",
"kind" : "variable",
"line" : 117}
]
}
,
{
"name" : "toStringNow(int I)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 121,
"members" : [
{
"name" : "toStringNow",
"kind" : "variable",
"line" : 123}
]
}
,
{
"name" : "toStringNow(bool B)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 127,
"members" : [
{
"name" : "toStringNow",
"kind" : "variable",
"line" : 129}
]
}
,
{
"name" : "toStringNow(string S)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 133,
"members" : [
{
"name" : "toStringNow",
"kind" : "variable",
"line" : 135}
]
}
,
{
"name" : "toStringNow(char C)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 139,
"members" : [
{
"name" : "toStringNow",
"kind" : "variable",
"line" : 141}
]
}
,
{
"name" : "parseUinteger(const(char)[] s)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Parse unsigned integer literal from the start of string s.\n returns:\n    .value = the integer literal as a string,\n    .rest = the string following the integer literal\n Otherwise:\n    .value = null,\n    .rest = s\n \n",
"line" : 155,
"members" : [
]
}
,
{
"name" : "parseInteger(const(char)[] s)",
"kind" : "template",
"protection" : "public",
"comment" : "\nParse integer literal optionally preceded by $(D '-') from the start\nof string $(D s).\n\nReturns:\n   .value = the integer literal as a string,\n   .rest = the string following the integer literal\n\nOtherwise:\n   .value = null,\n   .rest = s\n",
"line" : 187,
"members" : [
]
}
]
}
,
{
"name" : "std.mmfile",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/mmfile.d",
"comment" : "\n Read and write memory mapped files.\n Macros:\n  WIKI=Phobos\/StdMmfile\n\n Copyright: Copyright Digital Mars 2004 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Matthew Wilson\n Source:    $(PHOBOSSRC std\/_mmfile.d)\n \n",
"members" : [
{
"name" : "MmFile",
"kind" : "class",
"protection" : "public",
"comment" : "\n MmFile objects control the memory mapped file resource.\n \n",
"line" : 52,
"base" : "Object",
"members" : [
{
"name" : "Mode",
"kind" : "enum",
"protection" : "public",
"comment" : "\n The mode the memory mapped file is opened with.\n     \n",
"line" : 57,
"base" : "int",
"members" : [
{
"name" : "read",
"kind" : "enum member",
"protection" : "public",
"comment" : " Read existing file\n",
"line" : 58}
,
{
"name" : "readWriteNew",
"kind" : "enum member",
"protection" : "public",
"comment" : " Delete existing file, write new file\n",
"line" : 59}
,
{
"name" : "readWrite",
"kind" : "enum member",
"protection" : "public",
"comment" : " Read\/Write existing file, create if not existing\n",
"line" : 60}
,
{
"name" : "readCopyOnWrite",
"kind" : "enum member",
"protection" : "public",
"comment" : " Read\/Write existing file, copy on write\n",
"line" : 61}
]
}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MmFile(string filename)",
"comment" : "\n Open memory mapped file filename for reading.\n File is closed when the object instance is deleted.\n Throws:\n  std.file.FileException\n     \n",
"line" : 70}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MmFile(File file, Mode mode = cast(Mode)0, ulong size = cast(ulong)0, void* address = null, ulong window = cast(ulong)0)",
"line" : 75}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "MmFile(int fildes, Mode mode, ulong size, void* address, ulong window)",
"line" : 81}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MmFile(string filename, Mode mode, ulong size, void* address, ulong window = cast(ulong)0)",
"comment" : "\n Open memory mapped file filename in mode.\n File is closed when the object instance is deleted.\n Params:\n  filename = name of the file.\n      If null, an anonymous file mapping is created.\n  mode = access mode defined above.\n  size =  the size of the file. If 0, it is taken to be the\n      size of the existing file.\n  address = the preferred address to map the file to,\n      although the system is not required to honor it.\n      If null, the system selects the most convenient address.\n  window = preferred block size of the amount of data to map at one time\n      with 0 meaning map the entire file. The window size must be a\n      multiple of the memory allocation page size.\n Throws:\n  std.file.FileException\n     \n",
"line" : 166}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 394}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "const @property ulong()",
"comment" : "\n Gives size in bytes of the memory mapped file.\n     \n",
"line" : 416}
,
{
"name" : "mode",
"kind" : "function",
"protection" : "public",
"type" : "Mode()",
"comment" : "\n Read-only property returning the file mode.\n     \n",
"line" : 425}
,
{
"name" : "opSlice",
"kind" : "function",
"protection" : "public",
"type" : "void[]()",
"comment" : "\n Returns entire file contents as an array.\n     \n",
"line" : 434}
,
{
"name" : "opSlice",
"kind" : "function",
"protection" : "public",
"type" : "void[](ulong i1, ulong i2)",
"comment" : "\n Returns slice of file contents as an array.\n     \n",
"line" : 443}
,
{
"name" : "opIndex",
"kind" : "function",
"protection" : "public",
"type" : "ubyte(ulong i)",
"comment" : "\n Returns byte at index i in file.\n     \n",
"line" : 455}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"protection" : "public",
"type" : "ubyte(ubyte value, ulong i)",
"comment" : "\n Sets and returns byte at index i in file to value.\n     \n",
"line" : 466}
,
{
"name" : "mapped",
"kind" : "function",
"protection" : "private",
"type" : "int(ulong i)",
"line" : 476}
,
{
"name" : "unmap",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 484}
,
{
"name" : "map",
"kind" : "function",
"protection" : "private",
"type" : "void(ulong start, ulong len)",
"line" : 497}
,
{
"name" : "ensureMapped",
"kind" : "function",
"protection" : "private",
"type" : "void(ulong i)",
"line" : 516}
,
{
"name" : "ensureMapped",
"kind" : "function",
"protection" : "private",
"type" : "void(ulong i, ulong j)",
"line" : 534}
,
{
"name" : "filename",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 554}
,
{
"name" : "data",
"kind" : "variable",
"protection" : "private",
"type" : "void[]",
"line" : 555}
,
{
"name" : "start",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 556}
,
{
"name" : "window",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 557}
,
{
"name" : "size",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 558}
,
{
"name" : "mMode",
"kind" : "variable",
"protection" : "private",
"type" : "Mode",
"line" : 559}
,
{
"name" : "address",
"kind" : "variable",
"protection" : "private",
"type" : "void*",
"line" : 560}
,
{
"name" : "fd",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 570}
,
{
"name" : "prot",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 571}
,
{
"name" : "flags",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 572}
,
{
"name" : "fmode",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 573}
]
}
]
}
,
{
"name" : "std.numeric",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/numeric.d",
"comment" : "\nThis module is a port of a growing fragment of the $(D_PARAM numeric)\nheader in Alexander Stepanov's $(LINK2 http:\/\/sgi.com\/tech\/stl,\nStandard Template Library), with a few additions.\n\nMacros:\n\nWIKI = Phobos\/StdNumeric\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n                   Don Clugston, Robert Jacques\nSource:    $(PHOBOSSRC std\/_numeric.d)\n",
"members" : [
{
"name" : "CustomFloatFlags",
"kind" : "enum",
"protection" : "public",
"comment" : " Format flags for CustomFloat.\n",
"line" : 50,
"base" : "int",
"members" : [
{
"name" : "signed",
"kind" : "enum member",
"protection" : "public",
"comment" : " Adds a sign bit to allow for signed numbers.\n",
"line" : 53}
,
{
"name" : "storeNormalized",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n Store values in normalized form by default. The actual precision of the\n significand is extended by 1 bit by assuming an implicit leading bit of 1\n instead of 0. i.e. $(D 1.nnnn) instead of $(D 0.nnnn).\n True for all $(LUCKY IEE754) types\n     \n",
"line" : 61}
,
{
"name" : "allowDenorm",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n Stores the significand in $(LUCKY IEEE754 denormalized) form when the\n exponent is 0. Required to express the value 0.\n     \n",
"line" : 67}
,
{
"name" : "infinity",
"kind" : "enum member",
"protection" : "public",
"comment" : " Allows the storage of $(LUCKY IEEE754 _infinity) values.\n",
"line" : 70}
,
{
"name" : "nan",
"kind" : "enum member",
"protection" : "public",
"comment" : " Allows the storage of $(LUCKY IEEE754 Not a Number) values.\n",
"line" : 73}
,
{
"name" : "probability",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n If set, select an exponent bias such that max_exp = 1.\n i.e. so that the maximum value is >= 1.0 and < 2.0.\n Ignored if the exponent bias is manually specified.\n     \n",
"line" : 80}
,
{
"name" : "negativeUnsigned",
"kind" : "enum member",
"protection" : "public",
"comment" : " If set, unsigned custom floats are assumed to be negative.\n",
"line" : 83}
,
{
"name" : "allowDenormZeroOnly",
"kind" : "enum member",
"protection" : "public",
"comment" : "If set, 0 is the only allowed $(LUCKY IEEE754 denormalized) number.\n Requires allowDenorm and storeNormalized.\n     \n",
"line" : 88}
,
{
"name" : "ieee",
"kind" : "enum member",
"protection" : "public",
"comment" : " Include _all of the $(LUCKY IEEE754) options.\n",
"line" : 91}
,
{
"name" : "none",
"kind" : "enum member",
"protection" : "public",
"comment" : " Include none of the above options.\n",
"line" : 94}
]
}
,
{
"name" : "bsr64",
"kind" : "function",
"protection" : "private",
"type" : "int(ulong value)",
"line" : 98}
,
{
"name" : "CustomFloat(uint bits) if (bits == 8 || bits == 16 || bits == 32 || bits == 64 || bits == 80)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Allows user code to define custom floating-point formats. These formats are\n for storage only; all operations on them are performed by first implicitly\n extracting them to $(D real) first. After the operation is completed the\n result can be stored in a custom floating-point value via assignment.\n\n Example:\n ----\n \/\/ Define a 16-bit floating point values\n CustomFloat!16                                x;     \/\/ Using the number of bits\n CustomFloat!(10, 5)                           y;     \/\/ Using the precision and exponent width\n CustomFloat!(10, 5,CustomFloatFlags.ieee)     z;     \/\/ Using the precision, exponent width and format flags\n CustomFloat!(10, 5,CustomFloatFlags.ieee, 15) w;     \/\/ Using the precision, exponent width, format flags and exponent offset bias\n\n \/\/ Use the 16-bit floats mostly like normal numbers\n w = x*y - 1;\n writeln(w);\n\n \/\/ Functions calls require conversion\n z = sin(+x)           + cos(+y);                     \/\/ Use uniary plus to concisely convert to a real\n z = sin(x.re)         + cos(y.re);                   \/\/ Or use the .re property to convert to a real\n z = sin(x.get!float)  + cos(y.get!float);            \/\/ Or use get!T\n z = sin(cast(float)x) + cos(cast(float)y);           \/\/ Or use cast(T) to explicitly convert\n\n \/\/ Define a 8-bit custom float for storing probabilities\n alias CustomFloat!(4, 4, CustomFloatFlags.ieee^CustomFloatFlags.probability^CustomFloatFlags.signed ) Probability;\n auto p = Probability(0.5);\n ----\n \n",
"line" : 140,
"members" : [
]
}
,
{
"name" : "CustomFloat(uint precision,uint exponentWidth,CustomFloatFlags flags = CustomFloatFlags.ieee) if (((flags & flags.signed) + precision + exponentWidth) % 8 == 0 && precision + exponentWidth > 0)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 150,
"members" : [
{
"name" : "CustomFloat",
"kind" : "alias",
"type" : "CustomFloat!(precision,exponentWidth,flags,(1 << exponentWidth - ((flags & flags.probability) == 0)) - ((flags & (flags.nan | flags.infinity)) != 0) - ((flags & flags.probability) != 0))",
"line" : 156}
]
}
,
{
"name" : "CustomFloat(uint precision,uint exponentWidth,CustomFloatFlags flags,uint bias) if (((flags & flags.signed) + precision + exponentWidth) % 8 == 0 && precision + exponentWidth > 0)",
"kind" : "struct",
"protection" : "public",
"comment" : "ditto\n",
"line" : 166,
"members" : [
{
"name" : "CustomFloat",
"kind" : "struct",
"protection" : "public",
"line" : 166,
"members" : [
{
"name" : "uType(uint bits)",
"kind" : "template",
"protection" : "public",
"line" : 169,
"members" : [
]
}
,
{
"name" : "sType(uint bits)",
"kind" : "template",
"protection" : "public",
"line" : 175,
"members" : [
]
}
,
{
"name" : "T_sig",
"kind" : "alias",
"type" : "uType!(precision)",
"line" : 180}
,
{
"name" : "T_exp",
"kind" : "alias",
"type" : "uType!(exponentWidth)",
"line" : 181}
,
{
"name" : "T_signed_exp",
"kind" : "alias",
"type" : "sType!(exponentWidth)",
"line" : 182}
,
{
"name" : "Flags",
"kind" : "alias",
"type" : "CustomFloatFlags",
"line" : 184}
,
{
"name" : "ToBinary(F) if (is(CustomFloat!(F.sizeof * 8)) || is(F == real))",
"kind" : "union",
"protection" : "public",
"line" : 187,
"members" : [
{
"name" : "ToBinary",
"kind" : "union",
"protection" : "public",
"line" : 187,
"members" : [
{
"name" : "set",
"kind" : "variable",
"type" : "F",
"line" : 188}
,
{
"name" : "get",
"kind" : "variable",
"type" : "CustomFloat!(min(F.sizeof * 8,80))",
"line" : 192}
,
{
"name" : "opCall",
"kind" : "function",
"type" : "typeof(get)(F value)",
"line" : 195}
]
}
]
}
,
{
"name" : "roundedShift(T,U)",
"kind" : "template",
"protection" : "public",
"line" : 204,
"members" : [
{
"name" : "roundedShift",
"kind" : "function",
"type" : "void(ref T sig, U shift)",
"line" : 204}
]
}
,
{
"name" : "toNormalized(T,U)",
"kind" : "template",
"protection" : "public",
"line" : 218,
"members" : [
{
"name" : "toNormalized",
"kind" : "function",
"type" : "void(ref T sig, ref U exp)",
"line" : 218}
]
}
,
{
"name" : "fromNormalized(T,U)",
"kind" : "template",
"protection" : "public",
"line" : 252,
"members" : [
{
"name" : "fromNormalized",
"kind" : "function",
"type" : "void(ref T sig, ref U exp)",
"line" : 252}
]
}
,
{
"name" : "dig",
"kind" : "function",
"type" : "size_t()",
"comment" : " Returns: number of decimal digits of precision\n",
"line" : 369}
,
{
"name" : "epsilon",
"kind" : "function",
"type" : "CustomFloat()",
"comment" : " Returns: smallest increment to the value 1\n",
"line" : 376}
,
{
"name" : "mant_dig",
"kind" : "variable",
"comment" : " the number of bits in mantissa\n",
"line" : 395}
,
{
"name" : "max_10_exp",
"kind" : "function",
"type" : "int()",
"comment" : " Returns: maximum int value such that 10<sup>max_10_exp<\/sup> is representable\n",
"line" : 398}
,
{
"name" : "max_exp",
"kind" : "variable",
"comment" : " maximum int value such that 2<sup>max_exp-1<\/sup> is representable\n",
"line" : 401}
,
{
"name" : "min_10_exp",
"kind" : "function",
"type" : "int()",
"comment" : " Returns: minimum int value such that 10<sup>min_10_exp<\/sup> is representable\n",
"line" : 404}
,
{
"name" : "min_exp",
"kind" : "variable",
"comment" : " minimum int value such that 2<sup>min_exp-1<\/sup> is representable as a normalized value\n",
"line" : 407}
,
{
"name" : "max",
"kind" : "function",
"type" : "CustomFloat()",
"comment" : " Returns: largest representable value that's not infinity\n",
"line" : 410}
,
{
"name" : "min_normal",
"kind" : "function",
"type" : "CustomFloat()",
"comment" : " Returns: smallest representable normalized value that's not 0\n",
"line" : 420}
,
{
"name" : "re",
"kind" : "function",
"type" : "CustomFloat()",
"comment" : " Returns: real part\n",
"line" : 433}
,
{
"name" : "im",
"kind" : "function",
"type" : "CustomFloat()",
"comment" : " Returns: imaginary part\n",
"line" : 436}
,
{
"name" : "__ctor(F) if (__traits(compiles,cast(real)input))",
"kind" : "template",
"protection" : "public",
"comment" : " Initialize from any $(D real) compatible type.\n",
"line" : 439,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(F input)",
"line" : 439}
]
}
,
{
"name" : "opAssign(F : CustomFloat)",
"kind" : "template",
"protection" : "public",
"comment" : " Self assignment\n",
"line" : 442,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(F input)",
"comment" : " Self assignment\n",
"line" : 442}
]
}
,
{
"name" : "opAssign(F) if (__traits(compiles,cast(real)input))",
"kind" : "template",
"protection" : "public",
"comment" : " Assigns from any $(D real) compatible type.\n",
"line" : 450,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(F input)",
"comment" : " Assigns from any $(D real) compatible type.\n",
"line" : 450}
]
}
,
{
"name" : "get(F) if (staticIndexOf!(Unqual!(F),float,double,real) >= 0)",
"kind" : "template",
"protection" : "public",
"comment" : " Fetches the stored value either as a $(D float), $(D double) or $(D real).\n",
"line" : 482,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "F()",
"line" : 482}
]
}
,
{
"name" : "opCast(T) if (__traits(compiles,get!(T)))",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 501,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "T()",
"comment" : "ditto\n",
"line" : 501}
]
}
,
{
"name" : "opUnary(string op) if (__traits(compiles,mixin(op ~ \"(get!real)\")) || op == \"++\" || op == \"--\")",
"kind" : "template",
"protection" : "public",
"comment" : " Convert the CustomFloat to a real and perform the relavent operator on the result\n",
"line" : 504,
"members" : [
{
"name" : "opUnary",
"kind" : "function",
"type" : "real()",
"comment" : " Convert the CustomFloat to a real and perform the relavent operator on the result\n",
"line" : 504}
]
}
,
{
"name" : "opBinary(string op,T) if (__traits(compiles,mixin(\"get!real\" ~ op ~ \"b\")))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 514,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "real(T b)",
"comment" : " ditto\n",
"line" : 514}
]
}
,
{
"name" : "opBinaryRight(string op,T) if (__traits(compiles,mixin(\"a\" ~ op ~ \"get!real\")) && !__traits(compiles,mixin(\"get!real\" ~ op ~ \"b\")))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 519,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "real(T a)",
"comment" : " ditto\n",
"line" : 519}
]
}
,
{
"name" : "opCmp(T) if (__traits(compiles,cast(real)b))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 525,
"members" : [
{
"name" : "opCmp",
"kind" : "function",
"type" : "int(auto ref T b)",
"comment" : " ditto\n",
"line" : 525}
]
}
,
{
"name" : "opOpAssign(string op,T) if (__traits(compiles,mixin(\"get!real\" ~ op ~ \"cast(real)b\")))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 532,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "void(auto ref T b)",
"comment" : " ditto\n",
"line" : 532}
]
}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"comment" : " ditto\n",
"line" : 537}
]
}
]
}
,
{
"name" : "FPTemporary(F) if (isFloatingPoint!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "\nDefines the fastest type to use when storing temporaries of a\ncalculation intended to ultimately yield a result of type $(D F)\n(where $(D F) must be one of $(D float), $(D double), or $(D\nreal)). When doing a multi-step computation, you may want to store\nintermediate results as $(D FPTemporary!F).\n\nExample:\n----\n\/\/ Average numbers in an array\ndouble avg(in double[] a)\n{\n    if (a.length == 0) return 0;\n    FPTemporary!double result = 0;\n    foreach (e; a) result += e;\n    return result \/ a.length;\n}\n----\n\nThe necessity of $(D FPTemporary) stems from the optimized\nfloating-point operations and registers present in virtually all\nprocessors. When adding numbers in the example above, the addition may\nin fact be done in $(D real) precision internally. In that case,\nstoring the intermediate $(D result) in $(D double format) is not only\nless precise, it is also (surprisingly) slower, because a conversion\nfrom $(D real) to $(D double) is performed every pass through the\nloop. This being a lose-lose situation, $(D FPTemporary!F) has been\ndefined as the $(I fastest) type to use for calculations at precision\n$(D F). There is no need to define a type for the $(I most accurate)\ncalculations, as that is always $(D real).\n\nFinally, there is no guarantee that using $(D FPTemporary!F) will\nalways be fastest, as the speed of floating-point calculations depends\non very many factors.\n \n",
"line" : 611,
"members" : [
{
"name" : "FPTemporary",
"kind" : "alias",
"type" : "real",
"line" : 613}
]
}
,
{
"name" : "secantMethod(alias fun)",
"kind" : "template",
"protection" : "public",
"comment" : "\nImplements the $(WEB tinyurl.com\/2zb9yr, secant method) for finding a\nroot of the function $(D fun) starting from points $(D [xn_1, x_n])\n(ideally close to the root). $(D Num) may be $(D float), $(D double),\nor $(D real).\n\nExample:\n\n----\nfloat f(float x) {\n    return cos(x) - x*x*x;\n}\nauto x = secantMethod!(f)(0f, 1f);\nassert(approxEqual(x, 0.865474));\n----\n",
"line" : 632,
"members" : [
{
"name" : "secantMethod(Num)",
"kind" : "template",
"protection" : "public",
"line" : 634,
"members" : [
{
"name" : "secantMethod",
"kind" : "function",
"type" : "Num(Num xn_1, Num xn)",
"line" : 634}
]
}
]
}
,
{
"name" : "oppositeSigns(T)",
"kind" : "template",
"protection" : "public",
"line" : 665,
"members" : [
{
"name" : "oppositeSigns",
"kind" : "function",
"type" : "bool(T a, T b)",
"line" : 665}
]
}
,
{
"name" : "findRoot(T,R)",
"kind" : "template",
"protection" : "public",
"comment" : "  Find a real root of a real function f(x) via bracketing.\n\n Given a function $(D f) and a range $(D [a..b]) such that $(D f(a))\n and $(D f(b)) have opposite signs, returns the value of $(D x) in\n the range which is closest to a root of $(D f(x)).  If $(D f(x))\n has more than one root in the range, one will be chosen\n arbitrarily.  If $(D f(x)) returns NaN, NaN will be returned;\n otherwise, this algorithm is guaranteed to succeed.\n\n Uses an algorithm based on TOMS748, which uses inverse cubic\n interpolation whenever possible, otherwise reverting to parabolic\n or secant interpolation. Compared to TOMS748, this implementation\n improves worst-case performance by a factor of more than 100, and\n typical performance by a factor of 2. For 80-bit reals, most\n problems require 8 to 15 calls to $(D f(x)) to achieve full machine\n precision. The worst-case performance (pathological cases) is\n approximately twice the number of bits.\n\n References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n pp733-744 (1993).  Fortran code available from $(WEB\n www.netlib.org,www.netlib.org) as algorithm TOMS478.\n\n \n",
"line" : 696,
"members" : [
{
"name" : "findRoot",
"kind" : "function",
"type" : "T(scope R delegate(T) f, T a, T b)",
"comment" : "  Find a real root of a real function f(x) via bracketing.\n\n Given a function $(D f) and a range $(D [a..b]) such that $(D f(a))\n and $(D f(b)) have opposite signs, returns the value of $(D x) in\n the range which is closest to a root of $(D f(x)).  If $(D f(x))\n has more than one root in the range, one will be chosen\n arbitrarily.  If $(D f(x)) returns NaN, NaN will be returned;\n otherwise, this algorithm is guaranteed to succeed.\n\n Uses an algorithm based on TOMS748, which uses inverse cubic\n interpolation whenever possible, otherwise reverting to parabolic\n or secant interpolation. Compared to TOMS748, this implementation\n improves worst-case performance by a factor of more than 100, and\n typical performance by a factor of 2. For 80-bit reals, most\n problems require 8 to 15 calls to $(D f(x)) to achieve full machine\n precision. The worst-case performance (pathological cases) is\n approximately twice the number of bits.\n\n References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n pp733-744 (1993).  Fortran code available from $(WEB\n www.netlib.org,www.netlib.org) as algorithm TOMS478.\n\n \n",
"line" : 696}
]
}
,
{
"name" : "findRoot(T,R)",
"kind" : "template",
"protection" : "public",
"comment" : " Find root of a real function f(x) by bracketing, allowing the\n termination condition to be specified.\n\n Params:\n\n f = Function to be analyzed\n\n ax = Left bound of initial range of $(D f) known to contain the\n root.\n\n bx = Right bound of initial range of $(D f) known to contain the\n root.\n\n fax = Value of $(D f(ax)).\n\n fbx = Value of $(D f(bx)). ($(D f(ax)) and $(D f(bx)) are commonly\n known in advance.)\n\n\n tolerance = Defines an early termination condition. Receives the\n             current upper and lower bounds on the root. The\n             delegate must return $(D true) when these bounds are\n             acceptable. If this function always returns $(D false),\n             full machine precision will be achieved.\n\n Returns:\n\n A tuple consisting of two ranges. The first two elements are the\n range (in $(D x)) of the root, while the second pair of elements\n are the corresponding function values at those points. If an exact\n root was found, both of the first two elements will contain the\n root, and the second pair of elements will be 0.\n \n",
"line" : 736,
"members" : [
{
"name" : "findRoot",
"kind" : "function",
"type" : "Tuple!(T,T,R,R)(scope R delegate(T) f, T ax, T bx, R fax, R fbx, scope bool delegate(T lo, T hi) tolerance)",
"comment" : " Find root of a real function f(x) by bracketing, allowing the\n termination condition to be specified.\n\n Params:\n\n f = Function to be analyzed\n\n ax = Left bound of initial range of $(D f) known to contain the\n root.\n\n bx = Right bound of initial range of $(D f) known to contain the\n root.\n\n fax = Value of $(D f(ax)).\n\n fbx = Value of $(D f(bx)). ($(D f(ax)) and $(D f(bx)) are commonly\n known in advance.)\n\n\n tolerance = Defines an early termination condition. Receives the\n             current upper and lower bounds on the root. The\n             delegate must return $(D true) when these bounds are\n             acceptable. If this function always returns $(D false),\n             full machine precision will be achieved.\n\n Returns:\n\n A tuple consisting of two ranges. The first two elements are the\n range (in $(D x)) of the root, while the second pair of elements\n are the corresponding function values at those points. If an exact\n root was found, both of the first two elements will contain the\n root, and the second pair of elements will be 0.\n \n",
"line" : 736}
]
}
,
{
"name" : "euclideanDistance(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes $(LUCKY Euclidean distance) between input ranges $(D a) and\n$(D b). The two ranges must have the same length. The three-parameter\nversion stops computation as soon as the distance is greater than or\nequal to $(D limit) (this is useful to save computation if a small\ndistance is sought).\n \n",
"line" : 1169,
"members" : [
{
"name" : "euclideanDistance",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b)",
"comment" : "\nComputes $(LUCKY Euclidean distance) between input ranges $(D a) and\n$(D b). The two ranges must have the same length. The three-parameter\nversion stops computation as soon as the distance is greater than or\nequal to $(D limit) (this is useful to save computation if a small\ndistance is sought).\n \n",
"line" : 1169}
]
}
,
{
"name" : "euclideanDistance(Range1,Range2,F) if (isInputRange!(Range1) && isInputRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1186,
"members" : [
{
"name" : "euclideanDistance",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b, F limit)",
"comment" : " Ditto\n",
"line" : 1186}
]
}
,
{
"name" : "dotProduct(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2) && !(isArray!(Range1) && isArray!(Range2)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes the $(LUCKY dot product) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration.\n \n",
"line" : 1224,
"members" : [
{
"name" : "dotProduct",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b)",
"comment" : "\nComputes the $(LUCKY dot product) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration.\n \n",
"line" : 1224}
]
}
,
{
"name" : "dotProduct(F1,F2)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1241,
"members" : [
{
"name" : "dotProduct",
"kind" : "function",
"type" : "Unqual!(CommonType!(F1,F2))(in F1[] avector, in F2[] bvector)",
"comment" : " Ditto\n",
"line" : 1241}
]
}
,
{
"name" : "cosineSimilarity(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration. If either range has all-zero elements, return 0.\n \n",
"line" : 1318,
"members" : [
{
"name" : "cosineSimilarity",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b)",
"comment" : "\nComputes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration. If either range has all-zero elements, return 0.\n \n",
"line" : 1318}
]
}
,
{
"name" : "normalize(R) if (isForwardRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "\nNormalizes values in $(D range) by multiplying each element with a\nnumber chosen such that values sum up to $(D sum). If elements in $(D\nrange) sum to zero, assigns $(D sum \/ range.length) to\nall. Normalization makes sense only if all elements in $(D range) are\npositive. $(D normalize) assumes that is the case without checking it.\n\nReturns: $(D true) if normalization completed normally, $(D false) if\nall elements in $(D range) were zero or if $(D range) is empty.\n \n",
"line" : 1357,
"members" : [
{
"name" : "normalize",
"kind" : "function",
"type" : "bool(R range, ElementType!(R) sum = 1)",
"comment" : "\nNormalizes values in $(D range) by multiplying each element with a\nnumber chosen such that values sum up to $(D sum). If elements in $(D\nrange) sum to zero, assigns $(D sum \/ range.length) to\nall. Normalization makes sense only if all elements in $(D range) are\npositive. $(D normalize) assumes that is the case without checking it.\n\nReturns: $(D true) if normalization completed normally, $(D false) if\nall elements in $(D range) were zero or if $(D range) is empty.\n \n",
"line" : 1357}
]
}
,
{
"name" : "entropy(Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes $(LUCKY _entropy) of input range $(D r) in bits. This\nfunction assumes (without checking) that the values in $(D r) are all\nin $(D [0, 1]). For the entropy to be meaningful, often $(D r) should\nbe normalized too (i.e., its values should sum to 1). The\ntwo-parameter version stops evaluating as soon as the intermediate\nresult is greater than or equal to $(D max).\n \n",
"line" : 1415,
"members" : [
{
"name" : "entropy",
"kind" : "function",
"type" : "ElementType!(Range)(Range r)",
"comment" : "\nComputes $(LUCKY _entropy) of input range $(D r) in bits. This\nfunction assumes (without checking) that the values in $(D r) are all\nin $(D [0, 1]). For the entropy to be meaningful, often $(D r) should\nbe normalized too (i.e., its values should sum to 1). The\ntwo-parameter version stops evaluating as soon as the intermediate\nresult is greater than or equal to $(D max).\n \n",
"line" : 1415}
]
}
,
{
"name" : "entropy(Range,F) if (isInputRange!(Range) && !is(CommonType!(ElementType!(Range),F) == void))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1427,
"members" : [
{
"name" : "entropy",
"kind" : "function",
"type" : "ElementType!(Range)(Range r, F max)",
"comment" : " Ditto\n",
"line" : 1427}
]
}
,
{
"name" : "kullbackLeiblerDivergence(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes the $(LUCKY Kullback-Leibler divergence) between input ranges\n$(D a) and $(D b), which is the sum $(D ai * log(ai \/ bi)). The base\nof logarithm is 2. The ranges are assumed to contain elements in $(D\n[0, 1]). Usually the ranges are normalized probability distributions,\nbut this is not required or checked by $(D\nkullbackLeiblerDivergence). If any element $(D bi) is zero and the\ncorresponding element $(D ai) nonzero, returns infinity. (Otherwise,\nif $(D ai == 0 && bi == 0), the term $(D ai * log(ai \/ bi)) is\nconsidered zero.) If the inputs are normalized, the result is\npositive.\n \n",
"line" : 1463,
"members" : [
{
"name" : "kullbackLeiblerDivergence",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b)",
"comment" : "\nComputes the $(LUCKY Kullback-Leibler divergence) between input ranges\n$(D a) and $(D b), which is the sum $(D ai * log(ai \/ bi)). The base\nof logarithm is 2. The ranges are assumed to contain elements in $(D\n[0, 1]). Usually the ranges are normalized probability distributions,\nbut this is not required or checked by $(D\nkullbackLeiblerDivergence). If any element $(D bi) is zero and the\ncorresponding element $(D ai) nonzero, returns infinity. (Otherwise,\nif $(D ai == 0 && bi == 0), the term $(D ai * log(ai \/ bi)) is\nconsidered zero.) If the inputs are normalized, the result is\npositive.\n \n",
"line" : 1463}
]
}
,
{
"name" : "jensenShannonDivergence(Range1,Range2) if (isInputRange!(Range1) && isInputRange!(Range2) && is(CommonType!(ElementType!(Range1),ElementType!(Range2))))",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D\nb), which is the sum $(D (ai * log(2 * ai \/ (ai + bi)) + bi * log(2 *\nbi \/ (ai + bi))) \/ 2). The base of logarithm is 2. The ranges are\nassumed to contain elements in $(D [0, 1]). Usually the ranges are\nnormalized probability distributions, but this is not required or\nchecked by $(D jensenShannonDivergence). If the inputs are normalized,\nthe result is bounded within $(D [0, 1]). The three-parameter version\nstops evaluations as soon as the intermediate result is greater than\nor equal to $(D limit).\n \n",
"line" : 1507,
"members" : [
{
"name" : "jensenShannonDivergence",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b)",
"comment" : "\nComputes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D\nb), which is the sum $(D (ai * log(2 * ai \/ (ai + bi)) + bi * log(2 *\nbi \/ (ai + bi))) \/ 2). The base of logarithm is 2. The ranges are\nassumed to contain elements in $(D [0, 1]). Usually the ranges are\nnormalized probability distributions, but this is not required or\nchecked by $(D jensenShannonDivergence). If the inputs are normalized,\nthe result is bounded within $(D [0, 1]). The three-parameter version\nstops evaluations as soon as the intermediate result is greater than\nor equal to $(D limit).\n \n",
"line" : 1507}
]
}
,
{
"name" : "jensenShannonDivergence(Range1,Range2,F) if (isInputRange!(Range1) && isInputRange!(Range2) && is(typeof(CommonType!(ElementType!(Range1),ElementType!(Range2)).init >= F.init) : bool))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1534,
"members" : [
{
"name" : "jensenShannonDivergence",
"kind" : "function",
"type" : "CommonType!(ElementType!(Range1),ElementType!(Range2))(Range1 a, Range2 b, F limit)",
"comment" : " Ditto\n",
"line" : 1534}
]
}
,
{
"name" : "gapWeightedSimilarity(alias comp = \"a == b\",R1,R2,F) if (isRandomAccessRange!(R1) && hasLength!(R1) && isRandomAccessRange!(R2) && hasLength!(R2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe so-called \"all-lengths gap-weighted string kernel\" computes a\nsimilarity measure between $(D s) and $(D t) based on all of their\ncommon subsequences of all lengths. Gapped subsequences are also\nincluded.\n\nTo understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,\nconsider first the case $(D lambda = 1) and the strings $(D s =\n[\"Hello\", \"brave\", \"new\", \"world\"]) and $(D t = [\"Hello\", \"new\",\n\"world\"]). In that case, $(D gapWeightedSimilarity) counts the\nfollowing matches:\n\n$(OL $(LI three matches of length 1, namely $(D \"Hello\"), $(D \"new\"),\nand $(D \"world\");) $(LI three matches of length 2, namely ($(D\n\"Hello\", \"new\")), ($(D \"Hello\", \"world\")), and ($(D \"new\", \"world\"));)\n$(LI one match of length 3, namely ($(D \"Hello\", \"new\", \"world\")).))\n\nThe call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of\nthese matches and adds them up, returning 7.\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 1) == 7);\n----\n\nNote how the gaps in matching are simply ignored, for example ($(D\n\"Hello\", \"new\")) is deemed as good a match as ($(D \"new\",\n\"world\")). This may be too permissive for some applications. To\neliminate gapped matches entirely, use $(D lambda = 0):\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0) == 4);\n----\n\nThe call above eliminated the gapped matches ($(D \"Hello\", \"new\")),\n($(D \"Hello\", \"world\")), and ($(D \"Hello\", \"new\", \"world\")) from the\ntally. That leaves only 4 matches.\n\nThe most interesting case is when gapped matches still participate in\nthe result, but not as strongly as ungapped matches. The result will\nbe a smooth, fine-grained similarity measure between the input\nstrings. This is where values of $(D lambda) between 0 and 1 enter\ninto play: gapped matches are $(I exponentially penalized with the\nnumber of gaps) with base $(D lambda). This means that an ungapped\nmatch adds 1 to the return value; a match with one gap in either\nstring adds $(D lambda) to the return value; ...; a match with a total\nof $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return\nvalue. In the example above, we have 4 matches without gaps, 2 matches\nwith one gap, and 1 match with three gaps. The latter match is ($(D\n\"Hello\", \"world\")), which has two gaps in the first string and one gap\nin the second string, totaling to three gaps. Summing these up we get\n$(D 4 + 2 * lambda + pow(lambda, 3)).\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);\n----\n\n$(D gapWeightedSimilarity) is useful wherever a smooth similarity\nmeasure between sequences allowing for approximate matches is\nneeded. The examples above are given with words, but any sequences\nwith elements comparable for equality are allowed, e.g. characters or\nnumbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic\nprogramming implementation that needs $(D 16 * min(s.length,\nt.length)) extra bytes of memory and $(BIGOH s.length * t.length) time\nto complete.\n \n",
"line" : 1692,
"members" : [
{
"name" : "gapWeightedSimilarity",
"kind" : "function",
"type" : "F(R1 s, R2 t, F lambda)",
"comment" : "\nThe so-called \"all-lengths gap-weighted string kernel\" computes a\nsimilarity measure between $(D s) and $(D t) based on all of their\ncommon subsequences of all lengths. Gapped subsequences are also\nincluded.\n\nTo understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,\nconsider first the case $(D lambda = 1) and the strings $(D s =\n[\"Hello\", \"brave\", \"new\", \"world\"]) and $(D t = [\"Hello\", \"new\",\n\"world\"]). In that case, $(D gapWeightedSimilarity) counts the\nfollowing matches:\n\n$(OL $(LI three matches of length 1, namely $(D \"Hello\"), $(D \"new\"),\nand $(D \"world\");) $(LI three matches of length 2, namely ($(D\n\"Hello\", \"new\")), ($(D \"Hello\", \"world\")), and ($(D \"new\", \"world\"));)\n$(LI one match of length 3, namely ($(D \"Hello\", \"new\", \"world\")).))\n\nThe call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of\nthese matches and adds them up, returning 7.\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 1) == 7);\n----\n\nNote how the gaps in matching are simply ignored, for example ($(D\n\"Hello\", \"new\")) is deemed as good a match as ($(D \"new\",\n\"world\")). This may be too permissive for some applications. To\neliminate gapped matches entirely, use $(D lambda = 0):\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0) == 4);\n----\n\nThe call above eliminated the gapped matches ($(D \"Hello\", \"new\")),\n($(D \"Hello\", \"world\")), and ($(D \"Hello\", \"new\", \"world\")) from the\ntally. That leaves only 4 matches.\n\nThe most interesting case is when gapped matches still participate in\nthe result, but not as strongly as ungapped matches. The result will\nbe a smooth, fine-grained similarity measure between the input\nstrings. This is where values of $(D lambda) between 0 and 1 enter\ninto play: gapped matches are $(I exponentially penalized with the\nnumber of gaps) with base $(D lambda). This means that an ungapped\nmatch adds 1 to the return value; a match with one gap in either\nstring adds $(D lambda) to the return value; ...; a match with a total\nof $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return\nvalue. In the example above, we have 4 matches without gaps, 2 matches\nwith one gap, and 1 match with three gaps. The latter match is ($(D\n\"Hello\", \"world\")), which has two gaps in the first string and one gap\nin the second string, totaling to three gaps. Summing these up we get\n$(D 4 + 2 * lambda + pow(lambda, 3)).\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);\n----\n\n$(D gapWeightedSimilarity) is useful wherever a smooth similarity\nmeasure between sequences allowing for approximate matches is\nneeded. The examples above are given with words, but any sequences\nwith elements comparable for equality are allowed, e.g. characters or\nnumbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic\nprogramming implementation that needs $(D 16 * min(s.length,\nt.length)) extra bytes of memory and $(BIGOH s.length * t.length) time\nto complete.\n \n",
"line" : 1692}
]
}
,
{
"name" : "gapWeightedSimilarityNormalized(alias comp = \"a == b\",R1,R2,F) if (isRandomAccessRange!(R1) && hasLength!(R1) && isRandomAccessRange!(R2) && hasLength!(R2))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe similarity per $(D gapWeightedSimilarity) has an issue in that it\ngrows with the lengths of the two strings, even though the strings are\nnot actually very similar. For example, the range $(D [\"Hello\",\n\"world\"]) is increasingly similar with the range $(D [\"Hello\",\n\"world\", \"world\", \"world\",...]) as more instances of $(D \"world\") are\nappended. To prevent that, $(D gapWeightedSimilarityNormalized)\ncomputes a normalized version of the similarity that is computed as\n$(D gapWeightedSimilarity(s, t, lambda) \/\nsqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,\nlambda))). The function $(D gapWeightedSimilarityNormalized) (a\nso-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)\nonly for ranges that don't match in any position, and $(D 1) only for\nidentical ranges.\n\nExample:\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, s, 1) == 15);\nassert(gapWeightedSimilarity(t, t, 1) == 7);\nassert(gapWeightedSimilarity(s, t, 1) == 7);\nassert(gapWeightedSimilarityNormalized(s, t, 1) == 7. \/ sqrt(15. * 7));\n----\n\nThe optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for\navoiding duplicate computation. Many applications may have already\ncomputed $(D gapWeightedSimilarity(s, s, lambda)) and\/or $(D\ngapWeightedSimilarity(t, t, lambda)). In that case, they can be passed\nas $(D sSelfSim) and $(D tSelfSim), respectively.\n \n",
"line" : 1774,
"members" : [
{
"name" : "gapWeightedSimilarityNormalized",
"kind" : "function",
"type" : "Select!(isFloatingPoint!(F),F,double)(R1 s, R2 t, F lambda, F sSelfSim = F.init, F tSelfSim = F.init)",
"comment" : "\nThe similarity per $(D gapWeightedSimilarity) has an issue in that it\ngrows with the lengths of the two strings, even though the strings are\nnot actually very similar. For example, the range $(D [\"Hello\",\n\"world\"]) is increasingly similar with the range $(D [\"Hello\",\n\"world\", \"world\", \"world\",...]) as more instances of $(D \"world\") are\nappended. To prevent that, $(D gapWeightedSimilarityNormalized)\ncomputes a normalized version of the similarity that is computed as\n$(D gapWeightedSimilarity(s, t, lambda) \/\nsqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,\nlambda))). The function $(D gapWeightedSimilarityNormalized) (a\nso-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)\nonly for ranges that don't match in any position, and $(D 1) only for\nidentical ranges.\n\nExample:\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, s, 1) == 15);\nassert(gapWeightedSimilarity(t, t, 1) == 7);\nassert(gapWeightedSimilarity(s, t, 1) == 7);\nassert(gapWeightedSimilarityNormalized(s, t, 1) == 7. \/ sqrt(15. * 7));\n----\n\nThe optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for\navoiding duplicate computation. Many applications may have already\ncomputed $(D gapWeightedSimilarity(s, s, lambda)) and\/or $(D\ngapWeightedSimilarity(t, t, lambda)). In that case, they can be passed\nas $(D sSelfSim) and $(D tSelfSim), respectively.\n \n",
"line" : 1774}
]
}
,
{
"name" : "GapWeightedSimilarityIncremental(Range,F = double) if (isRandomAccessRange!(Range) && hasLength!(Range))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nSimilar to $(D gapWeightedSimilarity), just works in an incremental\nmanner by first revealing the matches of length 1, then gapped matches\nof length 2, and so on. The memory requirement is $(BIGOH s.length *\nt.length). The time complexity is $(BIGOH s.length * t.length) time\nfor computing each step. Continuing on the previous example:\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nauto simIter = gapWeightedSimilarityIncremental(s, t, 1);\nassert(simIter.front == 3); \/\/ three 1-length matches\nsimIter.popFront();\nassert(simIter.front == 3); \/\/ three 2-length matches\nsimIter.popFront();\nassert(simIter.front == 1); \/\/ one 3-length match\nsimIter.popFront();\nassert(simIter.empty);     \/\/ no more match\n----\n\nThe implementation is based on the pseudocode in Fig. 4 of the paper\n$(WEB jmlr.csail.mit.edu\/papers\/volume6\/rousu05a\/rousu05a.pdf,\n\"Efcient Computation of Gapped Substring Kernels on Large Alphabets\")\nby Rousu et al., with additional algorithmic and systems-level\noptimizations.\n \n",
"line" : 1834,
"members" : [
{
"name" : "GapWeightedSimilarityIncremental",
"kind" : "struct",
"protection" : "public",
"line" : 1834,
"members" : [
{
"name" : "s",
"kind" : "variable",
"type" : "Range",
"line" : 1836}
,
{
"name" : "t",
"kind" : "variable",
"type" : "Range",
"line" : 1836}
,
{
"name" : "currentValue",
"kind" : "variable",
"type" : "F",
"line" : 1837}
,
{
"name" : "kl",
"kind" : "variable",
"type" : "F*",
"line" : 1838}
,
{
"name" : "gram",
"kind" : "variable",
"type" : "size_t",
"line" : 1839}
,
{
"name" : "lambda",
"kind" : "variable",
"type" : "F",
"line" : 1840}
,
{
"name" : "lambda2",
"kind" : "variable",
"type" : "F",
"line" : 1840}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range s, Range t, F lambda)",
"comment" : "\nConstructs an object given two ranges $(D s) and $(D t) and a penalty\n$(D lambda). Constructor completes in $(BIGOH s.length * t.length)\ntime and computes all matches of length 1.\n \n",
"line" : 1848}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "GapWeightedSimilarityIncremental()",
"comment" : "\nReturns $(D this).\n \n",
"line" : 1901}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\nComputes the match of the popFront length. Completes in $(BIGOH s.length *\nt.length) time.\n \n",
"line" : 1910}
,
{
"name" : "front",
"kind" : "function",
"type" : "F()",
"comment" : "\nReturns the gapped similarity at the current match length (initially\n1, grows with each call to $(D popFront)).\n \n",
"line" : 1986}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\nReturns whether there are more matches.\n \n",
"line" : 1991}
]
}
]
}
,
{
"name" : "gapWeightedSimilarityIncremental(R,F)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDitto\n \n",
"line" : 2004,
"members" : [
{
"name" : "gapWeightedSimilarityIncremental",
"kind" : "function",
"type" : "GapWeightedSimilarityIncremental!(R,F)(R r1, R r2, F penalty)",
"comment" : "\nDitto\n \n",
"line" : 2004}
]
}
,
{
"name" : "gcd(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nComputes the greatest common divisor of $(D a) and $(D b) by using\nEuler's algorithm.\n \n",
"line" : 2083,
"members" : [
{
"name" : "gcd",
"kind" : "function",
"type" : "T(T a, T b)",
"comment" : "\nComputes the greatest common divisor of $(D a) and $(D b) by using\nEuler's algorithm.\n \n",
"line" : 2083}
]
}
,
{
"name" : "lookup_t",
"kind" : "alias",
"protection" : "private",
"type" : "float",
"line" : 2166}
,
{
"name" : "Fft",
"kind" : "class",
"protection" : "public",
"comment" : "A class for performing fast Fourier transforms of power of two sizes.\n This class encapsulates a large amount of state that is reusable when\n performing multiple FFTs of sizes smaller than or equal to that specified\n in the constructor.  This results in substantial speedups when performing\n multiple FFTs with a known maximum size.  However,\n a free function API is provided for convenience if you need to perform a\n one-off FFT.\n\n References:\n $(WEB en.wikipedia.org\/wiki\/Cooley%E2%80%93Tukey_FFT_algorithm)\n \n",
"line" : 2179,
"base" : "Object",
"members" : [
{
"name" : "negSinLookup",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(float[][])",
"line" : 2181}
,
{
"name" : "enforceSize(R)",
"kind" : "template",
"protection" : "public",
"line" : 2183,
"members" : [
{
"name" : "enforceSize",
"kind" : "function",
"type" : "const void(R range)",
"line" : 2183}
]
}
,
{
"name" : "fftImpl(Ret,R)",
"kind" : "template",
"protection" : "public",
"line" : 2188,
"members" : [
{
"name" : "fftImpl",
"kind" : "function",
"type" : "const void(Stride!(R) range, Ret buf)",
"line" : 2188}
]
}
,
{
"name" : "fftImplPureReal(Ret,R)",
"kind" : "template",
"protection" : "public",
"line" : 2216,
"members" : [
{
"name" : "fftImplPureReal",
"kind" : "function",
"type" : "const void(R range, Ret buf)",
"line" : 2216}
]
}
,
{
"name" : "butterfly(R)",
"kind" : "template",
"protection" : "public",
"line" : 2307,
"members" : [
{
"name" : "butterfly",
"kind" : "function",
"type" : "const void(R buf)",
"line" : 2307}
]
}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Fft(float[] memSpace)",
"line" : 2377}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Fft(ulong size)",
"comment" : "Create an $(D Fft) object for computing fast Fourier transforms of\n power of two sizes of $(D size) or smaller.  $(D size) must be a\n power of two.\n     \n",
"line" : 2434}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "const @property ulong()",
"line" : 2441}
,
{
"name" : "fft(F = double,R) if (isFloatingPoint!(F) && isRandomAccessRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "Compute the Fourier transform of range using the $(BIGOH N log N)\n Cooley-Tukey Algorithm.  $(D range) must be a random-access range with\n slicing and a length equal to $(D size) as provided at the construction of\n this object.  The contents of range can be either  numeric types,\n which will be interpreted as pure real values, or complex types with\n properties or members $(D .re) and $(D .im) that can be read.\n\n Note:  Pure real FFTs are automatically detected and the relevant\n        optimizations are performed.\n\n Returns:  An array of complex numbers representing the transformed data in\n           the frequency domain.\n     \n",
"line" : 2458,
"members" : [
{
"name" : "fft",
"kind" : "function",
"type" : "const Complex!(F)[](R range)",
"comment" : "Compute the Fourier transform of range using the $(BIGOH N log N)\n Cooley-Tukey Algorithm.  $(D range) must be a random-access range with\n slicing and a length equal to $(D size) as provided at the construction of\n this object.  The contents of range can be either  numeric types,\n which will be interpreted as pure real values, or complex types with\n properties or members $(D .re) and $(D .im) that can be read.\n\n Note:  Pure real FFTs are automatically detected and the relevant\n        optimizations are performed.\n\n Returns:  An array of complex numbers representing the transformed data in\n           the frequency domain.\n     \n",
"line" : 2458}
]
}
,
{
"name" : "fft(Ret,R) if (isRandomAccessRange!(Ret) && isComplexLike!(ElementType!(Ret)) && hasSlicing!(Ret))",
"kind" : "template",
"protection" : "public",
"comment" : "Same as the overload, but allows for the results to be stored in a user-\n provided buffer.  The buffer must be of the same length as range, must be\n a random-access range, must have slicing, and must contain elements that are\n complex-like.  This means that they must have a .re and a .im member or\n property that can be both read and written and are floating point numbers.\n     \n",
"line" : 2479,
"members" : [
{
"name" : "fft",
"kind" : "function",
"type" : "const void(R range, Ret buf)",
"comment" : "Same as the overload, but allows for the results to be stored in a user-\n provided buffer.  The buffer must be of the same length as range, must be\n a random-access range, must have slicing, and must contain elements that are\n complex-like.  This means that they must have a .re and a .im member or\n property that can be both read and written and are floating point numbers.\n     \n",
"line" : 2479}
]
}
,
{
"name" : "inverseFft(F = double,R) if (isRandomAccessRange!(R) && isComplexLike!(ElementType!(R)) && isFloatingPoint!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "Computes the inverse Fourier transform of a range.  The range must be a\n random access range with slicing, have a length equal to the size\n provided at construction of this object, and contain elements that are\n either of type std.complex.Complex or have essentially\n the same compile-time interface.\n\n Returns:  The time-domain signal.\n     \n",
"line" : 2514,
"members" : [
{
"name" : "inverseFft",
"kind" : "function",
"type" : "const Complex!(F)[](R range)",
"comment" : "Computes the inverse Fourier transform of a range.  The range must be a\n random access range with slicing, have a length equal to the size\n provided at construction of this object, and contain elements that are\n either of type std.complex.Complex or have essentially\n the same compile-time interface.\n\n Returns:  The time-domain signal.\n     \n",
"line" : 2514}
]
}
,
{
"name" : "inverseFft(Ret,R) if (isRandomAccessRange!(Ret) && isComplexLike!(ElementType!(Ret)) && hasSlicing!(Ret))",
"kind" : "template",
"protection" : "public",
"comment" : "Inverse FFT that allows a user-supplied buffer to be provided.  The buffer\n must be a random access range with slicing, and its elements\n must be some complex-like type.\n     \n",
"line" : 2533,
"members" : [
{
"name" : "inverseFft",
"kind" : "function",
"type" : "const void(R range, Ret buf)",
"comment" : "Inverse FFT that allows a user-supplied buffer to be provided.  The buffer\n must be a random access range with slicing, and its elements\n must be some complex-like type.\n     \n",
"line" : 2533}
]
}
]
}
,
{
"name" : "MakeLocalFft",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 2552}
,
{
"name" : "fft(F = double,R)",
"kind" : "template",
"protection" : "public",
"comment" : "Convenience functions that create an $(D Fft) object, run the FFT or inverse\n FFT and return the result.  Useful for one-off FFTs.\n\n Note:  In addition to convenience, these functions are slightly more\n        efficient than manually creating an Fft object for a single use,\n        as the Fft object is deterministically destroyed before these\n        functions return.\n \n",
"line" : 2570,
"members" : [
{
"name" : "fft",
"kind" : "function",
"type" : "Complex!(F)[](R range)",
"comment" : "Convenience functions that create an $(D Fft) object, run the FFT or inverse\n FFT and return the result.  Useful for one-off FFTs.\n\n Note:  In addition to convenience, these functions are slightly more\n        efficient than manually creating an Fft object for a single use,\n        as the Fft object is deterministically destroyed before these\n        functions return.\n \n",
"line" : 2570}
]
}
,
{
"name" : "fft(Ret,R)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2576,
"members" : [
{
"name" : "fft",
"kind" : "function",
"type" : "void(R range, Ret buf)",
"comment" : " ditto\n",
"line" : 2576}
]
}
,
{
"name" : "inverseFft(F = double,R)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2582,
"members" : [
{
"name" : "inverseFft",
"kind" : "function",
"type" : "Complex!(F)[](R range)",
"comment" : " ditto\n",
"line" : 2582}
]
}
,
{
"name" : "inverseFft(Ret,R)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2588,
"members" : [
{
"name" : "inverseFft",
"kind" : "function",
"type" : "void(R range, Ret buf)",
"comment" : " ditto\n",
"line" : 2588}
]
}
,
{
"name" : "swapRealImag(C)",
"kind" : "template",
"protection" : "public",
"line" : 2661,
"members" : [
{
"name" : "swapRealImag",
"kind" : "function",
"type" : "C(C input)",
"line" : 2661}
]
}
,
{
"name" : "Stride(R)",
"kind" : "struct",
"protection" : "public",
"line" : 2669,
"members" : [
{
"name" : "Stride",
"kind" : "struct",
"protection" : "public",
"line" : 2669,
"members" : [
{
"name" : "range",
"kind" : "variable",
"type" : "Unqual!(R)",
"line" : 2670}
,
{
"name" : "_nSteps",
"kind" : "variable",
"type" : "size_t",
"line" : 2671}
,
{
"name" : "_length",
"kind" : "variable",
"type" : "size_t",
"line" : 2672}
,
{
"name" : "E",
"kind" : "alias",
"type" : "ElementType!(R)",
"line" : 2673}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R range, size_t nStepsIn)",
"line" : 2675}
,
{
"name" : "length",
"kind" : "function",
"type" : "const @property size_t()",
"line" : 2681}
,
{
"name" : "save",
"kind" : "function",
"type" : "@property typeof(this)()",
"line" : 2685}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "E(size_t index)",
"line" : 2691}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property E()",
"line" : 2695}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2699}
,
{
"name" : "popHalf",
"kind" : "function",
"type" : "void()",
"line" : 2710}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const @property bool()",
"line" : 2714}
,
{
"name" : "nSteps",
"kind" : "function",
"type" : "const @property size_t()",
"line" : 2718}
,
{
"name" : "doubleSteps",
"kind" : "function",
"type" : "void()",
"line" : 2722}
,
{
"name" : "nSteps",
"kind" : "function",
"type" : "@property size_t(size_t newVal)",
"line" : 2727}
]
}
]
}
,
{
"name" : "slowFourier2(Ret,R)",
"kind" : "template",
"protection" : "public",
"line" : 2739,
"members" : [
{
"name" : "slowFourier2",
"kind" : "function",
"type" : "void(R range, Ret buf)",
"line" : 2739}
]
}
,
{
"name" : "slowFourier4(Ret,R)",
"kind" : "template",
"protection" : "public",
"line" : 2748,
"members" : [
{
"name" : "slowFourier4",
"kind" : "function",
"type" : "void(R range, Ret buf)",
"line" : 2748}
]
}
,
{
"name" : "isPowerOfTwo",
"kind" : "function",
"protection" : "private",
"type" : "bool(ulong num)",
"line" : 2759}
,
{
"name" : "roundDownToPowerOf2",
"kind" : "function",
"protection" : "private",
"type" : "ulong(ulong num)",
"line" : 2763}
,
{
"name" : "isComplexLike(T)",
"kind" : "template",
"protection" : "public",
"line" : 2772,
"members" : [
{
"name" : "isComplexLike",
"kind" : "variable",
"type" : "bool",
"line" : 2773}
]
}
]
}
,
{
"name" : "std.outbuffer",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/outbuffer.d",
"comment" : "\n Macros:\n      WIKI = Phobos\/StdOutbuffer\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_outbuffer.d)\n \n",
"members" : [
{
"name" : "OutBuffer",
"kind" : "class",
"protection" : "public",
"comment" : "\n OutBuffer provides a way to build up an array of bytes out\n of raw data. It is useful for things like preparing an\n array of bytes to write out to a file.\n OutBuffer's byte order is the format native to the computer.\n To control the byte order (endianness), use a class derived\n from OutBuffer.\n \n",
"line" : 38,
"base" : "Object",
"members" : [
{
"name" : "data",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[]",
"line" : 39}
,
{
"name" : "offset",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 40}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OutBuffer()",
"line" : 48}
,
{
"name" : "toBytes",
"kind" : "function",
"protection" : "public",
"type" : "ubyte[]()",
"comment" : "\n Convert to array of bytes.\n     \n",
"line" : 57}
,
{
"name" : "reserve",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong nbytes)",
"comment" : "\n Preallocate nbytes more to the size of the internal buffer.\n\n This is a\n speed optimization, a good guess at the maximum size of the resulting\n buffer will improve performance by eliminating reallocations and copying.\n     \n",
"line" : 68}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(ubyte)[] bytes)",
"comment" : "\n Append data to the internal buffer.\n     \n",
"line" : 91}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar[]) chars)",
"line" : 98}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(dchar)[] chars)",
"line" : 103}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte b)",
"comment" : " ditto\n",
"line" : 108}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(byte b)",
"comment" : " ditto\n",
"line" : 115}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(char c)",
"comment" : " ditto\n",
"line" : 116}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(dchar c)",
"comment" : " ditto\n",
"line" : 117}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ushort w)",
"comment" : " ditto\n",
"line" : 119}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(short s)",
"comment" : " ditto\n",
"line" : 126}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(wchar c)",
"comment" : " ditto\n",
"line" : 128}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(uint w)",
"comment" : " ditto\n",
"line" : 135}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(int i)",
"comment" : " ditto\n",
"line" : 142}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong l)",
"comment" : " ditto\n",
"line" : 144}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(long l)",
"comment" : " ditto\n",
"line" : 151}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(float f)",
"comment" : " ditto\n",
"line" : 153}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(double f)",
"comment" : " ditto\n",
"line" : 160}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(real f)",
"comment" : " ditto\n",
"line" : 167}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) s)",
"comment" : " ditto\n",
"line" : 174}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(OutBuffer buf)",
"comment" : " ditto\n",
"line" : 183}
,
{
"name" : "fill0",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong nbytes)",
"comment" : "\n Append nbytes of 0 to the internal buffer.\n     \n",
"line" : 192}
,
{
"name" : "alignSize",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong alignsize)",
"comment" : "\n 0-fill to align on power of 2 boundary.\n     \n",
"line" : 203}
,
{
"name" : "align2",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Optimize common special case alignSize(2)\n     \n",
"line" : 223}
,
{
"name" : "align4",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Optimize common special case alignSize(4)\n     \n",
"line" : 233}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convert internal buffer to array of chars.\n     \n",
"line" : 245}
,
{
"name" : "vprintf",
"kind" : "function",
"protection" : "public",
"type" : "void(string format, void* args)",
"comment" : "\n Append output of C's vprintf() to internal buffer.\n     \n",
"line" : 255}
,
{
"name" : "printf",
"kind" : "function",
"protection" : "public",
"type" : "void(string format,...)",
"comment" : "\n Append output of C's printf() to internal buffer.\n     \n",
"line" : 305}
,
{
"name" : "spread",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong index, ulong nbytes)",
"comment" : "\n At offset index into buffer, create nbytes of space by shifting upwards\n all data past index.\n     \n",
"line" : 326}
]
}
]
}
,
{
"name" : "std.parallelism",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/parallelism.d",
"comment" : "\n$(D std._parallelism) implements high-level primitives for SMP _parallelism.\nThese include parallel foreach, parallel reduce, parallel eager map, pipelining\nand future\/promise _parallelism.  $(D std._parallelism) is recommended when the\nsame operation is to be executed in parallel on different data, or when a\nfunction is to be executed in a background thread and its result returned to a\nwell-defined main thread.  For communication between arbitrary threads, see\n$(D std.concurrency).\n\n$(D std._parallelism) is based on the concept of a $(D Task).  A $(D Task) is an\nobject that represents the fundamental unit of work in this library and may be\nexecuted in parallel with any other $(D Task).  Using $(D Task)\ndirectly allows programming with a future\/promise paradigm.  All other\nsupported _parallelism paradigms (parallel foreach, map, reduce, pipelining)\nrepresent an additional level of abstraction over $(D Task).  They\nautomatically create one or more $(D Task) objects, or closely related types\nthat are conceptually identical but not part of the public API.\n\nAfter creation, a $(D Task) may be executed in a new thread, or submitted\nto a $(D TaskPool) for execution.  A $(D TaskPool) encapsulates a task queue\nand its worker threads.  Its purpose is to efficiently map a large\nnumber of $(D Task)s onto a smaller number of threads.  A task queue is a\nFIFO queue of $(D Task) objects that have been submitted to the\n$(D TaskPool) and are awaiting execution.  A worker thread is a thread that\nis associated with exactly one task queue.  It executes the $(D Task) at the\nfront of its queue when the queue has work available, or sleeps when\nno work is available.  Each task queue is associated with zero or\nmore worker threads.  If the result of a $(D Task) is needed before execution\nby a worker thread has begun, the $(D Task) can be removed from the task queue\nand executed immediately in the thread where the result is needed.\n\nWarning:  Unless marked as $(D @trusted) or $(D @safe), artifacts in\n          this module allow implicit data sharing between threads and cannot\n          guarantee that client code is free from low level data races.\n\nSynopsis:\n\n---\nimport std.algorithm, std.parallelism, std.range;\n\nvoid main() {\n    \/\/ Parallel reduce can be combined with std.algorithm.map to interesting\n    \/\/ effect.  The following example (thanks to Russel Winder) calculates\n    \/\/ pi by quadrature using std.algorithm.map and TaskPool.reduce.\n    \/\/ getTerm is evaluated in parallel as needed by TaskPool.reduce.\n    \/\/\n    \/\/ Timings on an Athlon 64 X2 dual core machine:\n    \/\/\n    \/\/ TaskPool.reduce:       12.170 s\n    \/\/ std.algorithm.reduce:  24.065 s\n\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0 \/ n;\n\n    real getTerm(int i)\n    {\n        immutable x = ( i - 0.5 ) * delta;\n        return delta \/ ( 1.0 + x * x ) ;\n    }\n\n    immutable pi = 4.0 * taskPool.reduce!\"a + b\"(\n        std.algorithm.map!getTerm(iota(n))\n    );\n}\n---\n\nAuthor:  David Simcha\nCopyright:  Copyright (c) 2009-2011, David Simcha.\nLicense:    $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0)\n",
"members" : [
{
"name" : "atomicSetUbyte",
"kind" : "function",
"protection" : "private",
"type" : "void(ref ubyte stuff, ubyte newVal)",
"line" : 185}
,
{
"name" : "atomicReadUbyte",
"kind" : "function",
"protection" : "private",
"type" : "ubyte(ref ubyte val)",
"line" : 191}
,
{
"name" : "atomicCasUbyte",
"kind" : "function",
"protection" : "private",
"type" : "bool(ref ubyte stuff, ubyte testVal, ubyte newVal)",
"line" : 198}
,
{
"name" : "MapType(R,functions...)",
"kind" : "template",
"protection" : "public",
"line" : 204,
"members" : [
]
}
,
{
"name" : "ReduceType(alias fun,R,E)",
"kind" : "template",
"protection" : "public",
"line" : 217,
"members" : [
{
"name" : "ReduceType",
"kind" : "alias",
"type" : "typeof(binaryFun!(fun)(E.init,ElementType!(R).init))",
"line" : 219}
]
}
,
{
"name" : "noUnsharedAliasing(T)",
"kind" : "template",
"protection" : "public",
"line" : 222,
"members" : [
{
"name" : "noUnsharedAliasing",
"kind" : "variable",
"type" : "bool",
"line" : 224}
]
}
,
{
"name" : "isSafeTask(F)",
"kind" : "template",
"protection" : "public",
"line" : 230,
"members" : [
{
"name" : "isSafeTask",
"kind" : "variable",
"type" : "bool",
"line" : 232}
]
}
,
{
"name" : "isSafeReturn(T)",
"kind" : "template",
"protection" : "public",
"line" : 264,
"members" : [
]
}
,
{
"name" : "randAssignable(R)",
"kind" : "template",
"protection" : "public",
"line" : 280,
"members" : [
{
"name" : "randAssignable",
"kind" : "variable",
"line" : 282}
]
}
,
{
"name" : "addressOf(T)",
"kind" : "template",
"protection" : "public",
"line" : 286,
"members" : [
{
"name" : "addressOf",
"kind" : "function",
"type" : "pure nothrow T*(ref T val)",
"line" : 286}
]
}
,
{
"name" : "TaskStatus",
"kind" : "enum",
"protection" : "public",
"line" : 291,
"base" : "ubyte",
"members" : [
{
"name" : "notStarted",
"kind" : "enum member",
"protection" : "public",
"line" : 293}
,
{
"name" : "inProgress",
"kind" : "enum member",
"protection" : "public",
"line" : 294}
,
{
"name" : "done",
"kind" : "enum member",
"protection" : "public",
"line" : 295}
]
}
,
{
"name" : "AliasReturn(alias fun,T...)",
"kind" : "template",
"protection" : "public",
"line" : 298,
"members" : [
{
"name" : "AliasReturn",
"kind" : "alias",
"type" : "typeof(delegate ()\n{\nT args;\nreturn fun(args);\n}\n)",
"line" : 300}
]
}
,
{
"name" : "reduceAdjoin(functions...)",
"kind" : "template",
"protection" : "public",
"line" : 305,
"members" : [
]
}
,
{
"name" : "reduceFinish(functions...)",
"kind" : "template",
"protection" : "public",
"line" : 327,
"members" : [
]
}
,
{
"name" : "isAssignable(T)",
"kind" : "template",
"protection" : "public",
"line" : 349,
"members" : [
{
"name" : "isAssignable",
"kind" : "variable",
"line" : 355}
]
}
,
{
"name" : "isRoundRobin(R : RoundRobinBuffer!(C1,C2),C1,C2)",
"kind" : "template",
"protection" : "public",
"line" : 358,
"members" : [
{
"name" : "isRoundRobin",
"kind" : "variable",
"line" : 360}
]
}
,
{
"name" : "isRoundRobin(T)",
"kind" : "template",
"protection" : "public",
"line" : 363,
"members" : [
{
"name" : "isRoundRobin",
"kind" : "variable",
"line" : 365}
]
}
,
{
"name" : "AbstractTask",
"kind" : "struct",
"protection" : "private",
"line" : 380,
"members" : [
{
"name" : "prev",
"kind" : "variable",
"protection" : "public",
"type" : "AbstractTask*",
"line" : 381}
,
{
"name" : "next",
"kind" : "variable",
"protection" : "public",
"type" : "AbstractTask*",
"line" : 382}
,
{
"name" : "runTask",
"kind" : "variable",
"protection" : "public",
"type" : "void function(void*)",
"line" : 385}
,
{
"name" : "exception",
"kind" : "variable",
"protection" : "public",
"type" : "object.Throwable",
"line" : 387}
,
{
"name" : "taskStatus",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte",
"line" : 388}
,
{
"name" : "done",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 390}
,
{
"name" : "job",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 405}
]
}
,
{
"name" : "Task(alias fun,Args...)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n$(D Task) represents the fundamental unit of work.  A $(D Task) may be\nexecuted in parallel with any other $(D Task).  Using this struct directly\nallows future\/promise _parallelism.  In this paradigm, a function (or delegate\nor other callable) is executed in a thread other than the one it was called\nfrom.  The calling thread does not block while the function is being executed.\nA call to $(D workForce), $(D yieldForce), or $(D spinForce) is used to\nensure that the $(D Task) has finished executing and to obtain the return\nvalue, if any.  These functions and $(D done) also act as full memory barriers,\nmeaning that any memory writes made in the thread that executed the $(D Task)\nare guaranteed to be visible in the calling thread after one of these functions\nreturns.\n\nThe $(XREF parallelism, task) and $(XREF parallelism, scopedTask) functions can\nbe used to create an instance of this struct.  See $(D task) for usage examples.\n\nFunction results are returned from $(D yieldForce), $(D spinForce) and\n$(D workForce) by ref.  If $(D fun) returns by ref, the reference will point\nto the returned reference of $(D fun).  Otherwise it will point to a\nfield in this struct.\n\nCopying of this struct is disabled, since it would provide no useful semantics.\nIf you want to pass this struct around, you should do so by reference or\npointer.\n\nBugs:  Changes to $(D ref) and $(D out) arguments are not propagated to the\n       call site, only to $(D args) in this struct.\n",
"line" : 440,
"members" : [
{
"name" : "Task",
"kind" : "struct",
"protection" : "public",
"line" : 440,
"members" : [
{
"name" : "base",
"kind" : "variable",
"type" : "AbstractTask",
"line" : 441}
,
{
"name" : "basePtr",
"kind" : "function",
"type" : "AbstractTask*()",
"line" : 445}
,
{
"name" : "impl",
"kind" : "function",
"type" : "void(void* myTask)",
"line" : 450}
,
{
"name" : "pool",
"kind" : "variable",
"type" : "TaskPool",
"line" : 467}
,
{
"name" : "isScoped",
"kind" : "variable",
"type" : "bool",
"line" : 468}
,
{
"name" : "_args",
"kind" : "variable",
"type" : "Args",
"line" : 470}
,
{
"name" : "ReturnType",
"kind" : "alias",
"type" : "typeof(fun(_args))",
"comment" : "\n    The return type of the function called by this $(D Task).  This can be\n    $(D void).\n    \n",
"line" : 518}
,
{
"name" : "enforcePool",
"kind" : "function",
"type" : "void()",
"line" : 544}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Args args)",
"line" : 549}
,
{
"name" : "spinForce",
"kind" : "function",
"type" : "@trusted ReturnType()",
"comment" : "\n    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    busy spin until it's done, then return the return value.  If it threw\n    an exception, rethrow that exception.\n\n    This function should be used when you expect the result of the\n    $(D Task) to be available on a timescale shorter than that of an OS\n    context switch.\n     \n",
"line" : 587}
,
{
"name" : "yieldForce",
"kind" : "function",
"type" : "@trusted ReturnType()",
"comment" : "\n    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    wait on a condition variable.  If it threw an exception, rethrow that\n    exception.\n\n    This function should be used for expensive functions, as waiting on a\n    condition variable introduces latency, but avoids wasted CPU cycles.\n     \n",
"line" : 615}
,
{
"name" : "workForce",
"kind" : "function",
"type" : "@trusted ReturnType()",
"comment" : "\n    If this $(D Task) was not started yet, execute it in the current\n    thread.  If it is finished, return its result.  If it is in progress,\n    execute any other $(D Task) from the $(D TaskPool) instance that\n    this $(D Task) was submitted to until this one\n    is finished.  If it threw an exception, rethrow that exception.\n    If no other tasks are available or this $(D Task) was executed using\n    $(D executeInNewThread), wait on a condition variable.\n     \n",
"line" : 660}
,
{
"name" : "done",
"kind" : "function",
"type" : "@trusted bool()",
"comment" : "\n    Returns $(D true) if the $(D Task) is finished executing.\n\n    Throws:  Rethrows any exception thrown during the execution of the\n             $(D Task).\n    \n",
"line" : 731}
,
{
"name" : "executeInNewThread",
"kind" : "function",
"type" : "@trusted void()",
"comment" : "\n    Create a new thread for executing this $(D Task), execute it in the\n    newly created thread, then terminate the thread.  This can be used for\n    future\/promise parallelism.  An explicit priority may be given\n    to the $(D Task).  If one is provided, its value is forwarded to\n    $(D core.thread.Thread.priority). See $(XREF parallelism, task) for\n    usage example.\n    \n",
"line" : 745}
,
{
"name" : "executeInNewThread",
"kind" : "function",
"type" : "@trusted void(int priority)",
"comment" : " Ditto\n",
"line" : 751}
]
}
]
}
,
{
"name" : "run(F,Args...)",
"kind" : "template",
"protection" : "public",
"line" : 772,
"members" : [
{
"name" : "run",
"kind" : "function",
"type" : "ReturnType!(F)(F fpOrDelegate, ref Args args)",
"line" : 772}
]
}
,
{
"name" : "task(alias fun,Args...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nCreates a $(D Task) on the GC heap that calls an alias.  This may be executed\nvia $(D Task.executeInNewThread) or by submitting to a\n$(XREF parallelism, TaskPool).  A globally accessible instance of\n$(D TaskPool) is provided by $(XREF parallelism, taskPool).\n\nReturns:  A pointer to the $(D Task).\n\nExamples:\n---\n\/\/ Read two files into memory at the same time.\nimport std.file;\n\nvoid main()\n{\n    \/\/ Create and execute a Task for reading foo.txt.\n    auto file1Task = task!read(\"foo.txt\");\n    file1Task.executeInNewThread();\n\n    \/\/ Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    \/\/ Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce();\n}\n---\n\n---\n\/\/ Sorts an array using a parallel quick sort algorithm.  The first partition\n\/\/ is done serially.  Both recursion branches are then executed in\n\/\/ parallel.\n\/\/\n\/\/ Timings for sorting an array of 1,000,000 doubles on an Athlon 64 X2\n\/\/ dual core machine:\n\/\/\n\/\/ This implementation:               176 milliseconds.\n\/\/ Equivalent serial implementation:  280 milliseconds\nvoid parallelSort(T)(T[] data)\n{\n    \/\/ Sort small subarrays serially.\n    if(data.length < 100)\n    {\n         std.algorithm.sort(data);\n         return;\n    }\n\n    \/\/ Partition the array.\n    swap(data[$ \/ 2], data[$ - 1]);\n    auto pivot = data[$ - 1];\n    bool lessThanPivot(T elem) { return elem < pivot; }\n\n    auto greaterEqual = partition!lessThanPivot(data[0..$ - 1]);\n    swap(data[$ - greaterEqual.length - 1], data[$ - 1]);\n\n    auto less = data[0..$ - greaterEqual.length - 1];\n    greaterEqual = data[$ - greaterEqual.length..$];\n\n    \/\/ Execute both recursion branches in parallel.\n    auto recurseTask = task!(parallelSort)(greaterEqual);\n    taskPool.put(recurseTask);\n    parallelSort(less);\n    recurseTask.yieldForce();\n}\n---\n",
"line" : 842,
"members" : [
{
"name" : "task",
"kind" : "function",
"type" : "(Args args)",
"comment" : "\nCreates a $(D Task) on the GC heap that calls an alias.  This may be executed\nvia $(D Task.executeInNewThread) or by submitting to a\n$(XREF parallelism, TaskPool).  A globally accessible instance of\n$(D TaskPool) is provided by $(XREF parallelism, taskPool).\n\nReturns:  A pointer to the $(D Task).\n\nExamples:\n---\n\/\/ Read two files into memory at the same time.\nimport std.file;\n\nvoid main()\n{\n    \/\/ Create and execute a Task for reading foo.txt.\n    auto file1Task = task!read(\"foo.txt\");\n    file1Task.executeInNewThread();\n\n    \/\/ Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    \/\/ Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce();\n}\n---\n\n---\n\/\/ Sorts an array using a parallel quick sort algorithm.  The first partition\n\/\/ is done serially.  Both recursion branches are then executed in\n\/\/ parallel.\n\/\/\n\/\/ Timings for sorting an array of 1,000,000 doubles on an Athlon 64 X2\n\/\/ dual core machine:\n\/\/\n\/\/ This implementation:               176 milliseconds.\n\/\/ Equivalent serial implementation:  280 milliseconds\nvoid parallelSort(T)(T[] data)\n{\n    \/\/ Sort small subarrays serially.\n    if(data.length < 100)\n    {\n         std.algorithm.sort(data);\n         return;\n    }\n\n    \/\/ Partition the array.\n    swap(data[$ \/ 2], data[$ - 1]);\n    auto pivot = data[$ - 1];\n    bool lessThanPivot(T elem) { return elem < pivot; }\n\n    auto greaterEqual = partition!lessThanPivot(data[0..$ - 1]);\n    swap(data[$ - greaterEqual.length - 1], data[$ - 1]);\n\n    auto less = data[0..$ - greaterEqual.length - 1];\n    greaterEqual = data[$ - greaterEqual.length..$];\n\n    \/\/ Execute both recursion branches in parallel.\n    auto recurseTask = task!(parallelSort)(greaterEqual);\n    taskPool.put(recurseTask);\n    parallelSort(less);\n    recurseTask.yieldForce();\n}\n---\n",
"line" : 842}
]
}
,
{
"name" : "task(F,Args...) if (is(typeof(delegateOrFp(args))) && !isSafeTask!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "\nCreates a $(D Task) on the GC heap that calls a function pointer, delegate, or\nclass\/struct with overloaded opCall.\n\nExamples:\n---\n\/\/ Read two files in at the same time again, but this time use a function\n\/\/ pointer instead of an alias to represent std.file.read.\nimport std.file;\n\nvoid main()\n{\n    \/\/ Create and execute a Task for reading foo.txt.\n    auto file1Task = task(&read, \"foo.txt\");\n    file1Task.executeInNewThread();\n\n    \/\/ Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    \/\/ Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce();\n}\n---\n\nNotes: This function takes a non-scope delegate, meaning it can be\n       used with closures.  If you can't allocate a closure due to objects\n       on the stack that have scoped destruction, see $(D scopedTask), which\n       takes a scope delegate.\n \n",
"line" : 876,
"members" : [
{
"name" : "task",
"kind" : "function",
"type" : "(F delegateOrFp, Args args)",
"comment" : "\nCreates a $(D Task) on the GC heap that calls a function pointer, delegate, or\nclass\/struct with overloaded opCall.\n\nExamples:\n---\n\/\/ Read two files in at the same time again, but this time use a function\n\/\/ pointer instead of an alias to represent std.file.read.\nimport std.file;\n\nvoid main()\n{\n    \/\/ Create and execute a Task for reading foo.txt.\n    auto file1Task = task(&read, \"foo.txt\");\n    file1Task.executeInNewThread();\n\n    \/\/ Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    \/\/ Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce();\n}\n---\n\nNotes: This function takes a non-scope delegate, meaning it can be\n       used with closures.  If you can't allocate a closure due to objects\n       on the stack that have scoped destruction, see $(D scopedTask), which\n       takes a scope delegate.\n \n",
"line" : 876}
]
}
,
{
"name" : "task(F,Args...) if (is(typeof(fun(args))) && isSafeTask!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "\nVersion of $(D task) usable from $(D @safe) code.  Usage mechanics are\nidentical to the non-@safe case, but safety introduces the some restrictions.\n\n1.  $(D fun) must be @safe or @trusted.\n\n2.  $(D F) must not have any unshared aliasing as defined by\n    $(XREF traits, hasUnsharedAliasing).  This means it\n    may not be an unshared delegate or a non-shared class or struct\n    with overloaded $(D opCall).  This also precludes accepting template\n    alias parameters.\n\n3.  $(D Args) must not have unshared aliasing.\n\n4.  $(D fun) must not return by reference.\n\n5.  The return type must not have unshared aliasing unless $(D fun) is\n    $(D pure) or the $(D Task) is executed via $(D executeInNewThread) instead\n    of using a $(D TaskPool).\n\n",
"line" : 903,
"members" : [
{
"name" : "task",
"kind" : "function",
"type" : "@trusted (F fun, Args args)",
"comment" : "\nVersion of $(D task) usable from $(D @safe) code.  Usage mechanics are\nidentical to the non-@safe case, but safety introduces the some restrictions.\n\n1.  $(D fun) must be @safe or @trusted.\n\n2.  $(D F) must not have any unshared aliasing as defined by\n    $(XREF traits, hasUnsharedAliasing).  This means it\n    may not be an unshared delegate or a non-shared class or struct\n    with overloaded $(D opCall).  This also precludes accepting template\n    alias parameters.\n\n3.  $(D Args) must not have unshared aliasing.\n\n4.  $(D fun) must not return by reference.\n\n5.  The return type must not have unshared aliasing unless $(D fun) is\n    $(D pure) or the $(D Task) is executed via $(D executeInNewThread) instead\n    of using a $(D TaskPool).\n\n",
"line" : 903}
]
}
,
{
"name" : "scopedTask(alias fun,Args...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nThese functions allow the creation of $(D Task) objects on the stack rather\nthan the GC heap.  The lifetime of a $(D Task) created by $(D scopedTask)\ncannot exceed the lifetime of the scope it was created in.\n\n$(D scopedTask) might be preferred over $(D task):\n\n1.  When a $(D Task) that calls a delegate is being created and a closure\n    cannot be allocated due to objects on the stack that have scoped\n    destruction.  The delegate overload of $(D scopedTask) takes a $(D scope)\n    delegate.\n\n2.  As a micro-optimization, to avoid the heap allocation associated with\n    $(D task) or with the creation of a closure.\n\nUsage is otherwise identical to $(D task).\n\nNotes:  $(D Task) objects created using $(D scopedTask) will automatically\ncall $(D Task.yieldForce) in their destructor if necessary to ensure\nthe $(D Task) is complete before the stack frame they reside on is destroyed.\n",
"line" : 930,
"members" : [
{
"name" : "scopedTask",
"kind" : "function",
"type" : "(Args args)",
"comment" : "\nThese functions allow the creation of $(D Task) objects on the stack rather\nthan the GC heap.  The lifetime of a $(D Task) created by $(D scopedTask)\ncannot exceed the lifetime of the scope it was created in.\n\n$(D scopedTask) might be preferred over $(D task):\n\n1.  When a $(D Task) that calls a delegate is being created and a closure\n    cannot be allocated due to objects on the stack that have scoped\n    destruction.  The delegate overload of $(D scopedTask) takes a $(D scope)\n    delegate.\n\n2.  As a micro-optimization, to avoid the heap allocation associated with\n    $(D task) or with the creation of a closure.\n\nUsage is otherwise identical to $(D task).\n\nNotes:  $(D Task) objects created using $(D scopedTask) will automatically\ncall $(D Task.yieldForce) in their destructor if necessary to ensure\nthe $(D Task) is complete before the stack frame they reside on is destroyed.\n",
"line" : 930}
]
}
,
{
"name" : "scopedTask(F,Args...) if (is(typeof(delegateOrFp(args))) && !isSafeTask!(F))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 938,
"members" : [
{
"name" : "scopedTask",
"kind" : "function",
"type" : "(scope F delegateOrFp, Args args)",
"comment" : " Ditto\n",
"line" : 938}
]
}
,
{
"name" : "scopedTask(F,Args...) if (is(typeof(fun(args))) && isSafeTask!(F))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 947,
"members" : [
{
"name" : "scopedTask",
"kind" : "function",
"type" : "@trusted (F fun, Args args)",
"comment" : " Ditto\n",
"line" : 947}
]
}
,
{
"name" : "totalCPUs",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(uint)",
"comment" : "\nThe total number of CPU cores available on the current machine, as reported by\nthe operating system.\n",
"line" : 959}
,
{
"name" : "ParallelismThread",
"kind" : "class",
"protection" : "private",
"line" : 971,
"base" : "Thread",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ParallelismThread(void delegate() dg)",
"line" : 973}
,
{
"name" : "pool",
"kind" : "variable",
"protection" : "public",
"type" : "std.parallelism.TaskPool",
"line" : 978}
]
}
,
{
"name" : "TaskPool",
"kind" : "class",
"protection" : "public",
"comment" : "\nThis class encapsulates a task queue and a set of worker threads.  Its purpose\nis to efficiently map a large number of $(D Task)s onto a smaller number of\nthreads.  A task queue is a FIFO queue of $(D Task) objects that have been\nsubmitted to the $(D TaskPool) and are awaiting execution.  A worker thread is a\nthread that executes the $(D Task) at the front of the queue when one is\navailable and sleeps when the queue is empty.\n\nThis class should usually be used via the global instantiation\navailable via the $(XREF parallelism, taskPool) property.\nOccasionally it is useful to explicitly instantiate a $(D TaskPool):\n\n1.  When you want $(D TaskPool) instances with multiple priorities, for example\n    a low priority pool and a high priority pool.\n\n2.  When the threads in the global task pool are waiting on a synchronization\n    primitive (for example a mutex), and you want to parallelize the code that\n    needs to run before these threads can be resumed.\n \n",
"line" : 1017,
"base" : "Object",
"members" : [
{
"name" : "isSingleTask",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 1023}
,
{
"name" : "pool",
"kind" : "variable",
"protection" : "private",
"type" : "ParallelismThread[]",
"line" : 1025}
,
{
"name" : "singleTaskThread",
"kind" : "variable",
"protection" : "private",
"type" : "core.thread.Thread",
"line" : 1026}
,
{
"name" : "head",
"kind" : "variable",
"protection" : "private",
"type" : "AbstractTask*",
"line" : 1028}
,
{
"name" : "tail",
"kind" : "variable",
"protection" : "private",
"type" : "AbstractTask*",
"line" : 1029}
,
{
"name" : "status",
"kind" : "variable",
"protection" : "private",
"type" : "PoolState",
"line" : 1030}
,
{
"name" : "workerCondition",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.condition.Condition",
"line" : 1031}
,
{
"name" : "waiterCondition",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.condition.Condition",
"line" : 1032}
,
{
"name" : "queueMutex",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.mutex.Mutex",
"line" : 1033}
,
{
"name" : "waiterMutex",
"kind" : "variable",
"protection" : "private",
"type" : "core.sync.mutex.Mutex",
"line" : 1034}
,
{
"name" : "nextInstanceIndex",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 1037}
,
{
"name" : "threadIndex",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 1040}
,
{
"name" : "instanceStartIndex",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(ulong)",
"line" : 1043}
,
{
"name" : "nextThreadIndex",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 1046}
,
{
"name" : "PoolState",
"kind" : "enum",
"protection" : "public",
"line" : 1048,
"base" : "ubyte",
"members" : [
{
"name" : "running",
"kind" : "enum member",
"protection" : "public",
"line" : 1050}
,
{
"name" : "finishing",
"kind" : "enum member",
"protection" : "public",
"line" : 1051}
,
{
"name" : "stopNow",
"kind" : "enum member",
"protection" : "public",
"line" : 1052}
]
}
,
{
"name" : "doJob",
"kind" : "function",
"protection" : "private",
"type" : "void(AbstractTask* job)",
"line" : 1055}
,
{
"name" : "doSingleTask",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1084}
,
{
"name" : "workLoop",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1096}
,
{
"name" : "pop",
"kind" : "function",
"protection" : "private",
"type" : "AbstractTask*()",
"line" : 1125}
,
{
"name" : "popNoSync",
"kind" : "function",
"protection" : "private",
"type" : "AbstractTask*()",
"line" : 1138}
,
{
"name" : "abstractPut",
"kind" : "function",
"protection" : "private",
"type" : "void(AbstractTask* task)",
"line" : 1172}
,
{
"name" : "abstractPutNoSync",
"kind" : "function",
"protection" : "private",
"type" : "void(AbstractTask* task)",
"line" : 1179}
,
{
"name" : "abstractPutGroupNoSync",
"kind" : "function",
"protection" : "private",
"type" : "void(AbstractTask* h, AbstractTask* t)",
"line" : 1211}
,
{
"name" : "tryDeleteExecute",
"kind" : "function",
"protection" : "private",
"type" : "void(AbstractTask* toExecute)",
"line" : 1228}
,
{
"name" : "deleteItem",
"kind" : "function",
"protection" : "private",
"type" : "bool(AbstractTask* item)",
"line" : 1249}
,
{
"name" : "deleteItemNoSync",
"kind" : "function",
"protection" : "private",
"type" : "bool(AbstractTask* item)",
"line" : 1256}
,
{
"name" : "queueLock",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1296}
,
{
"name" : "queueUnlock",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1302}
,
{
"name" : "waiterLock",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1308}
,
{
"name" : "waiterUnlock",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1313}
,
{
"name" : "wait",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1318}
,
{
"name" : "notify",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1323}
,
{
"name" : "notifyAll",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1328}
,
{
"name" : "waitUntilCompletion",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1333}
,
{
"name" : "notifyWaiters",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 1345}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "TaskPool(AbstractTask* task, int priority = 2147483647)",
"line" : 1353}
,
{
"name" : "defaultWorkUnitSize",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe ulong(ulong rangeLen)",
"line" : 1376}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "@trusted TaskPool()",
"comment" : "\nDefault constructor that initializes a $(D TaskPool) with\n$(D totalCPUs) - 1 worker threads.  The minus 1 is included because the\nmain thread will also be available to do work.\n\nNote:  On single-core machines, the primitives provided by $(D TaskPool)\n       operate transparently in single-threaded mode.\n \n",
"line" : 1397}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "@trusted TaskPool(ulong nWorkers)",
"comment" : "\n    Allows for custom number of worker threads.\n    \n",
"line" : 1405}
,
{
"name" : "parallel(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Implements a parallel foreach loop over a range.  This works by implicitly\n    creating and submitting one $(D Task) to the $(D TaskPool) for each worker\n    thread.  A work unit is a set of consecutive elements of $(D range) to\n    be processed by a worker thread between communication with any other\n    thread.  The number of elements processed per work unit is controlled by the\n    $(D workUnitSize) parameter.  Smaller work units provide better load\n    balancing, but larger work units avoid the overhead of communicating\n    with other threads frequently to fetch the next work unit.  Large work\n    units also avoid false sharing in cases where the range is being modified.\n    The less time a single iteration of the loop takes, the larger\n    $(D workUnitSize) should be.  For very expensive loop bodies,\n    $(D workUnitSize) should  be 1.  An overload that chooses a default work\n    unit size is also available.\n\n    Examples:\n    ---\n    \/\/ Find the logarithm of every number from 1 to\n    \/\/ 10_000_000 in parallel.\n    auto logs = new double[10_000_000];\n\n    \/\/ Parallel foreach works with or without an index\n    \/\/ variable.  It can be iterate by ref if range.front\n    \/\/ returns by ref.\n\n    \/\/ Iterate over logs using work units of size 100.\n    foreach(i, ref elem; taskPool.parallel(logs, 100))\n    {\n        elem = log(i + 1.0);\n    }\n\n    \/\/ Same thing, but use the default work unit size.\n    \/\/\n    \/\/ Timings on an Athlon 64 X2 dual core machine:\n    \/\/\n    \/\/ Parallel foreach:  388 milliseconds\n    \/\/ Regular foreach:   619 milliseconds\n    foreach(i, ref elem; taskPool.parallel(logs))\n    {\n        elem = log(i + 1.0);\n    }\n    ---\n\n    Notes:\n\n    The memory usage of this implementation is guaranteed to be constant\n    in $(D range.length).\n\n    Breaking from a parallel foreach loop via a break, labeled break,\n    labeled continue, return or goto statement throws a\n    $(D ParallelForeachError).\n\n    In the case of non-random access ranges, parallel foreach buffers lazily\n    to an array of size $(D workUnitSize) before executing the parallel portion\n    of the loop.  The exception is that, if a parallel foreach is executed\n    over a range returned by $(D asyncBuf) or $(D map), the copying is elided\n    and the buffers are simply swapped.  In this case $(D workUnitSize) is\n    ignored and the work unit size is set to the  buffer size of $(D range).\n\n    A memory barrier is guaranteed to be executed on exit from the loop,\n    so that results produced by all threads are visible in the calling thread.\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside a parallel foreach loop,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown by any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n    \n",
"line" : 1503,
"members" : [
{
"name" : "parallel",
"kind" : "function",
"type" : "ParallelForeach!(R)(R range, size_t workUnitSize)",
"comment" : "\n    Implements a parallel foreach loop over a range.  This works by implicitly\n    creating and submitting one $(D Task) to the $(D TaskPool) for each worker\n    thread.  A work unit is a set of consecutive elements of $(D range) to\n    be processed by a worker thread between communication with any other\n    thread.  The number of elements processed per work unit is controlled by the\n    $(D workUnitSize) parameter.  Smaller work units provide better load\n    balancing, but larger work units avoid the overhead of communicating\n    with other threads frequently to fetch the next work unit.  Large work\n    units also avoid false sharing in cases where the range is being modified.\n    The less time a single iteration of the loop takes, the larger\n    $(D workUnitSize) should be.  For very expensive loop bodies,\n    $(D workUnitSize) should  be 1.  An overload that chooses a default work\n    unit size is also available.\n\n    Examples:\n    ---\n    \/\/ Find the logarithm of every number from 1 to\n    \/\/ 10_000_000 in parallel.\n    auto logs = new double[10_000_000];\n\n    \/\/ Parallel foreach works with or without an index\n    \/\/ variable.  It can be iterate by ref if range.front\n    \/\/ returns by ref.\n\n    \/\/ Iterate over logs using work units of size 100.\n    foreach(i, ref elem; taskPool.parallel(logs, 100))\n    {\n        elem = log(i + 1.0);\n    }\n\n    \/\/ Same thing, but use the default work unit size.\n    \/\/\n    \/\/ Timings on an Athlon 64 X2 dual core machine:\n    \/\/\n    \/\/ Parallel foreach:  388 milliseconds\n    \/\/ Regular foreach:   619 milliseconds\n    foreach(i, ref elem; taskPool.parallel(logs))\n    {\n        elem = log(i + 1.0);\n    }\n    ---\n\n    Notes:\n\n    The memory usage of this implementation is guaranteed to be constant\n    in $(D range.length).\n\n    Breaking from a parallel foreach loop via a break, labeled break,\n    labeled continue, return or goto statement throws a\n    $(D ParallelForeachError).\n\n    In the case of non-random access ranges, parallel foreach buffers lazily\n    to an array of size $(D workUnitSize) before executing the parallel portion\n    of the loop.  The exception is that, if a parallel foreach is executed\n    over a range returned by $(D asyncBuf) or $(D map), the copying is elided\n    and the buffers are simply swapped.  In this case $(D workUnitSize) is\n    ignored and the work unit size is set to the  buffer size of $(D range).\n\n    A memory barrier is guaranteed to be executed on exit from the loop,\n    so that results produced by all threads are visible in the calling thread.\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside a parallel foreach loop,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown by any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n    \n",
"line" : 1503}
]
}
,
{
"name" : "parallel(R)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1512,
"members" : [
{
"name" : "parallel",
"kind" : "function",
"type" : "ParallelForeach!(R)(R range)",
"comment" : " Ditto\n",
"line" : 1512}
]
}
,
{
"name" : "amap(functions...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Eager parallel map.  The eagerness of this function means it has less\n    overhead than the lazily evaluated $(D TaskPool.map) and should be\n    preferred where the memory requirements of eagerness are acceptable.\n    $(D functions) are the functions to be evaluated, passed as template alias\n    parameters in a style similar to $(XREF algorithm, map).  The first\n    argument must be a random access range.\n\n    ---\n    auto numbers = iota(100_000_000.0);\n\n    \/\/ Find the square roots of numbers.\n    \/\/\n    \/\/ Timings on an Athlon 64 X2 dual core machine:\n    \/\/\n    \/\/ Parallel eager map:                   0.802 s\n    \/\/ Equivalent serial implementation:     1.768 s\n    auto squareRoots = taskPool.amap!sqrt(numbers);\n    ---\n\n    Immediately after the range argument, an optional work unit size argument\n    may be provided.  Work units as used by $(D amap) are identical to those\n    defined for parallel foreach.  If no work unit size is provided, the\n    default work unit size is used.\n\n    ---\n    \/\/ Same thing, but make work unit size 100.\n    auto squareRoots = taskPool.amap!sqrt(numbers, 100);\n    ---\n\n    An output range for returning the results may be provided as the last\n    argument.  If one is not provided, an array of the proper type will be\n    allocated on the garbage collected heap.  If one is provided, it must be a\n    random access range with assignable elements, must have reference\n    semantics with respect to assignment to its elements, and must have the\n    same length as the input range.  Writing to adjacent elements from\n    different threads must be safe.\n\n    ---\n    \/\/ Same thing, but explicitly allocate an array\n    \/\/ to return the results in.  The element type\n    \/\/ of the array may be either the exact type\n    \/\/ returned by functions or an implicit conversion\n    \/\/ target.\n    auto squareRoots = new float[numbers.length];\n    taskPool.amap!sqrt(numbers, squareRoots);\n\n    \/\/ Multiple functions, explicit output range, and\n    \/\/ explicit work unit size.\n    auto results = new Tuple!(float, real)[numbers.length];\n    taskPool.amap!(sqrt, log)(numbers, 100, results);\n    ---\n\n    Note:\n\n    A memory barrier is guaranteed to be executed after all results are written\n    but before returning so that results produced by all threads are visible\n    in the calling thread.\n\n    Tips:\n\n    To perform the mapping operation in place, provide the same range for the\n    input and output range.\n\n    To parallelize the copying of a range with expensive to evaluate elements\n    to an array, pass an identity function (a function that just returns\n    whatever argument is provided to it) to $(D amap).\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside the map functions,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All currently executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown from any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n     \n",
"line" : 1606,
"members" : [
{
"name" : "amap(Args...) if (isRandomAccessRange!(Args[0]))",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 1609,
"members" : [
{
"name" : "amap",
"kind" : "function",
"type" : "(Args args)",
"comment" : "\n",
"line" : 1609}
]
}
]
}
,
{
"name" : "map(functions...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    A semi-lazy parallel map that can be used for pipelining.  The map\n    functions are evaluated for the first $(D bufSize) elements and stored in a\n    buffer and made available to $(D popFront).  Meanwhile, in the\n    background a second buffer of the same size is filled.  When the first\n    buffer is exhausted, it is swapped with the second buffer and filled while\n    the values from what was originally the second buffer are read.  This\n    implementation allows for elements to be written to the buffer without\n    the need for atomic operations or synchronization for each write, and\n    enables the mapping function to be evaluated efficiently in parallel.\n\n    $(D map) has more overhead than the simpler procedure used by $(D amap)\n    but avoids the need to keep all results in memory simultaneously and works\n    with non-random access ranges.\n\n    Params:\n\n    source = The input range to be mapped.  If $(D source) is not random\n    access it will be lazily buffered to an array of size $(D bufSize) before\n    the map function is evaluated.  (For an exception to this rule, see Notes.)\n\n    bufSize = The size of the buffer to store the evaluated elements.\n\n    workUnitSize = The number of elements to evaluate in a single\n    $(D Task).  Must be less than or equal to $(D bufSize), and\n    should be a fraction of $(D bufSize) such that all worker threads can be\n    used.  If the default of size_t.max is used, workUnitSize will be set to\n    the pool-wide default.\n\n    Returns:  An input range representing the results of the map.  This range\n              has a length iff $(D source) has a length.\n\n    Notes:\n\n    If a range returned by $(D map) or $(D asyncBuf) is used as an input to\n    $(D map), then as an optimization the copying from the output buffer\n    of the first range to the input buffer of the second range is elided, even\n    though the ranges returned by $(D map) and $(D asyncBuf) are non-random\n    access ranges.  This means that the $(D bufSize) parameter passed to the\n    current call to $(D map) will be ignored and the size of the buffer\n    will be the buffer size of $(D source).\n\n    Examples:\n    ---\n    \/\/ Pipeline reading a file, converting each line to a number, taking the\n    \/\/ logarithms of the numbers, and performing the additions necessary to\n    \/\/ find the sum of the logarithms.\n\n    auto lineRange = File(\"numberList.txt\").byLine();\n    auto dupedLines = std.algorithm.map!\"a.idup\"(lineRange);\n    auto nums = taskPool.map!(to!double)(dupedLines);\n    auto logs = taskPool.map!log10(nums);\n\n    double sum = 0;\n    foreach(elem; logs)\n    {\n        sum += elem;\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source)\n    or computing the map function are re-thrown on a call to $(D popFront) or,\n    if thrown during construction, are simply allowed to propagate to the\n    caller.  In the case of exceptions thrown while computing the map function,\n    the exceptions are chained as in $(D TaskPool.amap).\n    \n",
"line" : 1784,
"members" : [
{
"name" : "map(S) if (isInputRange!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 1788,
"members" : [
{
"name" : "map",
"kind" : "function",
"type" : "(S source, size_t bufSize = 100, size_t workUnitSize = size_t.max)",
"comment" : "\n",
"line" : 1788}
]
}
]
}
,
{
"name" : "asyncBuf(S) if (isInputRange!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Given a $(D source) range that is expensive to iterate over, returns an\n    input range that asynchronously buffers the contents of\n    $(D source) into a buffer of $(D bufSize) elements in a worker thread,\n    while making prevously buffered elements from a second buffer, also of size\n    $(D bufSize), available via the range interface of the returned\n    object.  The returned range has a length iff $(D hasLength!(S)).\n    $(D asyncBuf) is useful, for example, when performing expensive operations\n    on the elements of ranges that represent data on a disk or network.\n\n    Examples:\n    ---\n    import std.conv, std.stdio;\n\n    void main()\n    {\n        \/\/ Fetch lines of a file in a background thread\n        \/\/ while processing prevously fetched lines,\n        \/\/ dealing with byLine's buffer recycling by\n        \/\/ eagerly duplicating every line.\n        auto lines = File(\"foo.txt\").byLine();\n        auto duped = std.algorithm.map!\"a.idup\"(lines);\n\n        \/\/ Fetch more lines in the background while we\n        \/\/ process the lines already read into memory\n        \/\/ into a matrix of doubles.\n        double[][] matrix;\n        auto asyncReader = taskPool.asyncBuf(duped);\n\n        foreach(line; asyncReader)\n        {\n            auto ls = line.split(\"\\t\");\n            matrix ~= to!(double[])(ls);\n        }\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source) are re-thrown on a\n    call to $(D popFront) or, if thrown during construction, simply\n    allowed to propagate to the caller.\n    \n",
"line" : 2105,
"members" : [
{
"name" : "asyncBuf",
"kind" : "function",
"type" : "(S source, size_t bufSize = 100)",
"comment" : "\n    Given a $(D source) range that is expensive to iterate over, returns an\n    input range that asynchronously buffers the contents of\n    $(D source) into a buffer of $(D bufSize) elements in a worker thread,\n    while making prevously buffered elements from a second buffer, also of size\n    $(D bufSize), available via the range interface of the returned\n    object.  The returned range has a length iff $(D hasLength!(S)).\n    $(D asyncBuf) is useful, for example, when performing expensive operations\n    on the elements of ranges that represent data on a disk or network.\n\n    Examples:\n    ---\n    import std.conv, std.stdio;\n\n    void main()\n    {\n        \/\/ Fetch lines of a file in a background thread\n        \/\/ while processing prevously fetched lines,\n        \/\/ dealing with byLine's buffer recycling by\n        \/\/ eagerly duplicating every line.\n        auto lines = File(\"foo.txt\").byLine();\n        auto duped = std.algorithm.map!\"a.idup\"(lines);\n\n        \/\/ Fetch more lines in the background while we\n        \/\/ process the lines already read into memory\n        \/\/ into a matrix of doubles.\n        double[][] matrix;\n        auto asyncReader = taskPool.asyncBuf(duped);\n\n        foreach(line; asyncReader)\n        {\n            auto ls = line.split(\"\\t\");\n            matrix ~= to!(double[])(ls);\n        }\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source) are re-thrown on a\n    call to $(D popFront) or, if thrown during construction, simply\n    allowed to propagate to the caller.\n    \n",
"line" : 2105}
]
}
,
{
"name" : "asyncBuf(C1,C2) if (is(typeof(C2.init()) : bool) && ParameterTypeTuple!(C1).length == 1 && ParameterTypeTuple!(C2).length == 0 && isArray!(ParameterTypeTuple!(C1)[0]))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Given a callable object $(D next) that writes to a user-provided buffer and\n    a second callable object $(D empty) that determines whether more data is\n    available to write via $(D next), returns an input range that\n    asynchronously calls $(D next) with a set of size $(D nBuffers) of buffers\n    and makes the results available in the order they were obtained via the\n    input range interface of the returned object.  Similarly to the\n    input range overload of $(D asyncBuf), the first half of the buffers\n    are made available via the range interface while the second half are\n    filled and vice-versa.\n\n    Params:\n\n    next = A callable object that takes a single argument that must be an array\n           with mutable elements.  When called, $(D next) writes data to\n           the array provided by the caller.\n\n    empty = A callable object that takes no arguments and returns a type\n            implicitly convertible to $(D bool).  This is used to signify\n            that no more data is available to be obtained by calling $(D next).\n\n    initialBufSize = The initial size of each buffer.  If $(D next) takes its\n                     array by reference, it may resize the buffers.\n\n    nBuffers = The number of buffers to cycle through when calling $(D next).\n\n    Examples:\n    ---\n    \/\/ Fetch lines of a file in a background thread while processing prevously\n    \/\/ fetched lines, without duplicating any lines.\n    auto file = File(\"foo.txt\");\n\n    void next(ref char[] buf)\n    {\n        file.readln(buf);\n    }\n\n    \/\/ Fetch more lines in the background while we process the lines already\n    \/\/ read into memory into a matrix of doubles.\n    double[][] matrix;\n    auto asyncReader = taskPool.asyncBuf(&next, &file.eof);\n\n    foreach(line; asyncReader)\n    {\n        auto ls = line.split(\"\\t\");\n        matrix ~= to!(double[])(ls);\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D range) are re-thrown on a\n    call to $(D popFront).\n\n    Warning:\n\n    Using the range returned by this function in a parallel foreach loop\n    will not work because buffers may be overwritten while the task that\n    processes them is in queue.  This is checked for at compile time\n    and will result in a static assertion failure.\n    \n",
"line" : 2304,
"members" : [
{
"name" : "asyncBuf",
"kind" : "function",
"type" : "(C1 next, C2 empty, size_t initialBufSize = 0, size_t nBuffers = 100)",
"comment" : "\n    Given a callable object $(D next) that writes to a user-provided buffer and\n    a second callable object $(D empty) that determines whether more data is\n    available to write via $(D next), returns an input range that\n    asynchronously calls $(D next) with a set of size $(D nBuffers) of buffers\n    and makes the results available in the order they were obtained via the\n    input range interface of the returned object.  Similarly to the\n    input range overload of $(D asyncBuf), the first half of the buffers\n    are made available via the range interface while the second half are\n    filled and vice-versa.\n\n    Params:\n\n    next = A callable object that takes a single argument that must be an array\n           with mutable elements.  When called, $(D next) writes data to\n           the array provided by the caller.\n\n    empty = A callable object that takes no arguments and returns a type\n            implicitly convertible to $(D bool).  This is used to signify\n            that no more data is available to be obtained by calling $(D next).\n\n    initialBufSize = The initial size of each buffer.  If $(D next) takes its\n                     array by reference, it may resize the buffers.\n\n    nBuffers = The number of buffers to cycle through when calling $(D next).\n\n    Examples:\n    ---\n    \/\/ Fetch lines of a file in a background thread while processing prevously\n    \/\/ fetched lines, without duplicating any lines.\n    auto file = File(\"foo.txt\");\n\n    void next(ref char[] buf)\n    {\n        file.readln(buf);\n    }\n\n    \/\/ Fetch more lines in the background while we process the lines already\n    \/\/ read into memory into a matrix of doubles.\n    double[][] matrix;\n    auto asyncReader = taskPool.asyncBuf(&next, &file.eof);\n\n    foreach(line; asyncReader)\n    {\n        auto ls = line.split(\"\\t\");\n        matrix ~= to!(double[])(ls);\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D range) are re-thrown on a\n    call to $(D popFront).\n\n    Warning:\n\n    Using the range returned by this function in a parallel foreach loop\n    will not work because buffers may be overwritten while the task that\n    processes them is in queue.  This is checked for at compile time\n    and will result in a static assertion failure.\n    \n",
"line" : 2304}
]
}
,
{
"name" : "reduce(functions...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Parallel reduce on a random access range.  Except as otherwise noted, usage\n    is similar to $(XREF algorithm, _reduce).  This function works by splitting\n    the range to be reduced into work units, which are slices to be reduced in\n    parallel.  Once the results from all work units are computed, a final serial\n    reduction is performed on these results to compute the final answer.\n    Therefore, care must be taken to choose the seed value appropriately.\n\n    Because the reduction is being performed in parallel,\n    $(D functions) must be associative.  For notational simplicity, let # be an\n    infix operator representing $(D functions).  Then, (a # b) # c must equal\n    a # (b # c).  Floating point addition is not associative\n    even though addition in exact arithmetic is.  Summing floating\n    point numbers using this function may give different results than summing\n    serially.  However, for many practical purposes floating point addition\n    can be treated as associative.\n\n    Note that, since $(D functions) are assumed to be associative, additional\n    optimizations are made to the serial portion of the reduction algorithm.\n    These take advantage of the instruction level parallelism of modern CPUs,\n    in addition to the thread-level parallelism that the rest of this\n    module exploits.  This can lead to better than linear speedups relative\n    to $(XREF algorithm, _reduce), especially for fine-grained benchmarks\n    like dot products.\n\n    An explicit seed may be provided as the first argument.  If\n    provided, it is used as the seed for all work units and for the final\n    reduction of results from all work units.  Therefore, if it is not the\n    identity value for the operation being performed, results may differ from\n    those generated by $(XREF algorithm, _reduce) or depending on how many work\n    units are used.  The next argument must be the range to be reduced.\n    ---\n    \/\/ Find the sum of squares of a range in parallel, using an explicit seed.\n    \/\/\n    \/\/ Timings on an Athlon 64 X2 dual core machine:\n    \/\/\n    \/\/ Parallel reduce:                     72 milliseconds\n    \/\/ Using std.algorithm.reduce instead:  181 milliseconds\n    auto nums = iota(10_000_000.0f);\n    auto sumSquares = taskPool.reduce!\"a + b\"(\n        0.0, std.algorithm.map!\"a * a\"(nums)\n    );\n    ---\n\n    If no explicit seed is provided, the first element of each work unit\n    is used as a seed.  For the final reduction, the result from the first\n    work unit is used as the seed.\n    ---\n    \/\/ Find the sum of a range in parallel, using the first element of each\n    \/\/ work unit as the seed.\n    auto sum = taskPool.reduce!\"a + b\"(nums);\n    ---\n\n    An explicit work unit size may be specified as the last argument.\n    Specifying too small a work unit size will effectively serialize the\n    reduction, as the final reduction of the result of each work unit will\n    dominate computation time.  If $(D TaskPool.size) for this instance\n    is zero, this parameter is ignored and one work unit is used.\n    ---\n    \/\/ Use a work unit size of 100.\n    auto sum2 = taskPool.reduce!\"a + b\"(nums, 100);\n\n    \/\/ Work unit size of 100 and explicit seed.\n    auto sum3 = taskPool.reduce!\"a + b\"(0.0, nums, 100);\n    ---\n\n    Parallel reduce supports multiple functions, like\n    $(D std.algorithm.reduce).\n    ---\n    \/\/ Find both the min and max of nums.\n    auto minMax = taskPool.reduce!(min, max)(nums);\n    assert(minMax[0] == reduce!min(nums));\n    assert(minMax[1] == reduce!max(nums));\n    ---\n\n    $(B Exception Handling):\n\n    After this function is finished executing, any exceptions thrown\n    are chained together via $(D Throwable.next) and rethrown.  The chaining\n    order is non-deterministic.\n     \n",
"line" : 2396,
"members" : [
{
"name" : "reduce(Args...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 2400,
"members" : [
{
"name" : "reduce",
"kind" : "function",
"type" : "(Args args)",
"comment" : "\n",
"line" : 2400}
]
}
]
}
,
{
"name" : "workerIndex",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @property @safe ulong()",
"comment" : "\n    Gets the index of the current thread relative to this $(D TaskPool).  Any\n    thread not in this pool will receive an index of 0.  The worker threads in\n    this pool receive unique indices of 1 through $(D this.size).\n\n    This function is useful for maintaining worker-local resources.\n\n    Examples:\n    ---\n    \/\/ Execute a loop that computes the greatest common divisor of every\n    \/\/ number from 0 through 999 with 42 in parallel.  Write the results out to\n    \/\/ a set of files, one for each thread.  This allows results to be written\n    \/\/ out without any synchronization.\n\n    import std.stdio, std.conv, std.range, std.numeric;\n\n    void main()\n    {\n        auto filesHandles = new File[taskPool.size + 1];\n        scope(exit) {\n            foreach(ref handle; fileHandles) {\n                handle.close();\n            }\n        }\n\n        foreach(i, ref handle; fileHandles)\n        {\n            handle = File(\"workerResults\" ~ to!string(i) ~ \".txt\");\n        }\n\n        foreach(num; parallel(iota(1_000)))\n        {\n            auto outHandle = fileHandles[taskPool.workerIndex];\n            outHandle.writeln(num, '\\t', gcd(num, 42));\n        }\n    }\n    ---\n    \n",
"line" : 2735}
,
{
"name" : "WorkerLocalStorage(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Struct for creating worker-local storage.  Worker-local storage is\n    thread-local storage that exists only for worker threads in a given\n    $(D TaskPool) plus a single thread outside the pool.  It is allocated on the\n    garbage collected heap in a way that avoids _false sharing, and doesn't\n    necessarily have global scope within any thread.  It can be accessed from\n    any worker thread in the $(D TaskPool) that created it, and one thread\n    outside this $(D TaskPool).  All threads outside the pool that created a\n    given instance of worker-local storage share a single slot.\n\n    Since the underlying data for this struct is heap-allocated, this struct\n    has reference semantics when passed between functions.\n\n    The main uses cases for $(D WorkerLocalStorageStorage) are:\n\n    1.  Performing parallel reductions with an imperative, as opposed to\n    functional, programming style.  In this case, it's useful to treat\n    $(D WorkerLocalStorageStorage) as local to each thread for only the parallel\n    portion of an algorithm.\n\n    2.  Recycling temporary buffers across iterations of a parallel foreach loop.\n\n    Examples:\n    ---\n    \/\/ Calculate pi as in our synopsis example, but\n    \/\/ use an imperative instead of a functional style.\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0L \/ n;\n\n    auto sums = taskPool.workerLocalStorage(0.0L);\n    foreach(i; parallel(iota(n)))\n    {\n        immutable x = ( i - 0.5L ) * delta;\n        immutable toAdd = delta \/ ( 1.0 + x * x );\n        sums.get += toAdd;\n    }\n\n    \/\/ Add up the results from each worker thread.\n    real pi = 0;\n    foreach(threadResult; sums.toRange)\n    {\n        pi += 4.0L * threadResult;\n    }\n    ---\n     \n",
"line" : 2789,
"members" : [
{
"name" : "WorkerLocalStorage",
"kind" : "struct",
"protection" : "public",
"line" : 2789,
"members" : [
{
"name" : "pool",
"kind" : "variable",
"type" : "TaskPool",
"line" : 2791}
,
{
"name" : "size",
"kind" : "variable",
"type" : "size_t",
"line" : 2792}
,
{
"name" : "cacheLineSize",
"kind" : "variable",
"type" : "size_t",
"line" : 2794}
,
{
"name" : "elemSize",
"kind" : "variable",
"type" : "size_t",
"line" : 2795}
,
{
"name" : "stillThreadLocal",
"kind" : "variable",
"type" : "bool*",
"line" : 2796}
,
{
"name" : "roundToLine",
"kind" : "function",
"type" : "pure nothrow size_t(size_t num)",
"line" : 2812}
,
{
"name" : "data",
"kind" : "variable",
"type" : "void*",
"line" : 2823}
,
{
"name" : "initialize",
"kind" : "function",
"type" : "void(TaskPool pool)",
"line" : 2825}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t index)",
"line" : 2855}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T val, size_t index)",
"line" : 2861}
,
{
"name" : "get",
"kind" : "function",
"type" : "@property T()",
"comment" : "\n        Get the current thread's instance.  Returns by ref.\n        Note that calling $(D get) from any thread\n        outside the $(D TaskPool) that created this instance will return the\n        same reference, so an instance of worker-local storage should only be\n        accessed from one thread outside the pool that created it.  If this\n        rule is violated, undefined behavior will result.\n\n        If assertions are enabled and $(D toRange) has been called, then this\n        WorkerLocalStorage instance is no longer worker-local and an assertion\n        failure will result when calling this method.  This is not checked\n        when assertions are disabled for performance reasons.\n         \n",
"line" : 2881}
,
{
"name" : "get",
"kind" : "function",
"type" : "@property void(T val)",
"comment" : "\n        Assign a value to the current thread's instance.  This function has\n        the same caveats as its overload.\n        \n",
"line" : 2894}
,
{
"name" : "toRange",
"kind" : "function",
"type" : "@property WorkerLocalStorageRange!(T)()",
"comment" : "\n        Returns a range view of the values for all threads, which can be used\n        to further process the results of each thread after running the parallel\n        part of your algorithm.  Do not use this method in the parallel portion\n        of your algorithm.\n\n        Calling this function sets a flag indicating that this struct is no\n        longer worker-local, and attempting to use the $(D get) method again\n        will result in an assertion failure if assertions are enabled.\n         \n",
"line" : 2914}
]
}
]
}
,
{
"name" : "WorkerLocalStorageRange(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Range primitives for worker-local storage.  The purpose of this is to\n    access results produced by each worker thread from a single thread once you\n    are no longer using the worker-local storage from multiple threads.\n    Do not use this struct in the parallel portion of your algorithm.\n\n    The proper way to instantiate this object is to call\n    $(D WorkerLocalStorage.toRange).  Once instantiated, this object behaves\n    as a finite random-access range with assignable, lvalue elemends and\n    a length equal to the number of worker threads in the $(D TaskPool) that\n    created it plus 1.\n     \n",
"line" : 2947,
"members" : [
{
"name" : "WorkerLocalStorageRange",
"kind" : "struct",
"protection" : "public",
"line" : 2947,
"members" : [
{
"name" : "workerLocalStorage",
"kind" : "variable",
"type" : "WorkerLocalStorage!(T)",
"line" : 2949}
,
{
"name" : "_length",
"kind" : "variable",
"type" : "size_t",
"line" : 2951}
,
{
"name" : "beginOffset",
"kind" : "variable",
"type" : "size_t",
"line" : 2952}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(WorkerLocalStorage!(T) wl)",
"line" : 2954}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property T()",
"line" : 2961}
,
{
"name" : "back",
"kind" : "function",
"type" : "@property T()",
"line" : 2966}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2971}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"line" : 2980}
,
{
"name" : "save",
"kind" : "function",
"type" : "@property typeof(this)()",
"line" : 2988}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t index)",
"line" : 2993}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(T val, size_t index)",
"line" : 2999}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "typeof(this)(size_t lower, size_t upper)",
"line" : 3005}
,
{
"name" : "empty",
"kind" : "function",
"type" : "@property bool()",
"line" : 3014}
,
{
"name" : "length",
"kind" : "function",
"type" : "@property size_t()",
"line" : 3019}
]
}
]
}
,
{
"name" : "workerLocalStorage(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Creates an instance of worker-local storage, initialized with a given\n    value.  The value is $(D lazy) so that you can, for example, easily\n    create one instance of a class for each worker.  For usage example,\n    see the $(D WorkerLocalStorage) struct.\n     \n",
"line" : 3031,
"members" : [
{
"name" : "workerLocalStorage",
"kind" : "function",
"type" : "WorkerLocalStorage!(T)(lazy T initialVal = T.init)",
"comment" : "\n    Creates an instance of worker-local storage, initialized with a given\n    value.  The value is $(D lazy) so that you can, for example, easily\n    create one instance of a class for each worker.  For usage example,\n    see the $(D WorkerLocalStorage) struct.\n     \n",
"line" : 3031}
]
}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "@trusted void()",
"comment" : "\n    Signals to all worker threads to terminate as soon as they are finished\n    with their current $(D Task), or immediately if they are not executing a\n    $(D Task).  $(D Task)s that were in queue will not be executed unless\n    a call to $(D Task.workForce), $(D Task.yieldForce) or $(D Task.spinForce)\n    causes them to be executed.\n\n    Use only if you have waitied on every $(D Task) and therefore know the\n    queue is empty, or if you speculatively executed some tasks and no longer\n    need the results.\n     \n",
"line" : 3059}
,
{
"name" : "finish",
"kind" : "function",
"protection" : "public",
"type" : "@trusted void(bool blocking = false)",
"comment" : "\n    Signals worker threads to terminate when the queue becomes empty.\n\n    If blocking argument is true, wait for all worker threads to terminate\n    before returning.  This option might be used in applications where\n    task results are never consumed-- e.g. when $(D TaskPool) is employed as a\n    rudimentary scheduler for tasks which communicate by means other than\n    return values.\n     \n",
"line" : 3076}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe ulong()",
"comment" : " Returns the number of worker threads in the pool.\n",
"line" : 3090}
,
{
"name" : "put(alias fun,Args...) if (!isSafeReturn!(typeof(task)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Put a $(D Task) object on the back of the task queue.  The $(D Task)\n    object may be passed by pointer or reference.\n\n    Example:\n    ---\n    import std.file;\n\n    \/\/ Create a task.\n    auto t = task!read(\"foo.txt\");\n\n    \/\/ Add it to the queue to be executed.\n    taskPool.put(t);\n    ---\n\n    Notes:\n\n    @trusted overloads of this function are called for $(D Task)s if\n    $(XREF traits, hasUnsharedAliasing) is false for the $(D Task)'s\n    return type or the function the $(D Task) executes is $(D pure).\n    $(D Task) objects that meet all other requirements specified in the\n    $(D @trusted) overloads of $(D task) and $(D scopedTask) may be created\n    and executed from $(D @safe) code via $(D Task.executeInNewThread) but\n    not via $(D TaskPool).\n\n    While this function takes the address of variables that may\n    be on the stack, some overloads are marked as @trusted.\n    $(D Task) includes a destructor that waits for the task to complete\n    before destroying the stack frame it is allocated on.  Therefore,\n    it is impossible for the stack frame to be destroyed before the task is\n    complete and no longer referenced by a $(D TaskPool).\n    \n",
"line" : 3127,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(ref Task!(fun,Args) task)",
"comment" : "\n    Put a $(D Task) object on the back of the task queue.  The $(D Task)\n    object may be passed by pointer or reference.\n\n    Example:\n    ---\n    import std.file;\n\n    \/\/ Create a task.\n    auto t = task!read(\"foo.txt\");\n\n    \/\/ Add it to the queue to be executed.\n    taskPool.put(t);\n    ---\n\n    Notes:\n\n    @trusted overloads of this function are called for $(D Task)s if\n    $(XREF traits, hasUnsharedAliasing) is false for the $(D Task)'s\n    return type or the function the $(D Task) executes is $(D pure).\n    $(D Task) objects that meet all other requirements specified in the\n    $(D @trusted) overloads of $(D task) and $(D scopedTask) may be created\n    and executed from $(D @safe) code via $(D Task.executeInNewThread) but\n    not via $(D TaskPool).\n\n    While this function takes the address of variables that may\n    be on the stack, some overloads are marked as @trusted.\n    $(D Task) includes a destructor that waits for the task to complete\n    before destroying the stack frame it is allocated on.  Therefore,\n    it is impossible for the stack frame to be destroyed before the task is\n    complete and no longer referenced by a $(D TaskPool).\n    \n",
"line" : 3127}
]
}
,
{
"name" : "put(alias fun,Args...) if (!isSafeReturn!(typeof(*task)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3135,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(Task!(fun,Args)* task)",
"comment" : " Ditto\n",
"line" : 3135}
]
}
,
{
"name" : "put(alias fun,Args...) if (isSafeReturn!(typeof(task)))",
"kind" : "template",
"protection" : "public",
"line" : 3142,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(ref Task!(fun,Args) task)",
"line" : 3142}
]
}
,
{
"name" : "put(alias fun,Args...) if (isSafeReturn!(typeof(*task)))",
"kind" : "template",
"protection" : "public",
"line" : 3149,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(Task!(fun,Args)* task)",
"line" : 3149}
]
}
,
{
"name" : "isDaemon",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted bool()",
"comment" : "\n    These properties control whether the worker threads are daemon threads.\n    A daemon thread is automatically terminated when all non-daemon threads\n    have terminated.  A non-daemon thread will prevent a program from\n    terminating as long as it has not terminated.\n\n    If any $(D TaskPool) with non-daemon threads is active, either $(D stop)\n    or $(D finish) must be called on it before the program can terminate.\n\n    The worker treads in the $(D TaskPool) instance returned by the\n    $(D taskPool) property are daemon by default.  The worker threads of\n    manually instantiated task pools are non-daemon by default.\n\n    Note:  For a size zero pool, the getter arbitrarily returns true and the\n           setter has no effect.\n    \n",
"line" : 3172}
,
{
"name" : "isDaemon",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted void(bool newVal)",
"comment" : " Ditto\n",
"line" : 3180}
,
{
"name" : "priority",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted int()",
"comment" : "\n    These functions allow getting and setting the OS scheduling priority of\n    the worker threads in this $(D TaskPool).  They forward to\n    $(D core.thread.Thread.priority), so a given priority value here means the\n    same thing as an identical priority value in $(D core.thread).\n\n    Note:  For a size zero pool, the getter arbitrarily returns\n           $(D core.thread.Thread.PRIORITY_MIN) and the setter has no effect.\n    \n",
"line" : 3199}
,
{
"name" : "priority",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted void(int newPriority)",
"comment" : " Ditto\n",
"line" : 3206}
]
}
,
{
"name" : "taskPool",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted TaskPool()",
"comment" : "\nReturns a lazily initialized global instantiation of $(D TaskPool).\nThis function can safely be called concurrently from multiple non-worker\nthreads.  The worker threads in this pool are daemon threads, meaning that it\nis not necessary to call $(D TaskPool.stop) or $(D TaskPool.finish) before\nterminating the main thread.\n",
"line" : 3225}
,
{
"name" : "_defaultPoolThreads",
"kind" : "variable",
"protection" : "private",
"type" : "shared(uint)",
"line" : 3247}
,
{
"name" : "defaultPoolThreads",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted uint()",
"comment" : "\nThese properties get and set the number of worker threads in the $(D TaskPool)\ninstance returned by $(D taskPool).  The default value is $(D totalCPUs) - 1.\nCalling the setter after the first call to $(D taskPool) does not changes\nnumber of worker threads in the instance returned by $(D taskPool).\n",
"line" : 3259}
,
{
"name" : "defaultPoolThreads",
"kind" : "function",
"protection" : "public",
"type" : "@property @trusted void(uint newVal)",
"comment" : " Ditto\n",
"line" : 3265}
,
{
"name" : "parallel(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nConvenience functions that forwards to $(D taskPool.parallel).  The\npurpose of these is to make parallel foreach less verbose and more\nreadable.\n\nExample:\n---\n\/\/ Find the logarithm of every number from 1 to 1_000_000 in parallel,\n\/\/ using the default TaskPool instance.\nauto logs = new double[1_000_000];\n\nforeach(i, ref elem; parallel(logs)) {\n    elem = log(i + 1.0);\n}\n---\n\n",
"line" : 3287,
"members" : [
{
"name" : "parallel",
"kind" : "function",
"type" : "ParallelForeach!(R)(R range)",
"comment" : "\nConvenience functions that forwards to $(D taskPool.parallel).  The\npurpose of these is to make parallel foreach less verbose and more\nreadable.\n\nExample:\n---\n\/\/ Find the logarithm of every number from 1 to 1_000_000 in parallel,\n\/\/ using the default TaskPool instance.\nauto logs = new double[1_000_000];\n\nforeach(i, ref elem; parallel(logs)) {\n    elem = log(i + 1.0);\n}\n---\n\n",
"line" : 3287}
]
}
,
{
"name" : "parallel(R)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3293,
"members" : [
{
"name" : "parallel",
"kind" : "function",
"type" : "ParallelForeach!(R)(R range, size_t workUnitSize)",
"comment" : " Ditto\n",
"line" : 3293}
]
}
,
{
"name" : "ParallelForeachError",
"kind" : "class",
"protection" : "public",
"line" : 3299,
"base" : "Error",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ParallelForeachError()",
"line" : 3301}
]
}
,
{
"name" : "randLen(R)",
"kind" : "template",
"protection" : "public",
"line" : 3309,
"members" : [
{
"name" : "randLen",
"kind" : "variable",
"line" : 3311}
]
}
,
{
"name" : "submitAndExecute",
"kind" : "function",
"protection" : "private",
"type" : "void(TaskPool pool, scope void delegate() doIt)",
"line" : 3314}
,
{
"name" : "foreachErr",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 3421}
,
{
"name" : "doSizeZeroCase(R,Delegate)",
"kind" : "template",
"protection" : "public",
"line" : 3426,
"members" : [
{
"name" : "doSizeZeroCase",
"kind" : "function",
"type" : "int(ref ParallelForeach!(R) p, Delegate dg)",
"line" : 3426}
]
}
,
{
"name" : "parallelApplyMixinRandomAccess",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 3471}
,
{
"name" : "parallelApplyMixinInputRange",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 3526}
,
{
"name" : "findLastException",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow Throwable(Throwable e)",
"line" : 3704}
,
{
"name" : "addToChain",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow void(Throwable e, ref Throwable firstException, ref Throwable lastException)",
"line" : 3717}
,
{
"name" : "ParallelForeach(R)",
"kind" : "struct",
"protection" : "public",
"line" : 3736,
"members" : [
{
"name" : "ParallelForeach",
"kind" : "struct",
"protection" : "public",
"line" : 3736,
"members" : [
{
"name" : "pool",
"kind" : "variable",
"type" : "TaskPool",
"line" : 3737}
,
{
"name" : "range",
"kind" : "variable",
"type" : "R",
"line" : 3738}
,
{
"name" : "workUnitSize",
"kind" : "variable",
"type" : "size_t",
"line" : 3739}
,
{
"name" : "E",
"kind" : "alias",
"type" : "ElementType!(R)",
"line" : 3740}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope NoIndexDg dg)",
"line" : 3753}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope IndexDg dg)",
"line" : 3765}
]
}
]
}
,
{
"name" : "RoundRobinBuffer(C1,C2)",
"kind" : "struct",
"protection" : "public",
"line" : 3786,
"members" : [
{
"name" : "RoundRobinBuffer",
"kind" : "struct",
"protection" : "public",
"line" : 3786,
"members" : [
{
"name" : "Array",
"kind" : "alias",
"type" : "ParameterTypeTuple!(C1.init)[0]",
"line" : 3789}
,
{
"name" : "T",
"kind" : "alias",
"type" : "typeof(Array.init[0])",
"line" : 3790}
,
{
"name" : "bufs",
"kind" : "variable",
"type" : "T[][]",
"line" : 3792}
,
{
"name" : "index",
"kind" : "variable",
"type" : "size_t",
"line" : 3793}
,
{
"name" : "nextDel",
"kind" : "variable",
"type" : "C1",
"line" : 3794}
,
{
"name" : "emptyDel",
"kind" : "variable",
"type" : "C2",
"line" : 3795}
,
{
"name" : "_empty",
"kind" : "variable",
"type" : "bool",
"line" : 3796}
,
{
"name" : "primed",
"kind" : "variable",
"type" : "bool",
"line" : 3797}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(C1 nextDel, C2 emptyDel, size_t initialBufSize, size_t nBuffers)",
"line" : 3799}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void()",
"line" : 3815}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property T[]()",
"line" : 3827}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 3838}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const pure nothrow @property @safe bool()",
"line" : 3850}
]
}
]
}
]
}
,
{
"name" : "std.path",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/path.d",
"comment" : " This module is used to manipulate _path strings.\n\n    All functions, with the exception of $(LREF expandTilde) (and in some\n    cases $(LREF absolutePath) and $(LREF relativePath)), are pure\n    string manipulation functions; they don't depend on any state outside\n    the program, nor do they perform any actual file system actions.\n    This has the consequence that the module does not make any distinction\n    between a _path that points to a directory and a _path that points to a\n    file, and it does not know whether or not the object pointed to by the\n    _path actually exists in the file system.\n    To differentiate between these cases, use $(XREF file,isDir) and\n    $(XREF file,exists).\n\n    Note that on Windows, both the backslash ($(D '\\')) and the slash ($(D '\/'))\n    are in principle valid directory separators.  This module treats them\n    both on equal footing, but in cases where a $(I new) separator is\n    added, a backslash will be used.  Furthermore, the $(LREF buildNormalizedPath)\n    function will replace all slashes with backslashes on that platform.\n\n    In general, the functions in this module assume that the input paths\n    are well-formed.  (That is, they should not contain invalid characters,\n    they should follow the file system's _path format, etc.)  The result\n    of calling a function on an ill-formed _path is undefined.  When there\n    is a chance that a _path or a file name is invalid (for instance, when it\n    has been input by the user), it may sometimes be desirable to use the\n    $(LREF isValidFilename) and $(LREF isValidPath) functions to check\n    this.\n\n    Most functions do not perform any memory allocations, and if a string is\n    returned, it is usually a slice of an input string.  If a function\n    allocates, this is explicitly mentioned in the documentation.\n\n    Authors:\n        Lars Tandle Kyllingstad,\n        $(WEB digitalmars.com, Walter Bright),\n        Grzegorz Adam Hankiewicz,\n        Thomas Khne,\n        $(WEB erdani.org, Andrei Alexandrescu)\n    Copyright:\n        Copyright (c) 20002011, the authors. All rights reserved.\n    License:\n        $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0)\n    Source:\n        $(PHOBOSSRC std\/_path.d)\n    Macros:\n        WIKI = Phobos\/StdPath\n",
"members" : [
{
"name" : "dirSeparator",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " String used to separate directory names in a path.  Under\n    POSIX this is a slash, under Windows a backslash.\n",
"line" : 75}
,
{
"name" : "pathSeparator",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Path separator string.  A colon under POSIX, a semicolon\n    under Windows.\n",
"line" : 85}
,
{
"name" : "isDirSeparator",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : " Determines whether the given character is a directory separator.\n\n    On Windows, this includes both $(D '\\') and $(D '\/').\n    On POSIX, it's just $(D '\/').\n",
"line" : 97}
,
{
"name" : "isDriveSeparator",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow @safe bool(dchar c)",
"line" : 111}
,
{
"name" : "isSeparator",
"kind" : "alias",
"protection" : "private",
"line" : 123}
,
{
"name" : "lastSeparator(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"line" : 130,
"members" : [
{
"name" : "lastSeparator",
"kind" : "function",
"type" : "pure nothrow @safe sizediff_t(in C[] path)",
"line" : 130}
]
}
,
{
"name" : "ltrimDirSeparators(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"line" : 182,
"members" : [
{
"name" : "ltrimDirSeparators",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"line" : 182}
]
}
,
{
"name" : "rtrimDirSeparators(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"line" : 190,
"members" : [
{
"name" : "rtrimDirSeparators",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"line" : 190}
]
}
,
{
"name" : "trimDirSeparators(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"line" : 198,
"members" : [
{
"name" : "trimDirSeparators",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"line" : 198}
]
}
,
{
"name" : "CaseSensitive",
"kind" : "enum",
"protection" : "public",
"comment" : " This $(D enum) is used as a template argument to functions which\n    compare file names, and determines whether the comparison is\n    case sensitive or not.\n",
"line" : 211,
"base" : "bool",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " File names are case insensitive\n",
"line" : 214}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " File names are case sensitive\n",
"line" : 217}
,
{
"name" : "osDefault",
"kind" : "enum member",
"protection" : "public",
"comment" : " The default (or most common) setting for the current platform.\n        That is, $(D no) on Windows and Mac OS X, and $(D yes) on all\n        POSIX systems except OS X (Linux, *BSD, etc.).\n    \n",
"line" : 223}
]
}
,
{
"name" : "osDefaultCaseSensitivity",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 227}
,
{
"name" : "baseName(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the name of a file, without any leading directory\n    and with an optional suffix chopped off.\n\n    If $(D suffix) is specified, it will be compared to $(D path)\n    using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (baseName(\"dir\/file.ext\")         == \"file.ext\");\n    assert (baseName(\"dir\/file.ext\", \".ext\") == \"file\");\n    assert (baseName(\"dir\/file.ext\", \".xyz\") == \"file.ext\");\n    assert (baseName(\"dir\/filename\", \"name\") == \"file\");\n    assert (baseName(\"dir\/subdir\/\")          == \"subdir\");\n\n    version (Windows)\n    {\n        assert (baseName(`d:file.ext`)      == \"file.ext\");\n        assert (baseName(`d:\\dir\\file.ext`) == \"file.ext\");\n    }\n    ---\n\n    Note:\n    This function $(I only) strips away the specified suffix, which\n    doesn't necessarily have to represent an extension.  If you want\n    to remove the extension from a path, regardless of what the extension\n    is, use $(LREF stripExtension).\n    If you want the filename without leading directories and without\n    an extension, combine the functions like this:\n    ---\n    assert (baseName(stripExtension(\"dir\/file.ext\")) == \"file\");\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/utilities\/basename.html,\n    the POSIX requirements for the 'basename' shell utility)\n    (with suitable adaptations for Windows paths).\n",
"line" : 274,
"members" : [
{
"name" : "baseName",
"kind" : "function",
"type" : "pure @trusted inout(C)[](inout(C)[] path)",
"comment" : " Returns the name of a file, without any leading directory\n    and with an optional suffix chopped off.\n\n    If $(D suffix) is specified, it will be compared to $(D path)\n    using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (baseName(\"dir\/file.ext\")         == \"file.ext\");\n    assert (baseName(\"dir\/file.ext\", \".ext\") == \"file\");\n    assert (baseName(\"dir\/file.ext\", \".xyz\") == \"file.ext\");\n    assert (baseName(\"dir\/filename\", \"name\") == \"file\");\n    assert (baseName(\"dir\/subdir\/\")          == \"subdir\");\n\n    version (Windows)\n    {\n        assert (baseName(`d:file.ext`)      == \"file.ext\");\n        assert (baseName(`d:\\dir\\file.ext`) == \"file.ext\");\n    }\n    ---\n\n    Note:\n    This function $(I only) strips away the specified suffix, which\n    doesn't necessarily have to represent an extension.  If you want\n    to remove the extension from a path, regardless of what the extension\n    is, use $(LREF stripExtension).\n    If you want the filename without leading directories and without\n    an extension, combine the functions like this:\n    ---\n    assert (baseName(stripExtension(\"dir\/file.ext\")) == \"file\");\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/utilities\/basename.html,\n    the POSIX requirements for the 'basename' shell utility)\n    (with suitable adaptations for Windows paths).\n",
"line" : 274}
]
}
,
{
"name" : "baseName(CaseSensitive cs = CaseSensitive.osDefault,C,C1) if (isSomeChar!(C) && isSomeChar!(C1))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 295,
"members" : [
{
"name" : "baseName",
"kind" : "function",
"type" : "pure @safe inout(C)[](inout(C)[] path, in C1[] suffix)",
"comment" : " ditto\n",
"line" : 295}
]
}
,
{
"name" : "dirName(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the directory part of a path.  On Windows, this\n    includes the drive letter if present.\n\n    This function performs a memory allocation if and only if $(D path)\n    is mutable and does not have a directory (in which case a new mutable\n    string is needed to hold the returned current-directory symbol,\n    $(D \".\")).\n\n    Examples:\n    ---\n    assert (dirName(\"file\")        == \".\");\n    assert (dirName(\"dir\/file\")    == \"dir\");\n    assert (dirName(\"\/file\")       == \"\/\");\n    assert (dirName(\"dir\/subdir\/\") == \"dir\");\n\n    version (Windows)\n    {\n        assert (dirName(\"d:file\")      == \"d:\");\n        assert (dirName(`d:\\dir\\file`) == `d:\\dir`);\n        assert (dirName(`d:\\file`)     == `d:\\`);\n        assert (dirName(`dir\\subdir\\`) == `dir`);\n    }\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/utilities\/dirname.html,\n    the POSIX requirements for the 'dirname' shell utility)\n    (with suitable adaptations for Windows paths).\n",
"line" : 389,
"members" : [
{
"name" : "dirName",
"kind" : "function",
"type" : "C[](C[] path)",
"comment" : " Returns the directory part of a path.  On Windows, this\n    includes the drive letter if present.\n\n    This function performs a memory allocation if and only if $(D path)\n    is mutable and does not have a directory (in which case a new mutable\n    string is needed to hold the returned current-directory symbol,\n    $(D \".\")).\n\n    Examples:\n    ---\n    assert (dirName(\"file\")        == \".\");\n    assert (dirName(\"dir\/file\")    == \"dir\");\n    assert (dirName(\"\/file\")       == \"\/\");\n    assert (dirName(\"dir\/subdir\/\") == \"dir\");\n\n    version (Windows)\n    {\n        assert (dirName(\"d:file\")      == \"d:\");\n        assert (dirName(`d:\\dir\\file`) == `d:\\dir`);\n        assert (dirName(`d:\\file`)     == `d:\\`);\n        assert (dirName(`dir\\subdir\\`) == `dir`);\n    }\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/utilities\/dirname.html,\n    the POSIX requirements for the 'dirname' shell utility)\n    (with suitable adaptations for Windows paths).\n",
"line" : 389}
]
}
,
{
"name" : "rootName(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the root directory of the specified path, or $(D null) if the\n    path is not rooted.\n\n    Examples:\n    ---\n    assert (rootName(\"foo\") is null);\n    assert (rootName(\"\/foo\") == \"\/\");\n\n    version (Windows)\n    {\n        assert (rootName(`\\foo`) == `\\`);\n        assert (rootName(`c:\\foo`) == `c:\\`);\n        assert (rootName(`\\\\server\\share\\foo`) == `\\\\server\\share`);\n    }\n    ---\n",
"line" : 481,
"members" : [
{
"name" : "rootName",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"comment" : " Returns the root directory of the specified path, or $(D null) if the\n    path is not rooted.\n\n    Examples:\n    ---\n    assert (rootName(\"foo\") is null);\n    assert (rootName(\"\/foo\") == \"\/\");\n\n    version (Windows)\n    {\n        assert (rootName(`\\foo`) == `\\`);\n        assert (rootName(`c:\\foo`) == `c:\\`);\n        assert (rootName(`\\\\server\\share\\foo`) == `\\\\server\\share`);\n    }\n    ---\n",
"line" : 481}
]
}
,
{
"name" : "driveName(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the drive of a path, or $(D null) if the drive\n    is not specified.  In the case of UNC paths, the network share\n    is returned.\n\n    Always returns $(D null) on POSIX.\n\n    Examples:\n    ---\n    version (Windows)\n    {\n        assert (driveName(`d:\\file`) == \"d:\");\n        assert (driveName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n        assert (driveName(`dir\\file`).empty);\n    }\n    ---\n",
"line" : 544,
"members" : [
{
"name" : "driveName",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"comment" : " Returns the drive of a path, or $(D null) if the drive\n    is not specified.  In the case of UNC paths, the network share\n    is returned.\n\n    Always returns $(D null) on POSIX.\n\n    Examples:\n    ---\n    version (Windows)\n    {\n        assert (driveName(`d:\\file`) == \"d:\");\n        assert (driveName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n        assert (driveName(`dir\\file`).empty);\n    }\n    ---\n",
"line" : 544}
]
}
,
{
"name" : "stripDrive(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Strips the drive from a Windows path.  On POSIX, the path is returned\n    unaltered.\n\n    Example:\n    ---\n    version (Windows)\n    {\n        assert (stripDrive(`d:\\dir\\file`) == `\\dir\\file`);\n        assert (stripDrive(`\\\\server\\share\\dir\\file`) == `\\dir\\file`);\n    }\n    ---\n",
"line" : 590,
"members" : [
{
"name" : "stripDrive",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"comment" : " Strips the drive from a Windows path.  On POSIX, the path is returned\n    unaltered.\n\n    Example:\n    ---\n    version (Windows)\n    {\n        assert (stripDrive(`d:\\dir\\file`) == `\\dir\\file`);\n        assert (stripDrive(`\\\\server\\share\\dir\\file`) == `\\dir\\file`);\n    }\n    ---\n",
"line" : 590}
]
}
,
{
"name" : "extSeparatorPos(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"line" : 621,
"members" : [
{
"name" : "extSeparatorPos",
"kind" : "function",
"type" : "pure nothrow @safe sizediff_t(in C[] path)",
"line" : 621}
]
}
,
{
"name" : "extension(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the _extension part of a file name, including the dot.\n\n    If there is no _extension, $(D null) is returned.\n\n    Examples:\n    ---\n    assert (extension(\"file\").empty);\n    assert (extension(\"file.ext\")       == \".ext\");\n    assert (extension(\"file.ext1.ext2\") == \".ext2\");\n    assert (extension(\"file.\")          == \".\");\n    assert (extension(\".file\").empty);\n    assert (extension(\".file.ext\")      == \".ext\");\n    ---\n",
"line" : 650,
"members" : [
{
"name" : "extension",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"comment" : " Returns the _extension part of a file name, including the dot.\n\n    If there is no _extension, $(D null) is returned.\n\n    Examples:\n    ---\n    assert (extension(\"file\").empty);\n    assert (extension(\"file.ext\")       == \".ext\");\n    assert (extension(\"file.ext1.ext2\") == \".ext2\");\n    assert (extension(\"file.\")          == \".\");\n    assert (extension(\".file\").empty);\n    assert (extension(\".file.ext\")      == \".ext\");\n    ---\n",
"line" : 650}
]
}
,
{
"name" : "stripExtension(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the path with the extension stripped off.\n\n    Examples:\n    ---\n    assert (stripExtension(\"file\")           == \"file\");\n    assert (stripExtension(\"file.ext\")       == \"file\");\n    assert (stripExtension(\"file.ext1.ext2\") == \"file.ext1\");\n    assert (stripExtension(\"file.\")          == \"file\");\n    assert (stripExtension(\".file\")          == \".file\");\n    assert (stripExtension(\".file.ext\")      == \".file\");\n    assert (stripExtension(\"dir\/file.ext\")   == \"dir\/file\");\n    ---\n",
"line" : 711,
"members" : [
{
"name" : "stripExtension",
"kind" : "function",
"type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
"comment" : " Returns the path with the extension stripped off.\n\n    Examples:\n    ---\n    assert (stripExtension(\"file\")           == \"file\");\n    assert (stripExtension(\"file.ext\")       == \"file\");\n    assert (stripExtension(\"file.ext1.ext2\") == \"file.ext1\");\n    assert (stripExtension(\"file.\")          == \"file\");\n    assert (stripExtension(\".file\")          == \".file\");\n    assert (stripExtension(\".file.ext\")      == \".file\");\n    assert (stripExtension(\"dir\/file.ext\")   == \"dir\/file\");\n    ---\n",
"line" : 711}
]
}
,
{
"name" : "setExtension(C1,C2) if (isSomeChar!(C1) && !is(C1 == immutable) && is(Unqual!(C1) == Unqual!(C2)))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns a string containing the _path given by $(D path), but where\n    the extension has been set to $(D ext).\n\n    If the filename already has an extension, it is replaced.   If not, the\n    extension is simply appended to the filename.  Including a leading dot\n    in $(D ext) is optional.\n\n    This function normally allocates a new string (the possible exception\n    being the case when path is immutable and doesn't already have an\n    extension).\n\n    Examples:\n    ---\n    assert (setExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (setExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (setExtension(\"file.old\", \"new\")  == \"file.new\");\n    assert (setExtension(\"file.old\", \".new\") == \"file.new\");\n    ---\n",
"line" : 775,
"members" : [
{
"name" : "setExtension",
"kind" : "function",
"type" : "pure nothrow @trusted immutable(Unqual!(C1))[](in C1[] path, in C2[] ext)",
"comment" : " Returns a string containing the _path given by $(D path), but where\n    the extension has been set to $(D ext).\n\n    If the filename already has an extension, it is replaced.   If not, the\n    extension is simply appended to the filename.  Including a leading dot\n    in $(D ext) is optional.\n\n    This function normally allocates a new string (the possible exception\n    being the case when path is immutable and doesn't already have an\n    extension).\n\n    Examples:\n    ---\n    assert (setExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (setExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (setExtension(\"file.old\", \"new\")  == \"file.new\");\n    assert (setExtension(\"file.old\", \".new\") == \"file.new\");\n    ---\n",
"line" : 775}
]
}
,
{
"name" : "setExtension(C1,C2) if (isSomeChar!(C1) && is(Unqual!(C1) == Unqual!(C2)))",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 786,
"members" : [
{
"name" : "setExtension",
"kind" : "function",
"type" : "pure nothrow @trusted immutable(C1)[](immutable(C1)[] path, const(C2)[] ext)",
"comment" : "ditto\n",
"line" : 786}
]
}
,
{
"name" : "defaultExtension(C1,C2) if (isSomeChar!(C1) && is(Unqual!(C1) == Unqual!(C2)))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns the _path given by $(D path), with the extension given by\n    $(D ext) appended if the path doesn't already have one.\n\n    Including the dot in the extension is optional.\n\n    This function always allocates a new string, except in the case when\n    path is immutable and already has an extension.\n\n    Examples:\n    ---\n    assert (defaultExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (defaultExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (defaultExtension(\"file.\", \"ext\")     == \"file.\");\n    assert (defaultExtension(\"file.old\", \"new\")  == \"file.old\");\n    assert (defaultExtension(\"file.old\", \".new\") == \"file.old\");\n    ---\n",
"line" : 854,
"members" : [
{
"name" : "defaultExtension",
"kind" : "function",
"type" : "pure @trusted immutable(Unqual!(C1))[](in C1[] path, in C2[] ext)",
"comment" : " Returns the _path given by $(D path), with the extension given by\n    $(D ext) appended if the path doesn't already have one.\n\n    Including the dot in the extension is optional.\n\n    This function always allocates a new string, except in the case when\n    path is immutable and already has an extension.\n\n    Examples:\n    ---\n    assert (defaultExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (defaultExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (defaultExtension(\"file.\", \"ext\")     == \"file.\");\n    assert (defaultExtension(\"file.old\", \"new\")  == \"file.old\");\n    assert (defaultExtension(\"file.old\", \".new\") == \"file.old\");\n    ---\n",
"line" : 854}
]
}
,
{
"name" : "buildPath(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Combines one or more path components.\n\n    The given path components are concatenated with each other,\n    and if necessary, directory separators are inserted between\n    them. If any of the path components are rooted (as defined by\n    $(LREF isRooted)) the preceding path components will be dropped.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == \"foo\/bar\/baz\");\n        assert (buildPath(\"\/foo\/\", \"bar\")      == \"\/foo\/bar\");\n        assert (buildPath(\"\/foo\", \"\/bar\")      == \"\/bar\");\n    }\n\n    version (Windows)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == `foo\\bar\\baz`);\n        assert (buildPath(`c:\\foo`, \"bar\")    == `c:\\foo\\bar`);\n        assert (buildPath(\"foo\", `d:\\bar`)    == `d:\\bar`);\n        assert (buildPath(\"foo\", `\\bar`)      == `\\bar`);\n    }\n    ---\n",
"line" : 918,
"members" : [
{
"name" : "buildPath",
"kind" : "function",
"type" : "pure @safe immutable(C)[](const(C[])[] paths...)",
"comment" : " Combines one or more path components.\n\n    The given path components are concatenated with each other,\n    and if necessary, directory separators are inserted between\n    them. If any of the path components are rooted (as defined by\n    $(LREF isRooted)) the preceding path components will be dropped.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == \"foo\/bar\/baz\");\n        assert (buildPath(\"\/foo\/\", \"bar\")      == \"\/foo\/bar\");\n        assert (buildPath(\"\/foo\", \"\/bar\")      == \"\/bar\");\n    }\n\n    version (Windows)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == `foo\\bar\\baz`);\n        assert (buildPath(`c:\\foo`, \"bar\")    == `c:\\foo\\bar`);\n        assert (buildPath(\"foo\", `d:\\bar`)    == `d:\\bar`);\n        assert (buildPath(\"foo\", `\\bar`)      == `\\bar`);\n    }\n    ---\n",
"line" : 918}
]
}
,
{
"name" : "buildNormalizedPath(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Performs the same task as $(LREF buildPath),\n    while at the same time resolving current\/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    On Windows, slashes are replaced with backslashes.\n\n    Note that this function does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildNormalizedPath(\"\/foo\/.\/bar\/..\/\/baz\/\") == \"\/foo\/baz\");\n        assert (buildNormalizedPath(\"..\/foo\/.\") == \"..\/foo\");\n        assert (buildNormalizedPath(\"\/foo\", \"bar\/baz\/\") == \"\/foo\/bar\/baz\");\n        assert (buildNormalizedPath(\"\/foo\", \"\/bar\/..\", \"baz\") == \"\/baz\");\n        assert (buildNormalizedPath(\"foo\/.\/bar\", \"..\/..\/\", \"..\/baz\") == \"..\/baz\");\n        assert (buildNormalizedPath(\"\/foo\/.\/bar\", \"..\/..\/baz\") == \"\/baz\");\n    }\n\n    version (Windows)\n    {\n        assert (buildNormalizedPath(`c:\\foo\\.\\bar\/..\\\\baz\\`) == `c:\\foo\\baz`);\n        assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\/..`) == `c:\\foo`);\n        assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) == `\\\\server\\share\\bar`);\n    }\n    ---\n",
"line" : 1021,
"members" : [
{
"name" : "buildNormalizedPath",
"kind" : "function",
"type" : "pure nothrow @trusted immutable(C)[](const(C[])[] paths...)",
"comment" : " Performs the same task as $(LREF buildPath),\n    while at the same time resolving current\/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    On Windows, slashes are replaced with backslashes.\n\n    Note that this function does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildNormalizedPath(\"\/foo\/.\/bar\/..\/\/baz\/\") == \"\/foo\/baz\");\n        assert (buildNormalizedPath(\"..\/foo\/.\") == \"..\/foo\");\n        assert (buildNormalizedPath(\"\/foo\", \"bar\/baz\/\") == \"\/foo\/bar\/baz\");\n        assert (buildNormalizedPath(\"\/foo\", \"\/bar\/..\", \"baz\") == \"\/baz\");\n        assert (buildNormalizedPath(\"foo\/.\/bar\", \"..\/..\/\", \"..\/baz\") == \"..\/baz\");\n        assert (buildNormalizedPath(\"\/foo\/.\/bar\", \"..\/..\/baz\") == \"\/baz\");\n    }\n\n    version (Windows)\n    {\n        assert (buildNormalizedPath(`c:\\foo\\.\\bar\/..\\\\baz\\`) == `c:\\foo\\baz`);\n        assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\/..`) == `c:\\foo`);\n        assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) == `\\\\server\\share\\bar`);\n    }\n    ---\n",
"line" : 1021}
]
}
,
{
"name" : "pathSplitter(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Returns a bidirectional range that iterates over the elements of a path.\n\n    Examples:\n    ---\n    assert (equal(pathSplitter(\"\/\"), [\"\/\"]));\n    assert (equal(pathSplitter(\"\/foo\/bar\"), [\"\/\", \"foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"\/\/foo\/bar\"), [\"\/\/foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"foo\/..\/bar\/\/.\/\"), [\"foo\", \"..\", \"bar\", \".\"]));\n\n    version (Windows)\n    {\n        assert (equal(pathSplitter(`foo\\..\\bar\\\/.\\`), [\"foo\", \"..\", \"bar\", \".\"]));\n        assert (equal(pathSplitter(\"c:\"), [\"c:\"]));\n        assert (equal(pathSplitter(`c:\\foo\\bar`), [`c:\\`, \"foo\", \"bar\"]));\n        assert (equal(pathSplitter(`c:foo\\bar`), [\"c:foo\", \"bar\"]));\n    }\n    ---\n",
"line" : 1435,
"members" : [
{
"name" : "pathSplitter",
"kind" : "function",
"type" : "pure nothrow @safe (const(C)[] path)",
"comment" : " Returns a bidirectional range that iterates over the elements of a path.\n\n    Examples:\n    ---\n    assert (equal(pathSplitter(\"\/\"), [\"\/\"]));\n    assert (equal(pathSplitter(\"\/foo\/bar\"), [\"\/\", \"foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"\/\/foo\/bar\"), [\"\/\/foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"foo\/..\/bar\/\/.\/\"), [\"foo\", \"..\", \"bar\", \".\"]));\n\n    version (Windows)\n    {\n        assert (equal(pathSplitter(`foo\\..\\bar\\\/.\\`), [\"foo\", \"..\", \"bar\", \".\"]));\n        assert (equal(pathSplitter(\"c:\"), [\"c:\"]));\n        assert (equal(pathSplitter(`c:\\foo\\bar`), [`c:\\`, \"foo\", \"bar\"]));\n        assert (equal(pathSplitter(`c:foo\\bar`), [\"c:foo\", \"bar\"]));\n    }\n    ---\n",
"line" : 1435}
]
}
,
{
"name" : "isRooted(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Determines whether a path starts at a root directory.\n\n    On POSIX, this function returns true if and only if the path starts\n    with a slash (\/).\n    ---\n    version (Posix)\n    {\n        assert (isRooted(\"\/\"));\n        assert (isRooted(\"\/foo\"));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"..\/foo\"));\n    }\n    ---\n\n    On Windows, this function returns true if the path starts at\n    the root directory of the current drive, of some other drive,\n    or of a network drive.\n    ---\n    version (Windows)\n    {\n        assert (isRooted(`\\`));\n        assert (isRooted(`\\foo`));\n        assert (isRooted(`d:\\foo`));\n        assert (isRooted(`\\\\foo\\bar`));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"d:foo\"));\n    }\n    ---\n",
"line" : 1658,
"members" : [
{
"name" : "isRooted",
"kind" : "function",
"type" : "pure nothrow @safe bool(in C[] path)",
"comment" : " Determines whether a path starts at a root directory.\n\n    On POSIX, this function returns true if and only if the path starts\n    with a slash (\/).\n    ---\n    version (Posix)\n    {\n        assert (isRooted(\"\/\"));\n        assert (isRooted(\"\/foo\"));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"..\/foo\"));\n    }\n    ---\n\n    On Windows, this function returns true if the path starts at\n    the root directory of the current drive, of some other drive,\n    or of a network drive.\n    ---\n    version (Windows)\n    {\n        assert (isRooted(`\\`));\n        assert (isRooted(`\\foo`));\n        assert (isRooted(`d:\\foo`));\n        assert (isRooted(`\\\\foo\\bar`));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"d:foo\"));\n    }\n    ---\n",
"line" : 1658}
]
}
,
{
"name" : "isAbsolute",
"kind" : "alias",
"protection" : "public",
"comment" : " Determines whether a path is absolute or not.\n\n    Examples:\n    On POSIX, an absolute path starts at the root directory.\n    (In fact, $(D _isAbsolute) is just an alias for $(LREF isRooted).)\n    ---\n    version (Posix)\n    {\n        assert (isAbsolute(\"\/\"));\n        assert (isAbsolute(\"\/foo\"));\n        assert (!isAbsolute(\"foo\"));\n        assert (!isAbsolute(\"..\/foo\"));\n    }\n    ---\n\n    On Windows, an absolute path starts at the root directory of\n    a specific drive.  Hence, it must start with $(D \"d:\\\") or $(D \"d:\/\"),\n    where $(D d) is the drive letter.  Alternatively, it may be a\n    network path, i.e. a path starting with a double (back)slash.\n    ---\n    version (Windows)\n    {\n        assert (isAbsolute(`d:\\`));\n        assert (isAbsolute(`d:\\foo`));\n        assert (isAbsolute(`\\\\foo\\bar`));\n        assert (!isAbsolute(`\\`));\n        assert (!isAbsolute(`\\foo`));\n        assert (!isAbsolute(\"d:foo\"));\n    }\n    ---\n",
"line" : 1730}
,
{
"name" : "absolutePath",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe string(string path, lazy string base = getcwd())",
"comment" : " Translates $(D path) into an absolute _path.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is empty, return $(D null).)\n        $(LI If $(D path) is already absolute, return it.)\n        $(LI Otherwise, append $(D path) to $(D base) and return\n            the result. If $(D base) is not specified, the current\n            working directory is used.)\n    )\n    The function allocates memory if and only if it gets to the third stage\n    of this algorithm.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (absolutePath(\"some\/file\", \"\/foo\/bar\")  == \"\/foo\/bar\/some\/file\");\n        assert (absolutePath(\"..\/file\", \"\/foo\/bar\")    == \"\/foo\/bar\/..\/file\");\n        assert (absolutePath(\"\/some\/file\", \"\/foo\/bar\") == \"\/some\/file\");\n    }\n\n    version (Windows)\n    {\n        assert (absolutePath(`some\\file`, `c:\\foo\\bar`)    == `c:\\foo\\bar\\some\\file`);\n        assert (absolutePath(`..\\file`, `c:\\foo\\bar`)      == `c:\\foo\\bar\\..\\file`);\n        assert (absolutePath(`c:\\some\\file`, `c:\\foo\\bar`) == `c:\\some\\file`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
"line" : 1795}
,
{
"name" : "relativePath(CaseSensitive cs = CaseSensitive.osDefault)",
"kind" : "template",
"protection" : "public",
"comment" : " Translates $(D path) into a relative _path.\n\n    The returned _path is relative to $(D base), which is by default\n    taken to be the current working directory.  If specified,\n    $(D base) must be an absolute _path, and it is always assumed\n    to refer to a directory.  If $(D path) and $(D base) refer to\n    the same directory, the function returns $(D \".\").\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is a relative directory, return it unaltered.)\n        $(LI Find a common root between $(D path) and $(D base).\n            If there is no common root, return $(D path) unaltered.)\n        $(LI Prepare a string with as many $(D \"..\/\") or $(D \"..\\\") as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of $(D path) to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    The function allocates memory if and only if it reaches the third stage\n    of the above algorithm.\n\n    Examples:\n    ---\n    assert (relativePath(\"foo\") == \"foo\");\n\n    version (Posix)\n    {\n        assert (relativePath(\"foo\", \"\/bar\") == \"foo\");\n        assert (relativePath(\"\/foo\/bar\", \"\/foo\/bar\") == \".\");\n        assert (relativePath(\"\/foo\/bar\", \"\/foo\/baz\") == \"..\/bar\");\n        assert (relativePath(\"\/foo\/bar\/baz\", \"\/foo\/woo\/wee\") == \"..\/..\/bar\/baz\");\n        assert (relativePath(\"\/foo\/bar\/baz\", \"\/foo\/bar\") == \"baz\");\n    }\n    version (Windows)\n    {\n        assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n        assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
"line" : 1884,
"members" : [
{
"name" : "relativePath",
"kind" : "function",
"type" : "string(string path, lazy string base = getcwd())",
"comment" : " Translates $(D path) into a relative _path.\n\n    The returned _path is relative to $(D base), which is by default\n    taken to be the current working directory.  If specified,\n    $(D base) must be an absolute _path, and it is always assumed\n    to refer to a directory.  If $(D path) and $(D base) refer to\n    the same directory, the function returns $(D \".\").\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is a relative directory, return it unaltered.)\n        $(LI Find a common root between $(D path) and $(D base).\n            If there is no common root, return $(D path) unaltered.)\n        $(LI Prepare a string with as many $(D \"..\/\") or $(D \"..\\\") as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of $(D path) to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    The function allocates memory if and only if it reaches the third stage\n    of the above algorithm.\n\n    Examples:\n    ---\n    assert (relativePath(\"foo\") == \"foo\");\n\n    version (Posix)\n    {\n        assert (relativePath(\"foo\", \"\/bar\") == \"foo\");\n        assert (relativePath(\"\/foo\/bar\", \"\/foo\/bar\") == \".\");\n        assert (relativePath(\"\/foo\/bar\", \"\/foo\/baz\") == \"..\/bar\");\n        assert (relativePath(\"\/foo\/bar\/baz\", \"\/foo\/woo\/wee\") == \"..\/..\/bar\/baz\");\n        assert (relativePath(\"\/foo\/bar\/baz\", \"\/foo\/bar\") == \"baz\");\n    }\n    version (Windows)\n    {\n        assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n        assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
"line" : 1884}
]
}
,
{
"name" : "filenameCharCmp(CaseSensitive cs = CaseSensitive.osDefault)",
"kind" : "template",
"protection" : "public",
"comment" : " Compares filename characters and return $(D < 0) if $(D a < b), $(D 0) if\n    $(D a == b) and $(D > 0) if $(D a > b).\n\n    This function can perform a case-sensitive or a case-insensitive\n    comparison.  This is controlled through the $(D cs) template parameter\n    which, if not specified, is given by\n    $(LREF CaseSensitive)$(D .osDefault).\n\n    On Windows, the backslash and slash characters ($(D '\\') and $(D '\/'))\n    are considered equal.\n\n    Examples:\n    ---\n    assert (filenameCharCmp('a', 'a') == 0);\n    assert (filenameCharCmp('a', 'b') < 0);\n    assert (filenameCharCmp('b', 'a') > 0);\n\n    version (linux)\n    {\n        \/\/ Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n        assert (filenameCharCmp('A', 'a') < 0);\n        assert (filenameCharCmp('a', 'A') > 0);\n    }\n    version (Windows)\n    {\n        \/\/ Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n        assert (filenameCharCmp('a', 'A') == 0);\n        assert (filenameCharCmp('a', 'B') < 0);\n        assert (filenameCharCmp('A', 'b') < 0);\n    }\n    ---\n",
"line" : 2002,
"members" : [
{
"name" : "filenameCharCmp",
"kind" : "function",
"type" : "pure nothrow @safe int(dchar a, dchar b)",
"comment" : " Compares filename characters and return $(D < 0) if $(D a < b), $(D 0) if\n    $(D a == b) and $(D > 0) if $(D a > b).\n\n    This function can perform a case-sensitive or a case-insensitive\n    comparison.  This is controlled through the $(D cs) template parameter\n    which, if not specified, is given by\n    $(LREF CaseSensitive)$(D .osDefault).\n\n    On Windows, the backslash and slash characters ($(D '\\') and $(D '\/'))\n    are considered equal.\n\n    Examples:\n    ---\n    assert (filenameCharCmp('a', 'a') == 0);\n    assert (filenameCharCmp('a', 'b') < 0);\n    assert (filenameCharCmp('b', 'a') > 0);\n\n    version (linux)\n    {\n        \/\/ Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n        assert (filenameCharCmp('A', 'a') < 0);\n        assert (filenameCharCmp('a', 'A') > 0);\n    }\n    version (Windows)\n    {\n        \/\/ Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n        assert (filenameCharCmp('a', 'A') == 0);\n        assert (filenameCharCmp('a', 'B') < 0);\n        assert (filenameCharCmp('A', 'b') < 0);\n    }\n    ---\n",
"line" : 2002}
]
}
,
{
"name" : "filenameCmp(CaseSensitive cs = CaseSensitive.osDefault,C1,C2) if (isSomeChar!(C1) && isSomeChar!(C2))",
"kind" : "template",
"protection" : "public",
"comment" : " Compares file names and returns\n    $(D < 0) if $(D filename1 < filename2),\n    $(D 0) if $(D filename1 == filename2) and\n    $(D > 0) if $(D filename1 > filename2).\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (filenameCmp(\"abc\", \"abc\") == 0);\n    assert (filenameCmp(\"abc\", \"abd\") < 0);\n    assert (filenameCmp(\"abc\", \"abb\") > 0);\n    assert (filenameCmp(\"abc\", \"abcd\") < 0);\n    assert (filenameCmp(\"abcd\", \"abc\") > 0);\n\n    version (linux)\n    {\n        \/\/ Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") < 0);\n        assert (filenameCmp(\"abc\", \"Abc\") > 0);\n    }\n    version (Windows)\n    {\n        \/\/ Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") == 0);\n        assert (filenameCmp(\"abc\", \"Abc\") == 0);\n        assert (filenameCmp(\"Abc\", \"abD\") < 0);\n        assert (filenameCmp(\"abc\", \"AbB\") > 0);\n    }\n    ---\n",
"line" : 2075,
"members" : [
{
"name" : "filenameCmp",
"kind" : "function",
"type" : "pure @safe int(const(C1)[] filename1, const(C2)[] filename2)",
"comment" : " Compares file names and returns\n    $(D < 0) if $(D filename1 < filename2),\n    $(D 0) if $(D filename1 == filename2) and\n    $(D > 0) if $(D filename1 > filename2).\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (filenameCmp(\"abc\", \"abc\") == 0);\n    assert (filenameCmp(\"abc\", \"abd\") < 0);\n    assert (filenameCmp(\"abc\", \"abb\") > 0);\n    assert (filenameCmp(\"abc\", \"abcd\") < 0);\n    assert (filenameCmp(\"abcd\", \"abc\") > 0);\n\n    version (linux)\n    {\n        \/\/ Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") < 0);\n        assert (filenameCmp(\"abc\", \"Abc\") > 0);\n    }\n    version (Windows)\n    {\n        \/\/ Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") == 0);\n        assert (filenameCmp(\"abc\", \"Abc\") == 0);\n        assert (filenameCmp(\"Abc\", \"abD\") < 0);\n        assert (filenameCmp(\"abc\", \"AbB\") > 0);\n    }\n    ---\n",
"line" : 2075}
]
}
,
{
"name" : "globMatch(CaseSensitive cs = CaseSensitive.osDefault,C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Matches a pattern against a path.\n\n    Some characters of pattern have a special meaning (they are\n    $(I meta-characters)) and can't be escaped. These are:\n\n    $(BOOKTABLE,\n    $(TR $(TD $(D *))\n         $(TD Matches 0 or more instances of any character.))\n    $(TR $(TD $(D ?))\n         $(TD Matches exactly one instance of any character.))\n    $(TR $(TD $(D [)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that appears\n              between the brackets.))\n    $(TR $(TD $(D [!)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that does not\n              appear between the brackets after the exclamation mark.))\n    $(TR $(TD $(D {)$(I string1)$(D ,)$(I string2)$(D ,)&hellip;$(D }))\n         $(TD Matches either of the specified strings.))\n    )\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Note that directory\n    separators and dots don't stop a meta-character from matching\n    further portions of the path.\n\n    Returns:\n    $(D true) if pattern matches path, $(D false) otherwise.\n\n    See_also:\n    $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Glob_%28programming%29,Wikipedia: _glob (programming))\n\n    Examples:\n    -----\n    assert (globMatch(\"foo.bar\", \"*\"));\n    assert (globMatch(\"foo.bar\", \"*.*\"));\n    assert (globMatch(`foo\/foo\\bar`, \"f*b*r\"));\n    assert (globMatch(\"foo.bar\", \"f???bar\"));\n    assert (globMatch(\"foo.bar\", \"[fg]???bar\"));\n    assert (globMatch(\"foo.bar\", \"[!gh]*bar\"));\n    assert (globMatch(\"bar.fooz\", \"bar.{foo,bif}z\"));\n    assert (globMatch(\"bar.bifz\", \"bar.{foo,bif}z\"));\n\n    version (Windows)\n    {\n        \/\/ Same as calling globMatch!(CaseSensitive.no)(path, pattern)\n        assert (globMatch(\"foo\", \"Foo\"));\n        assert (globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    version (linux)\n    {\n        \/\/ Same as calling globMatch!(CaseSensitive.yes)(path, pattern)\n        assert (!globMatch(\"foo\", \"Foo\"));\n        assert (!globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    -----\n \n",
"line" : 2180,
"members" : [
{
"name" : "globMatch",
"kind" : "function",
"type" : "pure nothrow @safe bool(const(C)[] path, const(C)[] pattern)",
"comment" : " Matches a pattern against a path.\n\n    Some characters of pattern have a special meaning (they are\n    $(I meta-characters)) and can't be escaped. These are:\n\n    $(BOOKTABLE,\n    $(TR $(TD $(D *))\n         $(TD Matches 0 or more instances of any character.))\n    $(TR $(TD $(D ?))\n         $(TD Matches exactly one instance of any character.))\n    $(TR $(TD $(D [)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that appears\n              between the brackets.))\n    $(TR $(TD $(D [!)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that does not\n              appear between the brackets after the exclamation mark.))\n    $(TR $(TD $(D {)$(I string1)$(D ,)$(I string2)$(D ,)&hellip;$(D }))\n         $(TD Matches either of the specified strings.))\n    )\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Note that directory\n    separators and dots don't stop a meta-character from matching\n    further portions of the path.\n\n    Returns:\n    $(D true) if pattern matches path, $(D false) otherwise.\n\n    See_also:\n    $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Glob_%28programming%29,Wikipedia: _glob (programming))\n\n    Examples:\n    -----\n    assert (globMatch(\"foo.bar\", \"*\"));\n    assert (globMatch(\"foo.bar\", \"*.*\"));\n    assert (globMatch(`foo\/foo\\bar`, \"f*b*r\"));\n    assert (globMatch(\"foo.bar\", \"f???bar\"));\n    assert (globMatch(\"foo.bar\", \"[fg]???bar\"));\n    assert (globMatch(\"foo.bar\", \"[!gh]*bar\"));\n    assert (globMatch(\"bar.fooz\", \"bar.{foo,bif}z\"));\n    assert (globMatch(\"bar.bifz\", \"bar.{foo,bif}z\"));\n\n    version (Windows)\n    {\n        \/\/ Same as calling globMatch!(CaseSensitive.no)(path, pattern)\n        assert (globMatch(\"foo\", \"Foo\"));\n        assert (globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    version (linux)\n    {\n        \/\/ Same as calling globMatch!(CaseSensitive.yes)(path, pattern)\n        assert (!globMatch(\"foo\", \"Foo\"));\n        assert (!globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    -----\n \n",
"line" : 2180}
]
}
,
{
"name" : "isValidFilename(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Checks that the given file or directory name is valid.\n\n    This function returns $(D true) if and only if $(D filename) is not\n    empty, not too long, and does not contain invalid characters.\n\n    The maximum length of $(D filename) is given by the constant\n    $(D core.stdc.stdio.FILENAME_MAX).  (On Windows, this number is\n    defined as the maximum number of UTF-16 code points, and the\n    test will therefore only yield strictly correct results when\n    $(D filename) is a string of $(D wchar)s.)\n\n    On Windows, the following criteria must be satisfied\n    ($(LINK2 http:\/\/msdn.microsoft.com\/en-us\/library\/aa365247(v=vs.85).aspx,source)):\n    $(UL\n        $(LI $(D filename) must not contain any characters whose integer\n            representation is in the range 0-31.)\n        $(LI $(D filename) must not contain any of the following $(I reserved\n            characters): <>:\"\/\\|?*)\n        $(LI $(D filename) may not end with a space ($(D ' ')) or a period\n            ($(D '.')).)\n    )\n\n    On POSIX, $(D filename) may not contain a forward slash ($(D '\/')) or\n    the null character ($(D '\\0')).\n",
"line" : 2372,
"members" : [
{
"name" : "isValidFilename",
"kind" : "function",
"type" : "pure nothrow @safe bool(in C[] filename)",
"comment" : " Checks that the given file or directory name is valid.\n\n    This function returns $(D true) if and only if $(D filename) is not\n    empty, not too long, and does not contain invalid characters.\n\n    The maximum length of $(D filename) is given by the constant\n    $(D core.stdc.stdio.FILENAME_MAX).  (On Windows, this number is\n    defined as the maximum number of UTF-16 code points, and the\n    test will therefore only yield strictly correct results when\n    $(D filename) is a string of $(D wchar)s.)\n\n    On Windows, the following criteria must be satisfied\n    ($(LINK2 http:\/\/msdn.microsoft.com\/en-us\/library\/aa365247(v=vs.85).aspx,source)):\n    $(UL\n        $(LI $(D filename) must not contain any characters whose integer\n            representation is in the range 0-31.)\n        $(LI $(D filename) must not contain any of the following $(I reserved\n            characters): <>:\"\/\\|?*)\n        $(LI $(D filename) may not end with a space ($(D ' ')) or a period\n            ($(D '.')).)\n    )\n\n    On POSIX, $(D filename) may not contain a forward slash ($(D '\/')) or\n    the null character ($(D '\\0')).\n",
"line" : 2372}
]
}
,
{
"name" : "isValidPath(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " Checks whether $(D path) is a valid _path.\n\n    Generally, this function checks that $(D path) is not empty, and that\n    each component of the path either satisfies $(LREF isValidFilename)\n    or is equal to $(D \".\") or $(D \"..\").\n    It does $(I not) check whether the _path points to an existing file\n    or directory; use $(XREF file,exists) for this purpose.\n\n    On Windows, some special rules apply:\n    $(UL\n        $(LI If the second character of $(D path) is a colon ($(D ':')),\n            the first character is interpreted as a drive letter, and\n            must be in the range A-Z (case insensitive).)\n        $(LI If $(D path) is on the form $(D `\\\\$(I server)\\$(I share)\\...`)\n            (UNC path), $(LREF isValidFilename) is applied to $(I server)\n            and $(I share) as well.)\n        $(LI If $(D path) starts with $(D `\\\\?\\`) (long UNC path), the\n            only requirement for the rest of the string is that it does\n            not contain the null character.)\n        $(LI If $(D path) starts with $(D `\\\\.\\`) (Win32 device namespace)\n            this function returns $(D false); such paths are beyond the scope\n            of this module.)\n    )\n",
"line" : 2461,
"members" : [
{
"name" : "isValidPath",
"kind" : "function",
"type" : "pure nothrow @safe bool(in C[] path)",
"comment" : " Checks whether $(D path) is a valid _path.\n\n    Generally, this function checks that $(D path) is not empty, and that\n    each component of the path either satisfies $(LREF isValidFilename)\n    or is equal to $(D \".\") or $(D \"..\").\n    It does $(I not) check whether the _path points to an existing file\n    or directory; use $(XREF file,exists) for this purpose.\n\n    On Windows, some special rules apply:\n    $(UL\n        $(LI If the second character of $(D path) is a colon ($(D ':')),\n            the first character is interpreted as a drive letter, and\n            must be in the range A-Z (case insensitive).)\n        $(LI If $(D path) is on the form $(D `\\\\$(I server)\\$(I share)\\...`)\n            (UNC path), $(LREF isValidFilename) is applied to $(I server)\n            and $(I share) as well.)\n        $(LI If $(D path) starts with $(D `\\\\?\\`) (long UNC path), the\n            only requirement for the rest of the string is that it does\n            not contain the null character.)\n        $(LI If $(D path) starts with $(D `\\\\.\\`) (Win32 device namespace)\n            this function returns $(D false); such paths are beyond the scope\n            of this module.)\n    )\n",
"line" : 2461}
]
}
,
{
"name" : "expandTilde",
"kind" : "function",
"protection" : "public",
"type" : "string(string inputPath)",
"comment" : " Performs tilde expansion in paths on POSIX systems.\n    On Windows, this function does nothing.\n\n    There are two ways of using tilde expansion in a path. One\n    involves using the tilde alone or followed by a path separator. In\n    this case, the tilde will be expanded with the value of the\n    environment variable $(D HOME).  The second way is putting\n    a username after the tilde (i.e. $(D ~john\/Mail)). Here,\n    the username will be searched for in the user database\n    (i.e. $(D \/etc\/passwd) on Unix systems) and will expand to\n    whatever path is stored there.  The username is considered the\n    string after the tilde ending at the first instance of a path\n    separator.\n\n    Note that using the $(D ~user) syntax may give different\n    values from just $(D ~) if the environment variable doesn't\n    match the value stored in the user database.\n\n    When the environment variable version is used, the path won't\n    be modified if the environment variable doesn't exist or it\n    is empty. When the database version is used, the path won't be\n    modified if the user doesn't exist in the database or there is\n    not enough memory to perform the query.\n\n    This function performs several memory allocations.\n\n    Returns:\n    $(D inputPath) with the tilde expanded, or just $(D inputPath)\n    if it could not be expanded.\n    For Windows, $(D expandTilde) merely returns its argument $(D inputPath).\n\n    Examples:\n    -----\n    void processFile(string path)\n    {\n        \/\/ Allow calling this function with paths such as ~\/foo\n        auto fullPath = expandTilde(path);\n        ...\n    }\n    -----\n",
"line" : 2630}
,
{
"name" : "sep",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2855}
,
{
"name" : "altsep",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2858}
,
{
"name" : "pathsep",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2861}
,
{
"name" : "linesep",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2864}
,
{
"name" : "curdir",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2865}
,
{
"name" : "pardir",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 2866}
,
{
"name" : "isSep",
"kind" : "function",
"protection" : "private",
"type" : "bool(dchar ch)",
"line" : 2868}
,
{
"name" : "fcmp(alias pred = \"a < b\",S1,S2) if (isSomeString!(S1) && isSomeString!(S2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF filenameCmp) instead.)\n\n Compare file names.\n Returns:\n      <table border=1 cellpadding=4 cellspacing=0>\n      <tr> <td> &lt; 0        <td> filename1 &lt; filename2\n      <tr> <td> = 0   <td> filename1 == filename2\n      <tr> <td> &gt; 0        <td> filename1 &gt; filename2\n      <\/table>\n \n",
"line" : 2885,
"members" : [
{
"name" : "fcmp",
"kind" : "function",
"type" : "int(S1 s1, S2 s2)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF filenameCmp) instead.)\n\n Compare file names.\n Returns:\n      <table border=1 cellpadding=4 cellspacing=0>\n      <tr> <td> &lt; 0        <td> filename1 &lt; filename2\n      <tr> <td> = 0   <td> filename1 == filename2\n      <tr> <td> &gt; 0        <td> filename1 &gt; filename2\n      <\/table>\n \n",
"line" : 2885}
]
}
,
{
"name" : "getExt()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF extension) instead.)\n\n Extracts the extension from a filename or path.\n\n This function will search fullname from the end until the\n first dot, path separator or first character of fullname is\n reached. Under Windows, the drive letter separator (<i>colon<\/i>)\n also terminates the search.\n\n Returns: If a dot was found, characters to its right are\n returned. If a path separator was found, or fullname didn't\n contain any dots or path separators, returns null.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     getExt(r\"d:\\path\\foo.bat\") \/\/ \"bat\"\n     getExt(r\"d:\\path.two\\bar\") \/\/ null\n }\n version(Posix)\n {\n     getExt(r\"\/home\/user.name\/bar.\")  \/\/ \"\"\n     getExt(r\"d:\\\\path.two\\\\bar\")     \/\/ \"two\\\\bar\"\n     getExt(r\"\/home\/user\/.resource\")  \/\/ \"resource\"\n }\n -----\n \n",
"line" : 2925,
"members" : [
{
"name" : "getExt",
"kind" : "function",
"type" : "string(string fullname)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF extension) instead.)\n\n Extracts the extension from a filename or path.\n\n This function will search fullname from the end until the\n first dot, path separator or first character of fullname is\n reached. Under Windows, the drive letter separator (<i>colon<\/i>)\n also terminates the search.\n\n Returns: If a dot was found, characters to its right are\n returned. If a path separator was found, or fullname didn't\n contain any dots or path separators, returns null.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     getExt(r\"d:\\path\\foo.bat\") \/\/ \"bat\"\n     getExt(r\"d:\\path.two\\bar\") \/\/ null\n }\n version(Posix)\n {\n     getExt(r\"\/home\/user.name\/bar.\")  \/\/ \"\"\n     getExt(r\"d:\\\\path.two\\\\bar\")     \/\/ \"two\\\\bar\"\n     getExt(r\"\/home\/user\/.resource\")  \/\/ \"resource\"\n }\n -----\n \n",
"line" : 2925}
]
}
,
{
"name" : "getName()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF stripExtension) instead.)\n\n Returns the extensionless version of a filename or path.\n\n This function will search fullname from the end until the\n first dot, path separator or first character of fullname is\n reached. Under Windows, the drive letter separator (<i>colon<\/i>)\n also terminates the search.\n\n Returns: If a dot was found, characters to its left are\n returned. If a path separator was found, or fullname didn't\n contain any dots or path separators, returns null.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     getName(r\"d:\\path\\foo.bat\") => \"d:\\path\\foo\"\n     getName(r\"d:\\path.two\\bar\") => null\n }\n version(Posix)\n {\n     getName(\"\/home\/user.name\/bar.\")  => \"\/home\/user.name\/bar\"\n     getName(r\"d:\\path.two\\bar\") => \"d:\\path\"\n     getName(\"\/home\/user\/.resource\") => \"\/home\/user\/\"\n }\n -----\n \n",
"line" : 3023,
"members" : [
{
"name" : "getName",
"kind" : "function",
"type" : "string(string fullname)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF stripExtension) instead.)\n\n Returns the extensionless version of a filename or path.\n\n This function will search fullname from the end until the\n first dot, path separator or first character of fullname is\n reached. Under Windows, the drive letter separator (<i>colon<\/i>)\n also terminates the search.\n\n Returns: If a dot was found, characters to its left are\n returned. If a path separator was found, or fullname didn't\n contain any dots or path separators, returns null.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     getName(r\"d:\\path\\foo.bat\") => \"d:\\path\\foo\"\n     getName(r\"d:\\path.two\\bar\") => null\n }\n version(Posix)\n {\n     getName(\"\/home\/user.name\/bar.\")  => \"\/home\/user.name\/bar\"\n     getName(r\"d:\\path.two\\bar\") => \"d:\\path\"\n     getName(\"\/home\/user\/.resource\") => \"\/home\/user\/\"\n }\n -----\n \n",
"line" : 3023}
]
}
,
{
"name" : "basename(Char,ExtChar = immutable(char)) if (isSomeChar!(Char) && isSomeChar!(ExtChar))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF baseName) instead.)\n\n Extracts the base name of a path and optionally chops off a\n specific suffix.\n\n This function will search $(D_PARAM fullname) from the end until\n the first path separator or first character of $(D_PARAM fullname)\n is reached. Under Windows, the drive letter separator ($(I colon))\n also terminates the search. After the search has ended, keep the\n portion to the right of the separator if found, or the entire\n $(D_PARAM fullname) otherwise. If the kept portion has suffix\n $(D_PARAM extension), remove that suffix. Return the remaining string.\n\n Returns: The portion of $(D_PARAM fullname) left after the path\n part and the extension part, if any, have been removed.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     basename(r\"d:\\path\\foo.bat\") => \"foo.bat\"\n     basename(r\"d:\\path\\foo\", \".bat\") => \"foo\"\n }\n version(Posix)\n {\n     basename(\"\/home\/user.name\/bar.\")  => \"bar.\"\n     basename(\"\/home\/user.name\/bar.\", \".\")  => \"bar\"\n }\n -----\n \n",
"line" : 3101,
"members" : [
{
"name" : "basename",
"kind" : "function",
"type" : "Char[](Char[] fullname, ExtChar[] extension = null)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF baseName) instead.)\n\n Extracts the base name of a path and optionally chops off a\n specific suffix.\n\n This function will search $(D_PARAM fullname) from the end until\n the first path separator or first character of $(D_PARAM fullname)\n is reached. Under Windows, the drive letter separator ($(I colon))\n also terminates the search. After the search has ended, keep the\n portion to the right of the separator if found, or the entire\n $(D_PARAM fullname) otherwise. If the kept portion has suffix\n $(D_PARAM extension), remove that suffix. Return the remaining string.\n\n Returns: The portion of $(D_PARAM fullname) left after the path\n part and the extension part, if any, have been removed.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     basename(r\"d:\\path\\foo.bat\") => \"foo.bat\"\n     basename(r\"d:\\path\\foo\", \".bat\") => \"foo\"\n }\n version(Posix)\n {\n     basename(\"\/home\/user.name\/bar.\")  => \"bar.\"\n     basename(\"\/home\/user.name\/bar.\", \".\")  => \"bar\"\n }\n -----\n \n",
"line" : 3101}
]
}
,
{
"name" : "getBaseName",
"kind" : "alias",
"protection" : "public",
"line" : 3134}
,
{
"name" : "dirname(Char) if (isSomeChar!(Char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF dirName) instead.)\n\n Extracts the directory part of a path.\n\n This function will search $(D fullname) from the end until the\n first path separator or first character of $(D fullname) is\n reached. Under Windows, the drive letter separator ($(I colon))\n also terminates the search.\n\n Returns: If a path separator was found, all the characters to its\n left without any trailing path separators are returned. Otherwise,\n $(D \".\") is returned.\n\n The found path separator will be included in the returned string\n if and only if it represents the root.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     assert(dirname(r\"d:\\path\\foo.bat\") == r\"d:\\path\");\n     assert(dirname(r\"d:\\path\") == r\"d:\\\");\n     assert(dirname(\"d:foo.bat\") == \"d:.\");\n     assert(dirname(\"foo.bat\") == \".\");\n }\n version(Posix)\n {\n     assert(dirname(\"\/home\/user\") == \"\/home\");\n     assert(dirname(\"\/home\") == \"\/\");\n     assert(dirname(\"user\") == \".\");\n }\n -----\n \n",
"line" : 3211,
"members" : [
{
"name" : "dirname",
"kind" : "function",
"type" : "Char[](Char[] fullname)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF dirName) instead.)\n\n Extracts the directory part of a path.\n\n This function will search $(D fullname) from the end until the\n first path separator or first character of $(D fullname) is\n reached. Under Windows, the drive letter separator ($(I colon))\n also terminates the search.\n\n Returns: If a path separator was found, all the characters to its\n left without any trailing path separators are returned. Otherwise,\n $(D \".\") is returned.\n\n The found path separator will be included in the returned string\n if and only if it represents the root.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     assert(dirname(r\"d:\\path\\foo.bat\") == r\"d:\\path\");\n     assert(dirname(r\"d:\\path\") == r\"d:\\\");\n     assert(dirname(\"d:foo.bat\") == \"d:.\");\n     assert(dirname(\"foo.bat\") == \".\");\n }\n version(Posix)\n {\n     assert(dirname(\"\/home\/user\") == \"\/home\");\n     assert(dirname(\"\/home\") == \"\/\");\n     assert(dirname(\"user\") == \".\");\n }\n -----\n \n",
"line" : 3211}
]
}
,
{
"name" : "getDirName",
"kind" : "alias",
"protection" : "public",
"line" : 3330}
,
{
"name" : "getDrive(Char) if (isSomeChar!(Char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF driveName) instead.)\n\n Extracts the drive letter of a path.\n\n This function will search fullname for a colon from the beginning.\n\n Returns: If a colon is found, all the characters to its left\n plus the colon are returned.  Otherwise, null is returned.\n\n Under Linux, this function always returns null immediately.\n\n Throws: Nothing.\n\n Examples:\n -----\n getDrive(r\"d:\\path\\foo.bat\") => \"d:\"\n -----\n \n",
"line" : 3430,
"members" : [
{
"name" : "getDrive",
"kind" : "function",
"type" : "Char[](Char[] fullname)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF driveName) instead.)\n\n Extracts the drive letter of a path.\n\n This function will search fullname for a colon from the beginning.\n\n Returns: If a colon is found, all the characters to its left\n plus the colon are returned.  Otherwise, null is returned.\n\n Under Linux, this function always returns null immediately.\n\n Throws: Nothing.\n\n Examples:\n -----\n getDrive(r\"d:\\path\\foo.bat\") => \"d:\"\n -----\n \n",
"line" : 3430}
]
}
,
{
"name" : "defaultExt()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF defaultExtension) instead.)\n\n Appends a default extension to a filename.\n\n This function first searches filename for an extension and\n appends ext if there is none. ext should not have any leading\n dots, one will be inserted between filename and ext if filename\n doesn't already end with one.\n\n Returns: filename if it contains an extension, otherwise filename\n + ext.\n\n Throws: Nothing.\n\n Examples:\n -----\n defaultExt(\"foo.txt\", \"raw\") => \"foo.txt\"\n defaultExt(\"foo.\", \"raw\") => \"foo.raw\"\n defaultExt(\"bar\", \"raw\") => \"bar.raw\"\n -----\n \n",
"line" : 3480,
"members" : [
{
"name" : "defaultExt",
"kind" : "function",
"type" : "string(string filename, string ext)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF defaultExtension) instead.)\n\n Appends a default extension to a filename.\n\n This function first searches filename for an extension and\n appends ext if there is none. ext should not have any leading\n dots, one will be inserted between filename and ext if filename\n doesn't already end with one.\n\n Returns: filename if it contains an extension, otherwise filename\n + ext.\n\n Throws: Nothing.\n\n Examples:\n -----\n defaultExt(\"foo.txt\", \"raw\") => \"foo.txt\"\n defaultExt(\"foo.\", \"raw\") => \"foo.raw\"\n defaultExt(\"bar\", \"raw\") => \"bar.raw\"\n -----\n \n",
"line" : 3480}
]
}
,
{
"name" : "addExt()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF setExtension) instead.)\n\n Adds or replaces an extension to a filename.\n\n This function first searches filename for an extension and\n replaces it with ext if found.  If there is no extension, ext\n will be appended. ext should not have any leading dots, one will\n be inserted between filename and ext if filename doesn't already\n end with one.\n\n Returns: filename + ext if filename is extensionless. Otherwise\n strips filename's extension off, appends ext and returns the\n result.\n\n Throws: Nothing.\n\n Examples:\n -----\n addExt(\"foo.txt\", \"raw\") => \"foo.raw\"\n addExt(\"foo.\", \"raw\") => \"foo.raw\"\n addExt(\"bar\", \"raw\") => \"bar.raw\"\n -----\n \n",
"line" : 3523,
"members" : [
{
"name" : "addExt",
"kind" : "function",
"type" : "string(string filename, string ext)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF setExtension) instead.)\n\n Adds or replaces an extension to a filename.\n\n This function first searches filename for an extension and\n replaces it with ext if found.  If there is no extension, ext\n will be appended. ext should not have any leading dots, one will\n be inserted between filename and ext if filename doesn't already\n end with one.\n\n Returns: filename + ext if filename is extensionless. Otherwise\n strips filename's extension off, appends ext and returns the\n result.\n\n Throws: Nothing.\n\n Examples:\n -----\n addExt(\"foo.txt\", \"raw\") => \"foo.raw\"\n addExt(\"foo.\", \"raw\") => \"foo.raw\"\n addExt(\"bar\", \"raw\") => \"bar.raw\"\n -----\n \n",
"line" : 3523}
]
}
,
{
"name" : "isabs()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF isAbsolute) instead.)\n\n Checks if path is absolute.\n\n Returns: non-zero if the path starts from the root directory (Linux) or\n drive letter and root directory (Windows),\n zero otherwise.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     isabs(r\"relative\\path\") => 0\n     isabs(r\"\\relative\\path\") => 0\n     isabs(r\"d:\\absolute\") => 1\n }\n version(Posix)\n {\n     isabs(\"\/home\/user\") => 1\n     isabs(\"foo\") => 0\n }\n -----\n \n",
"line" : 3572,
"members" : [
{
"name" : "isabs",
"kind" : "function",
"type" : "bool(in char[] path)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF isAbsolute) instead.)\n\n Checks if path is absolute.\n\n Returns: non-zero if the path starts from the root directory (Linux) or\n drive letter and root directory (Windows),\n zero otherwise.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     isabs(r\"relative\\path\") => 0\n     isabs(r\"\\relative\\path\") => 0\n     isabs(r\"d:\\absolute\") => 1\n }\n version(Posix)\n {\n     isabs(\"\/home\/user\") => 1\n     isabs(\"foo\") => 0\n }\n -----\n \n",
"line" : 3572}
]
}
,
{
"name" : "rel2abs()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF absolutePath) instead.)\n\n Converts a relative path into an absolute path.\n \n",
"line" : 3612,
"members" : [
{
"name" : "rel2abs",
"kind" : "function",
"type" : "string(string path)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF absolutePath) instead.)\n\n Converts a relative path into an absolute path.\n \n",
"line" : 3612}
]
}
,
{
"name" : "join()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF buildPath) instead.)\n\n Joins two or more path components.\n\n If p1 doesn't have a trailing path separator, one will be appended\n to it before concatenating p2.\n\n Returns: p1 ~ p2. However, if p2 is an absolute path, only p2\n will be returned.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     join(r\"c:\\foo\", \"bar\") => r\"c:\\foo\\bar\"\n     join(\"foo\", r\"d:\\bar\") => r\"d:\\bar\"\n }\n version(Posix)\n {\n     join(\"\/foo\/\", \"bar\") => \"\/foo\/bar\"\n     join(\"\/foo\", \"\/bar\") => \"\/bar\"\n }\n -----\n \n",
"line" : 3678,
"members" : [
{
"name" : "join",
"kind" : "function",
"type" : "string(const(char)[] p1, const(char)[] p2, const(char[])[] more...)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF buildPath) instead.)\n\n Joins two or more path components.\n\n If p1 doesn't have a trailing path separator, one will be appended\n to it before concatenating p2.\n\n Returns: p1 ~ p2. However, if p2 is an absolute path, only p2\n will be returned.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     join(r\"c:\\foo\", \"bar\") => r\"c:\\foo\\bar\"\n     join(\"foo\", r\"d:\\bar\") => r\"d:\\bar\"\n }\n version(Posix)\n {\n     join(\"\/foo\/\", \"bar\") => \"\/foo\/bar\"\n     join(\"\/foo\", \"\/bar\") => \"\/bar\"\n }\n -----\n \n",
"line" : 3678}
]
}
,
{
"name" : "fncharmatch()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF filenameCharCmp) instead.)\n\n Matches filename characters.\n\n Under Windows, the comparison is done ignoring case. Under Linux\n an exact match is performed.\n\n Returns: non zero if c1 matches c2, zero otherwise.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     fncharmatch('a', 'b') => 0\n     fncharmatch('A', 'a') => 1\n }\n version(Posix)\n {\n     fncharmatch('a', 'b') => 0\n     fncharmatch('A', 'a') => 0\n }\n -----\n \n",
"line" : 3870,
"members" : [
{
"name" : "fncharmatch",
"kind" : "function",
"type" : "bool(dchar c1, dchar c2)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF filenameCharCmp) instead.)\n\n Matches filename characters.\n\n Under Windows, the comparison is done ignoring case. Under Linux\n an exact match is performed.\n\n Returns: non zero if c1 matches c2, zero otherwise.\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     fncharmatch('a', 'b') => 0\n     fncharmatch('A', 'a') => 1\n }\n version(Posix)\n {\n     fncharmatch('a', 'b') => 0\n     fncharmatch('A', 'a') => 0\n }\n -----\n \n",
"line" : 3870}
]
}
,
{
"name" : "fnmatch()",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF globMatch) instead.)\n\n Matches a pattern against a filename.\n\n Some characters of pattern have special a meaning (they are\n <i>meta-characters<\/i>) and <b>can't<\/b> be escaped. These are:\n <p><table>\n <tr><td><b>*<\/b><\/td>\n     <td>Matches 0 or more instances of any character.<\/td><\/tr>\n <tr><td><b>?<\/b><\/td>\n     <td>Matches exactly one instances of any character.<\/td><\/tr>\n <tr><td><b>[<\/b><i>chars<\/i><b>]<\/b><\/td>\n     <td>Matches one instance of any character that appears\n     between the brackets.<\/td><\/tr>\n <tr><td><b>[!<\/b><i>chars<\/i><b>]<\/b><\/td>\n     <td>Matches one instance of any character that does not appear\n     between the brackets after the exclamation mark.<\/td><\/tr>\n <\/table><p>\n Internally individual character comparisons are done calling\n fncharmatch(), so its rules apply here too. Note that path\n separators and dots don't stop a meta-character from matching\n further portions of the filename.\n\n Returns: non zero if pattern matches filename, zero otherwise.\n\n See_Also: fncharmatch().\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     fnmatch(\"foo.bar\", \"*\") => 1\n     fnmatch(r\"foo\/foo\\bar\", \"f*b*r\") => 1\n     fnmatch(\"foo.bar\", \"f?bar\") => 0\n     fnmatch(\"Goo.bar\", \"[fg]???bar\") => 1\n     fnmatch(r\"d:\\foo\\bar\", \"d*foo?bar\") => 1\n }\n version(Posix)\n {\n     fnmatch(\"Go*.bar\", \"[fg]???bar\") => 0\n     fnmatch(\"\/foo*home\/bar\", \"?foo*bar\") => 1\n     fnmatch(\"foobar\", \"foo?bar\") => 1\n }\n -----\n \n",
"line" : 3943,
"members" : [
{
"name" : "fnmatch",
"kind" : "function",
"type" : "bool(const(char)[] filename, const(char)[] pattern)",
"comment" : "\n $(RED Deprecated. It will be removed in October 2012. Please use\n       $(LREF globMatch) instead.)\n\n Matches a pattern against a filename.\n\n Some characters of pattern have special a meaning (they are\n <i>meta-characters<\/i>) and <b>can't<\/b> be escaped. These are:\n <p><table>\n <tr><td><b>*<\/b><\/td>\n     <td>Matches 0 or more instances of any character.<\/td><\/tr>\n <tr><td><b>?<\/b><\/td>\n     <td>Matches exactly one instances of any character.<\/td><\/tr>\n <tr><td><b>[<\/b><i>chars<\/i><b>]<\/b><\/td>\n     <td>Matches one instance of any character that appears\n     between the brackets.<\/td><\/tr>\n <tr><td><b>[!<\/b><i>chars<\/i><b>]<\/b><\/td>\n     <td>Matches one instance of any character that does not appear\n     between the brackets after the exclamation mark.<\/td><\/tr>\n <\/table><p>\n Internally individual character comparisons are done calling\n fncharmatch(), so its rules apply here too. Note that path\n separators and dots don't stop a meta-character from matching\n further portions of the filename.\n\n Returns: non zero if pattern matches filename, zero otherwise.\n\n See_Also: fncharmatch().\n\n Throws: Nothing.\n\n Examples:\n -----\n version(Windows)\n {\n     fnmatch(\"foo.bar\", \"*\") => 1\n     fnmatch(r\"foo\/foo\\bar\", \"f*b*r\") => 1\n     fnmatch(\"foo.bar\", \"f?bar\") => 0\n     fnmatch(\"Goo.bar\", \"[fg]???bar\") => 1\n     fnmatch(r\"d:\\foo\\bar\", \"d*foo?bar\") => 1\n }\n version(Posix)\n {\n     fnmatch(\"Go*.bar\", \"[fg]???bar\") => 0\n     fnmatch(\"\/foo*home\/bar\", \"?foo*bar\") => 1\n     fnmatch(\"foobar\", \"foo?bar\") => 1\n }\n -----\n \n",
"line" : 3943}
]
}
]
}
,
{
"name" : "std.perf",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/perf.d",
"comment" : "\n Platform-independent performance measurement and timing classes.\n\n $(D_PARAM PerformanceCounter) is the main platform-independent timer class provided,\n covering the most typical use case, measuring elapsed wall-clock time.\n\n The module also provides several Windows-specific timers that can\n be useful in specialized situations.\n\n Synopsis:\n ----\nalias PerformanceCounter.interval_t interval_t;\nauto timer = new PerformanceCounter;\ntimer.start();\n\/\/ do computation\ntimer.stop();\ninterval_t elapsedMsec = timer.milliseconds;\nwritefln(\"Time elapsed: %s msec\", elapsedMsec);\n----\n In particular note that $(D_PARAM stop()) must be called\n before querying the elapsed time.\n\n These classes were ported to D from the\n $(LINK2 http:\/\/stlsoft.org\/,STLSoft C++ libraries),\n which were documented in the article\n \"$(LINK2 http:\/\/www.windevnet.com\/documents\/win0305a\/,\n Win32 Performance Measurement Options)\",\n May 2003 issue of Windows Develper Network.\n\n Author:\n Matthew Wilson\n\n Source:    $(PHOBOSSRC std\/_perf.d)\n\n Macros:\n      WIKI=Phobos\/StdPerf\n \n",
"members" : [
{
"name" : "timeval",
"kind" : "struct",
"protection" : "private",
"line" : 792,
"members" : [
{
"name" : "tv_sec",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 793}
,
{
"name" : "tv_usec",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 794}
]
}
,
{
"name" : "timezone",
"kind" : "struct",
"protection" : "private",
"line" : 797,
"members" : [
{
"name" : "tz_minuteswest",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 798}
,
{
"name" : "tz_dsttime",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 799}
]
}
,
{
"name" : "gettimeofday",
"kind" : "function",
"protection" : "private",
"type" : "extern (C) void(timeval* tv, timezone* tz)",
"line" : 801}
,
{
"name" : "PerformanceCounter",
"kind" : "class",
"protection" : "public",
"line" : 807,
"base" : "Object",
"members" : [
{
"name" : "epoch_type",
"kind" : "alias",
"protection" : "private",
"type" : "timeval",
"line" : 812}
,
{
"name" : "interval_t",
"kind" : "alias",
"protection" : "public",
"type" : "long",
"line" : 814}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 817}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 824}
,
{
"name" : "periodCount",
"kind" : "function",
"protection" : "public",
"type" : "const long()",
"line" : 832}
,
{
"name" : "seconds",
"kind" : "function",
"protection" : "public",
"type" : "const long()",
"line" : 837}
,
{
"name" : "milliseconds",
"kind" : "function",
"protection" : "public",
"type" : "const long()",
"line" : 845}
,
{
"name" : "microseconds",
"kind" : "function",
"protection" : "public",
"type" : "const long()",
"line" : 853}
,
{
"name" : "m_start",
"kind" : "variable",
"protection" : "private",
"type" : "timeval",
"line" : 862}
,
{
"name" : "m_end",
"kind" : "variable",
"protection" : "private",
"type" : "timeval",
"line" : 863}
]
}
]
}
,
{
"name" : "std.process",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/process.d",
"comment" : "\nMacros:\n\nWIKI=Phobos\/StdProcess\n\nCopyright: Copyright Digital Mars 2007 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           $(WEB thecybershadow.net, Vladimir Panteleev)\nSource:    $(PHOBOSSRC std\/_process.d)\n",
"members" : [
{
"name" : "environ",
"kind" : "variable",
"protection" : "private",
"type" : "const(char**)",
"line" : 75}
,
{
"name" : "system",
"kind" : "function",
"protection" : "public",
"type" : "int(string command)",
"comment" : "\n   Execute $(D command) in a _command shell.\n\n   Returns: If $(D command) is null, returns nonzero if the _command\n   interpreter is found, and zero otherwise. If $(D command) is not\n   null, returns -1 on error, or the exit status of command (which may\n   in turn signal an error in command's execution).\n\n   Note: On Unix systems, the homonym C function (which is accessible\n   to D programs as $(LINK2 std_c_process.html, std.c._system))\n   returns a code in the same format as $(LUCKY waitpid, waitpid),\n   meaning that C programs must use the $(D WEXITSTATUS) macro to\n   extract the actual exit code from the $(D system) call. D's $(D\n   system) automatically extracts the exit status.\n\n",
"line" : 97}
,
{
"name" : "toAStringz",
"kind" : "function",
"protection" : "private",
"type" : "void(const(immutable(char)[][]) a, const(char)** az)",
"line" : 117}
,
{
"name" : "P_WAIT",
"kind" : "alias",
"protection" : "public",
"line" : 143}
,
{
"name" : "P_NOWAIT",
"kind" : "alias",
"protection" : "public",
"line" : 144}
,
{
"name" : "spawnvp",
"kind" : "function",
"protection" : "public",
"type" : "int(int mode, string pathname, string[] argv)",
"line" : 146}
,
{
"name" : "_spawnvp",
"kind" : "function",
"protection" : "public",
"type" : "int(int mode, const(char*) pathname, const(char**) argv)",
"line" : 168}
,
{
"name" : "stopped",
"kind" : "alias",
"protection" : "private",
"line" : 220}
,
{
"name" : "signaled",
"kind" : "alias",
"protection" : "private",
"line" : 221}
,
{
"name" : "termsig",
"kind" : "alias",
"protection" : "private",
"line" : 222}
,
{
"name" : "exited",
"kind" : "alias",
"protection" : "private",
"line" : 223}
,
{
"name" : "exitstatus",
"kind" : "alias",
"protection" : "private",
"line" : 224}
,
{
"name" : "execv",
"kind" : "function",
"protection" : "public",
"type" : "int(const(immutable(char)[]) pathname, const(immutable(char)[][]) argv)",
"comment" : "\n Execute program specified by pathname, passing it the arguments (argv)\n and the environment (envp), returning the exit status.\n The 'p' versions of exec search the PATH environment variable\n setting for the program.\n \n",
"line" : 237}
,
{
"name" : "execve",
"kind" : "function",
"protection" : "public",
"type" : "int(const(immutable(char)[]) pathname, const(immutable(char)[][]) argv, const(immutable(char)[][]) envp)",
"comment" : " ditto \n",
"line" : 247}
,
{
"name" : "execvp",
"kind" : "function",
"protection" : "public",
"type" : "int(const(immutable(char)[]) pathname, const(immutable(char)[][]) argv)",
"comment" : " ditto \n",
"line" : 259}
,
{
"name" : "execvpe",
"kind" : "function",
"protection" : "public",
"type" : "int(const(immutable(char)[]) pathname, const(immutable(char)[][]) argv, const(immutable(char)[][]) envp)",
"comment" : " ditto \n",
"line" : 269}
,
{
"name" : "getpid",
"kind" : "alias",
"protection" : "public",
"comment" : "\n Returns the process ID of the calling process, which is guaranteed to be\n unique on the system. This call is always successful.\n\n Example:\n ---\n writefln(\"Current process id: %s\", getpid());\n ---\n \n",
"line" : 329}
,
{
"name" : "shell",
"kind" : "function",
"protection" : "public",
"type" : "string(string cmd)",
"comment" : "\n   Runs $(D_PARAM cmd) in a shell and returns its standard output. If\n   the process could not be started or exits with an error code,\n   throws an exception.\n\n   Example:\n\n   ----\n   auto tempFilename = chomp(shell(\"mcookie\"));\n   auto f = enforce(fopen(tempFilename), \"w\");\n   scope(exit)\n   {\n       fclose(f) == 0 || assert(false);\n       system(escapeShellCommand(\"rm\", tempFilename));\n   }\n   ... use f ...\n   ----\n",
"line" : 349}
,
{
"name" : "getenv",
"kind" : "function",
"protection" : "public",
"type" : "string(const(char[]) name)",
"comment" : "\nGets the value of environment variable $(D name) as a string. Calls\n$(LINK2 std_c_stdlib.html#_getenv, std.c.stdlib._getenv)\ninternally. \n",
"line" : 398}
,
{
"name" : "setenv",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name, const(char[]) value, bool overwrite)",
"comment" : "\nSets the value of environment variable $(D name) to $(D value). If the\nvalue was written, or the variable was already present and $(D\noverwrite) is false, returns normally. Otherwise, it throws an\nexception. Calls $(LINK2 std_c_stdlib.html#_setenv,\nstd.c.stdlib._setenv) internally. \n",
"line" : 416}
,
{
"name" : "unsetenv",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char[]) name)",
"comment" : "\nRemoves variable $(D name) from the environment. Calls $(LINK2\nstd_c_stdlib.html#_unsetenv, std.c.stdlib._unsetenv) internally. \n",
"line" : 426}
,
{
"name" : "environment",
"kind" : "alias",
"protection" : "public",
"type" : "std.process.Environment",
"comment" : " Manipulates environment variables using an associative-array-like\n    interface.\n\n    Examples:\n    ---\n    \/\/ Return variable, or throw an exception if it doesn't exist.\n    auto path = environment[\"PATH\"];\n\n    \/\/ Add\/replace variable.\n    environment[\"foo\"] = \"bar\";\n\n    \/\/ Remove variable.\n    environment.remove(\"foo\");\n\n    \/\/ Return variable, or null if it doesn't exist.\n    auto foo = environment.get(\"foo\");\n\n    \/\/ Return variable, or a default value if it doesn't exist.\n    auto foo = environment.get(\"foo\", \"default foo value\");\n\n    \/\/ Return an associative array of type string[string] containing\n    \/\/ all the environment variables.\n    auto aa = environment.toAA();\n    ---\n",
"line" : 508}
,
{
"name" : "Environment",
"kind" : "class",
"protection" : "public",
"line" : 511,
"base" : "Object",
"members" : [
{
"name" : "getImpl",
"kind" : "function",
"protection" : "private",
"type" : "bool(string name, out string value)",
"line" : 524}
,
{
"name" : "opIndex",
"kind" : "function",
"protection" : "public",
"type" : "string(string name)",
"line" : 559}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"protection" : "public",
"type" : "string(string value, string name)",
"line" : 570}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(string name)",
"line" : 605}
,
{
"name" : "get",
"kind" : "function",
"protection" : "public",
"type" : "string(string name, string defaultValue = null)",
"line" : 624}
,
{
"name" : "toAA",
"kind" : "function",
"protection" : "public",
"type" : "string[string]()",
"line" : 634}
]
}
,
{
"name" : "browse",
"kind" : "function",
"protection" : "public",
"type" : "void(string url)",
"line" : 798}
,
{
"name" : "charAllocator",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow @safe char[](ulong size)",
"line" : 850}
,
{
"name" : "escapeWindowsArgument",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow string(const(char[]) arg)",
"comment" : "\n    Quote an argument in a manner conforming to the behavior of\n    $(LINK2 http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/desktop\/bb776391(v=vs.85).aspx,\n    CommandLineToArgvW).\n",
"line" : 859}
,
{
"name" : "escapeWindowsArgumentImpl(alias allocator) if (is(typeof(allocator(size_t.init)[0] = (char).init)))",
"kind" : "template",
"protection" : "public",
"line" : 870,
"members" : [
{
"name" : "escapeWindowsArgumentImpl",
"kind" : "function",
"type" : "char[](in char[] arg)",
"line" : 870}
]
}
,
{
"name" : "escapePosixArgument",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow string(const(char[]) arg)",
"line" : 967}
,
{
"name" : "escapePosixArgumentImpl(alias allocator) if (is(typeof(allocator(size_t.init)[0] = (char).init)))",
"kind" : "template",
"protection" : "public",
"line" : 974,
"members" : [
{
"name" : "escapePosixArgumentImpl",
"kind" : "function",
"type" : "char[](in char[] arg)",
"line" : 974}
]
}
,
{
"name" : "escapeShellArgument(alias allocator)",
"kind" : "template",
"protection" : "public",
"line" : 1003,
"members" : [
{
"name" : "escapeShellArgument",
"kind" : "function",
"type" : "(in char[] arg)",
"line" : 1003}
]
}
,
{
"name" : "escapeShellArguments",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow string(const(char[][]) args)",
"line" : 1015}
,
{
"name" : "escapeWindowsShellCommand",
"kind" : "function",
"protection" : "public",
"type" : "string(const(char[]) command)",
"line" : 1038}
,
{
"name" : "escapeShellCommandString",
"kind" : "function",
"protection" : "private",
"type" : "string(string command)",
"line" : 1068}
,
{
"name" : "escapeShellCommand",
"kind" : "function",
"protection" : "public",
"type" : "string(const(char[][]) args...)",
"comment" : "\n    Escape an argv-style argument array to be used with the\n    $(D system) or $(D shell) functions.\n\n    Example:\n---\nstring url = \"http:\/\/dlang.org\/\";\nsystem(escapeShellCommand(\"wget\", url, \"-O\", \"dlang-index.html\"));\n---\n\n    Concatenate multiple $(D escapeShellCommand) and\n    $(D escapeShellFileName) results to use shell redirection or\n    piping operators.\n\n    Example:\n---\nsystem(\n    escapeShellCommand(\"curl\", \"http:\/\/dlang.org\/download.html\") ~\n    \"|\" ~\n    escapeShellCommand(\"grep\", \"-o\", `http:\/\/\\S*\\.zip`) ~\n    \">\" ~\n    escapeShellFileName(\"D download links.txt\"));\n---\n",
"line" : 1101}
,
{
"name" : "escapeShellFileName",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow string(const(char[]) fn)",
"comment" : "\n    Escape a filename to be used for shell redirection with\n    the $(D system) or $(D shell) functions.\n",
"line" : 1112}
]
}
,
{
"name" : "std.random",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/random.d",
"comment" : "\nFacilities for random number generation.\n\nThe new-style generator objects hold their own state so they are\nimmune of threading issues. The generators feature a number of\nwell-known and well-documented methods of generating random\nnumbers. An overall fast and reliable means to generate random numbers\nis the $(D_PARAM Mt19937) generator, which derives its name from\n\"$(LUCKY Mersenne Twister) with a period of 2 to the power of\n19937\". In memory-constrained situations, $(LUCKY linear congruential)\ngenerators such as $(D MinstdRand0) and $(D MinstdRand) might be\nuseful. The standard library provides an alias $(D_PARAM Random) for\nwhichever generator it considers the most fit for the target\nenvironment.\n\nExample:\n\n----\n\/\/ Generate a uniformly-distributed integer in the range [0, 14]\nauto i = uniform(0, 15);\n\/\/ Generate a uniformly-distributed real in the range [0, 100$(RPAREN)\n\/\/ using a specific random generator\nRandom gen;\nauto r = uniform(0.0L, 100.0L, gen);\n----\n\nIn addition to random number generators, this module features\ndistributions, which skew a generator's output statistical\ndistribution in various ways. So far the uniform distribution for\nintegers and real numbers have been implemented.\n\nSource:    $(PHOBOSSRC std\/_random.d)\n\nMacros:\n\nWIKI = Phobos\/StdRandom\n\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009, Joseph Rushton Wakeling 2012.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\n           Masahiro Nakagawa (Xorshift randome generator)\n           $(WEB braingam.es, Joseph Rushton Wakeling) (Algorithm D for random sampling)\nCredits:   The entire random number library architecture is derived from the\n           excellent $(WEB open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2007\/n2461.pdf, C++0X)\n           random number facility proposed by Jens Maurer and contributed to by\n           researchers at the Fermi laboratory(excluding Xorshift).\n",
"members" : [
{
"name" : "isUniformRNG(Rng,ElementType)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Test if Rng is a random-number generator. The overload\n taking a ElementType also makes sure that the Rng generates\n values of that type.\n\n A random-number generator has at least the following features:\n $(UL\n   $(LI it's an InputRange)\n   $(LI it has a 'bool isUniformRandom' field readable in CTFE)\n )\n \n",
"line" : 127,
"members" : [
{
"name" : "isUniformRNG",
"kind" : "variable",
"type" : "bool",
"line" : 129}
]
}
,
{
"name" : "isUniformRNG(Rng)",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n \n",
"line" : 140,
"members" : [
{
"name" : "isUniformRNG",
"kind" : "variable",
"type" : "bool",
"line" : 142}
]
}
,
{
"name" : "isSeedable(Rng,SeedType)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Test if Rng is seedable. The overload\n taking a SeedType also makes sure that the Rng can be seeded with SeedType.\n\n A seedable random-number generator has the following additional features:\n $(UL\n   $(LI it has a 'seed(ElementType)' function)\n )\n \n",
"line" : 158,
"members" : [
{
"name" : "isSeedable",
"kind" : "variable",
"type" : "bool",
"line" : 160}
]
}
,
{
"name" : "isSeedable(Rng)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 169,
"members" : [
{
"name" : "isSeedable",
"kind" : "variable",
"type" : "bool",
"line" : 171}
]
}
,
{
"name" : "LinearCongruentialEngine(UIntType,UIntType a,UIntType c,UIntType m) if (isUnsigned!(UIntType))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLinear Congruential generator.\n \n",
"line" : 249,
"members" : [
{
"name" : "LinearCongruentialEngine",
"kind" : "struct",
"protection" : "public",
"line" : 249,
"members" : [
{
"name" : "isUniformRandom",
"kind" : "variable",
"type" : "bool",
"comment" : "Mark this as a Rng\n",
"line" : 251}
,
{
"name" : "hasFixedRange",
"kind" : "variable",
"type" : "bool",
"comment" : " Does this generator have a fixed range? ($(D_PARAM true)).\n",
"line" : 253}
,
{
"name" : "min",
"kind" : "variable",
"type" : "UIntType",
"comment" : " Lowest generated value ($(D 1) if $(D c == 0), $(D 0) otherwise).\n",
"line" : 255}
,
{
"name" : "max",
"kind" : "variable",
"type" : "UIntType",
"comment" : " Highest generated value ($(D modulus - 1)).\n",
"line" : 257}
,
{
"name" : "multiplier",
"kind" : "variable",
"type" : "UIntType",
"comment" : "\nThe parameters of this distribution. The random number is $(D_PARAM x\n= (x * multipler + increment) % modulus).\n \n",
"line" : 262}
,
{
"name" : "increment",
"kind" : "variable",
"type" : "UIntType",
"comment" : "ditto\n",
"line" : 264}
,
{
"name" : "modulus",
"kind" : "variable",
"type" : "UIntType",
"comment" : "ditto\n",
"line" : 266}
,
{
"name" : "gcd",
"kind" : "function",
"type" : "ulong(ulong a, ulong b)",
"line" : 275}
,
{
"name" : "primeFactorsOnly",
"kind" : "function",
"type" : "ulong(ulong n)",
"line" : 286}
,
{
"name" : "properLinearCongruentialParameters",
"kind" : "function",
"type" : "bool(ulong m, ulong a, ulong c)",
"line" : 313}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(UIntType x0)",
"comment" : "\nConstructs a $(D_PARAM LinearCongruentialEngine) generator seeded with\n$(D x0).\n \n",
"line" : 348}
,
{
"name" : "seed",
"kind" : "function",
"type" : "void(UIntType x0 = 1)",
"comment" : "\n   (Re)seeds the generator.\n",
"line" : 356}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n   Advances the random sequence.\n",
"line" : 370}
,
{
"name" : "front",
"kind" : "function",
"type" : "UIntType()",
"comment" : "\n   Returns the current number in the random sequence.\n",
"line" : 406}
,
{
"name" : "save",
"kind" : "function",
"type" : "typeof(this)()",
"comment" : "\n",
"line" : 412}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"comment" : "\nAlways $(D false) (random generators are infinite ranges).\n \n",
"line" : 420}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(ref const LinearCongruentialEngine rhs)",
"comment" : "\n   Compares against $(D_PARAM rhs) for equality.\n \n",
"line" : 425}
,
{
"name" : "_x",
"kind" : "variable",
"type" : "UIntType",
"line" : 430}
]
}
]
}
,
{
"name" : "MinstdRand0",
"kind" : "alias",
"protection" : "public",
"type" : "LinearCongruentialEngine!(uint,16807,0,2147483647)",
"comment" : "\nDefine $(D_PARAM LinearCongruentialEngine) generators with well-chosen\nparameters. $(D MinstdRand0) implements Park and Miller's \"minimal\nstandard\" $(WEB\nwikipedia.org\/wiki\/Park%E2%80%93Miller_random_number_generator,\ngenerator) that uses 16807 for the multiplier. $(D MinstdRand)\nimplements a variant that has slightly better spectral behavior by\nusing the multiplier 48271. Both generators are rather simplistic.\n\nExample:\n\n----\n\/\/ seed with a constant\nauto rnd0 = MinstdRand0(1);\nauto n = rnd0.front; \/\/ same for each run\n\/\/ Seed with an unpredictable value\nrnd0.seed(unpredictableSeed);\nn = rnd0.front; \/\/ different across runs\n----\n \n",
"line" : 453}
,
{
"name" : "MinstdRand",
"kind" : "alias",
"protection" : "public",
"type" : "LinearCongruentialEngine!(uint,48271,0,2147483647)",
"comment" : " ditto\n",
"line" : 455}
,
{
"name" : "MersenneTwisterEngine(UIntType,ulong w,ulong n,ulong m,ulong r,UIntType a,ulong u,ulong s,UIntType b,ulong t,UIntType c,ulong l) if (isUnsigned!(UIntType))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nThe $(LUCKY Mersenne Twister) generator.\n \n",
"line" : 518,
"members" : [
{
"name" : "MersenneTwisterEngine",
"kind" : "struct",
"protection" : "public",
"line" : 518,
"members" : [
{
"name" : "isUniformRandom",
"kind" : "variable",
"type" : "bool",
"comment" : "Mark this as a Rng\n",
"line" : 520}
,
{
"name" : "wordSize",
"kind" : "variable",
"type" : "size_t",
"comment" : "\nParameter for the generator.\n",
"line" : 524}
,
{
"name" : "stateSize",
"kind" : "variable",
"type" : "size_t",
"line" : 525}
,
{
"name" : "shiftSize",
"kind" : "variable",
"type" : "size_t",
"line" : 526}
,
{
"name" : "maskBits",
"kind" : "variable",
"type" : "size_t",
"line" : 527}
,
{
"name" : "xorMask",
"kind" : "variable",
"type" : "UIntType",
"line" : 528}
,
{
"name" : "temperingU",
"kind" : "variable",
"type" : "UIntType",
"line" : 529}
,
{
"name" : "temperingS",
"kind" : "variable",
"type" : "size_t",
"line" : 530}
,
{
"name" : "temperingB",
"kind" : "variable",
"type" : "UIntType",
"line" : 531}
,
{
"name" : "temperingT",
"kind" : "variable",
"type" : "size_t",
"line" : 532}
,
{
"name" : "temperingC",
"kind" : "variable",
"type" : "UIntType",
"line" : 533}
,
{
"name" : "temperingL",
"kind" : "variable",
"type" : "size_t",
"line" : 534}
,
{
"name" : "min",
"kind" : "variable",
"type" : "UIntType",
"comment" : " Smallest generated value (0).\n",
"line" : 537}
,
{
"name" : "max",
"kind" : "variable",
"type" : "UIntType",
"comment" : " Largest generated value.\n",
"line" : 539}
,
{
"name" : "defaultSeed",
"kind" : "variable",
"type" : "UIntType",
"comment" : " The default seed value.\n",
"line" : 542}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(UIntType value)",
"comment" : "\n   Constructs a MersenneTwisterEngine object.\n",
"line" : 553}
,
{
"name" : "seed()",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Seeds a MersenneTwisterEngine object.\n   Note:\n   This seed function gives 2^32 starting points. To allow the RNG to be started in any one of its\n   internal states use the seed overload taking an InputRange.\n",
"line" : 564,
"members" : [
{
"name" : "seed",
"kind" : "function",
"type" : "void(UIntType value = defaultSeed)",
"comment" : "\n   Seeds a MersenneTwisterEngine object.\n   Note:\n   This seed function gives 2^32 starting points. To allow the RNG to be started in any one of its\n   internal states use the seed overload taking an InputRange.\n",
"line" : 564}
]
}
,
{
"name" : "seed(T) if (isInputRange!(T) && is(Unqual!(ElementType!(T)) == UIntType))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Seeds a MersenneTwisterEngine object using an InputRange.\n\n   Throws:\n   $(D Exception) if the InputRange didn't provide enough elements to seed the generator.\n   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.\n\n   Examples:\n   ----------------\n   Mt19937 gen;\n   gen.seed(map!((a) => unpredictableSeed)(repeat(0)));\n   ----------------\n \n",
"line" : 603,
"members" : [
{
"name" : "seed",
"kind" : "function",
"type" : "void(T range)",
"comment" : "\n   Seeds a MersenneTwisterEngine object using an InputRange.\n\n   Throws:\n   $(D Exception) if the InputRange didn't provide enough elements to seed the generator.\n   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.\n\n   Examples:\n   ----------------\n   Mt19937 gen;\n   gen.seed(map!((a) => unpredictableSeed)(repeat(0)));\n   ----------------\n \n",
"line" : 603}
]
}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n   Advances the generator.\n",
"line" : 624}
,
{
"name" : "front",
"kind" : "function",
"type" : "UIntType()",
"comment" : "\n   Returns the current random value.\n \n",
"line" : 675}
,
{
"name" : "save",
"kind" : "function",
"type" : "typeof(this)()",
"comment" : "\n",
"line" : 682}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"comment" : "\nAlways $(D false).\n \n",
"line" : 690}
,
{
"name" : "mt",
"kind" : "variable",
"type" : "UIntType[n]",
"line" : 692}
,
{
"name" : "mti",
"kind" : "variable",
"type" : "size_t",
"line" : 693}
,
{
"name" : "_y",
"kind" : "variable",
"type" : "UIntType",
"line" : 694}
]
}
]
}
,
{
"name" : "Mt19937",
"kind" : "alias",
"protection" : "public",
"type" : "MersenneTwisterEngine!(uint,32,624,397,31,-1727483681u,11,7,-1658038656u,15,-272236544u,18)",
"comment" : "\nA $(D MersenneTwisterEngine) instantiated with the parameters of the\noriginal engine $(WEB math.sci.hiroshima-u.ac.jp\/~m-mat\/MT\/emt.html,\nMT19937), generating uniformly-distributed 32-bit numbers with a\nperiod of 2 to the power of 19937. Recommended for random number\ngeneration unless memory is severely restricted, in which case a $(D\nLinearCongruentialEngine) would be the generator of choice.\n\nExample:\n\n----\n\/\/ seed with a constant\nMt19937 gen;\nauto n = gen.front; \/\/ same for each run\n\/\/ Seed with an unpredictable value\ngen.seed(unpredictableSeed);\nn = gen.front; \/\/ different across runs\n----\n \n",
"line" : 718}
,
{
"name" : "XorshiftEngine(UIntType,UIntType bits,UIntType a,UIntType b,UIntType c) if (isUnsigned!(UIntType))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Xorshift generator using 32bit algorithm.\n\n Implemented according to $(WEB www.jstatsoft.org\/v08\/i14\/paper, Xorshift RNGs).\n\n $(BOOKTABLE $(TEXTWITHCOMMAS Supporting bits are below, $(D bits) means second parameter of XorshiftEngine.),\n  $(TR $(TH bits) $(TH period))\n  $(TR $(TD 32)   $(TD 2^32 - 1))\n  $(TR $(TD 64)   $(TD 2^64 - 1))\n  $(TR $(TD 96)   $(TD 2^96 - 1))\n  $(TR $(TD 128)  $(TD 2^128 - 1))\n  $(TR $(TD 160)  $(TD 2^160 - 1))\n  $(TR $(TD 192)  $(TD 2^192 - 2^32))\n )\n \n",
"line" : 777,
"members" : [
{
"name" : "XorshiftEngine",
"kind" : "struct",
"protection" : "public",
"line" : 777,
"members" : [
{
"name" : "isUniformRandom",
"kind" : "variable",
"type" : "bool",
"comment" : "Mark this as a Rng\n",
"line" : 784}
,
{
"name" : "empty",
"kind" : "variable",
"comment" : " Always $(D false) (random generators are infinite ranges).\n",
"line" : 786}
,
{
"name" : "min",
"kind" : "variable",
"type" : "UIntType",
"comment" : " Smallest generated value.\n",
"line" : 788}
,
{
"name" : "max",
"kind" : "variable",
"type" : "UIntType",
"comment" : " Largest generated value.\n",
"line" : 790}
,
{
"name" : "size",
"kind" : "variable",
"line" : 794}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(UIntType x0)",
"comment" : "\n Constructs a $(D XorshiftEngine) generator seeded with $(D_PARAM x0).\n     \n",
"line" : 818}
,
{
"name" : "seed",
"kind" : "function",
"type" : "void(UIntType x0)",
"comment" : "\n (Re)seeds the generator.\n     \n",
"line" : 828}
,
{
"name" : "front",
"kind" : "function",
"type" : "UIntType()",
"comment" : "\n Returns the current number in the random sequence.\n     \n",
"line" : 845}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n Advances the random sequence.\n     \n",
"line" : 858}
,
{
"name" : "save",
"kind" : "function",
"type" : "typeof(this)()",
"comment" : "\n Captures a range state.\n     \n",
"line" : 915}
,
{
"name" : "opEquals",
"kind" : "function",
"type" : "const bool(ref const XorshiftEngine rhs)",
"comment" : "\n Compares against $(D_PARAM rhs) for equality.\n     \n",
"line" : 925}
,
{
"name" : "sanitizeSeeds",
"kind" : "function",
"type" : "void(ref UIntType[size] seeds)",
"line" : 933}
]
}
]
}
,
{
"name" : "Xorshift32",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,32,13,17,5)",
"comment" : "\n Define $(D XorshiftEngine) generators with well-chosen parameters. See each bits examples of \"Xorshift RNGs\".\n $(D Xorshift) is a Xorshift128's alias because 128bits implementation is mostly used.\n\n Example:\n -----\n \/\/ Seed with a constant\n auto rnd = Xorshift(1);\n auto num = rnd.front;  \/\/ same for each run\n\n \/\/ Seed with an unpredictable value\n rnd.seed(unpredictableSeed());\n num = rnd.front; \/\/ different across runs\n -----\n \n",
"line" : 972}
,
{
"name" : "Xorshift64",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,64,10,13,10)",
"comment" : " ditto\n",
"line" : 973}
,
{
"name" : "Xorshift96",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,96,10,5,26)",
"comment" : " ditto\n",
"line" : 974}
,
{
"name" : "Xorshift128",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,128,11,8,19)",
"comment" : " ditto\n",
"line" : 975}
,
{
"name" : "Xorshift160",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,160,2,1,4)",
"comment" : " ditto\n",
"line" : 976}
,
{
"name" : "Xorshift192",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,192,2,1,4)",
"comment" : " ditto\n",
"line" : 977}
,
{
"name" : "Xorshift",
"kind" : "alias",
"protection" : "public",
"type" : "XorshiftEngine!(uint,128,11,8,19)",
"comment" : " ditto\n",
"line" : 978}
,
{
"name" : "unpredictableSeed",
"kind" : "function",
"protection" : "public",
"type" : "@property uint()",
"comment" : "\nA \"good\" seed for initializing random number engines. Initializing\nwith $(D_PARAM unpredictableSeed) makes engines generate different\nrandom number sequences every run.\n\nExample:\n\n----\nauto rnd = Random(unpredictableSeed);\nauto n = rnd.front;\n...\n----\n",
"line" : 1026}
,
{
"name" : "Random",
"kind" : "alias",
"protection" : "public",
"type" : "MersenneTwisterEngine!(uint,32,624,397,31,-1727483681u,11,7,-1658038656u,15,-272236544u,18)",
"comment" : "\nThe \"default\", \"favorite\", \"suggested\" random number generator type on\nthe current platform. It is an alias for one of the previously-defined\ngenerators. You may want to use it if (1) you need to generate some\nnice random numbers, and (2) you don't care for the minutiae of the\nmethod being used.\n \n",
"line" : 1055}
,
{
"name" : "rndGen",
"kind" : "function",
"protection" : "public",
"type" : "@property ref MersenneTwisterEngine!(uint,32,624,397,31,-1727483681u,11,7,-1658038656u,15,-272236544u,18)()",
"comment" : "\nGlobal random number generator used by various functions in this\nmodule whenever no generator is specified. It is allocated per-thread\nand initialized to an unpredictable value for each thread.\n \n",
"line" : 1070}
,
{
"name" : "uniform(string boundaries = \"[)\",T1,T2) if (!is(CommonType!(T1,T2) == void))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGenerates a number between $(D a) and $(D b). The $(D boundaries)\nparameter controls the shape of the interval (open vs. closed on\neither side). Valid values for $(D boundaries) are $(D \"[]\"), $(D\n\"$(LPAREN)]\"), $(D \"[$(RPAREN)\"), and $(D \"()\"). The default interval\nis closed to the left and open to the right. The version that does not\ntake $(D urng) uses the default generator $(D rndGen).\n\nExample:\n\n----\nRandom gen(unpredictableSeed);\n\/\/ Generate an integer in [0, 1023]\nauto a = uniform(0, 1024, gen);\n\/\/ Generate a float in [0, 1$(RPAREN)\nauto a = uniform(0.0f, 1.0f, gen);\n----\n \n",
"line" : 1104,
"members" : [
{
"name" : "uniform",
"kind" : "function",
"type" : "(T1 a, T2 b)",
"comment" : "\nGenerates a number between $(D a) and $(D b). The $(D boundaries)\nparameter controls the shape of the interval (open vs. closed on\neither side). Valid values for $(D boundaries) are $(D \"[]\"), $(D\n\"$(LPAREN)]\"), $(D \"[$(RPAREN)\"), and $(D \"()\"). The default interval\nis closed to the left and open to the right. The version that does not\ntake $(D urng) uses the default generator $(D rndGen).\n\nExample:\n\n----\nRandom gen(unpredictableSeed);\n\/\/ Generate an integer in [0, 1023]\nauto a = uniform(0, 1024, gen);\n\/\/ Generate a float in [0, 1$(RPAREN)\nauto a = uniform(0.0f, 1.0f, gen);\n----\n \n",
"line" : 1104}
]
}
,
{
"name" : "uniform(string boundaries = \"[)\",T1,T2,UniformRandomNumberGenerator) if (isFloatingPoint!(CommonType!(T1,T2)))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1142,
"members" : [
{
"name" : "uniform",
"kind" : "function",
"type" : "(T1 a, T2 b, ref UniformRandomNumberGenerator urng)",
"comment" : " ditto\n",
"line" : 1142}
]
}
,
{
"name" : "uniform(string boundaries = \"[)\",T1,T2,UniformRandomNumberGenerator) if (isIntegral!(CommonType!(T1,T2)) || isSomeChar!(CommonType!(T1,T2)))",
"kind" : "template",
"protection" : "public",
"line" : 1175,
"members" : [
{
"name" : "uniform",
"kind" : "function",
"type" : "(T1 a, T2 b, ref UniformRandomNumberGenerator urng)",
"line" : 1175}
]
}
,
{
"name" : "uniform(T,UniformRandomNumberGenerator) if (isIntegral!(T) || isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGenerates a uniformly-distributed number in the range $(D [T.min,\nT.max]) for any integral type $(D T). If no random number generator is\npassed, uses the default $(D rndGen).\n \n",
"line" : 1255,
"members" : [
{
"name" : "uniform",
"kind" : "function",
"type" : "(ref UniformRandomNumberGenerator urng)",
"comment" : "\nGenerates a uniformly-distributed number in the range $(D [T.min,\nT.max]) for any integral type $(D T). If no random number generator is\npassed, uses the default $(D rndGen).\n \n",
"line" : 1255}
]
}
,
{
"name" : "uniform(T) if (isIntegral!(T) || isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1274,
"members" : [
{
"name" : "uniform",
"kind" : "function",
"type" : "()",
"comment" : " Ditto\n",
"line" : 1274}
]
}
,
{
"name" : "uniformDistribution(F = double) if (isFloatingPoint!(F))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGenerates a uniform probability distribution of size $(D n), i.e., an\narray of size $(D n) of positive numbers of type $(D F) that sum to\n$(D 1). If $(D useThis) is provided, it is used as storage.\n \n",
"line" : 1297,
"members" : [
{
"name" : "uniformDistribution",
"kind" : "function",
"type" : "F[](size_t n, F[] useThis = null)",
"comment" : "\nGenerates a uniform probability distribution of size $(D n), i.e., an\narray of size $(D n) of positive numbers of type $(D F) that sum to\n$(D 1). If $(D useThis) is provided, it is used as storage.\n \n",
"line" : 1297}
]
}
,
{
"name" : "randomShuffle(Range,RandomGen = Random) if (isRandomAccessRange!(Range) && isUniformRNG!(RandomGen))",
"kind" : "template",
"protection" : "public",
"comment" : "\nShuffles elements of $(D r) using $(D gen) as a shuffler. $(D r) must be\na random-access range with length.\n \n",
"line" : 1325,
"members" : [
{
"name" : "randomShuffle",
"kind" : "function",
"type" : "void(Range r, ref RandomGen gen = rndGen)",
"comment" : "\nShuffles elements of $(D r) using $(D gen) as a shuffler. $(D r) must be\na random-access range with length.\n \n",
"line" : 1325}
]
}
,
{
"name" : "dice(Rng,Num) if (isNumeric!(Num) && isForwardRange!(Rng))",
"kind" : "template",
"protection" : "public",
"comment" : "\nRolls a dice with relative probabilities stored in $(D\nproportions). Returns the index in $(D proportions) that was chosen.\n\nExample:\n\n----\nauto x = dice(0.5, 0.5);   \/\/ x is 0 or 1 in equal proportions\nauto y = dice(50, 50);     \/\/ y is 0 or 1 in equal proportions\nauto z = dice(70, 20, 10); \/\/ z is 0 70% of the time, 1 20% of the time,\n                           \/\/ and 2 10% of the time\n----\n",
"line" : 1359,
"members" : [
{
"name" : "dice",
"kind" : "function",
"type" : "size_t(ref Rng rnd, Num[] proportions...)",
"comment" : "\nRolls a dice with relative probabilities stored in $(D\nproportions). Returns the index in $(D proportions) that was chosen.\n\nExample:\n\n----\nauto x = dice(0.5, 0.5);   \/\/ x is 0 or 1 in equal proportions\nauto y = dice(50, 50);     \/\/ y is 0 or 1 in equal proportions\nauto z = dice(70, 20, 10); \/\/ z is 0 70% of the time, 1 20% of the time,\n                           \/\/ and 2 10% of the time\n----\n",
"line" : 1359}
]
}
,
{
"name" : "dice(R,Range) if (isForwardRange!(Range) && isNumeric!(ElementType!(Range)) && !isArray!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1366,
"members" : [
{
"name" : "dice",
"kind" : "function",
"type" : "size_t(ref R rnd, Range proportions)",
"comment" : " Ditto\n",
"line" : 1366}
]
}
,
{
"name" : "dice(Range) if (isForwardRange!(Range) && isNumeric!(ElementType!(Range)) && !isArray!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1373,
"members" : [
{
"name" : "dice",
"kind" : "function",
"type" : "size_t(Range proportions)",
"comment" : " Ditto\n",
"line" : 1373}
]
}
,
{
"name" : "dice(Num) if (isNumeric!(Num))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1380,
"members" : [
{
"name" : "dice",
"kind" : "function",
"type" : "size_t(Num[] proportions...)",
"comment" : " Ditto\n",
"line" : 1380}
]
}
,
{
"name" : "diceImpl(Rng,Range) if (isForwardRange!(Range) && isNumeric!(ElementType!(Range)) && isForwardRange!(Rng))",
"kind" : "template",
"protection" : "public",
"line" : 1386,
"members" : [
{
"name" : "diceImpl",
"kind" : "function",
"type" : "size_t(ref Rng rng, Range proportions)",
"line" : 1386}
]
}
,
{
"name" : "RandomCover(Range,Random) if (isRandomAccessRange!(Range) && isUniformRNG!(Random))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nCovers a given range $(D r) in a random manner, i.e. goes through each\nelement of $(D r) once and only once, just in a random order. $(D r)\nmust be a random-access range with length.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\nauto rnd = Random(unpredictableSeed);\nforeach (e; randomCover(a, rnd))\n{\n    writeln(e);\n}\n----\n \n",
"line" : 1435,
"members" : [
{
"name" : "RandomCover",
"kind" : "struct",
"protection" : "public",
"line" : 1435,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 1436}
,
{
"name" : "_rnd",
"kind" : "variable",
"type" : "Random",
"line" : 1437}
,
{
"name" : "_chosen",
"kind" : "variable",
"type" : "bool[]",
"line" : 1438}
,
{
"name" : "_current",
"kind" : "variable",
"type" : "uint",
"line" : 1439}
,
{
"name" : "_alreadyChosen",
"kind" : "variable",
"type" : "uint",
"line" : 1440}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input, Random rnd)",
"line" : 1442}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"line" : 1457}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 1461}
,
{
"name" : "save",
"kind" : "function",
"type" : "typeof(this)()",
"line" : 1490}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 1498}
]
}
]
}
,
{
"name" : "randomCover(Range,Random) if (isRandomAccessRange!(Range) && isUniformRNG!(Random))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1502,
"members" : [
{
"name" : "randomCover",
"kind" : "function",
"type" : "RandomCover!(Range,Random)(Range r, Random rnd)",
"comment" : " Ditto\n",
"line" : 1502}
]
}
,
{
"name" : "RandomSample(R,Random = void) if (isInputRange!(R) && (isUniformRNG!(Random) || is(Random == void)))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nSelects a random subsample out of $(D r), containing exactly $(D n)\nelements. The order of elements is the same as in the original\nrange. The total length of $(D r) must be known. If $(D total) is\npassed in, the total number of sample is considered to be $(D\ntotal). Otherwise, $(D RandomSample) uses $(D r.length).\n\nIf the number of elements is not exactly $(D total), $(D\nRandomSample) throws an exception. This is because $(D total) is\nessential to computing the probability of selecting elements in the\nrange.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n\/\/ Print 5 random elements picked off from a\nforeach (e; randomSample(a, 5))\n{\n    writeln(e);\n}\n----\n\n$(D RandomSample) implements Jeffrey Scott Vitter's Algorithm D\n(see Vitter $(WEB dx.doi.org\/10.1145\/358105.893, 1984), $(WEB\ndx.doi.org\/10.1145\/23002.23003, 1987)), which selects a sample\nof size $(D n) in O(n) steps and requiring O(n) random variates,\nregardless of the size of the data being sampled.\n",
"line" : 1557,
"members" : [
{
"name" : "RandomSample",
"kind" : "struct",
"protection" : "public",
"line" : 1557,
"members" : [
{
"name" : "_available",
"kind" : "variable",
"type" : "size_t",
"line" : 1558}
,
{
"name" : "_toSelect",
"kind" : "variable",
"type" : "size_t",
"line" : 1558}
,
{
"name" : "_alphaInverse",
"kind" : "variable",
"type" : "ushort",
"line" : 1559}
,
{
"name" : "_first",
"kind" : "variable",
"type" : "bool",
"line" : 1560}
,
{
"name" : "_algorithmA",
"kind" : "variable",
"type" : "bool",
"line" : 1560}
,
{
"name" : "_Vprime",
"kind" : "variable",
"type" : "double",
"line" : 1561}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 1562}
,
{
"name" : "_index",
"kind" : "variable",
"type" : "size_t",
"line" : 1563}
,
{
"name" : "initialize",
"kind" : "function",
"type" : "void(R input, size_t howMany, size_t total)",
"line" : 1604}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n   Range primitives.\n",
"line" : 1616}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"line" : 1622}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 1648}
,
{
"name" : "save",
"kind" : "function",
"type" : "typeof(this)()",
"comment" : " Ditto\n",
"line" : 1658}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : " Ditto\n",
"line" : 1666}
,
{
"name" : "index",
"kind" : "function",
"type" : "size_t()",
"comment" : "\nReturns the index of the visited record.\n \n",
"line" : 1674}
,
{
"name" : "skipA",
"kind" : "function",
"type" : "size_t()",
"line" : 1683}
,
{
"name" : "newVprime",
"kind" : "function",
"type" : "double(size_t remaining)",
"line" : 1727}
,
{
"name" : "skip",
"kind" : "function",
"type" : "size_t()",
"line" : 1753}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void()",
"line" : 1853}
]
}
]
}
,
{
"name" : "randomSample(R) if (isInputRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1867,
"members" : [
{
"name" : "randomSample",
"kind" : "function",
"type" : "(R r, size_t n, size_t total)",
"comment" : " Ditto\n",
"line" : 1867}
]
}
,
{
"name" : "randomSample(R) if (isInputRange!(R) && hasLength!(R))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1874,
"members" : [
{
"name" : "randomSample",
"kind" : "function",
"type" : "(R r, size_t n)",
"comment" : " Ditto\n",
"line" : 1874}
]
}
,
{
"name" : "randomSample(R,Random) if (isInputRange!(R) && isUniformRNG!(Random))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1881,
"members" : [
{
"name" : "randomSample",
"kind" : "function",
"type" : "(R r, size_t n, size_t total, Random gen)",
"comment" : " Ditto\n",
"line" : 1881}
]
}
,
{
"name" : "randomSample(R,Random) if (isInputRange!(R) && hasLength!(R) && isUniformRNG!(Random))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1888,
"members" : [
{
"name" : "randomSample",
"kind" : "function",
"type" : "(R r, size_t n, Random gen)",
"comment" : " Ditto\n",
"line" : 1888}
]
}
]
}
,
{
"name" : "std.range",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/range.d",
"comment" : "\nThis module defines the notion of a range. Ranges generalize the concept of\narrays, lists, or anything that involves sequential access. This abstraction\nenables the same set of algorithms (see $(LINK2 std_algorithm.html,\nstd.algorithm)) to be used with a vast variety of different concrete types. For\nexample, a linear search algorithm such as $(LINK2 std_algorithm.html#find,\nstd.algorithm.find) works not just for arrays, but for linked-lists, input\nfiles, incoming network data, etc.\n\nFor more detailed information about the conceptual aspect of ranges and the\nmotivation behind them, see Andrei Alexandrescu's article\n$(LINK2 http:\/\/www.informit.com\/articles\/printerfriendly.aspx?p=1407357&rll=1,\n$(I On Iteration)).\n\nThis module defines several templates for testing whether a given object is a\n_range, and what kind of _range it is:\n$(BOOKTABLE ,\n\n$(TR $(TD $(D $(LREF isInputRange)))\n$(TD Tests if something is an $(I input _range), defined to be something from\nwhich one can sequentially read data using the primitives $(D front), $(D\npopFront), and $(D empty).\n))\n\n$(TR $(TD $(D $(LREF isOutputRange)))\n$(TD Tests if something is an $(I output _range), defined to be something to\nwhich one can sequentially write data using the $(D $(LREF put)) primitive.\n))\n\n$(TR $(TD $(D $(LREF isForwardRange)))\n$(TD Tests if something is a $(I forward _range), defined to be an input _range\nwith the additional capability that one can save one's current position with\nthe $(D save) primitive, thus allowing one to iterate over the same _range\nmultiple times.\n))\n\n$(TR $(TD $(D $(LREF isBidirectionalRange)))\n$(TD Tests if something is a $(I bidirectional _range), that is, a forward\n_range that allows reverse traversal using the primitives $(D back) and $(D\npopBack).\n))\n\n$(TR $(TD $(D $(LREF isRandomAccessRange)))\n$(TD Tests if something is a $(I random access _range), which is a\nbidirectional _range that also supports the array subscripting operation via\nthe primitive $(D opIndex).\n))\n\n)\n\nA number of templates are provided that test for various _range capabilities:\n\n$(BOOKTABLE ,\n\n$(TR $(TD $(D $(LREF hasMobileElements)))\n$(TD Tests if a given _range's elements can be moved around using the\nprimitives $(D moveFront), $(D moveBack), or $(D moveAt).\n))\n\n$(TR $(TD $(D $(LREF ElementType)))\n$(TD Returns the element type of a given _range.\n))\n\n$(TR $(TD $(D $(LREF ElementEncodingType)))\n$(TD Returns the encoding element type of a given _range.\n))\n\n$(TR $(TD $(D $(LREF hasSwappableElements)))\n$(TD Tests if a _range is a forward _range with swappable elements.\n))\n\n$(TR $(TD $(D $(LREF hasAssignableElements)))\n$(TD Tests if a _range is a forward _range with mutable elements.\n))\n\n$(TR $(TD $(D $(LREF hasLvalueElements)))\n$(TD Tests if a _range is a forward _range with elements that can be passed by\nreference and have their address taken.\n))\n\n$(TR $(TD $(D $(LREF hasLength)))\n$(TD Tests if a given _range has the $(D length) attribute.\n))\n\n$(TR $(TD $(D $(LREF isInfinite)))\n$(TD Tests if a given _range is an $(I infinite _range).\n))\n\n$(TR $(TD $(D $(LREF hasSlicing)))\n$(TD Tests if a given _range supports the array slicing operation $(D R[x..y]).\n))\n\n$(TR $(TD $(D $(LREF walkLength)))\n$(TD Computes the length of any _range in O(n) time.\n))\n\n)\n\nA rich set of _range creation and composition templates are provided that let\nyou construct new ranges out of existing ranges:\n\n$(BOOKTABLE ,\n\n$(TR $(TD $(D $(LREF retro)))\n$(TD Iterates a bidirectional _range backwards.\n))\n\n$(TR $(TD $(D $(LREF stride)))\n$(TD Iterates a _range with stride $(I n).\n))\n\n$(TR $(TD $(D $(LREF chain)))\n$(TD Concatenates several ranges into a single _range.\n))\n\n$(TR $(TD $(D $(LREF roundRobin)))\n$(TD Given $(I n) ranges, creates a new _range that return the $(I n) first\nelements of each _range, in turn, then the second element of each _range, and\nso on, in a round-robin fashion.\n))\n\n$(TR $(TD $(D $(LREF radial)))\n$(TD Given a random-access _range and a starting point, creates a _range that\nalternately returns the next left and next right element to the starting point.\n))\n\n$(TR $(TD $(D $(LREF take)))\n$(TD Creates a sub-_range consisting of only up to the first $(I n) elements of\nthe given _range.\n))\n\n$(TR $(TD $(D $(LREF takeExactly)))\n$(TD Like $(D take), but assumes the given _range actually has $(I n) elements,\nand therefore also defines the $(D length) property.\n))\n\n$(TR $(TD $(D $(LREF takeOne)))\n$(TD Creates a random-access _range consisting of exactly the first element of\nthe given _range.\n))\n\n$(TR $(TD $(D $(LREF takeNone)))\n$(TD Creates a random-access _range consisting of zero elements of the given\n_range.\n))\n\n$(TR $(TD $(D $(LREF drop)))\n$(TD Creates the _range that results from discarding the first $(I n) elements\nfrom the given _range.\n))\n\n$(TR $(TD $(D $(LREF repeat)))\n$(TD Creates a _range that consists of a single element repeated $(I n) times,\nor an infinite _range repeating that element indefinitely.\n))\n\n$(TR $(TD $(D $(LREF cycle)))\n$(TD Creates an infinite _range that repeats the given forward _range\nindefinitely. Good for implementing circular buffers.\n))\n\n$(TR $(TD $(D $(LREF zip)))\n$(TD Given $(I n) _ranges, creates a _range that successively returns a tuple\nof all the first elements, a tuple of all the second elements, etc.\n))\n\n$(TR $(TD $(D $(LREF lockstep)))\n$(TD Iterates $(I n) _ranges in lockstep, for use in a $(D foreach) loop.\nSimilar to $(D zip), except that $(D lockstep) is designed especially for $(D\nforeach) loops.\n))\n\n$(TR $(TD $(D $(LREF recurrence)))\n$(TD Creates a forward _range whose values are defined by a mathematical\nrecurrence relation.\n))\n\n$(TR $(TD $(D $(LREF sequence)))\n$(TD Similar to $(D recurrence), except that a random-access _range is created.\n))\n\n$(TR $(TD $(D $(LREF iota)))\n$(TD Creates a _range consisting of numbers between a starting point and ending\npoint, spaced apart by a given interval.\n))\n\n$(TR $(TD $(D $(LREF frontTransversal)))\n$(TD Creates a _range that iterates over the first elements of the given\nranges.\n))\n\n$(TR $(TD $(D $(LREF transversal)))\n$(TD Creates a _range that iterates over the $(I n)'th elements of the given\nrandom-access ranges.\n))\n\n$(TR $(TD $(D $(LREF indexed)))\n$(TD Creates a _range that offers a view of a given _range as though its\nelements were reordered according to a given _range of indices.\n))\n\n$(TR $(TD $(D $(LREF chunks)))\n$(TD Creates a _range that returns fixed-size chunks of the original _range.\n))\n\n)\n\nThese _range-construction tools are implemented using templates; but sometimes\nan object-based interface for ranges is needed. For this purpose, this module\nprovides a number of object and $(D interface) definitions that can be used to\nwrap around _range objects created by the above templates:\n\n$(BOOKTABLE ,\n\n$(TR $(TD $(D $(LREF InputRange)))\n$(TD Wrapper for input ranges.\n))\n\n$(TR $(TD $(D $(LREF InputAssignable)))\n$(TD Wrapper for input ranges with assignable elements.\n))\n\n$(TR $(TD $(D $(LREF ForwardRange)))\n$(TD Wrapper for forward ranges.\n))\n\n$(TR $(TD $(D $(LREF ForwardAssignable)))\n$(TD Wrapper for forward ranges with assignable elements.\n))\n\n$(TR $(TD $(D $(LREF BidirectionalRange)))\n$(TD Wrapper for bidirectional ranges.\n))\n\n$(TR $(TD $(D $(LREF BidirectionalAssignable)))\n$(TD Wrapper for bidirectional ranges with assignable elements.\n))\n\n$(TR $(TD $(D $(LREF RandomAccessFinite)))\n$(TD Wrapper for finite random-access ranges.\n))\n\n$(TR $(TD $(D $(LREF RandomAccessAssignable)))\n$(TD Wrapper for finite random-access ranges with assignable elements.\n))\n\n$(TR $(TD $(D $(LREF RandomAccessInfinite)))\n$(TD Wrapper for infinite random-access ranges.\n))\n\n$(TR $(TD $(D $(LREF OutputRange)))\n$(TD Wrapper for output ranges.\n))\n\n$(TR $(TD $(D $(LREF OutputRangeObject)))\n$(TD Class that implements the $(D OutputRange) interface and wraps the\n$(D put) methods in virtual functions.\n))\n\n$(TR $(TD $(D $(LREF InputRangeObject)))\n$(TD Class that implements the $(D InputRange) interface and wraps the input\n_range methods in virtual functions.\n))\n\n)\n\nRanges whose elements are sorted afford better efficiency with certain\noperations. For this, the $(D $(LREF assumeSorted)) function can be used to\nconstruct a $(D $(LREF SortedRange)) from a pre-sorted _range. The $(D $(LINK2\nstd_algorithm.html#sort, std.algorithm.sort)) function also conveniently\nreturns a $(D SortedRange). $(D SortedRange) objects provide some additional\n_range operations that take advantage of the fact that the _range is sorted.\n\nFinally, this module also defines some convenience functions for\nmanipulating ranges:\n\n$(BOOKTABLE ,\n\n$(TR $(TD $(D $(LREF popFrontN)))\n$(TD Advances a given _range by $(I n) elements.\n))\n\n$(TR $(TD $(D $(LREF popBackN)))\n$(TD Advances a given bidirectional _range from the right by $(I n) elements.\n))\n\n$(TR $(TD $(D $(LREF moveFront)))\n$(TD Removes the front element of a _range.\n))\n\n$(TR $(TD $(D $(LREF moveBack)))\n$(TD Removes the back element of a bidirectional _range.\n))\n\n$(TR $(TD $(D $(LREF moveAt)))\n$(TD Removes the $(I i)'th element of a random-access _range.\n))\n\n)\n\nSource: $(PHOBOSSRC std\/_range.d)\n\nMacros:\n\nWIKI = Phobos\/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net\/leonardo\/so\/, Leonardo Maffi).\n \n",
"members" : [
{
"name" : "dummyRanges",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 493}
,
{
"name" : "isInputRange(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is an input range. An input range must\ndefine the primitives $(D empty), $(D popFront), and $(D front). The\nfollowing code should compile for any input range.\n\n----\nR r;              \/\/ can define a range object\nif (r.empty) {}   \/\/ can test for empty\nr.popFront();     \/\/ can invoke popFront()\nauto h = r.front; \/\/ can get the front of the range of non-void type\n----\n\nThe semantics of an input range (not checkable during compilation) are\nassumed to be the following ($(D r) is an object of type $(D R)):\n\n$(UL $(LI $(D r.empty) returns $(D false) iff there is more data\navailable in the range.)  $(LI $(D r.front) returns the current\nelement in the range. It may return by value or by reference. Calling\n$(D r.front) is allowed only if calling $(D r.empty) has, or would\nhave, returned $(D false).) $(LI $(D r.popFront) advances to the next\nelement in the range. Calling $(D r.popFront) is allowed only if\ncalling $(D r.empty) has, or would have, returned $(D false).))\n \n",
"line" : 549,
"members" : [
{
"name" : "isInputRange",
"kind" : "variable",
"type" : "bool",
"line" : 551}
]
}
,
{
"name" : "put(R,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\nOutputs $(D e) to $(D r). The exact effect is dependent upon the two\ntypes. Several cases are accepted, as described below. The code snippets\nare attempted in order, and the first to compile \"wins\" and gets\nevaluated.\n\n$(BOOKTABLE ,\n\n$(TR $(TH Code Snippet) $(TH Scenario))\n\n$(TR $(TD $(D r.put(e);)) $(TD $(D R) specifically defines a method\n$(D put) accepting an $(D E).))\n\n$(TR $(TD $(D r.put([ e ]);)) $(TD $(D R) specifically defines a\nmethod $(D put) accepting an $(D E[]).))\n\n$(TR $(TD $(D r.front = e; r.popFront();)) $(TD $(D R) is an input\nrange and $(D e) is assignable to $(D r.front).))\n\n$(TR $(TD $(D for (; !e.empty; e.popFront()) put(r, e.front);)) $(TD\nCopying range $(D E) to range $(D R).))\n\n$(TR $(TD $(D r(e);)) $(TD $(D R) is e.g. a delegate accepting an $(D\nE).))\n\n$(TR $(TD $(D r([ e ]);)) $(TD $(D R) is e.g. a $(D delegate)\naccepting an $(D E[]).))\n\n)\n \n",
"line" : 608,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(ref R r, E e)",
"comment" : "\nOutputs $(D e) to $(D r). The exact effect is dependent upon the two\ntypes. Several cases are accepted, as described below. The code snippets\nare attempted in order, and the first to compile \"wins\" and gets\nevaluated.\n\n$(BOOKTABLE ,\n\n$(TR $(TH Code Snippet) $(TH Scenario))\n\n$(TR $(TD $(D r.put(e);)) $(TD $(D R) specifically defines a method\n$(D put) accepting an $(D E).))\n\n$(TR $(TD $(D r.put([ e ]);)) $(TD $(D R) specifically defines a\nmethod $(D put) accepting an $(D E[]).))\n\n$(TR $(TD $(D r.front = e; r.popFront();)) $(TD $(D R) is an input\nrange and $(D e) is assignable to $(D r.front).))\n\n$(TR $(TD $(D for (; !e.empty; e.popFront()) put(r, e.front);)) $(TD\nCopying range $(D E) to range $(D R).))\n\n$(TR $(TD $(D r(e);)) $(TD $(D R) is e.g. a delegate accepting an $(D\nE).))\n\n$(TR $(TD $(D r([ e ]);)) $(TD $(D R) is e.g. a $(D delegate)\naccepting an $(D E[]).))\n\n)\n \n",
"line" : 608}
]
}
,
{
"name" : "isOutputRange(R,E)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is an output range for elements of type\n$(D E). An output range is defined functionally as a range that\nsupports the operation $(D put(r, e)) as defined above.\n \n",
"line" : 757,
"members" : [
{
"name" : "isOutputRange",
"kind" : "variable",
"type" : "bool",
"line" : 759}
]
}
,
{
"name" : "isForwardRange(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is a forward range. A forward range is an\ninput range $(D r) that can save \"checkpoints\" by saving $(D r.save)\nto another value of type $(D R). Notable examples of input ranges that\nare $(I not) forward ranges are file\/socket ranges; copying such a\nrange will not save the position in the stream, and they most likely\nreuse an internal buffer as the entire stream does not sit in\nmemory. Subsequently, advancing either the original or the copy will\nadvance the stream, so the copies are not independent.\n\nThe following code should compile for any forward range.\n\n----\nstatic assert(isInputRange!R);\nR r1;\nR r2 = r1.save; \/\/ can save the current position into another range\n----\n\nSaving a range is not duplicating it; in the example above, $(D r1)\nand $(D r2) still refer to the same underlying data. They just\nnavigate that data independently.\n\nThe semantics of a forward range (not checkable during compilation)\nare the same as for an input range, with the additional requirement\nthat backtracking must be possible by saving a copy of the range\nobject with $(D save) and using it later.\n \n",
"line" : 815,
"members" : [
{
"name" : "isForwardRange",
"kind" : "variable",
"type" : "bool",
"line" : 817}
]
}
,
{
"name" : "isBidirectionalRange(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is a bidirectional range. A bidirectional\nrange is a forward range that also offers the primitives $(D back) and\n$(D popBack). The following code should compile for any bidirectional\nrange.\n\n----\nR r;\nstatic assert(isForwardRange!R);           \/\/ is forward range\nr.popBack();                               \/\/ can invoke popBack\nauto t = r.back;                           \/\/ can get the back of the range\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w))); \/\/ same type for front and back\n----\n\nThe semantics of a bidirectional range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)):\n\n$(UL $(LI $(D r.back) returns (possibly a reference to) the last\nelement in the range. Calling $(D r.back) is allowed only if calling\n$(D r.empty) has, or would have, returned $(D false).))\n \n",
"line" : 855,
"members" : [
{
"name" : "isBidirectionalRange",
"kind" : "variable",
"type" : "bool",
"line" : 857}
]
}
,
{
"name" : "isRandomAccessRange(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is a random-access range. A random-access\nrange is a bidirectional range that also offers the primitive $(D\nopIndex), OR an infinite forward range that offers $(D opIndex). In\neither case, the range must either offer $(D length) or be\ninfinite. The following code should compile for any random-access\nrange.\n\n----\nR r;\nstatic assert(isForwardRange!R);  \/\/ range is forward\nstatic assert(isBidirectionalRange!R || isInfinite!R);\n                                  \/\/ range is bidirectional or infinite\nauto e = r[1];                    \/\/ can index\n----\n\nThe semantics of a random-access range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)): $(UL $(LI $(D r.opIndex(n)) returns a reference to the\n$(D n)th element in the range.))\n\nAlthough $(D char[]) and $(D wchar[]) (as well as their qualified\nversions including $(D string) and $(D wstring)) are arrays, $(D\nisRandomAccessRange) yields $(D false) for them because they use\nvariable-length encodings (UTF-8 and UTF-16 respectively). These types\nare bidirectional ranges only.\n \n",
"line" : 921,
"members" : [
{
"name" : "isRandomAccessRange",
"kind" : "variable",
"type" : "bool",
"line" : 923}
]
}
,
{
"name" : "hasMobileElements(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) iff the range supports the $(D moveFront) primitive,\nas well as $(D moveBack) and $(D moveAt) if it's a bidirectional or\nrandom access range.  These may be explicitly implemented, or may work\nvia the default behavior of the module level functions $(D moveFront)\nand friends.\n \n",
"line" : 1011,
"members" : [
{
"name" : "hasMobileElements",
"kind" : "variable",
"type" : "bool",
"line" : 1013}
]
}
,
{
"name" : "ElementType(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe element type of $(D R). $(D R) does not have to be a range. The\nelement type is determined as the type yielded by $(D r.front) for an\nobject $(D r) or type $(D R). For example, $(D ElementType!(T[])) is\n$(D T). If $(D R) is not a range, $(D ElementType!R) is $(D void).\n \n",
"line" : 1049,
"members" : [
]
}
,
{
"name" : "ElementEncodingType(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nThe encoding element type of $(D R). For narrow strings ($(D char[]),\n$(D wchar[]) and their qualified variants including $(D string) and\n$(D wstring)), $(D ElementEncodingType) is the character type of the\nstring. For all other ranges, $(D ElementEncodingType) is the same as\n$(D ElementType).\n \n",
"line" : 1078,
"members" : [
]
}
,
{
"name" : "hasSwappableElements(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is a forward range and has swappable\nelements. The following code should compile for any random-access\nrange.\n\n----\nR r;\nstatic assert(isForwardRange!(R));   \/\/ range is forward\nswap(r.front, r.front);              \/\/ can swap elements of the range\n----\n \n",
"line" : 1115,
"members" : [
{
"name" : "hasSwappableElements",
"kind" : "variable",
"type" : "bool",
"line" : 1117}
]
}
,
{
"name" : "hasAssignableElements(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is a forward range and has mutable\nelements. The following code should compile for any random-access\nrange.\n\n----\nR r;\nstatic assert(isForwardRange!R);  \/\/ range is forward\nauto e = r.front;\nr.front = e;                      \/\/ can assign elements of the range\n----\n \n",
"line" : 1146,
"members" : [
{
"name" : "hasAssignableElements",
"kind" : "variable",
"type" : "bool",
"line" : 1148}
]
}
,
{
"name" : "hasLvalueElements(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nTests whether $(D R) has lvalue elements.  These are defined as elements that\ncan be passed by reference and have their address taken.\n",
"line" : 1170,
"members" : [
{
"name" : "hasLvalueElements",
"kind" : "variable",
"type" : "bool",
"line" : 1172}
]
}
,
{
"name" : "hasLength(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) has a $(D length) member that returns an\nintegral type. $(D R) does not have to be a range. Note that $(D\nlength) is an optional primitive as no range must implement it. Some\nranges do not store their length explicitly, some cannot compute it\nwithout actually exhausting the range (e.g. socket streams), and some\nother ranges may be infinite.\n\nAlthough narrow string types ($(D char[]), $(D wchar[]), and their\nqualified derivatives) do define a $(D length) property, $(D\nhasLength) yields $(D false) for them. This is because a narrow\nstring's length does not reflect the number of characters, but instead\nthe number of encoding units, and as such is not useful with\nrange-oriented algorithms.\n \n",
"line" : 1212,
"members" : [
{
"name" : "hasLength",
"kind" : "variable",
"type" : "bool",
"line" : 1214}
]
}
,
{
"name" : "isInfinite(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) is an infinite input range. An\ninfinite input range is an input range that has a statically-defined\nenumerated member called $(D empty) that is always $(D false),\nfor example:\n\n----\nstruct MyInfiniteRange\n{\n    enum bool empty = false;\n    ...\n}\n----\n \n",
"line" : 1251,
"members" : [
]
}
,
{
"name" : "hasSlicing(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if $(D R) offers a slicing operator with\nintegral boundaries, that in turn returns an input range type. The\nfollowing code should compile for $(D hasSlicing) to be $(D true):\n\n----\nR r;\nauto s = r[1 .. 2];\nstatic assert(isInputRange!(typeof(s)));\n----\n \n",
"line" : 1276,
"members" : [
{
"name" : "hasSlicing",
"kind" : "variable",
"type" : "bool",
"line" : 1278}
]
}
,
{
"name" : "walkLength(Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nThis is a best-effort implementation of $(D length) for any kind of\nrange.\n\nIf $(D hasLength!(Range)), simply returns $(D range.length) without\nchecking $(D upTo).\n\nOtherwise, walks the range through its length and returns the number\nof elements seen. Performes $(BIGOH n) evaluations of $(D range.empty)\nand $(D range.popFront()), where $(D n) is the effective length of $(D\nrange). The $(D upTo) parameter is useful to \"cut the losses\" in case\nthe interest is in seeing whether the range has at least some number\nof elements. If the parameter $(D upTo) is specified, stops if $(D\nupTo) steps have been taken and returns $(D upTo).\n \n",
"line" : 1316,
"members" : [
{
"name" : "walkLength",
"kind" : "function",
"type" : "(Range range, const size_t upTo = size_t.max)",
"comment" : "\nThis is a best-effort implementation of $(D length) for any kind of\nrange.\n\nIf $(D hasLength!(Range)), simply returns $(D range.length) without\nchecking $(D upTo).\n\nOtherwise, walks the range through its length and returns the number\nof elements seen. Performes $(BIGOH n) evaluations of $(D range.empty)\nand $(D range.popFront()), where $(D n) is the effective length of $(D\nrange). The $(D upTo) parameter is useful to \"cut the losses\" in case\nthe interest is in seeing whether the range has at least some number\nof elements. If the parameter $(D upTo) is specified, stops if $(D\nupTo) steps have been taken and returns $(D upTo).\n \n",
"line" : 1316}
]
}
,
{
"name" : "retro(Range) if (isBidirectionalRange!(Unqual!(Range)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIterates a bidirectional range backwards. The original range can be\naccessed by using the $(D source) property. Applying retro twice to\nthe same range yields the original range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(retro(a), [ 5, 4, 3, 2, 1 ][]));\nassert(retro(a).source is a);\nassert(retro(retro(a)) is a);\n----\n \n",
"line" : 1356,
"members" : [
{
"name" : "retro",
"kind" : "function",
"type" : "(Range r)",
"comment" : "\nIterates a bidirectional range backwards. The original range can be\naccessed by using the $(D source) property. Applying retro twice to\nthe same range yields the original range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(retro(a), [ 5, 4, 3, 2, 1 ][]));\nassert(retro(a).source is a);\nassert(retro(retro(a)) is a);\n----\n \n",
"line" : 1356}
]
}
,
{
"name" : "stride(Range) if (isInputRange!(Unqual!(Range)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIterates range $(D r) with stride $(D n). If the range is a\nrandom-access range, moves by indexing into the range; otehrwise,\nmoves by successive calls to $(D popFront). Applying stride twice to\nthe same range results in a stride that with a step that is the\nproduct of the two applications.\n\nThrows: $(D Exception) if $(D n == 0).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\nassert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));\nassert(stride(stride(a, 2), 3) == stride(a, 6));\n----\n \n",
"line" : 1565,
"members" : [
{
"name" : "stride",
"kind" : "function",
"type" : "(Range r, size_t n)",
"comment" : "\nIterates range $(D r) with stride $(D n). If the range is a\nrandom-access range, moves by indexing into the range; otehrwise,\nmoves by successive calls to $(D popFront). Applying stride twice to\nthe same range results in a stride that with a step that is the\nproduct of the two applications.\n\nThrows: $(D Exception) if $(D n == 0).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\nassert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));\nassert(stride(stride(a, 2), 3) == stride(a, 6));\n----\n \n",
"line" : 1565}
]
}
,
{
"name" : "chain(Ranges...) if (Ranges.length > 0 && allSatisfy!(isInputRange,staticMap!(Unqual,Ranges)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSpans multiple ranges in sequence. The function $(D chain) takes any\nnumber of ranges and returns a $(D Chain!(R1, R2,...)) object. The\nranges may be different, but they must have the same element type. The\nresult is a range that offers the $(D front), $(D popFront), and $(D\nempty) primitives. If all input ranges offer random access and $(D\nlength), $(D Chain) offers them as well.\n\nIf only one range is offered to $(D Chain) or $(D chain), the $(D\nChain) type exits the picture by aliasing itself directly to that\nrange's type.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\nauto s = chain(arr1, arr2, arr3);\nassert(s.length == 7);\nassert(s[5] == 6);\nassert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));\n----\n \n",
"line" : 1923,
"members" : [
{
"name" : "chain",
"kind" : "function",
"type" : "(Ranges rs)",
"comment" : "\nSpans multiple ranges in sequence. The function $(D chain) takes any\nnumber of ranges and returns a $(D Chain!(R1, R2,...)) object. The\nranges may be different, but they must have the same element type. The\nresult is a range that offers the $(D front), $(D popFront), and $(D\nempty) primitives. If all input ranges offer random access and $(D\nlength), $(D Chain) offers them as well.\n\nIf only one range is offered to $(D Chain) or $(D chain), the $(D\nChain) type exits the picture by aliasing itself directly to that\nrange's type.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\nauto s = chain(arr1, arr2, arr3);\nassert(s.length == 7);\nassert(s[5] == 6);\nassert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));\n----\n \n",
"line" : 1923}
]
}
,
{
"name" : "roundRobin(Rs...) if (Rs.length > 1 && allSatisfy!(isInputRange,staticMap!(Unqual,Rs)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D roundRobin(r1, r2, r3)) yields $(D r1.front), then $(D r2.front),\nthen $(D r3.front), after which it pops off one element from each and\ncontinues again from $(D r1). For example, if two ranges are involved,\nit alternately yields elements off the two ranges. $(D roundRobin)\nstops after it has consumed all ranges (skipping over the ones that\nfinish early).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4];\nint[] b = [ 10, 20 ];\nassert(equal(roundRobin(a, b), [1, 10, 2, 20, 3, 4]));\n----\n \n",
"line" : 2344,
"members" : [
{
"name" : "roundRobin",
"kind" : "function",
"type" : "(Rs rs)",
"comment" : "\n$(D roundRobin(r1, r2, r3)) yields $(D r1.front), then $(D r2.front),\nthen $(D r3.front), after which it pops off one element from each and\ncontinues again from $(D r1). For example, if two ranges are involved,\nit alternately yields elements off the two ranges. $(D roundRobin)\nstops after it has consumed all ranges (skipping over the ones that\nfinish early).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4];\nint[] b = [ 10, 20 ];\nassert(equal(roundRobin(a, b), [1, 10, 2, 20, 3, 4]));\n----\n \n",
"line" : 2344}
]
}
,
{
"name" : "radial(Range,I) if (isRandomAccessRange!(Unqual!(Range)) && hasLength!(Unqual!(Range)) && isIntegral!(I))",
"kind" : "template",
"protection" : "public",
"comment" : "\nIterates a random-access range starting from a given point and\nprogressively extending left and right from that point. If no initial\npoint is given, iteration starts from the middle of the\nrange. Iteration spans the entire range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));\na = [ 1, 2, 3, 4 ];\nassert(equal(radial(a), [ 2, 3, 1, 4 ]));\n----\n \n",
"line" : 2465,
"members" : [
{
"name" : "radial",
"kind" : "function",
"type" : "(Range r, I startingIndex)",
"comment" : "\nIterates a random-access range starting from a given point and\nprogressively extending left and right from that point. If no initial\npoint is given, iteration starts from the middle of the\nrange. Iteration spans the entire range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));\na = [ 1, 2, 3, 4 ];\nassert(equal(radial(a), [ 2, 3, 1, 4 ]));\n----\n \n",
"line" : 2465}
]
}
,
{
"name" : "radial(R) if (isRandomAccessRange!(Unqual!(R)) && hasLength!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 2473,
"members" : [
{
"name" : "radial",
"kind" : "function",
"type" : "(R r)",
"comment" : " Ditto\n",
"line" : 2473}
]
}
,
{
"name" : "Take(Range) if (isInputRange!(Unqual!(Range)) && !(hasSlicing!(Unqual!(Range)) || is(Range T == Take!(T))))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nLazily takes only up to $(D n) elements of a range. This is\nparticularly useful when using with infinite ranges. If the range\noffers random access and $(D length), $(D Take) offers them as well.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nauto s = take(arr1, 5);\nassert(s.length == 5);\nassert(s[4] == 5);\nassert(equal(s, [ 1, 2, 3, 4, 5 ][]));\n----\n \n",
"line" : 2537,
"members" : [
{
"name" : "Take",
"kind" : "struct",
"protection" : "public",
"line" : 2537,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "Unqual!(Range)",
"line" : 2538}
,
{
"name" : "source",
"kind" : "variable",
"type" : "R",
"line" : 2541}
,
{
"name" : "_maxAvailable",
"kind" : "variable",
"type" : "size_t",
"line" : 2543}
,
{
"name" : "byRef",
"kind" : "variable",
"type" : "bool",
"line" : 2544}
,
{
"name" : "Source",
"kind" : "alias",
"type" : "R",
"line" : 2546}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 2548}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"line" : 2554}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2560}
,
{
"name" : "maxLength",
"kind" : "function",
"type" : "const size_t()",
"line" : 2672}
]
}
]
}
,
{
"name" : "Take(R) if (isInputRange!(Unqual!(R)) && (hasSlicing!(Unqual!(R)) || is(R T == Take!(T))))",
"kind" : "template",
"protection" : "public",
"line" : 2680,
"members" : [
{
"name" : "Take",
"kind" : "alias",
"type" : "R",
"line" : 2683}
]
}
,
{
"name" : "take(R) if (isInputRange!(Unqual!(R)) && hasSlicing!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2688,
"members" : [
{
"name" : "take",
"kind" : "function",
"type" : "Take!(R)(R input, size_t n)",
"comment" : " ditto\n",
"line" : 2688}
]
}
,
{
"name" : "take(R) if (is(R T == Take!(T)))",
"kind" : "template",
"protection" : "public",
"line" : 2706,
"members" : [
{
"name" : "take",
"kind" : "function",
"type" : "Take!(R)(R input, size_t n)",
"line" : 2706}
]
}
,
{
"name" : "take(R) if (isInputRange!(Unqual!(R)) && !hasSlicing!(Unqual!(R)) && !is(R T == Take!(T)))",
"kind" : "template",
"protection" : "public",
"line" : 2713,
"members" : [
{
"name" : "take",
"kind" : "function",
"type" : "Take!(R)(R input, size_t n)",
"line" : 2713}
]
}
,
{
"name" : "takeExactly(R) if (isInputRange!(R) && !hasSlicing!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "\nSimilar to $(LREF take), but assumes that $(D range) has at least $(D\nn) elements. Consequently, the result of $(D takeExactly(range, n))\nalways defines the $(D length) property (and initializes it to $(D n))\neven when $(D range) itself does not define $(D length).\n\nIf $(D R) has slicing, $(D takeExactly) simply returns a slice of $(D\nrange). Otherwise if $(D R) is an input range, the type of the result\nis an input range with length. Finally, if $(D R) is a forward range\n(including bidirectional), the type of the result is a forward range\nwith length.\n \n",
"line" : 2804,
"members" : [
{
"name" : "takeExactly",
"kind" : "function",
"type" : "(R range, size_t n)",
"comment" : "\nSimilar to $(LREF take), but assumes that $(D range) has at least $(D\nn) elements. Consequently, the result of $(D takeExactly(range, n))\nalways defines the $(D length) property (and initializes it to $(D n))\neven when $(D range) itself does not define $(D length).\n\nIf $(D R) has slicing, $(D takeExactly) simply returns a slice of $(D\nrange). Otherwise if $(D R) is an input range, the type of the result\nis an input range with length. Finally, if $(D R) is a forward range\n(including bidirectional), the type of the result is a forward range\nwith length.\n \n",
"line" : 2804}
]
}
,
{
"name" : "takeExactly(R) if (hasSlicing!(R))",
"kind" : "template",
"protection" : "public",
"line" : 2839,
"members" : [
{
"name" : "takeExactly",
"kind" : "function",
"type" : "(R range, size_t n)",
"line" : 2839}
]
}
,
{
"name" : "takeOne(R) if (isInputRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a range with at most one element; for example, $(D\ntakeOne([42, 43, 44])) returns a range consisting of the integer $(D\n42). Calling $(D popFront()) off that range renders it empty.\n\nSometimes an empty range with the same signature is needed. For such\nranges use $(D takeNone!R()). For example:\n\n----\nauto s = takeOne([42, 43, 44]);\nstatic assert(isRandomAccessRange!(typeof(s)));\nassert(s.length == 1);\nassert(!s.empty);\nassert(s.front == 42);\ns.front() = 43;\nassert(s.front == 43);\nassert(s.back == 43);\nassert(s[0] == 43);\ns.popFront();\nassert(s.length == 0);\nassert(s.empty);\ns = takeNone!(int[])();\nassert(s.length == 0);\nassert(s.empty);\n----\n\nIn effect $(D takeOne(r)) is somewhat equivalent to $(D take(r, 1)) and\n$(D takeNone(r)) is equivalent to $(D take(r, 0)), but in certain\ninterfaces it is important to know statically that the range may only\nhave at most one element.\n\nThe type returned by $(D takeOne) and $(D takeNone) is a random-access\nrange with length regardless of $(D R)'s capability (another feature\nthat distinguishes $(D takeOne)\/$(D takeNone) from $(D take)).\n \n",
"line" : 2904,
"members" : [
{
"name" : "takeOne",
"kind" : "function",
"type" : "(R source)",
"comment" : "\nReturns a range with at most one element; for example, $(D\ntakeOne([42, 43, 44])) returns a range consisting of the integer $(D\n42). Calling $(D popFront()) off that range renders it empty.\n\nSometimes an empty range with the same signature is needed. For such\nranges use $(D takeNone!R()). For example:\n\n----\nauto s = takeOne([42, 43, 44]);\nstatic assert(isRandomAccessRange!(typeof(s)));\nassert(s.length == 1);\nassert(!s.empty);\nassert(s.front == 42);\ns.front() = 43;\nassert(s.front == 43);\nassert(s.back == 43);\nassert(s[0] == 43);\ns.popFront();\nassert(s.length == 0);\nassert(s.empty);\ns = takeNone!(int[])();\nassert(s.length == 0);\nassert(s.empty);\n----\n\nIn effect $(D takeOne(r)) is somewhat equivalent to $(D take(r, 1)) and\n$(D takeNone(r)) is equivalent to $(D take(r, 0)), but in certain\ninterfaces it is important to know statically that the range may only\nhave at most one element.\n\nThe type returned by $(D takeOne) and $(D takeNone) is a random-access\nrange with length regardless of $(D R)'s capability (another feature\nthat distinguishes $(D takeOne)\/$(D takeNone) from $(D take)).\n \n",
"line" : 2904}
]
}
,
{
"name" : "takeNone(R) if (isInputRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 2939,
"members" : [
{
"name" : "takeNone",
"kind" : "function",
"type" : "()",
"comment" : " Ditto\n",
"line" : 2939}
]
}
,
{
"name" : "drop(R) if (isInputRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Convenience function which calls $(D $(LREF popFrontN)(range, n)) and\n    returns $(D range).\n\n    Examples:\n--------------------\nassert(drop([0, 2, 1, 5, 0, 3], 3) == [5, 0, 3]);\nassert(drop(\"hello world\", 6) == \"world\");\nassert(drop(\"hello world\", 50).empty);\nassert(equal(drop(take(\"hello world\", 6), 3), \"lo \"));\n--------------------\n  \n",
"line" : 2976,
"members" : [
{
"name" : "drop",
"kind" : "function",
"type" : "R(R range, size_t n)",
"comment" : "\n    Convenience function which calls $(D $(LREF popFrontN)(range, n)) and\n    returns $(D range).\n\n    Examples:\n--------------------\nassert(drop([0, 2, 1, 5, 0, 3], 3) == [5, 0, 3]);\nassert(drop(\"hello world\", 6) == \"world\");\nassert(drop(\"hello world\", 50).empty);\nassert(equal(drop(take(\"hello world\", 6), 3), \"lo \"));\n--------------------\n  \n",
"line" : 2976}
]
}
,
{
"name" : "popFrontN(Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\nEagerly advances $(D r) itself (not a copy) $(D n) times (by calling\n$(D r.popFront) at most $(D n) times). The pass of $(D r) into $(D\npopFrontN) is by reference, so the original range is\naffected. Completes in $(BIGOH 1) steps for ranges that support\nslicing, and in $(BIGOH n) time for all other ranges.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popFrontN(2);\nassert(a == [ 3, 4, 5 ]);\n----\n",
"line" : 3013,
"members" : [
{
"name" : "popFrontN",
"kind" : "function",
"type" : "size_t(ref Range r, size_t n)",
"comment" : "\nEagerly advances $(D r) itself (not a copy) $(D n) times (by calling\n$(D r.popFront) at most $(D n) times). The pass of $(D r) into $(D\npopFrontN) is by reference, so the original range is\naffected. Completes in $(BIGOH 1) steps for ranges that support\nslicing, and in $(BIGOH n) time for all other ranges.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popFrontN(2);\nassert(a == [ 3, 4, 5 ]);\n----\n",
"line" : 3013}
]
}
,
{
"name" : "popBackN(Range) if (isInputRange!(Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Eagerly reduces $(D r) itself (not a copy) $(D n) times from its right\n   side (by calling $(D r.popBack) $(D n) times). The pass of $(D r) into\n   $(D popBackN) is by reference, so the original range is\n   affected. Completes in $(BIGOH 1) steps for ranges that support\n   slicing, and in $(BIGOH n) time for all other ranges.\n\n   Returns the actual number of elements popped.\n\n   Example:\n   ----\n   int[] a = [ 1, 2, 3, 4, 5 ];\n   a.popBackN(2);\n   assert(a == [ 1, 2, 3 ]);\n   ----\n",
"line" : 3065,
"members" : [
{
"name" : "popBackN",
"kind" : "function",
"type" : "size_t(ref Range r, size_t n)",
"comment" : "\n   Eagerly reduces $(D r) itself (not a copy) $(D n) times from its right\n   side (by calling $(D r.popBack) $(D n) times). The pass of $(D r) into\n   $(D popBackN) is by reference, so the original range is\n   affected. Completes in $(BIGOH 1) steps for ranges that support\n   slicing, and in $(BIGOH n) time for all other ranges.\n\n   Returns the actual number of elements popped.\n\n   Example:\n   ----\n   int[] a = [ 1, 2, 3, 4, 5 ];\n   a.popBackN(2);\n   assert(a == [ 1, 2, 3 ]);\n   ----\n",
"line" : 3065}
]
}
,
{
"name" : "Repeat(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nRepeats one value forever.\n\nExample:\n----\nenforce(equal(take(repeat(5), 4), [ 5, 5, 5, 5 ][]));\n----\n",
"line" : 3107,
"members" : [
{
"name" : "Repeat",
"kind" : "struct",
"protection" : "public",
"line" : 3107,
"members" : [
{
"name" : "_value",
"kind" : "variable",
"type" : "T",
"line" : 3108}
,
{
"name" : "front",
"kind" : "function",
"type" : "T()",
"comment" : " Range primitive implementations.\n",
"line" : 3110}
,
{
"name" : "back",
"kind" : "function",
"type" : "T()",
"comment" : " Ditto\n",
"line" : 3112}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"comment" : " Ditto\n",
"line" : 3114}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 3116}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 3118}
,
{
"name" : "save",
"kind" : "function",
"type" : "Repeat!(T)()",
"comment" : " Ditto\n",
"line" : 3120}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "T(size_t)",
"comment" : " Ditto\n",
"line" : 3122}
]
}
]
}
,
{
"name" : "repeat(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3126,
"members" : [
{
"name" : "repeat",
"kind" : "function",
"type" : "Repeat!(T)(T value)",
"comment" : " Ditto\n",
"line" : 3126}
]
}
,
{
"name" : "repeat(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Repeats $(D value) exactly $(D n) times. Equivalent to $(D\n   take(repeat(value), n)).\n",
"line" : 3138,
"members" : [
{
"name" : "repeat",
"kind" : "function",
"type" : "Take!(Repeat!(T))(T value, size_t n)",
"comment" : "\n   Repeats $(D value) exactly $(D n) times. Equivalent to $(D\n   take(repeat(value), n)).\n",
"line" : 3138}
]
}
,
{
"name" : "replicate(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in January 2013.\n          Please use $(LREF repeat) instead.)\n  \n",
"line" : 3147,
"members" : [
{
"name" : "replicate",
"kind" : "function",
"type" : "Take!(Repeat!(T))(T value, size_t n)",
"line" : 3147}
]
}
,
{
"name" : "Cycle(Range) if (isForwardRange!(Unqual!(Range)) && !isInfinite!(Unqual!(Range)))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nRepeats the given forward range ad infinitum. If the original range is\ninfinite (fact that would make $(D Cycle) the identity application),\n$(D Cycle) detects that and aliases itself to the range type\nitself. If the original range has random access, $(D Cycle) offers\nrandom access and also offers a constructor taking an initial position\n$(D index). $(D Cycle) is specialized for statically-sized arrays,\nmostly for performance reasons.\n\nExample:\n----\nassert(equal(take(cycle([1, 2][]), 5), [ 1, 2, 1, 2, 1 ][]));\n----\n\nTip: This is a great way to implement simple circular buffers.\n",
"line" : 3175,
"members" : [
{
"name" : "Cycle",
"kind" : "struct",
"protection" : "public",
"line" : 3175,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "Unqual!(Range)",
"line" : 3176}
]
}
]
}
,
{
"name" : "Cycle(R) if (isInfinite!(R))",
"kind" : "template",
"protection" : "public",
"line" : 3279,
"members" : [
{
"name" : "Cycle",
"kind" : "alias",
"type" : "R",
"line" : 3282}
]
}
,
{
"name" : "Cycle(R) if (isStaticArray!(R))",
"kind" : "struct",
"protection" : "public",
"line" : 3287,
"members" : [
{
"name" : "Cycle",
"kind" : "struct",
"protection" : "public",
"line" : 3287,
"members" : [
{
"name" : "ElementType",
"kind" : "alias",
"type" : "typeof(R[0])",
"line" : 3288}
,
{
"name" : "_ptr",
"kind" : "variable",
"type" : "ElementType*",
"line" : 3289}
,
{
"name" : "_index",
"kind" : "variable",
"type" : "size_t",
"line" : 3290}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref R input, size_t index = 0)",
"line" : 3292}
,
{
"name" : "front",
"kind" : "function",
"type" : "inout inout(ElementType)()",
"line" : 3298}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"line" : 3303}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 3305}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "inout inout(ElementType)(size_t n)",
"line" : 3307}
,
{
"name" : "save",
"kind" : "function",
"type" : "Cycle!(R)()",
"line" : 3312}
]
}
]
}
,
{
"name" : "cycle(R) if (isForwardRange!(Unqual!(R)) && !isInfinite!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3319,
"members" : [
{
"name" : "cycle",
"kind" : "function",
"type" : "Cycle!(R)(R input)",
"comment" : " Ditto\n",
"line" : 3319}
]
}
,
{
"name" : "cycle(R) if (isRandomAccessRange!(Unqual!(R)) && !isInfinite!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3326,
"members" : [
{
"name" : "cycle",
"kind" : "function",
"type" : "Cycle!(R)(R input, size_t index = 0)",
"comment" : " Ditto\n",
"line" : 3326}
]
}
,
{
"name" : "cycle(R) if (isInfinite!(R))",
"kind" : "template",
"protection" : "public",
"line" : 3332,
"members" : [
{
"name" : "cycle",
"kind" : "function",
"type" : "Cycle!(R)(R input)",
"line" : 3332}
]
}
,
{
"name" : "cycle(R) if (isStaticArray!(R))",
"kind" : "template",
"protection" : "public",
"line" : 3338,
"members" : [
{
"name" : "cycle",
"kind" : "function",
"type" : "Cycle!(R)(ref R input, size_t index = 0)",
"line" : 3338}
]
}
,
{
"name" : "lengthType(R)",
"kind" : "template",
"protection" : "public",
"line" : 3414,
"members" : [
{
"name" : "lengthType",
"kind" : "alias",
"type" : "typeof(delegate ()\n{\nR r = void;\nreturn r.length;\n}\n())",
"line" : 3414}
]
}
,
{
"name" : "Zip(Ranges...) if (Ranges.length && allSatisfy!(isInputRange,staticMap!(Unqual,Ranges)))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Iterate several ranges in lockstep. The element type is a proxy tuple\n   that allows accessing the current element in the $(D n)th range by\n   using $(D e[n]).\n\n   Example:\n   ----\n   int[] a = [ 1, 2, 3 ];\n   string[] b = [ \"a\", \"b\", \"c\" ];\n   \/\/ prints 1:a 2:b 3:c\n   foreach (e; zip(a, b))\n   {\n   write(e[0], ':', e[1], ' ');\n   }\n   ----\n\n   $(D Zip) offers the lowest range facilities of all components, e.g. it\n   offers random access iff all ranges offer random access, and also\n   offers mutation and swapping if all ranges offer it. Due to this, $(D\n   Zip) is extremely powerful because it allows manipulating several\n   ranges in lockstep. For example, the following code sorts two arrays\n   in parallel:\n\n   ----\n   int[] a = [ 1, 2, 3 ];\n   string[] b = [ \"a\", \"b\", \"c\" ];\n   sort!(\"a[0] > b[0]\")(zip(a, b));\n   assert(a == [ 3, 2, 1 ]);\n   assert(b == [ \"c\", \"b\", \"a\" ]);\n   ----\n",
"line" : 3449,
"members" : [
{
"name" : "Zip",
"kind" : "struct",
"protection" : "public",
"line" : 3449,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "staticMap!(Unqual,Ranges)",
"line" : 3450}
,
{
"name" : "ranges",
"kind" : "variable",
"type" : "Tuple!(R)",
"line" : 3451}
,
{
"name" : "ElementType",
"kind" : "alias",
"type" : "Tuple!(staticMap!(.ElementType,R))",
"line" : 3452}
,
{
"name" : "stoppingPolicy",
"kind" : "variable",
"type" : "StoppingPolicy",
"line" : 3453}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R rs, StoppingPolicy s = StoppingPolicy.shortest)",
"comment" : "\n   Builds an object. Usually this is invoked indirectly by using the\n   $(LREF zip) function.\n \n",
"line" : 3459}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType()",
"comment" : "\n   Returns the current iterated element.\n",
"line" : 3525}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n   Advances to the next element in all controlled ranges.\n",
"line" : 3652}
]
}
]
}
,
{
"name" : "zip(R...) if (allSatisfy!(isInputRange,staticMap!(Unqual,R)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3808,
"members" : [
{
"name" : "zip",
"kind" : "function",
"type" : "(R ranges)",
"comment" : " Ditto\n",
"line" : 3808}
]
}
,
{
"name" : "zip(R...) if (allSatisfy!(isInputRange,staticMap!(Unqual,R)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3815,
"members" : [
{
"name" : "zip",
"kind" : "function",
"type" : "(StoppingPolicy sp, R ranges)",
"comment" : " Ditto\n",
"line" : 3815}
]
}
,
{
"name" : "StoppingPolicy",
"kind" : "enum",
"protection" : "public",
"comment" : "\n   Dictates how iteration in a $(D Zip) should stop. By default stop at\n   the end of the shortest of all ranges.\n",
"line" : 3826,
"base" : "int",
"members" : [
{
"name" : "shortest",
"kind" : "enum member",
"protection" : "public",
"comment" : " Stop when the shortest range is exhausted\n",
"line" : 3828}
,
{
"name" : "longest",
"kind" : "enum member",
"protection" : "public",
"comment" : " Stop when the longest range is exhausted\n",
"line" : 3830}
,
{
"name" : "requireSameLength",
"kind" : "enum member",
"protection" : "public",
"comment" : " Require that all ranges are equal\n",
"line" : 3832}
]
}
,
{
"name" : "lockstepApply(Ranges...) if (Ranges.length > 0)",
"kind" : "template",
"protection" : "public",
"line" : 3963,
"members" : [
{
"name" : "lockstepApply",
"kind" : "function",
"type" : "string(bool withIndex)",
"line" : 3963}
]
}
,
{
"name" : "Lockstep(Ranges...) if (Ranges.length > 1 && allSatisfy!(isInputRange,staticMap!(Unqual,Ranges)))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Iterate multiple ranges in lockstep using a $(D foreach) loop.  If only a single\n   range is passed in, the $(D Lockstep) aliases itself away.  If the\n   ranges are of different lengths and $(D s) == $(D StoppingPolicy.shortest)\n   stop after the shortest range is empty.  If the ranges are of different\n   lengths and $(D s) == $(D StoppingPolicy.requireSameLength), throw an\n   exception.  $(D s) may not be $(D StoppingPolicy.longest), and passing this\n   will throw an exception.\n\n   BUGS:  If a range does not offer lvalue access, but $(D ref) is used in the\n   $(D foreach) loop, it will be silently accepted but any modifications\n   to the variable will not be propagated to the underlying range.\n\n   Examples:\n   ---\n   auto arr1 = [1,2,3,4,5];\n   auto arr2 = [6,7,8,9,10];\n\n   foreach(ref a, ref b; lockstep(arr1, arr2))\n   {\n       a += b;\n   }\n\n   assert(arr1 == [7,9,11,13,15]);\n\n   \/\/ Lockstep also supports iterating with an index variable:\n   foreach(index, a, b; lockstep(arr1, arr2)) {\n       writefln(\"Index %s:  a = %s, b = %s\", index, a, b);\n   }\n   ---\n",
"line" : 4078,
"members" : [
{
"name" : "Lockstep",
"kind" : "struct",
"protection" : "public",
"line" : 4078,
"members" : [
{
"name" : "R",
"kind" : "alias",
"type" : "staticMap!(Unqual,Ranges)",
"line" : 4080}
,
{
"name" : "_ranges",
"kind" : "variable",
"type" : "R",
"line" : 4081}
,
{
"name" : "_s",
"kind" : "variable",
"type" : "StoppingPolicy",
"line" : 4082}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R ranges, StoppingPolicy s = StoppingPolicy.shortest)",
"line" : 4085}
]
}
]
}
,
{
"name" : "Lockstep(Range)",
"kind" : "template",
"protection" : "public",
"line" : 4099,
"members" : [
{
"name" : "Lockstep",
"kind" : "alias",
"type" : "Range",
"line" : 4101}
]
}
,
{
"name" : "lockstep(Args...) if (allSatisfy!(isInputRange,staticMap!(Unqual,Args)) || allSatisfy!(isInputRange,staticMap!(Unqual,Args[0 .. __dollar - 1])) && is(Args[__dollar - 1] == StoppingPolicy))",
"kind" : "template",
"protection" : "public",
"line" : 4117,
"members" : [
{
"name" : "lockstep",
"kind" : "function",
"type" : "(Args args)",
"line" : 4117}
]
}
,
{
"name" : "Recurrence(alias fun,StateType,ulong stateSize)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nCreates a mathematical sequence given the initial values and a\nrecurrence function that computes the next value from the existing\nvalues. The sequence comes in the form of an infinite forward\nrange. The type $(D Recurrence) itself is seldom used directly; most\noften, recurrences are obtained by calling the function $(D\nrecurrence).\n\nWhen calling $(D recurrence), the function that computes the next\nvalue is specified as a template argument, and the initial values in\nthe recurrence are passed as regular arguments. For example, in a\nFibonacci sequence, there are two initial values (and therefore a\nstate size of 2) because computing the next Fibonacci value needs the\npast two values.\n\nIf the function is passed in string form, the state has name $(D \"a\")\nand the zero-based index in the recurrence has name $(D \"n\"). The\ngiven string must return the desired value for $(D a[n]) given $(D a[n\n- 1]), $(D a[n - 2]), $(D a[n - 3]),..., $(D a[n - stateSize]). The\nstate size is dictated by the number of arguments passed to the call\nto $(D recurrence). The $(D Recurrence) struct itself takes care of\nmanaging the recurrence's state and shifting it appropriately.\n\nExample:\n----\n\/\/ a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]\nauto fib = recurrence!(\"a[n-1] + a[n-2]\")(1, 1);\n\/\/ print the first 10 Fibonacci numbers\nforeach (e; take(fib, 10)) { writeln(e); }\n\/\/ print the first 10 factorials\nforeach (e; take(recurrence!(\"a[n-1] * n\")(1), 10)) { writeln(e); }\n----\n \n",
"line" : 4260,
"members" : [
{
"name" : "Recurrence",
"kind" : "struct",
"protection" : "public",
"line" : 4260,
"members" : [
{
"name" : "_state",
"kind" : "variable",
"type" : "StateType[stateSize]",
"line" : 4261}
,
{
"name" : "_n",
"kind" : "variable",
"type" : "size_t",
"line" : 4262}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(StateType[stateSize] initial)",
"line" : 4264}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 4266}
,
{
"name" : "front",
"kind" : "function",
"type" : "StateType()",
"line" : 4276}
,
{
"name" : "save",
"kind" : "function",
"type" : "typeof(this)()",
"line" : 4281}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"line" : 4286}
]
}
]
}
,
{
"name" : "recurrence(alias fun,State...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4291,
"members" : [
{
"name" : "recurrence",
"kind" : "function",
"type" : "Recurrence!(fun,CommonType!(State),State.length)(State initial)",
"comment" : " Ditto\n",
"line" : 4291}
]
}
,
{
"name" : "Sequence(alias fun,State)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   $(D Sequence) is similar to $(D Recurrence) except that iteration is\n   presented in the so-called $(WEB en.wikipedia.org\/wiki\/Closed_form,\n   closed form). This means that the $(D n)th element in the series is\n   computable directly from the initial values and $(D n) itself. This\n   implies that the interface offered by $(D Sequence) is a random-access\n   range, as opposed to the regular $(D Recurrence), which only offers\n   forward iteration.\n\n   The state of the sequence is stored as a $(D Tuple) so it can be\n   heterogeneous.\n\n   Example:\n   ----\n   \/\/ a[0] = 1, a[1] = 2, a[n] = a[0] + n * a[1]\n   auto odds = sequence!(\"a[0] + n * a[1]\")(1, 2);\n   ----\n",
"line" : 4339,
"members" : [
{
"name" : "Sequence",
"kind" : "struct",
"protection" : "public",
"line" : 4339,
"members" : [
{
"name" : "compute",
"kind" : "alias",
"type" : "binaryFun!(fun,\"a\",\"n\")",
"line" : 4341}
,
{
"name" : "ElementType",
"kind" : "alias",
"type" : "typeof(compute(State.init,cast(size_t)1))",
"line" : 4342}
,
{
"name" : "_state",
"kind" : "variable",
"type" : "State",
"line" : 4343}
,
{
"name" : "_n",
"kind" : "variable",
"type" : "size_t",
"line" : 4344}
,
{
"name" : "_cache",
"kind" : "variable",
"type" : "ElementType",
"line" : 4345}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(State initial, size_t n = 0)",
"line" : 4348}
,
{
"name" : "front",
"kind" : "function",
"type" : "ElementType()",
"line" : 4355}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "ElementType()",
"line" : 4361}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 4366}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "ElementType(size_t n)",
"line" : 4373}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"line" : 4379}
,
{
"name" : "save",
"kind" : "function",
"type" : "Sequence()",
"line" : 4381}
]
}
]
}
,
{
"name" : "sequence(alias fun,State...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4385,
"members" : [
{
"name" : "sequence",
"kind" : "function",
"type" : "Sequence!(fun,Tuple!(State))(State args)",
"comment" : " Ditto\n",
"line" : 4385}
]
}
,
{
"name" : "iota(B,E,S) if ((isIntegral!(CommonType!(B,E)) || isPointer!(CommonType!(B,E))) && isIntegral!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Returns a range that goes through the numbers $(D begin), $(D begin +\n   step), $(D begin + 2 * step), $(D ...), up to and excluding $(D\n   end). The range offered is a random access range. The two-arguments\n   version has $(D step = 1). If $(D begin < end && step < 0) or $(D\n   begin > end && step > 0) or $(D begin == end), then an empty range is\n   returned.\n\n   Throws:\n   $(D Exception) if $(D begin != end && step == 0), an exception is\n   thrown.\n\n   Example:\n   ----\n   auto r = iota(0, 10, 1);\n   assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][]));\n   r = iota(0, 11, 3);\n   assert(equal(r, [0, 3, 6, 9][]));\n   assert(r[2] == 6);\n   auto rf = iota(0.0, 0.5, 0.1);\n   assert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));\n   ----\n",
"line" : 4444,
"members" : [
{
"name" : "iota",
"kind" : "function",
"type" : "(B begin, E end, S step)",
"comment" : "\n   Returns a range that goes through the numbers $(D begin), $(D begin +\n   step), $(D begin + 2 * step), $(D ...), up to and excluding $(D\n   end). The range offered is a random access range. The two-arguments\n   version has $(D step = 1). If $(D begin < end && step < 0) or $(D\n   begin > end && step > 0) or $(D begin == end), then an empty range is\n   returned.\n\n   Throws:\n   $(D Exception) if $(D begin != end && step == 0), an exception is\n   thrown.\n\n   Example:\n   ----\n   auto r = iota(0, 10, 1);\n   assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][]));\n   r = iota(0, 11, 3);\n   assert(equal(r, [0, 3, 6, 9][]));\n   assert(r[2] == 6);\n   auto rf = iota(0.0, 0.5, 0.1);\n   assert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));\n   ----\n",
"line" : 4444}
]
}
,
{
"name" : "iota(B,E) if (isFloatingPoint!(CommonType!(B,E)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4527,
"members" : [
{
"name" : "iota",
"kind" : "function",
"type" : "(B begin, E end)",
"comment" : " Ditto\n",
"line" : 4527}
]
}
,
{
"name" : "iota(B,E) if (isIntegral!(CommonType!(B,E)) || isPointer!(CommonType!(B,E)))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4534,
"members" : [
{
"name" : "iota",
"kind" : "function",
"type" : "(B begin, E end)",
"comment" : " Ditto\n",
"line" : 4534}
]
}
,
{
"name" : "iota(E)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4593,
"members" : [
{
"name" : "iota",
"kind" : "function",
"type" : "(E end)",
"comment" : " Ditto\n",
"line" : 4593}
]
}
,
{
"name" : "iota(B,E,S) if (isFloatingPoint!(CommonType!(B,E,S)))",
"kind" : "template",
"protection" : "public",
"line" : 4600,
"members" : [
{
"name" : "iota",
"kind" : "function",
"type" : "(B begin, E end, S step)",
"line" : 4600}
]
}
,
{
"name" : "TransverseOptions",
"kind" : "enum",
"protection" : "public",
"comment" : "\n   Options for the $(LREF FrontTransversal) and $(LREF Transversal) ranges\n   (below).\n",
"line" : 4845,
"base" : "int",
"members" : [
{
"name" : "assumeJagged",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n   When transversed, the elements of a range of ranges are assumed to\n   have different lengths (e.g. a jagged array).\n",
"line" : 4850}
,
{
"name" : "enforceNotJagged",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       The transversal enforces that the elements of a range of ranges have\n       all the same length (e.g. an array of arrays, all having the same\n       length). Checking is done once upon construction of the transversal\n       range.\n    \n",
"line" : 4857}
,
{
"name" : "assumeNotJagged",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       The transversal assumes, without verifying, that the elements of a\n       range of ranges have all the same length. This option is useful if\n       checking was already done from the outside of the range.\n    \n",
"line" : 4863}
]
}
,
{
"name" : "FrontTransversal(Ror,TransverseOptions opt = TransverseOptions.assumeJagged)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Given a range of ranges, iterate transversally through the first\n   elements of each of the enclosed ranges.\n\n   Example:\n   ----\n   int[][] x = new int[][2];\n   x[0] = [1, 2];\n   x[1] = [3, 4];\n   auto ror = frontTransversal(x);\n   assert(equal(ror, [ 1, 3 ][]));\n   ---\n",
"line" : 4881,
"members" : [
{
"name" : "FrontTransversal",
"kind" : "struct",
"protection" : "public",
"line" : 4881,
"members" : [
{
"name" : "RangeOfRanges",
"kind" : "alias",
"type" : "Unqual!(Ror)",
"line" : 4882}
,
{
"name" : "ElementType",
"kind" : "alias",
"type" : "typeof(RangeOfRanges.init.front.front)",
"line" : 4883}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void()",
"line" : 4885}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(RangeOfRanges input)",
"comment" : "\n   Construction from an input.\n",
"line" : 4906}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"comment" : " Ditto\n",
"line" : 4940}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 4963}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "()",
"line" : 5063}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "RangeOfRanges",
"line" : 5066}
]
}
]
}
,
{
"name" : "frontTransversal(TransverseOptions opt = TransverseOptions.assumeJagged,RangeOfRanges)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 5070,
"members" : [
{
"name" : "frontTransversal",
"kind" : "function",
"type" : "FrontTransversal!(RangeOfRanges,opt)(RangeOfRanges rr)",
"comment" : " Ditto\n",
"line" : 5070}
]
}
,
{
"name" : "Transversal(Ror,TransverseOptions opt = TransverseOptions.assumeJagged)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Given a range of ranges, iterate transversally through the the $(D\n   n)th element of each of the enclosed ranges. All elements of the\n   enclosing range must offer random access.\n\n   Example:\n   ----\n   int[][] x = new int[][2];\n   x[0] = [1, 2];\n   x[1] = [3, 4];\n   auto ror = transversal(x, 1);\n   assert(equal(ror, [ 2, 4 ][]));\n   ---\n",
"line" : 5153,
"members" : [
{
"name" : "Transversal",
"kind" : "struct",
"protection" : "public",
"line" : 5153,
"members" : [
{
"name" : "RangeOfRanges",
"kind" : "alias",
"type" : "Unqual!(Ror)",
"line" : 5154}
,
{
"name" : "InnerRange",
"kind" : "alias",
"type" : "ElementType!(RangeOfRanges)",
"line" : 5155}
,
{
"name" : "E",
"kind" : "alias",
"type" : "ElementType!(InnerRange)",
"line" : 5156}
,
{
"name" : "prime",
"kind" : "function",
"type" : "void()",
"line" : 5158}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(RangeOfRanges input, size_t n)",
"comment" : "\n   Construction from an input and an index.\n",
"line" : 5179}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"comment" : " Ditto\n",
"line" : 5212}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 5237}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "()",
"line" : 5351}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "RangeOfRanges",
"line" : 5354}
,
{
"name" : "_n",
"kind" : "variable",
"type" : "size_t",
"line" : 5355}
]
}
]
}
,
{
"name" : "transversal(TransverseOptions opt = TransverseOptions.assumeJagged,RangeOfRanges)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 5359,
"members" : [
{
"name" : "transversal",
"kind" : "function",
"type" : "Transversal!(RangeOfRanges,opt)(RangeOfRanges rr, size_t n)",
"comment" : " Ditto\n",
"line" : 5359}
]
}
,
{
"name" : "Transposed(RangeOfRanges)",
"kind" : "struct",
"protection" : "public",
"line" : 5424,
"members" : [
{
"name" : "Transposed",
"kind" : "struct",
"protection" : "public",
"line" : 5424,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(RangeOfRanges input)",
"line" : 5427}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ()",
"line" : 5433}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 5437}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 5451}
,
{
"name" : "save",
"kind" : "function",
"type" : "Transposed()",
"line" : 5458}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "()",
"line" : 5463}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "RangeOfRanges",
"line" : 5466}
]
}
]
}
,
{
"name" : "transposed(RangeOfRanges)",
"kind" : "template",
"protection" : "public",
"line" : 5469,
"members" : [
{
"name" : "transposed",
"kind" : "function",
"type" : "(RangeOfRanges rr)",
"line" : 5469}
]
}
,
{
"name" : "Indexed(Source,Indices) if (isRandomAccessRange!(Source) && isInputRange!(Indices) && is(typeof(Source.init[ElementType!(Indices).init])))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nThis struct takes two ranges, $(D source) and $(D indices), and creates a view\nof $(D source) as if its elements were reordered according to $(D indices).\n$(D indices) may include only a subset of the elements of $(D source) and\nmay also repeat elements.\n\n$(D Source) must be a random access range.  The returned range will be\nbidirectional or random-access if $(D Indices) is bidirectional or\nrandom-access, respectively.\n\nExamples:\n---\nauto source = [1, 2, 3, 4, 5];\nauto indices = [4, 3, 1, 2, 0, 4];\nauto ind = indexed(source, indices);\nassert(equal(ind, [5, 4, 2, 3, 1, 5]));\n\n\/\/ When elements of indices are duplicated and Source has lvalue elements,\n\/\/ these are aliased in ind.\nind[0]++;\nassert(ind[0] == 6);\nassert(ind[5] == 6);\n---\n",
"line" : 5516,
"members" : [
{
"name" : "Indexed",
"kind" : "struct",
"protection" : "public",
"line" : 5516,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Source source, Indices indices)",
"line" : 5517}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ref ()",
"comment" : " Range primitives\n",
"line" : 5525}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 5531}
,
{
"name" : "source",
"kind" : "function",
"type" : "Source()",
"comment" : "\n    Returns the source range.\n    \n",
"line" : 5671}
,
{
"name" : "indices",
"kind" : "function",
"type" : "Indices()",
"comment" : "\n    Returns the indices range.\n    \n",
"line" : 5679}
,
{
"name" : "_source",
"kind" : "variable",
"type" : "Source",
"line" : 5704}
,
{
"name" : "_indices",
"kind" : "variable",
"type" : "Indices",
"line" : 5705}
]
}
]
}
,
{
"name" : "indexed(Source,Indices)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 5710,
"members" : [
{
"name" : "indexed",
"kind" : "function",
"type" : "Indexed!(Source,Indices)(Source source, Indices indices)",
"comment" : " Ditto\n",
"line" : 5710}
]
}
,
{
"name" : "Chunks(Source) if (hasSlicing!(Source) && hasLength!(Source))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nThis range iterates over fixed-sized chunks of size $(D chunkSize) of a\n$(D source) range.  $(D Source) must be an input range with slicing and length.\nIf $(D source.length) is not evenly divisible by $(D chunkSize), the back\nelement of this range will contain fewer than $(D chunkSize) elements.\n\nExamples:\n---\nauto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto chunks = chunks(source, 4);\nassert(chunks[0] == [1, 2, 3, 4]);\nassert(chunks[1] == [5, 6, 7, 8]);\nassert(chunks[2] == [9, 10]);\nassert(chunks.back == chunks[2]);\nassert(chunks.front == chunks[0]);\nassert(chunks.length == 3);\n---\n",
"line" : 5764,
"members" : [
{
"name" : "Chunks",
"kind" : "struct",
"protection" : "public",
"line" : 5764,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Source source, size_t chunkSize)",
"comment" : "\n",
"line" : 5766}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ()",
"comment" : " Range primitives.\n",
"line" : 5774}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 5780}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : " Ditto\n",
"line" : 5787}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "(size_t index)",
"comment" : " Ditto\n",
"line" : 5803}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "typeof(this)(size_t lower, size_t upper)",
"comment" : " Ditto\n",
"line" : 5809}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : " Ditto\n",
"line" : 5817}
,
{
"name" : "opDollar",
"kind" : "alias",
"type" : "length",
"line" : 5823}
,
{
"name" : "back",
"kind" : "function",
"type" : "@property ()",
"comment" : " Ditto\n",
"line" : 5827}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 5845}
,
{
"name" : "_source",
"kind" : "variable",
"type" : "Source",
"line" : 5863}
,
{
"name" : "_chunkSize",
"kind" : "variable",
"type" : "size_t",
"line" : 5864}
]
}
]
}
,
{
"name" : "chunks(Source)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 5868,
"members" : [
{
"name" : "chunks",
"kind" : "function",
"type" : "Chunks!(Source)(Source source, size_t chunkSize)",
"comment" : " Ditto\n",
"line" : 5868}
]
}
,
{
"name" : "moveFront(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Moves the front of $(D r) out and returns it. Leaves $(D r.front) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
"line" : 5901,
"members" : [
{
"name" : "moveFront",
"kind" : "function",
"type" : "ElementType!(R)(R r)",
"comment" : "\n   Moves the front of $(D r) out and returns it. Leaves $(D r.front) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
"line" : 5901}
]
}
,
{
"name" : "moveBack(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Moves the back of $(D r) out and returns it. Leaves $(D r.back) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
"line" : 5931,
"members" : [
{
"name" : "moveBack",
"kind" : "function",
"type" : "ElementType!(R)(R r)",
"comment" : "\n   Moves the back of $(D r) out and returns it. Leaves $(D r.back) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
"line" : 5931}
]
}
,
{
"name" : "moveAt(R,I) if (isIntegral!(I))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Moves element at index $(D i) of $(D r) out and returns it. Leaves $(D\n   r.front) in a destroyable state that does not allocate any resources\n   (usually equal to its $(D .init) value).\n",
"line" : 5967,
"members" : [
{
"name" : "moveAt",
"kind" : "function",
"type" : "ElementType!(R)(R r, I i)",
"comment" : "\n   Moves element at index $(D i) of $(D r) out and returns it. Leaves $(D\n   r.front) in a destroyable state that does not allocate any resources\n   (usually equal to its $(D .init) value).\n",
"line" : 5967}
]
}
,
{
"name" : "InputRange(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "These interfaces are intended to provide virtual function-based wrappers\n around input ranges with element type E.  This is useful where a well-defined\n binary interface is required, such as when a DLL function or virtual function\n needs to accept a generic range as a parameter.  Note that\n $(D isInputRange) and friends check for conformance to structural\n interfaces, not for implementation of these $(D interface) types.\n\n Examples:\n ---\n class UsesRanges {\n     void useRange(InputRange range) {\n         \/\/ Function body.\n     }\n }\n\n \/\/ Create a range type.\n auto squares = map!\"a * a\"(iota(10));\n\n \/\/ Wrap it in an interface.\n auto squaresWrapped = inputRangeObject(squares);\n\n \/\/ Use it.\n auto usesRanges = new UsesRanges;\n usesRanges.useRange(squaresWrapped);\n ---\n\n Limitations:\n\n These interfaces are not capable of forwarding $(D ref) access to elements.\n\n Infiniteness of the wrapped range is not propagated.\n\n Length is not propagated in the case of non-random access ranges.\n\n \n",
"line" : 6045,
"members" : [
{
"name" : "InputRange",
"kind" : "interface",
"protection" : "public",
"line" : 6045,
"members" : [
{
"name" : "front",
"kind" : "function",
"type" : "E()",
"comment" : "\n",
"line" : 6047}
,
{
"name" : "moveFront",
"kind" : "function",
"type" : "E()",
"comment" : "\n",
"line" : 6050}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "\n",
"line" : 6053}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "\n",
"line" : 6056}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(int delegate(E))",
"comment" : "$(D foreach) iteration uses opApply, since one delegate call per loop\n iteration is faster than three virtual function calls.\n     \n",
"line" : 6070}
,
{
"name" : "opApply",
"kind" : "function",
"type" : "int(int delegate(size_t, E))",
"comment" : " Ditto\n",
"line" : 6073}
]
}
]
}
,
{
"name" : "ForwardRange(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Interface for a forward range of type $(D E).\n",
"line" : 6078,
"members" : [
{
"name" : "ForwardRange",
"kind" : "interface",
"protection" : "public",
"line" : 6078,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "ForwardRange!(E)()",
"comment" : "\n",
"line" : 6080}
]
}
]
}
,
{
"name" : "BidirectionalRange(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Interface for a bidirectional range of type $(D E).\n",
"line" : 6084,
"members" : [
{
"name" : "BidirectionalRange",
"kind" : "interface",
"protection" : "public",
"line" : 6084,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "BidirectionalRange!(E)()",
"comment" : "\n",
"line" : 6086}
,
{
"name" : "back",
"kind" : "function",
"type" : "E()",
"comment" : "\n",
"line" : 6089}
,
{
"name" : "moveBack",
"kind" : "function",
"type" : "E()",
"comment" : "\n",
"line" : 6092}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : "\n",
"line" : 6095}
]
}
]
}
,
{
"name" : "RandomAccessFinite(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Interface for a finite random access range of type $(D E).\n",
"line" : 6099,
"members" : [
{
"name" : "RandomAccessFinite",
"kind" : "interface",
"protection" : "public",
"line" : 6099,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "RandomAccessFinite!(E)()",
"comment" : "\n",
"line" : 6101}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "E(size_t)",
"comment" : "\n",
"line" : 6104}
,
{
"name" : "moveAt",
"kind" : "function",
"type" : "E(size_t)",
"comment" : "\n",
"line" : 6107}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : "\n",
"line" : 6110}
,
{
"name" : "opDollar",
"kind" : "alias",
"type" : "length",
"comment" : "\n",
"line" : 6113}
]
}
]
}
,
{
"name" : "RandomAccessInfinite(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Interface for an infinite random access range of type $(D E).\n",
"line" : 6124,
"members" : [
{
"name" : "RandomAccessInfinite",
"kind" : "interface",
"protection" : "public",
"line" : 6124,
"members" : [
{
"name" : "moveAt",
"kind" : "function",
"type" : "E(size_t)",
"comment" : "\n",
"line" : 6126}
,
{
"name" : "save",
"kind" : "function",
"type" : "RandomAccessInfinite!(E)()",
"comment" : "\n",
"line" : 6129}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "E(size_t)",
"comment" : "\n",
"line" : 6132}
]
}
]
}
,
{
"name" : "InputAssignable(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Adds assignable elements to InputRange.\n",
"line" : 6136,
"members" : [
{
"name" : "InputAssignable",
"kind" : "interface",
"protection" : "public",
"line" : 6136,
"members" : [
{
"name" : "front",
"kind" : "function",
"type" : "void(E newVal)",
"comment" : "\n",
"line" : 6138}
]
}
]
}
,
{
"name" : "ForwardAssignable(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Adds assignable elements to ForwardRange.\n",
"line" : 6142,
"members" : [
{
"name" : "ForwardAssignable",
"kind" : "interface",
"protection" : "public",
"line" : 6142,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "ForwardAssignable!(E)()",
"comment" : "\n",
"line" : 6144}
]
}
]
}
,
{
"name" : "BidirectionalAssignable(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Adds assignable elements to BidirectionalRange.\n",
"line" : 6148,
"members" : [
{
"name" : "BidirectionalAssignable",
"kind" : "interface",
"protection" : "public",
"line" : 6148,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "BidirectionalAssignable!(E)()",
"comment" : "\n",
"line" : 6150}
,
{
"name" : "back",
"kind" : "function",
"type" : "void(E newVal)",
"comment" : "\n",
"line" : 6153}
]
}
]
}
,
{
"name" : "RandomFiniteAssignable(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Adds assignable elements to RandomAccessFinite.\n",
"line" : 6157,
"members" : [
{
"name" : "RandomFiniteAssignable",
"kind" : "interface",
"protection" : "public",
"line" : 6157,
"members" : [
{
"name" : "save",
"kind" : "function",
"type" : "RandomFiniteAssignable!(E)()",
"comment" : "\n",
"line" : 6159}
,
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "void(E val, size_t index)",
"comment" : "\n",
"line" : 6162}
]
}
]
}
,
{
"name" : "OutputRange(E)",
"kind" : "interface",
"protection" : "public",
"comment" : "Interface for an output range of type $(D E).  Usage is similar to the\n $(D InputRange) interface and descendants.\n",
"line" : 6167,
"members" : [
{
"name" : "OutputRange",
"kind" : "interface",
"protection" : "public",
"line" : 6167,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(E)",
"comment" : "\n",
"line" : 6169}
]
}
]
}
,
{
"name" : "putMethods(E...)",
"kind" : "template",
"protection" : "public",
"line" : 6174,
"members" : [
{
"name" : "putMethods",
"kind" : "function",
"type" : "string()",
"line" : 6174}
]
}
,
{
"name" : "OutputRangeObject(R,E...)",
"kind" : "class",
"protection" : "public",
"comment" : "Implements the $(D OutputRange) interface for all types E and wraps the\n $(D put) method for each type $(D E) in a virtual function.\n \n",
"line" : 6187,
"members" : [
{
"name" : "OutputRangeObject",
"kind" : "class",
"protection" : "public",
"line" : 6187,
"members" : [
{
"name" : "_range",
"kind" : "variable",
"type" : "R",
"line" : 6190}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(R range)",
"line" : 6192}
]
}
]
}
,
{
"name" : "MostDerivedInputRange(R) if (isInputRange!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : "Returns the interface type that best matches $(D R).\n",
"line" : 6201,
"members" : [
{
"name" : "E",
"kind" : "alias",
"type" : "ElementType!(R)",
"line" : 6202}
]
}
,
{
"name" : "InputRangeObject(R) if (isInputRange!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : "Implements the most derived interface that $(D R) works with and wraps\n all relevant range primitives in virtual functions.  If $(D R) is already\n derived from the $(D InputRange) interface, aliases itself away.\n \n",
"line" : 6237,
"members" : [
]
}
,
{
"name" : "inputRangeObject(R) if (isInputRange!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "Convenience function for creating a $(D InputRangeObject) of the proper type.\n",
"line" : 6353,
"members" : [
{
"name" : "inputRangeObject",
"kind" : "function",
"type" : "InputRangeObject!(R)(R range)",
"comment" : "Convenience function for creating a $(D InputRangeObject) of the proper type.\n",
"line" : 6353}
]
}
,
{
"name" : "outputRangeObject(E...)",
"kind" : "template",
"protection" : "public",
"comment" : "Convenience function for creating a $(D OutputRangeObject) with a base range\n of type $(D R) that accepts types $(D E).\n\n Examples:\n ---\n uint[] outputArray;\n auto app = appender(&outputArray);\n auto appWrapped = outputRangeObject!(uint, uint[])(app);\n static assert(is(typeof(appWrapped) : OutputRange!(uint[])));\n static assert(is(typeof(appWrapped) : OutputRange!(uint)));\n ---\n",
"line" : 6373,
"members" : [
{
"name" : "outputRangeObject(R)",
"kind" : "template",
"protection" : "public",
"comment" : "\n",
"line" : 6376,
"members" : [
{
"name" : "outputRangeObject",
"kind" : "function",
"type" : "OutputRangeObject!(R,E)(R range)",
"comment" : "\n",
"line" : 6376}
]
}
]
}
,
{
"name" : "isTwoWayCompatible(alias fn,T1,T2)",
"kind" : "template",
"protection" : "public",
"comment" : "\n  Returns true if $(D fn) accepts variables of type T1 and T2 in any order.\n  The following code should compile:\n  ---\n  T1 foo();\n  T2 bar();\n\n  fn(foo(), bar());\n  fn(bar(), foo());\n  ---\n",
"line" : 6435,
"members" : [
{
"name" : "isTwoWayCompatible",
"kind" : "variable",
"line" : 6444}
]
}
,
{
"name" : "SearchPolicy",
"kind" : "enum",
"protection" : "public",
"comment" : "\n   Policy used with the searching primitives $(D lowerBound), $(D\n   upperBound), and $(D equalRange) of $(LREF SortedRange) below.\n \n",
"line" : 6453,
"base" : "int",
"members" : [
{
"name" : "trot",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Searches with a step that is grows linearly (1, 2, 3,...)\n       leading to a quadratic search schedule (indexes tried are 0, 1,\n       3, 6, 10, 15, 21, 28,...) Once the search overshoots its target,\n       the remaining interval is searched using binary search. The\n       search is completed in $(BIGOH sqrt(n)) time. Use it when you\n       are reasonably confident that the value is around the beginning\n       of the range.\n    \n",
"line" : 6463}
,
{
"name" : "gallop",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Performs a $(LUCKY galloping search algorithm), i.e. searches\n       with a step that doubles every time, (1, 2, 4, 8, ...)  leading\n       to an exponential search schedule (indexes tried are 0, 1, 3,\n       7, 15, 31, 63,...) Once the search overshoots its target, the\n       remaining interval is searched using binary search. A value is\n       found in $(BIGOH log(n)) time.\n    \n",
"line" : 6473}
,
{
"name" : "binarySearch",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Searches using a classic interval halving policy. The search\n       starts in the middle of the range, and each search step cuts\n       the range in half. This policy finds a value in $(BIGOH log(n))\n       time but is less cache friendly than $(D gallop) for large\n       ranges. The $(D binarySearch) policy is used as the last step\n       of $(D trot), $(D gallop), $(D trotBackwards), and $(D\n       gallopBackwards) strategies.\n    \n",
"line" : 6484}
,
{
"name" : "trotBackwards",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Similar to $(D trot) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n    \n",
"line" : 6490}
,
{
"name" : "gallopBackwards",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n       Similar to $(D gallop) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n    \n",
"line" : 6496}
]
}
,
{
"name" : "SortedRange(Range,alias pred = \"a < b\") if (isRandomAccessRange!(Range))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n   Represents a sorted random-access range. In addition to the regular\n   range primitives, supports fast operations using binary search. To\n   obtain a $(D SortedRange) from an unsorted range $(D r), use\n   $(XREF algorithm, sort) which sorts $(D r) in place and returns the\n   corresponding $(D SortedRange). To construct a $(D SortedRange)\n   from a range $(D r) that is known to be already sorted, use\n   $(LREF assumeSorted) described below.\n\n   Example:\n\n   ----\n   auto a = [ 1, 2, 3, 42, 52, 64 ];\n   auto r = assumeSorted(a);\n   assert(r.contains(3));\n   assert(!r.contains(32));\n   auto r1 = sort!\"a > b\"(a);\n   assert(r1.contains(3));\n   assert(!r1.contains(32));\n   assert(r1.release() == [ 64, 52, 42, 3, 2, 1 ]);\n   ----\n\n   $(D SortedRange) could accept ranges weaker than random-access, but it\n   is unable to provide interesting functionality for them. Therefore,\n   $(D SortedRange) is currently restricted to random-access ranges.\n\n   No copy of the original range is ever made. If the underlying range is\n   changed concurrently with its corresponding $(D SortedRange) in ways\n   that break its sortedness, $(D SortedRange) will work erratically.\n\n   Example:\n\n   ----\n   auto a = [ 1, 2, 3, 42, 52, 64 ];\n   auto r = assumeSorted(a);\n   assert(r.contains(42));\n   swap(a[3], a[5]);                      \/\/ illegal to break sortedness of original range\n   assert(!r.contains(42));                \/\/ passes although it shouldn't\n   ----\n",
"line" : 6541,
"members" : [
{
"name" : "SortedRange",
"kind" : "struct",
"protection" : "public",
"line" : 6541,
"members" : [
{
"name" : "predFun",
"kind" : "alias",
"type" : "binaryFun!(pred)",
"line" : 6542}
,
{
"name" : "geq(L,R)",
"kind" : "template",
"protection" : "public",
"line" : 6543,
"members" : [
{
"name" : "geq",
"kind" : "function",
"type" : "bool(L lhs, R rhs)",
"line" : 6543}
]
}
,
{
"name" : "gt(L,R)",
"kind" : "template",
"protection" : "public",
"line" : 6547,
"members" : [
{
"name" : "gt",
"kind" : "function",
"type" : "bool(L lhs, R rhs)",
"line" : 6547}
]
}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 6551}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input)",
"line" : 6555}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : " Range primitives.\n",
"line" : 6576}
,
{
"name" : "save",
"kind" : "function",
"type" : "@property ()",
"comment" : " Ditto\n",
"line" : 6583}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ()",
"comment" : " Ditto\n",
"line" : 6592}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 6597}
,
{
"name" : "back",
"kind" : "function",
"type" : "@property ()",
"comment" : " Ditto\n",
"line" : 6604}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 6609}
,
{
"name" : "opIndex",
"kind" : "function",
"type" : "(size_t i)",
"comment" : " Ditto\n",
"line" : 6616}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "(size_t a, size_t b)",
"comment" : " Ditto\n",
"line" : 6622}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : " Ditto\n",
"line" : 6630}
,
{
"name" : "opDollar",
"kind" : "alias",
"type" : "length",
"line" : 6635}
,
{
"name" : "release",
"kind" : "function",
"type" : "()",
"comment" : "\n   Releases the controlled range and returns it.\n",
"line" : 6641}
,
{
"name" : "getTransitionIndex(SearchPolicy sp,alias test,V) if (sp == SearchPolicy.binarySearch)",
"kind" : "template",
"protection" : "public",
"line" : 6648,
"members" : [
{
"name" : "getTransitionIndex",
"kind" : "function",
"type" : "size_t(V v)",
"line" : 6648}
]
}
,
{
"name" : "getTransitionIndex(SearchPolicy sp,alias test,V) if (sp == SearchPolicy.trot || sp == SearchPolicy.gallop)",
"kind" : "template",
"protection" : "public",
"line" : 6669,
"members" : [
{
"name" : "getTransitionIndex",
"kind" : "function",
"type" : "size_t(V v)",
"line" : 6669}
]
}
,
{
"name" : "getTransitionIndex(SearchPolicy sp,alias test,V) if (sp == SearchPolicy.trotBackwards || sp == SearchPolicy.gallopBackwards)",
"kind" : "template",
"protection" : "public",
"line" : 6701,
"members" : [
{
"name" : "getTransitionIndex",
"kind" : "function",
"type" : "size_t(V v)",
"line" : 6701}
]
}
,
{
"name" : "lowerBound(SearchPolicy sp = SearchPolicy.binarySearch,V) if (isTwoWayCompatible!(predFun,ElementType!(Range),V))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest left subrange on which $(D pred(x, value)) is $(D true) for\n   all $(D x) (e.g., if $(D pred) is \"less than\", returns the portion of\n   the range with elements strictly smaller than $(D value)). The search\n   schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com\/tech\/stl\/lower_bound.html, lower_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n   auto p = a.lowerBound(4);\n   assert(equal(p, [ 0, 1, 2, 3 ]));\n   ----\n",
"line" : 6748,
"members" : [
{
"name" : "lowerBound",
"kind" : "function",
"type" : "(V value)",
"comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest left subrange on which $(D pred(x, value)) is $(D true) for\n   all $(D x) (e.g., if $(D pred) is \"less than\", returns the portion of\n   the range with elements strictly smaller than $(D value)). The search\n   schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com\/tech\/stl\/lower_bound.html, lower_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n   auto p = a.lowerBound(4);\n   assert(equal(p, [ 0, 1, 2, 3 ]));\n   ----\n",
"line" : 6748}
]
}
,
{
"name" : "upperBound(SearchPolicy sp = SearchPolicy.binarySearch,V) if (isTwoWayCompatible!(predFun,ElementType!(Range),V))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest right subrange on which $(D pred(value, x)) is $(D true)\n   for all $(D x) (e.g., if $(D pred) is \"less than\", returns the\n   portion of the range with elements strictly greater than $(D\n   value)). The search schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com\/tech\/stl\/lower_bound.html,upper_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);\n   auto p = a.upperBound(3);\n   assert(equal(p, [4, 4, 5, 6]));\n   ----\n",
"line" : 6771,
"members" : [
{
"name" : "upperBound",
"kind" : "function",
"type" : "(V value)",
"comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest right subrange on which $(D pred(value, x)) is $(D true)\n   for all $(D x) (e.g., if $(D pred) is \"less than\", returns the\n   portion of the range with elements strictly greater than $(D\n   value)). The search schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com\/tech\/stl\/lower_bound.html,upper_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);\n   auto p = a.upperBound(3);\n   assert(equal(p, [4, 4, 5, 6]));\n   ----\n",
"line" : 6771}
]
}
,
{
"name" : "equalRange(V) if (isTwoWayCompatible!(predFun,ElementType!(Range),V))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Returns the subrange containing all elements $(D e) for which both $(D\n   pred(e, value)) and $(D pred(value, e)) evaluate to $(D false) (e.g.,\n   if $(D pred) is \"less than\", returns the portion of the range with\n   elements equal to $(D value)). Uses a classic binary search with\n   interval halving until it finds a value that satisfies the condition,\n   then uses $(D SearchPolicy.gallopBackwards) to find the left boundary\n   and $(D SearchPolicy.gallop) to find the right boundary. These\n   policies are justified by the fact that the two boundaries are likely\n   to be near the first found value (i.e., equal ranges are relatively\n   small). Completes the entire search in $(BIGOH log(n)) time. See also\n   STL's $(WEB sgi.com\/tech\/stl\/equal_range.html, equal_range).\n\n   Example:\n   ----\n   auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\n   auto r = equalRange(a, 3);\n   assert(equal(r, [ 3, 3, 3 ]));\n   ----\n",
"line" : 6798,
"members" : [
{
"name" : "equalRange",
"kind" : "function",
"type" : "(V value)",
"comment" : "\n   Returns the subrange containing all elements $(D e) for which both $(D\n   pred(e, value)) and $(D pred(value, e)) evaluate to $(D false) (e.g.,\n   if $(D pred) is \"less than\", returns the portion of the range with\n   elements equal to $(D value)). Uses a classic binary search with\n   interval halving until it finds a value that satisfies the condition,\n   then uses $(D SearchPolicy.gallopBackwards) to find the left boundary\n   and $(D SearchPolicy.gallop) to find the right boundary. These\n   policies are justified by the fact that the two boundaries are likely\n   to be near the first found value (i.e., equal ranges are relatively\n   small). Completes the entire search in $(BIGOH log(n)) time. See also\n   STL's $(WEB sgi.com\/tech\/stl\/equal_range.html, equal_range).\n\n   Example:\n   ----\n   auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\n   auto r = equalRange(a, 3);\n   assert(equal(r, [ 3, 3, 3 ]));\n   ----\n",
"line" : 6798}
]
}
,
{
"name" : "trisect(V) if (isTwoWayCompatible!(predFun,ElementType!(Range),V))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a tuple $(D r) such that $(D r[0]) is the same as the result\nof $(D lowerBound(value)), $(D r[1]) is the same as the result of $(D\nequalRange(value)), and $(D r[2]) is the same as the result of $(D\nupperBound(value)). The call is faster than computing all three\nseparately. Uses a search schedule similar to $(D\nequalRange). Completes the entire search in $(BIGOH log(n)) time.\n\nExample:\n----\nauto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\nauto r = assumeSorted(a).trisect(3);\nassert(equal(r[0], [ 1, 2 ]));\nassert(equal(r[1], [ 3, 3, 3 ]));\nassert(equal(r[2], [ 4, 4, 5, 6 ]));\n----\n",
"line" : 6854,
"members" : [
{
"name" : "trisect",
"kind" : "function",
"type" : "(V value)",
"comment" : "\nReturns a tuple $(D r) such that $(D r[0]) is the same as the result\nof $(D lowerBound(value)), $(D r[1]) is the same as the result of $(D\nequalRange(value)), and $(D r[2]) is the same as the result of $(D\nupperBound(value)). The call is faster than computing all three\nseparately. Uses a search schedule similar to $(D\nequalRange). Completes the entire search in $(BIGOH log(n)) time.\n\nExample:\n----\nauto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\nauto r = assumeSorted(a).trisect(3);\nassert(equal(r[0], [ 1, 2 ]));\nassert(equal(r[1], [ 3, 3, 3 ]));\nassert(equal(r[2], [ 4, 4, 5, 6 ]));\n----\n",
"line" : 6854}
]
}
,
{
"name" : "contains(V)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange), which is assumed to be sorted. Performs $(BIGOH log(r.length))\nevaluations of $(D pred). See also STL's $(WEB\nsgi.com\/tech\/stl\/binary_search.html, binary_search).\n \n",
"line" : 6902,
"members" : [
{
"name" : "contains",
"kind" : "function",
"type" : "bool(V value)",
"comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange), which is assumed to be sorted. Performs $(BIGOH log(r.length))\nevaluations of $(D pred). See also STL's $(WEB\nsgi.com\/tech\/stl\/binary_search.html, binary_search).\n \n",
"line" : 6902}
]
}
,
{
"name" : "canFind",
"kind" : "alias",
"type" : "contains",
"comment" : "\n    $(RED Deprecated. It will be removed in January 2013.\n          Please use $(LREF contains) instead.)\n  \n",
"line" : 6932}
]
}
]
}
,
{
"name" : "assumeSorted(alias pred = \"a < b\",R) if (isRandomAccessRange!(Unqual!(R)))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAssumes $(D r) is sorted by predicate $(D pred) and returns the\ncorresponding $(D SortedRange!(pred, R)) having $(D r) as support. To\nkeep the checking costs low, the cost is $(BIGOH 1) in release mode\n(no checks for sortedness are performed). In debug mode, a few random\nelements of $(D r) are checked for sortedness. The size of the sample\nis proportional $(BIGOH log(r.length)). That way, checking has no\neffect on the complexity of subsequent operations specific to sorted\nranges (such as binary search). The probability of an arbitrary\nunsorted range failing the test is very high (however, an\nalmost-sorted range is likely to pass it). To check for sortedness at\ncost $(BIGOH n), use $(XREF algorithm,isSorted).\n \n",
"line" : 7050,
"members" : [
{
"name" : "assumeSorted",
"kind" : "function",
"type" : "(R r)",
"comment" : "\nAssumes $(D r) is sorted by predicate $(D pred) and returns the\ncorresponding $(D SortedRange!(pred, R)) having $(D r) as support. To\nkeep the checking costs low, the cost is $(BIGOH 1) in release mode\n(no checks for sortedness are performed). In debug mode, a few random\nelements of $(D r) are checked for sortedness. The size of the sample\nis proportional $(BIGOH log(r.length)). That way, checking has no\neffect on the complexity of subsequent operations specific to sorted\nranges (such as binary search). The probability of an arbitrary\nunsorted range failing the test is very high (however, an\nalmost-sorted range is likely to pass it). To check for sortedness at\ncost $(BIGOH n), use $(XREF algorithm,isSorted).\n \n",
"line" : 7050}
]
}
,
{
"name" : "RefRange(R) if (isForwardRange!(R))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    Wrapper which effectively makes it possible to pass a range by reference.\n    Both the original range and the RefRange will always have the exact same\n    elements. Any operation done on one will affect the other. So, for instance,\n    if it's passed to a function which would implicitly copy the original range\n    if it were passed to it, the original range is $(I not) copied but is\n    consumed as if it were a reference type.\n\n    Note that $(D save) works as normal and operates on a new range, so if\n    $(D save) is ever called on the RefRange, then no operations on the saved\n    range will affect the original.\n\n    Examples:\n--------------------\nimport std.algorithm;\nubyte[] buffer = [1, 9, 45, 12, 22];\nauto found1 = find(buffer, 45);\nassert(found1 == [45, 12, 22]);\nassert(buffer == [1, 9, 45, 12, 22]);\n\nauto wrapped1 = refRange(&buffer);\nauto found2 = find(wrapped1, 45);\nassert(*found2.ptr == [45, 12, 22]);\nassert(buffer == [45, 12, 22]);\n\nauto found3 = find(wrapped2.save, 22);\nassert(*found3.ptr == [22]);\nassert(buffer == [45, 12, 22]);\n\nstring str = \"hello world\";\nauto wrappedStr = refRange(&str);\nassert(str.front == 'h');\nstr.popFrontN(5);\nassert(str == \" world\");\nassert(wrappedStr.front == ' ');\nassert(*wrappedStr.ptr == \" world\");\n--------------------\n  \n",
"line" : 7168,
"members" : [
{
"name" : "RefRange",
"kind" : "struct",
"protection" : "public",
"line" : 7168,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow @safe (R* range)",
"comment" : " \n",
"line" : 7172}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "(RefRange rhs)",
"comment" : "\n        This does not assign the pointer of $(D rhs) to this $(D RefRange).\n        Rather it assigns the range pointed to by $(D rhs) to the range pointed\n        to by this $(D RefRange). This is because $(I any) operation on a\n        $(D RefRange) is the same is if it occurred to the original range. The\n        one exception is when a $(D RefRange) is assigned $(D null) either\n        directly or because $(D rhs) is $(D null). In that case, $(D RefRange)\n        no longer refers to the original range but is $(D null).\n\n    Examples:\n--------------------\nubyte[] buffer1 = [1, 2, 3, 4, 5];\nubyte[] buffer2 = [6, 7, 8, 9, 10];\nauto wrapped1 = refRange(&buffer1);\nauto wrapped2 = refRange(&buffer2);\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\nassert(buffer1 != buffer2);\n\nwrapped1 = wrapped2;\n\n\/\/Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n\/\/But buffer1 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [6, 7, 8, 9, 10]);\n\nbuffer2 = [11, 12, 13, 14, 15];\n\n\/\/Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n\/\/But buffer2 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n\nwrapped2 = null;\n\n\/\/The pointer changed for wrapped2 but not wrapped1.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is null);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n\/\/buffer2 is not affected by the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n--------------------\n      \n",
"line" : 7233}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "(typeof(null) rhs)",
"comment" : " \n",
"line" : 7244}
,
{
"name" : "ptr",
"kind" : "function",
"type" : "inout pure nothrow @safe inout(R*)()",
"comment" : "\n        A pointer to the wrapped range.\n      \n",
"line" : 7252}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " \n",
"line" : 7308}
,
{
"name" : "_range",
"kind" : "variable",
"type" : "R*",
"line" : 7541}
]
}
]
}
,
{
"name" : "refRange(R) if (isForwardRange!(R) && !is(R == class))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Helper function for constructing a $(LREF RefRange).\n\n    If the given range is not a forward range or it is a class type (and thus is\n    already a reference type), then the original range is returned rather than\n    a $(LREF RefRange).\n  \n",
"line" : 7893,
"members" : [
{
"name" : "refRange",
"kind" : "function",
"type" : "(R* range)",
"comment" : "\n    Helper function for constructing a $(LREF RefRange).\n\n    If the given range is not a forward range or it is a class type (and thus is\n    already a reference type), then the original range is returned rather than\n    a $(LREF RefRange).\n  \n",
"line" : 7893}
]
}
,
{
"name" : "refRange(R) if (!isForwardRange!(R) && isInputRange!(R) || is(R == class))",
"kind" : "template",
"protection" : "public",
"line" : 7899,
"members" : [
{
"name" : "refRange",
"kind" : "function",
"type" : "(R* range)",
"line" : 7899}
]
}
]
}
,
{
"name" : "std.regex",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/regex.d",
"comment" : "\n  $(LUCKY Regular expressions) are a commonly used method of pattern matching\n  on strings, with $(I regex) being a catchy word for a pattern in this domain\n  specific language. Typical problems usually solved by regular expressions\n  include validation of user input and ubiquitous find & replace\n  in text processing utilities.\n\n  Synposis:\n  ---\n  import std.regex;\n  import std.stdio;\n  void main()\n  {\n      \/\/print out all possible dd\/mm\/yy(yy) dates found in user input\n      \/\/g - global, find all matches\n      auto r = regex(r\"\\b[0-9][0-9]?\/[0-9][0-9]?\/[0-9][0-9](?:[0-9][0-9])?\\b\", \"g\");\n      foreach(line; stdin.byLine)\n      {\n        \/\/match returns a range that can be iterated\n        \/\/to get all subsequent matches\n        foreach(c; match(line, r))\n            writeln(c.hit);\n      }\n  }\n  ...\n\n  \/\/create static regex at compile-time, contains fast native code\n  enum ctr = ctRegex!(`^.*\/([^\/]+)\/?$`);\n\n  \/\/works just like normal regex:\n  auto m2 = match(\"foo\/bar\", ctr);   \/\/first match found here if any\n  assert(m2);   \/\/ be sure to check if there is a match before examining contents!\n  assert(m2.captures[1] == \"bar\");   \/\/captures is a range of submatches, 0 - full match\n\n  ...\n\n  \/\/result of match is directly testable with if\/assert\/while\n  \/\/e.g. test if a string consists of letters:\n  assert(match(\"Letter\", `^\\p{L}+$`));\n\n\n  ---\n\n  The general usage guideline is to keep regex complexity on the side of simplicity,\n  as its capabilities reside in purely character-level manipulation,\n  and as such are ill-suited for tasks involving higher level invariants\n  like matching an integer number $(U bounded) in an [a,b] interval.\n  Checks of this sort of are better addressed by additional post-processing.\n\n  The basic syntax shouldn't surprise experienced users of regular expressions.\n  Thankfully, nowadays the web is bustling with resources to help newcomers, and a good\n  $(WEB www.regular-expressions.info, reference with tutorial) on regular expressions\n  can be found.\n\n  This library uses an ECMAScript syntax flavor with the following extensions:\n  $(UL\n    $(LI Named subexpressions, with Python syntax. )\n    $(LI Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.)\n    $(LI Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.)\n  )\n\n  $(REG_START Pattern syntax )\n  $(I std.regex operates on codepoint level,\n    'character' in this table denotes a single unicode codepoint.)\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_TITLE Atoms, Match single characters )\n    $(REG_ROW any character except [|*+?(), Matches the character itself. )\n    $(REG_ROW ., In single line mode matches any charcter.\n      Otherwise it matches any character except '\\n' and '\\r'. )\n    $(REG_ROW [class], Matches a single character\n      that belongs to this character class. )\n    $(REG_ROW [^class], Matches a single character that\n      does $(U not) belong to this character class.)\n    $(REG_ROW \\cC, Matches the control character corresponding to letter C)\n    $(REG_ROW \\xXX, Matches a character with hexadecimal value of XX. )\n    $(REG_ROW \\uXXXX, Matches a character  with hexadecimal value of XXXX. )\n    $(REG_ROW \\U00YYYYYY, Matches a character with hexadecimal value of YYYYYY. )\n    $(REG_ROW \\f, Matches a formfeed character. )\n    $(REG_ROW \\n, Matches a linefeed character. )\n    $(REG_ROW \\r, Matches a carriage return character. )\n    $(REG_ROW \\t, Matches a tab character. )\n    $(REG_ROW \\v, Matches a vertical tab character. )\n    $(REG_ROW \\d, Matches any unicode digit. )\n    $(REG_ROW \\D, Matches any character except unicode digits. )\n    $(REG_ROW \\w, Matches any word character (note: this includes numbers).)\n    $(REG_ROW \\W, Matches any non-word character.)\n    $(REG_ROW \\s, Matches whitespace, same as \\p{White_Space}.)\n    $(REG_ROW \\S, Matches any character except those recognized as $(I \\s ). )\n    $(REG_ROW \\\\, Matches \\ character. )\n    $(REG_ROW \\c where c is one of [|*+?(), Matches the character c itself. )\n    $(REG_ROW \\p{PropertyName}, Matches a character that belongs\n      to the unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW  \\P{PropertyName}, Matches a character that does not belong\n      to the unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW \\p{InBasicLatin}, Matches any character that is part of\n        the BasicLatin unicode $(U block).)\n    $(REG_ROW \\P{InBasicLatin}, Matches any character except ones in\n        the BasicLatin unicode $(U block).)\n    $(REG_ROW \\p{Cyrilic}, Matches any character that is part of\n        Cyrilic $(U script).)\n    $(REG_ROW \\P{Cyrilic}, Matches any character except ones in\n        Cyrilic $(U script).)\n    $(REG_TITLE Quantifiers, Specify repetition of other elements)\n    $(REG_ROW *, Matches previous character\/subexpression 0 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW *?, Matches previous character\/subexpression 0 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW +, Matches previous character\/subexpression 1 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW +?, Matches previous character\/subexpression 1 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW {n}, Matches previous character\/subexpression exactly n times. )\n    $(REG_ROW {n&#44}, Matches previous character\/subexpression n times or more.\n      Greedy version - tries as many times as possible. )\n    $(REG_ROW {n&#44}?, Matches previous character\/subexpression n times or more.\n      Lazy version - stops as early as possible.)\n    $(REG_ROW {n&#44m}, Matches previous character\/subexpression n to m times.\n      Greedy version - tries as many times as possible, but no more than m times. )\n    $(REG_ROW {n&#44m}?, Matches previous character\/subexpression n to m times.\n      Lazy version - stops as early as possible, but no less then n times.)\n    $(REG_TITLE Other, Subexpressions & alternations )\n    $(REG_ROW (regex),  Matches subexpression regex,\n      saving matched portion of text for later retrieval. )\n    $(REG_ROW (?:regex), Matches subexpression regex,\n      $(U not) saving matched portion of text. Useful to speed up matching. )\n    $(REG_ROW A|B, Matches subexpression A, or failing that, matches B. )\n    $(REG_ROW (?P&lt;name&gt;regex), Matches named subexpression\n        regex labeling it with name 'name'.\n        When referring to a matched portion of text,\n        names work like aliases in addition to direct numbers.\n     )\n    $(REG_TITLE Assertions, Match position rather than character )\n    $(REG_ROW ^, Matches at the begining of input or line (in multiline mode).)\n    $(REG_ROW $, Matches at the end of input or line (in multiline mode). )\n    $(REG_ROW \\b, Matches at word boundary. )\n    $(REG_ROW \\B, Matches when $(U not) at word boundary. )\n    $(REG_ROW (?=regex), Zero-width lookahead assertion.\n        Matches at a point where the subexpression\n        regex could be matched starting from the current position.\n      )\n    $(REG_ROW (?!regex), Zero-width negative lookahead assertion.\n        Matches at a point where the subexpression\n        regex could $(U not) be matched starting from the current position.\n      )\n    $(REG_ROW (?<=regex), Zero-width lookbehind assertion. Matches at a point\n        where the subexpression regex could be matched ending\n        at the current position (matching goes backwards).\n      )\n    $(REG_ROW  (?<!regex), Zero-width negative lookbehind assertion.\n      Matches at a point where the subexpression regex could $(U not)\n      be matched ending at the current position (matching goes backwards).\n     )\n  )\n\n  $(REG_START Character classes )\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_ROW Any atom, Has the same meaning as outside of a character class.)\n    $(REG_ROW a-z, Includes characters a, b, c, ..., z. )\n    $(REG_ROW [a||b]&#44 [a--b]&#44 [a~~b]&#44 [a&&b], Where a, b are arbitrary classes,\n     means union, set difference, symmetric set difference, and intersection respectively.\n     $(I Any sequence of character class elements implicitly forms a union.) )\n  )\n\n  $(REG_START Regex flags )\n  $(REG_TABLE\n    $(REG_TITLE Flag, Semantics )\n    $(REG_ROW g, Global regex, repeat over the whole input. )\n    $(REG_ROW i, Case insensitive matching. )\n    $(REG_ROW m, Multi-line mode, match ^, $ on start and end line separators\n       as well as start and end of input.)\n    $(REG_ROW s, Single-line mode, makes . match '\\n' and '\\r' as well. )\n    $(REG_ROW x, Free-form syntax, ignores whitespace in pattern,\n      useful for formatting complex regular expressions. )\n  )\n\n  $(B Unicode support)\n\n  This library provides full Level 1 support* according to\n    $(WEB unicode.org\/reports\/tr18\/, UTS 18). Specifically:\n  $(UL\n    $(LI 1.1 Hex notation via any of \\uxxxx, \\U00YYYYYY, \\xZZ.)\n    $(LI 1.2 Unicode properties.)\n    $(LI 1.3 Character classes with set operations.)\n    $(LI 1.4 Word boundaries use the full set of \"word\" characters.)\n    $(LI 1.5 Using simple casefolding to match case\n        insensitively across the full range of codepoints.)\n    $(LI 1.6 Respecting line breaks as any of\n        \\u000A | \\u000B | \\u000C | \\u000D | \\u0085 | \\u2028 | \\u2029 | \\u000D\\u000A.)\n    $(LI 1.7 Operating on codepoint level.)\n  )\n  *With exception of point 1.1.1, as of yet, normalization of input\n    is expected to be enforced by user.\n\n  $(B Slicing)\n\n  All matches returned by pattern matching functionality in this library\n  are slices of the original input, with the notable exception of the $(D replace)\n  family of functions which generate a new string from the input.\n\n  License: $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\n  Authors: Dmitry Olshansky,\n\n  API and utility constructs are based on original $(D std.regex)\n  by Walter Bright and Andrei Alexandrescu.\n\n  Copyright: Copyright Dmitry Olshansky, 2011\n\nMacros:\n    REG_ROW = $(TR $(TD $(I $1 )) $(TD $+) )\n    REG_TITLE = $(TR $(TD $(B $1)) $(TD $(B $2)) )\n    REG_TABLE = <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\" > $0 <\/table>\n    REG_START = <h3><div align=\"center\"> $0 <\/div><\/h3>\n \n",
"members" : [
{
"name" : "IR",
"kind" : "enum",
"protection" : "public",
"line" : 255,
"base" : "uint",
"members" : [
{
"name" : "Char",
"kind" : "enum member",
"protection" : "public",
"line" : 256}
,
{
"name" : "Any",
"kind" : "enum member",
"protection" : "public",
"line" : 257}
,
{
"name" : "CodepointSet",
"kind" : "enum member",
"protection" : "public",
"line" : 258}
,
{
"name" : "Trie",
"kind" : "enum member",
"protection" : "public",
"line" : 259}
,
{
"name" : "OrChar",
"kind" : "enum member",
"protection" : "public",
"line" : 265}
,
{
"name" : "Nop",
"kind" : "enum member",
"protection" : "public",
"line" : 266}
,
{
"name" : "End",
"kind" : "enum member",
"protection" : "public",
"line" : 267}
,
{
"name" : "Bol",
"kind" : "enum member",
"protection" : "public",
"line" : 268}
,
{
"name" : "Eol",
"kind" : "enum member",
"protection" : "public",
"line" : 269}
,
{
"name" : "Wordboundary",
"kind" : "enum member",
"protection" : "public",
"line" : 270}
,
{
"name" : "Notwordboundary",
"kind" : "enum member",
"protection" : "public",
"line" : 271}
,
{
"name" : "Backref",
"kind" : "enum member",
"protection" : "public",
"line" : 272}
,
{
"name" : "GroupStart",
"kind" : "enum member",
"protection" : "public",
"line" : 273}
,
{
"name" : "GroupEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 274}
,
{
"name" : "Option",
"kind" : "enum member",
"protection" : "public",
"line" : 275}
,
{
"name" : "GotoEndOr",
"kind" : "enum member",
"protection" : "public",
"line" : 276}
,
{
"name" : "OrStart",
"kind" : "enum member",
"protection" : "public",
"line" : 279}
,
{
"name" : "OrEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 280}
,
{
"name" : "InfiniteStart",
"kind" : "enum member",
"protection" : "public",
"line" : 283}
,
{
"name" : "InfiniteEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 284}
,
{
"name" : "InfiniteQStart",
"kind" : "enum member",
"protection" : "public",
"line" : 285}
,
{
"name" : "InfiniteQEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 286}
,
{
"name" : "RepeatStart",
"kind" : "enum member",
"protection" : "public",
"line" : 287}
,
{
"name" : "RepeatEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 288}
,
{
"name" : "RepeatQStart",
"kind" : "enum member",
"protection" : "public",
"line" : 289}
,
{
"name" : "RepeatQEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 290}
,
{
"name" : "LookaheadStart",
"kind" : "enum member",
"protection" : "public",
"line" : 292}
,
{
"name" : "LookaheadEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 293}
,
{
"name" : "NeglookaheadStart",
"kind" : "enum member",
"protection" : "public",
"line" : 294}
,
{
"name" : "NeglookaheadEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 295}
,
{
"name" : "LookbehindStart",
"kind" : "enum member",
"protection" : "public",
"line" : 296}
,
{
"name" : "LookbehindEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 297}
,
{
"name" : "NeglookbehindStart",
"kind" : "enum member",
"protection" : "public",
"line" : 298}
,
{
"name" : "NeglookbehindEnd",
"kind" : "enum member",
"protection" : "public",
"line" : 299}
]
}
,
{
"name" : "IRL(IR code)",
"kind" : "template",
"protection" : "public",
"line" : 303,
"members" : [
{
"name" : "IRL",
"kind" : "variable",
"type" : "uint",
"line" : 305}
]
}
,
{
"name" : "immediateParamsIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe int(IR i)",
"line" : 311}
,
{
"name" : "lengthOfIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe int(IR i)",
"line" : 325}
,
{
"name" : "lengthOfPairedIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe int(IR i)",
"line" : 331}
,
{
"name" : "hasMerge",
"kind" : "function",
"protection" : "private",
"type" : "@safe bool(IR i)",
"line" : 337}
,
{
"name" : "isStartIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe bool(IR i)",
"line" : 343}
,
{
"name" : "isEndIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe bool(IR i)",
"line" : 349}
,
{
"name" : "isAtomIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe bool(IR i)",
"line" : 355}
,
{
"name" : "pairedIR",
"kind" : "function",
"protection" : "private",
"type" : "@safe IR(IR i)",
"line" : 361}
,
{
"name" : "Bytecode",
"kind" : "struct",
"protection" : "private",
"line" : 369,
"members" : [
{
"name" : "raw",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 370}
,
{
"name" : "maxSequence",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 372}
,
{
"name" : "maxData",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 373}
,
{
"name" : "maxRaw",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 374}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref @safe Bytecode(IR code, uint data)",
"line" : 376}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref @safe Bytecode(IR code, uint data, uint seq)",
"line" : 382}
,
{
"name" : "fromRaw",
"kind" : "function",
"protection" : "public",
"type" : "@safe Bytecode(uint data)",
"line" : 390}
,
{
"name" : "data",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe uint()",
"line" : 398}
,
{
"name" : "sequence",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe uint()",
"line" : 401}
,
{
"name" : "code",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe IR()",
"line" : 404}
,
{
"name" : "hotspot",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe bool()",
"line" : 407}
,
{
"name" : "isAtom",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe bool()",
"line" : 410}
,
{
"name" : "isStart",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe bool()",
"line" : 413}
,
{
"name" : "isEnd",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe bool()",
"line" : 416}
,
{
"name" : "args",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe int()",
"line" : 419}
,
{
"name" : "setBackrefence",
"kind" : "function",
"protection" : "public",
"type" : "@safe void()",
"line" : 422}
,
{
"name" : "backreference",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe bool()",
"line" : 429}
,
{
"name" : "setLocalRef",
"kind" : "function",
"protection" : "public",
"type" : "@safe void()",
"line" : 436}
,
{
"name" : "localRef",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe bool()",
"line" : 443}
,
{
"name" : "mnemonic",
"kind" : "function",
"protection" : "public",
"type" : "const @property @trusted string()",
"line" : 450}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe uint()",
"line" : 456}
,
{
"name" : "pairedLength",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe uint()",
"line" : 462}
,
{
"name" : "paired",
"kind" : "function",
"protection" : "public",
"type" : "const @property @safe Bytecode()",
"line" : 468}
,
{
"name" : "indexOfPair",
"kind" : "function",
"protection" : "public",
"type" : "const @safe uint(uint pc)",
"line" : 475}
]
}
,
{
"name" : "disassemble",
"kind" : "function",
"protection" : "private",
"type" : "@trusted string(const(Bytecode[]) irb, uint pc, const(NamedGroup[]) dict = [])",
"line" : 485}
,
{
"name" : "prettyPrint(Sink,Char = const(char)) if (isOutputRange!(Sink,Char))",
"kind" : "template",
"protection" : "public",
"line" : 546,
"members" : [
{
"name" : "prettyPrint",
"kind" : "function",
"type" : "void(Sink sink, const(Bytecode)[] irb, uint pc = (uint).max, int indent = 3, size_t index = 0)",
"line" : 546}
]
}
,
{
"name" : "NamedGroup",
"kind" : "struct",
"protection" : "private",
"line" : 618,
"members" : [
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 619}
,
{
"name" : "group",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 620}
]
}
,
{
"name" : "Group(DataIndex)",
"kind" : "struct",
"protection" : "public",
"line" : 625,
"members" : [
{
"name" : "Group",
"kind" : "struct",
"protection" : "public",
"line" : 625,
"members" : [
{
"name" : "begin",
"kind" : "variable",
"type" : "DataIndex",
"line" : 626}
,
{
"name" : "end",
"kind" : "variable",
"type" : "DataIndex",
"line" : 626}
,
{
"name" : "toString",
"kind" : "function",
"type" : "const string()",
"line" : 627}
]
}
]
}
,
{
"name" : "RegexOption",
"kind" : "enum",
"protection" : "public",
"line" : 640,
"base" : "uint",
"members" : [
{
"name" : "global",
"kind" : "enum member",
"protection" : "public",
"line" : 641}
,
{
"name" : "casefold",
"kind" : "enum member",
"protection" : "public",
"line" : 642}
,
{
"name" : "freeform",
"kind" : "enum member",
"protection" : "public",
"line" : 643}
,
{
"name" : "nonunicode",
"kind" : "enum member",
"protection" : "public",
"line" : 644}
,
{
"name" : "multiline",
"kind" : "enum member",
"protection" : "public",
"line" : 645}
,
{
"name" : "singleline",
"kind" : "enum member",
"protection" : "public",
"line" : 646}
]
}
,
{
"name" : "RegexOptionNames",
"kind" : "alias",
"protection" : "private",
"line" : 648}
,
{
"name" : "RegexInfo",
"kind" : "enum",
"protection" : "public",
"line" : 650,
"base" : "uint",
"members" : [
{
"name" : "oneShot",
"kind" : "enum member",
"protection" : "public",
"line" : 650}
]
}
,
{
"name" : "NEL",
"kind" : "variable",
"protection" : "private",
"type" : "wchar",
"line" : 652}
,
{
"name" : "LS",
"kind" : "variable",
"protection" : "private",
"type" : "wchar",
"line" : 652}
,
{
"name" : "PS",
"kind" : "variable",
"protection" : "private",
"type" : "wchar",
"line" : 652}
,
{
"name" : "parseUniHex(Char)",
"kind" : "template",
"protection" : "public",
"line" : 656,
"members" : [
{
"name" : "parseUniHex",
"kind" : "function",
"type" : "dchar(ref Char[] str, uint maxDigit)",
"line" : 656}
]
}
,
{
"name" : "maxCharsetUsed",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 678}
,
{
"name" : "maxCachedTries",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 680}
,
{
"name" : "Trie",
"kind" : "alias",
"protection" : "private",
"type" : "CodepointTrie!(8)",
"line" : 682}
,
{
"name" : "trieCache",
"kind" : "variable",
"protection" : "private",
"type" : "CodepointTrie!(8)[const(CodepointSet)]",
"line" : 684}
,
{
"name" : "getTrie",
"kind" : "function",
"protection" : "private",
"type" : "@trusted CodepointTrie!(8)(const(CodepointSet) set)",
"line" : 687}
,
{
"name" : "wordCharacter",
"kind" : "function",
"protection" : "private",
"type" : "@property @safe CodepointSet()",
"line" : 706}
,
{
"name" : "wordTrie",
"kind" : "function",
"protection" : "private",
"type" : "@property @safe CodepointTrie!(8)()",
"line" : 712}
,
{
"name" : "memoizeExpr(string expr)",
"kind" : "template",
"protection" : "public",
"line" : 717,
"members" : [
{
"name" : "memoizeExpr",
"kind" : "function",
"type" : "()",
"line" : 717}
]
}
,
{
"name" : "getUnicodeSet",
"kind" : "function",
"protection" : "private",
"type" : "@trusted const(CodepointSet)(const(char[]) name, bool negated, bool casefold)",
"line" : 735}
,
{
"name" : "Stack(T,bool CTFE = false)",
"kind" : "struct",
"protection" : "public",
"line" : 795,
"members" : [
{
"name" : "Stack",
"kind" : "struct",
"protection" : "public",
"line" : 795,
"members" : [
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 811}
,
{
"name" : "push",
"kind" : "function",
"type" : "void(T item)",
"line" : 812}
,
{
"name" : "top",
"kind" : "function",
"type" : "T()",
"line" : 816}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"line" : 821}
,
{
"name" : "pop",
"kind" : "function",
"type" : "T()",
"line" : 822}
]
}
]
}
,
{
"name" : "maxGroupNumber",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 832}
,
{
"name" : "maxLookaroundDepth",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 833}
,
{
"name" : "maxCompiledLength",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 835}
,
{
"name" : "maxCumulativeRepetitionLength",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 837}
,
{
"name" : "BasicElementOf(Range)",
"kind" : "template",
"protection" : "public",
"line" : 839,
"members" : [
{
"name" : "BasicElementOf",
"kind" : "alias",
"type" : "Unqual!(ElementEncodingType!(Range))",
"line" : 841}
]
}
,
{
"name" : "Parser(R,bool CTFE = false) if (isForwardRange!(R) && is(ElementType!(R) : dchar))",
"kind" : "struct",
"protection" : "public",
"line" : 846,
"members" : [
{
"name" : "Parser",
"kind" : "struct",
"protection" : "public",
"line" : 846,
"members" : [
{
"name" : "infinite",
"kind" : "variable",
"line" : 847}
,
{
"name" : "_current",
"kind" : "variable",
"type" : "dchar",
"line" : 848}
,
{
"name" : "empty",
"kind" : "variable",
"type" : "bool",
"line" : 849}
,
{
"name" : "pat",
"kind" : "variable",
"type" : "R",
"line" : 850}
,
{
"name" : "origin",
"kind" : "variable",
"type" : "R",
"line" : 850}
,
{
"name" : "ir",
"kind" : "variable",
"type" : "Bytecode[]",
"line" : 851}
,
{
"name" : "re_flags",
"kind" : "variable",
"type" : "uint",
"line" : 852}
,
{
"name" : "fixupStack",
"kind" : "variable",
"type" : "Stack!(uint,CTFE)",
"line" : 853}
,
{
"name" : "dict",
"kind" : "variable",
"type" : "NamedGroup[]",
"line" : 854}
,
{
"name" : "groupStack",
"kind" : "variable",
"type" : "Stack!(uint,CTFE)",
"line" : 856}
,
{
"name" : "nesting",
"kind" : "variable",
"type" : "uint",
"line" : 857}
,
{
"name" : "lookaroundNest",
"kind" : "variable",
"type" : "uint",
"line" : 858}
,
{
"name" : "counterDepth",
"kind" : "variable",
"type" : "uint",
"line" : 859}
,
{
"name" : "charsets",
"kind" : "variable",
"type" : "const(CodepointSet)[]",
"line" : 860}
,
{
"name" : "tries",
"kind" : "variable",
"type" : "const(Trie)[]",
"line" : 861}
,
{
"name" : "backrefed",
"kind" : "variable",
"type" : "uint[]",
"line" : 862}
,
{
"name" : "__ctor(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"line" : 864,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(R pattern, S flags)",
"line" : 864}
]
}
,
{
"name" : "markBackref",
"kind" : "function",
"type" : "void(uint n)",
"line" : 886}
,
{
"name" : "current",
"kind" : "function",
"type" : "dchar()",
"line" : 893}
,
{
"name" : "_next",
"kind" : "function",
"type" : "bool()",
"line" : 895}
,
{
"name" : "skipSpace",
"kind" : "function",
"type" : "void()",
"line" : 907}
,
{
"name" : "next",
"kind" : "function",
"type" : "bool()",
"line" : 912}
,
{
"name" : "put",
"kind" : "function",
"type" : "void(Bytecode code)",
"line" : 924}
,
{
"name" : "putRaw",
"kind" : "function",
"type" : "void(uint number)",
"line" : 936}
,
{
"name" : "parseDecimal",
"kind" : "function",
"type" : "uint()",
"line" : 944}
,
{
"name" : "parseControlCode",
"kind" : "function",
"type" : "dchar()",
"line" : 959}
,
{
"name" : "parseFlags(S)",
"kind" : "template",
"protection" : "public",
"line" : 968,
"members" : [
{
"name" : "parseFlags",
"kind" : "function",
"type" : "void(S flags)",
"line" : 968}
]
}
,
{
"name" : "parseRegex",
"kind" : "function",
"type" : "void()",
"line" : 994}
,
{
"name" : "finishAlternation",
"kind" : "function",
"type" : "void(uint fix)",
"line" : 1173}
,
{
"name" : "parseQuantifier",
"kind" : "function",
"type" : "void(uint offset)",
"line" : 1194}
,
{
"name" : "parseAtom",
"kind" : "function",
"type" : "void()",
"line" : 1313}
,
{
"name" : "genLookaround",
"kind" : "function",
"type" : "void(IR opcode)",
"line" : 1360}
,
{
"name" : "fixLookaround",
"kind" : "function",
"type" : "void(uint fix)",
"line" : 1372}
,
{
"name" : "Operator",
"kind" : "enum",
"protection" : "public",
"line" : 1385,
"base" : "uint",
"members" : [
{
"name" : "Open",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
,
{
"name" : "Negate",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
,
{
"name" : "Difference",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
,
{
"name" : "SymDifference",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
,
{
"name" : "Intersection",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
,
{
"name" : "Union",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
,
{
"name" : "None",
"kind" : "enum member",
"protection" : "public",
"line" : 1386}
]
}
,
{
"name" : "parseCharTerm",
"kind" : "function",
"type" : "Tuple!(CodepointSet,Operator)()",
"line" : 1391}
,
{
"name" : "ValStack",
"kind" : "alias",
"type" : "Stack!(CodepointSet,CTFE)",
"line" : 1662}
,
{
"name" : "OpStack",
"kind" : "alias",
"type" : "Stack!(Operator,CTFE)",
"line" : 1663}
,
{
"name" : "parseCharset",
"kind" : "function",
"type" : "void()",
"line" : 1666}
,
{
"name" : "charsetToIr",
"kind" : "function",
"type" : "void(in CodepointSet set)",
"line" : 1772}
,
{
"name" : "parseEscape",
"kind" : "function",
"type" : "void()",
"line" : 1810}
,
{
"name" : "parseUnicodePropertySpec",
"kind" : "function",
"type" : "const(CodepointSet)(bool negated)",
"line" : 1904}
,
{
"name" : "error",
"kind" : "function",
"type" : "void(string msg)",
"line" : 1932}
,
{
"name" : "Char",
"kind" : "alias",
"type" : "BasicElementOf!(R)",
"line" : 1941}
,
{
"name" : "program",
"kind" : "function",
"type" : "Regex!(Char)()",
"line" : 1943}
]
}
]
}
,
{
"name" : "Regex(Char)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    $(D Regex) object holds regular expression pattern in compiled form.\n    Instances of this object are constructed via calls to $(D regex).\n    This is an intended form for caching and storage of frequently\n    used regular expressions.\n",
"line" : 1957,
"members" : [
{
"name" : "Regex",
"kind" : "struct",
"protection" : "public",
"line" : 1957,
"members" : [
{
"name" : "charsets",
"kind" : "variable",
"type" : "const(CodepointSet)[]",
"line" : 1959}
,
{
"name" : "ir",
"kind" : "variable",
"type" : "Bytecode[]",
"line" : 1960}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const nothrow bool()",
"comment" : "\n        Test if this object doesn't contain any compiled pattern.\n        Example:\n        ---\n        Regex!char r;\n        assert(r.empty);\n        r = regex(\"\");\/\/note: \"\" is a valid regex pattern\n        assert(!r.empty);\n        ---\n    \n",
"line" : 1972}
,
{
"name" : "dict",
"kind" : "variable",
"type" : "NamedGroup[]",
"line" : 1975}
,
{
"name" : "ngroup",
"kind" : "variable",
"type" : "uint",
"line" : 1976}
,
{
"name" : "maxCounterDepth",
"kind" : "variable",
"type" : "uint",
"line" : 1977}
,
{
"name" : "hotspotTableSize",
"kind" : "variable",
"type" : "uint",
"line" : 1978}
,
{
"name" : "threadCount",
"kind" : "variable",
"type" : "uint",
"line" : 1979}
,
{
"name" : "flags",
"kind" : "variable",
"type" : "uint",
"line" : 1980}
,
{
"name" : "tries",
"kind" : "variable",
"type" : "const(Trie)[]",
"line" : 1981}
,
{
"name" : "backrefed",
"kind" : "variable",
"type" : "uint[]",
"line" : 1982}
,
{
"name" : "kickstart",
"kind" : "variable",
"type" : "Kickstart!(Char)",
"line" : 1983}
,
{
"name" : "isBackref",
"kind" : "function",
"type" : "uint(uint n)",
"line" : 1986}
,
{
"name" : "checkIfOneShot",
"kind" : "function",
"type" : "void()",
"line" : 1994}
,
{
"name" : "lightPostprocess",
"kind" : "function",
"type" : "void()",
"line" : 2018}
,
{
"name" : "validate",
"kind" : "function",
"type" : "void()",
"line" : 2083}
,
{
"name" : "__ctor(S,bool x)",
"kind" : "template",
"protection" : "public",
"line" : 2119,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Parser!(S,x) p)",
"line" : 2119}
]
}
]
}
]
}
,
{
"name" : "lookupNamedGroup(String)",
"kind" : "template",
"protection" : "public",
"line" : 2142,
"members" : [
{
"name" : "lookupNamedGroup",
"kind" : "function",
"type" : "uint(NamedGroup[] dict, String name)",
"line" : 2142}
]
}
,
{
"name" : "endOfLine",
"kind" : "function",
"protection" : "private",
"type" : "@safe bool(dchar front, bool seenCr)",
"line" : 2150}
,
{
"name" : "startOfLine",
"kind" : "function",
"protection" : "private",
"type" : "@safe bool(dchar back, bool seenNl)",
"line" : 2157}
,
{
"name" : "quickTestFwd(RegEx)",
"kind" : "template",
"protection" : "public",
"line" : 2165,
"members" : [
{
"name" : "quickTestFwd",
"kind" : "function",
"type" : "int(uint pc, dchar front, ref const RegEx re)",
"line" : 2165}
]
}
,
{
"name" : "SampleGenerator(Char)",
"kind" : "struct",
"protection" : "public",
"line" : 2214,
"members" : [
{
"name" : "SampleGenerator",
"kind" : "struct",
"protection" : "public",
"line" : 2214,
"members" : [
{
"name" : "re",
"kind" : "variable",
"type" : "const(Regex!(Char))",
"line" : 2216}
,
{
"name" : "app",
"kind" : "variable",
"type" : "Appender!(char[])",
"line" : 2217}
,
{
"name" : "limit",
"kind" : "variable",
"type" : "uint",
"line" : 2218}
,
{
"name" : "seed",
"kind" : "variable",
"type" : "uint",
"line" : 2218}
,
{
"name" : "gen",
"kind" : "variable",
"type" : "Xorshift",
"line" : 2219}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(in Regex!(Char) r, uint threshold, uint randomSeed)",
"line" : 2222}
,
{
"name" : "rand",
"kind" : "function",
"type" : "uint(uint x)",
"line" : 2231}
,
{
"name" : "compose",
"kind" : "function",
"type" : "void()",
"line" : 2238}
,
{
"name" : "front",
"kind" : "function",
"type" : "Char[]()",
"line" : 2361}
,
{
"name" : "empty",
"kind" : "function",
"type" : "@property ()",
"line" : 2366}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 2368}
]
}
]
}
,
{
"name" : "StaticRegex(Char)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    A $(D StaticRegex) is $(D Regex) object that contains specially\n    generated machine code to speed up matching.\n    Implicitly convertible to normal $(D Regex),\n    however doing so will result in loosing this additional capability.\n",
"line" : 2382,
"members" : [
{
"name" : "StaticRegex",
"kind" : "struct",
"protection" : "public",
"line" : 2382,
"members" : [
{
"name" : "Matcher",
"kind" : "alias",
"type" : "BacktrackingMatcher!(true)",
"line" : 2384}
,
{
"name" : "MatchFn",
"kind" : "alias",
"type" : "bool function(ref Matcher!(Char))",
"line" : 2385}
,
{
"name" : "nativeFn",
"kind" : "variable",
"type" : "MatchFn",
"line" : 2386}
,
{
"name" : "_regex",
"kind" : "variable",
"type" : "Regex!(Char)",
"line" : 2388}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Regex!(Char) re, MatchFn fn)",
"line" : 2390}
]
}
]
}
,
{
"name" : "effectiveSize(Char)",
"kind" : "template",
"protection" : "public",
"line" : 2400,
"members" : [
{
"name" : "effectiveSize",
"kind" : "function",
"type" : "uint()",
"line" : 2400}
]
}
,
{
"name" : "ShiftOr(Char)",
"kind" : "struct",
"protection" : "public",
"line" : 2417,
"members" : [
{
"name" : "ShiftOr",
"kind" : "struct",
"protection" : "public",
"line" : 2417,
"members" : [
{
"name" : "table",
"kind" : "variable",
"type" : "uint[]",
"line" : 2419}
,
{
"name" : "fChar",
"kind" : "variable",
"type" : "uint",
"line" : 2420}
,
{
"name" : "n_length",
"kind" : "variable",
"type" : "uint",
"line" : 2421}
,
{
"name" : "charSize",
"kind" : "variable",
"line" : 2422}
,
{
"name" : "charsetThreshold",
"kind" : "variable",
"type" : "uint",
"line" : 2424}
,
{
"name" : "ShiftThread",
"kind" : "struct",
"protection" : "public",
"line" : 2426,
"members" : [
{
"name" : "tab",
"kind" : "variable",
"type" : "uint[]",
"line" : 2427}
,
{
"name" : "mask",
"kind" : "variable",
"type" : "uint",
"line" : 2428}
,
{
"name" : "idx",
"kind" : "variable",
"type" : "uint",
"line" : 2429}
,
{
"name" : "pc",
"kind" : "variable",
"type" : "uint",
"line" : 2430}
,
{
"name" : "counter",
"kind" : "variable",
"type" : "uint",
"line" : 2430}
,
{
"name" : "hops",
"kind" : "variable",
"type" : "uint",
"line" : 2430}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(uint newPc, uint newCounter, uint[] table)",
"line" : 2431}
,
{
"name" : "setMask",
"kind" : "function",
"type" : "void(uint idx, uint mask)",
"line" : 2441}
,
{
"name" : "setInvMask",
"kind" : "function",
"type" : "void(uint idx, uint mask)",
"line" : 2446}
,
{
"name" : "set(alias setBits = setInvMask)",
"kind" : "template",
"protection" : "public",
"line" : 2451,
"members" : [
{
"name" : "set",
"kind" : "function",
"type" : "void(dchar ch)",
"line" : 2451}
]
}
,
{
"name" : "add",
"kind" : "function",
"type" : "void(dchar ch)",
"line" : 2484}
,
{
"name" : "advance",
"kind" : "function",
"type" : "void(uint s)",
"line" : 2485}
,
{
"name" : "full",
"kind" : "function",
"type" : "bool()",
"line" : 2490}
]
}
,
{
"name" : "fork",
"kind" : "function",
"type" : "ShiftThread(ShiftThread t, uint newPc, uint newCounter)",
"line" : 2493}
,
{
"name" : "fetch",
"kind" : "function",
"type" : "ShiftThread(ref ShiftThread[] worklist)",
"line" : 2501}
,
{
"name" : "charLen",
"kind" : "function",
"type" : "uint(uint ch)",
"line" : 2510}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref const Regex!(Char) re, uint[] memory)",
"line" : 2517}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"line" : 2734}
,
{
"name" : "length",
"kind" : "function",
"type" : "const uint()",
"line" : 2736}
,
{
"name" : "search",
"kind" : "function",
"type" : "size_t(const(Char)[] haystack, size_t idx)",
"line" : 2742}
]
}
]
}
,
{
"name" : "Kickstart",
"kind" : "alias",
"protection" : "private",
"line" : 2923}
,
{
"name" : "Input(Char) if (is(Char : dchar))",
"kind" : "struct",
"protection" : "public",
"line" : 2928,
"members" : [
{
"name" : "Input",
"kind" : "struct",
"protection" : "public",
"line" : 2928,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "size_t",
"line" : 2929}
,
{
"name" : "String",
"kind" : "alias",
"type" : "const(Char)[]",
"line" : 2930}
,
{
"name" : "_origin",
"kind" : "variable",
"type" : "String",
"line" : 2931}
,
{
"name" : "_index",
"kind" : "variable",
"type" : "size_t",
"line" : 2932}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(String input, size_t idx = 0)",
"line" : 2935}
,
{
"name" : "nextChar",
"kind" : "function",
"type" : "bool(ref dchar res, ref size_t pos)",
"line" : 2942}
,
{
"name" : "atEnd",
"kind" : "function",
"type" : "bool()",
"line" : 2950}
,
{
"name" : "search(Kickstart)",
"kind" : "template",
"protection" : "public",
"line" : 2953,
"members" : [
{
"name" : "search",
"kind" : "function",
"type" : "bool(ref Kickstart kick, ref dchar res, ref size_t pos)",
"line" : 2953}
]
}
,
{
"name" : "lastIndex",
"kind" : "function",
"type" : "size_t()",
"line" : 2961}
,
{
"name" : "reset",
"kind" : "function",
"type" : "void(size_t index)",
"line" : 2964}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "String(size_t start, size_t end)",
"line" : 2966}
,
{
"name" : "BackLooper",
"kind" : "struct",
"protection" : "public",
"line" : 2969,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "size_t",
"line" : 2970}
,
{
"name" : "_origin",
"kind" : "variable",
"type" : "String",
"line" : 2971}
,
{
"name" : "_index",
"kind" : "variable",
"type" : "size_t",
"line" : 2972}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Input input)",
"line" : 2973}
,
{
"name" : "nextChar",
"kind" : "function",
"type" : "bool(ref dchar res, ref size_t pos)",
"line" : 2978}
,
{
"name" : "atEnd",
"kind" : "function",
"type" : "@property ()",
"line" : 2989}
,
{
"name" : "loopBack",
"kind" : "function",
"type" : "@property ()",
"line" : 2990}
,
{
"name" : "reset",
"kind" : "function",
"type" : "void(size_t index)",
"line" : 2993}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "String(size_t start, size_t end)",
"line" : 2995}
,
{
"name" : "lastIndex",
"kind" : "function",
"type" : "size_t()",
"line" : 2997}
]
}
,
{
"name" : "loopBack",
"kind" : "function",
"type" : "@property ()",
"line" : 2999}
]
}
]
}
,
{
"name" : "StreamTester(Char) if (is(Char : dchar))",
"kind" : "struct",
"protection" : "public",
"line" : 3005,
"members" : [
{
"name" : "StreamTester",
"kind" : "struct",
"protection" : "public",
"line" : 3005,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "ulong",
"line" : 3006}
,
{
"name" : "String",
"kind" : "alias",
"type" : "const(Char)[]",
"line" : 3007}
,
{
"name" : "refStream",
"kind" : "variable",
"type" : "Input!(Char)",
"line" : 3008}
,
{
"name" : "allStr",
"kind" : "variable",
"type" : "String",
"line" : 3009}
,
{
"name" : "stream",
"kind" : "variable",
"type" : "StreamCBuf!(Char)",
"line" : 3010}
,
{
"name" : "splits",
"kind" : "variable",
"type" : "size_t[]",
"line" : 3011}
,
{
"name" : "pos",
"kind" : "variable",
"type" : "size_t",
"line" : 3012}
,
{
"name" : "addNextChunk",
"kind" : "function",
"type" : "bool()",
"line" : 3015}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(String input, size_t[] splits)",
"line" : 3037}
,
{
"name" : "nextChar",
"kind" : "function",
"type" : "bool(ref dchar res, ref size_t pos)",
"line" : 3052}
,
{
"name" : "atEnd",
"kind" : "function",
"type" : "bool()",
"line" : 3075}
,
{
"name" : "search(Kickstart)",
"kind" : "template",
"protection" : "public",
"line" : 3081,
"members" : [
{
"name" : "search",
"kind" : "function",
"type" : "bool(ref Kickstart kick, ref dchar res, ref ulong pos)",
"line" : 3081}
]
}
,
{
"name" : "lastIndex",
"kind" : "function",
"type" : "size_t()",
"line" : 3101}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "String(size_t start, size_t end)",
"line" : 3103}
,
{
"name" : "BackLooper",
"kind" : "struct",
"protection" : "public",
"line" : 3109,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "ulong",
"line" : 3110}
,
{
"name" : "refBacklooper",
"kind" : "variable",
"type" : "Input!(Char).BackLooper",
"line" : 3111}
,
{
"name" : "backlooper",
"kind" : "variable",
"type" : "StreamCBuf!(Char).BackLooper",
"line" : 3112}
,
{
"name" : "startPos",
"kind" : "variable",
"type" : "ulong",
"line" : 3113}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Input!(Char).BackLooper refBacklooper, StreamCBuf!(Char).BackLooper backlooper)",
"line" : 3115}
,
{
"name" : "nextChar",
"kind" : "function",
"type" : "bool(ref dchar res, ref ulong pos)",
"line" : 3120}
,
{
"name" : "atEnd",
"kind" : "function",
"type" : "@property ()",
"line" : 3138}
,
{
"name" : "loopBack",
"kind" : "function",
"type" : "@property ()",
"line" : 3155}
,
{
"name" : "reset",
"kind" : "function",
"type" : "void(size_t index)",
"line" : 3158}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "String(size_t start, size_t end)",
"line" : 3160}
,
{
"name" : "lastIndex",
"kind" : "function",
"type" : "size_t()",
"line" : 3162}
]
}
,
{
"name" : "loopBack",
"kind" : "function",
"type" : "@property ()",
"line" : 3164}
]
}
]
}
,
{
"name" : "mallocArray(T)",
"kind" : "template",
"protection" : "public",
"line" : 3170,
"members" : [
{
"name" : "mallocArray",
"kind" : "function",
"type" : "T[](size_t len)",
"line" : 3170}
]
}
,
{
"name" : "arrayInChunk(T)",
"kind" : "template",
"protection" : "public",
"line" : 3176,
"members" : [
{
"name" : "arrayInChunk",
"kind" : "function",
"type" : "T[](size_t len, ref void[] chunk)",
"line" : 3176}
]
}
,
{
"name" : "BacktrackingMatcher(bool CTregex)",
"kind" : "template",
"protection" : "public",
"line" : 3187,
"members" : [
{
"name" : "BacktrackingMatcher(Char,Stream = Input!(Char)) if (is(Char : dchar))",
"kind" : "struct",
"protection" : "public",
"line" : 3191,
"members" : [
{
"name" : "BacktrackingMatcher",
"kind" : "struct",
"protection" : "public",
"line" : 3191,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "Stream.DataIndex",
"line" : 3192}
,
{
"name" : "State",
"kind" : "struct",
"protection" : "public",
"line" : 3194,
"members" : [
{
"name" : "index",
"kind" : "variable",
"type" : "DataIndex",
"line" : 3195}
,
{
"name" : "pc",
"kind" : "variable",
"type" : "uint",
"line" : 3196}
,
{
"name" : "counter",
"kind" : "variable",
"type" : "uint",
"line" : 3196}
,
{
"name" : "infiniteNesting",
"kind" : "variable",
"type" : "uint",
"line" : 3196}
]
}
,
{
"name" : "stateSize",
"kind" : "variable",
"line" : 3199}
,
{
"name" : "initialStack",
"kind" : "variable",
"line" : 3200}
,
{
"name" : "String",
"kind" : "alias",
"type" : "const(Char)[]",
"line" : 3201}
,
{
"name" : "re",
"kind" : "variable",
"type" : "RegEx",
"line" : 3206}
,
{
"name" : "s",
"kind" : "variable",
"type" : "Stream",
"line" : 3208}
,
{
"name" : "index",
"kind" : "variable",
"type" : "DataIndex",
"line" : 3209}
,
{
"name" : "front",
"kind" : "variable",
"type" : "dchar",
"line" : 3210}
,
{
"name" : "exhausted",
"kind" : "variable",
"type" : "bool",
"line" : 3211}
,
{
"name" : "pc",
"kind" : "variable",
"type" : "uint",
"line" : 3213}
,
{
"name" : "counter",
"kind" : "variable",
"type" : "uint",
"line" : 3213}
,
{
"name" : "lastState",
"kind" : "variable",
"type" : "DataIndex",
"line" : 3214}
,
{
"name" : "trackers",
"kind" : "variable",
"type" : "DataIndex[]",
"line" : 3215}
,
{
"name" : "memory",
"kind" : "variable",
"type" : "size_t[]",
"line" : 3218}
,
{
"name" : "matches",
"kind" : "variable",
"type" : "Group!(DataIndex)[]",
"line" : 3220}
,
{
"name" : "backrefed",
"kind" : "variable",
"type" : "Group!(DataIndex)[]",
"line" : 3220}
,
{
"name" : "initialMemory",
"kind" : "function",
"type" : "size_t(ref const RegEx re)",
"line" : 3229}
,
{
"name" : "stackSize",
"kind" : "function",
"type" : "size_t(ref const RegEx re)",
"line" : 3235}
,
{
"name" : "atStart",
"kind" : "function",
"type" : "bool()",
"line" : 3240}
,
{
"name" : "atEnd",
"kind" : "function",
"type" : "bool()",
"line" : 3242}
,
{
"name" : "next",
"kind" : "function",
"type" : "void()",
"line" : 3244}
,
{
"name" : "search",
"kind" : "function",
"type" : "void()",
"line" : 3250}
,
{
"name" : "newStack",
"kind" : "function",
"type" : "void()",
"line" : 3264}
,
{
"name" : "initExternalMemory",
"kind" : "function",
"type" : "void(void[] memBlock)",
"line" : 3271}
,
{
"name" : "initialize",
"kind" : "function",
"type" : "void(ref RegEx program, Stream stream, void[] memBlock)",
"line" : 3279}
,
{
"name" : "dupTo",
"kind" : "function",
"type" : "(void[] memory)",
"line" : 3289}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref RegEx program, Stream stream, void[] memBlock)",
"line" : 3296}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref RegEx program, Stream stream, void[] memBlock, dchar ch, DataIndex idx)",
"line" : 3303}
,
{
"name" : "matchFinalize",
"kind" : "function",
"type" : "bool()",
"line" : 3311}
,
{
"name" : "match",
"kind" : "function",
"type" : "bool(Group!(DataIndex)[] matches)",
"line" : 3329}
,
{
"name" : "matchImpl",
"kind" : "function",
"type" : "bool()",
"line" : 3380}
,
{
"name" : "stackAvail",
"kind" : "function",
"type" : "size_t()",
"line" : 3721}
,
{
"name" : "prevStack",
"kind" : "function",
"type" : "bool()",
"line" : 3726}
,
{
"name" : "stackPush(T) if (!isDynamicArray!(T))",
"kind" : "template",
"protection" : "public",
"line" : 3739,
"members" : [
{
"name" : "stackPush",
"kind" : "function",
"type" : "void(T val)",
"line" : 3739}
]
}
,
{
"name" : "stackPush(T)",
"kind" : "template",
"protection" : "public",
"line" : 3748,
"members" : [
{
"name" : "stackPush",
"kind" : "function",
"type" : "void(T[] val)",
"line" : 3748}
]
}
,
{
"name" : "stackPop(T) if (!isDynamicArray!(T))",
"kind" : "template",
"protection" : "public",
"line" : 3757,
"members" : [
{
"name" : "stackPop",
"kind" : "function",
"type" : "void(ref T val)",
"line" : 3757}
]
}
,
{
"name" : "stackPop(T)",
"kind" : "template",
"protection" : "public",
"line" : 3766,
"members" : [
{
"name" : "stackPop",
"kind" : "function",
"type" : "void(ref T[] val)",
"line" : 3766}
]
}
]
}
]
}
]
}
,
{
"name" : "ctSub(U...)",
"kind" : "template",
"protection" : "public",
"line" : 4179,
"members" : [
{
"name" : "ctSub",
"kind" : "function",
"type" : "string(string format, U args)",
"line" : 4179}
]
}
,
{
"name" : "ctGenSeq",
"kind" : "function",
"protection" : "private",
"type" : "@system string(int S, int E)",
"line" : 4207}
,
{
"name" : "Sequence(int S,int E)",
"kind" : "template",
"protection" : "public",
"line" : 4221,
"members" : [
]
}
,
{
"name" : "CtContext",
"kind" : "struct",
"protection" : "private",
"line" : 4227,
"members" : [
{
"name" : "counter",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"line" : 4229}
,
{
"name" : "infNesting",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"line" : 4229}
,
{
"name" : "nInfLoops",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 4230}
,
{
"name" : "match",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 4231}
,
{
"name" : "total_matches",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 4231}
,
{
"name" : "CtState",
"kind" : "struct",
"protection" : "public",
"line" : 4236,
"members" : [
{
"name" : "code",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 4237}
,
{
"name" : "addr",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 4238}
]
}
,
{
"name" : "__ctor(Char)",
"kind" : "template",
"protection" : "public",
"line" : 4241,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Regex!(Char) re)",
"line" : 4241}
]
}
,
{
"name" : "restoreCode",
"kind" : "function",
"protection" : "public",
"type" : "@safe string()",
"line" : 4248}
,
{
"name" : "saveCode",
"kind" : "function",
"protection" : "public",
"type" : "@safe string(uint pc, string count_expr = \"counter\")",
"line" : 4271}
,
{
"name" : "ctGenBlock",
"kind" : "function",
"protection" : "public",
"type" : "@safe CtState(Bytecode[] ir, int addr)",
"line" : 4293}
,
{
"name" : "ctGenGroup",
"kind" : "function",
"protection" : "public",
"type" : "@safe CtState(ref Bytecode[] ir, int addr)",
"line" : 4307}
,
{
"name" : "ctGenAlternation",
"kind" : "function",
"protection" : "public",
"type" : "@safe CtState(Bytecode[] ir, int addr)",
"line" : 4348}
,
{
"name" : "ctGenFixupCode",
"kind" : "function",
"protection" : "public",
"type" : "@safe string(ref Bytecode[] ir, int addr, int fixup)",
"line" : 4389}
,
{
"name" : "ctQuickTest",
"kind" : "function",
"protection" : "public",
"type" : "@safe string(Bytecode[] ir, int id)",
"line" : 4519}
,
{
"name" : "ctGenAtom",
"kind" : "function",
"protection" : "public",
"type" : "@safe CtState(ref Bytecode[] ir, int addr)",
"line" : 4544}
,
{
"name" : "ctAtomCode",
"kind" : "function",
"protection" : "public",
"type" : "@safe string(Bytecode[] ir, int addr)",
"line" : 4554}
,
{
"name" : "ctGenRegEx(Char)",
"kind" : "template",
"protection" : "public",
"line" : 4731,
"members" : [
{
"name" : "ctGenRegEx",
"kind" : "function",
"type" : "string(ref Regex!(Char) re)",
"line" : 4731}
]
}
]
}
,
{
"name" : "ctGenRegExCode(Char)",
"kind" : "template",
"protection" : "public",
"line" : 4779,
"members" : [
{
"name" : "ctGenRegExCode",
"kind" : "function",
"type" : "string(Regex!(Char) re)",
"line" : 4779}
]
}
,
{
"name" : "Thread(DataIndex)",
"kind" : "struct",
"protection" : "public",
"line" : 4787,
"members" : [
{
"name" : "Thread",
"kind" : "struct",
"protection" : "public",
"line" : 4787,
"members" : [
{
"name" : "next",
"kind" : "variable",
"type" : "Thread*",
"line" : 4788}
,
{
"name" : "pc",
"kind" : "variable",
"type" : "uint",
"line" : 4789}
,
{
"name" : "counter",
"kind" : "variable",
"type" : "uint",
"line" : 4790}
,
{
"name" : "uopCounter",
"kind" : "variable",
"type" : "uint",
"line" : 4791}
,
{
"name" : "matches",
"kind" : "variable",
"type" : "Group!(DataIndex)[1]",
"line" : 4792}
]
}
]
}
,
{
"name" : "ThreadList(DataIndex)",
"kind" : "struct",
"protection" : "public",
"line" : 4797,
"members" : [
{
"name" : "ThreadList",
"kind" : "struct",
"protection" : "public",
"line" : 4797,
"members" : [
{
"name" : "tip",
"kind" : "variable",
"type" : "Thread!(DataIndex)*",
"line" : 4798}
,
{
"name" : "toe",
"kind" : "variable",
"type" : "Thread!(DataIndex)*",
"line" : 4798}
,
{
"name" : "insertFront",
"kind" : "function",
"type" : "void(Thread!(DataIndex)* t)",
"line" : 4800}
,
{
"name" : "insertBack",
"kind" : "function",
"type" : "void(Thread!(DataIndex)* t)",
"line" : 4814}
,
{
"name" : "fetch",
"kind" : "function",
"type" : "Thread!(DataIndex)*()",
"line" : 4826}
,
{
"name" : "ThreadRange",
"kind" : "struct",
"protection" : "public",
"line" : 4837,
"members" : [
{
"name" : "ct",
"kind" : "variable",
"type" : "const(Thread!(DataIndex))*",
"line" : 4838}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ThreadList tlist)",
"line" : 4839}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 4840}
,
{
"name" : "front",
"kind" : "function",
"type" : "const(Thread!(DataIndex))*()",
"line" : 4841}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "@property ()",
"line" : 4843}
]
}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 4848}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "ThreadRange()",
"line" : 4852}
]
}
]
}
,
{
"name" : "OneShot",
"kind" : "enum",
"protection" : "public",
"line" : 4859,
"base" : "int",
"members" : [
{
"name" : "Fwd",
"kind" : "enum member",
"protection" : "public",
"line" : 4859}
,
{
"name" : "Bwd",
"kind" : "enum member",
"protection" : "public",
"line" : 4859}
]
}
,
{
"name" : "ThompsonMatcher(Char,Stream = Input!(Char)) if (is(Char : dchar))",
"kind" : "struct",
"protection" : "public",
"line" : 4867,
"members" : [
{
"name" : "ThompsonMatcher",
"kind" : "struct",
"protection" : "public",
"line" : 4867,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "Stream.DataIndex",
"line" : 4868}
,
{
"name" : "freelist",
"kind" : "variable",
"type" : "Thread!(DataIndex)*",
"line" : 4869}
,
{
"name" : "clist",
"kind" : "variable",
"type" : "ThreadList!(DataIndex)",
"line" : 4870}
,
{
"name" : "nlist",
"kind" : "variable",
"type" : "ThreadList!(DataIndex)",
"line" : 4870}
,
{
"name" : "merge",
"kind" : "variable",
"type" : "DataIndex[]",
"line" : 4871}
,
{
"name" : "backrefed",
"kind" : "variable",
"type" : "Group!(DataIndex)[]",
"line" : 4872}
,
{
"name" : "re",
"kind" : "variable",
"type" : "Regex!(Char)",
"line" : 4873}
,
{
"name" : "s",
"kind" : "variable",
"type" : "Stream",
"line" : 4874}
,
{
"name" : "front",
"kind" : "variable",
"type" : "dchar",
"line" : 4875}
,
{
"name" : "index",
"kind" : "variable",
"type" : "DataIndex",
"line" : 4876}
,
{
"name" : "genCounter",
"kind" : "variable",
"type" : "DataIndex",
"line" : 4877}
,
{
"name" : "threadSize",
"kind" : "variable",
"type" : "size_t",
"line" : 4878}
,
{
"name" : "matched",
"kind" : "variable",
"type" : "bool",
"line" : 4879}
,
{
"name" : "exhausted",
"kind" : "variable",
"type" : "bool",
"line" : 4880}
,
{
"name" : "getThreadSize",
"kind" : "function",
"type" : "size_t(ref const Regex!(Char) re)",
"line" : 4888}
,
{
"name" : "initialMemory",
"kind" : "function",
"type" : "size_t(ref const Regex!(Char) re)",
"line" : 4895}
,
{
"name" : "atStart",
"kind" : "function",
"type" : "bool()",
"line" : 4901}
,
{
"name" : "atEnd",
"kind" : "function",
"type" : "bool()",
"line" : 4904}
,
{
"name" : "next",
"kind" : "function",
"type" : "bool()",
"line" : 4906}
,
{
"name" : "initExternalMemory",
"kind" : "function",
"type" : "void(void[] memory)",
"line" : 4930}
,
{
"name" : "__ctor()",
"kind" : "template",
"protection" : "public",
"line" : 4941,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(Regex!(Char) program, Stream stream, void[] memory)",
"line" : 4941}
]
}
,
{
"name" : "__ctor(S)",
"kind" : "template",
"protection" : "public",
"line" : 4949,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref ThompsonMatcher!(Char,S) matcher, Bytecode[] piece, Stream stream)",
"line" : 4949}
]
}
,
{
"name" : "dupTo",
"kind" : "function",
"type" : "(void[] memory)",
"line" : 4961}
,
{
"name" : "MatchResult",
"kind" : "enum",
"protection" : "public",
"line" : 4968,
"members" : [
{
"name" : "NoMatch",
"kind" : "enum member",
"protection" : "public",
"line" : 4969}
,
{
"name" : "PartialMatch",
"kind" : "enum member",
"protection" : "public",
"line" : 4970}
,
{
"name" : "Match",
"kind" : "enum member",
"protection" : "public",
"line" : 4971}
]
}
,
{
"name" : "match",
"kind" : "function",
"type" : "bool(Group!(DataIndex)[] matches)",
"line" : 4975}
,
{
"name" : "finish",
"kind" : "function",
"type" : "void(const(Thread!(DataIndex))* t, Group!(DataIndex)[] matches)",
"line" : 5068}
,
{
"name" : "eval(bool withInput)",
"kind" : "template",
"protection" : "public",
"line" : 5087,
"members" : [
{
"name" : "eval",
"kind" : "function",
"type" : "void(Thread!(DataIndex)* t, Group!(DataIndex)[] matches)",
"line" : 5087}
]
}
,
{
"name" : "RestartPc",
"kind" : "variable",
"type" : "uint",
"line" : 5560}
,
{
"name" : "matchOneShot(OneShot direction)",
"kind" : "template",
"protection" : "public",
"line" : 5562,
"members" : [
{
"name" : "matchOneShot",
"kind" : "function",
"type" : "MatchResult(Group!(DataIndex)[] matches, uint startPc = 0)",
"line" : 5562}
]
}
,
{
"name" : "evalBack(bool withInput)",
"kind" : "template",
"protection" : "public",
"line" : 5637,
"members" : [
{
"name" : "evalBack",
"kind" : "function",
"type" : "void(Thread!(DataIndex)* t, Group!(DataIndex)[] matches)",
"line" : 5637}
]
}
,
{
"name" : "allocate",
"kind" : "function",
"type" : "Thread!(DataIndex)*()",
"line" : 6065}
,
{
"name" : "prepareFreeList",
"kind" : "function",
"type" : "void(size_t size, ref void[] memory)",
"line" : 6074}
,
{
"name" : "recycle",
"kind" : "function",
"type" : "void(Thread!(DataIndex)* t)",
"line" : 6086}
,
{
"name" : "recycle",
"kind" : "function",
"type" : "void(ref ThreadList!(DataIndex) list)",
"line" : 6093}
,
{
"name" : "fork",
"kind" : "function",
"type" : "Thread!(DataIndex)*(Thread!(DataIndex)* master, uint pc, uint counter)",
"line" : 6106}
,
{
"name" : "createStart",
"kind" : "function",
"type" : "Thread!(DataIndex)*(DataIndex index, uint pc = 0)",
"line" : 6117}
]
}
]
}
,
{
"name" : "Captures(R,DIndex = size_t) if (isSomeString!(R))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    $(D Captures) object contains submatches captured during a call\n    to $(D match) or iteration over $(D RegexMatch) range.\n\n    First element of range is the whole match.\n\n    Example, showing basic operations on $(D Captures):\n    ----\n    import std.regex;\n    import std.range;\n\n    void main()\n    {\n        auto m = match(\"@abc#\", regex(`(\\w)(\\w)(\\w)`));\n        auto c = m.captures;\n        assert(c.pre == \"@\");\/\/ part of input preceeding match\n        assert(c.post == \"#\"); \/\/ immediately after match\n        assert(c.hit == c[0] && c.hit == \"abc\");\/\/ the whole match\n        assert(c[2] ==\"b\");\n        assert(c.front == \"abc\");\n        c.popFront();\n        assert(c.front == \"a\");\n        assert(c.back == \"c\");\n        c.popBack();\n        assert(c.back == \"b\");\n        popFrontN(c, 2);\n        assert(c.empty);\n    }\n    ----\n",
"line" : 6161,
"members" : [
{
"name" : "Captures",
"kind" : "struct",
"protection" : "public",
"line" : 6161,
"members" : [
{
"name" : "DataIndex",
"kind" : "alias",
"type" : "DIndex",
"line" : 6162}
,
{
"name" : "String",
"kind" : "alias",
"type" : "R",
"line" : 6163}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 6165}
,
{
"name" : "_empty",
"kind" : "variable",
"type" : "bool",
"line" : 6166}
,
{
"name" : "smallString",
"kind" : "variable",
"line" : 6167}
,
{
"name" : "big_matches",
"kind" : "variable",
"type" : "Group!(DataIndex)[]",
"line" : 6170}
,
{
"name" : "small_matches",
"kind" : "variable",
"type" : "Group!(DataIndex)[smallString]",
"line" : 6171}
,
{
"name" : "f",
"kind" : "variable",
"type" : "uint",
"line" : 6173}
,
{
"name" : "b",
"kind" : "variable",
"type" : "uint",
"line" : 6173}
,
{
"name" : "ngroup",
"kind" : "variable",
"type" : "uint",
"line" : 6174}
,
{
"name" : "names",
"kind" : "variable",
"type" : "NamedGroup[]",
"line" : 6175}
,
{
"name" : "__ctor(alias Engine)",
"kind" : "template",
"protection" : "public",
"line" : 6177,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref RegexMatch!(R,Engine) rmatch)",
"line" : 6177}
]
}
,
{
"name" : "matches",
"kind" : "function",
"type" : "Group!(DataIndex)[]()",
"line" : 6187}
,
{
"name" : "newMatches",
"kind" : "function",
"type" : "void()",
"line" : 6192}
,
{
"name" : "pre",
"kind" : "function",
"type" : "R()",
"comment" : "Slice of input prior to the match.\n",
"line" : 6200}
,
{
"name" : "post",
"kind" : "function",
"type" : "R()",
"comment" : "Slice of input immediately after the match.\n",
"line" : 6206}
,
{
"name" : "hit",
"kind" : "function",
"type" : "R()",
"comment" : "Slice of matched portion of input.\n",
"line" : 6212}
,
{
"name" : "front",
"kind" : "function",
"type" : "R()",
"comment" : "Range interface.\n",
"line" : 6219}
,
{
"name" : "back",
"kind" : "function",
"type" : "R()",
"comment" : "ditto\n",
"line" : 6226}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "ditto\n",
"line" : 6233}
,
{
"name" : "popBack",
"kind" : "function",
"type" : "void()",
"comment" : "ditto\n",
"line" : 6240}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : "ditto\n",
"line" : 6247}
,
{
"name" : "opIndex()",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 6250,
"members" : [
{
"name" : "opIndex",
"kind" : "function",
"type" : "R(size_t i)",
"comment" : "ditto\n",
"line" : 6250}
]
}
,
{
"name" : "opIndex(String) if (isSomeString!(String))",
"kind" : "template",
"protection" : "public",
"comment" : "\n        Lookup named submatch.\n\n        ---\n        import std.regex;\n        import std.range;\n\n        auto m = match(\"a = 42;\", regex(`(?P<var>\\w+)\\s*=\\s*(?P<value>\\d+);`));\n        auto c = m.captures;\n        assert(c[\"var\"] == \"a\");\n        assert(c[\"value\"] == \"42\");\n        popFrontN(c, 2);\n        \/\/named groups are unaffected by range primitives\n        assert(c[\"var\"] ==\"a\");\n        assert(c.front == \"42\");\n        ----\n    \n",
"line" : 6274,
"members" : [
{
"name" : "opIndex",
"kind" : "function",
"type" : "R(String i)",
"comment" : "\n        Lookup named submatch.\n\n        ---\n        import std.regex;\n        import std.range;\n\n        auto m = match(\"a = 42;\", regex(`(?P<var>\\w+)\\s*=\\s*(?P<value>\\d+);`));\n        auto c = m.captures;\n        assert(c[\"var\"] == \"a\");\n        assert(c[\"value\"] == \"42\");\n        popFrontN(c, 2);\n        \/\/named groups are unaffected by range primitives\n        assert(c[\"var\"] ==\"a\");\n        assert(c.front == \"42\");\n        ----\n    \n",
"line" : 6274}
]
}
,
{
"name" : "length",
"kind" : "function",
"type" : "const size_t()",
"comment" : "Number of matches in this object.\n",
"line" : 6282}
,
{
"name" : "captures",
"kind" : "function",
"type" : "@property ref ()",
"comment" : "A hook for compatibility with original std.regex.\n",
"line" : 6285}
]
}
]
}
,
{
"name" : "RegexMatch(R,alias Engine = ThompsonMatcher) if (isSomeString!(R))",
"kind" : "struct",
"protection" : "public",
"comment" : "\n    A regex engine state, as returned by $(D match) family of functions.\n\n    Effectively it's a forward range of Captures!R, produced\n    by lazily searching for matches in a given input.\n\n    alias Engine specifies an engine type to use during matching,\n    and is automatically deduced in a call to $(D match)\/$(D bmatch).\n",
"line" : 6317,
"members" : [
{
"name" : "RegexMatch",
"kind" : "struct",
"protection" : "public",
"line" : 6317,
"members" : [
{
"name" : "Char",
"kind" : "alias",
"type" : "BasicElementOf!(R)",
"line" : 6319}
,
{
"name" : "EngineType",
"kind" : "alias",
"type" : "Engine!(Char)",
"line" : 6320}
,
{
"name" : "_engine",
"kind" : "variable",
"type" : "EngineType",
"line" : 6321}
,
{
"name" : "_input",
"kind" : "variable",
"type" : "R",
"line" : 6322}
,
{
"name" : "_captures",
"kind" : "variable",
"type" : "Captures!(R,EngineType.DataIndex)",
"line" : 6323}
,
{
"name" : "_memory",
"kind" : "variable",
"type" : "void[]",
"line" : 6324}
,
{
"name" : "__ctor(RegEx)",
"kind" : "template",
"protection" : "public",
"line" : 6326,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(RegEx prog, R input)",
"line" : 6326}
]
}
,
{
"name" : "counter",
"kind" : "function",
"type" : "size_t()",
"line" : 6339}
,
{
"name" : "pre",
"kind" : "function",
"type" : "R()",
"comment" : "Shorthands for front.pre, front.post, front.hit.\n",
"line" : 6362}
,
{
"name" : "post",
"kind" : "function",
"type" : "R()",
"comment" : "ditto\n",
"line" : 6368}
,
{
"name" : "hit",
"kind" : "function",
"type" : "R()",
"comment" : "ditto\n",
"line" : 6374}
,
{
"name" : "front",
"kind" : "function",
"type" : "@property ()",
"comment" : "\n        Functionality for processing subsequent matches of global regexes via range interface:\n        ---\n        import std.regex;\n        auto m = match(\"Hello, world!\", regex(`\\w+`, \"g\"));\n        assert(m.front.hit == \"Hello\");\n        m.popFront();\n        assert(m.front.hit == \"world\");\n        m.popFront();\n        assert(m.empty);\n        ---\n    \n",
"line" : 6392}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "ditto\n",
"line" : 6397}
,
{
"name" : "save",
"kind" : "function",
"type" : "()",
"comment" : "ditto\n",
"line" : 6414}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "Test if this match object is empty.\n",
"line" : 6417}
,
{
"name" : "opCast(T : bool)",
"kind" : "template",
"protection" : "public",
"comment" : "Same as !(x.empty), provided for its convenience  in conditional statements.\n",
"line" : 6420,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "T()",
"comment" : "Same as !(x.empty), provided for its convenience  in conditional statements.\n",
"line" : 6420}
]
}
,
{
"name" : "captures",
"kind" : "function",
"type" : "@property ()",
"comment" : " Same as .front, provided for compatibility with original std.regex.\n",
"line" : 6423}
]
}
]
}
,
{
"name" : "regex(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Compile regular expression pattern for the later execution.\n    Returns: $(D Regex) object that works on inputs having\n    the same character width as $(D pattern).\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n\n    Throws: $(D RegexException) if there were any errors during compilation.\n",
"line" : 6438,
"members" : [
{
"name" : "regex",
"kind" : "function",
"type" : "(S pattern, const(char)[] flags = \"\")",
"line" : 6438}
]
}
,
{
"name" : "regexImpl(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"line" : 6447,
"members" : [
{
"name" : "regexImpl",
"kind" : "function",
"type" : "(S pattern, const(char)[] flags = \"\")",
"line" : 6447}
]
}
,
{
"name" : "ctRegexImpl(alias pattern,string flags = [])",
"kind" : "template",
"protection" : "public",
"line" : 6466,
"members" : [
{
"name" : "r",
"kind" : "variable",
"line" : 6468}
,
{
"name" : "Char",
"kind" : "alias",
"type" : "BasicElementOf!(typeof(pattern))",
"line" : 6469}
,
{
"name" : "source",
"kind" : "variable",
"line" : 6470}
,
{
"name" : "Matcher",
"kind" : "alias",
"type" : "BacktrackingMatcher!(true)",
"line" : 6471}
,
{
"name" : "func",
"kind" : "function",
"type" : "bool(ref Matcher!(Char) matcher)",
"line" : 6472}
,
{
"name" : "nr",
"kind" : "variable",
"line" : 6477}
]
}
,
{
"name" : "ctRegex(alias pattern,alias flags = [])",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Experimental feature.\n\n    Compile regular expression using CTFE\n    and generate optimized native machine code for matching it.\n\n    Returns: StaticRegex object for faster matching.\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n",
"line" : 6492,
"members" : [
{
"name" : "ctRegex",
"kind" : "variable",
"line" : 6494}
]
}
,
{
"name" : "isRegexFor(RegEx,R)",
"kind" : "template",
"protection" : "public",
"line" : 6497,
"members" : [
{
"name" : "isRegexFor",
"kind" : "variable",
"line" : 6500}
]
}
,
{
"name" : "match(R,RegEx) if (isSomeString!(R) && is(RegEx == Regex!(BasicElementOf!(R))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Start matching $(D input) to regex pattern $(D re),\n    using Thompson NFA matching scheme.\n\n    This is the $(U recommended) method for matching regular expression.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar\/dchar) that contains pattern in form of\n        precompiled  bytecode. )\n      $(LI StaticRegex!char (wchar\/dchar) that contains pattern in form of\n        specially crafted native code. )\n    )\n    Returns: a $(D RegexMatch) object holding engine state after first match.\n",
"line" : 6520,
"members" : [
{
"name" : "match",
"kind" : "function",
"type" : "(R input, RegEx re)",
"line" : 6520}
]
}
,
{
"name" : "match(R,String) if (isSomeString!(R) && isSomeString!(String))",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 6527,
"members" : [
{
"name" : "match",
"kind" : "function",
"type" : "(R input, String re)",
"line" : 6527}
]
}
,
{
"name" : "match(R,RegEx) if (isSomeString!(R) && is(RegEx == StaticRegex!(BasicElementOf!(R))))",
"kind" : "template",
"protection" : "public",
"line" : 6533,
"members" : [
{
"name" : "match",
"kind" : "function",
"type" : "(R input, RegEx re)",
"line" : 6533}
]
}
,
{
"name" : "bmatch(R,RegEx) if (isSomeString!(R) && is(RegEx == Regex!(BasicElementOf!(R))))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Start matching $(D input) to regex pattern $(D re),\n    using traditional $(LUCKY backtracking) matching scheme.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar\/dchar) that contains pattern in form of\n        precompiled  bytecode. )\n      $(LI StaticRegex!char (wchar\/dchar) that contains pattern in form of\n        specially crafted native code. )\n    )\n\n    Returns: a $(D RegexMatch) object holding engine\n    state after first match.\n\n",
"line" : 6556,
"members" : [
{
"name" : "bmatch",
"kind" : "function",
"type" : "(R input, RegEx re)",
"line" : 6556}
]
}
,
{
"name" : "bmatch(R,String) if (isSomeString!(R) && isSomeString!(String))",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 6563,
"members" : [
{
"name" : "bmatch",
"kind" : "function",
"type" : "(R input, String re)",
"line" : 6563}
]
}
,
{
"name" : "bmatch(R,RegEx) if (isSomeString!(R) && is(RegEx == StaticRegex!(BasicElementOf!(R))))",
"kind" : "template",
"protection" : "public",
"line" : 6569,
"members" : [
{
"name" : "bmatch",
"kind" : "function",
"type" : "(R input, RegEx re)",
"line" : 6569}
]
}
,
{
"name" : "replace(alias scheme = match,R,RegEx) if (isSomeString!(R) && isRegexFor!(RegEx,R))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Construct a new string from $(D input) by replacing each match with\n    a string generated from match according to $(D format) specifier.\n\n    To replace all occurrences use regex with \"g\" flag, otherwise\n    only the first occurrence gets replaced.\n\n    Params:\n    input = string to search\n    re = compiled regular expression to use\n    format = format string to generate replacements from\n\n    Example:\n    ---\n    \/\/Comify a number\n    auto com = regex(r\"(?<=\\d)(?=(\\d\\d\\d)+\\b)\",\"g\");\n    assert(replace(\"12000 + 42100 = 54100\", com, \",\") == \"12,000 + 42,100 = 54,100\");\n    ---\n\n    The format string can reference parts of match using the following notation.\n    $(REG_TABLE\n        $(REG_TITLE Format specifier, Replaced by )\n        $(REG_ROW $&amp;, the whole match. )\n        $(REG_ROW $`, part of input $(I preceding) the match. )\n        $(REG_ROW $', part of input $(I following) the match. )\n        $(REG_ROW $$, '$' character. )\n        $(REG_ROW \\c &#44 where c is any character, the character c itself. )\n        $(REG_ROW \\\\, '\\' character. )\n        $(REG_ROW &#36;1 .. &#36;99, submatch number 1 to 99 respectively. )\n    )\n    ---\n    assert(replace(\"noon\", regex(\"^n\"), \"[$&]\") == \"[n]oon\");\n    ---\n",
"line" : 6609,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "R(R input, RegEx re, R format)",
"line" : 6609}
]
}
,
{
"name" : "replace(alias fun,R,RegEx,alias scheme = match) if (isSomeString!(R) && isRegexFor!(RegEx,R))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Search string for matches using regular expression pattern $(D re)\n    and pass captures for each match to user-defined functor $(D fun).\n\n    To replace all occurrances use regex with \"g\" flag, otherwise\n    only first occurrence gets replaced.\n\n    Returns: new string with all matches replaced by return values of $(D fun).\n\n    Params:\n    s = string to search\n    re = compiled regular expression\n    fun = delegate to use\n\n    Example:\n    Capitalize the letters 'a' and 'r':\n    ---\n    string baz(Captures!(string) m)\n    {\n        return std.string.toUpper(m.hit);\n    }\n    auto s = replace!(baz)(\"Strap a rocket engine on a chicken.\",\n            regex(\"[ar]\", \"g\"));\n    assert(s == \"StRAp A Rocket engine on A chicken.\");\n    ---\n",
"line" : 6651,
"members" : [
{
"name" : "replace",
"kind" : "function",
"type" : "R(R input, RegEx re)",
"line" : 6651}
]
}
,
{
"name" : "replaceFmt(R,Capt,OutR) if (isOutputRange!(OutR,ElementEncodingType!(R)[]) && isOutputRange!(OutR,ElementEncodingType!(Capt.String)[]))",
"kind" : "template",
"protection" : "public",
"line" : 6668,
"members" : [
{
"name" : "replaceFmt",
"kind" : "function",
"type" : "void(R format, Capt captures, OutR sink, bool ignoreBadSubs = false)",
"line" : 6668}
]
}
,
{
"name" : "Splitter(Range,alias RegEx = Regex) if (isSomeString!(Range) && isRegexFor!(RegEx,Range))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nRange that splits a string using a regular expression as a\nseparator.\n\nExample:\n----\nauto s1 = \", abc, de,  fg, hi, \";\nassert(equal(splitter(s1, regex(\", *\")),\n    [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"]));\n----\n",
"line" : 6750,
"members" : [
{
"name" : "Splitter",
"kind" : "struct",
"protection" : "public",
"line" : 6750,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 6752}
,
{
"name" : "_offset",
"kind" : "variable",
"type" : "size_t",
"line" : 6753}
,
{
"name" : "Rx",
"kind" : "alias",
"type" : "typeof(match(Range.init,RegEx.init))",
"line" : 6754}
,
{
"name" : "_match",
"kind" : "variable",
"type" : "Rx",
"line" : 6755}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input, RegEx separator)",
"line" : 6757}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "ref ()",
"line" : 6774}
,
{
"name" : "front",
"kind" : "function",
"type" : "Range()",
"comment" : "Forward range primitives.\n",
"line" : 6779}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : "ditto\n",
"line" : 6787}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : "ditto\n",
"line" : 6793}
,
{
"name" : "save",
"kind" : "function",
"type" : "@property ()",
"comment" : "ditto\n",
"line" : 6811}
]
}
]
}
,
{
"name" : "splitter(Range,RegEx) if (is(BasicElementOf!(Range) : dchar) && isRegexFor!(RegEx,Range))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    A helper function, creates a $(D Splitter) on range $(D r) separated by regex $(D pat).\n    Captured subexpressions have no effect on the resulting range.\n",
"line" : 6820,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "Splitter!(Range,RegEx)(Range r, RegEx pat)",
"line" : 6820}
]
}
,
{
"name" : "split(String,RegEx) if (isSomeString!(String) && isRegexFor!(RegEx,String))",
"kind" : "template",
"protection" : "public",
"comment" : "An eager version of $(D splitter) that creates an array with splitted slices of $(D input).\n",
"line" : 6827,
"members" : [
{
"name" : "split",
"kind" : "function",
"type" : "String[](String input, RegEx rx)",
"line" : 6827}
]
}
,
{
"name" : "RegexException",
"kind" : "class",
"protection" : "public",
"comment" : "Exception object thrown in case of errors during regex compilation.\n",
"line" : 6837,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "@trusted RegexException(string msg, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"comment" : "\n",
"line" : 6840}
]
}
]
}
,
{
"name" : "std.regexp",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/regexp.d",
"comment" : "\n $(RED Deprecated.\n       Please use $(LINK2 std_regex.html, std.regex) instead.)\n\n $(LINK2 http:\/\/www.digitalmars.com\/ctg\/regular.html, Regular\n expressions) are a powerful method of string pattern matching.  The\n regular expression language used in this library is the same as\n that commonly used, however, some of the very advanced forms may\n behave slightly differently. The standard observed is the $(WEB\n www.ecma-international.org\/publications\/standards\/Ecma-262.htm,\n ECMA standard) for regular expressions.\n\n std.regexp is designed to work only with valid UTF strings as input.\n To validate untrusted input, use std.utf.validate().\n\n In the following guide, $(I pattern)[] refers to a\n $(LINK2 http:\/\/www.digitalmars.com\/ctg\/regular.html, regular expression).\n The $(I attributes)[] refers to\n a string controlling the interpretation\n of the regular expression.\n It consists of a sequence of one or more\n of the following characters:\n\n <table border=1 cellspacing=0 cellpadding=5>\n <caption>Attribute Characters<\/caption>\n $(TR $(TH Attribute) $(TH Action))\n <tr>\n $(TD $(B g))\n $(TD global; repeat over the whole input string)\n <\/tr>\n <tr>\n $(TD $(B i))\n $(TD case insensitive)\n <\/tr>\n <tr>\n $(TD $(B m))\n $(TD treat as multiple lines separated by newlines)\n <\/tr>\n <\/table>\n\n The $(I format)[] string has the formatting characters:\n\n <table border=1 cellspacing=0 cellpadding=5>\n <caption>Formatting Characters<\/caption>\n $(TR $(TH Format) $(TH Replaced With))\n $(TR\n $(TD $(B $$))    $(TD $)\n )\n $(TR\n $(TD $(B $&amp;))    $(TD The matched substring.)\n )\n $(TR\n $(TD $(B $`))    $(TD The portion of string that precedes the matched substring.)\n )\n $(TR\n $(TD $(B $'))    $(TD The portion of string that follows the matched substring.)\n )\n $(TR\n $(TD $(B $(DOLLAR))$(I n)) $(TD The $(I n)th capture, where $(I n)\n      is a single digit 1-9\n      and $$(I n) is not followed by a decimal digit.)\n )\n $(TR\n $(TD $(B $(DOLLAR))$(I nn)) $(TD The $(I nn)th capture, where $(I nn)\n      is a two-digit decimal\n      number 01-99.\n      If $(I nn)th capture is undefined or more than the number\n      of parenthesized subexpressions, use the empty\n      string instead.)\n )\n <\/table>\n\n Any other $ are left as is.\n\n References:\n  $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Regular_expressions, Wikipedia)\n Macros:\n  WIKI = StdRegexp\n  DOLLAR = $\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_regexp.d)\n \n",
"members" : [
{
"name" : "email",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Regular expression to extract an _email address.\n References:\n  $(LINK2 http:\/\/www.regular-expressions.info\/email.html, How to Find or Validate an Email Address)$(BR)\n  $(LINK2 http:\/\/tools.ietf.org\/html\/rfc2822#section-3.4.1, RFC 2822 Internet Message Format)\n \n",
"line" : 156}
,
{
"name" : "url",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Regular expression to extract a _url \n",
"line" : 160}
,
{
"name" : "RegExpException",
"kind" : "class",
"protection" : "public",
"comment" : "\n One of these gets thrown on compilation errors\n \n",
"line" : 166,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "RegExpException(string msg)",
"line" : 168}
]
}
,
{
"name" : "regmatch_t",
"kind" : "struct",
"protection" : "public",
"line" : 175,
"members" : [
{
"name" : "rm_so",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 176}
,
{
"name" : "rm_eo",
"kind" : "variable",
"protection" : "public",
"type" : "long",
"line" : 177}
]
}
,
{
"name" : "rchar",
"kind" : "alias",
"protection" : "private",
"type" : "char",
"line" : 180}
,
{
"name" : "sub",
"kind" : "function",
"protection" : "public",
"type" : "string(string s, string pattern, string format, string attributes = null)",
"comment" : "\n Search string for matches with regular expression\n pattern with attributes.\n Replace each match with string generated from format.\n Params:\n  s = String to search.\n  pattern = Regular expression pattern.\n  format = Replacement string format.\n  attributes = Regular expression attributes.\n Returns:\n  the resulting string\n Example:\n  Replace the letters 'a' with the letters 'ZZ'.\n ---\n s = \"Strap a rocket engine on a chicken.\"\n sub(s, \"a\", \"ZZ\")        \/\/ result: StrZZp a rocket engine on a chicken.\n sub(s, \"a\", \"ZZ\", \"g\")   \/\/ result: StrZZp ZZ rocket engine on ZZ chicken.\n ---\n  The replacement format can reference the matches using\n  the $&amp;, $$, $', $`, $0 .. $99 notation:\n ---\n sub(s, \"[ar]\", \"[$&]\", \"g\") \/\/ result: St[r][a]p [a] [r]ocket engine on [a] chi\n ---\n \n",
"line" : 207}
,
{
"name" : "sub",
"kind" : "function",
"protection" : "public",
"type" : "string(string s, string pattern, string delegate(RegExp) dg, string attributes = null)",
"comment" : "\n Search string for matches with regular expression\n pattern with attributes.\n Pass each match to delegate dg.\n Replace each match with the return value from dg.\n Params:\n  s = String to search.\n  pattern = Regular expression pattern.\n  dg = Delegate\n  attributes = Regular expression attributes.\n Returns: the resulting string.\n Example:\n Capitalize the letters 'a' and 'r':\n ---\n s = \"Strap a rocket engine on a chicken.\";\n sub(s, \"[ar]\",\n    delegate char[] (RegExp m)\n    {\n         return toUpper(m[0]);\n    },\n    \"g\");    \/\/ result: StRAp A Rocket engine on A chicken.\n ---\n \n",
"line" : 247}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "long(string s, RegExp pattern)",
"comment" : "\n Search $(D_PARAM s[]) for first match with $(D_PARAM pattern).\n Params:\n  s = String to search.\n  pattern = Regular expression pattern.\n Returns:\n  index into s[] of match if found, -1 if no match.\n Example:\n ---\n auto s = \"abcabcabab\";\n find(s, RegExp(\"b\"));    \/\/ match, returns 1\n find(s, RegExp(\"f\"));    \/\/ no match, returns -1\n ---\n \n",
"line" : 336}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "long(string s, string pattern, string attributes = null)",
"comment" : "\n   Returns:\n\n   Same as $(D_PARAM find(s, RegExp(pattern, attributes))).\n\n   WARNING:\n\n   This function is scheduled for deprecation due to unnecessary\n   ambiguity with the homonym function in std.string. Instead of\n   $(D_PARAM std.regexp.find(s, p, a)), you may want to use $(D_PARAM\n   find(s, RegExp(p, a))).\n",
"line" : 367}
,
{
"name" : "rfind",
"kind" : "function",
"protection" : "public",
"type" : "long(string s, RegExp pattern)",
"comment" : "\n Search $(D_PARAM s[]) for last match with $(D_PARAM pattern).\n Params:\n  s = String to search.\n  pattern = Regular expression pattern.\n Returns:\n  index into s[] of match if found, -1 if no match.\n Example:\n ---\n auto s = \"abcabcabab\";\n rfind(s, RegExp(\"b\"));    \/\/ match, returns 9\n rfind(s, RegExp(\"f\"));    \/\/ no match, returns -1\n ---\n \n",
"line" : 399}
,
{
"name" : "rfind",
"kind" : "function",
"protection" : "public",
"type" : "long(string s, string pattern, string attributes = null)",
"comment" : "\nReturns:\n\n  Same as $(D_PARAM rfind(s, RegExp(pattern, attributes))).\n\nWARNING:\n\nThis function is scheduled for deprecation due to unnecessary\nambiguity with the homonym function in std.string. Instead of\n$(D_PARAM std.regexp.rfind(s, p, a)), you may want to use $(D_PARAM\nrfind(s, RegExp(p, a))).\n",
"line" : 446}
,
{
"name" : "split",
"kind" : "function",
"protection" : "public",
"type" : "string[](string s, RegExp pattern)",
"comment" : "\n Split s[] into an array of strings, using the regular\n expression $(D_PARAM pattern) as the separator.\n Params:\n  s = String to search.\n  pattern = Regular expression pattern.\n Returns:\n  array of slices into s[]\n Example:\n ---\n foreach (s; split(\"abcabcabab\", RegExp(\"C.\", \"i\")))\n {\n     writefln(\"s = '%s'\", s);\n }\n \/\/ Prints:\n \/\/ s = 'ab'\n \/\/ s = 'b'\n \/\/ s = 'bab'\n ---\n \n",
"line" : 503}
,
{
"name" : "split",
"kind" : "function",
"protection" : "public",
"type" : "string[](string s, string pattern, string attributes = null)",
"comment" : "\n  Returns:\n    Same as $(D_PARAM split(s, RegExp(pattern, attributes))).\n\nWARNING:\n\nThis function is scheduled for deprecation due to unnecessary\nambiguity with the homonym function in std.string. Instead of\n$(D_PARAM std.regexp.split(s, p, a)), you may want to use $(D_PARAM\nsplit(s, RegExp(p, a))).\n",
"line" : 540}
,
{
"name" : "search",
"kind" : "function",
"protection" : "public",
"type" : "RegExp(string s, string pattern, string attributes = null)",
"comment" : "\n Search s[] for first match with pattern[] with attributes[].\n Params:\n  s = String to search.\n  pattern = Regular expression pattern.\n  attributes = Regular expression attributes.\n Returns:\n  corresponding RegExp if found, null if not.\n Example:\n ---\n import std.stdio;\n import std.regexp;\n\n void main()\n {\n     if (auto m = std.regexp.search(\"abcdef\", \"c\"))\n     {\n         writefln(\"%s[%s]%s\", m.pre, m[0], m.post);\n     }\n }\n \/\/ Prints:\n \/\/ ab[c]def\n ---\n \n",
"line" : 593}
,
{
"name" : "RegExp",
"kind" : "class",
"protection" : "public",
"comment" : "\n RegExp is a class to handle regular expressions.\n\n It is the core foundation for adding powerful string pattern matching\n capabilities to programs like grep, text editors, awk, sed, etc.\n \n",
"line" : 632,
"base" : "Object",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "RegExp(string pattern, string attributes = null)",
"comment" : "\n Construct a RegExp object. Compile pattern\n with <i>attributes<\/i> into\n an internal form for fast execution.\n Params:\n  pattern = regular expression\n  attributes = _attributes\n Throws: RegExpException if there are any compilation errors.\n Example:\n  Declare two variables and assign to them a RegExp object:\n ---\n auto r = new RegExp(\"pattern\");\n auto s = new RegExp(r\"p[1-5]\\s*\");\n ---\n     \n",
"line" : 648}
,
{
"name" : "opCall",
"kind" : "function",
"protection" : "public",
"type" : "RegExp(string pattern, string attributes = null)",
"comment" : "\n Generate instance of RegExp.\n Params:\n  pattern = regular expression\n  attributes = _attributes\n Throws: RegExpException if there are any compilation errors.\n Example:\n  Declare two variables and assign to them a RegExp object:\n ---\n auto r = RegExp(\"pattern\");\n auto s = RegExp(r\"p[1-5]\\s*\");\n ---\n     \n",
"line" : 667}
,
{
"name" : "search",
"kind" : "function",
"protection" : "public",
"type" : "RegExp(string string)",
"comment" : "\n Set up for start of foreach loop.\n Returns:\n  search() returns instance of RegExp set up to _search string[].\n Example:\n ---\n import std.stdio;\n import std.regexp;\n\n void main()\n {\n     foreach(m; RegExp(\"ab\").search(\"abcabcabab\"))\n     {\n         writefln(\"%s[%s]%s\", m.pre, m[0], m.post);\n     }\n }\n \/\/ Prints:\n \/\/ [ab]cabcabab\n \/\/ abc[ab]cabab\n \/\/ abcabc[ab]ab\n \/\/ abcabcab[ab]\n ---\n     \n",
"line" : 714}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref RegExp) dg)",
"comment" : " ditto \n",
"line" : 722}
,
{
"name" : "opIndex",
"kind" : "function",
"protection" : "public",
"type" : "string(ulong n)",
"comment" : "\n Retrieve match n.\n\n n==0 means the matched substring, n>0 means the\n n'th parenthesized subexpression.\n if n is larger than the number of parenthesized subexpressions,\n null is returned.\n     \n",
"line" : 762}
,
{
"name" : "match",
"kind" : "function",
"protection" : "public",
"type" : "string(ulong n)",
"comment" : "\n       Same as $(D_PARAM opIndex(n)).\n\n       WARNING:\n\n       Scheduled for deprecation due to confusion with overloaded\n       $(D_PARAM match(string)). Instead of $(D_PARAM regex.match(n))\n       you may want to use $(D_PARAM regex[n]).\n    \n",
"line" : 785}
,
{
"name" : "pre",
"kind" : "function",
"protection" : "public",
"type" : "@property string()",
"comment" : "\n Return the slice of the input that precedes the matched substring.\n     \n",
"line" : 793}
,
{
"name" : "post",
"kind" : "function",
"protection" : "public",
"type" : "@property string()",
"comment" : "\n Return the slice of the input that follows the matched substring.\n     \n",
"line" : 801}
,
{
"name" : "re_nsub",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 806}
,
{
"name" : "pmatch",
"kind" : "variable",
"protection" : "public",
"type" : "regmatch_t[]",
"line" : 807}
,
{
"name" : "input",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 809}
,
{
"name" : "pattern",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 813}
,
{
"name" : "flags",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 815}
,
{
"name" : "errors",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 817}
,
{
"name" : "attributes",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 819}
,
{
"name" : "REA",
"kind" : "enum",
"protection" : "public",
"line" : 822,
"base" : "int",
"members" : [
{
"name" : "global",
"kind" : "enum member",
"protection" : "public",
"line" : 823}
,
{
"name" : "ignoreCase",
"kind" : "enum member",
"protection" : "public",
"line" : 824}
,
{
"name" : "multiline",
"kind" : "enum member",
"protection" : "public",
"line" : 825}
,
{
"name" : "dotmatchlf",
"kind" : "enum member",
"protection" : "public",
"line" : 827}
]
}
,
{
"name" : "src",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 832}
,
{
"name" : "src_start",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 833}
,
{
"name" : "p",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 834}
,
{
"name" : "gmatch",
"kind" : "variable",
"protection" : "private",
"type" : "regmatch_t",
"line" : 835}
,
{
"name" : "program",
"kind" : "variable",
"protection" : "private",
"type" : "const(ubyte)[]",
"line" : 838}
,
{
"name" : "buf",
"kind" : "variable",
"protection" : "private",
"type" : "std.outbuffer.OutBuffer",
"line" : 839}
,
{
"name" : "REend",
"kind" : "enum member",
"protection" : "public",
"line" : 850}
,
{
"name" : "REchar",
"kind" : "enum member",
"protection" : "public",
"line" : 851}
,
{
"name" : "REichar",
"kind" : "enum member",
"protection" : "public",
"line" : 852}
,
{
"name" : "REdchar",
"kind" : "enum member",
"protection" : "public",
"line" : 853}
,
{
"name" : "REidchar",
"kind" : "enum member",
"protection" : "public",
"line" : 854}
,
{
"name" : "REanychar",
"kind" : "enum member",
"protection" : "public",
"line" : 855}
,
{
"name" : "REanystar",
"kind" : "enum member",
"protection" : "public",
"line" : 856}
,
{
"name" : "REstring",
"kind" : "enum member",
"protection" : "public",
"line" : 857}
,
{
"name" : "REistring",
"kind" : "enum member",
"protection" : "public",
"line" : 858}
,
{
"name" : "REtestbit",
"kind" : "enum member",
"protection" : "public",
"line" : 859}
,
{
"name" : "REbit",
"kind" : "enum member",
"protection" : "public",
"line" : 860}
,
{
"name" : "REnotbit",
"kind" : "enum member",
"protection" : "public",
"line" : 861}
,
{
"name" : "RErange",
"kind" : "enum member",
"protection" : "public",
"line" : 862}
,
{
"name" : "REnotrange",
"kind" : "enum member",
"protection" : "public",
"line" : 863}
,
{
"name" : "REor",
"kind" : "enum member",
"protection" : "public",
"line" : 864}
,
{
"name" : "REplus",
"kind" : "enum member",
"protection" : "public",
"line" : 865}
,
{
"name" : "REstar",
"kind" : "enum member",
"protection" : "public",
"line" : 866}
,
{
"name" : "REquest",
"kind" : "enum member",
"protection" : "public",
"line" : 867}
,
{
"name" : "REnm",
"kind" : "enum member",
"protection" : "public",
"line" : 868}
,
{
"name" : "REnmq",
"kind" : "enum member",
"protection" : "public",
"line" : 869}
,
{
"name" : "REbol",
"kind" : "enum member",
"protection" : "public",
"line" : 870}
,
{
"name" : "REeol",
"kind" : "enum member",
"protection" : "public",
"line" : 871}
,
{
"name" : "REparen",
"kind" : "enum member",
"protection" : "public",
"line" : 872}
,
{
"name" : "REgoto",
"kind" : "enum member",
"protection" : "public",
"line" : 873}
,
{
"name" : "REwordboundary",
"kind" : "enum member",
"protection" : "public",
"line" : 875}
,
{
"name" : "REnotwordboundary",
"kind" : "enum member",
"protection" : "public",
"line" : 876}
,
{
"name" : "REdigit",
"kind" : "enum member",
"protection" : "public",
"line" : 877}
,
{
"name" : "REnotdigit",
"kind" : "enum member",
"protection" : "public",
"line" : 878}
,
{
"name" : "REspace",
"kind" : "enum member",
"protection" : "public",
"line" : 879}
,
{
"name" : "REnotspace",
"kind" : "enum member",
"protection" : "public",
"line" : 880}
,
{
"name" : "REword",
"kind" : "enum member",
"protection" : "public",
"line" : 881}
,
{
"name" : "REnotword",
"kind" : "enum member",
"protection" : "public",
"line" : 882}
,
{
"name" : "REbackref",
"kind" : "enum member",
"protection" : "public",
"line" : 883}
,
{
"name" : "isword",
"kind" : "function",
"protection" : "private",
"type" : "int(dchar c)",
"line" : 887}
,
{
"name" : "inf",
"kind" : "variable",
"protection" : "private",
"type" : "uint",
"line" : 889}
,
{
"name" : "compile",
"kind" : "function",
"protection" : "public",
"type" : "void(string pattern, string attributes)",
"line" : 895}
,
{
"name" : "split",
"kind" : "function",
"protection" : "public",
"type" : "string[](string s)",
"comment" : "\n Split s[] into an array of strings, using the regular\n expression as the separator.\n Returns:\n  array of slices into s[]\n \n",
"line" : 958}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "long(string string)",
"comment" : "\n Search string[] for match with regular expression.\n Returns:\n  index of match if successful, -1 if not found\n \n",
"line" : 1056}
,
{
"name" : "match",
"kind" : "function",
"protection" : "public",
"type" : "string[](string s)",
"comment" : "\n Search s[] for match.\n Returns:\n  If global attribute, return same value as exec(s).\n  If not global attribute, return array of all matches.\n \n",
"line" : 1085}
,
{
"name" : "replace",
"kind" : "function",
"protection" : "public",
"type" : "string(string s, string format)",
"comment" : "\n Find regular expression matches in s[]. Replace those matches\n with a new string composed of format[] merged with the result of the\n matches.\n If global, replace all matches. Otherwise, replace first match.\n Returns: the new string\n \n",
"line" : 1142}
,
{
"name" : "exec",
"kind" : "function",
"protection" : "public",
"type" : "string[](string s)",
"comment" : "\n Search string[] for match.\n Returns:\n  array of slices into string[] representing matches\n \n",
"line" : 1222}
,
{
"name" : "exec",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Pick up where last exec(string) or exec() left off,\n searching string[] for next match.\n Returns:\n  array of slices into string[] representing matches\n \n",
"line" : 1238}
,
{
"name" : "test",
"kind" : "function",
"protection" : "public",
"type" : "bool(string s)",
"comment" : "\n Search s[] for match.\n Returns: 0 for no match, !=0 for match\n Example:\n---\nimport std.stdio;\nimport std.regexp;\nimport std.string;\n\nint grep(int delegate(char[]) pred, char[][] list)\n{\n  int count;\n  foreach (s; list)\n  {  if (pred(s))\n       ++count;\n  }\n  return count;\n}\n\nvoid main()\n{\n  auto x = grep(&RegExp(\"[Ff]oo\").test,\n                std.string.split(\"mary had a foo lamb\"));\n  writefln(x);\n}\n---\n which prints: 1\n",
"line" : 1284}
,
{
"name" : "test",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Pick up where last test(string) or test() left off, and search again.\n Returns: 0 for no match, !=0 for match\n \n",
"line" : 1294}
,
{
"name" : "test",
"kind" : "function",
"protection" : "public",
"type" : "int(string s, ulong startindex)",
"comment" : "\n Test s[] starting at startindex against regular expression.\n Returns: 0 for no match, !=0 for match\n \n",
"line" : 1304}
,
{
"name" : "opEquals",
"kind" : "alias",
"protection" : "private",
"comment" : "\n       Returns whether string $(D_PARAM s) matches $(D_PARAM this).\n    \n",
"line" : 1379}
,
{
"name" : "chr",
"kind" : "function",
"protection" : "private",
"type" : "int(ref ulong si, char c)",
"line" : 1391}
,
{
"name" : "printProgram",
"kind" : "function",
"protection" : "private",
"type" : "void(const(ubyte)[] prog)",
"line" : 1402}
,
{
"name" : "trymatch",
"kind" : "function",
"protection" : "private",
"type" : "int(ulong pc, ulong pcend)",
"comment" : "\n Match input against a section of the program[].\n Returns:\n  1 if successful match\n  0 no match\n \n",
"line" : 1611}
,
{
"name" : "parseRegexp",
"kind" : "function",
"protection" : "private",
"type" : "int()",
"line" : 2141}
,
{
"name" : "parsePiece",
"kind" : "function",
"protection" : "private",
"type" : "int()",
"line" : 2187}
,
{
"name" : "parseAtom",
"kind" : "function",
"protection" : "private",
"type" : "int()",
"line" : 2299}
,
{
"name" : "Range",
"kind" : "class",
"protection" : "private",
"line" : 2494,
"base" : "Object",
"members" : [
{
"name" : "maxc",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 2495}
,
{
"name" : "maxb",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 2496}
,
{
"name" : "buf",
"kind" : "variable",
"protection" : "public",
"type" : "std.outbuffer.OutBuffer",
"line" : 2497}
,
{
"name" : "base",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte*",
"line" : 2498}
,
{
"name" : "bits",
"kind" : "variable",
"protection" : "public",
"type" : "BitArray",
"line" : 2499}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Range(OutBuffer buf)",
"line" : 2501}
,
{
"name" : "setbitmax",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong u)",
"line" : 2508}
,
{
"name" : "setbit2",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong u)",
"line" : 2528}
,
{
"name" : "this",
"kind" : "variable",
"protection" : "public",
"type" : "std.regexp.RegExp",
"line" : 2494}
]
}
,
{
"name" : "parseRange",
"kind" : "function",
"protection" : "private",
"type" : "int()",
"line" : 2537}
,
{
"name" : "error",
"kind" : "function",
"protection" : "private",
"type" : "void(string msg)",
"line" : 2732}
,
{
"name" : "escape",
"kind" : "function",
"protection" : "private",
"type" : "int()",
"line" : 2742}
,
{
"name" : "optimize",
"kind" : "function",
"protection" : "private",
"type" : "void()",
"line" : 2865}
,
{
"name" : "starrchars",
"kind" : "function",
"protection" : "private",
"type" : "int(Range r, const(ubyte)[] prog)",
"comment" : "\n",
"line" : 2939}
,
{
"name" : "replace",
"kind" : "function",
"protection" : "public",
"type" : "string(string format)",
"comment" : "\n After a match is found with test(), this function\n will take the match results and, using the format\n string, generate and return a new string.\n \n",
"line" : 3123}
,
{
"name" : "replace3",
"kind" : "function",
"protection" : "public",
"type" : "string(string format, string input, regmatch_t[] pmatch)",
"line" : 3130}
,
{
"name" : "replaceOld",
"kind" : "function",
"protection" : "public",
"type" : "string(string format)",
"comment" : "\n Like replace(char[] format), but uses old style formatting:\n        <table border=1 cellspacing=0 cellpadding=5>\n        <th>Format\n        <th>Description\n        <tr>\n        <td><b>&<\/b>\n        <td>replace with the match\n        <\/tr>\n        <tr>\n        <td><b>\\<\/b><i>n<\/i>\n        <td>replace with the <i>n<\/i>th parenthesized match, <i>n<\/i> is 1..9\n        <\/tr>\n        <tr>\n        <td><b>\\<\/b><i>c<\/i>\n        <td>replace with char <i>c<\/i>.\n        <\/tr>\n        <\/table>\n",
"line" : 3242}
]
}
,
{
"name" : "Pattern(Char)",
"kind" : "struct",
"protection" : "public",
"line" : 3317,
"members" : [
{
"name" : "Pattern",
"kind" : "struct",
"protection" : "public",
"line" : 3317,
"members" : [
{
"name" : "pattern",
"kind" : "variable",
"type" : "immutable(Char)[]",
"line" : 3318}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(immutable(Char)[] pattern)",
"line" : 3320}
]
}
]
}
,
{
"name" : "pattern(Char)",
"kind" : "template",
"protection" : "public",
"line" : 3326,
"members" : [
{
"name" : "pattern",
"kind" : "function",
"type" : "Pattern!(Char)(immutable(Char)[] pat)",
"line" : 3326}
]
}
,
{
"name" : "Splitter(Range)",
"kind" : "struct",
"protection" : "public",
"line" : 3332,
"members" : [
{
"name" : "Splitter",
"kind" : "struct",
"protection" : "public",
"line" : 3332,
"members" : [
{
"name" : "_input",
"kind" : "variable",
"type" : "Range",
"line" : 3333}
,
{
"name" : "_chunkLength",
"kind" : "variable",
"type" : "size_t",
"line" : 3334}
,
{
"name" : "_rx",
"kind" : "variable",
"type" : "RegExp",
"line" : 3335}
,
{
"name" : "search",
"kind" : "function",
"type" : "Range()",
"line" : 3337}
,
{
"name" : "advance",
"kind" : "function",
"type" : "void()",
"line" : 3344}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Range input, Pattern!(char) separator)",
"line" : 3352}
,
{
"name" : "opSlice",
"kind" : "function",
"type" : "ref ()",
"line" : 3360}
,
{
"name" : "front",
"kind" : "function",
"type" : "Range()",
"line" : 3364}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"line" : 3369}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"line" : 3374}
]
}
]
}
,
{
"name" : "splitter(Range)",
"kind" : "template",
"protection" : "public",
"line" : 3387,
"members" : [
{
"name" : "splitter",
"kind" : "function",
"type" : "Splitter!(Range)(Range r, Pattern!(char) pat)",
"line" : 3387}
]
}
]
}
,
{
"name" : "std.signals",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/signals.d",
"comment" : "\n Signals and Slots are an implementation of the Observer Pattern.\n Essentially, when a Signal is emitted, a list of connected Observers\n (called slots) are called.\n\n There have been several D implementations of Signals and Slots.\n This version makes use of several new features in D, which make\n using it simpler and less error prone. In particular, it is no\n longer necessary to instrument the slots.\n\n References:\n      $(LUCKY A Deeper Look at Signals and Slots)$(BR)\n      $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Observer_pattern, Observer pattern)$(BR)\n      $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Signals_and_slots, Wikipedia)$(BR)\n      $(LINK2 http:\/\/boost.org\/doc\/html\/$(SIGNALS).html, Boost Signals)$(BR)\n      $(LINK2 http:\/\/doc.trolltech.com\/4.1\/signalsandslots.html, Qt)$(BR)\n\n      There has been a great deal of discussion in the D newsgroups\n      over this, and several implementations:\n\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/announce\/signal_slots_library_4825.html, signal slots library)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/Signals_and_Slots_in_D_42387.html, Signals and Slots in D)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/Dynamic_binding_--_Qt_s_Signals_and_Slots_vs_Objective-C_42260.html, Dynamic binding -- Qt's Signals and Slots vs Objective-C)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/Dissecting_the_SS_42377.html, Dissecting the SS)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/dwt\/about_harmonia_454.html, about harmonia)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/announce\/1502.html, Another event handling module)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/41825.html, Suggestion: signal\/slot mechanism)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/13251.html, Signals and slots?)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/10714.html, Signals and slots ready for evaluation)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/digitalmars\/D\/1393.html, Signals &amp; Slots for Walter)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/28456.html, Signal\/Slot mechanism?)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/19470.html, Modern Features?)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/16592.html, Delegates vs interfaces)$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/16583.html, The importance of component programming (properties$(COMMA) signals and slots$(COMMA) etc))$(BR)\n      $(LINK2 http:\/\/www.digitalmars.com\/d\/archives\/16368.html, signals and slots)$(BR)\n\n Bugs:\n      Slots can only be delegates formed from class objects or\n      interfaces to class objects. If a delegate to something else\n      is passed to connect(), such as a struct member function,\n      a nested function or a COM interface, undefined behavior\n      will result.\n\n      Not safe for multiple threads operating on the same signals\n      or slots.\n Macros:\n      WIKI = Phobos\/StdSignals\n      SIGNALS=signals\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_signals.d)\n \n",
"members" : [
{
"name" : "_d_toObject",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) Object(void* p)",
"line" : 71}
,
{
"name" : "DisposeEvt",
"kind" : "alias",
"protection" : "public",
"type" : "void delegate(Object)",
"line" : 74}
,
{
"name" : "rt_attachDisposeEvent",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(Object obj, void delegate(Object) evt)",
"line" : 75}
,
{
"name" : "rt_detachDisposeEvent",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(Object obj, void delegate(Object) evt)",
"line" : 76}
,
{
"name" : "Signal(T1...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Mixin to create a signal within a class object.\n\n Different signals can be added to a class by naming the mixins.\n\n Example:\n---\nimport std.signals;\nimport std.stdio;\n\nclass Observer\n{   \/\/ our slot\n    void watch(string msg, int i)\n    {\n        writefln(\"Observed msg '%s' and value %s\", msg, i);\n    }\n}\n\nclass Foo\n{\n    int value() { return _value; }\n\n    int value(int v)\n    {\n        if (v != _value)\n        {   _value = v;\n            \/\/ call all the connected slots with the two parameters\n            emit(\"setting new value\", v);\n        }\n        return v;\n    }\n\n    \/\/ Mix in all the code we need to make Foo into a signal\n    mixin Signal!(string, int);\n\n  private :\n    int _value;\n}\n\nvoid main()\n{\n    Foo a = new Foo;\n    Observer o = new Observer;\n\n    a.value = 3;                \/\/ should not call o.watch()\n    a.connect(&o.watch);        \/\/ o.watch is the slot\n    a.value = 4;                \/\/ should call o.watch()\n    a.disconnect(&o.watch);     \/\/ o.watch is no longer a slot\n    a.value = 5;                \/\/ so should not call o.watch()\n    a.connect(&o.watch);        \/\/ connect again\n    a.value = 6;                \/\/ should call o.watch()\n    destroy(o);                 \/\/ destroying o should automatically disconnect it\n    a.value = 7;                \/\/ should not call o.watch()\n}\n---\n which should print:\n <pre>\n Observed msg 'setting new value' and value 4\n Observed msg 'setting new value' and value 6\n <\/pre>\n\n \n",
"line" : 142,
"members" : [
{
"name" : "slot_t",
"kind" : "alias",
"type" : "void delegate(T1)",
"comment" : "\n A slot is implemented as a delegate.\n The slot_t is the type of the delegate.\n The delegate must be to an instance of a class or an interface\n to a class instance.\n Delegates to struct instances or nested functions must not be\n used as slots.\n     \n",
"line" : 154}
,
{
"name" : "emit",
"kind" : "function",
"type" : "void(T1 i)",
"comment" : "\n Call each of the connected slots, passing the argument(s) i to them.\n     \n",
"line" : 159}
,
{
"name" : "connect",
"kind" : "function",
"type" : "void(slot_t slot)",
"comment" : "\n Add a slot to the list of slots to be called when emit() is called.\n     \n",
"line" : 170}
,
{
"name" : "disconnect",
"kind" : "function",
"type" : "void(slot_t slot)",
"comment" : "\n Remove a slot from the list of slots to be called when emit() is called.\n     \n",
"line" : 207}
,
{
"name" : "unhook",
"kind" : "function",
"type" : "void(Object o)",
"line" : 230}
,
{
"name" : "slots",
"kind" : "variable",
"type" : "slot_t[]",
"line" : 270}
,
{
"name" : "slots_idx",
"kind" : "variable",
"type" : "size_t",
"line" : 271}
]
}
,
{
"name" : "linkin",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 276}
]
}
,
{
"name" : "std.socket",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/socket.d",
"comment" : "\n Example: See $(SAMPLESRC listener.d) and $(SAMPLESRC htmlget.d)\n License: <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors: Christopher E. Miller, $(WEB klickverbot.at, David Nadlinger),\n      $(WEB thecybershadow.net, Vladimir Panteleev)\n Source:  $(PHOBOSSRC std\/_socket.d)\n Macros:\n      WIKI=Phobos\/StdSocket\n \n",
"members" : [
{
"name" : "_ctimeval",
"kind" : "alias",
"protection" : "private",
"type" : "timeval",
"line" : 105}
,
{
"name" : "_clinger",
"kind" : "alias",
"protection" : "private",
"type" : "linger",
"line" : 106}
,
{
"name" : "socket_t",
"kind" : "enum",
"protection" : "public",
"line" : 110,
"base" : "int",
"members" : [
{
"name" : "init",
"kind" : "enum member",
"protection" : "public",
"line" : 110}
]
}
,
{
"name" : "_SOCKET_ERROR",
"kind" : "variable",
"protection" : "private",
"type" : "const(int)",
"line" : 111}
,
{
"name" : "_lasterr",
"kind" : "function",
"protection" : "private",
"type" : "int()",
"line" : 114}
,
{
"name" : "SocketException",
"kind" : "class",
"protection" : "public",
"comment" : " Base exception thrown by $(D std.socket).\n",
"line" : 145,
"base" : "Exception",
"members" : [
{
"name" : "errorCode",
"kind" : "function",
"protection" : "public",
"type" : "const @property int()",
"comment" : "\n $(RED Deprecated. It will be removed in January 2013.\n       Please use $(LREF SocketOSException) instead.)\n\n Provided for compatibility with older code using $(D SocketException).\n     \n",
"line" : 153}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketException(string msg)",
"line" : 162}
]
}
,
{
"name" : "formatSocketError",
"kind" : "function",
"protection" : "private",
"type" : "string(int err)",
"line" : 168}
,
{
"name" : "lastSocketError",
"kind" : "function",
"protection" : "public",
"type" : "@property string()",
"comment" : " Retrieve the error message for the most recently encountered network error.\n",
"line" : 215}
,
{
"name" : "SocketOSException",
"kind" : "class",
"protection" : "public",
"comment" : " Socket exceptions representing network errors reported by the operating\n system.\n",
"line" : 222,
"base" : "SocketException",
"members" : [
{
"name" : "errorCode",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"comment" : " Platform-specific error code.\n",
"line" : 224}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketOSException(string msg, int err = _lasterr(), string function(int) errorFormatter = & formatSocketError)",
"line" : 226}
]
}
,
{
"name" : "SocketParameterException",
"kind" : "class",
"protection" : "public",
"comment" : " Socket exceptions representing invalid parameters specified by user code.\n",
"line" : 239,
"base" : "SocketException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketParameterException(string msg)",
"line" : 241}
]
}
,
{
"name" : "SocketFeatureException",
"kind" : "class",
"protection" : "public",
"comment" : " Socket exceptions representing attempts to use network capabilities not\n available on the current system.\n",
"line" : 249,
"base" : "SocketException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketFeatureException(string msg)",
"line" : 251}
]
}
,
{
"name" : "wouldHaveBlocked",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"comment" : " Return $(D true) if the last socket operation failed because the socket\n was in non-blocking mode and the operation would have blocked.\n",
"line" : 260}
,
{
"name" : "getnameinfoPointer",
"kind" : "variable",
"protection" : "private",
"type" : "extern (C) int function(const(sockaddr)*, uint, char*, uint, char*, uint, int)",
"line" : 270}
,
{
"name" : "getaddrinfoPointer",
"kind" : "variable",
"protection" : "private",
"type" : "extern (C) int function(const(char)*, const(char)*, const(addrinfo)*, addrinfo**)",
"line" : 271}
,
{
"name" : "freeaddrinfoPointer",
"kind" : "variable",
"protection" : "private",
"type" : "extern (C) void function(addrinfo*)",
"line" : 272}
,
{
"name" : "AddressFamily",
"kind" : "enum",
"protection" : "public",
"comment" : "\n The communication domain used to resolve an address.\n \n",
"line" : 320,
"base" : "int",
"members" : [
{
"name" : "UNSPEC",
"kind" : "enum member",
"protection" : "public",
"comment" : " Unspecified address family\n",
"line" : 322}
,
{
"name" : "UNIX",
"kind" : "enum member",
"protection" : "public",
"comment" : " Local communication\n",
"line" : 323}
,
{
"name" : "INET",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Protocol version 4\n",
"line" : 324}
,
{
"name" : "IPX",
"kind" : "enum member",
"protection" : "public",
"comment" : " Novell IPX\n",
"line" : 325}
,
{
"name" : "APPLETALK",
"kind" : "enum member",
"protection" : "public",
"comment" : " AppleTalk\n",
"line" : 326}
,
{
"name" : "INET6",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Protocol version 6\n",
"line" : 327}
]
}
,
{
"name" : "SocketType",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Communication semantics\n \n",
"line" : 334,
"base" : "int",
"members" : [
{
"name" : "STREAM",
"kind" : "enum member",
"protection" : "public",
"comment" : " Sequenced, reliable, two-way communication-based byte streams\n",
"line" : 336}
,
{
"name" : "DGRAM",
"kind" : "enum member",
"protection" : "public",
"comment" : " Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order\n",
"line" : 337}
,
{
"name" : "RAW",
"kind" : "enum member",
"protection" : "public",
"comment" : " Raw protocol access\n",
"line" : 338}
,
{
"name" : "RDM",
"kind" : "enum member",
"protection" : "public",
"comment" : " Reliably-delivered message datagrams\n",
"line" : 339}
,
{
"name" : "SEQPACKET",
"kind" : "enum member",
"protection" : "public",
"comment" : " Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length\n",
"line" : 340}
]
}
,
{
"name" : "ProtocolType",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Protocol\n \n",
"line" : 347,
"base" : "int",
"members" : [
{
"name" : "IP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Protocol version 4\n",
"line" : 349}
,
{
"name" : "ICMP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Control Message Protocol\n",
"line" : 350}
,
{
"name" : "IGMP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Group Management Protocol\n",
"line" : 351}
,
{
"name" : "GGP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Gateway to Gateway Protocol\n",
"line" : 352}
,
{
"name" : "TCP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Transmission Control Protocol\n",
"line" : 353}
,
{
"name" : "PUP",
"kind" : "enum member",
"protection" : "public",
"comment" : " PARC Universal Packet Protocol\n",
"line" : 354}
,
{
"name" : "UDP",
"kind" : "enum member",
"protection" : "public",
"comment" : " User Datagram Protocol\n",
"line" : 355}
,
{
"name" : "IDP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Xerox NS protocol\n",
"line" : 356}
,
{
"name" : "RAW",
"kind" : "enum member",
"protection" : "public",
"comment" : " Raw IP packets\n",
"line" : 357}
,
{
"name" : "IPV6",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Protocol version 6\n",
"line" : 358}
]
}
,
{
"name" : "Protocol",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D Protocol) is a class for retrieving protocol information.\n\n Example:\n ---\n auto proto = new Protocol;\n writeln(\"About protocol TCP:\");\n if (proto.getProtocolByType(ProtocolType.TCP))\n {\n     writefln(\"  Name: %s\", proto.name);\n     foreach(string s; proto.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writeln(\"  No information found\");\n ---\n \n",
"line" : 380,
"base" : "Object",
"members" : [
{
"name" : "type",
"kind" : "variable",
"protection" : "public",
"type" : "ProtocolType",
"comment" : " These members are populated when one of the following functions are called successfully:\n",
"line" : 382}
,
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " ditto\n",
"line" : 383}
,
{
"name" : "aliases",
"kind" : "variable",
"protection" : "public",
"type" : "string[]",
"comment" : " ditto\n",
"line" : 384}
,
{
"name" : "populate",
"kind" : "function",
"protection" : "public",
"type" : "void(protoent* proto)",
"line" : 387}
,
{
"name" : "getProtocolByName",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(char[]) name)",
"comment" : " Returns: false on failure \n",
"line" : 415}
,
{
"name" : "getProtocolByType",
"kind" : "function",
"protection" : "public",
"type" : "bool(ProtocolType type)",
"comment" : " Returns: false on failure \n",
"line" : 428}
]
}
,
{
"name" : "Service",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D Service) is a class for retrieving service information.\n\n Example:\n ---\n auto serv = new Service;\n writeln(\"About service epmap:\");\n if (serv.getServiceByName(\"epmap\", \"tcp\"))\n {\n     writefln(\"  Service: %s\", serv.name);\n     writefln(\"  Port: %d\", serv.port);\n     writefln(\"  Protocol: %s\", serv.protocolName);\n     foreach (string s; serv.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writefln(\"  No service for epmap.\");\n ---\n \n",
"line" : 477,
"base" : "Object",
"members" : [
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " These members are populated when one of the following functions are called successfully:\n",
"line" : 479}
,
{
"name" : "aliases",
"kind" : "variable",
"protection" : "public",
"type" : "string[]",
"comment" : " ditto\n",
"line" : 480}
,
{
"name" : "port",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " ditto\n",
"line" : 481}
,
{
"name" : "protocolName",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " ditto\n",
"line" : 482}
,
{
"name" : "populate",
"kind" : "function",
"protection" : "public",
"type" : "void(servent* serv)",
"line" : 485}
,
{
"name" : "getServiceByName",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(char[]) name, const(char[]) protocolName = null)",
"comment" : "\n If a protocol name is omitted, any protocol will be matched.\n Returns: false on failure.\n     \n",
"line" : 517}
,
{
"name" : "getServiceByPort",
"kind" : "function",
"protection" : "public",
"type" : "bool(ushort port, const(char[]) protocolName = null)",
"comment" : " ditto\n",
"line" : 529}
]
}
,
{
"name" : "HostException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class for exceptions thrown from an $(D InternetHost).\n \n",
"line" : 571,
"base" : "SocketOSException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HostException(string msg, int err = _lasterr())",
"line" : 573}
]
}
,
{
"name" : "InternetHost",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D InternetHost) is a class for resolving IPv4 addresses.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n\n Example:\n ---\n auto ih = new InternetHost;\n\n \/\/ Forward lookup\n writeln(\"About www.digitalmars.com:\");\n if (ih.getHostByName(\"www.digitalmars.com\"))\n {\n     writefln(\"  Name: %s\", ih.name);\n     auto ip = InternetAddress.addrToString(ih.addrList[0]);\n     writefln(\"  IP address: %s\", ip);\n     foreach (string s; ih.aliases)\n          writefln(\"  Alias: %s\", s);\n     writeln(\"---\");\n\n     \/\/ Reverse lookup\n     writefln(\"About IP %s:\", ip);\n     if (ih.getHostByAddr(ih.addrList[0]))\n     {\n         writefln(\"  Name: %s\", ih.name);\n         foreach (string s; ih.aliases)\n              writefln(\"  Alias: %s\", s);\n     }\n     else\n         writeln(\"  Reverse lookup failed\");\n }\n else\n     writeln(\"  Can't resolve www.digitalmars.com\");\n ---\n \n",
"line" : 616,
"base" : "Object",
"members" : [
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " These members are populated when one of the following functions are called successfully:\n",
"line" : 618}
,
{
"name" : "aliases",
"kind" : "variable",
"protection" : "public",
"type" : "string[]",
"comment" : " ditto\n",
"line" : 619}
,
{
"name" : "addrList",
"kind" : "variable",
"protection" : "public",
"type" : "uint[]",
"comment" : " ditto\n",
"line" : 620}
,
{
"name" : "validHostent",
"kind" : "function",
"protection" : "public",
"type" : "void(hostent* he)",
"line" : 623}
,
{
"name" : "populate",
"kind" : "function",
"protection" : "public",
"type" : "void(hostent* he)",
"line" : 630}
,
{
"name" : "getHostNoSync(string opMixin,T)",
"kind" : "template",
"protection" : "public",
"line" : 679,
"members" : [
{
"name" : "getHostNoSync",
"kind" : "function",
"type" : "bool(T param)",
"line" : 679}
]
}
,
{
"name" : "getHost(string opMixin,T)",
"kind" : "template",
"protection" : "public",
"line" : 695,
"members" : [
{
"name" : "getHost",
"kind" : "function",
"type" : "bool(T param)",
"line" : 695}
]
}
,
{
"name" : "getHostByName",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(char[]) name)",
"comment" : "\n Resolve host name.\n Returns: false if unable to resolve.\n     \n",
"line" : 706}
,
{
"name" : "getHostByAddr",
"kind" : "function",
"protection" : "public",
"type" : "bool(uint addr)",
"comment" : "\n Resolve IPv4 address number.\n\n Params:\n   addr = The IPv4 address to resolve, in host byte order.\n Returns:\n   false if unable to resolve.\n     \n",
"line" : 743}
,
{
"name" : "getHostByAddr",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(char[]) addr)",
"comment" : "\n Same as previous, but addr is an IPv4 address string in the\n dotted-decimal form $(I a.b.c.d).\n Returns: false if unable to resolve.\n     \n",
"line" : 756}
]
}
,
{
"name" : "AddressInfo",
"kind" : "struct",
"protection" : "public",
"comment" : " Holds information about a socket _address retrieved by $(D getAddressInfo).\n",
"line" : 805,
"members" : [
{
"name" : "family",
"kind" : "variable",
"protection" : "public",
"type" : "AddressFamily",
"comment" : " Address _family\n",
"line" : 806}
,
{
"name" : "type",
"kind" : "variable",
"protection" : "public",
"type" : "SocketType",
"comment" : " Socket _type\n",
"line" : 807}
,
{
"name" : "protocol",
"kind" : "variable",
"protection" : "public",
"type" : "ProtocolType",
"comment" : " Protocol\n",
"line" : 808}
,
{
"name" : "address",
"kind" : "variable",
"protection" : "public",
"type" : "std.socket.Address",
"comment" : " Socket _address\n",
"line" : 809}
,
{
"name" : "canonicalName",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Canonical name, when $(D AddressInfoFlags.CANONNAME) is used.\n",
"line" : 810}
]
}
,
{
"name" : "AddressInfoFlags",
"kind" : "enum",
"protection" : "public",
"comment" : " Specifies option flags for $(D getAddressInfo).\n",
"line" : 815,
"base" : "int",
"members" : [
{
"name" : "PASSIVE",
"kind" : "enum member",
"protection" : "public",
"comment" : " The resulting addresses will be used in a call to $(D Socket.bind).\n",
"line" : 818}
,
{
"name" : "CANONNAME",
"kind" : "enum member",
"protection" : "public",
"comment" : " The canonical name is returned in $(D canonicalName) member in the first $(D AddressInfo).\n",
"line" : 821}
,
{
"name" : "NUMERICHOST",
"kind" : "enum member",
"protection" : "public",
"comment" : " The $(D node) parameter passed to $(D getAddressInfo) must be a numeric string.\n This will suppress any potentially lengthy network host address lookups.\n",
"line" : 825}
]
}
,
{
"name" : "formatGaiError",
"kind" : "function",
"protection" : "private",
"type" : "string(int err)",
"comment" : " On POSIX, getaddrinfo uses its own error codes, and thus has its own\n formatting function.\n",
"line" : 831}
,
{
"name" : "getAddressInfo(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Provides _protocol-independent translation from host names to socket\n addresses. If advanced functionality is not required, consider using\n $(D getAddress) for compatibility with older systems.\n\n Returns: Array with one $(D AddressInfo) per socket address.\n\n Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)\n if this functionality is not available on the current system.\n\n Params:\n  node     = string containing host name or numeric address\n  options  = optional additional parameters, identified by type:\n             $(UL $(LI $(D string) - service name or port number)\n                  $(LI $(D AddressInfoFlags) - option flags)\n                  $(LI $(D AddressFamily) - address family to filter by)\n                  $(LI $(D SocketType) - socket type to filter by)\n                  $(LI $(D ProtocolType) - protocol to filter by))\n\n Example:\n ---\n \/\/ Roundtrip DNS resolution\n auto results = getAddressInfo(\"www.digitalmars.com\");\n assert(results[0].address.toHostNameString() ==\n     \"digitalmars.com\");\n\n \/\/ Canonical name\n results = getAddressInfo(\"www.digitalmars.com\",\n     AddressInfoFlags.CANONNAME);\n assert(results[0].canonicalName == \"digitalmars.com\");\n\n \/\/ IPv6 resolution\n results = getAddressInfo(\"ipv6.google.com\");\n assert(results[0].family == AddressFamily.INET6);\n\n \/\/ Multihomed resolution\n results = getAddressInfo(\"google.com\");\n assert(results.length > 1);\n\n \/\/ Parsing IPv4\n results = getAddressInfo(\"127.0.0.1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET);\n\n \/\/ Parsing IPv6\n results = getAddressInfo(\"::1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET6);\n ---\n \n",
"line" : 896,
"members" : [
{
"name" : "getAddressInfo",
"kind" : "function",
"type" : "AddressInfo[](in char[] node, T options)",
"comment" : "\n Provides _protocol-independent translation from host names to socket\n addresses. If advanced functionality is not required, consider using\n $(D getAddress) for compatibility with older systems.\n\n Returns: Array with one $(D AddressInfo) per socket address.\n\n Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)\n if this functionality is not available on the current system.\n\n Params:\n  node     = string containing host name or numeric address\n  options  = optional additional parameters, identified by type:\n             $(UL $(LI $(D string) - service name or port number)\n                  $(LI $(D AddressInfoFlags) - option flags)\n                  $(LI $(D AddressFamily) - address family to filter by)\n                  $(LI $(D SocketType) - socket type to filter by)\n                  $(LI $(D ProtocolType) - protocol to filter by))\n\n Example:\n ---\n \/\/ Roundtrip DNS resolution\n auto results = getAddressInfo(\"www.digitalmars.com\");\n assert(results[0].address.toHostNameString() ==\n     \"digitalmars.com\");\n\n \/\/ Canonical name\n results = getAddressInfo(\"www.digitalmars.com\",\n     AddressInfoFlags.CANONNAME);\n assert(results[0].canonicalName == \"digitalmars.com\");\n\n \/\/ IPv6 resolution\n results = getAddressInfo(\"ipv6.google.com\");\n assert(results[0].family == AddressFamily.INET6);\n\n \/\/ Multihomed resolution\n results = getAddressInfo(\"google.com\");\n assert(results.length > 1);\n\n \/\/ Parsing IPv4\n results = getAddressInfo(\"127.0.0.1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET);\n\n \/\/ Parsing IPv6\n results = getAddressInfo(\"::1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET6);\n ---\n \n",
"line" : 896}
]
}
,
{
"name" : "getAddressInfoImpl",
"kind" : "function",
"protection" : "private",
"type" : "AddressInfo[](const(char[]) node, const(char[]) service, addrinfo* hints)",
"line" : 925}
,
{
"name" : "serviceToPort",
"kind" : "function",
"protection" : "private",
"type" : "ushort(const(char[]) service)",
"line" : 991}
,
{
"name" : "getAddress",
"kind" : "function",
"protection" : "public",
"type" : "Address[](const(char[]) hostname, const(char[]) service = null)",
"comment" : "\n Provides _protocol-independent translation from host names to socket\n addresses. Uses $(D getAddressInfo) if the current system supports it,\n and $(D InternetHost) otherwise.\n\n Returns: Array with one $(D Address) instance per socket address.\n\n Throws: $(D SocketOSException) on failure.\n\n Example:\n ---\n writeln(\"Resolving www.digitalmars.com:\");\n try\n {\n     auto addresses = getAddress(\"www.digitalmars.com\");\n     foreach (address; addresses)\n         writefln(\"  IP: %s\", address.toAddrString());\n }\n catch (SocketException e)\n     writefln(\"  Lookup failed: %s\", e.msg);\n ---\n \n",
"line" : 1028}
,
{
"name" : "getAddress",
"kind" : "function",
"protection" : "public",
"type" : "Address[](const(char[]) hostname, ushort port)",
"comment" : " ditto\n",
"line" : 1044}
,
{
"name" : "parseAddress",
"kind" : "function",
"protection" : "public",
"type" : "Address(const(char[]) hostaddr, const(char[]) service = null)",
"comment" : "\n Provides _protocol-independent parsing of network addresses. Does not\n attempt name resolution. Uses $(D getAddressInfo) with\n $(D AddressInfoFlags.NUMERICHOST) if the current system supports it, and\n $(D InternetAddress) otherwise.\n\n Returns: An $(D Address) instance representing specified address.\n\n Throws: $(D SocketException) on failure.\n\n Example:\n ---\n writeln(\"Enter IP address:\");\n string ip = readln().chomp();\n try\n {\n     Address address = parseAddress(ip);\n     writefln(\"Looking up reverse of %s:\",\n         address.toAddrString());\n     try\n     {\n         string reverse = address.toHostNameString());\n         if (reverse)\n             writefln(\"  Reverse name: %s\", reverse);\n         else\n             writeln(\"  Reverse hostname not found.\");\n     }\n     catch (SocketException e)\n         writefln(\"  Lookup error: %s\", e.msg);\n }\n catch (SocketException e)\n {\n     writefln(\"  %s is not a valid IP address: %s\",\n         ip, e.msg);\n }\n ---\n \n",
"line" : 1121}
,
{
"name" : "parseAddress",
"kind" : "function",
"protection" : "public",
"type" : "Address(const(char[]) hostaddr, ushort port)",
"comment" : " ditto\n",
"line" : 1130}
,
{
"name" : "AddressException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class for exceptions thrown from an $(D Address).\n \n",
"line" : 1169,
"base" : "SocketOSException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "AddressException(string msg, int err = _lasterr())",
"line" : 1171}
]
}
,
{
"name" : "Address",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D Address) is an abstract class for representing a socket addresses.\n\n Example:\n ---\n writeln(\"About www.google.com port 80:\");\n try\n {\n     Address[] addresses = getAddress(\"www.google.com\", 80);\n     writefln(\"  %d addresses found.\", addresses.length);\n     foreach (int i, Address a; addresses)\n     {\n         writefln(\"  Address %d:\", i+1);\n         writefln(\"    IP address: %s\", a.toAddrString());\n         writefln(\"    Hostname: %s\", a.toHostNameString());\n         writefln(\"    Port: %s\", a.toPortString());\n         writefln(\"    Service name: %s\",\n             a.toServiceNameString());\n     }\n }\n catch (SocketException e)\n     writefln(\"  Lookup error: %s\", e.msg);\n ---\n \n",
"line" : 1203,
"base" : "Object",
"members" : [
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "sockaddr*()",
"comment" : " Returns pointer to underlying $(D sockaddr) structure.\n",
"line" : 1205}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const const(sockaddr)*()",
"comment" : " ditto\n",
"line" : 1206}
,
{
"name" : "nameLen",
"kind" : "function",
"protection" : "public",
"type" : "const uint()",
"comment" : " Returns actual size of underlying $(D sockaddr) structure.\n",
"line" : 1209}
,
{
"name" : "addressFamily",
"kind" : "function",
"protection" : "public",
"type" : "const @property AddressFamily()",
"comment" : " Family of this address.\n",
"line" : 1212}
,
{
"name" : "toHostString",
"kind" : "function",
"protection" : "private",
"type" : "const string(bool numeric)",
"line" : 1218}
,
{
"name" : "toServiceString",
"kind" : "function",
"protection" : "private",
"type" : "const string(bool numeric)",
"line" : 1258}
,
{
"name" : "toAddrString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Attempts to retrieve the host address as a human-readable string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if address retrieval for this address family is not available on the\n current system.\n     \n",
"line" : 1285}
,
{
"name" : "toHostNameString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D Address), or $(D null) if\n the host name did not resolve.\n\n Throws: $(D AddressException) on error, or $(D SocketFeatureException)\n if host name lookup for this address family is not available on the\n current system.\n     \n",
"line" : 1300}
,
{
"name" : "toPortString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Attempts to retrieve the numeric port number as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if port number retrieval for this address family is not available on the\n current system.\n     \n",
"line" : 1312}
,
{
"name" : "toServiceNameString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Attempts to retrieve the service name as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if service name lookup for this address family is not available on the\n current system.\n     \n",
"line" : 1324}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : " Human readable string representing this address.\n",
"line" : 1330}
]
}
,
{
"name" : "UnknownAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D UnknownAddress) encapsulates an unknown socket address.\n \n",
"line" : 1349,
"base" : "Address",
"members" : [
{
"name" : "sa",
"kind" : "variable",
"protection" : "protected",
"type" : "sockaddr",
"line" : 1352}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "sockaddr*()",
"line" : 1356}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const const(sockaddr)*()",
"line" : 1361}
,
{
"name" : "nameLen",
"kind" : "function",
"protection" : "public",
"type" : "const uint()",
"line" : 1367}
]
}
,
{
"name" : "UnknownAddressReference",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D UnknownAddressReference) encapsulates a reference to an arbitrary\n socket address.\n \n",
"line" : 1379,
"base" : "Address",
"members" : [
{
"name" : "sa",
"kind" : "variable",
"protection" : "protected",
"type" : "sockaddr*",
"line" : 1382}
,
{
"name" : "len",
"kind" : "variable",
"protection" : "protected",
"type" : "uint",
"line" : 1383}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnknownAddressReference(sockaddr* sa, uint len)",
"comment" : " Constructs an $(D Address) with a reference to the specified $(D sockaddr).\n",
"line" : 1387}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnknownAddressReference(const(sockaddr)* sa, uint len)",
"comment" : " Constructs an $(D Address) with a copy of the specified $(D sockaddr).\n",
"line" : 1394}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "sockaddr*()",
"line" : 1400}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const const(sockaddr)*()",
"line" : 1405}
,
{
"name" : "nameLen",
"kind" : "function",
"protection" : "public",
"type" : "const uint()",
"line" : 1411}
]
}
,
{
"name" : "InternetAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D InternetAddress) encapsulates an IPv4 (Internet Protocol version 4)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n \n",
"line" : 1425,
"base" : "Address",
"members" : [
{
"name" : "sin",
"kind" : "variable",
"protection" : "protected",
"type" : "sockaddr_in",
"line" : 1428}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "protected",
"type" : "InternetAddress()",
"line" : 1431}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "sockaddr*()",
"line" : 1437}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const const(sockaddr)*()",
"line" : 1442}
,
{
"name" : "nameLen",
"kind" : "function",
"protection" : "public",
"type" : "const uint()",
"line" : 1448}
,
{
"name" : "ADDR_ANY",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Any IPv4 host address.\n",
"line" : 1454}
,
{
"name" : "ADDR_NONE",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " An invalid IPv4 host address.\n",
"line" : 1455}
,
{
"name" : "PORT_ANY",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Any IPv4 port number.\n",
"line" : 1456}
,
{
"name" : "port",
"kind" : "function",
"protection" : "public",
"type" : "const ushort()",
"comment" : " Returns the IPv4 _port number (in host byte order).\n",
"line" : 1459}
,
{
"name" : "addr",
"kind" : "function",
"protection" : "public",
"type" : "const uint()",
"comment" : " Returns the IPv4 address number (in host byte order).\n",
"line" : 1465}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InternetAddress(const(char[]) addr, ushort port)",
"comment" : "\n Construct a new $(D InternetAddress).\n Params:\n   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,\n          or a host name which will be resolved using an $(D InternetHost)\n          object.\n   port = port number, may be $(D PORT_ANY).\n     \n",
"line" : 1478}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InternetAddress(uint addr, ushort port)",
"comment" : "\n Construct a new $(D InternetAddress).\n Params:\n   addr = (optional) an IPv4 address in host byte order, may be $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n     \n",
"line" : 1501}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InternetAddress(ushort port)",
"comment" : " ditto\n",
"line" : 1509}
,
{
"name" : "toAddrString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : " Human readable string representing the IPv4 address in dotted-decimal form.\n",
"line" : 1517}
,
{
"name" : "toPortString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : " Human readable string representing the IPv4 port.\n",
"line" : 1523}
,
{
"name" : "toHostNameString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D InternetAddress), or\n $(D null) if the host name did not resolve.\n\n Throws: $(D AddressException) on error.\n     \n",
"line" : 1536}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "uint(const(char[]) addr)",
"comment" : "\n Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)\n and return the number.\n Returns: If the string is not a legitimate IPv4 address,\n $(D ADDR_NONE) is returned.\n     \n",
"line" : 1563}
,
{
"name" : "addrToString",
"kind" : "function",
"protection" : "public",
"type" : "string(uint addr)",
"comment" : "\n Convert an IPv4 address number in host byte order to a human readable\n string representing the IPv4 address in dotted-decimal form.\n     \n",
"line" : 1572}
]
}
,
{
"name" : "Internet6Address",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D Internet6Address) encapsulates an IPv6 (Internet Protocol version 6)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n \n",
"line" : 1634,
"base" : "Address",
"members" : [
{
"name" : "sin6",
"kind" : "variable",
"protection" : "protected",
"type" : "sockaddr_in6",
"line" : 1637}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "protected",
"type" : "Internet6Address()",
"line" : 1640}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "sockaddr*()",
"line" : 1646}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const const(sockaddr)*()",
"line" : 1651}
,
{
"name" : "nameLen",
"kind" : "function",
"protection" : "public",
"type" : "const uint()",
"line" : 1657}
,
{
"name" : "ADDR_ANY",
"kind" : "function",
"protection" : "public",
"type" : "@property ref const(ubyte[16LU])()",
"comment" : " Any IPv6 host address.\n",
"line" : 1664}
,
{
"name" : "PORT_ANY",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Any IPv6 port number.\n",
"line" : 1677}
,
{
"name" : "port",
"kind" : "function",
"protection" : "public",
"type" : "const ushort()",
"comment" : " Returns the IPv6 port number.\n",
"line" : 1680}
,
{
"name" : "addr",
"kind" : "function",
"protection" : "public",
"type" : "const ubyte[16LU]()",
"comment" : " Returns the IPv6 address.\n",
"line" : 1686}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Internet6Address(const(char[]) node, const(char[]) service = null)",
"comment" : "\n Construct a new $(D Internet6Address).\n Params:\n   node = an IPv6 host address string in the form described in RFC 2373,\n          or a host name which will be resolved using $(D getAddressInfo).\n   port = (optional) service name or port number.\n     \n",
"line" : 1698}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Internet6Address(const(char[]) node, ushort port)",
"comment" : "\n Construct a new $(D Internet6Address).\n Params:\n   addr = an IPv6 host address string in the form described in RFC 2373,\n          or a host name which will be resolved using $(D getAddressInfo).\n   port = port number, may be $(D PORT_ANY).\n     \n",
"line" : 1712}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Internet6Address(ubyte[16LU] addr, ushort port)",
"comment" : "\n Construct a new $(D Internet6Address).\n Params:\n   addr = (optional) an IPv6 host address in host byte order, or\n                $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n     \n",
"line" : 1727}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Internet6Address(ushort port)",
"comment" : " ditto\n",
"line" : 1735}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "ubyte[16LU](const(char[]) addr)",
"comment" : "\n Parse an IPv6 host address string as described in RFC 2373, and return the\n address.\n Throws: $(D SocketException) on error.\n     \n",
"line" : 1747}
]
}
,
{
"name" : "SocketAcceptException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class for exceptions thrown by $(D Socket.accept).\n \n",
"line" : 1845,
"base" : "SocketOSException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketAcceptException(string msg, int err = _lasterr())",
"line" : 1847}
]
}
,
{
"name" : "SocketShutdown",
"kind" : "enum",
"protection" : "public",
"comment" : " How a socket is shutdown:\n",
"line" : 1854,
"base" : "int",
"members" : [
{
"name" : "RECEIVE",
"kind" : "enum member",
"protection" : "public",
"comment" : " socket receives are disallowed\n",
"line" : 1856}
,
{
"name" : "SEND",
"kind" : "enum member",
"protection" : "public",
"comment" : " socket sends are disallowed\n",
"line" : 1857}
,
{
"name" : "BOTH",
"kind" : "enum member",
"protection" : "public",
"comment" : " both RECEIVE and SEND\n",
"line" : 1858}
]
}
,
{
"name" : "SocketFlags",
"kind" : "enum",
"protection" : "public",
"comment" : " Flags may be OR'ed together:\n",
"line" : 1863,
"base" : "int",
"members" : [
{
"name" : "NONE",
"kind" : "enum member",
"protection" : "public",
"comment" : " no flags specified\n",
"line" : 1865}
,
{
"name" : "OOB",
"kind" : "enum member",
"protection" : "public",
"comment" : " out-of-band stream data\n",
"line" : 1867}
,
{
"name" : "PEEK",
"kind" : "enum member",
"protection" : "public",
"comment" : " peek at incoming data without removing it from the queue, only for receiving\n",
"line" : 1868}
,
{
"name" : "DONTROUTE",
"kind" : "enum member",
"protection" : "public",
"comment" : " data should not be subject to routing; this flag may be ignored. Only for sending\n",
"line" : 1869}
]
}
,
{
"name" : "FieldProxy(string target,string field)",
"kind" : "template",
"protection" : "public",
"line" : 1873,
"members" : [
]
}
,
{
"name" : "TimeVal",
"kind" : "struct",
"protection" : "public",
"comment" : " Duration timeout value.\n",
"line" : 1892,
"members" : [
{
"name" : "ctimeval",
"kind" : "variable",
"protection" : "public",
"type" : "timeval",
"line" : 1893}
,
{
"name" : "tv_sec_t",
"kind" : "alias",
"protection" : "public",
"type" : "long",
"line" : 1894}
,
{
"name" : "tv_usec_t",
"kind" : "alias",
"protection" : "public",
"type" : "long",
"line" : 1895}
]
}
,
{
"name" : "timeval",
"kind" : "alias",
"protection" : "public",
"type" : "TimeVal",
"comment" : "\n    $(RED Deprecated. It will be removed in January 2013.\n          Please use $(LREF TimeVal) instead.)\n  \n",
"line" : 1914}
,
{
"name" : "SocketSet",
"kind" : "class",
"protection" : "public",
"comment" : "\n A collection of sockets for use with $(D Socket.select).\n\n $(D SocketSet) allows specifying the capacity of the underlying\n $(D fd_set), however users should be aware that the exact meaning of this\n value varies depending on the current platform:\n $(UL $(LI On POSIX, $(D fd_set) is a bit array of file descriptors. The\n $(D SocketSet) capacity specifies the highest file descriptor which can be\n stored in the set.)\n $(LI on Windows, $(D fd_set) is an array of socket handles. Capacity\n indicates the actual number of sockets that can be stored in the set.))\n \n",
"line" : 1930,
"base" : "Object",
"members" : [
{
"name" : "fdsetMax",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 1942}
,
{
"name" : "setData",
"kind" : "variable",
"protection" : "private",
"type" : "fd_set",
"line" : 1944}
,
{
"name" : "set",
"kind" : "function",
"protection" : "private",
"type" : "@property fd_set*()",
"line" : 1945}
,
{
"name" : "set",
"kind" : "function",
"protection" : "private",
"type" : "const @property const(fd_set)*()",
"line" : 1946}
,
{
"name" : "maxfd",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 1947}
,
{
"name" : "count",
"kind" : "variable",
"protection" : "private",
"type" : "uint",
"line" : 1948}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketSet(uint max)",
"comment" : "\n Set the capacity of this $(D SocketSet). The exact meaning of the\n $(D max) parameter varies from platform to platform.\n Throws: $(D SocketParameterException) if $(D max) exceeds this\n platform's maximum socket set size.\n     \n",
"line" : 1960}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketSet()",
"comment" : " Uses the default capacity for the system.\n",
"line" : 1978}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " Reset the $(D SocketSet) so that there are 0 $(D Socket)s in the collection.\n",
"line" : 1984}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "void(socket_t s)",
"line" : 1996}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "void(Socket s)",
"comment" : " Add a $(D Socket) to the collection.\n Throws: $(D SocketParameterException) if the capacity of this\n $(D SocketSet) has been exceeded.\n",
"line" : 2023}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(socket_t s)",
"line" : 2028}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(Socket s)",
"comment" : " Remove this $(D Socket) from the collection.\n",
"line" : 2046}
,
{
"name" : "isSet",
"kind" : "function",
"protection" : "public",
"type" : "const int(socket_t s)",
"line" : 2051}
,
{
"name" : "isSet",
"kind" : "function",
"protection" : "public",
"type" : "const int(Socket s)",
"comment" : " Returns nonzero if this $(D Socket) is in the collection.\n",
"line" : 2064}
,
{
"name" : "max",
"kind" : "function",
"protection" : "public",
"type" : "const @property uint()",
"comment" : " Return the capacity of this $(D SocketSet). The exact meaning of the\n return value varies from platform to platform.\n",
"line" : 2072}
,
{
"name" : "toFd_set",
"kind" : "function",
"protection" : "public",
"type" : "fd_set*()",
"line" : 2085}
,
{
"name" : "selectn",
"kind" : "function",
"protection" : "public",
"type" : "const int()",
"line" : 2091}
]
}
,
{
"name" : "SocketOptionLevel",
"kind" : "enum",
"protection" : "public",
"comment" : " The level at which a socket option is defined:\n",
"line" : 2106,
"base" : "int",
"members" : [
{
"name" : "SOCKET",
"kind" : "enum member",
"protection" : "public",
"comment" : " Socket level\n",
"line" : 2108}
,
{
"name" : "IP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Protocol version 4 level\n",
"line" : 2109}
,
{
"name" : "ICMP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Control Message Protocol level\n",
"line" : 2110}
,
{
"name" : "IGMP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Group Management Protocol level\n",
"line" : 2111}
,
{
"name" : "GGP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Gateway to Gateway Protocol level\n",
"line" : 2112}
,
{
"name" : "TCP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Transmission Control Protocol level\n",
"line" : 2113}
,
{
"name" : "PUP",
"kind" : "enum member",
"protection" : "public",
"comment" : " PARC Universal Packet Protocol level\n",
"line" : 2114}
,
{
"name" : "UDP",
"kind" : "enum member",
"protection" : "public",
"comment" : " User Datagram Protocol level\n",
"line" : 2115}
,
{
"name" : "IDP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Xerox NS protocol level\n",
"line" : 2116}
,
{
"name" : "RAW",
"kind" : "enum member",
"protection" : "public",
"comment" : " Raw IP packet level\n",
"line" : 2117}
,
{
"name" : "IPV6",
"kind" : "enum member",
"protection" : "public",
"comment" : " Internet Protocol version 6 level\n",
"line" : 2118}
]
}
,
{
"name" : "Linger",
"kind" : "struct",
"protection" : "public",
"comment" : " _Linger information for use with SocketOption.LINGER.\n",
"line" : 2123,
"members" : [
{
"name" : "clinger",
"kind" : "variable",
"protection" : "public",
"type" : "linger",
"line" : 2124}
]
}
,
{
"name" : "linger",
"kind" : "alias",
"protection" : "public",
"type" : "Linger",
"comment" : "\n    $(RED Deprecated. It will be removed in January 2013.\n          Please use $(LREF Linger) instead.)\n  \n",
"line" : 2145}
,
{
"name" : "SocketOption",
"kind" : "enum",
"protection" : "public",
"comment" : " Specifies a socket option:\n",
"line" : 2148,
"base" : "int",
"members" : [
{
"name" : "DEBUG",
"kind" : "enum member",
"protection" : "public",
"comment" : " Record debugging information\n",
"line" : 2150}
,
{
"name" : "BROADCAST",
"kind" : "enum member",
"protection" : "public",
"comment" : " Allow transmission of broadcast messages\n",
"line" : 2151}
,
{
"name" : "REUSEADDR",
"kind" : "enum member",
"protection" : "public",
"comment" : " Allow local reuse of address\n",
"line" : 2152}
,
{
"name" : "LINGER",
"kind" : "enum member",
"protection" : "public",
"comment" : " Linger on close if unsent data is present\n",
"line" : 2153}
,
{
"name" : "OOBINLINE",
"kind" : "enum member",
"protection" : "public",
"comment" : " Receive out-of-band data in band\n",
"line" : 2154}
,
{
"name" : "SNDBUF",
"kind" : "enum member",
"protection" : "public",
"comment" : " Send buffer size\n",
"line" : 2155}
,
{
"name" : "RCVBUF",
"kind" : "enum member",
"protection" : "public",
"comment" : " Receive buffer size\n",
"line" : 2156}
,
{
"name" : "DONTROUTE",
"kind" : "enum member",
"protection" : "public",
"comment" : " Do not route\n",
"line" : 2157}
,
{
"name" : "SNDTIMEO",
"kind" : "enum member",
"protection" : "public",
"comment" : " Send timeout\n",
"line" : 2158}
,
{
"name" : "RCVTIMEO",
"kind" : "enum member",
"protection" : "public",
"comment" : " Receive timeout\n",
"line" : 2159}
,
{
"name" : "ERROR",
"kind" : "enum member",
"protection" : "public",
"comment" : " Retrieve and clear error status\n",
"line" : 2160}
,
{
"name" : "KEEPALIVE",
"kind" : "enum member",
"protection" : "public",
"comment" : " Enable keep-alive packets\n",
"line" : 2161}
,
{
"name" : "ACCEPTCONN",
"kind" : "enum member",
"protection" : "public",
"comment" : " Listen\n",
"line" : 2162}
,
{
"name" : "RCVLOWAT",
"kind" : "enum member",
"protection" : "public",
"comment" : " Minimum number of input bytes to process\n",
"line" : 2163}
,
{
"name" : "SNDLOWAT",
"kind" : "enum member",
"protection" : "public",
"comment" : " Minimum number of output bytes to process\n",
"line" : 2164}
,
{
"name" : "TYPE",
"kind" : "enum member",
"protection" : "public",
"comment" : " Socket type\n",
"line" : 2165}
,
{
"name" : "TCP_NODELAY",
"kind" : "enum member",
"protection" : "public",
"comment" : " Disable the Nagle algorithm for send coalescing\n",
"line" : 2168}
,
{
"name" : "IPV6_UNICAST_HOPS",
"kind" : "enum member",
"protection" : "public",
"comment" : " IP unicast hop limit\n",
"line" : 2171}
,
{
"name" : "IPV6_MULTICAST_IF",
"kind" : "enum member",
"protection" : "public",
"comment" : " IP multicast interface\n",
"line" : 2172}
,
{
"name" : "IPV6_MULTICAST_LOOP",
"kind" : "enum member",
"protection" : "public",
"comment" : " IP multicast loopback\n",
"line" : 2173}
,
{
"name" : "IPV6_MULTICAST_HOPS",
"kind" : "enum member",
"protection" : "public",
"comment" : " IP multicast hops\n",
"line" : 2174}
,
{
"name" : "IPV6_JOIN_GROUP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Add an IP group membership\n",
"line" : 2175}
,
{
"name" : "IPV6_LEAVE_GROUP",
"kind" : "enum member",
"protection" : "public",
"comment" : " Drop an IP group membership\n",
"line" : 2176}
,
{
"name" : "IPV6_V6ONLY",
"kind" : "enum member",
"protection" : "public",
"comment" : " Treat wildcard bind as AF_INET6-only\n",
"line" : 2177}
]
}
,
{
"name" : "Socket",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D Socket) is a class that creates a network communication endpoint using\n the Berkeley sockets interface.\n \n",
"line" : 2186,
"base" : "Object",
"members" : [
{
"name" : "sock",
"kind" : "variable",
"protection" : "private",
"type" : "socket_t",
"line" : 2188}
,
{
"name" : "_family",
"kind" : "variable",
"protection" : "private",
"type" : "AddressFamily",
"line" : 2189}
,
{
"name" : "WINSOCK_TIMEOUT_SKEW",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 2199}
,
{
"name" : "setSock",
"kind" : "function",
"protection" : "private",
"type" : "void(socket_t handle)",
"line" : 2226}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "protected",
"type" : "Socket()",
"line" : 2241}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(AddressFamily af, SocketType type, ProtocolType protocol)",
"comment" : "\n Create a blocking socket. If a single protocol type exists to support\n this socket type within the address family, the $(D ProtocolType) may be\n omitted.\n     \n",
"line" : 2253}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(AddressFamily af, SocketType type)",
"comment" : " ditto\n",
"line" : 2266}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(AddressFamily af, SocketType type, const(char[]) protocolName)",
"comment" : " ditto\n",
"line" : 2273}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(const(AddressInfo) info)",
"comment" : "\n Create a blocking socket using the parameters from the specified\n $(D AddressInfo) structure.\n     \n",
"line" : 2287}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(socket_t sock, AddressFamily af)",
"comment" : " Use an existing socket handle.\n",
"line" : 2293}
,
{
"name" : "handle",
"kind" : "function",
"protection" : "public",
"type" : "const @property socket_t()",
"comment" : " Get underlying socket handle.\n",
"line" : 2308}
,
{
"name" : "blocking",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : "\n Get\/set socket's blocking flag.\n\n When a socket is blocking, calls to receive(), accept(), and send()\n will block and wait for data\/action.\n A non-blocking socket will immediately return instead of blocking.\n     \n",
"line" : 2320}
,
{
"name" : "blocking",
"kind" : "function",
"protection" : "public",
"type" : "@property void(bool byes)",
"comment" : " ditto\n",
"line" : 2333}
,
{
"name" : "addressFamily",
"kind" : "function",
"protection" : "public",
"type" : "@property AddressFamily()",
"comment" : " Get the socket's address family.\n",
"line" : 2362}
,
{
"name" : "isAlive",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Property that indicates if this is a valid, alive socket.\n",
"line" : 2368}
,
{
"name" : "bind",
"kind" : "function",
"protection" : "public",
"type" : "void(Address addr)",
"comment" : " Associate a local address with this socket.\n",
"line" : 2376}
,
{
"name" : "connect",
"kind" : "function",
"protection" : "public",
"type" : "void(Address to)",
"comment" : "\n Establish a connection. If the socket is blocking, connect waits for\n the connection to be made. If the socket is nonblocking, connect\n returns immediately and the connection attempt is still in progress.\n     \n",
"line" : 2387}
,
{
"name" : "listen",
"kind" : "function",
"protection" : "public",
"type" : "void(int backlog)",
"comment" : "\n Listen for an incoming connection. $(D bind) must be called before you\n can $(D listen). The $(D backlog) is a request of how many pending\n incoming connections are queued until $(D accept)ed.\n     \n",
"line" : 2420}
,
{
"name" : "accepting",
"kind" : "function",
"protection" : "protected",
"type" : "Socket()",
"comment" : "\n Called by $(D accept) when a new $(D Socket) must be created for a new\n connection. To use a derived class, override this method and return an\n instance of your class. The returned $(D Socket)'s handle must not be\n set; $(D Socket) has a protected constructor $(D this()) to use in this\n situation.\n     \n",
"line" : 2435}
,
{
"name" : "accept",
"kind" : "function",
"protection" : "public",
"type" : "Socket()",
"comment" : "\n Accept an incoming connection. If the socket is blocking, $(D accept)\n waits for a connection request. Throws $(D SocketAcceptException) if\n unable to _accept. See $(D accepting) for use with derived classes.\n     \n",
"line" : 2445}
,
{
"name" : "shutdown",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketShutdown how)",
"comment" : " Disables sends and\/or receives.\n",
"line" : 2472}
,
{
"name" : "_close",
"kind" : "function",
"protection" : "private",
"type" : "void(socket_t sock)",
"line" : 2478}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Immediately drop any connections and release socket resources.\n Calling $(D shutdown) before $(D close) is recommended for\n connection-oriented sockets. The $(D Socket) object is no longer\n usable after $(D close).\n     \n",
"line" : 2499}
,
{
"name" : "hostName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : " Returns the local machine's host name.\n",
"line" : 2508}
,
{
"name" : "remoteAddress",
"kind" : "function",
"protection" : "public",
"type" : "Address()",
"comment" : " Remote endpoint $(D Address).\n",
"line" : 2517}
,
{
"name" : "localAddress",
"kind" : "function",
"protection" : "public",
"type" : "Address()",
"comment" : " Local endpoint $(D Address).\n",
"line" : 2530}
,
{
"name" : "ERROR",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"comment" : "\n Send or receive error code. See $(D wouldHaveBlocked),\n $(D lastSocketError) and $(D Socket.getErrorText) for obtaining more\n information about the error.\n     \n",
"line" : 2547}
,
{
"name" : "send",
"kind" : "function",
"protection" : "public",
"type" : "long(const(void)[] buf, SocketFlags flags)",
"comment" : "\n Send data on the connection. If the socket is blocking and there is no\n buffer space left, $(D send) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n     \n",
"line" : 2556}
,
{
"name" : "send",
"kind" : "function",
"protection" : "public",
"type" : "long(const(void)[] buf)",
"comment" : " ditto\n",
"line" : 2570}
,
{
"name" : "sendTo",
"kind" : "function",
"protection" : "public",
"type" : "long(const(void)[] buf, SocketFlags flags, Address to)",
"comment" : "\n Send data to a specific destination Address. If the destination address is\n not specified, a connection must have been made and that address is used.\n If the socket is blocking and there is no buffer space left, $(D sendTo) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n     \n",
"line" : 2582}
,
{
"name" : "sendTo",
"kind" : "function",
"protection" : "public",
"type" : "long(const(void)[] buf, Address to)",
"comment" : " ditto\n",
"line" : 2598}
,
{
"name" : "sendTo",
"kind" : "function",
"protection" : "public",
"type" : "long(const(void)[] buf, SocketFlags flags)",
"comment" : " ditto\n",
"line" : 2606}
,
{
"name" : "sendTo",
"kind" : "function",
"protection" : "public",
"type" : "long(const(void)[] buf)",
"comment" : " ditto\n",
"line" : 2621}
,
{
"name" : "receive",
"kind" : "function",
"protection" : "public",
"type" : "long(void[] buf, SocketFlags flags)",
"comment" : "\n Receive data on the connection. If the socket is blocking, $(D receive)\n waits until there is data to be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n     \n",
"line" : 2634}
,
{
"name" : "receive",
"kind" : "function",
"protection" : "public",
"type" : "long(void[] buf)",
"comment" : " ditto\n",
"line" : 2649}
,
{
"name" : "receiveFrom",
"kind" : "function",
"protection" : "public",
"type" : "long(void[] buf, SocketFlags flags, ref Address from)",
"comment" : "\n Receive data and get the remote endpoint $(D Address).\n If the socket is blocking, $(D receiveFrom) waits until there is data to\n be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n     \n",
"line" : 2661}
,
{
"name" : "receiveFrom",
"kind" : "function",
"protection" : "public",
"type" : "long(void[] buf, ref Address from)",
"comment" : " ditto\n",
"line" : 2684}
,
{
"name" : "receiveFrom",
"kind" : "function",
"protection" : "public",
"type" : "long(void[] buf, SocketFlags flags)",
"comment" : " ditto\n",
"line" : 2692}
,
{
"name" : "receiveFrom",
"kind" : "function",
"protection" : "public",
"type" : "long(void[] buf)",
"comment" : " ditto\n",
"line" : 2711}
,
{
"name" : "getOption",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketOptionLevel level, SocketOption option, void[] result)",
"comment" : " Get a socket option.\n Returns: The number of bytes written to $(D result).\n",
"line" : 2720}
,
{
"name" : "getOption",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketOptionLevel level, SocketOption option, out int result)",
"comment" : " Common case of getting integer and boolean options.\n",
"line" : 2730}
,
{
"name" : "getOption",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketOptionLevel level, SocketOption option, out Linger result)",
"comment" : " Get the linger option.\n",
"line" : 2737}
,
{
"name" : "getOption",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketOptionLevel level, SocketOption option, out Duration result)",
"comment" : " Get a timeout (duration) option.\n",
"line" : 2744}
,
{
"name" : "setOption",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketOptionLevel level, SocketOption option, void[] value)",
"line" : 2768}
,
{
"name" : "setOption",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketOptionLevel level, SocketOption option, int value)",
"comment" : " Common case for setting integer and boolean options.\n",
"line" : 2777}
,
{
"name" : "setOption",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketOptionLevel level, SocketOption option, Linger value)",
"comment" : " Set the linger option.\n",
"line" : 2784}
,
{
"name" : "setOption",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketOptionLevel level, SocketOption option, Duration value)",
"comment" : "\n Sets a timeout (duration) option, i.e. $(D SocketOption.SNDTIMEO) or\n $(D RCVTIMEO). Zero indicates no timeout.\n\n In a typical application, you might also want to consider using\n a non-blocking socket instead of setting a timeout on a blocking one.\n\n Note: While the receive timeout setting is generally quite accurate\n on *nix systems even for smaller durations, there are two issues to\n be aware of on Windows: First, although undocumented, the effective\n timeout duration seems to be the one set on the socket plus half\n a second. $(D setOption()) tries to compensate for that, but still,\n timeouts under 500ms are not possible on Windows. Second, be aware\n that the actual amount of time spent until a blocking call returns\n randomly varies on the order of 10ms.\n\n Params:\n   value = The timeout duration to set. Must not be negative.\n\n Throws: $(D SocketException) if setting the options fails.\n\n Example:\n ---\n import std.datetime;\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n \/\/ Set a receive timeout, and then wait at one end of\n \/\/ the socket pair, knowing that no data will arrive.\n pair[0].setOption(SocketOptionLevel.SOCKET,\n     SocketOption.RCVTIMEO, dur!\"seconds\"(1));\n\n auto sw = StopWatch(AutoStart.yes);\n ubyte[1] buffer;\n pair[0].receive(buffer);\n writefln(\"Waited %s ms until the socket timed out.\",\n     sw.peek.msecs);\n ---\n     \n",
"line" : 2829}
,
{
"name" : "getErrorText",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : " Get a text description of this socket's error status, and clear the\n socket's error status.\n",
"line" : 2856}
,
{
"name" : "setKeepAlive",
"kind" : "function",
"protection" : "public",
"type" : "void(int time, int interval)",
"comment" : "\n Enables TCP keep-alive with the specified parameters.\n\n Params:\n   time     = Number of seconds with no activity until the first\n              keep-alive packet is sent.\n   interval = Number of seconds between when successive keep-alive\n              packets are sent if no acknowledgement is received.\n\n Throws: $(D SocketOSException) if setting the options fails, or\n $(D SocketFeatureException) if setting keep-alive parameters is\n unsupported on the current platform.\n     \n",
"line" : 2876}
,
{
"name" : "select",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, TimeVal* tv)",
"comment" : "\n Wait for a socket to change status. A wait timeout $(D TimeVal),\n $(D Duration) or $(D long) microseconds may be specified; if a timeout\n is not specified or the $(D TimeVal) is $(D null), the maximum timeout\n is used. The $(D TimeVal) timeout has an unspecified value when\n $(D select) returns.\n Returns: The number of sockets with status changes, $(D 0) on timeout,\n or $(D -1) on interruption. If the return value is greater than $(D 0),\n the $(D SocketSets) are updated to only contain the sockets having status\n changes. For a connecting socket, a write status change means the\n connection is established and it's able to send. For a listening socket,\n a read status change means there is an incoming connection request and\n it's able to accept.\n     \n",
"line" : 2922}
,
{
"name" : "select",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, long microseconds)",
"comment" : " ditto\n",
"line" : 3012}
,
{
"name" : "select",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError, Duration duration)",
"comment" : " ditto\n",
"line" : 3022}
,
{
"name" : "select",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketSet checkRead, SocketSet checkWrite, SocketSet checkError)",
"comment" : " ditto\n",
"line" : 3033}
,
{
"name" : "createAddress",
"kind" : "function",
"protection" : "protected",
"type" : "Address()",
"comment" : " Returns a new Address object for the current address family.\n Can be overridden to support other addresses.\n",
"line" : 3041}
]
}
,
{
"name" : "TcpSocket",
"kind" : "class",
"protection" : "public",
"comment" : " $(D TcpSocket) is a shortcut class for a TCP Socket.\n",
"line" : 3064,
"base" : "Socket",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TcpSocket(AddressFamily family)",
"comment" : " Constructs a blocking TCP Socket.\n",
"line" : 3067}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TcpSocket()",
"comment" : " Constructs a blocking IPv4 TCP Socket.\n",
"line" : 3073}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TcpSocket(Address connectTo)",
"comment" : " Constructs a blocking TCP Socket and connects to an $(D Address).\n",
"line" : 3081}
]
}
,
{
"name" : "UdpSocket",
"kind" : "class",
"protection" : "public",
"comment" : " $(D UdpSocket) is a shortcut class for a UDP Socket.\n",
"line" : 3090,
"base" : "Socket",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UdpSocket(AddressFamily family)",
"comment" : " Constructs a blocking UDP Socket.\n",
"line" : 3093}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UdpSocket()",
"comment" : " Constructs a blocking IPv4 UDP Socket.\n",
"line" : 3100}
]
}
,
{
"name" : "socketPair",
"kind" : "function",
"protection" : "public",
"type" : "Socket[2LU]()",
"comment" : "\n Creates a pair of connected sockets.\n\n The two sockets are indistinguishable.\n\n Throws: $(D SocketException) if creation of the sockets fails.\n\n Example:\n ---\n immutable ubyte[] data = [1, 2, 3, 4];\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n pair[0].send(data);\n\n auto buf = new ubyte[data.length];\n pair[1].receive(buf);\n assert(buf == data);\n ---\n \n",
"line" : 3126}
]
}
,
{
"name" : "std.socketstream",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/socketstream.d",
"comment" : "\n $(RED Warning: This module is considered out-dated and not up to Phobos'\n       current standards. It will remain until we have a suitable replacement,\n       but be aware that it will not remain long term.)\n\n $(D SocketStream) is a stream for a blocking,\n connected $(D Socket).\n\n Example:\n      See $(SAMPLESRC htmlget.d)\n Authors: Christopher E. Miller\n References:\n      $(LINK2 std_stream.html, std.stream)\n Source:    $(PHOBOSSRC std\/_socketstream.d)\n Macros: WIKI=Phobos\/StdSocketstream\n \n",
"members" : [
{
"name" : "SocketStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n $(D SocketStream) is a stream for a blocking,\n connected $(D Socket).\n \n",
"line" : 49,
"base" : "Stream",
"members" : [
{
"name" : "sock",
"kind" : "variable",
"protection" : "private",
"type" : "std.socket.Socket",
"line" : 52}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketStream(Socket sock, FileMode mode)",
"comment" : "\n Constructs a SocketStream with the specified Socket and FileMode flags.\n         \n",
"line" : 59}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketStream(Socket sock)",
"comment" : "\n Uses mode $(D FileMode.In | FileMode.Out).\n         \n",
"line" : 72}
,
{
"name" : "socket",
"kind" : "function",
"protection" : "public",
"type" : "Socket()",
"comment" : "\n Property to get the $(D Socket) that is being streamed.\n         \n",
"line" : 81}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* _buffer, ulong size)",
"comment" : "\n Attempts to read the entire block, waiting if necessary.\n         \n",
"line" : 89}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) _buffer, ulong size)",
"comment" : "\n Attempts to write the entire block, waiting if necessary.\n         \n",
"line" : 107}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos whence)",
"comment" : "\n Socket streams do not support seeking. This disabled method throws\n a $(D SeekException).\n         \n",
"line" : 126}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Does not return the entire stream because that would\n require the remote connection to be closed.\n         \n",
"line" : 135}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Close the $(D Socket).\n         \n",
"line" : 143}
]
}
]
}
,
{
"name" : "std.stdint",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/stdint.d",
"comment" : "\n\n    D constrains integral types to specific sizes. But efficiency\n    of different sizes varies from machine to machine,\n    pointer sizes vary, and the maximum integer size varies.\n    <b>stdint<\/b> offers a portable way of trading off size\n    vs efficiency, in a manner compatible with the <tt>stdint.h<\/tt>\n    definitions in C.\n\n    The exact aliases are types of exactly the specified number of bits.\n    The at least aliases are at least the specified number of bits\n    large, and can be larger.\n    The fast aliases are the fastest integral type supported by the\n    processor that is at least as wide as the specified number of bits.\n\n    The aliases are:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Exact Alias\n    <th>Description\n    <th>At Least Alias\n    <th>Description\n    <th>Fast Alias\n    <th>Description\n    <tr>\n    <td>int8_t\n    <td>exactly 8 bits signed\n    <td>int_least8_t\n    <td>at least 8 bits signed\n    <td>int_fast8_t\n    <td>fast 8 bits signed\n    <tr>\n    <td>uint8_t\n    <td>exactly 8 bits unsigned\n    <td>uint_least8_t\n    <td>at least 8 bits unsigned\n    <td>uint_fast8_t\n    <td>fast 8 bits unsigned\n\n    <tr>\n    <td>int16_t\n    <td>exactly 16 bits signed\n    <td>int_least16_t\n    <td>at least 16 bits signed\n    <td>int_fast16_t\n    <td>fast 16 bits signed\n    <tr>\n    <td>uint16_t\n    <td>exactly 16 bits unsigned\n    <td>uint_least16_t\n    <td>at least 16 bits unsigned\n    <td>uint_fast16_t\n    <td>fast 16 bits unsigned\n\n    <tr>\n    <td>int32_t\n    <td>exactly 32 bits signed\n    <td>int_least32_t\n    <td>at least 32 bits signed\n    <td>int_fast32_t\n    <td>fast 32 bits signed\n    <tr>\n    <td>uint32_t\n    <td>exactly 32 bits unsigned\n    <td>uint_least32_t\n    <td>at least 32 bits unsigned\n    <td>uint_fast32_t\n    <td>fast 32 bits unsigned\n\n    <tr>\n    <td>int64_t\n    <td>exactly 64 bits signed\n    <td>int_least64_t\n    <td>at least 64 bits signed\n    <td>int_fast64_t\n    <td>fast 64 bits signed\n    <tr>\n    <td>uint64_t\n    <td>exactly 64 bits unsigned\n    <td>uint_least64_t\n    <td>at least 64 bits unsigned\n    <td>uint_fast64_t\n    <td>fast 64 bits unsigned\n    <\/table>\n\n    The ptr aliases are integral types guaranteed to be large enough\n    to hold a pointer without losing bits:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Alias\n    <th>Description\n    <tr>\n    <td>intptr_t\n    <td>signed integral type large enough to hold a pointer\n    <tr>\n    <td>uintptr_t\n    <td>unsigned integral type large enough to hold a pointer\n    <\/table>\n\n    The max aliases are the largest integral types:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Alias\n    <th>Description\n    <tr>\n    <td>intmax_t\n    <td>the largest signed integral type\n    <tr>\n    <td>uintmax_t\n    <td>the largest unsigned integral type\n    <\/table>\n\n Macros:\n  WIKI=Phobos\/StdStdint\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_stdint.d)\n \n",
"members" : [
]
}
,
{
"name" : "std.stdiobase",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/stdiobase.d",
"comment" : "\n The only purpose of this module is to do the static construction for\n std.stdio, to eliminate cyclic construction errors.\n\n Copyright: Copyright Andrei Alexandrescu 2008 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB erdani.org, Andrei Alexandrescu)\n Source:    $(PHOBOSSRC std\/_stdiobase.d)\n \n",
"members" : [
{
"name" : "std_stdio_static_this",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void()",
"line" : 19}
]
}
,
{
"name" : "std.stdio",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/stdio.d",
"comment" : "\nStandard I\/O functions that extend $(B std.c.stdio).  $(B std.c.stdio)\nis $(D_PARAM public)ally imported when importing $(B std.stdio).\n\nSource: $(PHOBOSSRC std\/_stdio.d)\nMacros:\nWIKI=Phobos\/StdStdio\n\nCopyright: Copyright Digital Mars 2007-.\nLicense:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Alex Rnne Petersen\n \n",
"members" : [
{
"name" : "fileno",
"kind" : "alias",
"protection" : "public",
"line" : 39}
,
{
"name" : "fopen64",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) shared(_iobuf)*(const(char*), const(char*))",
"line" : 46}
,
{
"name" : "fputc_unlocked",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(int, _iobuf*)",
"line" : 105}
,
{
"name" : "fputwc_unlocked",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(dchar, _iobuf*)",
"line" : 106}
,
{
"name" : "fgetc_unlocked",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(_iobuf*)",
"line" : 107}
,
{
"name" : "fgetwc_unlocked",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(_iobuf*)",
"line" : 108}
,
{
"name" : "flockfile",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(shared(_iobuf)*)",
"line" : 109}
,
{
"name" : "funlockfile",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(shared(_iobuf)*)",
"line" : 110}
,
{
"name" : "getline",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) long(char**, ulong*, shared(_iobuf)*)",
"line" : 111}
,
{
"name" : "getdelim",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) long(char**, ulong*, int, shared(_iobuf)*)",
"line" : 112}
,
{
"name" : "fwrite_unlocked",
"kind" : "function",
"protection" : "private",
"type" : "extern (C) ulong(const(void)* ptr, ulong size, ulong n, _iobuf* stream)",
"line" : 114}
,
{
"name" : "FPUTC",
"kind" : "alias",
"protection" : "public",
"line" : 125}
,
{
"name" : "FPUTWC",
"kind" : "alias",
"protection" : "public",
"line" : 126}
,
{
"name" : "FGETC",
"kind" : "alias",
"protection" : "public",
"line" : 127}
,
{
"name" : "FGETWC",
"kind" : "alias",
"protection" : "public",
"line" : 128}
,
{
"name" : "FLOCK",
"kind" : "alias",
"protection" : "public",
"line" : 130}
,
{
"name" : "FUNLOCK",
"kind" : "alias",
"protection" : "public",
"line" : 131}
,
{
"name" : "ByRecord(Fields...)",
"kind" : "struct",
"protection" : "public",
"line" : 164,
"members" : [
{
"name" : "ByRecord",
"kind" : "struct",
"protection" : "public",
"line" : 164,
"members" : [
{
"name" : "file",
"kind" : "variable",
"type" : "File",
"line" : 166}
,
{
"name" : "line",
"kind" : "variable",
"type" : "char[]",
"line" : 167}
,
{
"name" : "current",
"kind" : "variable",
"type" : "Tuple!(Fields)",
"line" : 168}
,
{
"name" : "format",
"kind" : "variable",
"type" : "string",
"line" : 169}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(File f, string format)",
"line" : 172}
,
{
"name" : "empty",
"kind" : "function",
"type" : "bool()",
"comment" : " Range primitive implementations.\n",
"line" : 181}
,
{
"name" : "front",
"kind" : "function",
"type" : "Tuple!(Fields)()",
"comment" : " Ditto\n",
"line" : 187}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 193}
]
}
]
}
,
{
"name" : "byRecord(Fields...)",
"kind" : "template",
"protection" : "public",
"line" : 211,
"members" : [
{
"name" : "byRecord",
"kind" : "function",
"type" : "ByRecord!(Fields)(File f, string format)",
"line" : 213}
]
}
,
{
"name" : "File",
"kind" : "struct",
"protection" : "public",
"comment" : "\nEncapsulates a $(D FILE*). Generally D does not attempt to provide\nthin wrappers over equivalent functions in the C standard library, but\nmanipulating $(D FILE*) values directly is unsafe and error-prone in\nmany ways. The $(D File) type ensures safe manipulation, automatic\nfile closing, and a lot of convenience.\n\nThe underlying $(D FILE*) handle is maintained in a reference-counted\nmanner, such that as soon as the last $(D File) variable bound to a\ngiven $(D FILE*) goes out of scope, the underlying $(D FILE*) is\nautomatically closed.\n\nExample:\n----\n\/\/ test.d\nvoid main(string args[])\n{\n    auto f = File(\"test.txt\", \"w\"); \/\/ open for writing\n    f.write(\"Hello\");\n    if (args.length > 1)\n    {\n        auto g = f; \/\/ now g and f write to the same file\n                    \/\/ internal reference count is 2\n        g.write(\", \", args[1]);\n        \/\/ g exits scope, reference count decreases to 1\n    }\n    f.writeln(\"!\");\n    \/\/ f exits scope, reference count falls to zero,\n    \/\/ underlying $(D FILE*) is closed.\n}\n----\n<pre class=console>\n% rdmd test.d Jimmy\n% cat test.txt\nHello, Jimmy!\n% __\n<\/pre>\n \n",
"line" : 258,
"members" : [
{
"name" : "Impl",
"kind" : "struct",
"protection" : "private",
"line" : 260,
"members" : [
{
"name" : "handle",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 261}
,
{
"name" : "refs",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 262}
,
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 263}
,
{
"name" : "isPipe",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"line" : 264}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref Impl(shared(_iobuf)* h, uint r, string n, bool pipe = false)",
"line" : 265}
]
}
,
{
"name" : "p",
"kind" : "variable",
"protection" : "private",
"type" : "Impl*",
"line" : 273}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref File(string name, const(char[]) stdioOpenmode = \"rb\")",
"comment" : "\nConstructor taking the name of the file to open and the open mode\n(with the same semantics as in the C standard library $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fopen.html, fopen)\nfunction). Throws an exception if the file could not be opened.\n\nCopying one $(D File) object to another results in the two $(D File)\nobjects referring to the same underlying file.\n\nThe destructor automatically closes the file as soon as no $(D File)\nobject refers to it anymore.\n \n",
"line" : 287}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(File rhs)",
"comment" : "\nAssigns a file to another. The target of the assignment gets detached\nfrom whatever file it was attached to, and attaches itself to the new\nfile.\n \n",
"line" : 314}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "void(string name, const(char[]) stdioOpenmode = \"rb\")",
"comment" : "\nFirst calls $(D detach) (throwing on failure), and then attempts to\n_open file $(D name) with mode $(D stdioOpenmode). The mode has the\nsame semantics as in the C standard library $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fopen.html, fopen) function.\nThrows exception in case of error.\n \n",
"line" : 326}
,
{
"name" : "popen",
"kind" : "function",
"protection" : "public",
"type" : "void(string command, const(char[]) stdioOpenmode = \"r\")",
"comment" : "\nFirst calls $(D detach) (throwing on failure), and then runs a command\nby calling the C standard library function $(WEB\nopengroup.org\/onlinepubs\/007908799\/xsh\/_popen.html, _popen).\n \n",
"line" : 338}
,
{
"name" : "isOpen",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property bool()",
"comment" : " Returns $(D true) if the file is opened. \n",
"line" : 347}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "const pure @property bool()",
"comment" : "\nReturns $(D true) if the file is at end (see $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/feof.html, feof)). The file\nmust be opened, otherwise an exception is thrown.\n \n",
"line" : 357}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property string()",
"comment" : " Returns the name of the file, if any. \n",
"line" : 364}
,
{
"name" : "error",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property bool()",
"comment" : "\nIf the file is not opened, returns $(D false). Otherwise, returns\n$(WEB cplusplus.com\/reference\/clibrary\/cstdio\/ferror.html, ferror) for\nthe file handle.\n \n",
"line" : 374}
,
{
"name" : "detach",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\nDetaches from the underlying file. If the sole owner, calls $(D close)\nand throws if that fails.\n  \n",
"line" : 383}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\nIf the file was unopened, succeeds vacuously. Otherwise closes the\nfile (by calling $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fclose.html, fclose)),\nthrowing on error. Even if an exception is thrown, afterwards the $(D\nFile) object is empty. This is different from $(D detach) in that it\nalways closes the file; consequently, all other $(D File) objects\nreferring to the same handle will see a closed file henceforth.\n \n",
"line" : 413}
,
{
"name" : "clearerr",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow void()",
"comment" : "\nIf the file is not opened, succeeds vacuously. Otherwise, returns\n$(WEB cplusplus.com\/reference\/clibrary\/cstdio\/_clearerr.html,\n_clearerr) for the file handle.\n \n",
"line" : 448}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/_fflush.html, _fflush) for the\nfile handle and throws on error.\n \n",
"line" : 459}
,
{
"name" : "rawRead(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fread.html, fread) for the\nfile handle and throws on error. The number of items to read and the size of\neach item is inferred from the size and type of the input array, respectively.\n\nReturns: The slice of $(D buffer) containing the data that was actually read.\nThis will be shorter than $(D buffer) if EOF was reached before the buffer\ncould be filled.\n\n$(D rawRead) always reads in binary mode on Windows.\n \n",
"line" : 478,
"members" : [
{
"name" : "rawRead",
"kind" : "function",
"type" : "T[](T[] buffer)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fread.html, fread) for the\nfile handle and throws on error. The number of items to read and the size of\neach item is inferred from the size and type of the input array, respectively.\n\nReturns: The slice of $(D buffer) containing the data that was actually read.\nThis will be shorter than $(D buffer) if EOF was reached before the buffer\ncould be filled.\n\n$(D rawRead) always reads in binary mode on Windows.\n \n",
"line" : 478}
]
}
,
{
"name" : "rawWrite(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fwrite.html, fwrite) for the file\nhandle and throws on error. The number of items to write and the size of each\nitem is inferred from the size and type of the input array, respectively. An\nerror is thrown if the buffer could not be written in its entirety.\n\n$(D rawWrite) always writes in binary mode on Windows.\n \n",
"line" : 524,
"members" : [
{
"name" : "rawWrite",
"kind" : "function",
"type" : "void(in T[] buffer)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fwrite.html, fwrite) for the file\nhandle and throws on error. The number of items to write and the size of each\nitem is inferred from the size and type of the input array, respectively. An\nerror is thrown if the buffer could not be written in its entirety.\n\n$(D rawWrite) always writes in binary mode on Windows.\n \n",
"line" : 524}
]
}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "void(long offset, int origin = 0)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/fseek.html, fseek) for the\nfile handle. Throws on error.\n \n",
"line" : 565}
,
{
"name" : "tell",
"kind" : "function",
"protection" : "public",
"type" : "const @property ulong()",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/ftell.html, ftell) for the\nmanaged file handle. Throws on error.\n \n",
"line" : 611}
,
{
"name" : "rewind",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/_rewind.html, _rewind) for the\nfile handle. Throws on error.\n \n",
"line" : 643}
,
{
"name" : "setvbuf",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong size, int mode = 0)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls $(WEB\ncplusplus.com\/reference\/clibrary\/cstdio\/_setvbuf.html, _setvbuf) for\nthe file handle.\n \n",
"line" : 654}
,
{
"name" : "setvbuf",
"kind" : "function",
"protection" : "public",
"type" : "void(void[] buf, int mode = 0)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, calls\n$(WEB cplusplus.com\/reference\/clibrary\/cstdio\/_setvbuf.html,\n_setvbuf) for the file handle. \n",
"line" : 665}
,
{
"name" : "write(S...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, writes its\narguments in text format to the file. \n",
"line" : 676,
"members" : [
{
"name" : "write",
"kind" : "function",
"type" : "void(S args)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, writes its\narguments in text format to the file. \n",
"line" : 676}
]
}
,
{
"name" : "writeln(S...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, writes its\narguments in text format to the file, followed by a newline. \n",
"line" : 713,
"members" : [
{
"name" : "writeln",
"kind" : "function",
"type" : "void(S args)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, writes its\narguments in text format to the file, followed by a newline. \n",
"line" : 713}
]
}
,
{
"name" : "errorMessage",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 723}
,
{
"name" : "writef(S...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, writes its\narguments in text format to the file, according to the format in the\nfirst argument. \n",
"line" : 729,
"members" : [
{
"name" : "writef",
"kind" : "function",
"type" : "void(S args)",
"comment" : "\nIf the file is not opened, throws an exception. Otherwise, writes its\narguments in text format to the file, according to the format in the\nfirst argument. \n",
"line" : 729}
]
}
,
{
"name" : "writefln(S...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nSame as writef, plus adds a newline. \n",
"line" : 741,
"members" : [
{
"name" : "writefln",
"kind" : "function",
"type" : "void(S args)",
"comment" : "\nSame as writef, plus adds a newline. \n",
"line" : 741}
]
}
,
{
"name" : "readln(S = string)",
"kind" : "template",
"protection" : "public",
"comment" : "\nRead line from stream $(D fp) and write it to $(D buf[]), including\nterminating character.\n\nThis is often faster than $(D File.readln(dchar)) because the buffer\nis reused each call. Note that reusing the buffer means that the\nprevious contents of it has to be copied if needed.\n\nParams:\nfp = input stream\nbuf = buffer used to store the resulting line data. buf is\nresized as necessary.\n\nReturns:\n0 for end of file, otherwise number of characters read\n\nThrows: $(D StdioException) on I\/O error, or $(D UnicodeException) on Unicode\nconversion error.\n\nExample:\n---\n\/\/ Reads $(D stdin) and writes it to $(D stdout).\nimport std.stdio;\n\nint main()\n{\n    char[] buf;\n    while (stdin.readln(buf))\n        write(buf);\n    return 0;\n}\n---\n\nThis method is more efficient than the one in the previous example\nbecause $(D stdin.readln(buf)) reuses (if possible) memory allocated\nby $(D buf), whereas $(D buf = stdin.readln()) makes a new memory allocation\nwith every line.  \n",
"line" : 788,
"members" : [
{
"name" : "readln",
"kind" : "function",
"type" : "S(dchar terminator = '\\x0a')",
"comment" : "\nRead line from stream $(D fp) and write it to $(D buf[]), including\nterminating character.\n\nThis is often faster than $(D File.readln(dchar)) because the buffer\nis reused each call. Note that reusing the buffer means that the\nprevious contents of it has to be copied if needed.\n\nParams:\nfp = input stream\nbuf = buffer used to store the resulting line data. buf is\nresized as necessary.\n\nReturns:\n0 for end of file, otherwise number of characters read\n\nThrows: $(D StdioException) on I\/O error, or $(D UnicodeException) on Unicode\nconversion error.\n\nExample:\n---\n\/\/ Reads $(D stdin) and writes it to $(D stdout).\nimport std.stdio;\n\nint main()\n{\n    char[] buf;\n    while (stdin.readln(buf))\n        write(buf);\n    return 0;\n}\n---\n\nThis method is more efficient than the one in the previous example\nbecause $(D stdin.readln(buf)) reuses (if possible) memory allocated\nby $(D buf), whereas $(D buf = stdin.readln()) makes a new memory allocation\nwith every line.  \n",
"line" : 788}
]
}
,
{
"name" : "readln(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto \n",
"line" : 816,
"members" : [
{
"name" : "readln",
"kind" : "function",
"type" : "size_t(ref C[] buf, dchar terminator = '\\x0a')",
"comment" : " ditto \n",
"line" : 816}
]
}
,
{
"name" : "readln(C,R) if (isBidirectionalRange!(R) && is(typeof(terminator.front == buf[0])))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto \n",
"line" : 838,
"members" : [
{
"name" : "readln",
"kind" : "function",
"type" : "size_t(ref C[] buf, R terminator)",
"comment" : " ditto \n",
"line" : 838}
]
}
,
{
"name" : "readf(Data...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Read data from the file according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n     \n",
"line" : 879,
"members" : [
{
"name" : "readf",
"kind" : "function",
"type" : "uint(in char[] format, Data data)",
"comment" : "\n Read data from the file according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n     \n",
"line" : 879}
]
}
,
{
"name" : "tmpfile",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Returns a temporary file by calling $(WEB\n cplusplus.com\/reference\/clibrary\/cstdio\/_tmpfile.html, _tmpfile). \n",
"line" : 900}
,
{
"name" : "wrapFile",
"kind" : "function",
"protection" : "public",
"type" : "File(shared(_iobuf)* f)",
"comment" : "\nUnsafe function that wraps an existing $(D FILE*). The resulting $(D\nFile) never takes the initiative in closing the file. \n",
"line" : 912}
,
{
"name" : "getFP",
"kind" : "function",
"protection" : "public",
"type" : "pure shared(_iobuf)*()",
"comment" : "\nReturns the $(D FILE*) corresponding to this object.\n \n",
"line" : 923}
,
{
"name" : "fileno",
"kind" : "function",
"protection" : "public",
"type" : "const int()",
"comment" : "\nReturns the file number corresponding to this object.\n \n",
"line" : 938}
,
{
"name" : "ByLine(Char,Terminator)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nRange that reads one line at a time. \n ditto\n",
"line" : 948,
"members" : [
{
"name" : "ByLine",
"kind" : "struct",
"protection" : "public",
"line" : 948,
"members" : [
{
"name" : "file",
"kind" : "variable",
"type" : "File",
"line" : 949}
,
{
"name" : "line",
"kind" : "variable",
"type" : "Char[]",
"line" : 950}
,
{
"name" : "terminator",
"kind" : "variable",
"type" : "Terminator",
"line" : 951}
,
{
"name" : "keepTerminator",
"kind" : "variable",
"type" : "KeepTerminator",
"line" : 952}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(File f, KeepTerminator kt = KeepTerminator.no, Terminator terminator = '\\x0a')",
"line" : 954}
,
{
"name" : "empty",
"kind" : "function",
"type" : "const bool()",
"comment" : " Range primitive implementations.\n",
"line" : 963}
,
{
"name" : "front",
"kind" : "function",
"type" : "Char[]()",
"comment" : " Ditto\n",
"line" : 986}
,
{
"name" : "popFront",
"kind" : "function",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 993}
]
}
]
}
,
{
"name" : "byLine(Terminator = char,Char = char)",
"kind" : "template",
"protection" : "public",
"comment" : "\nConvenience function that returns the $(D LinesReader) corresponding\nto this file. \n",
"line" : 1014,
"members" : [
{
"name" : "byLine",
"kind" : "function",
"type" : "ByLine!(Char,Terminator)(KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a')",
"comment" : "\nConvenience function that returns the $(D LinesReader) corresponding\nto this file. \n",
"line" : 1014}
]
}
,
{
"name" : "byRecord(Fields...)",
"kind" : "template",
"protection" : "public",
"line" : 1066,
"members" : [
{
"name" : "byRecord",
"kind" : "function",
"type" : "ByRecord!(Fields)(string format)",
"line" : 1068}
]
}
,
{
"name" : "ByChunk",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Range that reads a chunk at a time.\n     \n",
"line" : 1097,
"members" : [
{
"name" : "file_",
"kind" : "variable",
"protection" : "private",
"type" : "File",
"line" : 1099}
,
{
"name" : "chunk_",
"kind" : "variable",
"protection" : "private",
"type" : "ubyte[]",
"line" : 1100}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref ByChunk(File file, ulong size)",
"line" : 1104}
,
{
"name" : "empty",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Range primitive operations.\n",
"line" : 1120}
,
{
"name" : "front",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @property ubyte[]()",
"comment" : " Ditto\n",
"line" : 1128}
,
{
"name" : "popFront",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " Ditto\n",
"line" : 1135}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(ByChunk) p)",
"line" : 1097}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref ByChunk(ByChunk p)",
"line" : 1097}
]
}
,
{
"name" : "byChunk",
"kind" : "function",
"protection" : "public",
"type" : "ByChunk(ulong chunkSize)",
"comment" : "\nIterates through a file a chunk at a time by using $(D foreach).\n\nExample:\n\n---------\nvoid main()\n{\n  foreach (ubyte[] buffer; stdin.byChunk(4096))\n  {\n    ... use buffer ...\n  }\n}\n---------\n\nThe content of $(D buffer) is reused across calls. In the example\nabove, $(D buffer.length) is 4096 for all iterations, except for the\nlast one, in which case $(D buffer.length) may be less than 4096 (but\nalways greater than zero).\n\nIn case of an I\/O error, an $(D StdioException) is thrown.\n \n",
"line" : 1167}
,
{
"name" : "LockingTextWriter",
"kind" : "struct",
"protection" : "public",
"comment" : "\n$(D Range) that locks the file and allows fast writing to it.\n \n",
"line" : 1199,
"members" : [
{
"name" : "fps",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 1200}
,
{
"name" : "handle",
"kind" : "variable",
"protection" : "public",
"type" : "_iobuf*",
"line" : 1201}
,
{
"name" : "orientation",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 1202}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref LockingTextWriter(ref File f)",
"line" : 1204}
,
{
"name" : "put(A) if (is(ElementType!(A) : const(dchar)))",
"kind" : "template",
"protection" : "public",
"comment" : " Range primitive implementations.\n",
"line" : 1227,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(A writeme)",
"comment" : " Range primitive implementations.\n",
"line" : 1227}
]
}
,
{
"name" : "put(C) if (is(C : const(dchar)))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1255,
"members" : [
{
"name" : "put",
"kind" : "function",
"type" : "void(C c)",
"comment" : " ditto\n",
"line" : 1255}
]
}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(LockingTextWriter) p)",
"line" : 1199}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref LockingTextWriter(LockingTextWriter p)",
"line" : 1199}
]
}
,
{
"name" : "lockingTextWriter",
"kind" : "function",
"protection" : "public",
"type" : "@property LockingTextWriter()",
"comment" : " Convenience function.\n",
"line" : 1333}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"comment" : " Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.\n",
"line" : 1339}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(File) p)",
"line" : 258}
]
}
,
{
"name" : "LockingTextReader",
"kind" : "struct",
"protection" : "public",
"line" : 1360,
"members" : [
{
"name" : "_f",
"kind" : "variable",
"protection" : "private",
"type" : "File",
"line" : 1361}
,
{
"name" : "_crt",
"kind" : "variable",
"protection" : "private",
"type" : "dchar",
"line" : 1362}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref LockingTextReader(File f)",
"line" : 1364}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(LockingTextReader r)",
"line" : 1382}
,
{
"name" : "empty",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 1387}
,
{
"name" : "front",
"kind" : "function",
"protection" : "public",
"type" : "@property dchar()",
"line" : 1406}
,
{
"name" : "popFront",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1412}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(LockingTextReader) p)",
"line" : 1360}
]
}
,
{
"name" : "writefx",
"kind" : "function",
"protection" : "private",
"type" : "void(shared(_iobuf)* fps, TypeInfo[] arguments, void* argptr, int newline = cast(int)false)",
"line" : 1446}
,
{
"name" : "isFileHandle(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Indicates whether $(D T) is a file handle of some kind.\n \n",
"line" : 1518,
"members" : [
{
"name" : "isFileHandle",
"kind" : "variable",
"line" : 1521}
]
}
,
{
"name" : "isStreamingDevice",
"kind" : "alias",
"protection" : "public",
"comment" : "\n $(RED Scheduled for deprecation in January 2013.\n       Please use $(D isFileHandle) instead.)\n \n",
"line" : 1534}
,
{
"name" : "write(T...) if (!is(T[0] : File))",
"kind" : "template",
"protection" : "public",
"comment" : "\nFor each argument $(D arg) in $(D args), format the argument (as per\n$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting\nstring to $(D args[0]). A call without any arguments will fail to\ncompile.\n\nThrows: In case of an I\/O error, throws an $(D StdioException).\n \n",
"line" : 1544,
"members" : [
{
"name" : "write",
"kind" : "function",
"type" : "void(T args)",
"comment" : "\nFor each argument $(D arg) in $(D args), format the argument (as per\n$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting\nstring to $(D args[0]). A call without any arguments will fail to\ncompile.\n\nThrows: In case of an I\/O error, throws an $(D StdioException).\n \n",
"line" : 1544}
]
}
,
{
"name" : "writeln(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Equivalent to $(D write(args, '\\n')).  Calling $(D writeln) without\n arguments is valid and just prints a newline to the standard\n output.\n \n",
"line" : 1578,
"members" : [
{
"name" : "writeln",
"kind" : "function",
"type" : "void(T args)",
"comment" : "\n Equivalent to $(D write(args, '\\n')).  Calling $(D writeln) without\n arguments is valid and just prints a newline to the standard\n output.\n \n",
"line" : 1578}
]
}
,
{
"name" : "writef(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n If the first argument $(D args[0]) is a $(D FILE*), use\n $(LINK2 std_format.html#format-string, the format specifier) in\n $(D args[1]) to control the formatting of $(D\n args[2..$]), and write the resulting string to $(D args[0]).\n If $(D arg[0]) is not a $(D FILE*), the call is\n equivalent to $(D writef(stdout, args)).\n\n\nIMPORTANT:\n\nNew behavior starting with D 2.006: unlike previous versions,\n$(D writef) (and also $(D writefln)) only scans its first\nstring argument for format specifiers, but not subsequent string\narguments. This decision was made because the old behavior made it\nunduly hard to simply print string variables that occasionally\nembedded percent signs.\n\nAlso new starting with 2.006 is support for positional\nparameters with\n$(LINK2 http:\/\/opengroup.org\/onlinepubs\/009695399\/functions\/printf.html,\nPOSIX) syntax.\n\nExample:\n\n-------------------------\nwritef(\"Date: %2$s %1$s\", \"October\", 5); \/\/ \"Date: 5 October\"\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the popFront parameter after\nthe largest positional parameter already used.\n\nNew starting with 2.008: raw format specifiers. Using the \"%r\"\nspecifier makes $(D writef) simply write the binary\nrepresentation of the argument. Use \"%-r\" to write numbers in little\nendian format, \"%+r\" to write numbers in big endian format, and \"%r\"\nto write numbers in platform-native format.\n\n",
"line" : 1729,
"members" : [
{
"name" : "writef",
"kind" : "function",
"type" : "void(T args)",
"comment" : "\n If the first argument $(D args[0]) is a $(D FILE*), use\n $(LINK2 std_format.html#format-string, the format specifier) in\n $(D args[1]) to control the formatting of $(D\n args[2..$]), and write the resulting string to $(D args[0]).\n If $(D arg[0]) is not a $(D FILE*), the call is\n equivalent to $(D writef(stdout, args)).\n\n\nIMPORTANT:\n\nNew behavior starting with D 2.006: unlike previous versions,\n$(D writef) (and also $(D writefln)) only scans its first\nstring argument for format specifiers, but not subsequent string\narguments. This decision was made because the old behavior made it\nunduly hard to simply print string variables that occasionally\nembedded percent signs.\n\nAlso new starting with 2.006 is support for positional\nparameters with\n$(LINK2 http:\/\/opengroup.org\/onlinepubs\/009695399\/functions\/printf.html,\nPOSIX) syntax.\n\nExample:\n\n-------------------------\nwritef(\"Date: %2$s %1$s\", \"October\", 5); \/\/ \"Date: 5 October\"\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the popFront parameter after\nthe largest positional parameter already used.\n\nNew starting with 2.008: raw format specifiers. Using the \"%r\"\nspecifier makes $(D writef) simply write the binary\nrepresentation of the argument. Use \"%-r\" to write numbers in little\nendian format, \"%+r\" to write numbers in big endian format, and \"%r\"\nto write numbers in platform-native format.\n\n",
"line" : 1729}
]
}
,
{
"name" : "writefln(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Equivalent to $(D writef(args, '\\n')).\n \n",
"line" : 1757,
"members" : [
{
"name" : "writefln",
"kind" : "function",
"type" : "void(T args)",
"comment" : "\n Equivalent to $(D writef(args, '\\n')).\n \n",
"line" : 1757}
]
}
,
{
"name" : "readf(A...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Read data from $(D stdin) according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n \n",
"line" : 1804,
"members" : [
{
"name" : "readf",
"kind" : "function",
"type" : "uint(in char[] format, A args)",
"comment" : "\n Read data from $(D stdin) according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n \n",
"line" : 1804}
]
}
,
{
"name" : "readln",
"kind" : "function",
"protection" : "public",
"type" : "string(dchar terminator = cast(dchar)'\\x0a')",
"comment" : "\n Read line from stream $(D fp).\n Returns:\n        $(D null) for end of file,\n        $(D char[]) for line read from $(D fp), including terminating character\n Params:\n        $(D fp) = input stream\n        $(D terminator) = line terminator, '\\n' by default\n Throws:\n        $(D StdioException) on error\n Example:\n        Reads $(D stdin) and writes it to $(D stdout).\n---\nimport std.stdio;\n\nint main()\n{\n    char[] buf;\n    while ((buf = readln()) != null)\n        write(buf);\n    return 0;\n}\n---\n",
"line" : 1844}
,
{
"name" : "readln",
"kind" : "function",
"protection" : "public",
"type" : "ulong(ref char[] buf, dchar terminator = cast(dchar)'\\x0a')",
"comment" : " ditto \n",
"line" : 1850}
,
{
"name" : "fopen",
"kind" : "function",
"protection" : "private",
"type" : "shared(_iobuf)*(const(char[]) name, const(char[]) mode = \"r\")",
"line" : 1859}
,
{
"name" : "popen",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) shared(_iobuf)*(const(char*), const(char*))",
"line" : 1867}
,
{
"name" : "popen",
"kind" : "function",
"protection" : "public",
"type" : "shared(_iobuf)*(const(char[]) name, const(char[]) mode = \"r\")",
"comment" : "\n Convenience function that forwards to $(D std.c.stdio.popen)\n with appropriately-constructed C-style strings.\n \n",
"line" : 1873}
,
{
"name" : "binaryWrite(T)",
"kind" : "template",
"protection" : "public",
"line" : 1883,
"members" : [
{
"name" : "binaryWrite",
"kind" : "function",
"type" : "void(FILE* f, T obj)",
"line" : 1883}
]
}
,
{
"name" : "lines",
"kind" : "struct",
"protection" : "public",
"comment" : "\n Iterates through the lines of a file by using $(D foreach).\n\n Example:\n\n---------\nvoid main()\n{\n  foreach (string line; lines(stdin))\n  {\n    ... use line ...\n  }\n}\n---------\n The line terminator ('\\n' by default) is part of the string read (it\ncould be missing in the last line of the file). Several types are\nsupported for $(D line), and the behavior of $(D lines)\nchanges accordingly:\n\n$(OL $(LI If $(D line) has type $(D string), $(D\nwstring), or $(D dstring), a new string of the respective type\nis allocated every read.) $(LI If $(D line) has type $(D\nchar[]), $(D wchar[]), $(D dchar[]), the line's content\nwill be reused (overwritten) across reads.) $(LI If $(D line)\nhas type $(D immutable(ubyte)[]), the behavior is similar to\ncase (1), except that no UTF checking is attempted upon input.) $(LI\nIf $(D line) has type $(D ubyte[]), the behavior is\nsimilar to case (2), except that no UTF checking is attempted upon\ninput.))\n\nIn all cases, a two-symbols versions is also accepted, in which case\nthe first symbol (of integral type, e.g. $(D ulong) or $(D\nuint)) tracks the zero-based number of the current line.\n\nExample:\n----\n  foreach (ulong i, string line; lines(stdin))\n  {\n    ... use line ...\n  }\n----\n\n In case of an I\/O error, an $(D StdioException) is thrown.\n \n",
"line" : 1935,
"members" : [
{
"name" : "f",
"kind" : "variable",
"protection" : "private",
"type" : "File",
"line" : 1936}
,
{
"name" : "terminator",
"kind" : "variable",
"protection" : "private",
"type" : "dchar",
"line" : 1937}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref lines(File f, dchar terminator = cast(dchar)'\\x0a')",
"line" : 1940}
,
{
"name" : "opApply(D)",
"kind" : "template",
"protection" : "public",
"line" : 1958,
"members" : [
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope D dg)",
"line" : 1958}
]
}
,
{
"name" : "opApplyRaw(D)",
"kind" : "template",
"protection" : "public",
"line" : 2003,
"members" : [
{
"name" : "opApplyRaw",
"kind" : "function",
"type" : "int(scope D dg)",
"line" : 2003}
]
}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(lines) p)",
"line" : 1935}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref lines(lines p)",
"line" : 1935}
]
}
,
{
"name" : "chunks",
"kind" : "struct",
"protection" : "public",
"comment" : "\nIterates through a file a chunk at a time by using $(D\nforeach).\n\nExample:\n\n---------\nvoid main()\n{\n  foreach (ubyte[] buffer; chunks(stdin, 4096))\n  {\n    ... use buffer ...\n  }\n}\n---------\n\nThe content of $(D buffer) is reused across calls. In the\n example above, $(D buffer.length) is 4096 for all iterations,\n except for the last one, in which case $(D buffer.length) may\n be less than 4096 (but always greater than zero).\n\n In case of an I\/O error, an $(D StdioException) is thrown.\n",
"line" : 2183,
"members" : [
{
"name" : "f",
"kind" : "variable",
"protection" : "private",
"type" : "File",
"line" : 2184}
,
{
"name" : "size",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 2185}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ref chunks(File f, ulong size)",
"line" : 2188}
,
{
"name" : "opApply(D)",
"kind" : "template",
"protection" : "public",
"line" : 2208,
"members" : [
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope D dg)",
"line" : 2208}
]
}
,
{
"name" : "__cpctor",
"kind" : "function",
"protection" : "public",
"type" : "const void(ref const(chunks) p)",
"line" : 2183}
,
{
"name" : "opAssign",
"kind" : "function",
"protection" : "public",
"type" : "ref chunks(chunks p)",
"line" : 2183}
]
}
,
{
"name" : "StdioException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown if I\/O errors happen.\n \n",
"line" : 2273,
"base" : "Exception",
"members" : [
{
"name" : "errno",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Operating system error code.\n",
"line" : 2276}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StdioException(string message, uint e = cast(uint)errno())",
"comment" : "\nInitialize with a message and an error code. \n",
"line" : 2280}
,
{
"name" : "opCall",
"kind" : "function",
"protection" : "public",
"type" : "void(string msg)",
"comment" : " Convenience functions that throw an $(D StdioException). \n",
"line" : 2305}
,
{
"name" : "opCall",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " ditto\n",
"line" : 2311}
]
}
,
{
"name" : "std_stdio_static_this",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void()",
"line" : 2317}
,
{
"name" : "stdin",
"kind" : "variable",
"protection" : "public",
"type" : "File",
"comment" : " The standard input stream.\n",
"line" : 2336}
,
{
"name" : "stdout",
"kind" : "variable",
"protection" : "public",
"type" : "File",
"comment" : " The standard output stream.\n",
"line" : 2337}
,
{
"name" : "stderr",
"kind" : "variable",
"protection" : "public",
"type" : "File",
"comment" : " The standard error stream.\n",
"line" : 2338}
,
{
"name" : "readlnImpl",
"kind" : "function",
"protection" : "private",
"type" : "ulong(shared(_iobuf)* fps, ref char[] buf, dchar terminator = cast(dchar)'\\x0a')",
"line" : 2504}
,
{
"name" : "openNetwork",
"kind" : "function",
"protection" : "public",
"type" : "File(string host, ushort port)",
"comment" : " Experimental network access via the File interface\n\n        Opens a TCP connection to the given host and port, then returns\n        a File struct with read and write access through the same interface\n        as any other file (meaning writef and the byLine ranges work!).\n\n        Authors:\n                Adam D. Ruppe\n\n        Bugs:\n                Only works on Linux\n",
"line" : 2701}
]
}
,
{
"name" : "std.stream",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/stream.d",
"comment" : "\n $(RED Warning: This module is considered out-dated and not up to Phobos'\n       current standards. It will remain until we have a suitable replacement,\n       but be aware that it will not remain long term.)\n\n Source:    $(PHOBOSSRC std\/_stream.d)\n Macros:\n      WIKI = Phobos\/StdStream\n \n",
"members" : [
{
"name" : "StreamException",
"kind" : "class",
"protection" : "public",
"comment" : " A base class for stream exceptions.\n",
"line" : 48,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StreamException(string msg)",
"comment" : " Construct a StreamException with given error message.\n",
"line" : 50}
]
}
,
{
"name" : "ReadException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown when unable to read data from Stream.\n",
"line" : 54,
"base" : "StreamException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ReadException(string msg)",
"comment" : " Construct a ReadException with given error message.\n",
"line" : 56}
]
}
,
{
"name" : "WriteException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown when unable to write data to Stream.\n",
"line" : 60,
"base" : "StreamException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "WriteException(string msg)",
"comment" : " Construct a WriteException with given error message.\n",
"line" : 62}
]
}
,
{
"name" : "SeekException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown when unable to move Stream pointer.\n",
"line" : 66,
"base" : "StreamException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SeekException(string msg)",
"comment" : " Construct a SeekException with given error message.\n",
"line" : 68}
]
}
,
{
"name" : "SeekPos",
"kind" : "enum",
"protection" : "public",
"line" : 72,
"base" : "int",
"members" : [
{
"name" : "Set",
"kind" : "enum member",
"protection" : "public",
"line" : 73}
,
{
"name" : "Current",
"kind" : "enum member",
"protection" : "public",
"line" : 74}
,
{
"name" : "End",
"kind" : "enum member",
"protection" : "public",
"line" : 75}
]
}
,
{
"name" : "InputStream",
"kind" : "interface",
"protection" : "public",
"comment" : " InputStream is the interface for readable streams.\n",
"line" : 94,
"members" : [
{
"name" : "readExact",
"kind" : "function",
"protection" : "public",
"type" : "void(void* buffer, ulong size)",
"comment" : "\n Read exactly size bytes into the buffer.\n\n Throws a ReadException if it is not correct.\n   \n",
"line" : 101}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "ulong(ubyte[] buffer)",
"comment" : "\n Read a block of data big enough to fill the given array buffer.\n\n Returns: the actual number of bytes read. Unfilled bytes are not modified.\n   \n",
"line" : 108}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out byte x)",
"comment" : "\n Read a basic type or counted string.\n\n Throw a ReadException if it could not be read.\n Outside of byte, ubyte, and char, the format is\n implementation-specific and should not be used except as opposite actions\n to write.\n   \n",
"line" : 118}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ubyte x)",
"comment" : " ditto\n",
"line" : 119}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out short x)",
"comment" : " ditto\n",
"line" : 120}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ushort x)",
"comment" : " ditto\n",
"line" : 121}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out int x)",
"comment" : " ditto\n",
"line" : 122}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out uint x)",
"comment" : " ditto\n",
"line" : 123}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out long x)",
"comment" : " ditto\n",
"line" : 124}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ulong x)",
"comment" : " ditto\n",
"line" : 125}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out float x)",
"comment" : " ditto\n",
"line" : 126}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out double x)",
"comment" : " ditto\n",
"line" : 127}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out real x)",
"comment" : " ditto\n",
"line" : 128}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ifloat x)",
"comment" : " ditto\n",
"line" : 129}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out idouble x)",
"comment" : " ditto\n",
"line" : 130}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ireal x)",
"comment" : " ditto\n",
"line" : 131}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out cfloat x)",
"comment" : " ditto\n",
"line" : 132}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out cdouble x)",
"comment" : " ditto\n",
"line" : 133}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out creal x)",
"comment" : " ditto\n",
"line" : 134}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out char x)",
"comment" : " ditto\n",
"line" : 135}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out wchar x)",
"comment" : " ditto\n",
"line" : 136}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out dchar x)",
"comment" : " ditto\n",
"line" : 137}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out char[] s)",
"comment" : " ditto\n",
"line" : 140}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out wchar[] s)",
"comment" : " ditto\n",
"line" : 143}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "char[]()",
"comment" : "\n Read a line that is terminated with some combination of carriage return and\n line feed or end-of-file.\n\n The terminators are not included. The wchar version\n is identical. The optional buffer parameter is filled (reallocating\n it if necessary) and a slice of the result is returned.\n   \n",
"line" : 153}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "char[](char[] result)",
"comment" : " ditto\n",
"line" : 154}
,
{
"name" : "readLineW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[]()",
"comment" : " ditto\n",
"line" : 155}
,
{
"name" : "readLineW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[](wchar[] result)",
"comment" : " ditto\n",
"line" : 156}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref char[] line) dg)",
"comment" : "\n Overload foreach statements to read the stream line by line and call the\n supplied delegate with each line or with each line with line number.\n\n The string passed in line may be reused between calls to the delegate.\n Line numbering starts at 1.\n Breaking out of the foreach will leave the stream\n position at the beginning of the next line to be read.\n For example, to echo a file line-by-line with line numbers run:\n ------------------------------------\n Stream file = new BufferedFile(\"sample.txt\");\n foreach(ulong n, char[] line; file)\n {\n     writefln(\"line %d: %s\", n, line);\n }\n file.close();\n ------------------------------------\n   \n",
"line" : 178}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref ulong n, ref char[] line) dg)",
"comment" : " ditto\n",
"line" : 179}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref wchar[] line) dg)",
"comment" : " ditto\n",
"line" : 180}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref ulong n, ref wchar[] line) dg)",
"comment" : " ditto\n",
"line" : 181}
,
{
"name" : "readString",
"kind" : "function",
"protection" : "public",
"type" : "char[](ulong length)",
"comment" : " Read a string of the given length,\n throwing ReadException if there was a problem.\n",
"line" : 185}
,
{
"name" : "readStringW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[](ulong length)",
"comment" : "\n Read a string of the given length, throwing ReadException if there was a\n problem.\n\n The file format is implementation-specific and should not be used\n except as opposite actions to <b>write<\/b>.\n   \n",
"line" : 195}
,
{
"name" : "getc",
"kind" : "function",
"protection" : "public",
"type" : "char()",
"comment" : "\n Read and return the next character in the stream.\n\n This is the only method that will handle ungetc properly.\n getcw's format is implementation-specific.\n If EOF is reached then getc returns char.init and getcw returns wchar.init.\n   \n",
"line" : 206}
,
{
"name" : "getcw",
"kind" : "function",
"protection" : "public",
"type" : "wchar()",
"comment" : " ditto\n",
"line" : 207}
,
{
"name" : "ungetc",
"kind" : "function",
"protection" : "public",
"type" : "char(char c)",
"comment" : "\n Push a character back onto the stream.\n\n They will be returned in first-in last-out order from getc\/getcw.\n Only has effect on further calls to getc() and getcw().\n   \n",
"line" : 215}
,
{
"name" : "ungetcw",
"kind" : "function",
"protection" : "public",
"type" : "wchar(wchar c)",
"comment" : " ditto\n",
"line" : 216}
,
{
"name" : "vreadf",
"kind" : "function",
"protection" : "public",
"type" : "int(TypeInfo[] arguments, void* args)",
"comment" : "\n Scan a string from the input using a similar form to C's scanf\n and <a href=\"std_format.html\">std.format<\/a>.\n\n An argument of type string is interpreted as a format string.\n All other arguments must be pointer types.\n If a format string is not present a default will be supplied computed from\n the base type of the pointer type. An argument of type string* is filled\n (possibly with appending characters) and a slice of the result is assigned\n back into the argument. For example the following readf statements\n are equivalent:\n --------------------------\n int x;\n double y;\n string s;\n file.readf(&x, \" hello \", &y, &s);\n file.readf(\"%d hello %f %s\", &x, &y, &s);\n file.readf(\"%d hello %f\", &x, &y, \"%s\", &s);\n --------------------------\n   \n",
"line" : 238}
,
{
"name" : "readf",
"kind" : "function",
"protection" : "public",
"type" : "int(...)",
"comment" : " ditto\n",
"line" : 239}
,
{
"name" : "available",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"comment" : " Retrieve the number of bytes available for immediate reading.\n",
"line" : 242}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"comment" : "\n Return whether the current file position is the same as the end of the\n file.\n\n This does not require actually reading past the end, as with stdio. For\n non-seekable streams this might only return true after attempting to read\n past the end.\n   \n",
"line" : 253}
,
{
"name" : "isOpen",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " Return true if the stream is currently open.\n",
"line" : 255}
]
}
,
{
"name" : "OutputStream",
"kind" : "interface",
"protection" : "public",
"comment" : " Interface for writable streams.\n",
"line" : 259,
"members" : [
{
"name" : "writeExact",
"kind" : "function",
"protection" : "public",
"type" : "void(const(void*) buffer, ulong size)",
"comment" : "\n Write exactly size bytes from buffer, or throw a WriteException if that\n could not be done.\n   \n",
"line" : 265}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(ubyte)[] buffer)",
"comment" : "\n Write as much of the buffer as possible,\n returning the number of bytes written.\n   \n",
"line" : 271}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(byte x)",
"comment" : "\n Write a basic type.\n\n Outside of byte, ubyte, and char, the format is implementation-specific\n and should only be used in conjunction with read.\n Throw WriteException on error.\n   \n",
"line" : 280}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte x)",
"comment" : " ditto\n",
"line" : 281}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(short x)",
"comment" : " ditto\n",
"line" : 282}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ushort x)",
"comment" : " ditto\n",
"line" : 283}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(int x)",
"comment" : " ditto\n",
"line" : 284}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(uint x)",
"comment" : " ditto\n",
"line" : 285}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(long x)",
"comment" : " ditto\n",
"line" : 286}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong x)",
"comment" : " ditto\n",
"line" : 287}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(float x)",
"comment" : " ditto\n",
"line" : 288}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(double x)",
"comment" : " ditto\n",
"line" : 289}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(real x)",
"comment" : " ditto\n",
"line" : 290}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ifloat x)",
"comment" : " ditto\n",
"line" : 291}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(idouble x)",
"comment" : " ditto\n",
"line" : 292}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ireal x)",
"comment" : " ditto\n",
"line" : 293}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(cfloat x)",
"comment" : " ditto\n",
"line" : 294}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(cdouble x)",
"comment" : " ditto\n",
"line" : 295}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(creal x)",
"comment" : " ditto\n",
"line" : 296}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(char x)",
"comment" : " ditto\n",
"line" : 297}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(wchar x)",
"comment" : " ditto\n",
"line" : 298}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(dchar x)",
"comment" : " ditto\n",
"line" : 299}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"comment" : "\n Writes a string, together with its length.\n\n The format is implementation-specific\n and should only be used in conjunction with read.\n Throw WriteException on error.\n   \n",
"line" : 308}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"comment" : " ditto\n",
"line" : 309}
,
{
"name" : "writeLine",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"comment" : "\n Write a line of text,\n appending the line with an operating-system-specific line ending.\n\n Throws WriteException on error.\n   \n",
"line" : 317}
,
{
"name" : "writeLineW",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"comment" : "\n Write a line of text,\n appending the line with an operating-system-specific line ending.\n\n The format is implementation-specific.\n Throws WriteException on error.\n   \n",
"line" : 326}
,
{
"name" : "writeString",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"comment" : "\n Write a string of text.\n\n Throws WriteException if it could not be fully written.\n   \n",
"line" : 333}
,
{
"name" : "writeStringW",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"comment" : "\n Write a string of text.\n\n The format is implementation-specific.\n Throws WriteException if it could not be fully written.\n   \n",
"line" : 341}
,
{
"name" : "vprintf",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(char)[] format, void* args)",
"comment" : "\n Print a formatted string into the stream using printf-style syntax,\n returning the number of bytes written.\n   \n",
"line" : 347}
,
{
"name" : "printf",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(char)[] format,...)",
"comment" : " ditto\n",
"line" : 348}
,
{
"name" : "writef",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream(...)",
"comment" : "\n Print a formatted string into the stream using writef-style syntax.\n References: <a href=\"std_format.html\">std.format<\/a>.\n Returns: self to chain with other stream commands like flush.\n   \n",
"line" : 355}
,
{
"name" : "writefln",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream(...)",
"comment" : " ditto\n",
"line" : 356}
,
{
"name" : "writefx",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream(TypeInfo[] arguments, void* argptr, int newline = cast(int)false)",
"comment" : " ditto\n",
"line" : 357}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " Flush pending output if appropriate.\n",
"line" : 359}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " Close the stream, flushing output if appropriate.\n",
"line" : 360}
,
{
"name" : "isOpen",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"comment" : " Return true if the stream is currently open.\n",
"line" : 361}
]
}
,
{
"name" : "Stream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Stream is the base abstract class from which the other stream classes derive.\n\n Stream's byte order is the format native to the computer.\n\n Reading:\n These methods require that the readable flag be set.\n Problems with reading result in a ReadException being thrown.\n Stream implements the InputStream interface in addition to the\n readBlock method.\n\n Writing:\n These methods require that the writeable flag be set. Problems with writing\n result in a WriteException being thrown. Stream implements the OutputStream\n interface in addition to the following methods:\n writeBlock\n copyFrom\n copyFrom\n\n Seeking:\n These methods require that the seekable flag be set.\n Problems with seeking result in a SeekException being thrown.\n seek, seekSet, seekCur, seekEnd, position, size, toString, toHash\n \n",
"line" : 391,
"base" : "Object",
"interfaces" : [
"InputStream",
"OutputStream"],
"members" : [
{
"name" : "readable",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"comment" : " Indicates whether this stream can be read from.\n",
"line" : 395}
,
{
"name" : "writeable",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"comment" : " Indicates whether this stream can be written to.\n",
"line" : 396}
,
{
"name" : "seekable",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"comment" : " Indicates whether this stream can be seeked within.\n",
"line" : 397}
,
{
"name" : "isopen",
"kind" : "variable",
"protection" : "protected",
"type" : "bool",
"comment" : " Indicates whether this stream is open.\n",
"line" : 398}
,
{
"name" : "readEOF",
"kind" : "variable",
"protection" : "protected",
"type" : "bool",
"comment" : " Indicates whether this stream is at eof\n after the last read attempt.\n                                   \n",
"line" : 400}
,
{
"name" : "prevCr",
"kind" : "variable",
"protection" : "protected",
"type" : "bool",
"comment" : " For a non-seekable stream indicates that\n the last readLine or readLineW ended on a\n '\\r' character.\n                                  \n",
"line" : 404}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Stream()",
"line" : 409}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* buffer, ulong size)",
"comment" : "\n Read up to size bytes into the buffer and return the number of bytes\n actually read. A return value of 0 indicates end-of-file.\n   \n",
"line" : 415}
,
{
"name" : "readExact",
"kind" : "function",
"protection" : "public",
"type" : "void(void* buffer, ulong size)",
"line" : 419}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "ulong(ubyte[] buffer)",
"line" : 433}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out byte x)",
"line" : 439}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ubyte x)",
"line" : 440}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out short x)",
"line" : 441}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ushort x)",
"line" : 442}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out int x)",
"line" : 443}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out uint x)",
"line" : 444}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out long x)",
"line" : 445}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ulong x)",
"line" : 446}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out float x)",
"line" : 447}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out double x)",
"line" : 448}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out real x)",
"line" : 449}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ifloat x)",
"line" : 450}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out idouble x)",
"line" : 451}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ireal x)",
"line" : 452}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out cfloat x)",
"line" : 453}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out cdouble x)",
"line" : 454}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out creal x)",
"line" : 455}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out char x)",
"line" : 456}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out wchar x)",
"line" : 457}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out dchar x)",
"line" : 458}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out char[] s)",
"line" : 461}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out wchar[] s)",
"line" : 468}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "char[]()",
"line" : 475}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "char[](char[] result)",
"line" : 482}
,
{
"name" : "readLineW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[]()",
"line" : 518}
,
{
"name" : "readLineW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[](wchar[] result)",
"line" : 525}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref char[] line) dg)",
"line" : 559}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref ulong n, ref char[] line) dg)",
"line" : 571}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref wchar[] line) dg)",
"line" : 585}
,
{
"name" : "opApply",
"kind" : "function",
"protection" : "public",
"type" : "int(scope int delegate(ref ulong n, ref wchar[] line) dg)",
"line" : 597}
,
{
"name" : "readString",
"kind" : "function",
"protection" : "public",
"type" : "char[](ulong length)",
"line" : 612}
,
{
"name" : "readStringW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[](ulong length)",
"line" : 620}
,
{
"name" : "unget",
"kind" : "variable",
"protection" : "private",
"type" : "wchar[]",
"line" : 627}
,
{
"name" : "ungetAvailable",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 628}
,
{
"name" : "getc",
"kind" : "function",
"protection" : "public",
"type" : "char()",
"line" : 633}
,
{
"name" : "getcw",
"kind" : "function",
"protection" : "public",
"type" : "wchar()",
"line" : 653}
,
{
"name" : "ungetc",
"kind" : "function",
"protection" : "public",
"type" : "char(char c)",
"line" : 675}
,
{
"name" : "ungetcw",
"kind" : "function",
"protection" : "public",
"type" : "wchar(wchar c)",
"line" : 686}
,
{
"name" : "vreadf",
"kind" : "function",
"protection" : "public",
"type" : "int(TypeInfo[] arguments, void* args)",
"line" : 695}
,
{
"name" : "readf",
"kind" : "function",
"protection" : "public",
"type" : "int(...)",
"line" : 1031}
,
{
"name" : "available",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 1036}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) buffer, ulong size)",
"comment" : "\n Write up to size bytes from buffer in the stream, returning the actual\n number of bytes that were written.\n   \n",
"line" : 1042}
,
{
"name" : "writeExact",
"kind" : "function",
"protection" : "public",
"type" : "void(const(void*) buffer, ulong size)",
"line" : 1046}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(ubyte)[] buffer)",
"line" : 1061}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(byte x)",
"line" : 1067}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte x)",
"line" : 1068}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(short x)",
"line" : 1069}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ushort x)",
"line" : 1070}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(int x)",
"line" : 1071}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(uint x)",
"line" : 1072}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(long x)",
"line" : 1073}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong x)",
"line" : 1074}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(float x)",
"line" : 1075}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(double x)",
"line" : 1076}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(real x)",
"line" : 1077}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ifloat x)",
"line" : 1078}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(idouble x)",
"line" : 1079}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ireal x)",
"line" : 1080}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(cfloat x)",
"line" : 1081}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(cdouble x)",
"line" : 1082}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(creal x)",
"line" : 1083}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(char x)",
"line" : 1084}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(wchar x)",
"line" : 1085}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(dchar x)",
"line" : 1086}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"line" : 1089}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"line" : 1095}
,
{
"name" : "writeLine",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"line" : 1101}
,
{
"name" : "writeLineW",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"line" : 1112}
,
{
"name" : "writeString",
"kind" : "function",
"protection" : "public",
"type" : "void(const(char)[] s)",
"line" : 1123}
,
{
"name" : "writeStringW",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] s)",
"line" : 1128}
,
{
"name" : "vprintf",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(char)[] format, void* args)",
"line" : 1134}
,
{
"name" : "printf",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(char)[] format,...)",
"line" : 1168}
,
{
"name" : "doFormatCallback",
"kind" : "function",
"protection" : "private",
"type" : "void(dchar c)",
"line" : 1183}
,
{
"name" : "writef",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream(...)",
"line" : 1190}
,
{
"name" : "writefln",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream(...)",
"line" : 1195}
,
{
"name" : "writefx",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream(TypeInfo[] arguments, void* argptr, int newline = cast(int)false)",
"line" : 1200}
,
{
"name" : "copyFrom",
"kind" : "function",
"protection" : "public",
"type" : "void(Stream s)",
"comment" : "\n Copies all data from s into this stream.\n This may throw ReadException or WriteException on failure.\n This restores the file position of s so that it is unchanged.\n   \n",
"line" : 1212}
,
{
"name" : "copyFrom",
"kind" : "function",
"protection" : "public",
"type" : "void(Stream s, ulong count)",
"comment" : "\n Copy a specified number of bytes from the given stream into this one.\n This may throw ReadException or WriteException on failure.\n Unlike the previous form, this doesn't restore the file position of s.\n   \n",
"line" : 1232}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos whence)",
"comment" : "\n Change the current position of the stream. whence is either SeekPos.Set, in\n   which case the offset is an absolute index from the beginning of the stream,\n   SeekPos.Current, in which case the offset is a delta from the current\n   position, or SeekPos.End, in which case the offset is a delta from the end of\n   the stream (negative or zero offsets only make sense in that case). This\n   returns the new file position.\n   \n",
"line" : 1250}
,
{
"name" : "seekSet",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset)",
"comment" : "\n Aliases for their normal seek counterparts.\n   \n",
"line" : 1255}
,
{
"name" : "seekCur",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset)",
"comment" : " ditto\n",
"line" : 1256}
,
{
"name" : "seekEnd",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset)",
"comment" : " ditto\n",
"line" : 1257}
,
{
"name" : "position",
"kind" : "function",
"protection" : "public",
"type" : "@property void(ulong pos)",
"comment" : "\n Sets file position. Equivalent to calling seek(pos, SeekPos.Set).\n   \n",
"line" : 1262}
,
{
"name" : "position",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"comment" : "\n Returns current file position. Equivalent to seek(0, SeekPos.Current).\n   \n",
"line" : 1267}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"comment" : "\n Retrieve the size of the stream in bytes.\n The stream must be seekable or a SeekException is thrown.\n   \n",
"line" : 1273}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 1281}
,
{
"name" : "isOpen",
"kind" : "function",
"protection" : "public",
"type" : "@property bool()",
"line" : 1292}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1295}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1301}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Read the entire stream and return it as a string.\n If the stream is not seekable the contents from the current position to eof\n is read and returned.\n   \n",
"line" : 1312}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @trusted ulong()",
"comment" : "\n Get a hash of the stream by reading each byte and using it in a CRC-32\n checksum.\n   \n",
"line" : 1353}
,
{
"name" : "assertReadable",
"kind" : "function",
"protection" : "protected",
"type" : "void()",
"line" : 1378}
,
{
"name" : "assertWriteable",
"kind" : "function",
"protection" : "protected",
"type" : "void()",
"line" : 1383}
,
{
"name" : "assertSeekable",
"kind" : "function",
"protection" : "protected",
"type" : "void()",
"line" : 1388}
]
}
,
{
"name" : "FilterStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n A base class for streams that wrap a source stream with additional\n functionality.\n\n The method implementations forward read\/write\/seek calls to the\n source stream. A FilterStream can change the position of the source stream\n arbitrarily and may not keep the source stream state in sync with the\n FilterStream, even upon flushing and closing the FilterStream. It is\n recommended to not make any assumptions about the state of the source position\n and read\/write state after a FilterStream has acted upon it. Specifc subclasses\n of FilterStream should document how they modify the source stream and if any\n invariants hold true between the source and filter.\n \n",
"line" : 1407,
"base" : "Stream",
"members" : [
{
"name" : "s",
"kind" : "variable",
"protection" : "private",
"type" : "std.stream.Stream",
"line" : 1408}
,
{
"name" : "nestClose",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"comment" : " Property indicating when this stream closes to close the source stream as\n well.\n Defaults to true.\n",
"line" : 1413}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FilterStream(Stream source)",
"comment" : " Construct a FilterStream for the given source.\n",
"line" : 1416}
,
{
"name" : "source",
"kind" : "function",
"protection" : "public",
"type" : "Stream()",
"comment" : "\n Get the current source stream.\n   \n",
"line" : 1426}
,
{
"name" : "source",
"kind" : "function",
"protection" : "public",
"type" : "void(Stream s)",
"comment" : "\n Set the current source stream.\n\n Setting the source stream closes this stream before attaching the new\n source. Attaching an open stream reopens this stream and resets the stream\n state.\n   \n",
"line" : 1435}
,
{
"name" : "resetSource",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Indicates the source stream changed state and that this stream should reset\n any readable, writeable, seekable, isopen and buffering flags.\n   \n",
"line" : 1445}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* buffer, ulong size)",
"line" : 1459}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) buffer, ulong size)",
"line" : 1466}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1471}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos whence)",
"line" : 1480}
,
{
"name" : "available",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 1485}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1486}
]
}
,
{
"name" : "BufferedStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n This subclass is for buffering a source stream.\n\n A buffered stream must be\n closed explicitly to ensure the final buffer content is written to the source\n stream. The source stream position is changed according to the block size so\n reading or writing to the BufferedStream may not change the source stream\n position by the same amount.\n \n",
"line" : 1498,
"base" : "FilterStream",
"members" : [
{
"name" : "buffer",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[]",
"line" : 1499}
,
{
"name" : "bufferCurPos",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 1500}
,
{
"name" : "bufferLen",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 1501}
,
{
"name" : "bufferDirty",
"kind" : "variable",
"protection" : "public",
"type" : "bool",
"line" : 1502}
,
{
"name" : "bufferSourcePos",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 1503}
,
{
"name" : "streamPos",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 1504}
,
{
"name" : "DefaultBufferSize",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 1522}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedStream(Stream source, ulong bufferSize = 8192LU)",
"comment" : "\n Create a buffered stream for the stream source with the buffer size\n bufferSize.\n   \n",
"line" : 1528}
,
{
"name" : "resetSource",
"kind" : "function",
"protection" : "protected",
"type" : "void()",
"line" : 1534}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* result, ulong len)",
"line" : 1543}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) result, ulong len)",
"line" : 1592}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos whence)",
"line" : 1645}
,
{
"name" : "TreadLine(T)",
"kind" : "template",
"protection" : "public",
"line" : 1664,
"members" : [
{
"name" : "readLine",
"kind" : "function",
"type" : "T[](T[] inBuffer)",
"line" : 1665}
]
}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "char[](char[] inBuffer)",
"line" : 1712}
,
{
"name" : "readLine",
"kind" : "alias",
"protection" : "public",
"line" : 1718}
,
{
"name" : "readLineW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[](wchar[] inBuffer)",
"line" : 1720}
,
{
"name" : "readLineW",
"kind" : "alias",
"protection" : "public",
"line" : 1726}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 1728}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 1758}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 1775}
,
{
"name" : "available",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 1781}
]
}
,
{
"name" : "StreamFileException",
"kind" : "class",
"protection" : "public",
"comment" : " An exception for File errors.\n",
"line" : 1787,
"base" : "StreamException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StreamFileException(string msg)",
"comment" : " Construct a StreamFileException with given error message.\n",
"line" : 1789}
]
}
,
{
"name" : "OpenException",
"kind" : "class",
"protection" : "public",
"comment" : " An exception for errors during File.open.\n",
"line" : 1793,
"base" : "StreamFileException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OpenException(string msg)",
"comment" : " Construct an OpenFileException with given error message.\n",
"line" : 1795}
]
}
,
{
"name" : "FileMode",
"kind" : "enum",
"protection" : "public",
"line" : 1799,
"base" : "int",
"members" : [
{
"name" : "In",
"kind" : "enum member",
"protection" : "public",
"line" : 1800}
,
{
"name" : "Out",
"kind" : "enum member",
"protection" : "public",
"line" : 1801}
,
{
"name" : "OutNew",
"kind" : "enum member",
"protection" : "public",
"line" : 1802}
,
{
"name" : "Append",
"kind" : "enum member",
"protection" : "public",
"line" : 1803}
]
}
,
{
"name" : "HANDLE",
"kind" : "alias",
"protection" : "public",
"type" : "int",
"line" : 1816}
,
{
"name" : "File",
"kind" : "class",
"protection" : "public",
"comment" : " This subclass is for unbuffered file system streams.\n",
"line" : 1820,
"base" : "Stream",
"members" : [
{
"name" : "hFile",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 1826}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "File()",
"line" : 1829}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "File(int hFile, FileMode mode)",
"line" : 1841}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "File(string filename, FileMode mode = cast(FileMode)1)",
"comment" : "\n Create the stream with no open file, an open file in read mode, or an open\n file with explicit file mode.\n mode, if given, is a combination of FileMode.In\n (indicating a file that can be read) and FileMode.Out (indicating a file\n that can be written).\n Opening a file for reading that doesn't exist will error.\n Opening a file for writing that doesn't exist will create the file.\n The FileMode.OutNew mode will open the file for writing and reset the\n length to zero.\n The FileMode.Append mode will open the file for writing and move the\n file position to the end of the file.\n   \n",
"line" : 1867}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "void(string filename, FileMode mode = cast(FileMode)1)",
"comment" : "\n Open a file for the stream, in an identical manner to the constructors.\n If an error occurs an OpenException is thrown.\n   \n",
"line" : 1878}
,
{
"name" : "parseMode",
"kind" : "function",
"protection" : "private",
"type" : "void(int mode, out int access, out int share, out int createMode)",
"line" : 1901}
,
{
"name" : "create",
"kind" : "function",
"protection" : "public",
"type" : "void(string filename)",
"comment" : " Create a file for writing.\n",
"line" : 1938}
,
{
"name" : "create",
"kind" : "function",
"protection" : "public",
"type" : "void(string filename, FileMode mode)",
"comment" : " ditto\n",
"line" : 1943}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " Close the current file if it is open; otherwise it does nothing.\n",
"line" : 1949}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* buffer, ulong size)",
"line" : 1977}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) buffer, ulong size)",
"line" : 1992}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos rel)",
"line" : 2006}
,
{
"name" : "available",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"comment" : "\n For a seekable file returns the difference of the size and position and\n otherwise returns 0.\n   \n",
"line" : 2028}
,
{
"name" : "handle",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"line" : 2039}
]
}
,
{
"name" : "BufferedFile",
"kind" : "class",
"protection" : "public",
"comment" : "\n This subclass is for buffered file system streams.\n\n It is a convenience class for wrapping a File in a BufferedStream.\n A buffered stream must be closed explicitly to ensure the final buffer\n content is written to the file.\n \n",
"line" : 2123,
"base" : "BufferedStream",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedFile()",
"comment" : " opens file for reading\n",
"line" : 2126}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedFile(string filename, FileMode mode = cast(FileMode)1, ulong bufferSize = 8192LU)",
"comment" : " opens file in requested mode and buffer size\n",
"line" : 2129}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedFile(File file, ulong bufferSize = 8192LU)",
"comment" : " opens file for reading with requested buffer size\n",
"line" : 2135}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedFile(int hFile, FileMode mode, ulong buffersize)",
"comment" : " opens existing handle; use with care!\n",
"line" : 2140}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "void(string filename, FileMode mode = cast(FileMode)1)",
"comment" : " opens file in requested mode\n",
"line" : 2145}
,
{
"name" : "create",
"kind" : "function",
"protection" : "public",
"type" : "void(string filename, FileMode mode = cast(FileMode)6)",
"comment" : " creates file in requested mode\n",
"line" : 2152}
]
}
,
{
"name" : "BOM",
"kind" : "enum",
"protection" : "public",
"comment" : " UTF byte-order-mark signatures\n",
"line" : 2210,
"base" : "int",
"members" : [
{
"name" : "UTF8",
"kind" : "enum member",
"protection" : "public",
"comment" : " UTF-8\n",
"line" : 2211}
,
{
"name" : "UTF16LE",
"kind" : "enum member",
"protection" : "public",
"comment" : " UTF-16 Little Endian\n",
"line" : 2212}
,
{
"name" : "UTF16BE",
"kind" : "enum member",
"protection" : "public",
"comment" : " UTF-16 Big Endian\n",
"line" : 2213}
,
{
"name" : "UTF32LE",
"kind" : "enum member",
"protection" : "public",
"comment" : " UTF-32 Little Endian\n",
"line" : 2214}
,
{
"name" : "UTF32BE",
"kind" : "enum member",
"protection" : "public",
"comment" : " UTF-32 Big Endian\n",
"line" : 2215}
]
}
,
{
"name" : "NBOMS",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 2218}
,
{
"name" : "BOMEndian",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(Endian[5LU])",
"line" : 2219}
,
{
"name" : "ByteOrderMarks",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(ubyte[][5LU])",
"line" : 2225}
,
{
"name" : "EndianStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n This subclass wraps a stream with big-endian or little-endian byte order\n swapping.\n\n UTF Byte-Order-Mark (BOM) signatures can be read and deduced or\n written.\n Note that an EndianStream should not be used as the source of another\n FilterStream since a FilterStream call the source with byte-oriented\n read\/write requests and the EndianStream will not perform any byte swapping.\n The EndianStream reads and writes binary data (non-getc functions) in a\n one-to-one\n manner with the source stream so the source stream's position and state will be\n kept in sync with the EndianStream if only non-getc functions are called.\n \n",
"line" : 2248,
"base" : "FilterStream",
"members" : [
{
"name" : "endian",
"kind" : "variable",
"protection" : "public",
"type" : "Endian",
"comment" : " Endianness property of the source stream.\n",
"line" : 2250}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "EndianStream(Stream source, Endian end = endian)",
"comment" : "\n Create the endian stream for the source stream source with endianness end.\n The default endianness is the native byte order.\n The Endian type is defined\n in the std.system module.\n   \n",
"line" : 2258}
,
{
"name" : "readBOM",
"kind" : "function",
"protection" : "public",
"type" : "int(int ungetCharSize = 1)",
"comment" : "\n Return -1 if no BOM and otherwise read the BOM and return it.\n\n If there is no BOM or if bytes beyond the BOM are read then the bytes read\n are pushed back onto the ungetc buffer or ungetcw buffer.\n Pass ungetCharSize == 2 to use\n ungetcw instead of ungetc when no BOM is present.\n   \n",
"line" : 2271}
,
{
"name" : "fixBO",
"kind" : "function",
"protection" : "public",
"type" : "void(const(void)* buffer, ulong size)",
"comment" : "\n Correct the byte order of buffer to match native endianness.\n size must be even.\n   \n",
"line" : 2315}
,
{
"name" : "fixBlockBO",
"kind" : "function",
"protection" : "public",
"type" : "void(void* buffer, uint size, ulong repeat)",
"comment" : "\n Correct the byte order of the given buffer in blocks of the given size and\n repeated the given number of times.\n size must be even.\n   \n",
"line" : 2355}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out byte x)",
"line" : 2362}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ubyte x)",
"line" : 2363}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out short x)",
"line" : 2364}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ushort x)",
"line" : 2365}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out int x)",
"line" : 2366}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out uint x)",
"line" : 2367}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out long x)",
"line" : 2368}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ulong x)",
"line" : 2369}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out float x)",
"line" : 2370}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out double x)",
"line" : 2371}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out real x)",
"line" : 2372}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ifloat x)",
"line" : 2373}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out idouble x)",
"line" : 2374}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out ireal x)",
"line" : 2375}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out cfloat x)",
"line" : 2376}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out cdouble x)",
"line" : 2377}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out creal x)",
"line" : 2378}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out char x)",
"line" : 2379}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out wchar x)",
"line" : 2380}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "void(out dchar x)",
"line" : 2381}
,
{
"name" : "getcw",
"kind" : "function",
"protection" : "public",
"type" : "wchar()",
"line" : 2383}
,
{
"name" : "readStringW",
"kind" : "function",
"protection" : "public",
"type" : "wchar[](ulong length)",
"line" : 2404}
,
{
"name" : "writeBOM",
"kind" : "function",
"protection" : "public",
"type" : "void(BOM b)",
"comment" : " Write the specified BOM b to the source stream.\n",
"line" : 2412}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(byte x)",
"line" : 2417}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte x)",
"line" : 2418}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(short x)",
"line" : 2419}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ushort x)",
"line" : 2420}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(int x)",
"line" : 2421}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(uint x)",
"line" : 2422}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(long x)",
"line" : 2423}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong x)",
"line" : 2424}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(float x)",
"line" : 2425}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(double x)",
"line" : 2426}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(real x)",
"line" : 2427}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ifloat x)",
"line" : 2428}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(idouble x)",
"line" : 2429}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(ireal x)",
"line" : 2430}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(cfloat x)",
"line" : 2431}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(cdouble x)",
"line" : 2432}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(creal x)",
"line" : 2433}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(char x)",
"line" : 2434}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(wchar x)",
"line" : 2435}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "void(dchar x)",
"line" : 2436}
,
{
"name" : "writeStringW",
"kind" : "function",
"protection" : "public",
"type" : "void(const(wchar)[] str)",
"line" : 2438}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 2445}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 2446}
]
}
,
{
"name" : "TArrayStream(Buffer)",
"kind" : "class",
"protection" : "public",
"comment" : "\n Parameterized subclass that wraps an array-like buffer with a stream\n interface.\n\n The type Buffer must support the length property, opIndex and opSlice.\n Compile in release mode when directly instantiating a TArrayStream to avoid\n link errors.\n \n",
"line" : 2541,
"members" : [
{
"name" : "TArrayStream",
"kind" : "class",
"protection" : "public",
"line" : 2541,
"members" : [
{
"name" : "buf",
"kind" : "variable",
"type" : "Buffer",
"line" : 2542}
,
{
"name" : "len",
"kind" : "variable",
"type" : "ulong",
"line" : 2543}
,
{
"name" : "cur",
"kind" : "variable",
"type" : "ulong",
"line" : 2544}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(Buffer buf)",
"comment" : " Create the stream for the the buffer buf. Non-copying.\n",
"line" : 2547}
,
{
"name" : "readBlock",
"kind" : "function",
"type" : "size_t(void* buffer, size_t size)",
"line" : 2560}
,
{
"name" : "writeBlock",
"kind" : "function",
"type" : "size_t(const void* buffer, size_t size)",
"line" : 2571}
,
{
"name" : "seek",
"kind" : "function",
"type" : "ulong(long offset, SeekPos rel)",
"line" : 2585}
,
{
"name" : "available",
"kind" : "function",
"type" : "size_t()",
"line" : 2607}
,
{
"name" : "data",
"kind" : "function",
"type" : "ubyte[]()",
"comment" : " Get the current memory data in total.\n",
"line" : 2610}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"line" : 2617}
]
}
]
}
,
{
"name" : "MemoryStream",
"kind" : "class",
"protection" : "public",
"comment" : " This subclass reads and constructs an array of bytes in memory.\n",
"line" : 2653,
"base" : "TArrayStream",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryStream()",
"comment" : " Create the output buffer and setup for reading, writing, and seeking.\n",
"line" : 2657}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryStream(ubyte[] buf)",
"comment" : "\n Create the output buffer and setup for reading, writing, and seeking.\n Load it with specific input data.\n   \n",
"line" : 2663}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryStream(byte[] buf)",
"comment" : " ditto\n",
"line" : 2664}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryStream(char[] buf)",
"comment" : " ditto\n",
"line" : 2665}
,
{
"name" : "reserve",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong count)",
"comment" : " Ensure the stream can hold count bytes.\n",
"line" : 2668}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) buffer, ulong size)",
"line" : 2673}
]
}
,
{
"name" : "MmFileStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n This subclass wraps a memory-mapped file with the stream API.\n See std.mmfile module.\n \n",
"line" : 2730,
"base" : "TArrayStream",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MmFileStream(MmFile file)",
"comment" : " Create stream wrapper for file.\n",
"line" : 2733}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 2739}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 2746}
]
}
,
{
"name" : "SliceStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n This subclass slices off a portion of another stream, making seeking relative\n to the boundaries of the slice.\n\n It could be used to section a large file into a\n set of smaller files, such as with tar archives. Reading and writing a\n SliceStream does not modify the position of the source stream if it is\n seekable.\n \n",
"line" : 2795,
"base" : "FilterStream",
"members" : [
{
"name" : "pos",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 2797}
,
{
"name" : "low",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 2798}
,
{
"name" : "high",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 2799}
,
{
"name" : "bounded",
"kind" : "variable",
"protection" : "private",
"type" : "bool",
"line" : 2800}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SliceStream(Stream s, ulong low)",
"comment" : "\n Indicate both the source stream to use for reading from and the low part of\n the slice.\n\n The high part of the slice is dependent upon the end of the source\n stream, so that if you write beyond the end it resizes the stream normally.\n   \n",
"line" : 2810}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SliceStream(Stream s, ulong low, ulong high)",
"comment" : "\n Indicate the high index as well.\n\n Attempting to read or write past the high\n index results in the end being clipped off.\n   \n",
"line" : 2827}
,
{
"name" : "readBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* buffer, ulong size)",
"line" : 2847}
,
{
"name" : "writeBlock",
"kind" : "function",
"protection" : "public",
"type" : "ulong(const(void*) buffer, ulong size)",
"line" : 2862}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(long offset, SeekPos rel)",
"line" : 2877}
,
{
"name" : "available",
"kind" : "function",
"protection" : "public",
"type" : "@property ulong()",
"line" : 2911}
]
}
]
}
,
{
"name" : "std.string",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/string.d",
"comment" : "\nString handling functions. Objects of types $(D _string), $(D\nwstring), and $(D dstring) are value types and cannot be mutated\nelement-by-element. For using mutation during building strings, use\n$(D char[]), $(D wchar[]), or $(D dchar[]). The $(D *_string) types\nare preferable because they don't exhibit undesired aliasing, thus\nmaking code more robust.\n\nMacros: WIKI = Phobos\/StdString\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense: $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB digitalmars.com, Walter Bright),\n         $(WEB erdani.org, Andrei Alexandrescu),\n         and Jonathan M Davis\n\nSource:    $(PHOBOSSRC std\/_string.d)\n\n",
"members" : [
{
"name" : "StringException",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Exception thrown on errors in std.string functions.\n  \n",
"line" : 52,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringException(string msg, string file = __FILE__, ulong line = cast(ulong)__LINE__, Throwable next = null)",
"comment" : "\n        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      \n",
"line" : 61}
]
}
,
{
"name" : "hexdigits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[16LU])",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, hexDigits) instead.)\n\n    0..9A..F\n  \n",
"line" : 78}
,
{
"name" : "digits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[])",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, _digits) instead.)\n\n    0..9\n  \n",
"line" : 86}
,
{
"name" : "octdigits",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[8LU])",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, octDigits) instead.)\n\n    0..7\n  \n",
"line" : 94}
,
{
"name" : "lowercase",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[26LU])",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, _lowercase) instead.)\n\n    a..z\n  \n",
"line" : 102}
,
{
"name" : "letters",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[52LU])",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, _letters) instead.)\n\n    A..Za..z\n  \n",
"line" : 110}
,
{
"name" : "uppercase",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[26LU])",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, _uppercase) instead.)\n\n    A..Z\n  \n",
"line" : 119}
,
{
"name" : "whitespace",
"kind" : "alias",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, _whitespace) instead.)\n\n    ASCII whitespace.\n  \n",
"line" : 127}
,
{
"name" : "LS",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF uni, lineSep) instead.)\n\n    UTF line separator.\n  \n",
"line" : 135}
,
{
"name" : "PS",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF uni, paraSep) instead.)\n\n    UTF paragraph separator.\n  \n",
"line" : 143}
,
{
"name" : "newline",
"kind" : "alias",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(XREF ascii, _newline) instead.)\n\n    Newline sequence for this system.\n  \n",
"line" : 151}
,
{
"name" : "iswhite(C) if (is(Unqual!(C) : dchar))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012.\n       Please use $(XREF ascii, isWhite) or $(XREF uni, isWhite) instead.)\n\n Returns true if c is ASCII whitespace or unicode LS or PS.\n \n",
"line" : 160,
"members" : [
{
"name" : "iswhite",
"kind" : "function",
"type" : "bool(C c)",
"line" : 160}
]
}
,
{
"name" : "icmp(alias pred = \"a < b\",S1,S2) if (isSomeString!(S1) && isSomeString!(S2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Compares two ranges of characters lexicographically. The comparison is\n    case insensitive. Use $(D XREF algorithm, cmp) for a case sensitive\n    comparison. $(D icmp) works like $(D XREF algorithm, cmp) except that it\n    converts characters to lowercase prior to applying ($D pred). Technically,\n    $(D icmp(r1, r2)) is equivalent to\n    $(D cmp!\"std.uni.toLower(a) < std.uni.toLower(b)\"(r1, r2)).\n\n    $(BOOKTABLE,\n        $(TR $(TD $(D < 0))  $(TD $(D s1 < s2) ))\n        $(TR $(TD $(D = 0))  $(TD $(D s1 == s2)))\n        $(TR $(TD $(D > 0))  $(TD $(D s1 > s2)))\n     )\n  \n",
"line" : 183,
"members" : [
{
"name" : "icmp",
"kind" : "function",
"type" : "int(S1 s1, S2 s2)",
"comment" : "\n    Compares two ranges of characters lexicographically. The comparison is\n    case insensitive. Use $(D XREF algorithm, cmp) for a case sensitive\n    comparison. $(D icmp) works like $(D XREF algorithm, cmp) except that it\n    converts characters to lowercase prior to applying ($D pred). Technically,\n    $(D icmp(r1, r2)) is equivalent to\n    $(D cmp!\"std.uni.toLower(a) < std.uni.toLower(b)\"(r1, r2)).\n\n    $(BOOKTABLE,\n        $(TR $(TD $(D < 0))  $(TD $(D s1 < s2) ))\n        $(TR $(TD $(D = 0))  $(TD $(D s1 == s2)))\n        $(TR $(TD $(D > 0))  $(TD $(D s1 > s2)))\n     )\n  \n",
"line" : 183}
]
}
,
{
"name" : "icmp(alias pred = \"a < b\",S1,S2) if (!(isSomeString!(S1) && isSomeString!(S2)) && isForwardRange!(S1) && is(Unqual!(ElementType!(S1)) == dchar) && isForwardRange!(S2) && is(Unqual!(ElementType!(S2)) == dchar))",
"kind" : "template",
"protection" : "public",
"line" : 218,
"members" : [
{
"name" : "icmp",
"kind" : "function",
"type" : "int(S1 s1, S2 s2)",
"line" : 218}
]
}
,
{
"name" : "toStringz",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow immutable(char)*(const(char)[] s)",
"comment" : "\n    Returns a C-style zero-terminated string equivalent to $(D s). $(D s)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D s.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(RED Important Note:) When passing a $(D char*) to a C function, and the C\n    function keeps it around for any reason, make sure that you keep a reference\n    to it in your D code. Otherwise, it may go away during a garbage collection\n    cycle and cause a nasty bug when the C code tries to use it.\n  \n",
"line" : 315}
,
{
"name" : "toStringz",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow immutable(char)*(string s)",
"comment" : " Ditto \n",
"line" : 358}
,
{
"name" : "CaseSensitive",
"kind" : "enum",
"protection" : "public",
"comment" : "\n   Flag indicating whether a search is case-sensitive.\n",
"line" : 404,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"line" : 404}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"line" : 404}
]
}
,
{
"name" : "indexOf(Char) if (isSomeChar!(Char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the index of the first occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 412,
"members" : [
{
"name" : "indexOf",
"kind" : "function",
"type" : "pure sizediff_t(in Char[] s, dchar c, CaseSensitive cs = CaseSensitive.yes)",
"comment" : "\n    Returns the index of the first occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 412}
]
}
,
{
"name" : "indexOf(Char1,Char2) if (isSomeChar!(Char1) && isSomeChar!(Char2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the index of the first occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 502,
"members" : [
{
"name" : "indexOf",
"kind" : "function",
"type" : "sizediff_t(const(Char1)[] s, const(Char2)[] sub, CaseSensitive cs = CaseSensitive.yes)",
"comment" : "\n    Returns the index of the first occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 502}
]
}
,
{
"name" : "lastIndexOf(Char) if (isSomeChar!(Char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the index of the last occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 576,
"members" : [
{
"name" : "lastIndexOf",
"kind" : "function",
"type" : "sizediff_t(const(Char)[] s, dchar c, CaseSensitive cs = CaseSensitive.yes)",
"comment" : "\n    Returns the index of the last occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 576}
]
}
,
{
"name" : "lastIndexOf(Char1,Char2) if (isSomeChar!(Char1) && isSomeChar!(Char2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the index of the last occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 671,
"members" : [
{
"name" : "lastIndexOf",
"kind" : "function",
"type" : "sizediff_t(const(Char1)[] s, const(Char2)[] sub, CaseSensitive cs = CaseSensitive.yes)",
"comment" : "\n    Returns the index of the last occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
"line" : 671}
]
}
,
{
"name" : "representation(Char) if (isSomeChar!(Char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the representation type of a string, which is the same type\n as the string except the character type is replaced by $(D ubyte),\n $(D ushort), or $(D uint) depending on the character width.\n\n Example:\n----\nstring s = \"hello\";\nstatic assert(is(typeof(representation(s)) == immutable(ubyte)[]));\n----\n \n",
"line" : 787,
"members" : [
{
"name" : "representation",
"kind" : "function",
"type" : "pure nothrow (Char[] s)",
"comment" : "\n Returns the representation type of a string, which is the same type\n as the string except the character type is replaced by $(D ubyte),\n $(D ushort), or $(D uint) depending on the character width.\n\n Example:\n----\nstring s = \"hello\";\nstatic assert(is(typeof(representation(s)) == immutable(ubyte)[]));\n----\n \n",
"line" : 787}
]
}
,
{
"name" : "tolower(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012.\n       Please use $(D toLower) instead.)\n\n Convert string s[] to lower case.\n \n",
"line" : 846,
"members" : [
{
"name" : "tolower",
"kind" : "function",
"type" : "S(S s)",
"line" : 846}
]
}
,
{
"name" : "toLower(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are lowercase (in unicode, not just ASCII). If $(D s) does not\n    have any uppercase characters, then $(D s) is returned.\n  \n",
"line" : 856,
"members" : [
{
"name" : "toLower",
"kind" : "function",
"type" : "pure @trusted S(S s)",
"comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are lowercase (in unicode, not just ASCII). If $(D s) does not\n    have any uppercase characters, then $(D s) is returned.\n  \n",
"line" : 856}
]
}
,
{
"name" : "tolowerInPlace(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   $(RED Deprecated. It will be removed in September 2012.\n         Please use $(D toLowerInPlace) instead.)\n\n   Converts $(D s) to lowercase in place.\n \n",
"line" : 904,
"members" : [
{
"name" : "tolowerInPlace",
"kind" : "function",
"type" : "void(ref C[] s)",
"line" : 904}
]
}
,
{
"name" : "toLowerInPlace(C) if (is(C == char) || is(C == wchar))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Converts $(D s) to lowercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any uppercase characters, then $(D s) is unaltered.\n \n",
"line" : 913,
"members" : [
{
"name" : "toLowerInPlace",
"kind" : "function",
"type" : "void(ref C[] s)",
"comment" : "\n    Converts $(D s) to lowercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any uppercase characters, then $(D s) is unaltered.\n \n",
"line" : 913}
]
}
,
{
"name" : "toLowerInPlace(C) if (is(C == dchar))",
"kind" : "template",
"protection" : "public",
"line" : 945,
"members" : [
{
"name" : "toLowerInPlace",
"kind" : "function",
"type" : "pure nothrow @safe void(ref C[] s)",
"line" : 945}
]
}
,
{
"name" : "toupper(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012.\n       Please use $(D toUpper) instead.)\n\n Convert string s[] to upper case.\n \n",
"line" : 1019,
"members" : [
{
"name" : "toupper",
"kind" : "function",
"type" : "S(S s)",
"line" : 1019}
]
}
,
{
"name" : "toUpper(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are uppercase (in unicode, not just ASCII). If $(D s) does not\n    have any lowercase characters, then $(D s) is returned.\n  \n",
"line" : 1029,
"members" : [
{
"name" : "toUpper",
"kind" : "function",
"type" : "pure @trusted S(S s)",
"comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are uppercase (in unicode, not just ASCII). If $(D s) does not\n    have any lowercase characters, then $(D s) is returned.\n  \n",
"line" : 1029}
]
}
,
{
"name" : "toupperInPlace(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.\n          Please use $(D toUpperInPlace) instead.)\n\n   Converts $(D s) to uppercase in place.\n \n",
"line" : 1077,
"members" : [
{
"name" : "toupperInPlace",
"kind" : "function",
"type" : "void(ref C[] s)",
"line" : 1077}
]
}
,
{
"name" : "toUpperInPlace(C) if (isSomeChar!(C) && (is(C == char) || is(C == wchar)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Converts $(D s) to uppercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any lowercase characters, then $(D s) is unaltered.\n \n",
"line" : 1086,
"members" : [
{
"name" : "toUpperInPlace",
"kind" : "function",
"type" : "void(ref C[] s)",
"comment" : "\n    Converts $(D s) to uppercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any lowercase characters, then $(D s) is unaltered.\n \n",
"line" : 1086}
]
}
,
{
"name" : "toUpperInPlace(C) if (is(C == dchar))",
"kind" : "template",
"protection" : "public",
"line" : 1119,
"members" : [
{
"name" : "toUpperInPlace",
"kind" : "function",
"type" : "pure nothrow @safe void(ref C[] s)",
"line" : 1119}
]
}
,
{
"name" : "capitalize(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Capitalize the first character of $(D s) and conver the rest of $(D s)\n    to lowercase.\n \n",
"line" : 1179,
"members" : [
{
"name" : "capitalize",
"kind" : "function",
"type" : "pure @trusted S(S s)",
"comment" : "\n    Capitalize the first character of $(D s) and conver the rest of $(D s)\n    to lowercase.\n \n",
"line" : 1179}
]
}
,
{
"name" : "capwords(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n  $(RED Deprecated. It will be removed in September 2012.)\n\n Capitalize all words in string s[].\n Remove leading and trailing whitespace.\n Replace all sequences of whitespace with a single space.\n \n",
"line" : 1257,
"members" : [
{
"name" : "capwords",
"kind" : "function",
"type" : "S(S s)",
"line" : 1257}
]
}
,
{
"name" : "repeat(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in March 2012.\n        Please use $(XREF array, replicate) instead.)\n\n Repeat $(D s) for $(D n) times.\n \n",
"line" : 1317,
"members" : [
{
"name" : "repeat",
"kind" : "function",
"type" : "S(S s, size_t n)",
"line" : 1317}
]
}
,
{
"name" : "splitlines(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012.\n       Please use $(LREF splitLines) instead.)\n\n Split s[] into an array of lines,\n using CR, LF, or CR-LF as the delimiter.\n The delimiter is not included in the line.\n \n",
"line" : 1332,
"members" : [
{
"name" : "splitlines",
"kind" : "function",
"type" : "S[](S s)",
"line" : 1332}
]
}
,
{
"name" : "KeepTerminator",
"kind" : "enum",
"protection" : "public",
"comment" : "\n    Split $(D s) into an array of lines using $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(XREF uni, lineSep), and $(XREF uni, paraSep) as delimiters.\n    If $(D keepTerm) is set to $(D KeepTerminator.yes), then the delimiter\n    is included in the strings returned.\n  \n",
"line" : 1343,
"base" : "bool",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"line" : 1343}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"line" : 1343}
]
}
,
{
"name" : "splitLines(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1345,
"members" : [
{
"name" : "splitLines",
"kind" : "function",
"type" : "S[](S s, KeepTerminator keepTerm = KeepTerminator.no)",
"comment" : " ditto\n",
"line" : 1345}
]
}
,
{
"name" : "stripl(String)",
"kind" : "template",
"protection" : "public",
"comment" : "\n  $(RED Deprecated. It will be removed in September 2012.\n        Please use $(D stripLeft) instead.)\n\n Strips leading whitespace.\n \n",
"line" : 1433,
"members" : [
{
"name" : "stripl",
"kind" : "function",
"type" : "String(String s)",
"line" : 1433}
]
}
,
{
"name" : "stripLeft(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Strips leading whitespace.\n\n    Examples:\n--------------------\nassert(stripLeft(\"     hello world     \") ==\n       \"hello world     \");\nassert(stripLeft(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\\n\\t\\v\\r\");\nassert(stripLeft(\"hello world\") ==\n       \"hello world\");\nassert(stripLeft([lineSep] ~ \"hello world\" ~ lineSep) ==\n       \"hello world\" ~ [lineSep]);\nassert(stripLeft([paraSep] ~ \"hello world\" ~ paraSep) ==\n       \"hello world\" ~ [paraSep]);\n--------------------\n  \n",
"line" : 1455,
"members" : [
{
"name" : "stripLeft",
"kind" : "function",
"type" : "pure @safe C[](C[] str)",
"comment" : "\n    Strips leading whitespace.\n\n    Examples:\n--------------------\nassert(stripLeft(\"     hello world     \") ==\n       \"hello world     \");\nassert(stripLeft(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\\n\\t\\v\\r\");\nassert(stripLeft(\"hello world\") ==\n       \"hello world\");\nassert(stripLeft([lineSep] ~ \"hello world\" ~ lineSep) ==\n       \"hello world\" ~ [lineSep]);\nassert(stripLeft([paraSep] ~ \"hello world\" ~ paraSep) ==\n       \"hello world\" ~ [paraSep]);\n--------------------\n  \n",
"line" : 1455}
]
}
,
{
"name" : "stripr(String)",
"kind" : "template",
"protection" : "public",
"comment" : "\n  $(RED Deprecated. It will be removed in September 2012.\n        Please use $(D stripRight) instead.)\n\n Strips trailing whitespace.\n \n",
"line" : 1489,
"members" : [
{
"name" : "stripr",
"kind" : "function",
"type" : "String(String s)",
"line" : 1489}
]
}
,
{
"name" : "stripRight(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Strips trailing whitespace.\n\n    Examples:\n--------------------\nassert(stripRight(\"     hello world     \") ==\n       \"     hello world\");\nassert(stripRight(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"\\n\\t\\v\\rhello world\");\nassert(stripRight(\"hello world\") ==\n       \"hello world\");\nassert(stripRight([lineSep] ~ \"hello world\" ~ lineSep) ==\n       [lineSep] ~ \"hello world\");\nassert(stripRight([paraSep] ~ \"hello world\" ~ paraSep) ==\n       [paraSep] ~ \"hello world\");\n--------------------\n  \n",
"line" : 1511,
"members" : [
{
"name" : "stripRight",
"kind" : "function",
"type" : "C[](C[] str)",
"comment" : "\n    Strips trailing whitespace.\n\n    Examples:\n--------------------\nassert(stripRight(\"     hello world     \") ==\n       \"     hello world\");\nassert(stripRight(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"\\n\\t\\v\\rhello world\");\nassert(stripRight(\"hello world\") ==\n       \"hello world\");\nassert(stripRight([lineSep] ~ \"hello world\" ~ lineSep) ==\n       [lineSep] ~ \"hello world\");\nassert(stripRight([paraSep] ~ \"hello world\" ~ paraSep) ==\n       [paraSep] ~ \"hello world\");\n--------------------\n  \n",
"line" : 1511}
]
}
,
{
"name" : "strip(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Strips both leading and trailing whitespace.\n\n    Examples:\n--------------------\nassert(strip(\"     hello world     \") ==\n       \"hello world\");\nassert(strip(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\");\nassert(strip(\"hello world\") ==\n       \"hello world\");\nassert(strip([lineSep] ~ \"hello world\" ~ [lineSep]) ==\n       \"hello world\");\nassert(strip([paraSep] ~ \"hello world\" ~ [paraSep]) ==\n       \"hello world\");\n--------------------\n  \n",
"line" : 1556,
"members" : [
{
"name" : "strip",
"kind" : "function",
"type" : "C[](C[] str)",
"comment" : "\n    Strips both leading and trailing whitespace.\n\n    Examples:\n--------------------\nassert(strip(\"     hello world     \") ==\n       \"hello world\");\nassert(strip(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\");\nassert(strip(\"hello world\") ==\n       \"hello world\");\nassert(strip([lineSep] ~ \"hello world\" ~ [lineSep]) ==\n       \"hello world\");\nassert(strip([paraSep] ~ \"hello world\" ~ [paraSep]) ==\n       \"hello world\");\n--------------------\n  \n",
"line" : 1556}
]
}
,
{
"name" : "chomp(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D str) ends with $(D delimiter), then $(D str) is returned without\n    $(D delimiter) on its end. If it $(D str) does $(I not) end with\n    $(D delimiter), then it is returned unchanged.\n\n    If no $(D delimiter) is given, then one trailing  $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(XREF uni, lineSep), or $(XREF uni, paraSep) is removed from\n    the end of $(D str). If $(D str) does not end with any of those characters,\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chomp(\" hello world  \\n\\r\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\r\\n\") == \" hello world  \");\nassert(chomp(\" hello world  \\n\\n\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\n\\n \") == \" hello world  \\n\\n \");\nassert(chomp(\" hello world  \\n\\n\" ~ [lineSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [paraSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world\") == \" hello world\");\nassert(chomp(\"\") == \"\");\n\nassert(chomp(\" hello world\", \"orld\") == \" hello w\");\nassert(chomp(\" hello world\", \" he\") == \" hello world\");\nassert(chomp(\"\", \"hello\") == \"\");\n--------------------\n  \n",
"line" : 1634,
"members" : [
{
"name" : "chomp",
"kind" : "function",
"type" : "C[](C[] str)",
"comment" : "\n    If $(D str) ends with $(D delimiter), then $(D str) is returned without\n    $(D delimiter) on its end. If it $(D str) does $(I not) end with\n    $(D delimiter), then it is returned unchanged.\n\n    If no $(D delimiter) is given, then one trailing  $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(XREF uni, lineSep), or $(XREF uni, paraSep) is removed from\n    the end of $(D str). If $(D str) does not end with any of those characters,\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chomp(\" hello world  \\n\\r\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\r\\n\") == \" hello world  \");\nassert(chomp(\" hello world  \\n\\n\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\n\\n \") == \" hello world  \\n\\n \");\nassert(chomp(\" hello world  \\n\\n\" ~ [lineSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [paraSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world\") == \" hello world\");\nassert(chomp(\"\") == \"\");\n\nassert(chomp(\" hello world\", \"orld\") == \" hello w\");\nassert(chomp(\" hello world\", \" he\") == \" hello world\");\nassert(chomp(\"\", \"hello\") == \"\");\n--------------------\n  \n",
"line" : 1634}
]
}
,
{
"name" : "chomp(C1,C2) if (isSomeChar!(C1) && isSomeChar!(C2))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1676,
"members" : [
{
"name" : "chomp",
"kind" : "function",
"type" : "C1[](C1[] str, const(C2)[] delimiter)",
"comment" : " Ditto\n",
"line" : 1676}
]
}
,
{
"name" : "chompPrefix(C1,C2) if (isSomeChar!(C1) && isSomeChar!(C2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    If $(D str) starts with $(D delimiter), then the part of $(D str) following\n    $(D delimiter) is returned. If it $(D str) does $(I not) start with\n    $(D delimiter), then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chompPrefix(\"hello world\", \"he\") == \"llo world\");\nassert(chompPrefix(\"hello world\", \"hello w\") == \"orld\");\nassert(chompPrefix(\"hello world\", \" world\") == \"hello world\");\nassert(chompPrefix(\"\", \"hello\") == \"\");\n--------------------\n \n",
"line" : 1770,
"members" : [
{
"name" : "chompPrefix",
"kind" : "function",
"type" : "C1[](C1[] str, C2[] delimiter)",
"comment" : "\n    If $(D str) starts with $(D delimiter), then the part of $(D str) following\n    $(D delimiter) is returned. If it $(D str) does $(I not) start with\n    $(D delimiter), then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chompPrefix(\"hello world\", \"he\") == \"llo world\");\nassert(chompPrefix(\"hello world\", \"hello w\") == \"orld\");\nassert(chompPrefix(\"hello world\", \" world\") == \"hello world\");\nassert(chompPrefix(\"\", \"hello\") == \"\");\n--------------------\n \n",
"line" : 1770}
]
}
,
{
"name" : "chop(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns $(D str) without its last character, if there is one. If $(D str)\n    ends with $(D \"\\r\\n\"), then both are removed. If $(D str) is empty, then\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chop(\"hello world\") == \"hello worl\");\nassert(chop(\"hello world\\n\") == \"hello world\");\nassert(chop(\"hello world\\r\") == \"hello world\");\nassert(chop(\"hello world\\n\\r\") == \"hello world\\n\");\nassert(chop(\"hello world\\r\\n\") == \"hello world\");\nassert(chop(\"Walter Bright\") == \"Walter Brigh\");\nassert(chop(\"\") == \"\");\n--------------------\n \n",
"line" : 1835,
"members" : [
{
"name" : "chop",
"kind" : "function",
"type" : "S(S str)",
"comment" : "\n    Returns $(D str) without its last character, if there is one. If $(D str)\n    ends with $(D \"\\r\\n\"), then both are removed. If $(D str) is empty, then\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chop(\"hello world\") == \"hello worl\");\nassert(chop(\"hello world\\n\") == \"hello world\");\nassert(chop(\"hello world\\r\") == \"hello world\");\nassert(chop(\"hello world\\n\\r\") == \"hello world\\n\");\nassert(chop(\"hello world\\r\\n\") == \"hello world\");\nassert(chop(\"Walter Bright\") == \"Walter Brigh\");\nassert(chop(\"\") == \"\");\n--------------------\n \n",
"line" : 1835}
]
}
,
{
"name" : "ljustify(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n  $(RED Deprecated. It will be removed in September 2012.\n        Please use $(D leftJustify) instead.)\n\n Left justify string s[] in field width chars wide.\n \n",
"line" : 1884,
"members" : [
{
"name" : "ljustify",
"kind" : "function",
"type" : "S(S s, size_t width)",
"line" : 1884}
]
}
,
{
"name" : "leftJustify(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
"line" : 1894,
"members" : [
{
"name" : "leftJustify",
"kind" : "function",
"type" : "@trusted S(S s, size_t width, dchar fillChar = ' ')",
"comment" : "\n    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
"line" : 1894}
]
}
,
{
"name" : "rjustify(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n  $(RED Deprecated. It will be removed in September 2012.\n        Please use $(D rightJustify) instead.)\n\n Left right string s[] in field width chars wide.\n \n",
"line" : 1930,
"members" : [
{
"name" : "rjustify",
"kind" : "function",
"type" : "S(S s, size_t width)",
"line" : 1930}
]
}
,
{
"name" : "rightJustify(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
"line" : 1940,
"members" : [
{
"name" : "rightJustify",
"kind" : "function",
"type" : "@trusted S(S s, size_t width, dchar fillChar = ' ')",
"comment" : "\n    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
"line" : 1940}
]
}
,
{
"name" : "center(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Center $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
"line" : 1975,
"members" : [
{
"name" : "center",
"kind" : "function",
"type" : "@trusted S(S s, size_t width, dchar fillChar = ' ')",
"comment" : "\n    Center $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
"line" : 1975}
]
}
,
{
"name" : "zfill(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012.\n       Please use $(D rightJustify) with a fill character of '0' instead.)\n\n Same as rjustify(), but fill with '0's.\n\n \n",
"line" : 2042,
"members" : [
{
"name" : "zfill",
"kind" : "function",
"type" : "S(S s, int width)",
"line" : 2042}
]
}
,
{
"name" : "insert(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in March 2012.\n       Please use $(XREF array, insertInPlace) instead.)\n\n Insert sub[] into s[] at location index.\n \n",
"line" : 2054,
"members" : [
{
"name" : "insert",
"kind" : "function",
"type" : "S(S s, size_t index, S sub)",
"line" : 2054}
]
}
,
{
"name" : "expandtabs(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in September 2012.\n       Please use $(D detab) instead.)\n\n Replace tabs with the appropriate number of spaces.\n tabsize is the distance between tab stops.\n \n",
"line" : 2073,
"members" : [
{
"name" : "expandtabs",
"kind" : "function",
"type" : "S(S str, size_t tabsize = 8)",
"line" : 2073}
]
}
,
{
"name" : "detab(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replace each tab character in $(D s) with the number of spaces necessary\n    to align the following character at the next tab stop where $(D tabSize)\n    is the distance between tab stops.\n  \n",
"line" : 2083,
"members" : [
{
"name" : "detab",
"kind" : "function",
"type" : "pure @trusted S(S s, size_t tabSize = 8)",
"comment" : "\n    Replace each tab character in $(D s) with the number of spaces necessary\n    to align the following character at the next tab stop where $(D tabSize)\n    is the distance between tab stops.\n  \n",
"line" : 2083}
]
}
,
{
"name" : "entab(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replaces spaces in $(D s) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        s       = String to convert.\n        tabSize = Tab columns are $(D tabSize) spaces apart.\n \n",
"line" : 2170,
"members" : [
{
"name" : "entab",
"kind" : "function",
"type" : "pure @trusted S(S s, size_t tabSize = 8)",
"comment" : "\n    Replaces spaces in $(D s) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        s       = String to convert.\n        tabSize = Tab columns are $(D tabSize) spaces apart.\n \n",
"line" : 2170}
]
}
,
{
"name" : "translate(C1,C2 = immutable(char)) if (isSomeChar!(C1) && isSomeChar!(C2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replaces the characters in $(D str) which are keys in $(D transTable) with\n    their corresponding values in $(D transTable). $(D transTable) is an AA\n    where its keys are $(D dchar) and its values are either $(D dchar) or some\n    type of string. Also, if $(D toRemove) is given, the characters in it are\n    removed from $(D str) prior to translation. $(D str) itself is unaltered.\n    A copy with the changes is returned.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\nassert(translate(\"hello world\", transTable2) == \"h5llorange worangerld\");\n--------------------\n  \n",
"line" : 2337,
"members" : [
{
"name" : "translate",
"kind" : "function",
"type" : "@safe C1[](C1[] str, dchar[dchar] transTable, const(C2)[] toRemove = null)",
"comment" : "\n    Replaces the characters in $(D str) which are keys in $(D transTable) with\n    their corresponding values in $(D transTable). $(D transTable) is an AA\n    where its keys are $(D dchar) and its values are either $(D dchar) or some\n    type of string. Also, if $(D toRemove) is given, the characters in it are\n    removed from $(D str) prior to translation. $(D str) itself is unaltered.\n    A copy with the changes is returned.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\nassert(translate(\"hello world\", transTable2) == \"h5llorange worangerld\");\n--------------------\n  \n",
"line" : 2337}
]
}
,
{
"name" : "translate(C1,S,C2 = immutable(char)) if (isSomeChar!(C1) && isSomeString!(S) && isSomeChar!(C2))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 2402,
"members" : [
{
"name" : "translate",
"kind" : "function",
"type" : "@safe C1[](C1[] str, S[dchar] transTable, const(C2)[] toRemove = null)",
"comment" : " Ditto \n",
"line" : 2402}
]
}
,
{
"name" : "translateImpl(C1,T,C2)",
"kind" : "template",
"protection" : "public",
"line" : 2456,
"members" : [
{
"name" : "translateImpl",
"kind" : "function",
"type" : "@trusted (C1[] str, T transTable, const(C2)[] toRemove)",
"line" : 2456}
]
}
,
{
"name" : "translate(C = immutable(char)) if (is(Unqual!(C) == char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    This is an $(I $(RED ASCII-only)) overload of $(LREF _translate). It\n    will $(I not) work with Unicode. It exists as an optimization for the\n    cases where Unicode processing is not necessary.\n\n    Unlike the other overloads of $(LREF _translate), this one does not take\n    an AA. Rather, it takes a $(D string) generated by $(LREF makeTrans).\n\n    The array generated by $(D makeTrans) is $(D 256) elements long such that\n    the index is equal to the ASCII character being replaced and the value is\n    equal to the character that it's being replaced with. Note that translate\n    does not decode any of the characters, so you can actually pass it Extended\n    ASCII characters if you want to (ASCII only actually uses $(D 128)\n    characters), but be warned that Extended ASCII characters are not valid\n    Unicode and therefore will result in a $(D UTFException) being thrown from\n    most other Phobos functions.\n\n    Also, because no decoding occurs, it is possible to use this overload to\n    translate ASCII characters within a proper UTF-8 string without altering the\n    other, non-ASCII characters. It's replacing any code unit greater than\n    $(D 127) with another code unit or replacing any code unit with another code\n    unit greater than $(D 127) which will cause UTF validation issues.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTrans).\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\nauto transTable1 = makeTrans(\"eo5\", \"57q\");\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n--------------------\n  \n",
"line" : 2525,
"members" : [
{
"name" : "translate",
"kind" : "function",
"type" : "nothrow @trusted C[](in char[] str, in char[] transTable, in char[] toRemove = null)",
"comment" : "\n    This is an $(I $(RED ASCII-only)) overload of $(LREF _translate). It\n    will $(I not) work with Unicode. It exists as an optimization for the\n    cases where Unicode processing is not necessary.\n\n    Unlike the other overloads of $(LREF _translate), this one does not take\n    an AA. Rather, it takes a $(D string) generated by $(LREF makeTrans).\n\n    The array generated by $(D makeTrans) is $(D 256) elements long such that\n    the index is equal to the ASCII character being replaced and the value is\n    equal to the character that it's being replaced with. Note that translate\n    does not decode any of the characters, so you can actually pass it Extended\n    ASCII characters if you want to (ASCII only actually uses $(D 128)\n    characters), but be warned that Extended ASCII characters are not valid\n    Unicode and therefore will result in a $(D UTFException) being thrown from\n    most other Phobos functions.\n\n    Also, because no decoding occurs, it is possible to use this overload to\n    translate ASCII characters within a proper UTF-8 string without altering the\n    other, non-ASCII characters. It's replacing any code unit greater than\n    $(D 127) with another code unit or replacing any code unit with another code\n    unit greater than $(D 127) which will cause UTF validation issues.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTrans).\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\nauto transTable1 = makeTrans(\"eo5\", \"57q\");\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n--------------------\n  \n",
"line" : 2525}
]
}
,
{
"name" : "makeTrans",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @trusted string(const(char[]) from, const(char[]) to)",
"comment" : " Ditto \n",
"line" : 2564}
,
{
"name" : "maketrans",
"kind" : "alias",
"protection" : "public",
"comment" : "\n $(RED Deprecated. It will be removed in January 2013.\n       Please use $(LREF makeTrans) instead.)\n\n Construct translation table for $(LREF translate).\n \n",
"line" : 2639}
,
{
"name" : "bug2479format",
"kind" : "function",
"protection" : "private",
"type" : "string(TypeInfo[] arguments, void* argptr)",
"line" : 2661}
,
{
"name" : "bug2479sformat",
"kind" : "function",
"protection" : "private",
"type" : "char[](char[] s, TypeInfo[] arguments, void* argptr)",
"line" : 2674}
,
{
"name" : "format",
"kind" : "function",
"protection" : "public",
"type" : "string(...)",
"comment" : "\n Format arguments into a string.\n\n  $(RED format's current implementation is scheduled for replacement in\n        November 2012. It will then be replaced with $(LREF xformat)'s implementation.\n        This will be seamless for most code, but it will make it so that the\n        only argument that can be a format string is the first one, so any\n        code which uses multiple format strings will break. Please change\n        your calls to format accordingly.\n\n        e.g.:\n----\nformat(\"key = %s\", key, \", value = %s\", value)\n----\n        will need to be rewritten as:\n----\nformat(\"key = %s, value = %s\", key, value)\n----\n   )\n \n",
"line" : 2723}
,
{
"name" : "sformat",
"kind" : "function",
"protection" : "public",
"type" : "char[](char[] s,...)",
"comment" : "\n Format arguments into string <i>s<\/i> which must be large\n enough to hold the result. Throws RangeError if it is not.\n Returns: s\n\n  $(RED sformat's current implementation is scheduled for replacement in\n        November 2012. It will then be replaced with $(LREF xsformat)'s implementation.\n        This will be seamless for most code, but it will make it so that the\n        only argument that can be a format string is the first one, so any\n        code which uses multiple format strings will break. Please change\n        your calls to sformat accordingly.\n\n        e.g.:\n----\nsformat(buf, \"key = %s\", key, \", value = %s\", value)\n----\n        will need to be rewritten as:\n----\nsformat(buf, \"key = %s, value = %s\", key, value)\n----\n   )\n \n",
"line" : 2762}
,
{
"name" : "xformat(Char,Args...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Format arguments into a string.\n\n xformat is a version of $(LREF format) whose behavior matches that of\n $(XREF stdio, writef). $(LREF format) will be changed to use this\n implementation in November 2012. In the interim, xformat is provided for\n those who need the improved implementation. It will be scheduled for\n deprecation once format has been updated.\n \n",
"line" : 2844,
"members" : [
{
"name" : "xformat",
"kind" : "function",
"type" : "string(in Char[] fmt, Args args)",
"comment" : "\n Format arguments into a string.\n\n xformat is a version of $(LREF format) whose behavior matches that of\n $(XREF stdio, writef). $(LREF format) will be changed to use this\n implementation in November 2012. In the interim, xformat is provided for\n those who need the improved implementation. It will be scheduled for\n deprecation once format has been updated.\n \n",
"line" : 2844}
]
}
,
{
"name" : "xsformat(Char,Args...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Format arguments into string $(D_PARAM buf) which must be large\n enough to hold the result. Throws RangeError if it is not.\n\n xsformat is a version of $(LREF sformat) whose behavior matches that of\n $(XREF stdio, writef). $(LREF sformat) will be changed to use this\n implementation in November 2012. In the interim, xsformat is provided for\n those who need the improved implementation. It will be scheduled for\n deprecation once sformat has been updated.\n\n Returns: filled slice of $(D_PARAM buf)\n \n",
"line" : 2889,
"members" : [
{
"name" : "xsformat",
"kind" : "function",
"type" : "char[](char[] buf, in Char[] fmt, Args args)",
"comment" : "\n Format arguments into string $(D_PARAM buf) which must be large\n enough to hold the result. Throws RangeError if it is not.\n\n xsformat is a version of $(LREF sformat) whose behavior matches that of\n $(XREF stdio, writef). $(LREF sformat) will be changed to use this\n implementation in November 2012. In the interim, xsformat is provided for\n those who need the improved implementation. It will be scheduled for\n deprecation once sformat has been updated.\n\n Returns: filled slice of $(D_PARAM buf)\n \n",
"line" : 2889}
]
}
,
{
"name" : "inPattern(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n See if character c is in the pattern.\n Patterns:\n\n  A <i>pattern<\/i> is an array of characters much like a <i>character\n  class<\/i> in regular expressions. A sequence of characters\n  can be given, such as \"abcde\". The '-' can represent a range\n  of characters, as \"a-e\" represents the same pattern as \"abcde\".\n  \"a-fA-F0-9\" represents all the hex characters.\n  If the first character of a pattern is '^', then the pattern\n  is negated, i.e. \"^0-9\" means any character except a digit.\n  The functions inPattern, <b>countchars<\/b>, <b>removeschars<\/b>,\n  and <b>squeeze<\/b>\n  use patterns.\n\n Note: In the future, the pattern syntax may be improved\n  to be more like regular expression character classes.\n \n",
"line" : 2976,
"members" : [
{
"name" : "inPattern",
"kind" : "function",
"type" : "bool(dchar c, in S pattern)",
"comment" : "\n See if character c is in the pattern.\n Patterns:\n\n  A <i>pattern<\/i> is an array of characters much like a <i>character\n  class<\/i> in regular expressions. A sequence of characters\n  can be given, such as \"abcde\". The '-' can represent a range\n  of characters, as \"a-e\" represents the same pattern as \"abcde\".\n  \"a-fA-F0-9\" represents all the hex characters.\n  If the first character of a pattern is '^', then the pattern\n  is negated, i.e. \"^0-9\" means any character except a digit.\n  The functions inPattern, <b>countchars<\/b>, <b>removeschars<\/b>,\n  and <b>squeeze<\/b>\n  use patterns.\n\n Note: In the future, the pattern syntax may be improved\n  to be more like regular expression character classes.\n \n",
"line" : 2976}
]
}
,
{
"name" : "inPattern(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n See if character c is in the intersection of the patterns.\n \n",
"line" : 3059,
"members" : [
{
"name" : "inPattern",
"kind" : "function",
"type" : "bool(dchar c, S[] patterns)",
"comment" : "\n See if character c is in the intersection of the patterns.\n \n",
"line" : 3059}
]
}
,
{
"name" : "countchars(S,S1) if (isSomeString!(S) && isSomeString!(S1))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Count characters in s that match pattern.\n \n",
"line" : 3076,
"members" : [
{
"name" : "countchars",
"kind" : "function",
"type" : "size_t(S s, in S1 pattern)",
"comment" : "\n Count characters in s that match pattern.\n \n",
"line" : 3076}
]
}
,
{
"name" : "removechars(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Return string that is s with all characters removed that match pattern.\n \n",
"line" : 3103,
"members" : [
{
"name" : "removechars",
"kind" : "function",
"type" : "S(S s, in S pattern)",
"comment" : "\n Return string that is s with all characters removed that match pattern.\n \n",
"line" : 3103}
]
}
,
{
"name" : "squeeze(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Return string where sequences of a character in s[] from pattern[]\n are replaced with a single instance of that character.\n If pattern is null, it defaults to all characters.\n \n",
"line" : 3149,
"members" : [
{
"name" : "squeeze",
"kind" : "function",
"type" : "S(S s, in S pattern = null)",
"comment" : "\n Return string where sequences of a character in s[] from pattern[]\n are replaced with a single instance of that character.\n If pattern is null, it defaults to all characters.\n \n",
"line" : 3149}
]
}
,
{
"name" : "munch(S1,S2)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Finds the position $(D_PARAM pos) of the first character in $(D_PARAM\n s) that does not match $(D_PARAM pattern) (in the terminology used by\n $(LINK2 std_string.html,inPattern)). Updates $(D_PARAM s =\n s[pos..$]). Returns the slice from the beginning of the original\n (before update) string up to, and excluding, $(D_PARAM pos).\n\n Example:\n ---\nstring s = \"123abc\";\nstring t = munch(s, \"0123456789\");\nassert(t == \"123\" && s == \"abc\");\nt = munch(s, \"0123456789\");\nassert(t == \"\" && s == \"abc\");\n ---\n\nThe $(D_PARAM munch) function is mostly convenient for skipping\ncertain category of characters (e.g. whitespace) when parsing\nstrings. (In such cases, the return value is not used.)\n \n",
"line" : 3227,
"members" : [
{
"name" : "munch",
"kind" : "function",
"type" : "S1(ref S1 s, S2 pattern)",
"comment" : "\n Finds the position $(D_PARAM pos) of the first character in $(D_PARAM\n s) that does not match $(D_PARAM pattern) (in the terminology used by\n $(LINK2 std_string.html,inPattern)). Updates $(D_PARAM s =\n s[pos..$]). Returns the slice from the beginning of the original\n (before update) string up to, and excluding, $(D_PARAM pos).\n\n Example:\n ---\nstring s = \"123abc\";\nstring t = munch(s, \"0123456789\");\nassert(t == \"123\" && s == \"abc\");\nt = munch(s, \"0123456789\");\nassert(t == \"\" && s == \"abc\");\n ---\n\nThe $(D_PARAM munch) function is mostly convenient for skipping\ncertain category of characters (e.g. whitespace) when parsing\nstrings. (In such cases, the return value is not used.)\n \n",
"line" : 3227}
]
}
,
{
"name" : "succ(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Return string that is the 'successor' to s[].\n If the rightmost character is a-zA-Z0-9, it is incremented within\n its case or digits. If it generates a carry, the process is\n repeated with the one to its immediate left.\n \n",
"line" : 3259,
"members" : [
{
"name" : "succ",
"kind" : "function",
"type" : "S(S s)",
"comment" : "\n Return string that is the 'successor' to s[].\n If the rightmost character is a-zA-Z0-9, it is incremented within\n its case or digits. If it generates a carry, the process is\n repeated with the one to its immediate left.\n \n",
"line" : 3259}
]
}
,
{
"name" : "tr(C1,C2,C3,C4 = immutable(char))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Replaces the characters in $(D str) which are in $(D from) with the\n    the corresponding characters in $(D to) and returns the resulting string.\n\n    $(D tr) is based on\n    $(WEB pubs.opengroup.org\/onlinepubs\/9699919799\/utilities\/_tr.html, Posix's tr),\n    though it doesn't do everything that the Posix utility does.\n\n    Params:\n        str       = The original string.\n        from      = The characters to replace.\n        to        = The characters to replace with.\n        modifiers = String containing modifiers.\n\n    Modifiers:\n        $(BOOKTABLE,\n        $(TR $(TD Modifier) $(TD Description))\n        $(TR $(TD $(D 'c')) $(TD Complement the list of characters in $(D from)))\n        $(TR $(TD $(D 'd')) $(TD Removes matching characters with no corresponding\n                              replacement in $(D to)))\n        $(TR $(TD $(D 's')) $(TD Removes adjacent duplicates in the replaced\n                              characters))\n        )\n\n    If the modifier $(D 'd') is present, then the number of characters in\n    $(D to) may be only $(D 0) or $(D 1).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is empty, then\n    $(D to) is taken to be the same as $(D from).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is shorter than\n    $(D from), then $(D to) is extended by replicating the last charcter in\n    $(D to).\n\n    Both $(D from) and $(D to) may contain ranges using the $(D '-') character\n    (e.g. $(D \"a-d\") is synonymous with $(D \"abcd).) Neither accept a leading\n    $(D '^') as meaning the complement of the string (use the $(D 'c') modifier\n    for that).\n  \n",
"line" : 3363,
"members" : [
{
"name" : "tr",
"kind" : "function",
"type" : "C1[](C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null)",
"comment" : "\n    Replaces the characters in $(D str) which are in $(D from) with the\n    the corresponding characters in $(D to) and returns the resulting string.\n\n    $(D tr) is based on\n    $(WEB pubs.opengroup.org\/onlinepubs\/9699919799\/utilities\/_tr.html, Posix's tr),\n    though it doesn't do everything that the Posix utility does.\n\n    Params:\n        str       = The original string.\n        from      = The characters to replace.\n        to        = The characters to replace with.\n        modifiers = String containing modifiers.\n\n    Modifiers:\n        $(BOOKTABLE,\n        $(TR $(TD Modifier) $(TD Description))\n        $(TR $(TD $(D 'c')) $(TD Complement the list of characters in $(D from)))\n        $(TR $(TD $(D 'd')) $(TD Removes matching characters with no corresponding\n                              replacement in $(D to)))\n        $(TR $(TD $(D 's')) $(TD Removes adjacent duplicates in the replaced\n                              characters))\n        )\n\n    If the modifier $(D 'd') is present, then the number of characters in\n    $(D to) may be only $(D 0) or $(D 1).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is empty, then\n    $(D to) is taken to be the same as $(D from).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is shorter than\n    $(D from), then $(D to) is extended by replicating the last charcter in\n    $(D to).\n\n    Both $(D from) and $(D to) may contain ranges using the $(D '-') character\n    (e.g. $(D \"a-d\") is synonymous with $(D \"abcd).) Neither accept a leading\n    $(D '^') as meaning the complement of the string (use the $(D 'c') modifier\n    for that).\n  \n",
"line" : 3363}
]
}
,
{
"name" : "isNumeric",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(char)[] s, const(bool) bAllowSep = false)",
"comment" : "\n [in] string s can be formatted in the following ways:\n\n Integer Whole Number:\n (for byte, ubyte, short, ushort, int, uint, long, and ulong)\n ['+'|'-']digit(s)[U|L|UL]\n\n examples: 123, 123UL, 123L, +123U, -123L\n\n Floating-Point Number:\n (for float, double, real, ifloat, idouble, and ireal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|inf|-inf]\n\n examples: +123., -123.01, 123.3e-10f, 123.3e-10fi, 123.3e-10L\n\n (for cfloat, cdouble, and creal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+]\n         [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|nan+nani|inf|-inf]\n\n examples: nan, -123e-1+456.9e-10Li, +123e+10+456i, 123+456\n\n [in] bool bAllowSep\n False by default, but when set to true it will accept the\n separator characters \",\" and \"_\" within the string, but these\n characters should be stripped from the string before using any\n of the conversion functions like toInt(), toFloat(), and etc\n else an error will occur.\n\n Also please note, that no spaces are allowed within the string\n anywhere whether it's a leading, trailing, or embedded space(s),\n thus they too must be stripped from the string before using this\n function, or any of the conversion functions.\n \n",
"line" : 3561}
,
{
"name" : "isNumeric",
"kind" : "function",
"protection" : "public",
"type" : "bool(...)",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.)\n\n    Allow any object as a parameter\n  \n",
"line" : 3708}
,
{
"name" : "isNumeric",
"kind" : "function",
"protection" : "public",
"type" : "bool(TypeInfo[] _arguments, void* _argptr)",
"comment" : "\n    $(RED Deprecated. It will be removed in September 2012.)\n\n    Check only the first parameter, all others will be ignored.\n  \n",
"line" : 3718}
,
{
"name" : "soundex",
"kind" : "function",
"protection" : "public",
"type" : "char[](const(char)[] string, char[] buffer = null)",
"comment" : "\n Soundex algorithm.\n\n The Soundex algorithm converts a word into 4 characters\n based on how the word sounds phonetically. The idea is that\n two spellings that sound alike will have the same Soundex\n value, which means that Soundex can be used for fuzzy matching\n of names.\n\n Params:\n  string = String to convert to Soundex representation.\n  buffer = Optional 4 char array to put the resulting Soundex\n      characters into. If null, the return value\n      buffer will be allocated on the heap.\n Returns:\n  The four character array with the Soundex result in it.\n  Returns null if there is no Soundex representation for the string.\n\n See_Also:\n  $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Soundex, Wikipedia),\n  $(LUCKY The Soundex Indexing System)\n\n Bugs:\n  Only works well with English names.\n  There are other arguably better Soundex algorithms,\n  but this one is the standard one.\n \n",
"line" : 3885}
,
{
"name" : "abbrev",
"kind" : "function",
"protection" : "public",
"type" : "string[string](string[] values)",
"comment" : "\n Construct an associative array consisting of all\n abbreviations that uniquely map to the strings in values.\n\n This is useful in cases where the user is expected to type\n in one of a known set of strings, and the program will helpfully\n autocomplete the string once sufficient characters have been\n entered that uniquely identify it.\n Example:\n ---\n import std.stdio;\n import std.string;\n\n void main()\n {\n    static string[] list = [ \"food\", \"foxy\" ];\n\n    auto abbrevs = std.string.abbrev(list);\n\n    foreach (key, value; abbrevs)\n    {\n       writefln(\"%s => %s\", key, value);\n    }\n }\n ---\n produces the output:\n <pre>\n fox =&gt; foxy\n food =&gt; food\n foxy =&gt; foxy\n foo =&gt; food\n <\/pre>\n \n",
"line" : 4031}
,
{
"name" : "column(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Compute column number after string if string starts in the\n leftmost column, which is numbered starting from 0.\n \n",
"line" : 4103,
"members" : [
{
"name" : "column",
"kind" : "function",
"type" : "size_t(S str, size_t tabsize = 8)",
"comment" : "\n Compute column number after string if string starts in the\n leftmost column, which is numbered starting from 0.\n \n",
"line" : 4103}
]
}
,
{
"name" : "wrap(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Wrap text into a paragraph.\n\n The input text string s is formed into a paragraph\n by breaking it up into a sequence of lines, delineated\n by \\n, such that the number of columns is not exceeded\n on each line.\n The last line is terminated with a \\n.\n Params:\n  s = text string to be wrapped\n  columns = maximum number of _columns in the paragraph\n  firstindent = string used to _indent first line of the paragraph\n  indent = string to use to _indent following lines of the paragraph\n  tabsize = column spacing of tabs\n Returns:\n  The resulting paragraph.\n \n",
"line" : 4159,
"members" : [
{
"name" : "wrap",
"kind" : "function",
"type" : "S(S s, size_t columns = 80, S firstindent = null, S indent = null, size_t tabsize = 8)",
"comment" : "\n Wrap text into a paragraph.\n\n The input text string s is formed into a paragraph\n by breaking it up into a sequence of lines, delineated\n by \\n, such that the number of columns is not exceeded\n on each line.\n The last line is terminated with a \\n.\n Params:\n  s = text string to be wrapped\n  columns = maximum number of _columns in the paragraph\n  firstindent = string used to _indent first line of the paragraph\n  indent = string to use to _indent following lines of the paragraph\n  tabsize = column spacing of tabs\n Returns:\n  The resulting paragraph.\n \n",
"line" : 4159}
]
}
,
{
"name" : "outdent(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Removes indentation from a multi-line string or an array of single-line strings.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n A StringException will be thrown if inconsistent indentation prevents\n the input from being outdented.\n\n Works at compile-time.\n\n Example:\n ---\n writeln(q{\n     import std.stdio;\n     void main() {\n         writeln(\"Hello\");\n     }\n }.outdent());\n ---\n\n Output:\n ---\n\n import std.stdio;\n void main() {\n     writeln(\"Hello\");\n }\n\n ---\n\n \n",
"line" : 4271,
"members" : [
{
"name" : "outdent",
"kind" : "function",
"type" : "S(S str)",
"comment" : "\n Removes indentation from a multi-line string or an array of single-line strings.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n A StringException will be thrown if inconsistent indentation prevents\n the input from being outdented.\n\n Works at compile-time.\n\n Example:\n ---\n writeln(q{\n     import std.stdio;\n     void main() {\n         writeln(\"Hello\");\n     }\n }.outdent());\n ---\n\n Output:\n ---\n\n import std.stdio;\n void main() {\n     writeln(\"Hello\");\n }\n\n ---\n\n \n",
"line" : 4271}
]
}
,
{
"name" : "outdent(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 4277,
"members" : [
{
"name" : "outdent",
"kind" : "function",
"type" : "S[](S[] lines)",
"comment" : " ditto\n",
"line" : 4277}
]
}
,
{
"name" : "ctfe_strip(S) if (isSomeString!(Unqual!(S)))",
"kind" : "template",
"protection" : "public",
"line" : 4334,
"members" : [
{
"name" : "ctfe_strip",
"kind" : "function",
"type" : "S(S str)",
"line" : 4334}
]
}
,
{
"name" : "ctfe_stripRight(S) if (isSomeString!(Unqual!(S)))",
"kind" : "template",
"protection" : "public",
"line" : 4340,
"members" : [
{
"name" : "ctfe_stripRight",
"kind" : "function",
"type" : "S(S str)",
"line" : 4340}
]
}
,
{
"name" : "hardDeprec(string vers,string date,string oldFunc,string newFunc)",
"kind" : "template",
"protection" : "public",
"line" : 4450,
"members" : [
{
"name" : "hardDeprec",
"kind" : "variable",
"line" : 4454}
]
}
]
}
,
{
"name" : "std.syserror",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/syserror.d",
"comment" : "\n Convert Win32 error code to string\n\n Source:    $(PHOBOSSRC std\/_syserror.d)\n",
"members" : [
{
"name" : "SysError",
"kind" : "class",
"protection" : "public",
"line" : 16,
"base" : "Object",
"members" : [
{
"name" : "msg",
"kind" : "function",
"protection" : "public",
"type" : "string(uint errcode)",
"line" : 21}
]
}
]
}
,
{
"name" : "std.system",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/system.d",
"comment" : "\n Information about the target operating system, environment, and CPU.\n\n Macros:\n      WIKI = Phobos\/StdSystem\n\n  Copyright: Copyright Digital Mars 2000 - 2011\n  License:   $(WEB www.boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n  Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n  Source:    $(PHOBOSSRC std\/_system.d)\n \n",
"members" : [
{
"name" : "OS",
"kind" : "enum",
"protection" : "public",
"comment" : "\n        Operating system.\n\n        Note:\n            This is for cases where you need a value representing the OS at\n            runtime. If you're doing something which should compile differently\n            on different OSes, then please use $(D version(Windows)),\n            $(D version(linux)), etc.\n\n        See_Also:\n            <a href=\"..\/version.html#PredefinedVersions\">Predefined Versions<\/a>\n      \n",
"line" : 31,
"base" : "int",
"members" : [
{
"name" : "win32",
"kind" : "enum member",
"protection" : "public",
"comment" : " Microsoft 32 bit Windows systems\n",
"line" : 32}
,
{
"name" : "win64",
"kind" : "enum member",
"protection" : "public",
"comment" : " Microsoft 64 bit Windows systems\n",
"line" : 33}
,
{
"name" : "linux",
"kind" : "enum member",
"protection" : "public",
"comment" : " All Linux Systems\n",
"line" : 34}
,
{
"name" : "osx",
"kind" : "enum member",
"protection" : "public",
"comment" : " Mac OS X\n",
"line" : 35}
,
{
"name" : "freeBSD",
"kind" : "enum member",
"protection" : "public",
"comment" : " FreeBSD\n",
"line" : 36}
,
{
"name" : "solaris",
"kind" : "enum member",
"protection" : "public",
"comment" : " Solaris\n",
"line" : 37}
,
{
"name" : "otherPosix",
"kind" : "enum member",
"protection" : "public",
"comment" : " Other Posix Systems\n",
"line" : 38}
]
}
,
{
"name" : "os",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(OS)",
"comment" : " The OS that the program was compiled for.\n",
"line" : 44}
,
{
"name" : "Endian",
"kind" : "enum",
"protection" : "public",
"comment" : "\n        Byte order endianness.\n\n        Note:\n            This is intended for cases where you need to deal with endianness at\n            runtime. If you're doing something which should compile differently\n            depending on whether you're compiling on a big endian or little\n            endian machine, then please use $(D version(BigEndian)) and\n            $(D version(LittleEndian)).\n\n        See_Also:\n            <a href=\"..\/version.html#PredefinedVersions\">Predefined Versions<\/a>\n      \n",
"line" : 64,
"base" : "int",
"members" : [
{
"name" : "bigEndian",
"kind" : "enum member",
"protection" : "public",
"comment" : " Big endian byte order\n",
"line" : 65}
,
{
"name" : "littleEndian",
"kind" : "enum member",
"protection" : "public",
"comment" : " Little endian byte order\n",
"line" : 66}
]
}
,
{
"name" : "endian",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(Endian)",
"comment" : " The endianness that the program was compiled for.\n",
"line" : 70}
]
}
,
{
"name" : "std.traits",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/traits.d",
"comment" : "\n Templates with which to extract information about types and symbols at\n compile time.\n\n Macros:\n  WIKI = Phobos\/StdTraits\n\n Copyright: Copyright Digital Mars 2005 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Tomasz Stachowiak ($(D isExpressionTuple)),\n            $(WEB erdani.org, Andrei Alexandrescu),\n            Shin Fujishiro,\n            $(WEB octarineparrot.com, Robert Clipsham),\n            $(WEB klickverbot.at, David Nadlinger),\n            Kenji Hara\n Source:    $(PHOBOSSRC std\/_traits.d)\n \n",
"members" : [
{
"name" : "Demangle(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n\n",
"line" : 42,
"members" : [
{
"name" : "Demangle",
"kind" : "struct",
"protection" : "public",
"line" : 42,
"members" : [
{
"name" : "value",
"kind" : "variable",
"type" : "T",
"line" : 43}
,
{
"name" : "rest",
"kind" : "variable",
"type" : "string",
"line" : 44}
]
}
]
}
,
{
"name" : "demangleParameterStorageClass",
"kind" : "function",
"protection" : "private",
"type" : "Demangle!(uint)(string mstr)",
"comment" : "\n\n",
"line" : 48}
,
{
"name" : "demangleFunctionAttributes",
"kind" : "function",
"protection" : "private",
"type" : "Demangle!(uint)(string mstr)",
"comment" : "\n\n",
"line" : 79}
,
{
"name" : "IntegralTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(byte, ubyte, short, ushort, int, uint, long, ulong)",
"comment" : "\n\n",
"line" : 106}
,
{
"name" : "SignedIntTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(byte, short, int, long)",
"comment" : "\n\n",
"line" : 107}
,
{
"name" : "UnsignedIntTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(ubyte, ushort, uint, ulong)",
"comment" : "\n\n",
"line" : 108}
,
{
"name" : "FloatingPointTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(float, double, real)",
"comment" : "\n\n",
"line" : 109}
,
{
"name" : "ImaginaryTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(ifloat, idouble, ireal)",
"comment" : "\n\n",
"line" : 110}
,
{
"name" : "ComplexTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(cfloat, cdouble, creal)",
"comment" : "\n\n",
"line" : 111}
,
{
"name" : "NumericTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(byte, ubyte, short, ushort, int, uint, long, ulong, float, double, real)",
"comment" : "\n\n",
"line" : 112}
,
{
"name" : "CharTypeList",
"kind" : "alias",
"protection" : "private",
"type" : "(char, wchar, dchar)",
"comment" : "\n\n",
"line" : 113}
,
{
"name" : "defaultInit(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n\n",
"line" : 116,
"members" : [
]
}
,
{
"name" : "packageName(alias T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the full package name for the given symbol.\n Example:\n ---\n import std.traits;\n static assert(packageName!(packageName) == \"std\");\n ---\n \n",
"line" : 153,
"members" : [
]
}
,
{
"name" : "moduleName(alias T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the module name (including package) for the given symbol.\n Example:\n ---\n import std.traits;\n static assert(moduleName!(moduleName) == \"std.traits\");\n ---\n \n",
"line" : 187,
"members" : [
]
}
,
{
"name" : "fullyQualifiedName(alias T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the fully qualified name of a symbol.\n Example:\n ---\n import std.traits;\n static assert(fullyQualifiedName!(fullyQualifiedName) == \"std.traits.fullyQualifiedName\");\n ---\n \n",
"line" : 217,
"members" : [
]
}
,
{
"name" : "ReturnType(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the type of the return value from a function,\n a pointer to function, a delegate, a struct\n with an opCall, a pointer to a struct with an opCall,\n or a class with an opCall.\n Example:\n ---\n import std.traits;\n int foo();\n ReturnType!(foo) x;   \/\/ x is declared as int\n ---\n \n",
"line" : 274,
"members" : [
]
}
,
{
"name" : "ParameterTypeTuple(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGet, as a tuple, the types of the parameters to a function, a pointer\nto function, a delegate, a struct with an $(D opCall), a pointer to a\nstruct with an $(D opCall), or a class with an $(D opCall).\n\nExample:\n---\nimport std.traits;\nint foo(int, long);\nvoid bar(ParameterTypeTuple!(foo));      \/\/ declares void bar(int, long);\nvoid abc(ParameterTypeTuple!(foo)[1]);   \/\/ declares void abc(long);\n---\n",
"line" : 334,
"members" : [
]
}
,
{
"name" : "arity(alias func) if (isCallable!(func) && variadicFunctionStyle!(func) == Variadic.no)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the number of arguments of function $(D func).\narity is undefined for variadic functions.\n\nExample:\n---\nvoid foo(){}\nstatic assert(arity!foo==0);\nvoid bar(uint){}\nstatic assert(arity!bar==1);\n---\n \n",
"line" : 379,
"members" : [
{
"name" : "arity",
"kind" : "variable",
"type" : "size_t",
"line" : 382}
]
}
,
{
"name" : "ParameterStorageClass",
"kind" : "enum",
"protection" : "public",
"comment" : "\nReturns a tuple consisting of the storage classes of the parameters of a\nfunction $(D func).\n\nExample:\n--------------------\nalias ParameterStorageClass STC; \/\/ shorten the enum name\n\nvoid func(ref int ctx, out real result, real param)\n{\n}\nalias ParameterStorageClassTuple!(func) pstc;\nstatic assert(pstc.length == 3); \/\/ three parameters\nstatic assert(pstc[0] == STC.ref_);\nstatic assert(pstc[1] == STC.out_);\nstatic assert(pstc[2] == STC.none);\n--------------------\n \n",
"line" : 412,
"base" : "uint",
"members" : [
{
"name" : "none",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n These flags can be bitwise OR-ed together to represent complex storage\n class.\n     \n ditto\n",
"line" : 418}
,
{
"name" : "scope_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 419}
,
{
"name" : "out_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 420}
,
{
"name" : "ref_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 421}
,
{
"name" : "lazy_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 422}
]
}
,
{
"name" : "ParameterStorageClassTuple(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 426,
"members" : [
{
"name" : "Func",
"kind" : "alias",
"type" : "Unqual!(FunctionTypeOf!(func))",
"line" : 429}
,
{
"name" : "Params",
"kind" : "alias",
"type" : "ParameterTypeTuple!(Func)",
"line" : 435}
,
{
"name" : "margs",
"kind" : "variable",
"line" : 438}
,
{
"name" : "demangleNextParameter(string margs,size_t i = 0)",
"kind" : "template",
"protection" : "public",
"line" : 441,
"members" : [
]
}
,
{
"name" : "ParameterStorageClassTuple",
"kind" : "alias",
"type" : "demangleNextParameter!(margs)",
"line" : 460}
]
}
,
{
"name" : "ParameterIdentifierTuple(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"line" : 510,
"members" : [
{
"name" : "Impl(size_t i = 0)",
"kind" : "template",
"protection" : "public",
"line" : 531,
"members" : [
]
}
,
{
"name" : "ParameterIdentifierTuple",
"kind" : "alias",
"type" : "Impl!()",
"line" : 539}
]
}
,
{
"name" : "ParameterDefaultValueTuple(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"line" : 588,
"members" : [
{
"name" : "Impl(size_t i = 0)",
"kind" : "template",
"protection" : "public",
"line" : 613,
"members" : [
]
}
,
{
"name" : "ParameterDefaultValueTuple",
"kind" : "alias",
"type" : "Impl!()",
"line" : 621}
]
}
,
{
"name" : "FunctionAttribute",
"kind" : "enum",
"protection" : "public",
"comment" : "\nReturns the attributes attached to a function $(D func).\n\nExample:\n--------------------\nalias FunctionAttribute FA; \/\/ shorten the enum name\n\nreal func(real x) pure nothrow @safe\n{\n    return x;\n}\nstatic assert(functionAttributes!(func) & FA.pure_);\nstatic assert(functionAttributes!(func) & FA.safe);\nstatic assert(!(functionAttributes!(func) & FA.trusted)); \/\/ not @trusted\n--------------------\n \n",
"line" : 677,
"base" : "uint",
"members" : [
{
"name" : "none",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n These flags can be bitwise OR-ed together to represent complex attribute.\n     \n ditto\n",
"line" : 682}
,
{
"name" : "pure_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 683}
,
{
"name" : "nothrow_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 684}
,
{
"name" : "ref_",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 685}
,
{
"name" : "property",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 686}
,
{
"name" : "trusted",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 687}
,
{
"name" : "safe",
"kind" : "enum member",
"protection" : "public",
"comment" : " ditto\n",
"line" : 688}
]
}
,
{
"name" : "functionAttributes(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 692,
"members" : [
{
"name" : "Func",
"kind" : "alias",
"type" : "Unqual!(FunctionTypeOf!(func))",
"line" : 695}
,
{
"name" : "functionAttributes",
"kind" : "variable",
"type" : "uint",
"line" : 697}
]
}
,
{
"name" : "isSafe(alias func) if (isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D true) if $(D func) is $(D @safe) or $(D @trusted).\n\nExample:\n--------------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( isSafe!add);\nstatic assert( isSafe!sub);\nstatic assert(!isSafe!mul);\n--------------------\n \n",
"line" : 765,
"members" : [
{
"name" : "isSafe",
"kind" : "variable",
"line" : 769}
]
}
,
{
"name" : "isUnsafe(alias func)",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D true) if $(D func) is $(D @system).\n\nExample:\n--------------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert(!isUnsafe!add);\nstatic assert(!isUnsafe!sub);\nstatic assert( isUnsafe!mul);\n--------------------\n \n",
"line" : 855,
"members" : [
{
"name" : "isUnsafe",
"kind" : "variable",
"line" : 857}
]
}
,
{
"name" : "areAllSafe(funcs...) if (funcs.length > 0)",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(RED Scheduled for deprecation in January 2013. It's badly named and provides\nredundant functionality. It was also badly broken prior to 2.060 (bug# 8362), so\nany code which uses it probably needs to be changed anyway. Please use\n$(D allSatisfy(isSafe, ...)) instead.)\n\n$(D true) all functions are $(D isSafe).\n\nExample:\n--------------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( areAllSafe!(add, add));\nstatic assert( areAllSafe!(add, sub));\nstatic assert(!areAllSafe!(sub, mul));\n--------------------\n \n",
"line" : 947,
"members" : [
]
}
,
{
"name" : "functionLinkage(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the calling convention of function as a string.\n\nExample:\n--------------------\nstring a = functionLinkage!(writeln!(string, int));\nassert(a == \"D\"); \/\/ extern(D)\n\nauto fp = &printf;\nstring b = functionLinkage!(fp);\nassert(b == \"C\"); \/\/ extern(C)\n--------------------\n \n",
"line" : 1003,
"members" : [
{
"name" : "Func",
"kind" : "alias",
"type" : "Unqual!(FunctionTypeOf!(func))",
"line" : 1006}
,
{
"name" : "functionLinkage",
"kind" : "variable",
"type" : "string",
"line" : 1008}
]
}
,
{
"name" : "Variadic",
"kind" : "enum",
"protection" : "public",
"comment" : "\nDetermines what kind of variadic parameters function has.\n\nExample:\n--------------------\nvoid func() {}\nstatic assert(variadicFunctionStyle!(func) == Variadic.no);\n\nextern(C) int printf(in char*, ...);\nstatic assert(variadicFunctionStyle!(printf) == Variadic.c);\n--------------------\n \n",
"line" : 1050,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " Function is not variadic.\n",
"line" : 1051}
,
{
"name" : "c",
"kind" : "enum member",
"protection" : "public",
"comment" : " Function is a _C-style variadic function.\n",
"line" : 1052}
,
{
"name" : "d",
"kind" : "enum member",
"protection" : "public",
"comment" : " Function is a _D-style variadic function, which uses\n __argptr and __arguments.\n",
"line" : 1054}
,
{
"name" : "typesafe",
"kind" : "enum member",
"protection" : "public",
"comment" : " Function is a typesafe variadic function.\n",
"line" : 1055}
]
}
,
{
"name" : "variadicFunctionStyle(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1059,
"members" : [
{
"name" : "Func",
"kind" : "alias",
"type" : "Unqual!(FunctionTypeOf!(func))",
"line" : 1062}
,
{
"name" : "callconv",
"kind" : "variable",
"line" : 1065}
,
{
"name" : "mfunc",
"kind" : "variable",
"line" : 1066}
,
{
"name" : "mtype",
"kind" : "variable",
"line" : 1067}
,
{
"name" : "argclose",
"kind" : "variable",
"line" : 1070}
,
{
"name" : "variadicFunctionStyle",
"kind" : "variable",
"type" : "Variadic",
"line" : 1073}
]
}
,
{
"name" : "FunctionTypeOf(func...) if (func.length == 1 && isCallable!(func))",
"kind" : "template",
"protection" : "public",
"comment" : "\nGet the function type from a callable object $(D func).\n\nUsing builtin $(D typeof) on a property function yields the types of the\nproperty value, not of the property function itself.  Still,\n$(D FunctionTypeOf) is able to obtain function types of properties.\n--------------------\nclass C\n{\n    int value() @property;\n}\nstatic assert(is( typeof(C.value) == int ));\nstatic assert(is( FunctionTypeOf!(C.value) == function ));\n--------------------\n\nNote:\nDo not confuse function types with function pointer types; function types are\nusually used for compile-time reflection purposes.\n \n",
"line" : 1114,
"members" : [
]
}
,
{
"name" : "SetFunctionAttributes(T,string linkage,uint attrs) if (isFunctionPointer!(T) || isDelegate!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Constructs a new function or delegate type with the same basic signature\n as the given one, but different attributes (including linkage).\n\n This is especially useful for adding\/removing attributes from\/to types in\n generic code, where the actual type name cannot be spelt out.\n\n Params:\n    T = The base type.\n    linkage = The desired linkage of the result type.\n    attrs = The desired $(LREF FunctionAttribute)s of the result type.\n\n Examples:\n ---\n template ExternC(T)\n     if (isFunctionPointer!T || isDelegate!T || is(T == function))\n {\n     alias SetFunctionAttributes!(T, \"C\", functionAttributes!T) ExternC;\n }\n ---\n\n ---\n auto assumePure(T)(T t)\n     if (isFunctionPointer!T || isDelegate!T)\n {\n     enum attrs = functionAttributes!T | FunctionAttribute.pure_;\n     return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;\n }\n ---\n \n",
"line" : 1224,
"members" : [
]
}
,
{
"name" : "SetFunctionAttributes(T,string linkage,uint attrs) if (is(T == function))",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 1283,
"members" : [
{
"name" : "SetFunctionAttributes",
"kind" : "alias",
"type" : "FunctionTypeOf!(SetFunctionAttributes!(T*,linkage,attrs))",
"line" : 1290}
]
}
,
{
"name" : "FieldTypeTuple(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the types of the fields of a struct or class.\n This consists of the fields that take up memory space,\n excluding the hidden fields like the virtual function\n table pointer.\n \n",
"line" : 1356,
"members" : [
]
}
,
{
"name" : "RepresentationTypeTuple(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nGet the primitive types of the fields of a struct or class, in\ntopological order.\n\nExample:\n----\nstruct S1 { int a; float b; }\nstruct S2 { char[] a; union { S1 b; S1 * c; } }\nalias RepresentationTypeTuple!(S2) R;\nassert(R.length == 4\n    && is(R[0] == char[]) && is(R[1] == int)\n    && is(R[2] == float) && is(R[3] == S1*));\n----\n",
"line" : 1461,
"members" : [
{
"name" : "Impl(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1463,
"members" : [
]
}
]
}
,
{
"name" : "hasRawAliasing(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1621,
"members" : [
{
"name" : "Impl(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1623,
"members" : [
]
}
,
{
"name" : "hasRawAliasing",
"kind" : "variable",
"line" : 1644}
]
}
,
{
"name" : "hasRawUnsharedAliasing(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1726,
"members" : [
{
"name" : "Impl(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1728,
"members" : [
]
}
,
{
"name" : "hasRawUnsharedAliasing",
"kind" : "variable",
"line" : 1749}
]
}
,
{
"name" : "hasObjects(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1813,
"members" : [
]
}
,
{
"name" : "hasUnsharedObjects(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1841,
"members" : [
]
}
,
{
"name" : "hasAliasing(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable;) $(LI an array $(D U[]) and $(D U) is not\nimmutable;) $(LI a reference to a class or interface type $(D C) and $(D C) is\nnot immutable.) $(LI an associative array that is not immutable.)\n$(LI a delegate.))\n",
"line" : 1873,
"members" : [
{
"name" : "hasAliasing",
"kind" : "variable",
"line" : 1876}
]
}
,
{
"name" : "hasAliasing(R : Rebindable!(R))",
"kind" : "template",
"protection" : "public",
"line" : 1880,
"members" : [
{
"name" : "hasAliasing",
"kind" : "variable",
"line" : 1882}
]
}
,
{
"name" : "hasIndirections(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*);) $(LI an\narray $(D U[]);) $(LI a reference to a class type $(D C).)\n$(LI an associative array.) $(LI a delegate.))\n \n",
"line" : 1916,
"members" : [
{
"name" : "Impl(T...)",
"kind" : "template",
"protection" : "public",
"line" : 1918,
"members" : [
]
}
,
{
"name" : "hasIndirections",
"kind" : "variable",
"line" : 1945}
]
}
,
{
"name" : "hasLocalAliasing",
"kind" : "alias",
"protection" : "public",
"line" : 1973}
,
{
"name" : "hasRawLocalAliasing",
"kind" : "alias",
"protection" : "public",
"line" : 1974}
,
{
"name" : "hasLocalObjects",
"kind" : "alias",
"protection" : "public",
"line" : 1975}
,
{
"name" : "hasUnsharedAliasing(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable or shared;) $(LI an array $(D U[]) and $(D U) is not\nimmutable or shared;) $(LI a reference to a class type $(D C) and\n$(D C) is not immutable or shared.) $(LI an associative array that is not\nimmutable or shared.) $(LI a delegate that is not shared.))\n",
"line" : 1986,
"members" : [
]
}
,
{
"name" : "hasElaborateCopyConstructor(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n True if $(D S) or any type embedded directly in the representation of $(D S)\n defines an elaborate copy constructor. Elaborate copy constructors are\n introduced by defining $(D this(this)) for a $(D struct). (Non-struct types\n never have elaborate copy constructors.)\n \n",
"line" : 2061,
"members" : [
]
}
,
{
"name" : "hasElaborateAssign(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   True if $(D S) or any type directly embedded in the representation of $(D S)\n   defines an elaborate assignmentq. Elaborate assignments are introduced by\n   defining $(D opAssign(typeof(this))) or $(D opAssign(ref typeof(this)))\n   for a $(D struct). (Non-struct types never have elaborate assignments.)\n \n",
"line" : 2095,
"members" : [
]
}
,
{
"name" : "hasElaborateDestructor(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   True if $(D S) or any type directly embedded in the representation\n   of $(D S) defines an elaborate destructor. Elaborate destructors\n   are introduced by defining $(D ~this()) for a $(D\n   struct). (Non-struct types never have elaborate destructors, even\n   though classes may define $(D ~this()).)\n \n",
"line" : 2138,
"members" : [
]
}
,
{
"name" : "Identity(alias A)",
"kind" : "template",
"protection" : "public",
"line" : 2175,
"members" : [
{
"name" : "Identity",
"kind" : "alias",
"type" : "A",
"line" : 2175}
]
}
,
{
"name" : "hasMember(T,string name)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Yields $(D true) if and only if $(D T) is an aggregate that defines\n   a symbol called $(D name).\n \n",
"line" : 2181,
"members" : [
]
}
,
{
"name" : "EnumMembers(E) if (is(E == enum))",
"kind" : "template",
"protection" : "public",
"comment" : "\nRetrieves the members of an enumerated type $(D enum E).\n\nParams:\n E = An enumerated type. $(D E) may have duplicated values.\n\nReturns:\n Static tuple composed of the members of the enumerated type $(D E).\n The members are arranged in the same order as declared in $(D E).\n\nNote:\n Returned values are strictly typed with $(D E). Thus, the following code\n does not work without the explicit cast:\n--------------------\nenum E : int { a, b, c }\nint[] abc = cast(int[]) [ EnumMembers!E ];\n--------------------\n Cast is not necessary if the type of the variable is inferred. See the\n example below.\n\nExamples:\n Creating an array of enumerated values:\n--------------------\nenum Sqrts : real\n{\n    one   = 1,\n    two   = 1.41421,\n    three = 1.73205,\n}\nauto sqrts = [ EnumMembers!Sqrts ];\nassert(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);\n--------------------\n\n A generic function $(D rank(v)) in the following example uses this\n template for finding a member $(D e) in an enumerated type $(D E).\n--------------------\n\/\/ Returns i if e is the i-th enumerator of E.\nsize_t rank(E)(E e)\n    if (is(E == enum))\n{\n    foreach (i, member; EnumMembers!E)\n    {\n        if (e == member)\n            return i;\n    }\n    assert(0, \"Not an enum member\");\n}\n\nenum Mode\n{\n    read  = 1,\n    write = 2,\n    map   = 4,\n}\nassert(rank(Mode.read ) == 0);\nassert(rank(Mode.write) == 1);\nassert(rank(Mode.map  ) == 2);\n--------------------\n \n",
"line" : 2305,
"members" : [
{
"name" : "WithIdentifier(string ident)",
"kind" : "template",
"protection" : "public",
"line" : 2309,
"members" : [
]
}
,
{
"name" : "EnumSpecificMembers(names...)",
"kind" : "template",
"protection" : "public",
"line" : 2327,
"members" : [
]
}
,
{
"name" : "EnumMembers",
"kind" : "alias",
"type" : "EnumSpecificMembers!(__traits(allMembers,E))",
"line" : 2343}
]
}
,
{
"name" : "BaseTypeTuple(A)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get a $(D_PARAM TypeTuple) of the base class and base interfaces of\n this class or interface. $(D_PARAM BaseTypeTuple!(Object)) returns\n the empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I { }\n class A { }\n class B : A, I { }\n\n void main()\n {\n     alias BaseTypeTuple!(B) TL;\n     writeln(typeid(TL));        \/\/ prints: (A,I)\n }\n ---\n \n",
"line" : 2411,
"members" : [
]
}
,
{
"name" : "BaseClassesTuple(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get a $(D_PARAM TypeTuple) of $(I all) base classes of this class,\n in decreasing order. Interfaces are not included. $(D_PARAM\n BaseClassesTuple!(Object)) yields the empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I { }\n class A { }\n class B : A, I { }\n class C : B { }\n\n void main()\n {\n     alias BaseClassesTuple!(C) TL;\n     writeln(typeid(TL));        \/\/ prints: (B,A,Object)\n }\n ---\n \n",
"line" : 2468,
"members" : [
]
}
,
{
"name" : "InterfacesTuple(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get a $(D_PARAM TypeTuple) of $(I all) interfaces directly or\n indirectly inherited by this class or interface. Interfaces do not\n repeat if multiply implemented. $(D_PARAM InterfacesTuple!(Object))\n yields the empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I1 { }\n interface I2 { }\n class A : I1, I2 { }\n class B : A, I1 { }\n class C : B { }\n\n void main()\n {\n     alias InterfacesTuple!(C) TL;\n     writeln(typeid(TL));        \/\/ prints: (I1, I2)\n }\n ---\n \n",
"line" : 2509,
"members" : [
{
"name" : "Flatten(H,T...)",
"kind" : "template",
"protection" : "public",
"line" : 2511,
"members" : [
]
}
]
}
,
{
"name" : "TransitiveBaseTypeTuple(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get a $(D_PARAM TypeTuple) of $(I all) base classes of $(D_PARAM\n T), in decreasing order, followed by $(D_PARAM T)'s\n interfaces. $(D_PARAM TransitiveBaseTypeTuple!(Object)) yields the\n empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I { }\n class A { }\n class B : A, I { }\n class C : B { }\n\n void main()\n {\n     alias TransitiveBaseTypeTuple!(C) TL;\n     writeln(typeid(TL));        \/\/ prints: (B,A,Object,I)\n }\n ---\n \n",
"line" : 2584,
"members" : [
]
}
,
{
"name" : "MemberFunctionsTuple(C,string name) if (is(C == class) || is(C == interface))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a tuple of non-static functions with the name $(D name) declared in the\nclass or interface $(D C).  Covariant duplicates are shrunk into the most\nderived one.\n\nExample:\n--------------------\ninterface I { I foo(); }\nclass B\n{\n    real foo(real v) { return v; }\n}\nclass C : B, I\n{\n    override C foo() { return this; } \/\/ covariant overriding of I.foo()\n}\nalias MemberFunctionsTuple!(C, \"foo\") foos;\nstatic assert(foos.length == 2);\nstatic assert(__traits(isSame, foos[0], C.foo));\nstatic assert(__traits(isSame, foos[1], B.foo));\n--------------------\n \n",
"line" : 2634,
"members" : [
]
}
,
{
"name" : "CommonType(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nGet the type that all types can be implicitly converted to. Useful\ne.g. in figuring out an array type from a bunch of initializing\nvalues. Returns $(D_PARAM void) if passed an empty list, or if the\ntypes have no common type.\n\nExample:\n\n----\nalias CommonType!(int, long, short) X;\nassert(is(X == long));\nalias CommonType!(int, char[], short) Y;\nassert(is(Y == void));\n----\n",
"line" : 2784,
"members" : [
]
}
,
{
"name" : "ImplicitConversionTargets(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a tuple with all possible target types of an implicit\n conversion of a value of type $(D_PARAM T).\n\n Important note:\n\n The possible targets are computed more conservatively than the D\n 2.005 compiler does, eliminating all dangerous conversions. For\n example, $(D_PARAM ImplicitConversionTargets!(double)) does not\n include $(D_PARAM float).\n \n",
"line" : 2833,
"members" : [
]
}
,
{
"name" : "isImplicitlyConvertible(From,To)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIs $(D From) implicitly convertible to $(D To)?\n \n",
"line" : 2909,
"members" : [
{
"name" : "isImplicitlyConvertible",
"kind" : "variable",
"type" : "bool",
"line" : 2911}
]
}
,
{
"name" : "isAssignable(Lhs,Rhs)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) iff a value of type $(D Rhs) can be assigned to a variable of\ntype $(D Lhs).\n\nExamples:\n---\nstatic assert(isAssignable!(long, int));\nstatic assert(!isAssignable!(int, long));\nstatic assert( isAssignable!(const(char)[], string));\nstatic assert(!isAssignable!(string, char[]));\n---\n",
"line" : 2950,
"members" : [
{
"name" : "isAssignable",
"kind" : "variable",
"type" : "bool",
"line" : 2952}
]
}
,
{
"name" : "isStorageClassImplicitlyConvertible(From,To)",
"kind" : "template",
"protection" : "public",
"line" : 2974,
"members" : [
{
"name" : "isStorageClassImplicitlyConvertible",
"kind" : "variable",
"line" : 2978}
]
}
,
{
"name" : "Pointify(T)",
"kind" : "template",
"protection" : "public",
"line" : 2980,
"members" : [
{
"name" : "Pointify",
"kind" : "alias",
"type" : "void*",
"line" : 2980}
]
}
,
{
"name" : "isCovariantWith(F,G) if (is(F == function) && is(G == function))",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetermines whether the function type $(D F) is covariant with $(D G), i.e.,\nfunctions of the type $(D F) can override ones of the type $(D G).\n\nExample:\n--------------------\ninterface I { I clone(); }\ninterface J { J clone(); }\nclass C : I\n{\n    override C clone()   \/\/ covariant overriding of I.clone()\n    {\n        return new C;\n    }\n}\n\n\/\/ C.clone() can override I.clone(), indeed.\nstatic assert(isCovariantWith!(typeof(C.clone), typeof(I.clone)));\n\n\/\/ C.clone() can't override J.clone(); the return type C is not implicitly\n\/\/ convertible to J.\nstatic assert(isCovariantWith!(typeof(C.clone), typeof(J.clone)));\n--------------------\n \n",
"line" : 3018,
"members" : [
]
}
,
{
"name" : "BooleanTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3195,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "inout(bool)(inout(bool))",
"line" : 3197}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(bool))(shared(inout(bool)))",
"line" : 3198}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(bool)(immutable(bool))",
"line" : 3200}
]
}
,
{
"name" : "IntegralTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3229,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "inout(byte)(inout(byte))",
"line" : 3231}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(ubyte)(inout(ubyte))",
"line" : 3232}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(short)(inout(short))",
"line" : 3233}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(ushort)(inout(ushort))",
"line" : 3234}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(int)(inout(int))",
"line" : 3235}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(uint)(inout(uint))",
"line" : 3236}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(long)(inout(long))",
"line" : 3237}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(ulong)(inout(ulong))",
"line" : 3238}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(byte))(shared(inout(byte)))",
"line" : 3239}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(ubyte))(shared(inout(ubyte)))",
"line" : 3240}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(short))(shared(inout(short)))",
"line" : 3241}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(ushort))(shared(inout(ushort)))",
"line" : 3242}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(int))(shared(inout(int)))",
"line" : 3243}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(uint))(shared(inout(uint)))",
"line" : 3244}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(long))(shared(inout(long)))",
"line" : 3245}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(ulong))(shared(inout(ulong)))",
"line" : 3246}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(char)(immutable(char))",
"line" : 3248}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(wchar)(immutable(wchar))",
"line" : 3249}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(dchar)(immutable(dchar))",
"line" : 3250}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(byte)(immutable(byte))",
"line" : 3253}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(ubyte)(immutable(ubyte))",
"line" : 3254}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(short)(immutable(short))",
"line" : 3255}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(ushort)(immutable(ushort))",
"line" : 3256}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(int)(immutable(int))",
"line" : 3257}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(uint)(immutable(uint))",
"line" : 3258}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(long)(immutable(long))",
"line" : 3259}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(ulong)(immutable(ulong))",
"line" : 3260}
]
}
,
{
"name" : "FloatingPointTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3288,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "inout(float)(inout(float))",
"line" : 3290}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(double)(inout(double))",
"line" : 3291}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(real)(inout(real))",
"line" : 3292}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(float))(shared(inout(float)))",
"line" : 3293}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(double))(shared(inout(double)))",
"line" : 3294}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(real))(shared(inout(real)))",
"line" : 3295}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(float)(immutable(float))",
"line" : 3297}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(double)(immutable(double))",
"line" : 3298}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(real)(immutable(real))",
"line" : 3299}
]
}
,
{
"name" : "NumericTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3327,
"members" : [
]
}
,
{
"name" : "UnsignedTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3355,
"members" : [
]
}
,
{
"name" : "SignedTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3364,
"members" : [
]
}
,
{
"name" : "CharTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3377,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "inout(char)(inout(char))",
"line" : 3379}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(wchar)(inout(wchar))",
"line" : 3380}
,
{
"name" : "idx",
"kind" : "function",
"type" : "inout(dchar)(inout(dchar))",
"line" : 3381}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(char))(shared(inout(char)))",
"line" : 3382}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(wchar))(shared(inout(wchar)))",
"line" : 3383}
,
{
"name" : "idx",
"kind" : "function",
"type" : "shared(inout(dchar))(shared(inout(dchar)))",
"line" : 3384}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(char)(immutable(char))",
"line" : 3386}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(wchar)(immutable(wchar))",
"line" : 3387}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(dchar)(immutable(dchar))",
"line" : 3388}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(byte)(immutable(byte))",
"line" : 3391}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(ubyte)(immutable(ubyte))",
"line" : 3392}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(short)(immutable(short))",
"line" : 3393}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(ushort)(immutable(ushort))",
"line" : 3394}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(int)(immutable(int))",
"line" : 3395}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(uint)(immutable(uint))",
"line" : 3396}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(long)(immutable(long))",
"line" : 3397}
,
{
"name" : "idy",
"kind" : "function",
"type" : "immutable(ulong)(immutable(ulong))",
"line" : 3398}
]
}
,
{
"name" : "StaticArrayTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3432,
"members" : [
{
"name" : "idx(U,size_t n)",
"kind" : "template",
"protection" : "public",
"line" : 3434,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "inout(U[n])(inout(U[n]))",
"line" : 3434}
]
}
]
}
,
{
"name" : "DynamicArrayTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3463,
"members" : [
{
"name" : "idx(U)",
"kind" : "template",
"protection" : "public",
"line" : 3465,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "inout(U[])(inout(U[]))",
"line" : 3465}
]
}
]
}
,
{
"name" : "ArrayTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3503,
"members" : [
]
}
,
{
"name" : "StringTypeOf(T) if (!is(T == enum) && isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"line" : 3519,
"members" : [
{
"name" : "StringTypeOf",
"kind" : "alias",
"type" : "ArrayTypeOf!(T)",
"line" : 3521}
]
}
,
{
"name" : "AssocArrayTypeOf(T) if (!is(T == enum))",
"kind" : "template",
"protection" : "public",
"line" : 3549,
"members" : [
{
"name" : "idx(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3551,
"members" : [
{
"name" : "idx",
"kind" : "function",
"type" : "immutable(V[K])(immutable(V[K]))",
"line" : 3551}
]
}
,
{
"name" : "idy(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3553,
"members" : [
{
"name" : "idy",
"kind" : "function",
"type" : "inout(V)[K](inout(V)[K])",
"line" : 3553}
]
}
,
{
"name" : "idy(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3554,
"members" : [
{
"name" : "idy",
"kind" : "function",
"type" : "shared(V[K])(shared(V[K]))",
"line" : 3554}
]
}
,
{
"name" : "idz(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3556,
"members" : [
{
"name" : "idz",
"kind" : "function",
"type" : "inout(V[K])(inout(V[K]))",
"line" : 3556}
]
}
,
{
"name" : "idz(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3557,
"members" : [
{
"name" : "idz",
"kind" : "function",
"type" : "shared(inout(V[K]))(shared(inout(V[K])))",
"line" : 3557}
]
}
,
{
"name" : "idw(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3559,
"members" : [
{
"name" : "idw",
"kind" : "function",
"type" : "inout(immutable(V)[K])(inout(immutable(V)[K]))",
"line" : 3559}
]
}
,
{
"name" : "idw(K,V)",
"kind" : "template",
"protection" : "public",
"line" : 3560,
"members" : [
{
"name" : "idw",
"kind" : "function",
"type" : "shared(inout(immutable(V)[K]))(shared(inout(immutable(V)[K])))",
"line" : 3560}
]
}
]
}
,
{
"name" : "BuiltinTypeOf(T)",
"kind" : "template",
"protection" : "public",
"line" : 3610,
"members" : [
]
}
,
{
"name" : "isBoolean(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether we can treat T as a built-in boolean type.\n \n",
"line" : 3631,
"members" : [
{
"name" : "isBoolean",
"kind" : "variable",
"type" : "bool",
"line" : 3633}
]
}
,
{
"name" : "isIntegral(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether we can treat T as a built-in integral type. Types $(D bool),\n $(D char), $(D wchar), and $(D dchar) are not considered integral.\n \n",
"line" : 3640,
"members" : [
{
"name" : "isIntegral",
"kind" : "variable",
"type" : "bool",
"line" : 3642}
]
}
,
{
"name" : "isFloatingPoint(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether we can treat T as a built-in floating point type.\n \n",
"line" : 3701,
"members" : [
{
"name" : "isFloatingPoint",
"kind" : "variable",
"type" : "bool",
"line" : 3703}
]
}
,
{
"name" : "isNumeric(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether we can treat T as a built-in numeric type (integral or floating\npoint).\n \n",
"line" : 3732,
"members" : [
{
"name" : "isNumeric",
"kind" : "variable",
"type" : "bool",
"line" : 3734}
]
}
,
{
"name" : "isScalarType(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether T is a scalar type.\n \n",
"line" : 3740,
"members" : [
{
"name" : "isScalarType",
"kind" : "variable",
"type" : "bool",
"line" : 3742}
]
}
,
{
"name" : "isBasicType(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether T is a basic type.\n \n",
"line" : 3757,
"members" : [
{
"name" : "isBasicType",
"kind" : "variable",
"type" : "bool",
"line" : 3759}
]
}
,
{
"name" : "isUnsigned(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether $(D T) is a built-in unsigned numeric type.\n \n",
"line" : 3774,
"members" : [
{
"name" : "isUnsigned",
"kind" : "variable",
"type" : "bool",
"line" : 3776}
]
}
,
{
"name" : "isSigned(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether $(D T) is a built-in signed numeric type.\n \n",
"line" : 3782,
"members" : [
{
"name" : "isSigned",
"kind" : "variable",
"type" : "bool",
"line" : 3784}
]
}
,
{
"name" : "isSomeChar(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether we can treat T as one of the built-in character types.\n \n",
"line" : 3790,
"members" : [
{
"name" : "isSomeChar",
"kind" : "variable",
"line" : 3792}
]
}
,
{
"name" : "isSomeString(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether we can treat T as one of the built-in string types.\n \n",
"line" : 3813,
"members" : [
]
}
,
{
"name" : "isNarrowString(T)",
"kind" : "template",
"protection" : "public",
"line" : 3845,
"members" : [
{
"name" : "isNarrowString",
"kind" : "variable",
"line" : 3847}
]
}
,
{
"name" : "isStaticArray(T : U[N],U,ulong N)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether type T is a static array.\n \n",
"line" : 3867,
"members" : [
{
"name" : "isStaticArray",
"kind" : "variable",
"type" : "bool",
"line" : 3869}
]
}
,
{
"name" : "isStaticArray(T)",
"kind" : "template",
"protection" : "public",
"line" : 3872,
"members" : [
{
"name" : "isStaticArray",
"kind" : "variable",
"type" : "bool",
"line" : 3874}
]
}
,
{
"name" : "isDynamicArray(T,U = void)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether type T is a dynamic array.\n \n",
"line" : 3900,
"members" : [
{
"name" : "isDynamicArray",
"kind" : "variable",
"type" : "bool",
"line" : 3902}
]
}
,
{
"name" : "isDynamicArray(T : U[],U)",
"kind" : "template",
"protection" : "public",
"line" : 3905,
"members" : [
{
"name" : "isDynamicArray",
"kind" : "variable",
"type" : "bool",
"line" : 3907}
]
}
,
{
"name" : "isArray(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether type T is an array.\n \n",
"line" : 3920,
"members" : [
{
"name" : "isArray",
"kind" : "variable",
"type" : "bool",
"line" : 3922}
]
}
,
{
"name" : "isAssociativeArray(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether T is an associative array type\n \n",
"line" : 3939,
"members" : [
{
"name" : "isAssociativeArray",
"kind" : "variable",
"type" : "bool",
"line" : 3941}
]
}
,
{
"name" : "isBuiltinType(T)",
"kind" : "template",
"protection" : "public",
"line" : 3962,
"members" : [
{
"name" : "isBuiltinType",
"kind" : "variable",
"line" : 3964}
]
}
,
{
"name" : "isPointer(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether type $(D T) is a pointer.\n \n",
"line" : 3970,
"members" : [
]
}
,
{
"name" : "PointerTarget(T : T*)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the target type of a pointer.\n",
"line" : 3996,
"members" : [
{
"name" : "PointerTarget",
"kind" : "alias",
"type" : "T",
"line" : 3998}
]
}
,
{
"name" : "pointerTarget",
"kind" : "alias",
"protection" : "public",
"comment" : " $(RED Scheduled for deprecation. Please use $(LREF PointerTarget) instead.)\n",
"line" : 4002}
,
{
"name" : "isAggregateType(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Detect whether type $(D T) is an aggregate type.\n \n",
"line" : 4015,
"members" : [
{
"name" : "isAggregateType",
"kind" : "variable",
"line" : 4018}
]
}
,
{
"name" : "isIterable(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns $(D true) if T can be iterated over using a $(D foreach) loop with\n a single loop variable of automatically inferred type, regardless of how\n the $(D foreach) loop is implemented.  This includes ranges, structs\/classes\n that define $(D opApply) with a single loop variable, and builtin dynamic,\n static and associative arrays.\n \n",
"line" : 4028,
"members" : [
{
"name" : "isIterable",
"kind" : "variable",
"line" : 4030}
]
}
,
{
"name" : "isMutable(T)",
"kind" : "template",
"protection" : "public",
"line" : 4059,
"members" : [
{
"name" : "isMutable",
"kind" : "variable",
"line" : 4061}
]
}
,
{
"name" : "isExpressionTuple(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Tells whether the tuple T is an expression tuple.\n \n",
"line" : 4081,
"members" : [
]
}
,
{
"name" : "isTypeTuple(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether tuple $(D T) is a type tuple.\n \n",
"line" : 4114,
"members" : [
]
}
,
{
"name" : "isFunctionPointer(T...) if (T.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether symbol or type $(D T) is a function pointer.\n \n",
"line" : 4144,
"members" : [
]
}
,
{
"name" : "isDelegate(T...) if (T.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether $(D T) is a delegate.\n",
"line" : 4179,
"members" : [
{
"name" : "isDelegate",
"kind" : "variable",
"type" : "bool",
"line" : 4182}
]
}
,
{
"name" : "isSomeFunction(T...) if (T.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether symbol or type $(D T) is a function, a function pointer or a delegate.\n \n",
"line" : 4199,
"members" : [
]
}
,
{
"name" : "isCallable(T...) if (T.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDetect whether $(D T) is a callable object, which can be called with the\nfunction call operator $(D $(LPAREN)...$(RPAREN)).\n \n",
"line" : 4260,
"members" : [
]
}
,
{
"name" : "isAbstractFunction(method...) if (method.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nExactly the same as the builtin traits:\n$(D ___traits(_isAbstractFunction, method)).\n \n",
"line" : 4294,
"members" : [
{
"name" : "isAbstractFunction",
"kind" : "variable",
"type" : "bool",
"line" : 4297}
]
}
,
{
"name" : "Unqual(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nRemoves all qualifiers, if any, from type $(D T).\n\nExample:\n----\nstatic assert(is(Unqual!(int) == int));\nstatic assert(is(Unqual!(const int) == int));\nstatic assert(is(Unqual!(immutable int) == int));\nstatic assert(is(Unqual!(shared int) == int));\nstatic assert(is(Unqual!(shared(const int)) == int));\n----\n \n",
"line" : 4318,
"members" : [
]
}
,
{
"name" : "ModifyTypePreservingSTC(alias Modifier,T)",
"kind" : "template",
"protection" : "public",
"line" : 4352,
"members" : [
]
}
,
{
"name" : "ForeachType(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the inferred type of the loop variable when a variable of type T\nis iterated over using a $(D foreach) loop with a single loop variable and\nautomatically inferred return type.  Note that this may not be the same as\n$(D std.range.ElementType!(Range)) in the case of narrow strings, or if T\nhas both opApply and a range interface.\n",
"line" : 4377,
"members" : [
{
"name" : "ForeachType",
"kind" : "alias",
"type" : "ReturnType!(typeof(delegate (int x = 0)\n{\nforeach (elem; T.init)\n{\nreturn elem;\n}\nassert(0);\n}\n))",
"line" : 4387}
]
}
,
{
"name" : "OriginalType(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nStrips off all $(D typedef)s (including $(D enum) ones) from type $(D T).\n\nExample:\n--------------------\nenum E : int { a }\ntypedef E F;\ntypedef const F G;\nstatic assert(is(OriginalType!G == const int));\n--------------------\n \n",
"line" : 4410,
"members" : [
{
"name" : "Impl(T)",
"kind" : "template",
"protection" : "public",
"line" : 4412,
"members" : [
]
}
,
{
"name" : "OriginalType",
"kind" : "alias",
"type" : "ModifyTypePreservingSTC!(Impl,T)",
"line" : 4419}
]
}
,
{
"name" : "KeyType(V : V[K],K)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the Key type of an Associative Array.\n Example:\n ---\n import std.traits;\n alias int[string] Hash;\n static assert(is(KeyType!Hash == string));\n KeyType!Hash str = \"string\";   \/\/ str is declared as string\n ---\n \n",
"line" : 4448,
"members" : [
{
"name" : "KeyType",
"kind" : "alias",
"type" : "K",
"line" : 4450}
]
}
,
{
"name" : "ValueType(V : V[K],K)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Get the Value type of an Associative Array.\n Example:\n ---\n import std.traits;\n alias int[string] Hash;\n static assert(is(ValueType!Hash == int));\n ValueType!Hash num = 1;   \/\/ num is declared as int\n ---\n \n",
"line" : 4463,
"members" : [
{
"name" : "ValueType",
"kind" : "alias",
"type" : "V",
"line" : 4465}
]
}
,
{
"name" : "Unsigned(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the corresponding unsigned type for T. T must be a numeric\n integral type, otherwise a compile-time error occurs.\n \n",
"line" : 4481,
"members" : [
{
"name" : "Impl(T)",
"kind" : "template",
"protection" : "public",
"line" : 4483,
"members" : [
]
}
,
{
"name" : "Unsigned",
"kind" : "alias",
"type" : "ModifyTypePreservingSTC!(Impl,OriginalType!(T))",
"line" : 4499}
]
}
,
{
"name" : "Largest(T...) if (T.length >= 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the largest type, i.e. T such that T.sizeof is the largest.  If more\nthan one type is of the same size, the leftmost argument of these in will be\nreturned.\n",
"line" : 4520,
"members" : [
]
}
,
{
"name" : "Signed(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the corresponding signed type for T. T must be a numeric integral type,\notherwise a compile-time error occurs.\n \n",
"line" : 4555,
"members" : [
{
"name" : "Impl(T)",
"kind" : "template",
"protection" : "public",
"line" : 4557,
"members" : [
]
}
,
{
"name" : "Signed",
"kind" : "alias",
"type" : "ModifyTypePreservingSTC!(Impl,OriginalType!(T))",
"line" : 4573}
]
}
,
{
"name" : "unsigned(T) if (isIntegral!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the corresponding unsigned value for $(D x), e.g. if $(D x)\n has type $(D int), returns $(D cast(uint) x). The advantage\n compared to the cast is that you do not need to rewrite the cast if\n $(D x) later changes type to e.g. $(D long).\n \n",
"line" : 4592,
"members" : [
{
"name" : "unsigned",
"kind" : "function",
"type" : "(T x)",
"comment" : "\n Returns the corresponding unsigned value for $(D x), e.g. if $(D x)\n has type $(D int), returns $(D cast(uint) x). The advantage\n compared to the cast is that you do not need to rewrite the cast if\n $(D x) later changes type to e.g. $(D long).\n \n",
"line" : 4592}
]
}
,
{
"name" : "unsigned(T) if (isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"line" : 4636,
"members" : [
{
"name" : "unsigned",
"kind" : "function",
"type" : "(T x)",
"line" : 4636}
]
}
,
{
"name" : "mostNegative(T) if (isNumeric!(T) || isSomeChar!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the most negative value of the numeric type T.\n",
"line" : 4656,
"members" : [
]
}
,
{
"name" : "mangledName(sth...) if (sth.length == 1)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns the mangled name of symbol or type $(D sth).\n\n$(D mangledName) is the same as builtin $(D .mangleof) property, except that\nthe correct names of property functions are obtained.\n--------------------\nmodule test;\nimport std.traits : mangledName;\n\nclass C\n{\n    int value() @property;\n}\npragma(msg, C.value.mangleof);      \/\/ prints \"i\"\npragma(msg, mangledName!(C.value)); \/\/ prints \"_D4test1C5valueMFNdZi\"\n--------------------\n \n",
"line" : 4702,
"members" : [
]
}
,
{
"name" : "Dummy(T...)",
"kind" : "template",
"protection" : "public",
"line" : 4716,
"members" : [
{
"name" : "Hook",
"kind" : "struct",
"protection" : "public",
"line" : 4716,
"members" : [
]
}
]
}
,
{
"name" : "removeDummyEnvelope",
"kind" : "function",
"protection" : "private",
"type" : "string(string s)",
"line" : 4718}
,
{
"name" : "Select(bool condition,T,F)",
"kind" : "template",
"protection" : "public",
"comment" : "\nAliases itself to $(D T) if the boolean $(D condition) is $(D true)\nand to $(D F) otherwise.\n\nExample:\n----\nalias Select!(size_t.sizeof == 4, int, long) Int;\n----\n \n",
"line" : 4807,
"members" : [
]
}
,
{
"name" : "select(bool cond : true,A,B)",
"kind" : "template",
"protection" : "public",
"comment" : "\nIf $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n \n",
"line" : 4823,
"members" : [
{
"name" : "select",
"kind" : "function",
"type" : "A(A a, lazy B b)",
"comment" : "\nIf $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n \n",
"line" : 4823}
]
}
,
{
"name" : "select(bool cond : false,A,B)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 4825,
"members" : [
{
"name" : "select",
"kind" : "function",
"type" : "B(lazy A a, B b)",
"comment" : " Ditto\n",
"line" : 4825}
]
}
]
}
,
{
"name" : "std.typecons",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/typecons.d",
"comment" : "\nThis module implements a variety of type constructors, i.e., templates\nthat allow construction of new, useful general-purpose types.\n\nSource:    $(PHOBOSSRC std\/_typecons.d)\n\nMacros:\n\nWIKI = Phobos\/StdVariant\n\nSynopsis:\n\n----\n\/\/ value tuples\nalias Tuple!(float, \"x\", float, \"y\", float, \"z\") Coord;\nCoord c;\nc[1] = 1;       \/\/ access by index\nc.z = 1;        \/\/ access by given name\nalias Tuple!(string, string) DicEntry; \/\/ names can be omitted\n\n\/\/ Rebindable references to const and immutable objects\nvoid bar()\n{\n    const w1 = new Widget, w2 = new Widget;\n    w1.foo();\n    \/\/ w1 = w2 would not work; can't rebind const object\n    auto r = Rebindable!(const Widget)(w1);\n    \/\/ invoke method as if r were a Widget object\n    r.foo();\n    \/\/ rebind r to refer to another object\n    r = w2;\n}\n----\n\nCopyright: Copyright the respective authors, 2008-\nLicense:   $(WEB boost.org\/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n           $(WEB bartoszmilewski.wordpress.com, Bartosz Milewski),\n           Don Clugston,\n           Shin Fujishiro,\n           Kenji Hara\n \n",
"members" : [
{
"name" : "Unique(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nEncapsulates unique ownership of a resource.  Resource of type T is\ndeleted at the end of the scope, unless it is transferred.  The\ntransfer can be explicit, by calling $(D release), or implicit, when\nreturning Unique from a function. The resource can be a polymorphic\nclass object, in which case Unique behaves polymorphically too.\n\nExample:\n",
"line" : 62,
"members" : [
{
"name" : "Unique",
"kind" : "struct",
"protection" : "public",
"line" : 62,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(RefT p)",
"comment" : "\n    Constructor that takes an rvalue.\n    It will ensure uniqueness, as long as the rvalue\n    isn't just a view on an lvalue (e.g., a cast)\n    Typical usage:\n    ----\n    Unique!(Foo) f = new Foo;\n    ----\n    \n",
"line" : 89}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref RefT p)",
"comment" : "\n    Constructor that takes an lvalue. It nulls its source.\n    The nulling will ensure uniqueness as long as there\n    are no previous aliases to the source.\n    \n",
"line" : 99}
,
{
"name" : "isEmpty",
"kind" : "function",
"type" : "const bool()",
"line" : 138}
,
{
"name" : "release",
"kind" : "function",
"type" : "Unique()",
"comment" : " Returns a unique rvalue. Nullifies the current contents \n",
"line" : 143}
,
{
"name" : "opDot",
"kind" : "function",
"type" : "RefT()",
"comment" : " Forwards member access to contents \n",
"line" : 152}
,
{
"name" : "_p",
"kind" : "variable",
"type" : "RefT",
"line" : 162}
]
}
]
}
,
{
"name" : "Tuple(Specs...)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nTuple of values, for example $(D Tuple!(int, string)) is a record that\nstores an $(D int) and a $(D string). $(D Tuple) can be used to bundle\nvalues together, notably when returning multiple values from a\nfunction. If $(D obj) is a tuple, the individual members are\naccessible with the syntax $(D obj[0]) for the first field, $(D obj[1])\nfor the second, and so on.\n\nThe choice of zero-based indexing instead of one-base indexing was\nmotivated by the ability to use value tuples with various compile-time\nloop constructs (e.g. type tuple iteration), all of which use\nzero-based indexing.\n\nExample:\n\n----\nTuple!(int, int) point;\n\/\/ assign coordinates\npoint[0] = 5;\npoint[1] = 6;\n\/\/ read coordinates\nauto x = point[0];\nauto y = point[1];\n----\n\nTuple members can be named. It is legal to mix named and unnamed\nmembers. The method above is still applicable to all fields.\n\nExample:\n\n----\nalias Tuple!(int, \"index\", string, \"value\") Entry;\nEntry e;\ne.index = 4;\ne.value = \"Hello\";\nassert(e[1] == \"Hello\");\nassert(e[0] == 4);\n----\n\nTuples with named fields are distinct types from tuples with unnamed\nfields, i.e. each naming imparts a separate type for the tuple. Two\ntuple differing in naming only are still distinct, even though they\nmight have the same structure.\n\nExample:\n\n----\nTuple!(int, \"x\", int, \"y\") point1;\nTuple!(int, int) point2;\nassert(!is(typeof(point1) == typeof(point2))); \/\/ passes\n----\n",
"line" : 272,
"members" : [
{
"name" : "Tuple",
"kind" : "struct",
"protection" : "public",
"line" : 272,
"members" : [
{
"name" : "parseSpecs(Specs...)",
"kind" : "template",
"protection" : "public",
"line" : 277,
"members" : [
]
}
,
{
"name" : "FieldSpec(T,string s = \"\")",
"kind" : "template",
"protection" : "public",
"line" : 303,
"members" : [
{
"name" : "Type",
"kind" : "alias",
"type" : "T",
"line" : 305}
,
{
"name" : "name",
"kind" : "alias",
"type" : "s",
"line" : 306}
]
}
,
{
"name" : "fieldSpecs",
"kind" : "alias",
"type" : "parseSpecs!(Specs)",
"line" : 309}
,
{
"name" : "extractType(alias spec)",
"kind" : "template",
"protection" : "public",
"line" : 312,
"members" : [
{
"name" : "extractType",
"kind" : "alias",
"type" : "spec.Type",
"line" : 312}
]
}
,
{
"name" : "extractName(alias spec)",
"kind" : "template",
"protection" : "public",
"line" : 313,
"members" : [
{
"name" : "extractName",
"kind" : "alias",
"type" : "spec.name",
"line" : 313}
]
}
,
{
"name" : "injectNamedFields",
"kind" : "function",
"type" : "string()",
"line" : 321}
,
{
"name" : "sliceSpecs(size_t from,size_t to)",
"kind" : "template",
"protection" : "public",
"line" : 339,
"members" : [
{
"name" : "sliceSpecs",
"kind" : "alias",
"type" : "staticMap!(expandSpec,fieldSpecs[from .. to])",
"line" : 342}
]
}
,
{
"name" : "expandSpec(alias spec)",
"kind" : "template",
"protection" : "public",
"line" : 345,
"members" : [
]
}
,
{
"name" : "Types",
"kind" : "alias",
"type" : "staticMap!(extractType,fieldSpecs)",
"comment" : "\n   The type of the tuple's components.\n",
"line" : 361}
,
{
"name" : "field",
"kind" : "variable",
"type" : "Types",
"line" : 363}
,
{
"name" : "expand",
"kind" : "alias",
"type" : "field",
"line" : 365}
,
{
"name" : "at(size_t index)",
"kind" : "template",
"protection" : "public",
"line" : 372,
"members" : [
{
"name" : "at",
"kind" : "function",
"type" : "()",
"line" : 372}
]
}
,
{
"name" : "__ctor(U...) if (U.length == Types.length)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Constructor taking one value for each field. Each argument must be\n   implicitly assignable to the respective element of the target.\n \n",
"line" : 380,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(U values)",
"line" : 380}
]
}
,
{
"name" : "__ctor(U) if (isTuple!(U))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Constructor taking a compatible tuple. Each element of the source\n   must be implicitly assignable to the respective element of the\n   target.\n \n",
"line" : 393,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(U another)",
"line" : 393}
]
}
,
{
"name" : "opEquals(R) if (isTuple!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Comparison for equality.\n \n",
"line" : 407,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "bool(R rhs)",
"comment" : "\n   Comparison for equality.\n \n",
"line" : 407}
]
}
,
{
"name" : "opCmp(R) if (isTuple!(R))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Comparison for ordering.\n \n",
"line" : 423,
"members" : [
{
"name" : "opCmp",
"kind" : "function",
"type" : "int(R rhs)",
"comment" : "\n   Comparison for ordering.\n \n",
"line" : 423}
]
}
,
{
"name" : "opAssign(R) if (isTuple!(R) && allSatisfy!(isIdentityAssignable,Types))",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Assignment from another tuple. Each element of the source must be\n   implicitly assignable to the respective element of the target.\n \n",
"line" : 443,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(R rhs)",
"comment" : "\n   Assignment from another tuple. Each element of the source must be\n   implicitly assignable to the respective element of the target.\n \n",
"line" : 443}
]
}
,
{
"name" : "_workaround4424()",
"kind" : "template",
"protection" : "public",
"line" : 457,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(typeof(this))",
"line" : 459}
]
}
,
{
"name" : "slice(uint from,uint to)",
"kind" : "template",
"protection" : "public",
"comment" : "\n   Takes a slice of the tuple.\n\n   Example:\n\n----\nTuple!(int, string, float, double) a;\na[1] = \"abc\";\na[2] = 4.5;\nauto s = a.slice!(1, 3);\nstatic assert(is(typeof(s) == Tuple!(string, float)));\nassert(s[0] == \"abc\" && s[1] == 4.5);\n----\n \n",
"line" : 478,
"members" : [
{
"name" : "slice",
"kind" : "function",
"type" : "Tuple!(sliceSpecs!(from,to))()",
"line" : 478}
]
}
,
{
"name" : "length",
"kind" : "variable",
"comment" : "\n   The length of the tuple.\n \n",
"line" : 486}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"comment" : "\n   Converts to string.\n \n",
"line" : 491}
]
}
]
}
,
{
"name" : "Identity(alias T)",
"kind" : "template",
"protection" : "public",
"line" : 519,
"members" : [
{
"name" : "Identity",
"kind" : "alias",
"type" : "T",
"line" : 521}
]
}
,
{
"name" : "isIdentityAssignable(T)",
"kind" : "template",
"protection" : "public",
"line" : 524,
"members" : [
{
"name" : "isIdentityAssignable",
"kind" : "variable",
"line" : 526}
]
}
,
{
"name" : "tuple(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns a $(D Tuple) object instantiated and initialized according to\nthe arguments.\n\nExample:\n----\nauto value = tuple(5, 6.7, \"hello\");\nassert(value[0] == 5);\nassert(value[1] == 6.7);\nassert(value[2] == \"hello\");\n----\n",
"line" : 683,
"members" : [
{
"name" : "tuple",
"kind" : "function",
"type" : "Tuple!(T)(T args)",
"comment" : "\nReturns a $(D Tuple) object instantiated and initialized according to\nthe arguments.\n\nExample:\n----\nauto value = tuple(5, 6.7, \"hello\");\nassert(value[0] == 5);\nassert(value[1] == 6.7);\nassert(value[2] == \"hello\");\n----\n",
"line" : 683}
]
}
,
{
"name" : "isTuple(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D T) is an instance of the\n$(D Tuple) struct template.\n \n",
"line" : 692,
"members" : [
]
}
,
{
"name" : "Rebindable(T) if (is(T == class) || is(T == interface) || isArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D Rebindable!(T)) is a simple, efficient wrapper that behaves just\nlike an object of type $(D T), except that you can reassign it to\nrefer to another object. For completeness, $(D Rebindable!(T)) aliases\nitself away to $(D T) if $(D T) is a non-const object type. However,\n$(D Rebindable!(T)) does not compile if $(D T) is a non-class type.\n\nRegular $(D const) object references cannot be reassigned:\n\n----\nclass Widget { int x; int y() const { return a; } }\nconst a = new Widget;\na.y();          \/\/ fine\na.x = 5;        \/\/ error! can't modify const a\na = new Widget; \/\/ error! can't modify const a\n----\n\nHowever, $(D Rebindable!(Widget)) does allow reassignment, while\notherwise behaving exactly like a $(D const Widget):\n\n----\nauto a = Rebindable!(const Widget)(new Widget);\na.y();          \/\/ fine\na.x = 5;        \/\/ error! can't modify const a\na = new Widget; \/\/ fine\n----\n\nYou may want to use $(D Rebindable) when you want to have mutable\nstorage referring to $(D const) objects, for example an array of\nreferences that must be sorted in place. $(D Rebindable) does not\nbreak the soundness of D's type system and does not incur any of the\nrisks usually associated with $(D cast).\n\n \n",
"line" : 757,
"members" : [
]
}
,
{
"name" : "rebindable(T) if (is(T == class) || is(T == interface) || isArray!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\nConvenience function for creating a $(D Rebindable) using automatic type\ninference.\n",
"line" : 816,
"members" : [
{
"name" : "rebindable",
"kind" : "function",
"type" : "Rebindable!(T)(T obj)",
"comment" : "\nConvenience function for creating a $(D Rebindable) using automatic type\ninference.\n",
"line" : 816}
]
}
,
{
"name" : "rebindable(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nThis function simply returns the $(D Rebindable) object passed in.  It's useful\nin generic programming cases when a given object may be either a regular\n$(D class) or a $(D Rebindable).\n",
"line" : 829,
"members" : [
{
"name" : "rebindable",
"kind" : "function",
"type" : "Rebindable!(T)(Rebindable!(T) obj)",
"comment" : "\nThis function simply returns the $(D Rebindable) object passed in.  It's useful\nin generic programming cases when a given object may be either a regular\n$(D class) or a $(D Rebindable).\n",
"line" : 829}
]
}
,
{
"name" : "alignForSize(E...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n  Order the provided members to minimize size while preserving alignment.\n  Returns a declaration to be mixed in.\n\nExample:\n---\nstruct Banner {\n  mixin(alignForSize!(byte[6], double)([\"name\", \"height\"]));\n}\n---\n\n  Alignment is not always optimal for 80-bit reals, nor for structs declared\n  as align(1).\n",
"line" : 916,
"members" : [
{
"name" : "alignForSize",
"kind" : "function",
"type" : "string(string[] names...)",
"comment" : "\n  Order the provided members to minimize size while preserving alignment.\n  Returns a declaration to be mixed in.\n\nExample:\n---\nstruct Banner {\n  mixin(alignForSize!(byte[6], double)([\"name\", \"height\"]));\n}\n---\n\n  Alignment is not always optimal for 80-bit reals, nor for structs declared\n  as align(1).\n",
"line" : 916}
]
}
,
{
"name" : "Ref(T)",
"kind" : "struct",
"protection" : "public",
"line" : 971,
"members" : [
{
"name" : "Ref",
"kind" : "struct",
"protection" : "public",
"line" : 971,
"members" : [
{
"name" : "_p",
"kind" : "variable",
"type" : "T*",
"line" : 972}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(ref T value)",
"line" : 973}
,
{
"name" : "opDot",
"kind" : "function",
"type" : "T()",
"line" : 974}
,
{
"name" : "opImplicitCastTo",
"kind" : "function",
"type" : "T()",
"line" : 975}
,
{
"name" : "value",
"kind" : "function",
"type" : "T()",
"line" : 976}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(T value)",
"line" : 978}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(T* value)",
"line" : 982}
]
}
]
}
,
{
"name" : "Nullable(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nDefines a value paired with a distinctive \"null\" state that denotes\nthe absence of a value. If default constructed, a $(D\nNullable!T) object starts in the null state. Assigning it renders it\nnon-null. Calling $(D nullify) can nullify it again.\n\nExample:\n----\nNullable!int a;\nassert(a.isNull);\na = 5;\nassert(!a.isNull);\nassert(a == 5);\n----\n\nPractically $(D Nullable!T) stores a $(D T) and a $(D bool).\n \n",
"line" : 1017,
"members" : [
{
"name" : "Nullable",
"kind" : "struct",
"protection" : "public",
"line" : 1017,
"members" : [
{
"name" : "_value",
"kind" : "variable",
"type" : "T",
"line" : 1018}
,
{
"name" : "_isNull",
"kind" : "variable",
"type" : "bool",
"line" : 1019}
,
{
"name" : "__ctor()",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor initializing $(D this) with $(D value).\n \n",
"line" : 1024,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(T value)",
"line" : 1024}
]
}
,
{
"name" : "isNull",
"kind" : "function",
"type" : "const pure nothrow @safe bool()",
"comment" : "\nReturns $(D true) if and only if $(D this) is in the null state.\n \n",
"line" : 1033}
,
{
"name" : "nullify()",
"kind" : "template",
"protection" : "public",
"comment" : "\nForces $(D this) to the null state.\n \n",
"line" : 1041,
"members" : [
{
"name" : "nullify",
"kind" : "function",
"type" : "void()",
"comment" : "\nForces $(D this) to the null state.\n \n",
"line" : 1041}
]
}
,
{
"name" : "_workaround4424()",
"kind" : "template",
"protection" : "public",
"line" : 1048,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(ref const Nullable)",
"line" : 1050}
]
}
,
{
"name" : "opAssign()",
"kind" : "template",
"protection" : "public",
"comment" : "\nAssigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null.\n \n",
"line" : 1058,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(T value)",
"comment" : "\nAssigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null.\n \n",
"line" : 1058}
]
}
,
{
"name" : "get",
"kind" : "function",
"type" : "inout pure @safe inout(T)()",
"comment" : "\nGets the value. Throws an exception if $(D this) is in the null\nstate. This function is also called for the implicit conversion to $(D\nT).\n \n",
"line" : 1069}
]
}
]
}
,
{
"name" : "Nullable(T,T nullValue)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nJust like $(D Nullable!T), except that the null state is defined as a\nparticular value. For example, $(D Nullable!(uint, uint.max)) is an\n$(D uint) that sets aside the value $(D uint.max) to denote a null\nstate. $(D Nullable!(T, nullValue)) is more storage-efficient than $(D\nNullable!T) because it does not need to store an extra $(D bool).\n \n",
"line" : 1176,
"members" : [
{
"name" : "Nullable",
"kind" : "struct",
"protection" : "public",
"line" : 1176,
"members" : [
{
"name" : "_value",
"kind" : "variable",
"type" : "T",
"line" : 1177}
,
{
"name" : "__ctor()",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor initializing $(D this) with $(D value).\n \n",
"line" : 1182,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(T value)",
"line" : 1182}
]
}
,
{
"name" : "isNull()",
"kind" : "template",
"protection" : "public",
"comment" : "\nReturns $(D true) if and only if $(D this) is in the null state.\n \n",
"line" : 1190,
"members" : [
{
"name" : "isNull",
"kind" : "function",
"type" : "const bool()",
"line" : 1190}
]
}
,
{
"name" : "nullify()",
"kind" : "template",
"protection" : "public",
"comment" : "\nForces $(D this) to the null state.\n \n",
"line" : 1198,
"members" : [
{
"name" : "nullify",
"kind" : "function",
"type" : "void()",
"comment" : "\nForces $(D this) to the null state.\n \n",
"line" : 1198}
]
}
,
{
"name" : "opAssign()",
"kind" : "template",
"protection" : "public",
"comment" : "\nAssigns $(D value) to the internally-held state. No null checks are\nmade.\n \n",
"line" : 1207,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(T value)",
"comment" : "\nAssigns $(D value) to the internally-held state. No null checks are\nmade.\n \n",
"line" : 1207}
]
}
,
{
"name" : "get()",
"kind" : "template",
"protection" : "public",
"comment" : "\nGets the value. Throws an exception if $(D this) is in the null\nstate. This function is also called for the implicit conversion to $(D\nT).\n \n",
"line" : 1217,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "inout inout(T)()",
"line" : 1217}
]
}
]
}
]
}
,
{
"name" : "NullableRef(T)",
"kind" : "struct",
"protection" : "public",
"comment" : "\nJust like $(D Nullable!T), except that the object refers to a value\nsitting elsewhere in memory. This makes assignments overwrite the\ninitially assigned value. Internally $(D NullableRef!T) only stores a\npointer to $(D T) (i.e., $(D Nullable!T.sizeof == (T*).sizeof)).\n \n",
"line" : 1300,
"members" : [
{
"name" : "NullableRef",
"kind" : "struct",
"protection" : "public",
"line" : 1300,
"members" : [
{
"name" : "_value",
"kind" : "variable",
"type" : "T*",
"line" : 1301}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "pure nothrow @safe (T* value)",
"comment" : "\nConstructor binding $(D this) with $(D value).\n \n",
"line" : 1306}
,
{
"name" : "bind",
"kind" : "function",
"type" : "pure nothrow @safe void(T* value)",
"comment" : "\nBinds the internal state to $(D value).\n \n",
"line" : 1314}
,
{
"name" : "isNull",
"kind" : "function",
"type" : "const pure nothrow @safe bool()",
"comment" : "\nReturns $(D true) if and only if $(D this) is in the null state.\n \n",
"line" : 1322}
,
{
"name" : "nullify",
"kind" : "function",
"type" : "pure nothrow @safe void()",
"comment" : "\nForces $(D this) to the null state.\n \n",
"line" : 1330}
,
{
"name" : "opAssign()",
"kind" : "template",
"protection" : "public",
"comment" : "\nAssigns $(D value) to the internally-held state.\n \n",
"line" : 1338,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(T value)",
"comment" : "\nAssigns $(D value) to the internally-held state.\n \n",
"line" : 1338}
]
}
,
{
"name" : "get()",
"kind" : "template",
"protection" : "public",
"comment" : "\nGets the value. Throws an exception if $(D this) is in the null\nstate. This function is also called for the implicit conversion to $(D\nT).\n \n",
"line" : 1349,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "inout inout(T)()",
"line" : 1349}
]
}
]
}
]
}
,
{
"name" : "BlackHole(Base)",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D BlackHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions in $(D Base) as do-nothing functions.  Each\nauto-implemented function just returns the default value of the return type\nwithout doing anything.\n\nThe name came from\n$(WEB search.cpan.org\/~sburke\/Class-_BlackHole-0.04\/lib\/Class\/_BlackHole.pm, Class::_BlackHole)\nPerl module by Sean M. Burke.\n\nExample:\n--------------------\nabstract class C\n{\n    int m_value;\n    this(int v) { m_value = v; }\n    int value() @property { return m_value; }\n\n    abstract real realValue() @property;\n    abstract void doSomething();\n}\n\nvoid main()\n{\n    auto c = new BlackHole!C(42);\n    writeln(c.value);     \/\/ prints \"42\"\n\n    \/\/ Abstract functions are implemented as do-nothing:\n    writeln(c.realValue); \/\/ prints \"NaN\"\n    c.doSomething();      \/\/ does nothing\n}\n--------------------\n\nSee_Also:\n  AutoImplement, generateEmptyFunction\n \n",
"line" : 1477,
"members" : [
{
"name" : "BlackHole",
"kind" : "alias",
"type" : "AutoImplement!(Base,generateEmptyFunction,isAbstractFunction)",
"line" : 1480}
]
}
,
{
"name" : "WhiteHole(Base)",
"kind" : "template",
"protection" : "public",
"comment" : "\n$(D WhiteHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions as throw-always functions.  Each auto-implemented\nfunction fails with throwing an $(D Error) and does never return.  Useful for\ntrapping use of not-yet-implemented functions.\n\nThe name came from\n$(WEB search.cpan.org\/~mschwern\/Class-_WhiteHole-0.04\/lib\/Class\/_WhiteHole.pm, Class::_WhiteHole)\nPerl module by Michael G Schwern.\n\nExample:\n--------------------\nclass C\n{\n    abstract void notYetImplemented();\n}\n\nvoid main()\n{\n    auto c = new WhiteHole!C;\n    c.notYetImplemented(); \/\/ throws an Error\n}\n--------------------\n\nBUGS:\n  Nothrow functions cause program to abort in release mode because the trap is\n  implemented with $(D assert(0)) for nothrow functions.\n\nSee_Also:\n  AutoImplement, generateAssertTrap\n \n",
"line" : 1543,
"members" : [
{
"name" : "WhiteHole",
"kind" : "alias",
"type" : "AutoImplement!(Base,generateAssertTrap,isAbstractFunction)",
"line" : 1546}
]
}
,
{
"name" : "NotImplementedError",
"kind" : "class",
"protection" : "public",
"line" : 1550,
"base" : "Error",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "NotImplementedError(string method)",
"line" : 1552}
]
}
,
{
"name" : "AutoImplement(Base,alias how,alias what = isAbstractFunction)",
"kind" : "class",
"protection" : "public",
"comment" : "\n$(D AutoImplement) automatically implements (by default) all abstract member\nfunctions in the class or interface $(D Base) in specified way.\n\nParams:\n  how  = template which specifies _how functions will be implemented\/overridden.\n\n         Two arguments are passed to $(D how): the type $(D Base) and an alias\n         to an implemented function.  Then $(D how) must return an implemented\n         function body as a string.\n\n         The generated function body can use these keywords:\n         $(UL\n            $(LI $(D a0), $(D a1), &hellip;: arguments passed to the function;)\n            $(LI $(D args): a tuple of the arguments;)\n            $(LI $(D self): an alias to the function itself;)\n            $(LI $(D parent): an alias to the overridden function (if any).)\n         )\n\n        You may want to use templated property functions (instead of Implicit\n        Template Properties) to generate complex functions:\n--------------------\n\/\/ Prints log messages for each call to overridden functions.\nstring generateLogger(C, alias fun)() @property\n{\n    enum qname = C.stringof ~ \".\" ~ __traits(identifier, fun);\n    string stmt;\n\n    stmt ~= q{ struct Importer { import std.stdio; } };\n    stmt ~= `Importer.writeln$(LPAREN)\"Log: ` ~ qname ~ `(\", args, \")\"$(RPAREN);`;\n    static if (!__traits(isAbstractFunction, fun))\n    {\n        static if (is(typeof(return) == void))\n            stmt ~= q{ parent(args); };\n        else\n            stmt ~= q{\n                auto r = parent(args);\n                Importer.writeln(\"--> \", r);\n                return r;\n            };\n    }\n    return stmt;\n}\n--------------------\n\n  what = template which determines _what functions should be\n         implemented\/overridden.\n\n         An argument is passed to $(D what): an alias to a non-final member\n         function in $(D Base).  Then $(D what) must return a boolean value.\n         Return $(D true) to indicate that the passed function should be\n         implemented\/overridden.\n\n--------------------\n\/\/ Sees if fun returns something.\ntemplate hasValue(alias fun)\n{\n    enum bool hasValue = !is(ReturnType!(fun) == void);\n}\n--------------------\n\n\nNote:\n\nGenerated code is inserted in the scope of $(D std.typecons) module.  Thus,\nany useful functions outside $(D std.typecons) cannot be used in the generated\ncode.  To workaround this problem, you may $(D import) necessary things in a\nlocal struct, as done in the $(D generateLogger()) template in the above\nexample.\n\n\nBUGS:\n\n$(UL\n $(LI Variadic arguments to constructors are not forwarded to super.)\n $(LI Deep interface inheritance causes compile error with messages like\n      \"Error: function std.typecons._AutoImplement!(Foo)._AutoImplement.bar\n      does not override any function\".  [$(BUGZILLA 2525), $(BUGZILLA 3525)] )\n $(LI The $(D parent) keyword is actually a delegate to the super class'\n      corresponding member function.  [$(BUGZILLA 2540)] )\n $(LI Using alias template parameter in $(D how) and\/or $(D what) may cause\n     strange compile error.  Use template tuple parameter instead to workaround\n     this problem.  [$(BUGZILLA 4217)] )\n)\n \n",
"line" : 1678,
"members" : [
{
"name" : "AutoImplement",
"kind" : "class",
"protection" : "public",
"line" : 1678,
"members" : [
{
"name" : "autoImplement_helper_",
"kind" : "alias",
"type" : "AutoImplement_Helper!(\"autoImplement_helper_\",\"Base\",Base,how,what)",
"line" : 1682}
]
}
]
}
,
{
"name" : "AutoImplement_Helper(string myName,string baseName,Base,alias generateMethodBody,alias cherrypickMethod)",
"kind" : "template",
"protection" : "public",
"line" : 1691,
"members" : [
{
"name" : "staticFilter(alias pred,lst...)",
"kind" : "template",
"protection" : "public",
"line" : 1700,
"members" : [
]
}
,
{
"name" : "enumerateOverloads(C,alias pred)",
"kind" : "template",
"protection" : "public",
"line" : 1716,
"members" : [
{
"name" : "Impl(names...)",
"kind" : "template",
"protection" : "public",
"line" : 1718,
"members" : [
]
}
,
{
"name" : "enumerateOverloads",
"kind" : "alias",
"type" : "Impl!(__traits(allMembers,C))",
"line" : 1734}
]
}
,
{
"name" : "canonicalPicker(fun...)",
"kind" : "template",
"protection" : "public",
"line" : 1742,
"members" : [
{
"name" : "canonicalPicker",
"kind" : "variable",
"type" : "bool",
"line" : 1744}
]
}
,
{
"name" : "targetOverloadSets",
"kind" : "alias",
"type" : "enumerateOverloads!(Base,canonicalPicker)",
"line" : 1752}
,
{
"name" : "INTERNAL_FUNCINFO_ID(string name,size_t i)",
"kind" : "template",
"protection" : "public",
"line" : 1781,
"members" : [
{
"name" : "INTERNAL_FUNCINFO_ID",
"kind" : "variable",
"type" : "string",
"line" : 1783}
]
}
,
{
"name" : "populate(overloads...)",
"kind" : "template",
"protection" : "public",
"line" : 1791,
"members" : [
]
}
,
{
"name" : "populate(string name,methods...)",
"kind" : "template",
"protection" : "public",
"line" : 1799,
"members" : [
]
}
,
{
"name" : "CommonGeneratingPolicy()",
"kind" : "template",
"protection" : "public",
"line" : 1821,
"members" : [
{
"name" : "BASE_CLASS_ID",
"kind" : "variable",
"type" : "string",
"line" : 1824}
,
{
"name" : "FUNCINFO_ID(string name,size_t i)",
"kind" : "template",
"protection" : "public",
"line" : 1827,
"members" : [
{
"name" : "FUNCINFO_ID",
"kind" : "variable",
"type" : "string",
"line" : 1829}
]
}
]
}
,
{
"name" : "ConstructorGeneratingPolicy()",
"kind" : "template",
"protection" : "public",
"line" : 1835,
"members" : [
{
"name" : "generateFunctionBody(ctor...)",
"kind" : "template",
"protection" : "public",
"line" : 1840,
"members" : [
{
"name" : "generateFunctionBody",
"kind" : "function",
"type" : "@property string()",
"line" : 1840}
]
}
]
}
,
{
"name" : "MethodGeneratingPolicy()",
"kind" : "template",
"protection" : "public",
"line" : 1856,
"members" : [
{
"name" : "generateFunctionBody(func...)",
"kind" : "template",
"protection" : "public",
"line" : 1861,
"members" : [
{
"name" : "generateFunctionBody",
"kind" : "function",
"type" : "@property string()",
"line" : 1861}
]
}
]
}
,
{
"name" : "ConstructorGenerator",
"kind" : "alias",
"type" : "MemberFunctionGenerator!(ConstructorGeneratingPolicy!())",
"line" : 1873}
,
{
"name" : "MethodGenerator",
"kind" : "alias",
"type" : "MemberFunctionGenerator!(MethodGeneratingPolicy!())",
"line" : 1875}
,
{
"name" : "code",
"kind" : "variable",
"type" : "string",
"line" : 1877}
]
}
,
{
"name" : "OverloadSet(string nam,T...)",
"kind" : "template",
"protection" : "public",
"line" : 1974,
"members" : [
{
"name" : "name",
"kind" : "variable",
"type" : "string",
"line" : 1976}
,
{
"name" : "contents",
"kind" : "alias",
"type" : "T",
"line" : 1977}
]
}
,
{
"name" : "FuncInfo(alias func,T = typeof(&func))",
"kind" : "template",
"protection" : "public",
"line" : 1983,
"members" : [
{
"name" : "RT",
"kind" : "alias",
"type" : "ReturnType!(T)",
"line" : 1985}
,
{
"name" : "PT",
"kind" : "alias",
"type" : "ParameterTypeTuple!(T)",
"line" : 1986}
]
}
,
{
"name" : "FuncInfo(Func)",
"kind" : "template",
"protection" : "public",
"line" : 1988,
"members" : [
{
"name" : "RT",
"kind" : "alias",
"type" : "ReturnType!(Func)",
"line" : 1990}
,
{
"name" : "PT",
"kind" : "alias",
"type" : "ParameterTypeTuple!(Func)",
"line" : 1991}
]
}
,
{
"name" : "MemberFunctionGenerator(alias Policy)",
"kind" : "template",
"protection" : "public",
"line" : 2020,
"members" : [
{
"name" : "CONSTRUCTOR_NAME",
"kind" : "variable",
"line" : 2027}
,
{
"name" : "WITH_BASE_CLASS",
"kind" : "variable",
"line" : 2030}
,
{
"name" : "WITHOUT_SYMBOL",
"kind" : "variable",
"line" : 2033}
,
{
"name" : "CountUp(size_t n)",
"kind" : "template",
"protection" : "public",
"line" : 2050,
"members" : [
]
}
,
{
"name" : "generateCode(overloads...)",
"kind" : "template",
"protection" : "public",
"line" : 2067,
"members" : [
{
"name" : "generateCode",
"kind" : "function",
"type" : "@property string()",
"line" : 2067}
]
}
,
{
"name" : "generateCodeForOverloadSet(alias oset)",
"kind" : "template",
"protection" : "public",
"line" : 2093,
"members" : [
{
"name" : "generateCodeForOverloadSet",
"kind" : "function",
"type" : "@property string()",
"line" : 2093}
]
}
,
{
"name" : "generateFunction(string myFuncInfo,string name,func...)",
"kind" : "template",
"protection" : "public",
"line" : 2112,
"members" : [
{
"name" : "generateFunction",
"kind" : "function",
"type" : "@property string()",
"line" : 2112}
]
}
,
{
"name" : "generateParameters(string myFuncInfo,func...)",
"kind" : "template",
"protection" : "public",
"line" : 2212,
"members" : [
{
"name" : "generateParameters",
"kind" : "function",
"type" : "@property string()",
"line" : 2212}
]
}
,
{
"name" : "enumerateParameters(size_t n)",
"kind" : "template",
"protection" : "public",
"line" : 2258,
"members" : [
{
"name" : "enumerateParameters",
"kind" : "function",
"type" : "@property string()",
"line" : 2258}
]
}
]
}
,
{
"name" : "generateEmptyFunction(C,func...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nPredefined how-policies for $(D AutoImplement).  These templates are used by\n$(D BlackHole) and $(D WhiteHole), respectively.\n \n",
"line" : 2277,
"members" : [
]
}
,
{
"name" : "generateAssertTrap(C,func...)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2294,
"members" : [
]
}
,
{
"name" : "RefCountedAutoInitialize",
"kind" : "enum",
"protection" : "public",
"comment" : "\nOptions regarding auto-initialization of a $(D RefCounted) object (see\nthe definition of $(D RefCounted) below).\n \n",
"line" : 2316,
"base" : "int",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : " Do not auto-initialize the object\n",
"line" : 2318}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " Auto-initialize the object\n",
"line" : 2320}
]
}
,
{
"name" : "RefCounted(T,RefCountedAutoInitialize autoInit = RefCountedAutoInitialize.yes) if (!is(T == class))",
"kind" : "struct",
"protection" : "public",
"comment" : "\nDefines a reference-counted object containing a $(D T) value as\npayload. $(D RefCounted) keeps track of all references of an object,\nand when the reference count goes down to zero, frees the underlying\nstore. $(D RefCounted) uses $(D malloc) and $(D free) for operation.\n\n$(D RefCounted) is unsafe and should be used with care. No references\nto the payload should be escaped outside the $(D RefCounted) object.\n\nThe $(D autoInit) option makes the object ensure the store is\nautomatically initialized. Leaving $(D autoInit ==\nRefCountedAutoInitialize.yes) (the default option) is convenient but\nhas the cost of a test whenever the payload is accessed. If $(D\nautoInit == RefCountedAutoInitialize.no), user code must call either\n$(D refCountedIsInitialized) or $(D refCountedEnsureInitialized)\nbefore attempting to access the payload. Not doing so results in null\npointer dereference.\n\nExample:\n----\n\/\/ A pair of an $(D int) and a $(D size_t) - the latter being the\n\/\/ reference count - will be dynamically allocated\nauto rc1 = RefCounted!int(5);\nassert(rc1 == 5);\n\/\/ No more allocation, add just one extra reference count\nauto rc2 = rc1;\n\/\/ Reference semantics\nrc2 = 42;\nassert(rc1 == 42);\n\/\/ the pair will be freed when rc1 and rc2 go out of scope\n----\n \n",
"line" : 2358,
"members" : [
{
"name" : "RefCounted",
"kind" : "struct",
"protection" : "public",
"line" : 2358,
"members" : [
{
"name" : "_RefCounted",
"kind" : "struct",
"protection" : "public",
"line" : 2360,
"members" : [
{
"name" : "_store",
"kind" : "variable",
"type" : "Tuple!(T,\"_payload\",size_t,\"_count\")*",
"line" : 2361}
,
{
"name" : "initialize(A...)",
"kind" : "template",
"protection" : "public",
"line" : 2381,
"members" : [
{
"name" : "initialize",
"kind" : "function",
"type" : "void(A args)",
"line" : 2381}
]
}
,
{
"name" : "isInitialized",
"kind" : "function",
"type" : "const bool()",
"comment" : "\n           Returns $(D true) if and only if the underlying store has been\n           allocated and initialized.\n        \n",
"line" : 2401}
,
{
"name" : "ensureInitialized",
"kind" : "function",
"type" : "void()",
"comment" : "\n           Makes sure the payload was properly initialized. Such a\n           call is typically inserted before using the payload.\n        \n",
"line" : 2410}
]
}
,
{
"name" : "RefCounted",
"kind" : "variable",
"type" : "_RefCounted",
"line" : 2416}
,
{
"name" : "__ctor(A...) if (A.length > 0)",
"kind" : "template",
"protection" : "public",
"comment" : "\nConstructor that initializes the payload.\n\nPostcondition: $(D refCountedIsInitialized)\n \n",
"line" : 2423,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(A args)",
"line" : 2423}
]
}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(typeof(this) rhs)",
"comment" : "\nAssignment operators\n \n",
"line" : 2479}
,
{
"name" : "opAssign",
"kind" : "function",
"type" : "void(T rhs)",
"comment" : " Ditto\n",
"line" : 2485}
,
{
"name" : "refCountedPayload",
"kind" : "function",
"type" : "T()",
"comment" : "\nReturns a reference to the payload. If (autoInit ==\nRefCountedAutoInitialize.yes), calls $(D\nrefCountedEnsureInitialized). Otherwise, just issues $(D\nassert(refCountedIsInitialized)). Used with $(D alias\nrefCountedPayload this;), so callers can just use the $(D RefCounted)\nobject as a $(D T).\n \n",
"line" : 2506}
,
{
"name" : "refCountedPayload",
"kind" : "function",
"type" : "const const(T)()",
"line" : 2520}
]
}
]
}
,
{
"name" : "Proxy(alias a)",
"kind" : "template",
"protection" : "public",
"comment" : "\nMake proxy for $(D a).\n\nExample:\n----\nstruct MyInt\n{\n    private int value;\n    mixin Proxy!value;\n\n    this(int n){ value = n; }\n}\n\nMyInt n = 10;\n\n\/\/ Enable operations that original type has.\n++n;\nassert(n == 11);\nassert(n * 2 == 22);\n\nvoid func(int n) { }\n\n\/\/ Disable implicit conversions to original type.\n\/\/int x = n;\n\/\/func(n);\n----\n \n",
"line" : 2623,
"members" : [
{
"name" : "opEquals(this X)",
"kind" : "template",
"protection" : "public",
"line" : 2625,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "ref (auto ref typeof(this) b)",
"line" : 2625}
]
}
,
{
"name" : "opEquals(this X,B) if (!is(B == typeof(this)))",
"kind" : "template",
"protection" : "public",
"line" : 2630,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "ref (auto ref B b)",
"line" : 2630}
]
}
,
{
"name" : "opCmp(this X,B) if (!is(typeof(a.opCmp(b))) || !is(typeof(b.opCmp(a))))",
"kind" : "template",
"protection" : "public",
"line" : 2635,
"members" : [
{
"name" : "opCmp",
"kind" : "function",
"type" : "ref (auto ref B b)",
"line" : 2635}
]
}
,
{
"name" : "opCall(this X,Args...)",
"kind" : "template",
"protection" : "public",
"line" : 2646,
"members" : [
{
"name" : "opCall",
"kind" : "function",
"type" : "ref (auto ref Args args)",
"line" : 2646}
]
}
,
{
"name" : "opCast(T,this X)",
"kind" : "template",
"protection" : "public",
"line" : 2648,
"members" : [
{
"name" : "opCast",
"kind" : "function",
"type" : "ref ()",
"line" : 2648}
]
}
,
{
"name" : "opIndex(this X,D...)",
"kind" : "template",
"protection" : "public",
"line" : 2650,
"members" : [
{
"name" : "opIndex",
"kind" : "function",
"type" : "ref (auto ref D i)",
"line" : 2650}
]
}
,
{
"name" : "opSlice(this X)",
"kind" : "template",
"protection" : "public",
"line" : 2651,
"members" : [
{
"name" : "opSlice",
"kind" : "function",
"type" : "ref ()",
"line" : 2651}
]
}
,
{
"name" : "opSlice(this X,B,E)",
"kind" : "template",
"protection" : "public",
"line" : 2652,
"members" : [
{
"name" : "opSlice",
"kind" : "function",
"type" : "ref (auto ref B b, auto ref E e)",
"line" : 2652}
]
}
,
{
"name" : "opUnary(string op,this X)",
"kind" : "template",
"protection" : "public",
"line" : 2654,
"members" : [
{
"name" : "opUnary",
"kind" : "function",
"type" : "ref ()",
"line" : 2654}
]
}
,
{
"name" : "opIndexUnary(string op,this X,D...)",
"kind" : "template",
"protection" : "public",
"line" : 2655,
"members" : [
{
"name" : "opIndexUnary",
"kind" : "function",
"type" : "ref (auto ref D i)",
"line" : 2655}
]
}
,
{
"name" : "opSliceUnary(string op,this X)",
"kind" : "template",
"protection" : "public",
"line" : 2656,
"members" : [
{
"name" : "opSliceUnary",
"kind" : "function",
"type" : "ref ()",
"line" : 2656}
]
}
,
{
"name" : "opSliceUnary(string op,this X,B,E)",
"kind" : "template",
"protection" : "public",
"line" : 2657,
"members" : [
{
"name" : "opSliceUnary",
"kind" : "function",
"type" : "ref (auto ref B b, auto ref E e)",
"line" : 2657}
]
}
,
{
"name" : "opBinary(string op,this X,B)",
"kind" : "template",
"protection" : "public",
"line" : 2659,
"members" : [
{
"name" : "opBinary",
"kind" : "function",
"type" : "ref (auto ref B b)",
"line" : 2659}
]
}
,
{
"name" : "opBinaryRight(string op,this X,B)",
"kind" : "template",
"protection" : "public",
"line" : 2660,
"members" : [
{
"name" : "opBinaryRight",
"kind" : "function",
"type" : "ref (auto ref B b)",
"line" : 2660}
]
}
,
{
"name" : "opAssign(this X,V) if (!is(V == typeof(this)))",
"kind" : "template",
"protection" : "public",
"line" : 2679,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "ref (auto ref V v)",
"line" : 2679}
]
}
,
{
"name" : "opIndexAssign(this X,V,D...)",
"kind" : "template",
"protection" : "public",
"line" : 2680,
"members" : [
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "ref (auto ref V v, auto ref D i)",
"line" : 2680}
]
}
,
{
"name" : "opSliceAssign(this X,V)",
"kind" : "template",
"protection" : "public",
"line" : 2681,
"members" : [
{
"name" : "opSliceAssign",
"kind" : "function",
"type" : "ref (auto ref V v)",
"line" : 2681}
]
}
,
{
"name" : "opSliceAssign(this X,V,B,E)",
"kind" : "template",
"protection" : "public",
"line" : 2682,
"members" : [
{
"name" : "opSliceAssign",
"kind" : "function",
"type" : "ref (auto ref V v, auto ref B b, auto ref E e)",
"line" : 2682}
]
}
,
{
"name" : "opOpAssign(string op,this X,V)",
"kind" : "template",
"protection" : "public",
"line" : 2684,
"members" : [
{
"name" : "opOpAssign",
"kind" : "function",
"type" : "ref (auto ref V v)",
"line" : 2684}
]
}
,
{
"name" : "opIndexOpAssign(string op,this X,V,D...)",
"kind" : "template",
"protection" : "public",
"line" : 2685,
"members" : [
{
"name" : "opIndexOpAssign",
"kind" : "function",
"type" : "ref (auto ref V v, auto ref D i)",
"line" : 2685}
]
}
,
{
"name" : "opSliceOpAssign(string op,this X,V)",
"kind" : "template",
"protection" : "public",
"line" : 2686,
"members" : [
{
"name" : "opSliceOpAssign",
"kind" : "function",
"type" : "ref (auto ref V v)",
"line" : 2686}
]
}
,
{
"name" : "opSliceOpAssign(string op,this X,V,B,E)",
"kind" : "template",
"protection" : "public",
"line" : 2687,
"members" : [
{
"name" : "opSliceOpAssign",
"kind" : "function",
"type" : "ref (auto ref V v, auto ref B b, auto ref E e)",
"line" : 2687}
]
}
,
{
"name" : "opDispatch(string name)",
"kind" : "template",
"protection" : "public",
"line" : 2689,
"members" : [
]
}
]
}
,
{
"name" : "Typedef(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\nLibrary typedef.\n \n",
"line" : 2880,
"members" : [
{
"name" : "Typedef",
"kind" : "alias",
"type" : ".Typedef!(T,T.init)",
"line" : 2882}
]
}
,
{
"name" : "Typedef(T,T init,string cookie = null)",
"kind" : "struct",
"protection" : "public",
"comment" : " ditto\n",
"line" : 2887,
"members" : [
{
"name" : "Typedef",
"kind" : "struct",
"protection" : "public",
"line" : 2887,
"members" : [
{
"name" : "Typedef_payload",
"kind" : "variable",
"type" : "T",
"line" : 2888}
,
{
"name" : "this",
"kind" : "constructor",
"type" : "(T init)",
"line" : 2890}
]
}
]
}
,
{
"name" : "scoped(T,Args...) if (is(T == class))",
"kind" : "template",
"protection" : "public",
"comment" : "\nAllocates a $(D class) object right inside the current scope,\ntherefore avoiding the overhead of $(D new). This facility is unsafe;\nit is the responsibility of the user to not escape a reference to the\nobject outside the scope.\n\nNote: it's illegal to move a class reference even if you are sure there\nis no pointers to it.\n\nExample:\n----\nunittest\n{\n    class A { int x; }\n    auto a1 = scoped!A();\n    auto a2 = scoped!A();\n    a1.x = 42;\n    a2.x = 53;\n    assert(a1.x == 42);\n\n    auto a3 = a2; \/\/ illegal, fails to compile\n    assert([a2][0].x == 42); \/\/ illegal, unexpected behaviour\n}\n----\n \n",
"line" : 2941,
"members" : [
{
"name" : "scoped",
"kind" : "function",
"type" : "@system (Args args)",
"comment" : "\nAllocates a $(D class) object right inside the current scope,\ntherefore avoiding the overhead of $(D new). This facility is unsafe;\nit is the responsibility of the user to not escape a reference to the\nobject outside the scope.\n\nNote: it's illegal to move a class reference even if you are sure there\nis no pointers to it.\n\nExample:\n----\nunittest\n{\n    class A { int x; }\n    auto a1 = scoped!A();\n    auto a2 = scoped!A();\n    a1.x = 42;\n    a2.x = 53;\n    assert(a1.x == 42);\n\n    auto a3 = a2; \/\/ illegal, fails to compile\n    assert([a2][0].x == 42); \/\/ illegal, unexpected behaviour\n}\n----\n \n",
"line" : 2941}
]
}
,
{
"name" : "maxAlignment(U...) if (isTypeTuple!(U))",
"kind" : "template",
"protection" : "public",
"line" : 2983,
"members" : [
]
}
,
{
"name" : "Flag(string name)",
"kind" : "template",
"protection" : "public",
"comment" : "\nDefines a simple, self-documenting yes\/no flag. This makes it easy for\nAPIs to define functions accepting flags without resorting to $(D\nbool), which is opaque in calls, and without needing to define an\nenumerated type separately. Using $(D Flag!\"Name\") instead of $(D\nbool) makes the flag's meaning visible in calls. Each yes\/no flag has\nits own type, which makes confusions and mix-ups impossible.\n\nExample:\n----\n\/\/ Before\nstring getLine(bool keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\n\/\/ Code calling getLine (usually far away from its definition) can't\n\/\/ be understood without looking at the documentation, even by users\n\/\/ familiar with the API. Assuming the reverse meaning\n\/\/ (i.e. \"ignoreTerminator\") and inserting the wrong code compiles and\n\/\/ runs with erroneous results.\nauto line = getLine(false);\n\n\/\/ After\nstring getLine(Flag!\"KeepTerminator\" keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\n\/\/ Code calling getLine can be easily read and understood even by\n\/\/ people not fluent with the API.\nauto line = getLine(Flag!\"KeepTerminator\".yes);\n----\n\nPassing categorical data by means of unstructured $(D bool)\nparameters is classified under \"simple-data coupling\" by Steve\nMcConnell in the $(LUCKY Code Complete) book, along with three other\nkinds of coupling. The author argues citing several studies that\ncoupling has a negative effect on code quality. $(D Flag) offers a\nsimple structuring method for passing yes\/no flags to APIs.\n\nAs a perk, the flag's name may be any string and as such can include\ncharacters not normally allowed in identifiers, such as\nspaces and dashes.\n \n",
"line" : 3250,
"members" : [
{
"name" : "Flag",
"kind" : "enum",
"protection" : "public",
"comment" : "\n",
"line" : 3252,
"base" : "bool",
"members" : [
{
"name" : "no",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n         When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".no) for the negative option. When using a value\n         of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".no) or just $(D false) or $(D 0).  \n",
"line" : 3259}
,
{
"name" : "yes",
"kind" : "enum member",
"protection" : "public",
"comment" : " When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".yes) for the affirmative option. When using a\n         value of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".yes).\n        \n",
"line" : 3266}
]
}
]
}
,
{
"name" : "Yes",
"kind" : "struct",
"protection" : "public",
"comment" : "\nConvenience names that allow using e.g. $(D yes!\"encryption\") instead of\n$(D Flag!\"encryption\".yes) and $(D no!\"encryption\") instead of $(D\nFlag!\"encryption\".no).\n",
"line" : 3276,
"members" : [
{
"name" : "opDispatch(string name)",
"kind" : "template",
"protection" : "public",
"line" : 3277,
"members" : [
{
"name" : "opDispatch",
"kind" : "variable",
"line" : 3279}
]
}
]
}
,
{
"name" : "No",
"kind" : "struct",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 3286,
"members" : [
{
"name" : "opDispatch(string name)",
"kind" : "template",
"protection" : "public",
"line" : 3287,
"members" : [
{
"name" : "opDispatch",
"kind" : "variable",
"line" : 3289}
]
}
]
}
]
}
,
{
"name" : "std.typetuple",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/typetuple.d",
"comment" : "\n Templates with which to manipulate type tuples (also known as type lists).\n\n Some operations on type tuples are built in to the language,\n such as TL[$(I n)] which gets the $(I n)th type from the\n type tuple. TL[$(I lwr) .. $(I upr)] returns a new type\n list that is a slice of the old one.\n\n References:\n  Based on ideas in Table 3.1 from\n  $(LINK2 http:\/\/amazon.com\/exec\/obidos\/ASIN\/0201704315\/ref=ase_classicempire\/102-2957199-2585768,\n      Modern C++ Design),\n   Andrei Alexandrescu (Addison-Wesley Professional, 2001)\n Macros:\n  WIKI = Phobos\/StdTypeTuple\n\n Copyright: Copyright Digital Mars 2005 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_typetuple.d)\n \n",
"members" : [
{
"name" : "TypeTuple(TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Creates a typetuple out of a sequence of zero or more types.\n Example:\n ---\n import std.typetuple;\n alias TypeTuple!(int, double) TL;\n\n int foo(TL td)  \/\/ same as int foo(int, double);\n {\n    return td[0] + cast(int)td[1];\n }\n ---\n\n Example:\n ---\n TypeTuple!(TL, char)\n \/\/ is equivalent to:\n TypeTuple!(int, double, char)\n ---\n \n",
"line" : 53,
"members" : [
{
"name" : "TypeTuple",
"kind" : "alias",
"type" : "TList",
"line" : 55}
]
}
,
{
"name" : "staticIndexOf(T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the index of the first occurrence of type T in the\n sequence of zero or more types TList.\n If not found, -1 is returned.\n Example:\n ---\n import std.typetuple;\n import std.stdio;\n\n void foo()\n {\n    writefln(\"The index of long is %s\",\n          staticIndexOf!(long, TypeTuple!(int, long, double)));\n    \/\/ prints: The index of long is 1\n }\n ---\n \n",
"line" : 75,
"members" : [
{
"name" : "staticIndexOf",
"kind" : "variable",
"line" : 77}
]
}
,
{
"name" : "staticIndexOf(alias T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 81,
"members" : [
{
"name" : "staticIndexOf",
"kind" : "variable",
"line" : 83}
]
}
,
{
"name" : "genericIndexOf(args...) if (args.length >= 1)",
"kind" : "template",
"protection" : "public",
"line" : 87,
"members" : [
{
"name" : "e",
"kind" : "alias",
"type" : "Alias!(args[0])",
"line" : 90}
,
{
"name" : "tuple",
"kind" : "alias",
"type" : "args[1 .. __dollar]",
"line" : 91}
]
}
,
{
"name" : "IndexOf",
"kind" : "alias",
"protection" : "public",
"comment" : " Kept for backwards compatibility\n",
"line" : 137}
,
{
"name" : "Erase(T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a typetuple created from TList with the first occurrence,\n if any, of T removed.\n Example:\n ---\n Erase!(long, int, long, double, char)\n \/\/ is the same as:\n TypeTuple!(int, double, char)\n ---\n \n",
"line" : 158,
"members" : [
{
"name" : "Erase",
"kind" : "alias",
"type" : "GenericErase!(T,TList).result",
"line" : 160}
]
}
,
{
"name" : "Erase(alias T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 164,
"members" : [
{
"name" : "Erase",
"kind" : "alias",
"type" : "GenericErase!(T,TList).result",
"line" : 166}
]
}
,
{
"name" : "GenericErase(args...) if (args.length >= 1)",
"kind" : "template",
"protection" : "public",
"line" : 170,
"members" : [
{
"name" : "e",
"kind" : "alias",
"type" : "Alias!(args[0])",
"line" : 173}
,
{
"name" : "tuple",
"kind" : "alias",
"type" : "args[1 .. __dollar]",
"line" : 174}
]
}
,
{
"name" : "EraseAll(T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a typetuple created from TList with the all occurrences,\n if any, of T removed.\n Example:\n ---\n alias TypeTuple!(int, long, long, int) TL;\n\n EraseAll!(long, TL)\n \/\/ is the same as:\n TypeTuple!(int, int)\n ---\n \n",
"line" : 216,
"members" : [
{
"name" : "EraseAll",
"kind" : "alias",
"type" : "GenericEraseAll!(T,TList).result",
"line" : 218}
]
}
,
{
"name" : "EraseAll(alias T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 222,
"members" : [
{
"name" : "EraseAll",
"kind" : "alias",
"type" : "GenericEraseAll!(T,TList).result",
"line" : 224}
]
}
,
{
"name" : "GenericEraseAll(args...) if (args.length >= 1)",
"kind" : "template",
"protection" : "public",
"line" : 228,
"members" : [
{
"name" : "e",
"kind" : "alias",
"type" : "Alias!(args[0])",
"line" : 231}
,
{
"name" : "tuple",
"kind" : "alias",
"type" : "args[1 .. __dollar]",
"line" : 232}
]
}
,
{
"name" : "NoDuplicates(TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a typetuple created from TList with the all duplicate\n types removed.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n NoDuplicates!(TL)\n \/\/ is the same as:\n TypeTuple!(int, long, float)\n ---\n \n",
"line" : 275,
"members" : [
]
}
,
{
"name" : "Replace(T,U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a typetuple created from TList with the first occurrence\n of type T, if found, replaced with type U.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n Replace!(long, char, TL)\n \/\/ is the same as:\n TypeTuple!(int, char, long, int, float)\n ---\n \n",
"line" : 304,
"members" : [
{
"name" : "Replace",
"kind" : "alias",
"type" : "GenericReplace!(T,U,TList).result",
"line" : 306}
]
}
,
{
"name" : "Replace(alias T,U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 310,
"members" : [
{
"name" : "Replace",
"kind" : "alias",
"type" : "GenericReplace!(T,U,TList).result",
"line" : 312}
]
}
,
{
"name" : "Replace(T,alias U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 316,
"members" : [
{
"name" : "Replace",
"kind" : "alias",
"type" : "GenericReplace!(T,U,TList).result",
"line" : 318}
]
}
,
{
"name" : "Replace(alias T,alias U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 322,
"members" : [
{
"name" : "Replace",
"kind" : "alias",
"type" : "GenericReplace!(T,U,TList).result",
"line" : 324}
]
}
,
{
"name" : "GenericReplace(args...) if (args.length >= 2)",
"kind" : "template",
"protection" : "public",
"line" : 328,
"members" : [
{
"name" : "from",
"kind" : "alias",
"type" : "Alias!(args[0])",
"line" : 331}
,
{
"name" : "to",
"kind" : "alias",
"type" : "Alias!(args[1])",
"line" : 332}
,
{
"name" : "tuple",
"kind" : "alias",
"type" : "args[2 .. __dollar]",
"line" : 333}
]
}
,
{
"name" : "ReplaceAll(T,U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a typetuple created from TList with all occurrences\n of type T, if found, replaced with type U.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n ReplaceAll!(long, char, TL)\n \/\/ is the same as:\n TypeTuple!(int, char, char, int, float)\n ---\n \n",
"line" : 383,
"members" : [
{
"name" : "ReplaceAll",
"kind" : "alias",
"type" : "GenericReplaceAll!(T,U,TList).result",
"line" : 385}
]
}
,
{
"name" : "ReplaceAll(alias T,U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 389,
"members" : [
{
"name" : "ReplaceAll",
"kind" : "alias",
"type" : "GenericReplaceAll!(T,U,TList).result",
"line" : 391}
]
}
,
{
"name" : "ReplaceAll(T,alias U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 395,
"members" : [
{
"name" : "ReplaceAll",
"kind" : "alias",
"type" : "GenericReplaceAll!(T,U,TList).result",
"line" : 397}
]
}
,
{
"name" : "ReplaceAll(alias T,alias U,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto\n",
"line" : 401,
"members" : [
{
"name" : "ReplaceAll",
"kind" : "alias",
"type" : "GenericReplaceAll!(T,U,TList).result",
"line" : 403}
]
}
,
{
"name" : "GenericReplaceAll(args...) if (args.length >= 2)",
"kind" : "template",
"protection" : "public",
"line" : 407,
"members" : [
{
"name" : "from",
"kind" : "alias",
"type" : "Alias!(args[0])",
"line" : 410}
,
{
"name" : "to",
"kind" : "alias",
"type" : "Alias!(args[1])",
"line" : 411}
,
{
"name" : "tuple",
"kind" : "alias",
"type" : "args[2 .. __dollar]",
"line" : 412}
]
}
,
{
"name" : "Reverse(TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns a typetuple created from TList with the order reversed.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n Reverse!(TL)\n \/\/ is the same as:\n TypeTuple!(float, int, long, long, int)\n ---\n \n",
"line" : 461,
"members" : [
]
}
,
{
"name" : "MostDerived(T,TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the type from TList that is the most derived from type T.\n If none are found, T is returned.\n Example:\n ---\n class A { }\n class B : A { }\n class C : B { }\n alias TypeTuple!(A, C, B) TL;\n\n MostDerived!(Object, TL) x;  \/\/ x is declared as type C\n ---\n \n",
"line" : 482,
"members" : [
]
}
,
{
"name" : "DerivedToFront(TList...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the typetuple TList with the types sorted so that the most\n derived types come first.\n Example:\n ---\n class A { }\n class B : A { }\n class C : B { }\n alias TypeTuple!(A, C, B) TL;\n\n DerivedToFront!(TL)\n \/\/ is the same as:\n TypeTuple!(C, B, A)\n ---\n \n",
"line" : 507,
"members" : [
]
}
,
{
"name" : "staticMap(alias F,T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nEvaluates to $(D TypeTuple!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))).\n\nExample:\n----\nalias staticMap!(Unqual, int, const int, immutable int) T;\nstatic assert(is(T == TypeTuple!(int, int, int)));\n----\n \n",
"line" : 528,
"members" : [
]
}
,
{
"name" : "allSatisfy(alias F,T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nEvaluates to $(D F!(T[0]) && F!(T[1]) && ... && F!(T[$ - 1])).\n\nExample:\n----\nstatic assert(!allSatisfy!(isIntegral, int, double));\nstatic assert(allSatisfy!(isIntegral, int, long));\n----\n \n",
"line" : 564,
"members" : [
]
}
,
{
"name" : "anySatisfy(alias F,T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\nEvaluates to $(D F!(T[0]) || F!(T[1]) || ... || F!(T[$ - 1])).\n\nExample:\n----\nstatic assert(!anySatisfy!(isIntegral, string, double));\nstatic assert(anySatisfy!(isIntegral, int, double));\n----\n \n",
"line" : 595,
"members" : [
]
}
,
{
"name" : "Alias(alias a)",
"kind" : "template",
"protection" : "public",
"line" : 628,
"members" : [
]
}
,
{
"name" : "Alias(a...)",
"kind" : "template",
"protection" : "public",
"line" : 638,
"members" : [
{
"name" : "Alias",
"kind" : "alias",
"type" : "a",
"line" : 640}
]
}
,
{
"name" : "isSame(ab...) if (ab.length == 2)",
"kind" : "template",
"protection" : "public",
"line" : 664,
"members" : [
]
}
,
{
"name" : "expectType(T)",
"kind" : "template",
"protection" : "public",
"line" : 687,
"members" : [
]
}
,
{
"name" : "expectBool(bool b)",
"kind" : "template",
"protection" : "public",
"line" : 688,
"members" : [
]
}
,
{
"name" : "Pack(T...)",
"kind" : "template",
"protection" : "public",
"line" : 739,
"members" : [
{
"name" : "tuple",
"kind" : "alias",
"type" : "T",
"line" : 741}
,
{
"name" : "equals(U...)",
"kind" : "template",
"protection" : "public",
"line" : 744,
"members" : [
]
}
]
}
]
}
,
{
"name" : "std.uni",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/uni.d",
"comment" : "\n    Functions which operate on Unicode characters.\n\n    For functions which operate on ASCII characters and ignore Unicode\n    characters, see $(LINK2 std_ascii.html, std.ascii).\n\n    References:\n        $(WEB www.digitalmars.com\/d\/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org\/wiki\/Unicode, Wikipedia),\n        $(WEB www.unicode.org, The Unicode Consortium)\n\n    Trademarks:\n        Unicode(tm) is a trademark of Unicode, Inc.\n\n    Macros:\n        WIKI=Phobos\/StdUni\n\n    Copyright: Copyright 2000 -\n    License:   $(WEB www.boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright), Jonathan M Davis, and Kenji Hara\n    Source:    $(PHOBOSSRC std\/_uni.d)\n  \n",
"members" : [
{
"name" : "lineSep",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : " UTF line separator\n",
"line" : 29}
,
{
"name" : "paraSep",
"kind" : "variable",
"protection" : "public",
"type" : "dchar",
"comment" : " UTF paragraph separator\n",
"line" : 30}
,
{
"name" : "isWhite",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Whether or not $(D c) is a Unicode whitespace character.\n    (general Unicode category: Part of C0(tab, vertical tab, form feed,\n    carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))\n  \n",
"line" : 37}
,
{
"name" : "isUniLower",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n   $(RED Deprecated. It will be removed in September 2012. Please use\n   $(D isLower) instead.)\n\n    Return whether $(D c) is a Unicode lowercase character.\n  \n",
"line" : 53}
,
{
"name" : "isLower",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Return whether $(D c) is a Unicode lowercase character.\n  \n",
"line" : 61}
,
{
"name" : "isUniUpper",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n   $(RED Deprecated. It will be removed in September 2012. Please use\n   $(D isUpper) instead.)\n\n    Return whether $(D c) is a Unicode uppercase character.\n  \n",
"line" : 76}
,
{
"name" : "isUpper",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Return whether $(D c) is a Unicode uppercase character.\n  \n",
"line" : 84}
,
{
"name" : "toUniLower",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe dchar(dchar c)",
"comment" : "\n   $(RED Deprecated. It will be removed in September 2012. Please use\n   $(D toLower) instead.)\n\n    If $(D c) is a Unicode uppercase character, then its lowercase equivalent\n    is returned. Otherwise $(D c) is returned.\n  \n",
"line" : 100}
,
{
"name" : "toLower",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe dchar(dchar c)",
"comment" : "\n    If $(D c) is a Unicode uppercase character, then its lowercase equivalent\n    is returned. Otherwise $(D c) is returned.\n  \n",
"line" : 109}
,
{
"name" : "toUniUpper",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe dchar(dchar c)",
"comment" : "\n   $(RED Deprecated. It will be removed in September 2012. Please use\n   $(D toUpper) instead.)\n\n    If $(D c) is a Unicode lowercase character, then its uppercase equivalent\n    is returned. Otherwise $(D c) is returned.\n  \n",
"line" : 172}
,
{
"name" : "toUpper",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe dchar(dchar c)",
"comment" : "\n    If $(D c) is a Unicode lowercase character, then its uppercase equivalent\n    is returned. Otherwise $(D c) is returned.\n  \n",
"line" : 181}
,
{
"name" : "isUniAlpha",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n   $(RED Deprecated. It will be removed in September 2012. Please use\n   $(D isAlpha) instead.)\n\n    Returns whether $(D c) is a Unicode alpha character\n    (general Unicode category: Lu, Ll, Lt, Lm, and Lo).\n\n    Standards: Unicode 5.0.0.\n  \n",
"line" : 246}
,
{
"name" : "isAlpha",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode alpha character\n    (general Unicode category: Lu, Ll, Lt, Lm, and Lo).\n\n    Standards: Unicode 5.0.0.\n  \n",
"line" : 257}
,
{
"name" : "isMark",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode mark\n    (general Unicode category: Mn, Me, Mc).\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 658}
,
{
"name" : "isNumber",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode numerical character\n    (general Unicode category: Nd, Nl, No).\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1010}
,
{
"name" : "isPunctuation",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode punctuation character\n    (general Unicode category: Pd, Ps, Pe, Pc, Po, Pi, Pf).\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1136}
,
{
"name" : "isSymbol",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode symbol character\n    (general Unicode category: Sm, Sc, Sk, So)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1505}
,
{
"name" : "isSpace",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode whitespace character\n    (general Unicode category: Zs)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1817}
,
{
"name" : "isGraphical",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode graphical character\n    (general Unicode category: L, M, N, P, S, Zs).\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1838}
,
{
"name" : "isControl",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode control character\n    (general Unicode category: Cc)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1856}
,
{
"name" : "isFormat",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode formatting character\n    (general Unicode category: Cf)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1873}
,
{
"name" : "isPrivateUse",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode Private Use character\n    (general Unicode category: Co)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1909}
,
{
"name" : "isSurrogate",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode surrogate character\n    (general Unicode category: Cs)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1928}
,
{
"name" : "isSurrogateHi",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode high surrogate (lead surrogate).\n\n    Standards: Unicode 2.0.\n  \n",
"line" : 1938}
,
{
"name" : "isSurrogateLo",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode low surrogate (trail surrogate).\n\n    Standards: Unicode 2.0.\n  \n",
"line" : 1948}
,
{
"name" : "isNonCharacter",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a Unicode non-character\n    (general Unicode category: Cn)\n\n    Standards: Unicode 6.0.0.\n  \n",
"line" : 1964}
,
{
"name" : "binarySearch(alias table)",
"kind" : "template",
"protection" : "public",
"line" : 2484,
"members" : [
{
"name" : "binarySearch",
"kind" : "function",
"type" : "pure nothrow @safe bool(dchar c)",
"line" : 2484}
]
}
,
{
"name" : "binarySearch2",
"kind" : "function",
"protection" : "private",
"type" : "pure nothrow @safe bool(dchar c, immutable(dchar[2LU][]) table)",
"line" : 2501}
]
}
,
{
"name" : "std.uri",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/uri.d",
"comment" : "\n Encode and decode Uniform Resource Identifiers (URIs).\n URIs are used in internet transfer protocols.\n Valid URI characters consist of letters, digits,\n and the characters $(B ;\/?:@&amp;=+$,-_.!~*'())\n Reserved URI characters are $(B ;\/?:@&amp;=+$,)\n Escape sequences consist of $(B %) followed by two hex digits.\n\n See_Also:\n  $(LINK2 http:\/\/www.ietf.org\/rfc\/rfc3986.txt, RFC 3986)<br>\n  $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Uniform_resource_identifier, Wikipedia)\n Macros:\n  WIKI = Phobos\/StdUri\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_uri.d)\n \n",
"members" : [
{
"name" : "URIerror",
"kind" : "class",
"protection" : "public",
"line" : 39,
"base" : "Error",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "URIerror()",
"line" : 41}
]
}
,
{
"name" : "URI_Alpha",
"kind" : "enum member",
"protection" : "public",
"line" : 49}
,
{
"name" : "URI_Reserved",
"kind" : "enum member",
"protection" : "public",
"line" : 50}
,
{
"name" : "URI_Mark",
"kind" : "enum member",
"protection" : "public",
"line" : 51}
,
{
"name" : "URI_Digit",
"kind" : "enum member",
"protection" : "public",
"line" : 52}
,
{
"name" : "URI_Hash",
"kind" : "enum member",
"protection" : "public",
"line" : 53}
,
{
"name" : "hex2ascii",
"kind" : "variable",
"protection" : "public",
"type" : "immutable(char[16LU])",
"line" : 56}
,
{
"name" : "uri_flags",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[128LU]",
"line" : 58}
,
{
"name" : "URI_Encode",
"kind" : "function",
"protection" : "private",
"type" : "string(immutable(dchar)[] string, uint unescapedSet)",
"line" : 83}
,
{
"name" : "ascii2hex",
"kind" : "function",
"protection" : "public",
"type" : "uint(dchar c)",
"line" : 215}
,
{
"name" : "URI_Decode",
"kind" : "function",
"protection" : "private",
"type" : "immutable(dchar)[](string string, uint reservedSet)",
"line" : 222}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "string(string encodedURI)",
"comment" : "\n Decodes the URI string encodedURI into a UTF-8 string and returns it.\n Escape sequences that resolve to reserved URI characters are not replaced.\n Escape sequences that resolve to the '#' character are not replaced.\n \n",
"line" : 337}
,
{
"name" : "decodeComponent",
"kind" : "function",
"protection" : "public",
"type" : "string(string encodedURIComponent)",
"comment" : "\n Decodes the URI string encodedURI into a UTF-8 string and returns it. All\n escape sequences are decoded.\n \n",
"line" : 348}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "string(string uri)",
"comment" : "\n Encodes the UTF-8 string uri into a URI and returns that URI. Any character\n not a valid URI character is escaped. The '#' character is not escaped.\n \n",
"line" : 359}
,
{
"name" : "encodeComponent",
"kind" : "function",
"protection" : "public",
"type" : "string(string uriComponent)",
"comment" : "\n Encodes the UTF-8 string uriComponent into a URI and returns that URI.\n Any character not a letter, digit, or one of -_.!~*'() is escaped.\n \n",
"line" : 370}
,
{
"name" : "uriLength",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string s)",
"comment" : "\n Does string s[] start with a URL?\n Returns:\n  -1    it does not\n  len  it does, and s[0..len] is the slice of s[] that is that URL\n \n",
"line" : 383}
,
{
"name" : "emailLength",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string s)",
"comment" : "\n Does string s[] start with an email address?\n Returns:\n  -1    it does not\n  len   it does, and s[0..i] is the slice of s[] that is that email address\n References:\n  RFC2822\n \n",
"line" : 442}
]
}
,
{
"name" : "std.utf",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/utf.d",
"comment" : "\n    Encode and decode UTF-8, UTF-16 and UTF-32 strings.\n\n    UTF character support is restricted to\n    $(D '\\u0000' &lt;= character &lt;= '\\U0010FFFF').\n\n    See_Also:\n        $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Unicode, Wikipedia)<br>\n        $(LINK http:\/\/www.cl.cam.ac.uk\/~mgk25\/unicode.html#utf-8)<br>\n        $(LINK http:\/\/anubis.dkuug.dk\/JTC1\/SC2\/WG2\/docs\/n1335)\n    Macros:\n        WIKI = Phobos\/StdUtf\n\n    Copyright: Copyright Digital Mars 2000 - 2010.\n    License:   $(WEB www.boost.org\/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std\/_utf.d)\n   \n",
"members" : [
{
"name" : "UTFException",
"kind" : "class",
"protection" : "public",
"comment" : "\n    Exception thrown on errors in std.utf functions.\n  \n",
"line" : 43,
"base" : "Exception",
"members" : [
{
"name" : "sequence",
"kind" : "variable",
"protection" : "public",
"type" : "uint[4LU]",
"line" : 45}
,
{
"name" : "len",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"line" : 46}
,
{
"name" : "setSequence",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe UTFException(uint[] data...)",
"line" : 49}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UTFException(string msg, string file = __FILE__, ulong line = cast(ulong)__LINE__, Throwable next = null)",
"line" : 62}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UTFException(string msg, ulong index, string file = __FILE__, ulong line = cast(ulong)__LINE__, Throwable next = null)",
"line" : 68}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 75}
]
}
,
{
"name" : "UtfException",
"kind" : "alias",
"protection" : "public",
"type" : "std.utf.UTFException",
"comment" : "\n    $(RED Deprecated. It will be removed in January 2013.\n          Please use $(LREF UTFException) instead.)\n  \n",
"line" : 101}
,
{
"name" : "isValidDchar",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe bool(dchar c)",
"comment" : "\n    Returns whether $(D c) is a valid UTF-32 character.\n\n    $(D '\\uFFFE') and $(D '\\uFFFF') are considered valid by $(D isValidDchar),\n    as they are permitted for internal use by an application, but they are\n    not allowed for interchange by the Unicode standard.\n  \n",
"line" : 112}
,
{
"name" : "stride(S) if (is(S : const(char[])))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(D stride) returns the length of the UTF-8 sequence starting at $(D index)\n    in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        $(D UTFException) if $(D str[index]) is not the start of a valid UTF-8\n        sequence.\n  \n",
"line" : 153,
"members" : [
{
"name" : "stride",
"kind" : "function",
"type" : "pure @trusted uint(auto ref const S str, size_t index)",
"comment" : "\n    $(D stride) returns the length of the UTF-8 sequence starting at $(D index)\n    in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        $(D UTFException) if $(D str[index]) is not the start of a valid UTF-8\n        sequence.\n  \n",
"line" : 153}
]
}
,
{
"name" : "strideImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure @trusted uint(char c, ulong index)",
"line" : 163}
,
{
"name" : "strideBack",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe uint(const(char[]) str, ulong index)",
"comment" : "\n    $(D strideBack) returns the length of the UTF-8 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        $(D UTFException) if $(D str[index]) is not one past the end of a valid\n        UTF-8 sequence.\n  \n",
"line" : 211}
,
{
"name" : "stride(S) if (is(S : const(wchar[])))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(D stride) returns the length of the UTF-16 sequence starting at $(D index)\n    in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n  \n",
"line" : 258,
"members" : [
{
"name" : "stride",
"kind" : "function",
"type" : "pure nothrow @safe uint(in S str, size_t index)",
"comment" : "\n    $(D stride) returns the length of the UTF-16 sequence starting at $(D index)\n    in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n  \n",
"line" : 258}
]
}
,
{
"name" : "strideBack",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe uint(const(wchar[]) str, ulong index)",
"comment" : "\n    $(D strideBack) returns the length of the UTF-16 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        $(D UTFException) if $(D str[index]) is not one past the end of a valid\n        UTF-16 sequence.\n  \n",
"line" : 302}
,
{
"name" : "stride(S) if (is(S : const(dchar[])))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(D stride) returns the length of the UTF-32 sequence starting at $(D index)\n    in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n  \n",
"line" : 345,
"members" : [
{
"name" : "stride",
"kind" : "function",
"type" : "pure nothrow @safe uint(in S str, size_t index)",
"comment" : "\n    $(D stride) returns the length of the UTF-32 sequence starting at $(D index)\n    in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n  \n",
"line" : 345}
]
}
,
{
"name" : "strideBack",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe uint(const(dchar[]) str, ulong index)",
"comment" : "\n    $(D strideBack) returns the length of the UTF-32 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n  \n",
"line" : 385}
,
{
"name" : "toUCSindex(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Given $(D index) into $(D str) and assuming that $(D index) is at the start\n    of a UTF sequence, $(D toUCSindex) determines the number of UCS characters\n    up to $(D index). So, $(D index) is the index of a code unit at the\n    beginning of a code point, and the return value is how many code points into\n    the string that that code point is.\n\nExamples:\n--------------------\nassert(toUCSindex(`hello world`, 7) == 7);\nassert(toUCSindex(`hello world`w, 7) == 7);\nassert(toUCSindex(`hello world`d, 7) == 7);\n\nassert(toUCSindex(`Ma Chrie`, 7) == 6);\nassert(toUCSindex(`Ma Chrie`w, 7) == 7);\nassert(toUCSindex(`Ma Chrie`d, 7) == 7);\n\nassert(toUCSindex(` \/ `, 9) == 3);\nassert(toUCSindex(` \/ `w, 9) == 9);\nassert(toUCSindex(` \/ `d, 9) == 9);\n--------------------\n  \n",
"line" : 439,
"members" : [
{
"name" : "toUCSindex",
"kind" : "function",
"type" : "pure @safe size_t(const(C)[] str, size_t index)",
"comment" : "\n    Given $(D index) into $(D str) and assuming that $(D index) is at the start\n    of a UTF sequence, $(D toUCSindex) determines the number of UCS characters\n    up to $(D index). So, $(D index) is the index of a code unit at the\n    beginning of a code point, and the return value is how many code points into\n    the string that that code point is.\n\nExamples:\n--------------------\nassert(toUCSindex(`hello world`, 7) == 7);\nassert(toUCSindex(`hello world`w, 7) == 7);\nassert(toUCSindex(`hello world`d, 7) == 7);\n\nassert(toUCSindex(`Ma Chrie`, 7) == 6);\nassert(toUCSindex(`Ma Chrie`w, 7) == 7);\nassert(toUCSindex(`Ma Chrie`d, 7) == 7);\n\nassert(toUCSindex(` \/ `, 9) == 3);\nassert(toUCSindex(` \/ `w, 9) == 9);\nassert(toUCSindex(` \/ `d, 9) == 9);\n--------------------\n  \n",
"line" : 439}
]
}
,
{
"name" : "toUTFindex",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe ulong(const(char[]) str, ulong n)",
"comment" : "\n    Given a UCS index $(D n) into $(D str), returns the UTF index.\n    So, $(D n) is how many code points into the string the code point is, and\n    the array index of the code unit is returned.\n\nExamples:\n--------------------\nassert(toUTFindex(`hello world`, 7) == 7);\nassert(toUTFindex(`hello world`w, 7) == 7);\nassert(toUTFindex(`hello world`d, 7) == 7);\n\nassert(toUTFindex(`Ma Chrie`, 6) == 7);\nassert(toUTFindex(`Ma Chrie`w, 7) == 7);\nassert(toUTFindex(`Ma Chrie`d, 7) == 7);\n\nassert(toUTFindex(` \/ `, 3) == 9);\nassert(toUTFindex(` \/ `w, 9) == 9);\nassert(toUTFindex(` \/ `d, 9) == 9);\n--------------------\n  \n",
"line" : 500}
,
{
"name" : "toUTFindex",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe ulong(const(wchar[]) str, ulong n)",
"comment" : " ditto\n",
"line" : 509}
,
{
"name" : "toUTFindex",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe ulong(const(dchar[]) str, ulong n)",
"comment" : " ditto\n",
"line" : 524}
,
{
"name" : "decode(S) if (is(S : const(char[])))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Decodes and returns the character starting at $(D str[index]). $(D index)\n    is advanced to one past the decoded character. If the character is not\n    well-formed, then a $(D UTFException) is thrown and $(D index) remains\n    unchanged.\n\n    Throws:\n        $(D UTFException) if $(D str[index]) is not the start of a valid UTF\n        sequence.\n  \n",
"line" : 542,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "pure @trusted dchar(in S str, ref size_t index)",
"comment" : "\n    Decodes and returns the character starting at $(D str[index]). $(D index)\n    is advanced to one past the decoded character. If the character is not\n    well-formed, then a $(D UTFException) is thrown and $(D index) remains\n    unchanged.\n\n    Throws:\n        $(D UTFException) if $(D str[index]) is not the start of a valid UTF\n        sequence.\n  \n",
"line" : 542}
]
}
,
{
"name" : "decodeImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure @trusted dchar(const(char)* pstr, ulong length, ref ulong index)",
"line" : 566}
,
{
"name" : "decode(S) if (is(S : const(wchar[])))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 714,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "pure @trusted dchar(in S str, ref size_t index)",
"comment" : " ditto\n",
"line" : 714}
]
}
,
{
"name" : "decodeImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure @trusted dchar(const(wchar)* pstr, ulong length, ref ulong index)",
"comment" : " ditto\n",
"line" : 733}
,
{
"name" : "decode(S) if (is(S : const(dchar[])))",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 785,
"members" : [
{
"name" : "decode",
"kind" : "function",
"type" : "pure @safe dchar(in S str, ref size_t index)",
"comment" : " ditto\n",
"line" : 785}
]
}
,
{
"name" : "decodeImpl",
"kind" : "function",
"protection" : "private",
"type" : "pure @safe dchar(const(dchar[]) str, ref ulong index)",
"comment" : " ditto\n",
"line" : 800}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe ulong(ref char[4LU] buf, dchar c)",
"comment" : "\n    Encodes $(D c) into the static array, $(D buf), and returns the actual\n    length of the encoded character (a number between $(D 1) and $(D 4) for\n    $(D char[4]) buffers and a number between $(D 1) and $(D 2) for\n    $(D wchar[2]) buffers.\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n  \n",
"line" : 818}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe ulong(ref wchar[2LU] buf, dchar c)",
"comment" : " Ditto\n",
"line" : 883}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe void(ref char[] str, dchar c)",
"comment" : "\n    Encodes $(D c) in $(D str)'s encoding and appends it to $(D str).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n  \n",
"line" : 932}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe void(ref wchar[] str, dchar c)",
"comment" : " ditto\n",
"line" : 1026}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe void(ref dchar[] str, dchar c)",
"comment" : " ditto\n",
"line" : 1076}
,
{
"name" : "codeLength(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the number of code units that are required to encode the code point\n    $(D c) when $(D C) is the character type used to encode it.\n\nExamples:\n------\nassert(codeLength!char('a') == 1);\nassert(codeLength!wchar('a') == 1);\nassert(codeLength!dchar('a') == 1);\n\nassert(codeLength!char('\\U0010FFFF') == 4);\nassert(codeLength!wchar('\\U0010FFFF') == 2);\nassert(codeLength!dchar('\\U0010FFFF') == 1);\n------\n  \n",
"line" : 1119,
"members" : [
{
"name" : "codeLength",
"kind" : "function",
"type" : "pure nothrow @safe ubyte(dchar c)",
"comment" : "\n    Returns the number of code units that are required to encode the code point\n    $(D c) when $(D C) is the character type used to encode it.\n\nExamples:\n------\nassert(codeLength!char('a') == 1);\nassert(codeLength!wchar('a') == 1);\nassert(codeLength!dchar('a') == 1);\n\nassert(codeLength!char('\\U0010FFFF') == 4);\nassert(codeLength!wchar('\\U0010FFFF') == 2);\nassert(codeLength!dchar('\\U0010FFFF') == 1);\n------\n  \n",
"line" : 1119}
]
}
,
{
"name" : "codeLength(C1,C2) if (isSomeChar!(C1) && isSomeChar!(C2))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the number of code units that are required to encode $(D str)\n    in a string whose character type is $(D C). This is particularly useful\n    when slicing one string with the length of another and the two string\n    types use different character types.\n\nExamples:\n------\nassert(codeLength!char(\"hello world\") ==\n       to!string(\"hello world\").length);\nassert(codeLength!wchar(\"hello world\") ==\n       to!wstring(\"hello world\").length);\nassert(codeLength!dchar(\"hello world\") ==\n       to!dstring(\"hello world\").length);\n\nassert(codeLength!char(``) ==\n       to!string(``).length);\nassert(codeLength!wchar(``) ==\n       to!wstring(``).length);\nassert(codeLength!dchar(``) ==\n       to!dstring(``).length);\n\nstring haystack = `tre sans la verit, a, ce ne serait pas bien.`;\nwstring needle = `tre sans la verit`;\nassert(haystack[codeLength!char(needle) .. $] ==\n       `, a, ce ne serait pas bien.`);\n------\n  \n",
"line" : 1183,
"members" : [
{
"name" : "codeLength",
"kind" : "function",
"type" : "pure @safe size_t(C2[] str)",
"comment" : "\n    Returns the number of code units that are required to encode $(D str)\n    in a string whose character type is $(D C). This is particularly useful\n    when slicing one string with the length of another and the two string\n    types use different character types.\n\nExamples:\n------\nassert(codeLength!char(\"hello world\") ==\n       to!string(\"hello world\").length);\nassert(codeLength!wchar(\"hello world\") ==\n       to!wstring(\"hello world\").length);\nassert(codeLength!dchar(\"hello world\") ==\n       to!dstring(\"hello world\").length);\n\nassert(codeLength!char(``) ==\n       to!string(``).length);\nassert(codeLength!wchar(``) ==\n       to!wstring(``).length);\nassert(codeLength!dchar(``) ==\n       to!dstring(``).length);\n\nstring haystack = `tre sans la verit, a, ce ne serait pas bien.`;\nwstring needle = `tre sans la verit`;\nassert(haystack[codeLength!char(needle) .. $] ==\n       `, a, ce ne serait pas bien.`);\n------\n  \n",
"line" : 1183}
]
}
,
{
"name" : "validate(S) if (isSomeString!(S))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Checks to see if $(D str) is well-formed unicode or not.\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
"line" : 1247,
"members" : [
{
"name" : "validate",
"kind" : "function",
"type" : "pure @safe void(in S str)",
"comment" : "\n    Checks to see if $(D str) is well-formed unicode or not.\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
"line" : 1247}
]
}
,
{
"name" : "toUTF8",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe char[](out char[4LU] buf, dchar c)",
"line" : 1263}
,
{
"name" : "toUTF8",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe string(const(char[]) s)",
"comment" : "\n Encodes string $(D_PARAM s) into UTF-8 and returns the encoded string.\n \n",
"line" : 1304}
,
{
"name" : "toUTF8",
"kind" : "function",
"protection" : "public",
"type" : "pure @trusted string(const(wchar[]) s)",
"comment" : " ditto\n",
"line" : 1311}
,
{
"name" : "toUTF8",
"kind" : "function",
"protection" : "public",
"type" : "pure @trusted string(const(dchar[]) s)",
"comment" : " ditto\n",
"line" : 1337}
,
{
"name" : "toUTF16",
"kind" : "function",
"protection" : "public",
"type" : "pure nothrow @safe wchar[](ref wchar[2LU] buf, dchar c)",
"line" : 1367}
,
{
"name" : "toUTF16",
"kind" : "function",
"protection" : "public",
"type" : "pure @trusted immutable(wchar)[](const(char[]) s)",
"comment" : "\n Encodes string $(D s) into UTF-16 and returns the encoded string.\n \n",
"line" : 1390}
,
{
"name" : "toUTF16",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe immutable(wchar)[](const(wchar[]) s)",
"comment" : " ditto\n",
"line" : 1416}
,
{
"name" : "toUTF16",
"kind" : "function",
"protection" : "public",
"type" : "pure @trusted immutable(wchar)[](const(dchar[]) s)",
"comment" : " ditto\n",
"line" : 1423}
,
{
"name" : "toUTF32",
"kind" : "function",
"protection" : "public",
"type" : "pure @trusted immutable(dchar)[](const(char[]) s)",
"comment" : "\n Encodes string $(D_PARAM s) into UTF-32 and returns the encoded string.\n \n",
"line" : 1444}
,
{
"name" : "toUTF32",
"kind" : "function",
"protection" : "public",
"type" : "pure @trusted immutable(dchar)[](const(wchar[]) s)",
"comment" : " ditto\n",
"line" : 1465}
,
{
"name" : "toUTF32",
"kind" : "function",
"protection" : "public",
"type" : "pure @safe immutable(dchar)[](const(dchar[]) s)",
"comment" : " ditto\n",
"line" : 1486}
,
{
"name" : "toUTFz(P)",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns a C-style zero-terminated string equivalent to $(D str). $(D str)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D str.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(D toUTFz) accepts any type of string and is templated on the type of\n    character pointer that you wish to convert to. It will avoid allocating a\n    new string if it can, but there's a decent chance that it will end up having\n    to allocate a new string - particularly when dealing with character types\n    other than $(D char).\n\n    $(RED Warning 1:) If the result of $(D toUTFz) equals $(D str.ptr), then if\n    anything alters the character one past the end of $(D str) (which is the\n    $(D '\\0') character terminating the string), then the string won't be\n    zero-terminated anymore. The most likely scenarios for that are if you\n    append to $(D str) and no reallocation takes place or when $(D str) is a\n    slice of a larger array, and you alter the character in the larger array\n    which is one character past the end of $(D str). Another case where it could\n    occur would be if you had a mutable character array immediately after\n    $(D str) in memory (for example, if they're member variables in a\n    user-defined type with one declared right after the other) and that\n    character array happened to start with $(D '\\0'). Such scenarios will never\n    occur if you immediately use the zero-terminated string after calling\n    $(D toUTFz) and the C function using it doesn't keep a reference to it.\n    Also, they are unlikely to occur even if you save the zero-terminated string\n    (the cases above would be among the few examples of where it could happen).\n    However, if you save the zero-terminate string and want to be absolutely\n    certain that the string stays zero-terminated, then simply append a\n    $(D '\\0') to the string and use its $(D ptr) property rather than calling\n    $(D toUTFz).\n\n    $(RED Warning 2:) When passing a character pointer to a C function, and the\n    C function keeps it around for any reason, make sure that you keep a\n    reference to it in your D code. Otherwise, it may go away during a garbage\n    collection cycle and cause a nasty bug when the C code tries to use it.\n\n    Examples:\n--------------------\nauto p1 = toUTFz!(char*)(\"hello world\");\nauto p2 = toUTFz!(const(char)*)(\"hello world\");\nauto p3 = toUTFz!(immutable(char)*)(\"hello world\");\nauto p4 = toUTFz!(char*)(\"hello world\"d);\nauto p5 = toUTFz!(const(wchar)*)(\"hello world\");\nauto p6 = toUTFz!(immutable(dchar)*)(\"hello world\"w);\n--------------------\n  \n",
"line" : 1544,
"members" : [
{
"name" : "toUTFz(S)",
"kind" : "template",
"protection" : "public",
"line" : 1546,
"members" : [
{
"name" : "toUTFz",
"kind" : "function",
"type" : "@system P(S str)",
"line" : 1546}
]
}
]
}
,
{
"name" : "toUTFz(P,S)",
"kind" : "template",
"protection" : "public",
"comment" : " Ditto \n",
"line" : 1553,
"members" : [
{
"name" : "toUTFz",
"kind" : "function",
"type" : "@system P(S str)",
"line" : 1555}
]
}
,
{
"name" : "toUTFzImpl(P,S) if (isSomeString!(S) && isPointer!(P) && isSomeChar!(typeof(*P.init)) && is(Unqual!(typeof(*P.init)) == Unqual!(ElementEncodingType!(S))) && is(immutable(Unqual!(ElementEncodingType!(S))) == ElementEncodingType!(S)))",
"kind" : "template",
"protection" : "public",
"line" : 1561,
"members" : [
{
"name" : "toUTFzImpl",
"kind" : "function",
"type" : "@system P(S str)",
"line" : 1561}
]
}
,
{
"name" : "toUTFzImpl(P,S) if (isSomeString!(S) && isPointer!(P) && isSomeChar!(typeof(*P.init)) && is(Unqual!(typeof(*P.init)) == Unqual!(ElementEncodingType!(S))) && !is(immutable(Unqual!(ElementEncodingType!(S))) == ElementEncodingType!(S)))",
"kind" : "template",
"protection" : "public",
"line" : 1599,
"members" : [
{
"name" : "toUTFzImpl",
"kind" : "function",
"type" : "@system P(S str)",
"line" : 1599}
]
}
,
{
"name" : "toUTFzImpl(P,S) if (isSomeString!(S) && isPointer!(P) && isSomeChar!(typeof(*P.init)) && !is(Unqual!(typeof(*P.init)) == Unqual!(ElementEncodingType!(S))))",
"kind" : "template",
"protection" : "public",
"line" : 1633,
"members" : [
{
"name" : "toUTFzImpl",
"kind" : "function",
"type" : "P(S str)",
"line" : 1633}
]
}
,
{
"name" : "toUTF16z(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    $(D toUTF16z) is a convenience function for $(D toUTFz!(const(wchar)*)).\n\n    Encodes string $(D s) into UTF-16 and returns the encoded string.\n    $(D toUTF16z) is suitable for calling the 'W' functions in the Win32 API\n    that take an $(D LPWSTR) or $(D LPCWSTR) argument.\n  \n",
"line" : 1751,
"members" : [
{
"name" : "toUTF16z",
"kind" : "function",
"type" : "const(wchar)*(const(C)[] str)",
"comment" : "\n    $(D toUTF16z) is a convenience function for $(D toUTFz!(const(wchar)*)).\n\n    Encodes string $(D s) into UTF-16 and returns the encoded string.\n    $(D toUTF16z) is suitable for calling the 'W' functions in the Win32 API\n    that take an $(D LPWSTR) or $(D LPCWSTR) argument.\n  \n",
"line" : 1751}
]
}
,
{
"name" : "count(C) if (isSomeChar!(C))",
"kind" : "template",
"protection" : "public",
"comment" : "\n    Returns the total number of code points encoded in $(D str).\n\n    Supercedes: This function supercedes $(LREF toUCSindex).\n\n    Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
"line" : 1841,
"members" : [
{
"name" : "count",
"kind" : "function",
"type" : "pure @trusted size_t(const(C)[] str)",
"comment" : "\n    Returns the total number of code points encoded in $(D str).\n\n    Supercedes: This function supercedes $(LREF toUCSindex).\n\n    Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
"line" : 1841}
]
}
]
}
,
{
"name" : "std.uuid",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/uuid.d",
"comment" : "\n<script type=\"text\/javascript\">inhibitQuickIndex = 1<\/script>\n\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Parsing UUIDs) $(TD $(MYREF parseUUID) $(MYREF\nUUID(string)) $(MYREF UUIDParsingException) $(MYREF uuidRegex) )\n)\n$(TR $(TDNW Generating UUIDs) $(TD $(MYREF sha1UUID) $(MYREF randomUUID) $(MYREF\nmd5UUID))\n)\n$(TR $(TDNW Using UUIDs) $(TD $(MYREF2 UUID.uuidVersion, uuidVersion) $(MYREF2 UUID.variant, variant)\n$(MYREF2 UUID.toString, toString) $(MYREF2 UUID.data, data) $(MYREF2 UUID.swap, swap)\n$(MYREF2 UUID.opEquals, opEquals) $(MYREF2 UUID.opCmp, opCmp) $(MYREF2 UUID.toHash, toHash) )\n)\n$(TR $(TDNW UUID namespaces) $(TD $(MYREF dnsNamespace) $(MYREF urlNamespace)\n$(MYREF oidNamespace) $(MYREF x500Namespace) )\n)\n)\n\n A $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier, UUID), or\n $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier, Universally unique identifier),\n is intended to uniquely identify information in a distributed environment\n without significant central coordination. It can be\n used to tag objects with very short lifetimes, or to reliably identify very\n persistent objects across a network.\n\n UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify\n rows or records in order to ensure that they are unique across different\n databases, or for publication\/subscription services. Network messages may be\n identified with a UUID to ensure that different parts of a message are put back together\n again. Distributed computing may use UUIDs to identify a remote procedure call.\n Transactions and classes involved in serialization may be identified by UUIDs.\n Microsoft's component object model (COM) uses UUIDs to distinguish different software\n component interfaces. UUIDs are inserted into documents from Microsoft Office programs.\n UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are\n also a basis for OIDs (object identifiers), and URNs (uniform resource name).\n\n An attractive feature of UUIDs when compared to alternatives is their relative small size,\n of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require\n a centralized authority.\n\n When UUIDs are generated by one of the defined mechanisms, they are either guaranteed\n to be unique, different from all other generated UUIDs (that is, it has never been\n generated before and it will never be generated again), or it is extremely likely\n to be unique (depending on the mechanism).\n\n For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly\n initialized. An UUID is empty if $(MYREF3 UUID.empty, empty) is true. Empty UUIDs are equal to\n $(D UUID.init), which is a UUID with all 16 bytes set to 0.\n Use UUID's constructors or the UUID generator functions to get an initialized UUID.\n\n This is a port of $(LINK2 http:\/\/www.boost.org\/doc\/libs\/1_42_0\/libs\/uuid\/uuid.html,\n boost._uuid) from the Boost project with some minor additions and API\n changes for a more D-like API.\n\n Examples:\n ------------------------\n UUID[] ids;\n ids ~= randomUUID();\n ids ~= md5UUID(\"test.name.123\");\n ids ~= sha1UUID(\"test.name.123\");\n\n foreach(entry; ids)\n {\n     assert(entry.variant == UUID.Variant.rfc4122);\n }\n\n assert(ids[0].uuidVersion == UUID.Version.randomNumberBased);\n assert(ids[1].toString() == \"22390768-cced-325f-8f0f-cfeaa19d0ccd\");\n assert(ids[1].data == [34, 57, 7, 104, 204, 237, 50, 95, 143, 15, 207,\n     234, 161, 157, 12, 205]);\n\n UUID id;\n assert(id.empty);\n\n ------------------------\n Standards:\n $(LINK2 http:\/\/www.ietf.org\/rfc\/rfc4122.txt, RFC 4122)\n\n See_Also:\n $(LINK http:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier)\n\n Copyright: Copyright Johannes Pfau 2011 - .\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>\n Authors:   Johannes Pfau\n Source:    $(PHOBOSSRC std\/_uuid.d)\n\n Macros:\n MYREF = <font face='Consolas, \"Bitstream Vera Sans Mono\", \"Andale Mono\", Monaco, \"DejaVu Sans Mono\", \"Lucida Console\", monospace'><a href=\"#$1\">$1<\/a>&nbsp;<\/font>\n MYREF2 = <font face='Consolas, \"Bitstream Vera Sans Mono\", \"Andale Mono\", Monaco, \"DejaVu Sans Mono\", \"Lucida Console\", monospace'><a href=\"#$2\">$1<\/a>&nbsp;<\/font>\n MYREF3 = <a href=\"#$2\">$(D $1)<\/a>\n \n",
"members" : [
{
"name" : "UUID",
"kind" : "struct",
"protection" : "public",
"comment" : "\n\n \n",
"line" : 112,
"members" : [
{
"name" : "toChar",
"kind" : "function",
"protection" : "private",
"type" : "const pure nothrow @safe char(ulong i)",
"line" : 114}
,
{
"name" : "_toString",
"kind" : "function",
"protection" : "private",
"type" : "const pure nothrow @safe char[36LU]()",
"line" : 122}
,
{
"name" : "Variant",
"kind" : "enum",
"protection" : "public",
"comment" : "\n RFC 4122 defines different internal data layouts for UUIDs. These are\n the UUID formats supported by this module. It's\n possible to read, compare and use all these Variants, but\n UUIDs generated by this module will always be in rfc4122 format.\n\n Note: Do not confuse this with $(XREF _variant, _Variant). This has nothing\n to do with $(XREF _variant, _Variant).\n         \n",
"line" : 162,
"base" : "int",
"members" : [
{
"name" : "ncs",
"kind" : "enum member",
"protection" : "public",
"comment" : " NCS backward compatibility\n",
"line" : 163}
,
{
"name" : "rfc4122",
"kind" : "enum member",
"protection" : "public",
"comment" : " Defined in RFC 4122 document\n",
"line" : 164}
,
{
"name" : "microsoft",
"kind" : "enum member",
"protection" : "public",
"comment" : " Microsoft Corporation backward compatibility\n",
"line" : 165}
,
{
"name" : "future",
"kind" : "enum member",
"protection" : "public",
"comment" : "Reserved for future use\n",
"line" : 166}
]
}
,
{
"name" : "Version",
"kind" : "enum",
"protection" : "public",
"comment" : "\n RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n\n Note:\n All of these UUID versions can be read and processed by\n $(D std.uuid), but only version 3, 4 and 5 UUIDs can be generated.\n         \n",
"line" : 179,
"base" : "int",
"members" : [
{
"name" : "unknown",
"kind" : "enum member",
"protection" : "public",
"comment" : "Unknown version\n",
"line" : 181}
,
{
"name" : "timeBased",
"kind" : "enum member",
"protection" : "public",
"comment" : "Version 1\n",
"line" : 183}
,
{
"name" : "dceSecurity",
"kind" : "enum member",
"protection" : "public",
"comment" : "Version 2\n",
"line" : 185}
,
{
"name" : "nameBasedMD5",
"kind" : "enum member",
"protection" : "public",
"comment" : "Version 3 (Name based + MD5)\n",
"line" : 187}
,
{
"name" : "randomNumberBased",
"kind" : "enum member",
"protection" : "public",
"comment" : "Version 4 (Random)\n",
"line" : 189}
,
{
"name" : "nameBasedSHA1",
"kind" : "enum member",
"protection" : "public",
"comment" : "Version 5 (Name based + SHA-1)\n",
"line" : 191}
]
}
,
{
"name" : "data",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[16LU]",
"comment" : "\n It is sometimes useful to get or set the 16 bytes of a UUID\n directly.\n\n Note:\n UUID uses a 16-ubyte representation for the UUID data.\n RFC 4122 defines a UUID as a special structure in big-endian\n format. These 16-ubytes always equal the big-endian structure\n defined in RFC 4122.\n\n Examples:\n -----------------------------------------------\n auto rawData = uuid.data; \/\/get data\n rawData[0] = 1; \/\/modify\n uuid.data = rawData; \/\/set data\n uuid.data[1] = 2; \/\/modify directly\n -----------------------------------------------\n         \n",
"line" : 212}
,
{
"name" : "__ctor()",
"kind" : "template",
"protection" : "public",
"comment" : "\n Construct a UUID struct from the 16 byte representation\n of a UUID.\n\n Examples:\n -------------------------\n ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n auto tmp = UUID(data);\n assert(tmp.data == data);\n -------------------------\n         \n",
"line" : 248,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(ubyte[16] uuidData)",
"line" : 248}
]
}
,
{
"name" : "__ctor(T) if (isSomeChar!(Unqual!(T)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n <a name=\"UUID(string)\"><\/a>\n Parse a UUID from its canonical string form. An UUID in its\n canonical form looks like this: 8ab3060e-2cba-4f23-b74c-b52db3bdfb46\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at\n compile time.\n\n Note:\n This is a strict parser. It only accepts the pattern above.\n It doesn't support any leading or trailing characters. It only\n accepts characters used for hex numbers and the string must have\n hyphens exactly like above.\n\n For a less strict parser, see $(LREF parseUUID)\n\n Examples:\n -------------------------\n id = UUID(\"8AB3060E-2cba-4f23-b74c-b52db3bdfb46\");\n assert(id.data == [138, 179, 6, 14, 44, 186, 79, 35, 183, 76,\n    181, 45, 179, 189, 251, 70]);\n assert(id.toString() == \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n\n \/\/Can also be used in CTFE, for example as UUID literals:\n enum ctfeID = UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n \/\/here parsing is done at compile time, no runtime overhead!\n -------------------------\n\n BUGS: Could be pure, but this depends on parse!(string, 16).\n         \n",
"line" : 339,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(T[] uuid)",
"line" : 339}
]
}
,
{
"name" : "empty",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @trusted bool()",
"comment" : "\n Returns true if and only if the UUID is equal\n to {00000000-0000-0000-0000-000000000000}\n\n Examples:\n -------------------------\n UUID id;\n assert(id.empty);\n id = UUID(\"00000000-0000-0000-0000-000000000001\");\n assert(!id.empty);\n -------------------------\n         \n",
"line" : 465}
,
{
"name" : "variant",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe Variant()",
"comment" : "\n RFC 4122 defines different internal data layouts for UUIDs.\n Returns the format used by this UUID.\n\n Note: Do not confuse this with $(XREF _variant, _Variant). This has nothing\n to do with $(XREF _variant, _Variant). The type of this property is\n $(MYREF3 std.uuid.UUID.Variant, _Variant).\n\n See_Also:\n $(MYREF3 UUID.Variant, Variant)\n\n Examples:\n ------------------------\n assert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").variant\n     == UUID.Variant.rfc4122);\n ------------------------\n         \n",
"line" : 528}
,
{
"name" : "uuidVersion",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @property @safe Version()",
"comment" : "\n RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n Returns the version used by this UUID.\n\n See_Also:\n $(MYREF3 UUID.Version, Version)\n\n Examples:\n ----------------------------\n  assert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").uuidVersion\n      == UUID.Version.randomNumberBased);\n ----------------------------\n         \n",
"line" : 594}
,
{
"name" : "swap",
"kind" : "function",
"protection" : "public",
"type" : "nothrow @safe void(ref UUID rhs)",
"comment" : "\n Swap the data of this UUID with the data of rhs.\n\n Note: linear complexity\n\n Examples:\n ----------------------------\n UUID u1;\n auto u2 = UUID(cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);\n u1.swap(u2);\n\n assert(u1.data == cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);\n assert(u2.data == cast(ubyte[16])[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);\n ----------------------------\n         \n",
"line" : 661}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe bool(const(UUID) s)",
"comment" : "\n All of the standard numeric operators are defined for\n the UUID struct.\n\n Examples:\n -------------------------\n \/\/compare UUIDs\n assert(UUID(\"00000000-0000-0000-0000-000000000000\") == UUID.init);\n\n \/\/UUIDs in associative arrays:\n int[UUID] test = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\") : 1,\n     UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\") : 2,\n     UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\") : 3];\n\n assert(test[UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")] == 3);\n\n \/\/UUIDS can be sorted:\n import std.algorithm;\n UUID[] ids = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\"),\n               UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\"),\n               UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")];\n sort(ids);\n -------------------------\n         \n",
"line" : 706}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe bool(ref const(UUID) s)",
"comment" : "\n ditto\n         \n",
"line" : 714}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe int(ref const(UUID) s)",
"comment" : "\n ditto\n         \n",
"line" : 722}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe int(const(UUID) s)",
"comment" : "\n ditto\n         \n",
"line" : 730}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe ulong()",
"comment" : "\n ditto\n         \n",
"line" : 738}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const void(scope void delegate(const(char)[]) sink)",
"comment" : "\n Return the UUID as a string in the canonical form.\n\n Examples:\n ----------------------------------\n auto id = UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n assert(id.toString() == \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n ----------------------------------\n         \n",
"line" : 808}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const pure nothrow @safe string()",
"comment" : "ditto\n",
"line" : 814}
,
{
"name" : "__xopEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(const(void*) p, const(void*) q)",
"line" : 112}
]
}
,
{
"name" : "md5UUID",
"kind" : "function",
"protection" : "public",
"type" : "@safe UUID(const(char[]) name, const(UUID) namespace = UUID([cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u]))",
"comment" : "\n This function generates a name based (Version 3) UUID from a namespace UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n RFC 4122 recommends to use Version 5 UUIDs (SHA-1) instead of Version 3\n UUIDs (MD5) for new applications.\n\n CTFE:\n CTFE is currently not supported as $(D std.md5) doesn't work in CTFE.\n\n Examples:\n ---------------------------------------\n \/\/Use default UUID.init namespace\n auto simpleID = md5UUID(\"test.uuid.any.string\");\n\n \/\/use a name-based id as namespace\n auto namespace = md5UUID(\"my.app\");\n auto id = md5UUID(\"some-description\", namespace);\n ---------------------------------------\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\n\n BUGS: Could be pure, but this depends on the MD5 hash code.\n \n",
"line" : 890}
,
{
"name" : "md5UUID",
"kind" : "function",
"protection" : "public",
"type" : "@trusted UUID(const(ubyte[]) data, const(UUID) namespace = UUID([cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u,cast(ubyte)0u]))",
"comment" : "\n ditto\n \n",
"line" : 898}
,
{
"name" : "randomUUID()",
"kind" : "template",
"protection" : "public",
"comment" : "\n This function generates a random number based UUID from a random\n number generator.\n\n CTFE:\n This function is not supported at compile time.\n\n Examples:\n ------------------------------------------\n \/\/simple call\n auto uuid = randomUUID();\n\n \/\/provide a custom RNG. Must be seeded manually.\n Xorshift192 gen;\n\n gen.seed(unpredictableSeed());\n auto uuid3 = randomUUID(gen);\n ------------------------------------------\n \n",
"line" : 1086,
"members" : [
{
"name" : "randomUUID",
"kind" : "function",
"type" : "UUID()",
"line" : 1086}
]
}
,
{
"name" : "randomUUID(RNG) if (isUniformRNG!(RNG) && isIntegral!(typeof(RNG.front)))",
"kind" : "template",
"protection" : "public",
"comment" : "\n ditto\n \n",
"line" : 1101,
"members" : [
{
"name" : "randomUUID",
"kind" : "function",
"type" : "UUID(ref RNG randomGen)",
"comment" : "\n ditto\n \n",
"line" : 1101}
]
}
,
{
"name" : "parseUUID(T) if (isSomeString!(T))",
"kind" : "template",
"protection" : "public",
"comment" : "\n This is a less strict parser compared to the parser used in the\n UUID constructor. It enforces the following rules:\n\n $(UL\n   $(LI hex numbers are always two hexdigits([0-9a-fA-F]))\n   $(LI there must be exactly 16 such pairs in the input, not less, not more)\n   $(LI there can be exactly one dash between two hex-pairs, but not more)\n   $(LI there can be multiple characters enclosing the 16 hex pairs,\n     as long as these characters do not contain [0-9a-fA-F])\n )\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at compile time.\n\n Examples:\n -------------------------\n auto id = parseUUID(\"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46\");\n \/\/no dashes\n id = parseUUID(\"8ab3060e2cba4f23b74cb52db3bdfb46\");\n \/\/dashes at different positions\n id = parseUUID(\"8a-b3-06-0e2cba4f23b74c-b52db3bdfb-46\");\n \/\/leading \/ trailing characters\n id = parseUUID(\"{8ab3060e-2cba-4f23-b74c-b52db3bdfb46}\");\n \/\/unicode\n id = parseUUID(\"8ab3060e2cba4f23b74cb52db3bdfb46\");\n \/\/multiple trailing\/leading characters\n id = parseUUID(\"\/\/\/8ab3060e2cba4f23b74cb52db3bdfb46||\");\n\n \/\/Can also be used in CTFE, for example as UUID literals:\n enum ctfeID = parseUUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n \/\/here parsing is done at compile time, no runtime overhead!\n -------------------------\n\n BUGS: Could be pure, but this depends on parse!(string, 16).\n \n",
"line" : 1187,
"members" : [
{
"name" : "parseUUID",
"kind" : "function",
"type" : "UUID(T uuidString)",
"line" : 1187}
]
}
,
{
"name" : "parseUUID(Range) if (isInputRange!(Range) && is(Unqual!(ElementType!(Range)) == dchar))",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 1193,
"members" : [
{
"name" : "parseUUID",
"kind" : "function",
"type" : "UUID(ref Range uuidRange)",
"comment" : "ditto\n",
"line" : 1193}
]
}
,
{
"name" : "dnsNamespace",
"kind" : "variable",
"protection" : "public",
"type" : "UUID",
"comment" : "\n Default namespace from RFC 4122\n\n Name string is a fully-qualified domain name\n \n",
"line" : 1470}
,
{
"name" : "urlNamespace",
"kind" : "variable",
"protection" : "public",
"type" : "UUID",
"comment" : "\n Default namespace from RFC 4122\n\n Name string is a URL\n \n",
"line" : 1477}
,
{
"name" : "oidNamespace",
"kind" : "variable",
"protection" : "public",
"type" : "UUID",
"comment" : "\n Default namespace from RFC 4122\n\n Name string is an ISO OID\n \n",
"line" : 1484}
,
{
"name" : "x500Namespace",
"kind" : "variable",
"protection" : "public",
"type" : "UUID",
"comment" : "\n Default namespace from RFC 4122\n\n Name string is an X.500 DN (in DER or a text output format)\n \n",
"line" : 1491}
,
{
"name" : "uuidRegex",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n Regex string to extract UUIDs from text.\n\n Examples:\n -------------------\n import std.algorithm;\n import std.regex;\n\n string test = \"Lorem ipsum dolor sit amet, consetetur \"\n     \"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \\n\"\n     \"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \\r\\n\"\n     \"magna aliquyam erat, sed diam voluptua. \"\n     \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et \"\n     \"justo duo dolores et ea rebum.\";\n\n auto r = regex(uuidRegex, \"g\");\n\n UUID[] found;\n foreach(c; match(test, r))\n {\n     found ~= UUID(c.hit);\n }\n\n writeln(found);\n -------------------\n \n",
"line" : 1520}
,
{
"name" : "UUIDParsingException",
"kind" : "class",
"protection" : "public",
"comment" : "\n This exception is thrown if an error occurs when parsing a UUID\n from a string.\n \n",
"line" : 1549,
"base" : "Exception",
"members" : [
{
"name" : "Reason",
"kind" : "enum",
"protection" : "public",
"comment" : "\n The reason why parsing the UUID string failed (if known)\n         \n",
"line" : 1556,
"base" : "int",
"members" : [
{
"name" : "unknown",
"kind" : "enum member",
"protection" : "public",
"comment" : "\n",
"line" : 1557}
,
{
"name" : "tooLittle",
"kind" : "enum member",
"protection" : "public",
"comment" : "The passed in input was correct, but more input was expected.\n",
"line" : 1558}
,
{
"name" : "tooMuch",
"kind" : "enum member",
"protection" : "public",
"comment" : "The input data is too long (There's no guarantee the first part of the data is valid)\n",
"line" : 1559}
,
{
"name" : "invalidChar",
"kind" : "enum member",
"protection" : "public",
"comment" : "Encountered an invalid character\n",
"line" : 1560}
]
}
,
{
"name" : "reason",
"kind" : "variable",
"protection" : "public",
"type" : "Reason",
"comment" : "ditto\n",
"line" : 1564}
,
{
"name" : "input",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "The original input string which should have been parsed.\n",
"line" : 1566}
,
{
"name" : "position",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"comment" : "The position in the input string where the error occurred.\n",
"line" : 1568}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "UUIDParsingException(string input, ulong pos, Reason why = cast(Reason)0, string msg = \"\", Throwable next = null, string file = __FILE__, ulong line = cast(ulong)__LINE__)",
"line" : 1570}
]
}
]
}
,
{
"name" : "std.variant",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/variant.d",
"comment" : "\n This module implements a\n $(LINK2 http:\/\/erdani.org\/publications\/cuj-04-2002.html,discriminated union)\n type (a.k.a.\n $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Tagged_union,tagged union),\n $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Algebraic_data_type,algebraic type)).\n Such types are useful\n for type-uniform binary interfaces, interfacing with scripting\n languages, and comfortable exploratory programming.\n\n Macros:\n  WIKI = Phobos\/StdVariant\n\n Synopsis:\n\n ----\n Variant a; \/\/ Must assign before use, otherwise exception ensues\n \/\/ Initialize with an integer; make the type int\n Variant b = 42;\n assert(b.type == typeid(int));\n \/\/ Peek at the value\n assert(b.peek!(int) !is null && *b.peek!(int) == 42);\n \/\/ Automatically convert per language rules\n auto x = b.get!(real);\n \/\/ Assign any other type, including other variants\n a = b;\n a = 3.14;\n assert(a.type == typeid(double));\n \/\/ Implicit conversions work just as with built-in types\n assert(a > b);\n \/\/ Check for convertibility\n assert(!a.convertsTo!(int)); \/\/ double not convertible to int\n \/\/ Strings and all other arrays are supported\n a = \"now I'm a string\";\n assert(a == \"now I'm a string\");\n a = new int[42]; \/\/ can also assign arrays\n assert(a.length == 42);\n a[5] = 7;\n assert(a[5] == 7);\n \/\/ Can also assign class values\n class Foo {}\n auto foo = new Foo;\n a = foo;\n assert(*a.peek!(Foo) == foo); \/\/ and full type information is preserved\n ----\n\n Credits:\n\n Reviewed by Brad Roberts. Daniel Keep provided a detailed code\n review prompting the following improvements: (1) better support for\n arrays; (2) support for associative arrays; (3) friendlier behavior\n towards the garbage collector.\n\n Copyright: Copyright Andrei Alexandrescu 2007 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB erdani.org, Andrei Alexandrescu)\n Source:    $(PHOBOSSRC std\/_variant.d)\n \n",
"members" : [
{
"name" : "maxSize(T...)",
"kind" : "template",
"protection" : "public",
"line" : 76,
"members" : [
]
}
,
{
"name" : "This",
"kind" : "struct",
"protection" : "public",
"line" : 89}
,
{
"name" : "AssociativeArray(T)",
"kind" : "template",
"protection" : "public",
"line" : 91,
"members" : [
{
"name" : "valid",
"kind" : "variable",
"type" : "bool",
"line" : 93}
,
{
"name" : "Key",
"kind" : "alias",
"type" : "void",
"line" : 94}
,
{
"name" : "Value",
"kind" : "alias",
"type" : "void",
"line" : 95}
]
}
,
{
"name" : "AssociativeArray(T : V[K],K,V)",
"kind" : "template",
"protection" : "public",
"line" : 98,
"members" : [
{
"name" : "valid",
"kind" : "variable",
"type" : "bool",
"line" : 100}
,
{
"name" : "Key",
"kind" : "alias",
"type" : "K",
"line" : 101}
,
{
"name" : "Value",
"kind" : "alias",
"type" : "V",
"line" : 102}
]
}
,
{
"name" : "This2Variant(V,T...)",
"kind" : "template",
"protection" : "public",
"line" : 105,
"members" : [
]
}
,
{
"name" : "VariantN(ulong maxDataSize,AllowedTypesX...)",
"kind" : "struct",
"protection" : "public",
"comment" : "\n $(D_PARAM VariantN) is a back-end type seldom used directly by user\n code. Two commonly-used types using $(D_PARAM VariantN) as\n back-end are:\n\n $(OL $(LI $(B Algebraic): A closed discriminated union with a\n limited type universe (e.g., $(D_PARAM Algebraic!(int, double,\n string)) only accepts these three types and rejects anything\n else).) $(LI $(B Variant): An open discriminated union allowing an\n unbounded set of types. The restriction is that the size of the\n stored type cannot be larger than the largest built-in type. This\n means that $(D_PARAM Variant) can accommodate all primitive types\n and all user-defined types except for large $(D_PARAM struct)s.) )\n\n Both $(D_PARAM Algebraic) and $(D_PARAM Variant) share $(D_PARAM\n VariantN)'s interface. (See their respective documentations below.)\n\n $(D_PARAM VariantN) is a discriminated union type parameterized\n with the largest size of the types stored ($(D_PARAM maxDataSize))\n and with the list of allowed types ($(D_PARAM AllowedTypes)). If\n the list is empty, then any type up of size up to $(D_PARAM\n maxDataSize) (rounded up for alignment) can be stored in a\n $(D_PARAM VariantN) object.\n\n \n",
"line" : 155,
"members" : [
{
"name" : "VariantN",
"kind" : "struct",
"protection" : "public",
"line" : 155,
"members" : [
{
"name" : "AllowedTypes",
"kind" : "alias",
"type" : "This2Variant!(VariantN,AllowedTypesX)",
"line" : 156}
,
{
"name" : "SizeChecker",
"kind" : "struct",
"protection" : "public",
"line" : 161,
"members" : [
{
"name" : "fptr",
"kind" : "variable",
"type" : "int function()",
"line" : 162}
,
{
"name" : "data",
"kind" : "variable",
"type" : "ubyte[maxDataSize]",
"line" : 163}
]
}
,
{
"name" : "size",
"kind" : "variable",
"line" : 165}
,
{
"name" : "allowed(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Tells whether a type $(D_PARAM T) is statically allowed for\n storage inside a $(D_PARAM VariantN) object by looking\n $(D_PARAM T) up in $(D_PARAM AllowedTypes). If $(D_PARAM\n AllowedTypes) is empty, all types of size up to $(D_PARAM\n maxSize) are allowed.\n     \n",
"line" : 174,
"members" : [
{
"name" : "allowed",
"kind" : "variable",
"type" : "bool",
"line" : 176}
]
}
,
{
"name" : "OpID",
"kind" : "enum",
"protection" : "public",
"line" : 185,
"members" : [
{
"name" : "getTypeInfo",
"kind" : "enum member",
"protection" : "public",
"line" : 185}
,
{
"name" : "get",
"kind" : "enum member",
"protection" : "public",
"line" : 185}
,
{
"name" : "compare",
"kind" : "enum member",
"protection" : "public",
"line" : 185}
,
{
"name" : "testConversion",
"kind" : "enum member",
"protection" : "public",
"line" : 185}
,
{
"name" : "toString",
"kind" : "enum member",
"protection" : "public",
"line" : 185}
,
{
"name" : "index",
"kind" : "enum member",
"protection" : "public",
"line" : 186}
,
{
"name" : "indexAssign",
"kind" : "enum member",
"protection" : "public",
"line" : 186}
,
{
"name" : "catAssign",
"kind" : "enum member",
"protection" : "public",
"line" : 186}
,
{
"name" : "copyOut",
"kind" : "enum member",
"protection" : "public",
"line" : 186}
,
{
"name" : "length",
"kind" : "enum member",
"protection" : "public",
"line" : 186}
,
{
"name" : "apply",
"kind" : "enum member",
"protection" : "public",
"line" : 187}
]
}
,
{
"name" : "fptr",
"kind" : "variable",
"type" : "sizediff_t function(OpID selector, ubyte[size]* store, void* data)",
"line" : 190}
,
{
"name" : "store",
"kind" : "variable",
"type" : "ubyte[size]",
"line" : 194}
,
{
"name" : "handler(A : void)",
"kind" : "template",
"protection" : "public",
"line" : 202,
"members" : [
{
"name" : "handler",
"kind" : "function",
"type" : "sizediff_t(OpID selector, ubyte[size]*, void* parm)",
"line" : 202}
]
}
,
{
"name" : "handler(A)",
"kind" : "template",
"protection" : "public",
"line" : 237,
"members" : [
{
"name" : "handler",
"kind" : "function",
"type" : "sizediff_t(OpID selector, ubyte[size]* pStore, void* parm)",
"line" : 237}
]
}
,
{
"name" : "__ctor(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Constructs a $(D_PARAM VariantN) value given an argument of a\n generic type. Statically rejects disallowed types.\n     \n",
"line" : 491,
"members" : [
{
"name" : "this",
"kind" : "constructor",
"type" : "(T value)",
"line" : 491}
]
}
,
{
"name" : "opAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : " Assigns a $(D_PARAM VariantN) from a generic\n argument. Statically rejects disallowed types. \n",
"line" : 501,
"members" : [
{
"name" : "opAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : " Assigns a $(D_PARAM VariantN) from a generic\n argument. Statically rejects disallowed types. \n",
"line" : 501}
]
}
,
{
"name" : "hasValue",
"kind" : "function",
"type" : "const pure nothrow bool()",
"comment" : " Returns true if and only if the $(D_PARAM VariantN) object\n holds a valid value (has been initialized with, or assigned\n from, a valid value).\n Example:\n ----\n Variant a;\n assert(!a.hasValue);\n Variant b;\n a = b;\n assert(!a.hasValue); \/\/ still no value\n a = 5;\n assert(a.hasValue);\n ----\n     \n",
"line" : 565}
,
{
"name" : "peek(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n If the $(D_PARAM VariantN) object holds a value of the\n $(I exact) type $(D_PARAM T), returns a pointer to that\n value. Otherwise, returns $(D_PARAM null). In cases\n where $(D_PARAM T) is statically disallowed, $(D_PARAM\n peek) will not compile.\n\n Example:\n ----\n Variant a = 5;\n auto b = a.peek!(int);\n assert(b !is null);\n *b = 6;\n assert(a == 6);\n ----\n     \n",
"line" : 587,
"members" : [
{
"name" : "peek",
"kind" : "function",
"type" : "T*()",
"line" : 587}
]
}
,
{
"name" : "type",
"kind" : "function",
"type" : "const TypeInfo()",
"comment" : "\n Returns the $(D_PARAM typeid) of the currently held value.\n     \n",
"line" : 599}
,
{
"name" : "convertsTo(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns $(D_PARAM true) if and only if the $(D_PARAM VariantN)\n object holds an object implicitly convertible to type $(D_PARAM\n U). Implicit convertibility is defined as per\n $(LINK2 std_traits.html#ImplicitConversionTargets,ImplicitConversionTargets).\n     \n",
"line" : 613,
"members" : [
{
"name" : "convertsTo",
"kind" : "function",
"type" : "const bool()",
"line" : 613}
]
}
,
{
"name" : "get(T) if (!is(T == const))",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the value stored in the $(D_PARAM VariantN) object,\n implicitly converted to the requested type $(D_PARAM T), in\n fact $(D_PARAM DecayStaticToDynamicArray!(T)). If an implicit\n conversion is not possible, throws a $(D_PARAM\n VariantException).\n     \n",
"line" : 653,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "T()",
"line" : 653}
]
}
,
{
"name" : "get(T) if (is(T == const))",
"kind" : "template",
"protection" : "public",
"line" : 669,
"members" : [
{
"name" : "get",
"kind" : "function",
"type" : "const T()",
"line" : 669}
]
}
,
{
"name" : "coerce(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns the value stored in the $(D_PARAM VariantN) object,\n explicitly converted (coerced) to the requested type $(D_PARAM\n T). If $(D_PARAM T) is a string type, the value is formatted as\n a string. If the $(D_PARAM VariantN) object is a string, a\n parse of the string to type $(D_PARAM T) is attempted. If a\n conversion is not possible, throws a $(D_PARAM\n VariantException).\n     \n",
"line" : 695,
"members" : [
{
"name" : "coerce",
"kind" : "function",
"type" : "T()",
"line" : 695}
]
}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"comment" : "\n Formats the stored value as a string.\n     \n",
"line" : 751}
,
{
"name" : "opEquals(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Comparison for equality used by the \"==\" and \"!=\"  operators.\n     \n",
"line" : 763,
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"type" : "bool(T rhs)",
"comment" : "\n Comparison for equality used by the \"==\" and \"!=\"  operators.\n     \n",
"line" : 763}
]
}
,
{
"name" : "opCmp(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Ordering comparison used by the \"<\", \"<=\", \">\", and \">=\"\n operators. In case comparison is not sensible between the held\n value and $(D_PARAM rhs), an exception is thrown.\n     \n",
"line" : 778,
"members" : [
{
"name" : "opCmp",
"kind" : "function",
"type" : "int(T rhs)",
"comment" : "\n Ordering comparison used by the \"<\", \"<=\", \">\", and \">=\"\n operators. In case comparison is not sensible between the held\n value and $(D_PARAM rhs), an exception is thrown.\n     \n",
"line" : 778}
]
}
,
{
"name" : "toHash",
"kind" : "function",
"type" : "size_t()",
"comment" : "\n Computes the hash of the held value.\n     \n",
"line" : 798}
,
{
"name" : "opArithmetic(T,string op)",
"kind" : "template",
"protection" : "public",
"line" : 803,
"members" : [
{
"name" : "opArithmetic",
"kind" : "function",
"type" : "VariantN(T other)",
"line" : 803}
]
}
,
{
"name" : "opLogic(T,string op)",
"kind" : "template",
"protection" : "public",
"line" : 840,
"members" : [
{
"name" : "opLogic",
"kind" : "function",
"type" : "VariantN(T other)",
"line" : 840}
]
}
,
{
"name" : "opAdd(T)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Arithmetic between $(D_PARAM VariantN) objects and numeric\n values. All arithmetic operations return a $(D_PARAM VariantN)\n object typed depending on the types of both values\n involved. The conversion rules mimic D's built-in rules for\n arithmetic conversions.\n     \n",
"line" : 879,
"members" : [
{
"name" : "opAdd",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "\n Arithmetic between $(D_PARAM VariantN) objects and numeric\n values. All arithmetic operations return a $(D_PARAM VariantN)\n object typed depending on the types of both values\n involved. The conversion rules mimic D's built-in rules for\n arithmetic conversions.\n     \n",
"line" : 879}
]
}
,
{
"name" : "opSub(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 881,
"members" : [
{
"name" : "opSub",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 881}
]
}
,
{
"name" : "opMul(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\nditto\n",
"line" : 892,
"members" : [
{
"name" : "opMul",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\nditto\n",
"line" : 892}
]
}
,
{
"name" : "opDiv(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 894,
"members" : [
{
"name" : "opDiv",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 894}
]
}
,
{
"name" : "opMod(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 901,
"members" : [
{
"name" : "opMod",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 901}
]
}
,
{
"name" : "opAnd(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 908,
"members" : [
{
"name" : "opAnd",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 908}
]
}
,
{
"name" : "opOr(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 910,
"members" : [
{
"name" : "opOr",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 910}
]
}
,
{
"name" : "opXor(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 912,
"members" : [
{
"name" : "opXor",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 912}
]
}
,
{
"name" : "opShl(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 914,
"members" : [
{
"name" : "opShl",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 914}
]
}
,
{
"name" : "opShr(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 921,
"members" : [
{
"name" : "opShr",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 921}
]
}
,
{
"name" : "opUShr(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 928,
"members" : [
{
"name" : "opUShr",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 928}
]
}
,
{
"name" : "opCat(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 935,
"members" : [
{
"name" : "opCat",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 935}
]
}
,
{
"name" : "opAddAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 950,
"members" : [
{
"name" : "opAddAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 950}
]
}
,
{
"name" : "opSubAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 952,
"members" : [
{
"name" : "opSubAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 952}
]
}
,
{
"name" : "opMulAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 954,
"members" : [
{
"name" : "opMulAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 954}
]
}
,
{
"name" : "opDivAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 956,
"members" : [
{
"name" : "opDivAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 956}
]
}
,
{
"name" : "opModAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 958,
"members" : [
{
"name" : "opModAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 958}
]
}
,
{
"name" : "opAndAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 960,
"members" : [
{
"name" : "opAndAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 960}
]
}
,
{
"name" : "opOrAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 962,
"members" : [
{
"name" : "opOrAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 962}
]
}
,
{
"name" : "opXorAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 964,
"members" : [
{
"name" : "opXorAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 964}
]
}
,
{
"name" : "opShlAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 966,
"members" : [
{
"name" : "opShlAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 966}
]
}
,
{
"name" : "opShrAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 968,
"members" : [
{
"name" : "opShrAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 968}
]
}
,
{
"name" : "opUShrAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 970,
"members" : [
{
"name" : "opUShrAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 970}
]
}
,
{
"name" : "opCatAssign(T)",
"kind" : "template",
"protection" : "public",
"comment" : "ditto\n",
"line" : 972,
"members" : [
{
"name" : "opCatAssign",
"kind" : "function",
"type" : "VariantN(T rhs)",
"comment" : "ditto\n",
"line" : 972}
]
}
,
{
"name" : "opIndex(K)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Array and associative array operations. If a $(D_PARAM\n VariantN) contains an (associative) array, it can be indexed\n into. Otherwise, an exception is thrown.\n\n Example:\n ----\n auto a = Variant(new int[10]);\n a[5] = 42;\n assert(a[5] == 42);\n int[int] hash = [ 42:24 ];\n a = hash;\n assert(a[42] == 24);\n ----\n\n Caveat:\n\n Due to limitations in current language, read-modify-write\n operations $(D_PARAM op=) will not work properly:\n\n ----\n Variant a = new int[10];\n a[5] = 42;\n a[5] += 8;\n assert(a[5] == 50); \/\/ fails, a[5] is still 42\n ----\n     \n",
"line" : 1006,
"members" : [
{
"name" : "opIndex",
"kind" : "function",
"type" : "VariantN(K i)",
"comment" : "\n Array and associative array operations. If a $(D_PARAM\n VariantN) contains an (associative) array, it can be indexed\n into. Otherwise, an exception is thrown.\n\n Example:\n ----\n auto a = Variant(new int[10]);\n a[5] = 42;\n assert(a[5] == 42);\n int[int] hash = [ 42:24 ];\n a = hash;\n assert(a[42] == 24);\n ----\n\n Caveat:\n\n Due to limitations in current language, read-modify-write\n operations $(D_PARAM op=) will not work properly:\n\n ----\n Variant a = new int[10];\n a[5] = 42;\n a[5] += 8;\n assert(a[5] == 50); \/\/ fails, a[5] is still 42\n ----\n     \n",
"line" : 1006}
]
}
,
{
"name" : "opIndexAssign(T,N)",
"kind" : "template",
"protection" : "public",
"comment" : " ditto\n",
"line" : 1023,
"members" : [
{
"name" : "opIndexAssign",
"kind" : "function",
"type" : "VariantN(T value, N i)",
"comment" : " ditto\n",
"line" : 1023}
]
}
,
{
"name" : "length",
"kind" : "function",
"type" : "size_t()",
"comment" : " If the $(D_PARAM VariantN) contains an (associative) array,\n returns the length of that array. Otherwise, throws an\n exception.\n     \n",
"line" : 1034}
,
{
"name" : "opApply(Delegate) if (is(Delegate == delegate))",
"kind" : "template",
"protection" : "public",
"comment" : "\n       If the $(D VariantN) contains an array, applies $(D dg) to each\n       element of the array in turn. Otherwise, throws an exception.\n     \n",
"line" : 1043,
"members" : [
{
"name" : "opApply",
"kind" : "function",
"type" : "int(scope Delegate dg)",
"comment" : "\n       If the $(D VariantN) contains an array, applies $(D dg) to each\n       element of the array in turn. Otherwise, throws an exception.\n     \n",
"line" : 1043}
]
}
]
}
]
}
,
{
"name" : "Algebraic(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Algebraic data type restricted to a closed set of possible\n types. It's an alias for a $(D_PARAM VariantN) with an\n appropriately-constructed maximum size. $(D_PARAM Algebraic) is\n useful when it is desirable to restrict what a discriminated type\n could hold to the end of defining simpler and more efficient\n manipulation.\n\n Future additions to $(D_PARAM Algebraic) will allow compile-time\n checking that all possible types are handled by user code,\n eliminating a large class of errors.\n\n Bugs:\n\n Currently, $(D_PARAM Algebraic) does not allow recursive data\n types. They will be allowed in a future iteration of the\n implementation.\n\n Example:\n ----\n auto v = Algebraic!(int, double, string)(5);\n assert(v.peek!(int));\n v = 3.14;\n assert(v.peek!(double));\n \/\/ auto x = v.peek!(long); \/\/ won't compile, type long not allowed\n \/\/ v = '1'; \/\/ won't compile, type char not allowed\n ----\n \n",
"line" : 1125,
"members" : [
{
"name" : "Algebraic",
"kind" : "alias",
"type" : "VariantN!(maxSize!(T),T)",
"line" : 1127}
]
}
,
{
"name" : "Variant",
"kind" : "alias",
"protection" : "public",
"type" : "VariantN!(32LU)",
"comment" : "\n$(D_PARAM Variant) is an alias for $(D_PARAM VariantN) instantiated\nwith the largest of $(D_PARAM creal), $(D_PARAM char[]), and $(D_PARAM\nvoid delegate()). This ensures that $(D_PARAM Variant) is large enough\nto hold all of D's predefined types, including all numeric types,\npointers, delegates, and class references.  You may want to use\n$(D_PARAM VariantN) directly with a different maximum size either for\nstoring larger types, or for saving memory.\n \n",
"line" : 1140}
,
{
"name" : "variantArray(T...)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Returns an array of variants constructed from $(D_PARAM args).\n Example:\n ----\n auto a = variantArray(1, 3.14, \"Hi!\");\n assert(a[1] == 3.14);\n auto b = Variant(a); \/\/ variant array as variant\n assert(b[1] == 3.14);\n ----\n\n Code that needs functionality similar to the $(D_PARAM boxArray)\n function in the $(D_PARAM std.boxer) module can achieve it like this:\n\n ----\n \/\/ old\n Box[] fun(...)\n {\n     ...\n     return boxArray(_arguments, _argptr);\n }\n \/\/ new\n Variant[] fun(T...)(T args)\n {\n     ...\n     return variantArray(args);\n }\n ----\n\n This is by design. During construction the $(D_PARAM Variant) needs\n static type information about the type being held, so as to store a\n pointer to function for fast retrieval.\n \n",
"line" : 1175,
"members" : [
{
"name" : "variantArray",
"kind" : "function",
"type" : "Variant[](T args)",
"comment" : "\n Returns an array of variants constructed from $(D_PARAM args).\n Example:\n ----\n auto a = variantArray(1, 3.14, \"Hi!\");\n assert(a[1] == 3.14);\n auto b = Variant(a); \/\/ variant array as variant\n assert(b[1] == 3.14);\n ----\n\n Code that needs functionality similar to the $(D_PARAM boxArray)\n function in the $(D_PARAM std.boxer) module can achieve it like this:\n\n ----\n \/\/ old\n Box[] fun(...)\n {\n     ...\n     return boxArray(_arguments, _argptr);\n }\n \/\/ new\n Variant[] fun(T...)(T args)\n {\n     ...\n     return variantArray(args);\n }\n ----\n\n This is by design. During construction the $(D_PARAM Variant) needs\n static type information about the type being held, so as to store a\n pointer to function for fast retrieval.\n \n",
"line" : 1175}
]
}
,
{
"name" : "VariantException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown in three cases:\n\n $(OL $(LI An uninitialized Variant is used in any way except\n assignment and $(D_PARAM hasValue);) $(LI A $(D_PARAM get) or\n $(D_PARAM coerce) is attempted with an incompatible target type;)\n $(LI A comparison between $(D_PARAM Variant) objects of\n incompatible types is attempted.))\n\n \n",
"line" : 1197,
"base" : "Exception",
"members" : [
{
"name" : "source",
"kind" : "variable",
"protection" : "public",
"type" : "object.TypeInfo",
"comment" : " The source type in the conversion or comparison\n",
"line" : 1200}
,
{
"name" : "target",
"kind" : "variable",
"protection" : "public",
"type" : "object.TypeInfo",
"comment" : " The target type in the conversion or comparison\n",
"line" : 1202}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "@trusted VariantException(string s)",
"line" : 1203}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "@trusted VariantException(TypeInfo source, TypeInfo target)",
"line" : 1207}
]
}
]
}
,
{
"name" : "std.xml",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/xml.d",
"comment" : "\n$(RED Warning: This module is considered out-dated and not up to Phobos'\n      current standards. It will remain until we have a suitable replacement,\n      but be aware that it will not remain long term.)\n\nClasses and functions for creating and parsing XML\n\nThe basic architecture of this module is that there are standalone functions,\nclasses for constructing an XML document from scratch (Tag, Element and\nDocument), and also classes for parsing a pre-existing XML file (ElementParser\nand DocumentParser). The parsing classes <i>may<\/i> be used to build a\nDocument, but that is not their primary purpose. The handling capabilities of\nDocumentParser and ElementParser are sufficiently customizable that you can\nmake them do pretty much whatever you want.\n\nExample: This example creates a DOM (Document Object Model) tree\n    from an XML file.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\nimport std.file;\n\n\/\/ books.xml is used in various samples throughout the Microsoft XML Core\n\/\/ Services (MSXML) SDK.\n\/\/\n\/\/ See http:\/\/msdn2.microsoft.com\/en-us\/library\/ms762271(VS.85).aspx\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    \/\/ Check for well-formedness\n    check(s);\n\n    \/\/ Make a DOM tree\n    auto doc = new Document(s);\n\n    \/\/ Plain-print it\n    writeln(doc);\n}\n------------------------------------------------------------------------------\n\nExample: This example does much the same thing, except that the file is\n    deconstructed and reconstructed by hand. This is more work, but the\n    techniques involved offer vastly more power.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\n\nstruct Book\n{\n    string id;\n    string author;\n    string title;\n    string genre;\n    string price;\n    string pubDate;\n    string description;\n}\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    \/\/ Check for well-formedness\n    check(s);\n\n    \/\/ Take it apart\n    Book[] books;\n\n    auto xml = new DocumentParser(s);\n    xml.onStartTag[\"book\"] = (ElementParser xml)\n    {\n        Book book;\n        book.id = xml.tag.attr[\"id\"];\n\n        xml.onEndTag[\"author\"]       = (in Element e) { book.author      = e.text(); };\n        xml.onEndTag[\"title\"]        = (in Element e) { book.title       = e.text(); };\n        xml.onEndTag[\"genre\"]        = (in Element e) { book.genre       = e.text(); };\n        xml.onEndTag[\"price\"]        = (in Element e) { book.price       = e.text(); };\n        xml.onEndTag[\"publish-date\"] = (in Element e) { book.pubDate     = e.text(); };\n        xml.onEndTag[\"description\"]  = (in Element e) { book.description = e.text(); };\n\n        xml.parse();\n\n        books ~= book;\n    };\n    xml.parse();\n\n    \/\/ Put it back together again;\n    auto doc = new Document(new Tag(\"catalog\"));\n    foreach(book;books)\n    {\n        auto element = new Element(\"book\");\n        element.tag.attr[\"id\"] = book.id;\n\n        element ~= new Element(\"author\",      book.author);\n        element ~= new Element(\"title\",       book.title);\n        element ~= new Element(\"genre\",       book.genre);\n        element ~= new Element(\"price\",       book.price);\n        element ~= new Element(\"publish-date\",book.pubDate);\n        element ~= new Element(\"description\", book.description);\n\n        doc ~= element;\n    }\n\n    \/\/ Pretty-print it\n    writefln(join(doc.pretty(3),\"\\n\"));\n}\n-------------------------------------------------------------------------------\nMacros:\n    WIKI=Phobos\/StdXml\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std\/_xml.d)\n",
"members" : [
{
"name" : "cdata",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 137}
,
{
"name" : "isChar",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is a character according to the XML standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 147}
,
{
"name" : "isSpace",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is whitespace according to the XML standard\n\n Only the following characters are considered whitespace in XML - space, tab,\n carriage return and linefeed\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 214}
,
{
"name" : "isDigit",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is a digit according to the XML standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 227}
,
{
"name" : "isLetter",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is a letter according to the XML standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 252}
,
{
"name" : "isIdeographic",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is an ideographic character according to the\n XML standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 266}
,
{
"name" : "isBaseChar",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is a base character according to the XML\n standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 301}
,
{
"name" : "isCombiningChar",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is a combining character according to the\n XML standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 315}
,
{
"name" : "isExtender",
"kind" : "function",
"protection" : "public",
"type" : "bool(dchar c)",
"comment" : "\n Returns true if the character is an extender according to the XML standard\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
"line" : 328}
,
{
"name" : "encode(S)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Encodes a string by replacing all characters which need to be escaped with\n appropriate predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n If the string is not modified, the original will be returned.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be encoded\n\n Returns: The encoded string\n\n Examples:\n --------------\n writefln(encode(\"a > b\")); \/\/ writes \"a &gt; b\"\n --------------\n \n",
"line" : 357,
"members" : [
{
"name" : "encode",
"kind" : "function",
"type" : "S(S s)",
"comment" : "\n Encodes a string by replacing all characters which need to be escaped with\n appropriate predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n If the string is not modified, the original will be returned.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be encoded\n\n Returns: The encoded string\n\n Examples:\n --------------\n writefln(encode(\"a > b\")); \/\/ writes \"a &gt; b\"\n --------------\n \n",
"line" : 357}
]
}
,
{
"name" : "DecodeMode",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Mode to use for decoding.\n\n $(DDOC_ENUM_MEMBERS NONE) Do not decode\n $(DDOC_ENUM_MEMBERS LOOSE) Decode, but ignore errors\n $(DDOC_ENUM_MEMBERS STRICT) Decode, and throw exception on error\n \n",
"line" : 403,
"base" : "int",
"members" : [
{
"name" : "NONE",
"kind" : "enum member",
"protection" : "public",
"line" : 404}
,
{
"name" : "LOOSE",
"kind" : "enum member",
"protection" : "public",
"line" : 404}
,
{
"name" : "STRICT",
"kind" : "enum member",
"protection" : "public",
"line" : 404}
]
}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "string(string s, DecodeMode mode = cast(DecodeMode)1)",
"comment" : "\n Decodes a string by unescaping all predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n This function decodes the entities &amp;amp;, &amp;quot;, &amp;apos;,\n &amp;lt; and &amp;gt,\n as well as decimal and hexadecimal entities such as &amp;#x20AC;\n\n If the string does not contain an ampersand, the original will be returned.\n\n Note that the \"mode\" parameter can be one of DecodeMode.NONE (do not\n decode), DecodeMode.LOOSE (decode, but ignore errors), or DecodeMode.STRICT\n (decode, and throw a DecodeException in the event of an error).\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be decoded\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if mode == DecodeMode.STRICT and decode fails\n\n Returns: The decoded string\n\n Examples:\n --------------\n writefln(decode(\"a &gt; b\")); \/\/ writes \"a > b\"\n --------------\n \n",
"line" : 441}
,
{
"name" : "Document",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing an XML document.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n \n",
"line" : 534,
"base" : "Element",
"members" : [
{
"name" : "prolog",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n Contains all text which occurs before the root element.\n Defaults to &lt;?xml version=\"1.0\"?&gt;\n     \n",
"line" : 540}
,
{
"name" : "epilog",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n Contains all text which occurs after the root element.\n Defaults to the empty string\n     \n",
"line" : 545}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Document(string s)",
"comment" : "\n Constructs a Document by parsing XML text.\n\n This function creates a complete DOM (Document Object Model) tree.\n\n The input to this function MUST be valid XML.\n This is enforced by DocumentParser's in contract.\n\n Params:\n      s = the complete XML text.\n     \n",
"line" : 558}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Document(const(Tag) tag)",
"comment" : "\n Constructs a Document from a Tag.\n\n Params:\n      tag = the start tag of the document.\n     \n",
"line" : 580}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const bool(Object o)",
"comment" : "\n Compares two Documents for equality\n\n Examples:\n --------------\n Document d1,d2;\n if (d1 == d2) { }\n --------------\n         \n",
"line" : 596}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const int(Object o)",
"comment" : "\n Compares two Documents\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n\n Examples:\n --------------\n Document d1,d2;\n if (d1 < d2) { }\n --------------\n         \n",
"line" : 618}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @trusted ulong()",
"comment" : "\n Returns the hash of a Document\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n         \n",
"line" : 637}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns the string representation of a Document. (That is, the\n complete XML of a document).\n         \n",
"line" : 646}
]
}
,
{
"name" : "Element",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing an XML element.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n \n",
"line" : 658,
"base" : "Item",
"members" : [
{
"name" : "tag",
"kind" : "variable",
"protection" : "public",
"type" : "std.xml.Tag",
"comment" : " The start tag of the element\n",
"line" : 660}
,
{
"name" : "items",
"kind" : "variable",
"protection" : "public",
"type" : "Item[]",
"comment" : " The element's items\n",
"line" : 661}
,
{
"name" : "texts",
"kind" : "variable",
"protection" : "public",
"type" : "Text[]",
"comment" : " The element's text items\n",
"line" : 662}
,
{
"name" : "cdatas",
"kind" : "variable",
"protection" : "public",
"type" : "CData[]",
"comment" : " The element's CData items\n",
"line" : 663}
,
{
"name" : "comments",
"kind" : "variable",
"protection" : "public",
"type" : "Comment[]",
"comment" : " The element's comments\n",
"line" : 664}
,
{
"name" : "pis",
"kind" : "variable",
"protection" : "public",
"type" : "ProcessingInstruction[]",
"comment" : " The element's processing instructions\n",
"line" : 665}
,
{
"name" : "elements",
"kind" : "variable",
"protection" : "public",
"type" : "Element[]",
"comment" : " The element's child elements\n",
"line" : 666}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Element(string name, string interior = null)",
"comment" : "\n Constructs an Element given a name and a string to be used as a Text\n interior.\n\n Params:\n      name = the name of the element.\n      interior = (optional) the string interior.\n\n Examples:\n -------------------------------------------------------\n auto element = new Element(\"title\",\"Serenity\")\n     \/\/ constructs the element <title>Serenity<\/title>\n -------------------------------------------------------\n     \n",
"line" : 682}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Element(const(Tag) tag_)",
"comment" : "\n Constructs an Element from a Tag.\n\n Params:\n      tag = the start or empty tag of the element.\n     \n",
"line" : 694}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(Text item)",
"comment" : "\n Append a text item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new Text(\"hello\");\n --------------\n     \n",
"line" : 714}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(CData item)",
"comment" : "\n Append a CData item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new CData(\"hello\");\n --------------\n     \n",
"line" : 732}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(Comment item)",
"comment" : "\n Append a comment to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new Comment(\"hello\");\n --------------\n     \n",
"line" : 750}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(ProcessingInstruction item)",
"comment" : "\n Append a processing instruction to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new ProcessingInstruction(\"hello\");\n --------------\n     \n",
"line" : 768}
,
{
"name" : "opCatAssign",
"kind" : "function",
"protection" : "public",
"type" : "void(Element item)",
"comment" : "\n Append a complete element to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n Element other = new Element(\"br\");\n element ~= other;\n    \/\/ appends element representing <br \/>\n --------------\n     \n",
"line" : 788}
,
{
"name" : "appendItem",
"kind" : "function",
"protection" : "private",
"type" : "void(Item item)",
"line" : 794}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "private",
"type" : "void(ElementParser xml)",
"line" : 801}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : "\n Compares two Elements for equality\n\n Examples:\n --------------\n Element e1,e2;\n if (e1 == e2) { }\n --------------\n     \n",
"line" : 827}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : "\n Compares two Elements\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n\n Examples:\n --------------\n Element e1,e2;\n if (e1 < e2) { }\n --------------\n     \n",
"line" : 851}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of an Element\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n     \n",
"line" : 870}
,
{
"name" : "text",
"kind" : "function",
"protection" : "public",
"type" : "const string(DecodeMode mode = cast(DecodeMode)1)",
"comment" : "\n Returns the decoded interior of an element.\n\n The element is assumed to containt text <i>only<\/i>. So, for\n example, given XML such as \"&lt;title&gt;Good &amp;amp;\n Bad&lt;\/title&gt;\", will return \"Good &amp; Bad\".\n\n Params:\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if decode fails\n         \n",
"line" : 891}
,
{
"name" : "pretty",
"kind" : "function",
"protection" : "public",
"type" : "const string[](uint indent = cast(uint)2)",
"comment" : "\n Returns an indented string representation of this item\n\n Params:\n      indent = (optional) number of spaces by which to indent this\n          element. Defaults to 2.\n         \n",
"line" : 910}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns the string representation of an Element\n\n Examples:\n --------------\n auto element = new Element(\"br\");\n writefln(element.toString()); \/\/ writes \"<br \/>\"\n --------------\n         \n",
"line" : 946}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"line" : 956}
]
}
,
{
"name" : "TagType",
"kind" : "enum",
"protection" : "public",
"comment" : "\n Tag types.\n\n $(DDOC_ENUM_MEMBERS START) Used for start tags\n $(DDOC_ENUM_MEMBERS END) Used for end tags\n $(DDOC_ENUM_MEMBERS EMPTY) Used for empty tags\n\n \n",
"line" : 968,
"base" : "int",
"members" : [
{
"name" : "START",
"kind" : "enum member",
"protection" : "public",
"line" : 968}
,
{
"name" : "END",
"kind" : "enum member",
"protection" : "public",
"line" : 968}
,
{
"name" : "EMPTY",
"kind" : "enum member",
"protection" : "public",
"line" : 968}
]
}
,
{
"name" : "Tag",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing an XML tag.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n The class invariant guarantees\n <ul>\n <li> that $(B type) is a valid enum TagType value<\/li>\n <li> that $(B name) consists of valid characters<\/li>\n <li> that each attribute name consists of valid characters<\/li>\n <\/ul>\n \n",
"line" : 983,
"base" : "Object",
"members" : [
{
"name" : "type",
"kind" : "variable",
"protection" : "public",
"type" : "TagType",
"comment" : " Type of tag\n",
"line" : 984}
,
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Tag name\n",
"line" : 985}
,
{
"name" : "attr",
"kind" : "variable",
"protection" : "public",
"type" : "string[string]",
"comment" : " Associative array of attributes\n",
"line" : 986}
,
{
"name" : "tagString",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 987}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Tag(string name, TagType type = cast(TagType)0)",
"comment" : "\n Constructs an instance of Tag with a specified name and type\n\n The constructor does not initialize the attributes. To initialize the\n attributes, you access the $(B attr) member variable.\n\n Params:\n      name = the Tag's name\n      type = (optional) the Tag's type. If omitted, defaults to\n          TagType.START.\n\n Examples:\n --------------\n auto tag = new Tag(\"img\",Tag.EMPTY);\n tag.attr[\"src\"] = \"http:\/\/example.com\/example.jpg\";\n --------------\n     \n",
"line" : 1028}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "Tag(ref string s, bool dummy)",
"line" : 1044}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "const bool(Object o)",
"comment" : "\n Compares two Tags for equality\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n\n Examples:\n --------------\n Tag tag1,tag2\n if (tag1 == tag2) { }\n --------------\n         \n",
"line" : 1094}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "const int(Object o)",
"comment" : "\n Compares two Tags\n\n Examples:\n --------------\n Tag tag1,tag2\n if (tag1 < tag2) { }\n --------------\n         \n",
"line" : 1113}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of a Tag\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n         \n",
"line" : 1129}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns the string representation of a Tag\n\n Examples:\n --------------\n auto tag = new Tag(\"book\",TagType.START);\n writefln(tag.toString()); \/\/ writes \"<book>\"\n --------------\n         \n",
"line" : 1143}
,
{
"name" : "toNonEndString",
"kind" : "function",
"protection" : "private",
"type" : "const string()",
"line" : 1151}
,
{
"name" : "toStartString",
"kind" : "function",
"protection" : "private",
"type" : "const string()",
"line" : 1159}
,
{
"name" : "toEndString",
"kind" : "function",
"protection" : "private",
"type" : "const string()",
"line" : 1161}
,
{
"name" : "toEmptyString",
"kind" : "function",
"protection" : "private",
"type" : "const string()",
"line" : 1163}
,
{
"name" : "isStart",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : "\n Returns true if the Tag is a start tag\n\n Examples:\n --------------\n if (tag.isStart) { }\n --------------\n         \n",
"line" : 1174}
,
{
"name" : "isEnd",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : "\n Returns true if the Tag is an end tag\n\n Examples:\n --------------\n if (tag.isEnd) { }\n --------------\n         \n",
"line" : 1184}
,
{
"name" : "isEmpty",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : "\n Returns true if the Tag is an empty tag\n\n Examples:\n --------------\n if (tag.isEmpty) { }\n --------------\n         \n",
"line" : 1194}
]
}
,
{
"name" : "Comment",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing a comment\n \n",
"line" : 1201,
"base" : "Item",
"members" : [
{
"name" : "content",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 1203}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Comment(string content)",
"comment" : "\n Construct a comment\n\n Params:\n      content = the body of the comment\n\n Throws: CommentException if the comment body is illegal (contains \"--\"\n or exactly equals \"-\")\n\n Examples:\n --------------\n auto item = new Comment(\"This is a comment\");\n    \/\/ constructs <!--This is a comment-->\n --------------\n     \n",
"line" : 1220}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : "\n Compares two comments for equality\n\n Examples:\n --------------\n Comment item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
"line" : 1236}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : "\n Compares two comments\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n\n Examples:\n --------------\n Comment item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
"line" : 1255}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of a Comment\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n     \n",
"line" : 1269}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns a string representation of this comment\n     \n",
"line" : 1274}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Returns false always\n",
"line" : 1276}
]
}
,
{
"name" : "CData",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing a Character Data section\n \n",
"line" : 1282,
"base" : "Item",
"members" : [
{
"name" : "content",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 1284}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CData(string content)",
"comment" : "\n Construct a chraracter data section\n\n Params:\n      content = the body of the character data segment\n\n Throws: CDataException if the segment body is illegal (contains \"]]>\")\n\n Examples:\n --------------\n auto item = new CData(\"<b>hello<\/b>\");\n    \/\/ constructs <![CDATA[<b>hello<\/b>]]>\n --------------\n     \n",
"line" : 1300}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : "\n Compares two CDatas for equality\n\n Examples:\n --------------\n CData item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
"line" : 1315}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : "\n Compares two CDatas\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n\n Examples:\n --------------\n CData item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
"line" : 1334}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of a CData\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n     \n",
"line" : 1348}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns a string representation of this CData section\n     \n",
"line" : 1353}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Returns false always\n",
"line" : 1355}
]
}
,
{
"name" : "Text",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing a text (aka Parsed Character Data) section\n \n",
"line" : 1361,
"base" : "Item",
"members" : [
{
"name" : "content",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 1363}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Text(string content)",
"comment" : "\n Construct a text (aka PCData) section\n\n Params:\n      content = the text. This function encodes the text before\n      insertion, so it is safe to insert any text\n\n Examples:\n --------------\n auto Text = new CData(\"a < b\");\n    \/\/ constructs a &lt; b\n --------------\n     \n",
"line" : 1378}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : "\n Compares two text sections for equality\n\n Examples:\n --------------\n Text item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
"line" : 1392}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : "\n Compares two text sections\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n\n Examples:\n --------------\n Text item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
"line" : 1411}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of a text section\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n     \n",
"line" : 1425}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns a string representation of this Text section\n     \n",
"line" : 1430}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : "\n Returns true if the content is the empty string\n     \n",
"line" : 1435}
]
}
,
{
"name" : "XMLInstruction",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing an XML Instruction section\n \n",
"line" : 1441,
"base" : "Item",
"members" : [
{
"name" : "content",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 1443}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "XMLInstruction(string content)",
"comment" : "\n Construct an XML Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: XIException if the segment body is illegal (contains \">\")\n\n Examples:\n --------------\n auto item = new XMLInstruction(\"ATTLIST\");\n    \/\/ constructs <!ATTLIST>\n --------------\n     \n",
"line" : 1459}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : "\n Compares two XML instructions for equality\n\n Examples:\n --------------\n XMLInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
"line" : 1474}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : "\n Compares two XML instructions\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n\n Examples:\n --------------\n XMLInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
"line" : 1493}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of an XMLInstruction\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n     \n",
"line" : 1507}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns a string representation of this XmlInstruction\n     \n",
"line" : 1512}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Returns false always\n",
"line" : 1514}
]
}
,
{
"name" : "ProcessingInstruction",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class representing a Processing Instruction section\n \n",
"line" : 1520,
"base" : "Item",
"members" : [
{
"name" : "content",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 1522}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ProcessingInstruction(string content)",
"comment" : "\n Construct a Processing Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: PIException if the segment body is illegal (contains \"?>\")\n\n Examples:\n --------------\n auto item = new ProcessingInstruction(\"php\");\n    \/\/ constructs <?php?>\n --------------\n     \n",
"line" : 1538}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : "\n Compares two processing instructions for equality\n\n Examples:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
"line" : 1553}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : "\n Compares two processing instructions\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n\n Examples:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
"line" : 1572}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : "\n Returns the hash of a ProcessingInstruction\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n     \n",
"line" : 1586}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns a string representation of this ProcessingInstruction\n     \n",
"line" : 1591}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Returns false always\n",
"line" : 1593}
]
}
,
{
"name" : "Item",
"kind" : "class",
"protection" : "public",
"comment" : "\n Abstract base class for XML items\n \n",
"line" : 1600,
"base" : "Object",
"members" : [
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object o)",
"comment" : " Compares with another Item of same type for equality\n",
"line" : 1602}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object o)",
"comment" : " Compares with another Item of same type\n",
"line" : 1605}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "const nothrow @safe ulong()",
"comment" : " Returns the hash of this item\n",
"line" : 1608}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : " Returns a string representation of this item\n",
"line" : 1611}
,
{
"name" : "pretty",
"kind" : "function",
"protection" : "public",
"type" : "const string[](uint indent)",
"comment" : "\n Returns an indented string representation of this item\n\n Params:\n      indent = number of spaces by which to indent child elements\n     \n",
"line" : 1619}
,
{
"name" : "isEmptyXML",
"kind" : "function",
"protection" : "public",
"type" : "const @property bool()",
"comment" : " Returns true if the item represents empty XML text\n",
"line" : 1626}
]
}
,
{
"name" : "DocumentParser",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class for parsing an XML Document.\n\n This is a subclass of ElementParser. Most of the useful functions are\n documented there.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Bugs:\n      Currently only supports UTF documents.\n\n      If there is an encoding attribute in the prolog, it is ignored.\n\n \n",
"line" : 1643,
"base" : "ElementParser",
"members" : [
{
"name" : "xmlText",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 1645}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DocumentParser(string xmlText_)",
"comment" : "\n Constructs a DocumentParser.\n\n The input to this function MUST be valid XML.\n This is enforced by the function's in contract.\n\n Params:\n      xmltext = the entire XML document as text\n\n     \n",
"line" : 1657}
]
}
,
{
"name" : "ElementParser",
"kind" : "class",
"protection" : "public",
"comment" : "\n Class for parsing an XML element.\n\n Standards: $(LINK2 http:\/\/www.w3.org\/TR\/1998\/REC-xml-19980210, XML 1.0)\n\n Note that you cannot construct instances of this class directly. You can\n construct a DocumentParser (which is a subclass of ElementParser), but\n otherwise, Instances of ElementParser will be created for you by the\n library, and passed your way via onStartTag handlers.\n\n \n",
"line" : 1693,
"base" : "Object",
"members" : [
{
"name" : "Handler",
"kind" : "alias",
"protection" : "public",
"type" : "void delegate(string)",
"line" : 1694}
,
{
"name" : "ElementHandler",
"kind" : "alias",
"protection" : "public",
"type" : "void delegate(const(Element) element)",
"line" : 1695}
,
{
"name" : "ParserHandler",
"kind" : "alias",
"protection" : "public",
"type" : "void delegate(ElementParser parser)",
"line" : 1696}
,
{
"name" : "tag_",
"kind" : "variable",
"protection" : "private",
"type" : "std.xml.Tag",
"line" : 1700}
,
{
"name" : "elementStart",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 1701}
,
{
"name" : "s",
"kind" : "variable",
"protection" : "private",
"type" : "string*",
"line" : 1702}
,
{
"name" : "commentHandler",
"kind" : "variable",
"protection" : "private",
"type" : "void delegate(string)",
"line" : 1704}
,
{
"name" : "cdataHandler",
"kind" : "variable",
"protection" : "private",
"type" : "void delegate(string)",
"line" : 1705}
,
{
"name" : "xiHandler",
"kind" : "variable",
"protection" : "private",
"type" : "void delegate(string)",
"line" : 1706}
,
{
"name" : "piHandler",
"kind" : "variable",
"protection" : "private",
"type" : "void delegate(string)",
"line" : 1707}
,
{
"name" : "rawTextHandler",
"kind" : "variable",
"protection" : "private",
"type" : "void delegate(string)",
"line" : 1708}
,
{
"name" : "textHandler",
"kind" : "variable",
"protection" : "private",
"type" : "void delegate(string)",
"line" : 1709}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "ElementParser(ElementParser parent)",
"line" : 1712}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "ElementParser(Tag tag, string* t)",
"line" : 1720}
,
{
"name" : "tag",
"kind" : "function",
"protection" : "public",
"type" : "const @property const(Tag)()",
"comment" : "\n The Tag at the start of the element being parsed. You can read this to\n determine the tag's name and attributes.\n     \n",
"line" : 1732}
,
{
"name" : "onStartTag",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(ElementParser parser)[string]",
"comment" : "\n Register a handler which will be called whenever a start tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n start tag.\n\n Examples:\n --------------\n \/\/ Call this function whenever a <podcast> start tag is encountered\n onStartTag[\"podcast\"] = (ElementParser xml)\n {\n     \/\/ Your code here\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n\n \/\/ call myEpisodeStartHandler (defined elsewhere) whenever an <episode>\n \/\/ start tag is encountered\n onStartTag[\"episode\"] = &myEpisodeStartHandler;\n\n \/\/ call delegate dg for all other start tags\n onStartTag[null] = dg;\n --------------\n\n This library will supply your function with a new instance of\n ElementHandler, which may be used to parse inside the element whose\n start tag was just found, or to identify the tag attributes of the\n element, etc.\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;\/br&gt;\n and &lt;br\/&gt;.\n     \n",
"line" : 1768}
,
{
"name" : "onEndTag",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(const(Element) element)[string]",
"comment" : "\n Register a handler which will be called whenever an end tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n end tag.\n\n Examples:\n --------------\n \/\/ Call this function whenever a <\/podcast> end tag is encountered\n onEndTag[\"podcast\"] = (in Element e)\n {\n     \/\/ Your code here\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n\n \/\/ call myEpisodeEndHandler (defined elsewhere) whenever an <\/episode>\n \/\/ end tag is encountered\n onEndTag[\"episode\"] = &myEpisodeEndHandler;\n\n \/\/ call delegate dg for all other end tags\n onEndTag[null] = dg;\n --------------\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;\/br&gt;\n and &lt;br\/&gt;.\n     \n",
"line" : 1799}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "protected",
"type" : "ElementParser()",
"line" : 1801}
,
{
"name" : "onText",
"kind" : "function",
"protection" : "public",
"type" : "@property void(void delegate(string) handler)",
"comment" : "\n Register a handler which will be called whenever text is encountered.\n\n Examples:\n --------------\n \/\/ Call this function whenever text is encountered\n onText = (string s)\n {\n     \/\/ Your code here\n\n     \/\/ The passed parameter s will have been decoded by the time you see\n     \/\/ it, and so may contain any character.\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n --------------\n     \n",
"line" : 1824}
,
{
"name" : "onTextRaw",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string) handler)",
"comment" : "\n Register an alternative handler which will be called whenever text\n is encountered. This differs from onText in that onText will decode\n the text, wheras onTextRaw will not. This allows you to make design\n choices, since onText will be more accurate, but slower, while\n onTextRaw will be faster, but less accurate. Of course, you can\n still call decode() within your handler, if you want, but you'd\n probably want to use onTextRaw only in circumstances where you\n know that decoding is unnecessary.\n\n Examples:\n --------------\n \/\/ Call this function whenever text is encountered\n onText = (string s)\n {\n     \/\/ Your code here\n\n     \/\/ The passed parameter s will NOT have been decoded.\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n --------------\n     \n",
"line" : 1850}
,
{
"name" : "onCData",
"kind" : "function",
"protection" : "public",
"type" : "@property void(void delegate(string) handler)",
"comment" : "\n Register a handler which will be called whenever a character data\n segement is encountered.\n\n Examples:\n --------------\n \/\/ Call this function whenever a CData section is encountered\n onCData = (string s)\n {\n     \/\/ Your code here\n\n     \/\/ The passed parameter s does not include the opening <![CDATA[\n     \/\/ nor closing ]]>\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n --------------\n     \n",
"line" : 1871}
,
{
"name" : "onComment",
"kind" : "function",
"protection" : "public",
"type" : "@property void(void delegate(string) handler)",
"comment" : "\n Register a handler which will be called whenever a comment is\n encountered.\n\n Examples:\n --------------\n \/\/ Call this function whenever a comment is encountered\n onComment = (string s)\n {\n     \/\/ Your code here\n\n     \/\/ The passed parameter s does not include the opening <!-- nor\n     \/\/ closing -->\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n --------------\n     \n",
"line" : 1892}
,
{
"name" : "onPI",
"kind" : "function",
"protection" : "public",
"type" : "@property void(void delegate(string) handler)",
"comment" : "\n Register a handler which will be called whenever a processing\n instruction is encountered.\n\n Examples:\n --------------\n \/\/ Call this function whenever a processing instruction is encountered\n onPI = (string s)\n {\n     \/\/ Your code here\n\n     \/\/ The passed parameter s does not include the opening <? nor\n     \/\/ closing ?>\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n --------------\n     \n",
"line" : 1913}
,
{
"name" : "onXI",
"kind" : "function",
"protection" : "public",
"type" : "@property void(void delegate(string) handler)",
"comment" : "\n Register a handler which will be called whenever an XML instruction is\n encountered.\n\n Examples:\n --------------\n \/\/ Call this function whenever an XML instruction is encountered\n \/\/ (Note: XML instructions may only occur preceeding the root tag of a\n \/\/ document).\n onPI = (string s)\n {\n     \/\/ Your code here\n\n     \/\/ The passed parameter s does not include the opening <! nor\n     \/\/ closing >\n     \/\/\n     \/\/ This is a a closure, so code here may reference\n     \/\/ variables which are outside of this scope\n };\n --------------\n     \n",
"line" : 1936}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Parse an XML element.\n\n Parsing will continue until the end of the current element. Any items\n encountered for which a handler has been registered will invoke that\n handler.\n\n Throws: various kinds of XMLException\n     \n",
"line" : 1947}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"comment" : "\n Returns that part of the element which has already been parsed\n     \n",
"line" : 2073}
]
}
,
{
"name" : "Check(string msg)",
"kind" : "template",
"protection" : "public",
"line" : 2083,
"members" : [
{
"name" : "old",
"kind" : "variable",
"type" : "string",
"line" : 2085}
,
{
"name" : "fail",
"kind" : "function",
"type" : "void()",
"line" : 2087}
,
{
"name" : "fail",
"kind" : "function",
"type" : "void(Err e)",
"line" : 2093}
,
{
"name" : "fail",
"kind" : "function",
"type" : "void(string msg2)",
"line" : 2099}
]
}
,
{
"name" : "checkMisc",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2105}
,
{
"name" : "checkDocument",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2118}
,
{
"name" : "checkChars",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2130}
,
{
"name" : "checkSpace",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2155}
,
{
"name" : "checkName",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s, out string name)",
"line" : 2162}
,
{
"name" : "checkAttValue",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2181}
,
{
"name" : "checkCharData",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2201}
,
{
"name" : "checkComment",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2214}
,
{
"name" : "checkPI",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2225}
,
{
"name" : "checkCDSect",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2237}
,
{
"name" : "checkProlog",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2249}
,
{
"name" : "checkXMLDecl",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2266}
,
{
"name" : "checkVersionInfo",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2282}
,
{
"name" : "checkEq",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2296}
,
{
"name" : "checkVersionNum",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2309}
,
{
"name" : "checkDocTypeDecl",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2317}
,
{
"name" : "checkSDDecl",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2333}
,
{
"name" : "checkElement",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2353}
,
{
"name" : "checkTag",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s, out string type, out string name)",
"line" : 2380}
,
{
"name" : "checkAttribute",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2401}
,
{
"name" : "checkETag",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s, out string name)",
"line" : 2415}
,
{
"name" : "checkContent",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2429}
,
{
"name" : "checkCharRef",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s, out dchar c)",
"line" : 2450}
,
{
"name" : "checkReference",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2499}
,
{
"name" : "checkEntityRef",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2512}
,
{
"name" : "checkEncName",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2526}
,
{
"name" : "checkEncodingDecl",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s)",
"line" : 2535}
,
{
"name" : "checkLiteral",
"kind" : "function",
"protection" : "private",
"type" : "void(string literal, ref string s)",
"line" : 2551}
,
{
"name" : "checkEnd",
"kind" : "function",
"protection" : "private",
"type" : "void(string end, ref string s)",
"line" : 2559}
,
{
"name" : "opt(alias f)",
"kind" : "template",
"protection" : "public",
"line" : 2571,
"members" : [
{
"name" : "opt",
"kind" : "function",
"type" : "void(ref string s)",
"line" : 2571}
]
}
,
{
"name" : "plus(alias f)",
"kind" : "template",
"protection" : "public",
"line" : 2576,
"members" : [
{
"name" : "plus",
"kind" : "function",
"type" : "void(ref string s)",
"line" : 2576}
]
}
,
{
"name" : "star(alias f)",
"kind" : "template",
"protection" : "public",
"line" : 2582,
"members" : [
{
"name" : "star",
"kind" : "function",
"type" : "void(ref string s)",
"line" : 2582}
]
}
,
{
"name" : "quoted(alias f)",
"kind" : "template",
"protection" : "public",
"line" : 2591,
"members" : [
{
"name" : "quoted",
"kind" : "function",
"type" : "void(ref string s)",
"line" : 2591}
]
}
,
{
"name" : "seq(alias f,alias g)",
"kind" : "template",
"protection" : "public",
"line" : 2607,
"members" : [
{
"name" : "seq",
"kind" : "function",
"type" : "void(ref string s)",
"line" : 2607}
]
}
,
{
"name" : "check",
"kind" : "function",
"protection" : "public",
"type" : "void(string s)",
"comment" : "\n Check an entire XML document for well-formedness\n\n Params:\n      s = the document to be checked, passed as a string\n\n Throws: CheckException if the document is not well formed\n\n CheckException's toString() method will yield the complete heirarchy of\n parse failure (the XML equivalent of a stack trace), giving the line and\n column number of every failure at every level.\n \n",
"line" : 2626}
,
{
"name" : "XMLException",
"kind" : "class",
"protection" : "public",
"comment" : " The base class for exceptions thrown by this module \n",
"line" : 2731,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "XMLException(string msg)",
"line" : 2731}
]
}
,
{
"name" : "CommentException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown during Comment constructor\n",
"line" : 2736,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "CommentException(string msg)",
"line" : 2737}
]
}
,
{
"name" : "CDataException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown during CData constructor\n",
"line" : 2740,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "CDataException(string msg)",
"line" : 2741}
]
}
,
{
"name" : "XIException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown during XMLInstruction constructor\n",
"line" : 2744,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "XIException(string msg)",
"line" : 2745}
]
}
,
{
"name" : "PIException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown during ProcessingInstruction constructor\n",
"line" : 2748,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "PIException(string msg)",
"line" : 2749}
]
}
,
{
"name" : "TextException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown during Text constructor\n",
"line" : 2752,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "TextException(string msg)",
"line" : 2753}
]
}
,
{
"name" : "DecodeException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown during decode()\n",
"line" : 2756,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "DecodeException(string msg)",
"line" : 2757}
]
}
,
{
"name" : "InvalidTypeException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown if comparing with wrong type\n",
"line" : 2760,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "InvalidTypeException(string msg)",
"line" : 2761}
]
}
,
{
"name" : "TagException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown when parsing for Tags\n",
"line" : 2764,
"base" : "XMLException",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "TagException(string msg)",
"line" : 2765}
]
}
,
{
"name" : "CheckException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Thrown during check()\n \n",
"line" : 2770,
"base" : "XMLException",
"members" : [
{
"name" : "err",
"kind" : "variable",
"protection" : "public",
"type" : "std.xml.CheckException",
"comment" : " Parent in heirarchy\n",
"line" : 2772}
,
{
"name" : "tail",
"kind" : "variable",
"protection" : "private",
"type" : "string",
"line" : 2773}
,
{
"name" : "msg",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n Name of production rule which failed to parse,\n or specific error message\n     \n",
"line" : 2778}
,
{
"name" : "line",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"comment" : " Line number at which parse failure occurred\n",
"line" : 2779}
,
{
"name" : "column",
"kind" : "variable",
"protection" : "public",
"type" : "ulong",
"comment" : " Column number at which parse failure occurred\n",
"line" : 2780}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "private",
"type" : "CheckException(string tail, string msg, CheckException err = null)",
"line" : 2782}
,
{
"name" : "complete",
"kind" : "function",
"protection" : "private",
"type" : "void(string entire)",
"line" : 2790}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "const string()",
"line" : 2801}
]
}
,
{
"name" : "Err",
"kind" : "alias",
"protection" : "private",
"line" : 2812}
,
{
"name" : "toType(T)",
"kind" : "template",
"protection" : "public",
"line" : 2818,
"members" : [
{
"name" : "toType",
"kind" : "function",
"type" : "T(Object o)",
"line" : 2818}
]
}
,
{
"name" : "chop",
"kind" : "function",
"protection" : "private",
"type" : "string(ref string s, ulong n)",
"line" : 2829}
,
{
"name" : "optc",
"kind" : "function",
"protection" : "private",
"type" : "bool(ref string s, char c)",
"line" : 2837}
,
{
"name" : "reqc",
"kind" : "function",
"protection" : "private",
"type" : "void(ref string s, char c)",
"line" : 2844}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "private",
"type" : "nothrow @trusted ulong(string s, ulong h = cast(ulong)0)",
"line" : 2850}
,
{
"name" : "CharTable",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[])",
"line" : 2857}
,
{
"name" : "BaseCharTable",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[])",
"line" : 2898}
,
{
"name" : "IdeographicTable",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[])",
"line" : 2899}
,
{
"name" : "CombiningCharTable",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[])",
"line" : 2919}
,
{
"name" : "DigitTable",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[])",
"line" : 2923}
,
{
"name" : "ExtenderTable",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(int[])",
"line" : 2926}
,
{
"name" : "lookup",
"kind" : "function",
"protection" : "private",
"type" : "bool(const(int)[] table, int c)",
"line" : 2928}
,
{
"name" : "startOf",
"kind" : "function",
"protection" : "private",
"type" : "string(string s)",
"line" : 2946}
,
{
"name" : "exit",
"kind" : "function",
"protection" : "private",
"type" : "void(string s = null)",
"line" : 2957}
]
}
,
{
"name" : "std.zip",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/zip.d",
"comment" : "\n Read\/write data in the $(LINK2 http:\/\/www.info-_zip.org, zip archive) format.\n Makes use of the etc.c.zlib compression library.\n\n Bugs:\n      $(UL\n      $(LI Multi-disk zips not supported.)\n      $(LI Only Zip version 20 formats are supported.)\n      $(LI Only supports compression modes 0 (no compression) and 8 (deflate).)\n      $(LI Does not support encryption.)\n      $(LI $(BUGZILLA 592))\n      $(LI $(BUGZILLA 1832))\n      $(LI $(BUGZILLA 2137))\n      $(LI $(BUGZILLA 2138))\n      )\n\n Macros:\n      WIKI = Phobos\/StdZip\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_zip.d)\n \n",
"members" : [
{
"name" : "ZipException",
"kind" : "class",
"protection" : "public",
"comment" : " Thrown on error.\n \n",
"line" : 44,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZipException(string msg)",
"line" : 46}
]
}
,
{
"name" : "ArchiveMember",
"kind" : "class",
"protection" : "public",
"comment" : "\n A member of the ZipArchive.\n \n",
"line" : 56,
"base" : "Object",
"members" : [
{
"name" : "madeVersion",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Read Only\n",
"line" : 57}
,
{
"name" : "extractVersion",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Read Only\n",
"line" : 58}
,
{
"name" : "flags",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Read\/Write: normally set to 0\n",
"line" : 59}
,
{
"name" : "compressionMethod",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Read\/Write: 0 for compression, 8 for deflate\n",
"line" : 60}
,
{
"name" : "time",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read\/Write: Last modified time of the member. It's in the DOS date\/time format.\n",
"line" : 61}
,
{
"name" : "crc32",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: cyclic redundancy check (CRC) value\n",
"line" : 62}
,
{
"name" : "compressedSize",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: size of data of member in compressed form.\n",
"line" : 63}
,
{
"name" : "expandedSize",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: size of data of member in expanded form.\n",
"line" : 64}
,
{
"name" : "diskNumber",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Read Only: should be 0.\n",
"line" : 65}
,
{
"name" : "internalAttributes",
"kind" : "variable",
"protection" : "public",
"type" : "ushort",
"comment" : " Read\/Write\n",
"line" : 66}
,
{
"name" : "externalAttributes",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read\/Write\n",
"line" : 67}
,
{
"name" : "offset",
"kind" : "variable",
"protection" : "private",
"type" : "uint",
"line" : 69}
,
{
"name" : "name",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : "\n Read\/Write: Usually the file name of the archive member; it is used to\n index the archive directory for the member. Each member must have a unique\n name[]. Do not change without removing member from the directory first.\n     \n",
"line" : 76}
,
{
"name" : "extra",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[]",
"comment" : " Read\/Write: extra data for this member.\n",
"line" : 78}
,
{
"name" : "comment",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Read\/Write: comment associated with this member.\n",
"line" : 79}
,
{
"name" : "compressedData",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[]",
"comment" : " Read Only: data of member in compressed form.\n",
"line" : 80}
,
{
"name" : "expandedData",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[]",
"comment" : " Read\/Write: data of member in uncompressed form.\n",
"line" : 81}
]
}
,
{
"name" : "ZipArchive",
"kind" : "class",
"protection" : "public",
"comment" : "\n Object representing the entire archive.\n ZipArchives are collections of ArchiveMembers.\n \n",
"line" : 108,
"base" : "Object",
"members" : [
{
"name" : "data",
"kind" : "variable",
"protection" : "public",
"type" : "ubyte[]",
"comment" : " Read Only: array representing the entire contents of the archive.\n",
"line" : 109}
,
{
"name" : "endrecOffset",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"line" : 110}
,
{
"name" : "diskNumber",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: 0 since multi-disk zip archives are not supported.\n",
"line" : 112}
,
{
"name" : "diskStartDir",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: 0 since multi-disk zip archives are not supported.\n",
"line" : 113}
,
{
"name" : "numEntries",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: number of ArchiveMembers in the directory.\n",
"line" : 114}
,
{
"name" : "totalEntries",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " Read Only: same as totalEntries.\n",
"line" : 115}
,
{
"name" : "comment",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"comment" : " Read\/Write: the archive comment. Must be less than 65536 bytes in length.\n",
"line" : 116}
,
{
"name" : "directory",
"kind" : "variable",
"protection" : "public",
"type" : "ArchiveMember[string]",
"comment" : "\n Read Only: array indexed by the name of each member of the archive.\n Example:\n  All the members of the archive can be accessed with a foreach loop:\n --------------------\n ZipArchive archive = new ZipArchive(data);\n foreach (ArchiveMember am; archive.directory)\n {\n     writefln(\"member name is '%s'\", am.name);\n }\n --------------------\n     \n",
"line" : 130}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZipArchive()",
"comment" : " Constructor to use when creating a new archive.\n     \n",
"line" : 148}
,
{
"name" : "addMember",
"kind" : "function",
"protection" : "public",
"type" : "void(ArchiveMember de)",
"comment" : " Add de to the archive.\n     \n",
"line" : 154}
,
{
"name" : "deleteMember",
"kind" : "function",
"protection" : "public",
"type" : "void(ArchiveMember de)",
"comment" : " Delete de from the archive.\n     \n",
"line" : 161}
,
{
"name" : "build",
"kind" : "function",
"protection" : "public",
"type" : "void[]()",
"comment" : "\n Construct an archive out of the current members of the archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, and directory[].\n For each ArchiveMember, fills in properties crc32, compressedSize,\n compressedData[].\n\n Returns: array representing the entire archive.\n     \n",
"line" : 176}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZipArchive(void[] buffer)",
"comment" : "\n Constructor to use when reading an existing archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, comment[], and directory[].\n For each ArchiveMember, fills in\n properties madeVersion, extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, compressedData[], diskNumber,\n internalAttributes, externalAttributes, name[], extra[], comment[].\n Use expand() to get the expanded data for each ArchiveMember.\n\n Params:\n  buffer = the entire contents of the archive.\n     \n",
"line" : 312}
,
{
"name" : "expand",
"kind" : "function",
"protection" : "public",
"type" : "ubyte[](ArchiveMember de)",
"comment" : "\n Decompress the contents of archive member de and return the expanded\n data.\n\n Fills in properties extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, expandedData[], name[], extra[].\n     \n",
"line" : 416}
,
{
"name" : "getUshort",
"kind" : "function",
"protection" : "public",
"type" : "ushort(int i)",
"line" : 473}
,
{
"name" : "getUint",
"kind" : "function",
"protection" : "public",
"type" : "uint(int i)",
"line" : 487}
,
{
"name" : "putUshort",
"kind" : "function",
"protection" : "public",
"type" : "void(int i, ushort us)",
"line" : 499}
,
{
"name" : "putUint",
"kind" : "function",
"protection" : "public",
"type" : "void(int i, uint ui)",
"line" : 512}
]
}
]
}
,
{
"name" : "std.zlib",
"kind" : "module",
"file" : "\/usr\/include\/dmd\/phobos\/std\/zlib.d",
"comment" : "\n Compress\/decompress data using the $(LINK2 http:\/\/www._zlib.net, zlib library).\n\n References:\n  $(LINK2 http:\/\/en.wikipedia.org\/wiki\/Zlib, Wikipedia)\n\n Macros:\n  WIKI = Phobos\/StdZlib\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http:\/\/www.boost.org\/LICENSE_1_0.txt\">Boost License 1.0<\/a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std\/_zlib.d)\n \n",
"members" : [
{
"name" : "Z_NO_FLUSH",
"kind" : "enum member",
"protection" : "public",
"line" : 32}
,
{
"name" : "Z_SYNC_FLUSH",
"kind" : "enum member",
"protection" : "public",
"line" : 33}
,
{
"name" : "Z_FULL_FLUSH",
"kind" : "enum member",
"protection" : "public",
"line" : 34}
,
{
"name" : "Z_FINISH",
"kind" : "enum member",
"protection" : "public",
"line" : 35}
,
{
"name" : "ZlibException",
"kind" : "class",
"protection" : "public",
"comment" : "\n Errors throw a ZlibException.\n \n",
"line" : 42,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZlibException(int errnum)",
"line" : 44}
]
}
,
{
"name" : "adler32",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint adler, const(void)[] buf)",
"comment" : "\n Compute the Adler32 checksum of the data in buf[]. adler is the starting\n value when computing a cumulative checksum.\n \n",
"line" : 68}
,
{
"name" : "crc32",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint crc, const(void)[] buf)",
"comment" : "\n Compute the CRC32 checksum of the data in buf[]. crc is the starting value\n when computing a cumulative checksum.\n \n",
"line" : 91}
,
{
"name" : "compress",
"kind" : "function",
"protection" : "public",
"type" : "const(void)[](const(void)[] srcbuf, int level)",
"comment" : "\n Compresses the data in srcbuf[] using compression _level level.\n The default value\n for level is 6, legal values are 1..9, with 1 being the least compression\n and 9 being the most.\n Returns the compressed data.\n \n",
"line" : 116}
,
{
"name" : "compress",
"kind" : "function",
"protection" : "public",
"type" : "const(void)[](const(void)[] buf)",
"comment" : "\n ditto\n \n",
"line" : 139}
,
{
"name" : "uncompress",
"kind" : "function",
"protection" : "public",
"type" : "void[](void[] srcbuf, ulong destlen = cast(ulong)0u, int winbits = 15)",
"comment" : "\n Decompresses the data in srcbuf[].\n Params: destlen = size of the uncompressed data.\n It need not be accurate, but the decompression will be faster if the exact\n size is supplied.\n Returns: the decompressed data.\n \n",
"line" : 152}
,
{
"name" : "HeaderFormat",
"kind" : "enum",
"protection" : "public",
"comment" : " the header format the compressed stream is wrapped in\n",
"line" : 246,
"base" : "int",
"members" : [
{
"name" : "deflate",
"kind" : "enum member",
"protection" : "public",
"comment" : " a standard zlib header\n",
"line" : 247}
,
{
"name" : "gzip",
"kind" : "enum member",
"protection" : "public",
"comment" : " a gzip file format header\n",
"line" : 248}
,
{
"name" : "determineFromData",
"kind" : "enum member",
"protection" : "public",
"comment" : " used when decompressing. Try to automatically detect the stream format by looking at the data\n",
"line" : 249}
]
}
,
{
"name" : "Compress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Used when the data to be compressed is not all in one buffer.\n \n",
"line" : 257,
"base" : "Object",
"members" : [
{
"name" : "zs",
"kind" : "variable",
"protection" : "private",
"type" : "z_stream",
"line" : 259}
,
{
"name" : "level",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 260}
,
{
"name" : "inited",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 261}
,
{
"name" : "gzip",
"kind" : "variable",
"protection" : "private",
"type" : "immutable(bool)",
"line" : 262}
,
{
"name" : "error",
"kind" : "function",
"protection" : "private",
"type" : "void(int err)",
"line" : 264}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Compress(int level, HeaderFormat header = cast(HeaderFormat)0)",
"comment" : "\n Construct. level is the same as for D.zlib.compress(). header can be used to make a gzip compatible stream.\n     \n",
"line" : 278}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Compress(HeaderFormat header = cast(HeaderFormat)0)",
"comment" : " ditto\n",
"line" : 290}
,
{
"name" : "compress",
"kind" : "function",
"protection" : "public",
"type" : "const(void)[](const(void)[] buf)",
"comment" : "\n Compress the data in buf and return the compressed data.\n The buffers\n returned from successive calls to this should be concatenated together.\n     \n",
"line" : 312}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void[](int mode = 4)",
"comment" : "\n Compress and return any remaining data.\n The returned data should be appended to that returned by compress().\n Params:\n  mode = one of the following:\n          $(DL\n                    $(DT Z_SYNC_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on.)\n                    $(DT Z_FULL_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on,\n                        and the decompressor needs to be restartable at this\n                        point.)\n                    $(DT Z_FINISH)\n                    $(DD (default) Used when finished compressing the data. )\n                )\n     \n",
"line" : 364}
]
}
,
{
"name" : "UnCompress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Used when the data to be decompressed is not all in one buffer.\n \n",
"line" : 421,
"base" : "Object",
"members" : [
{
"name" : "zs",
"kind" : "variable",
"protection" : "private",
"type" : "z_stream",
"line" : 423}
,
{
"name" : "inited",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 424}
,
{
"name" : "done",
"kind" : "variable",
"protection" : "private",
"type" : "int",
"line" : 425}
,
{
"name" : "destbufsize",
"kind" : "variable",
"protection" : "private",
"type" : "ulong",
"line" : 426}
,
{
"name" : "format",
"kind" : "variable",
"protection" : "private",
"type" : "HeaderFormat",
"line" : 428}
,
{
"name" : "error",
"kind" : "function",
"protection" : "private",
"type" : "void(int err)",
"line" : 430}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnCompress(uint destbufsize)",
"comment" : "\n Construct. destbufsize is the same as for D.zlib.uncompress().\n     \n",
"line" : 444}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnCompress(HeaderFormat format = cast(HeaderFormat)2)",
"comment" : " ditto \n",
"line" : 450}
,
{
"name" : "uncompress",
"kind" : "function",
"protection" : "public",
"type" : "const(void)[](const(void)[] buf)",
"comment" : "\n Decompress the data in buf and return the decompressed data.\n The buffers returned from successive calls to this should be concatenated\n together.\n     \n",
"line" : 473}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void[]()",
"comment" : "\n Decompress and return any remaining data.\n The returned data should be appended to that returned by uncompress().\n The UnCompress object cannot be used further.\n     \n",
"line" : 525}
]
}
]
}
]
