[
 {
  "name" : "std.algorithm",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/algorithm.d",
  "comment" : "\n<script type=\"text/javascript\">inhibitQuickIndex = 1</script>\n\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Searching) $(TD $(MYREF balancedParens) $(MYREF\nboyerMooreFinder) $(MYREF canFind) $(MYREF count) $(MYREF countUntil)\n$(MYREF endsWith) $(MYREF commonPrefix) $(MYREF find) $(MYREF\nfindAdjacent) $(MYREF findAmong) $(MYREF findSkip) $(MYREF findSplit)\n$(MYREF findSplitAfter) $(MYREF findSplitBefore) $(MYREF indexOf)\n$(MYREF minCount) $(MYREF minPos) $(MYREF mismatch) $(MYREF skipOver)\n$(MYREF startsWith) $(MYREF until) )\n)\n$(TR $(TDNW Comparison) $(TD $(MYREF cmp) $(MYREF equal) $(MYREF\nlevenshteinDistance) $(MYREF levenshteinDistanceAndPath) $(MYREF max)\n$(MYREF min) $(MYREF mismatch) )\n)\n$(TR $(TDNW Iteration) $(TD $(MYREF filter) $(MYREF filterBidirectional)\n$(MYREF group) $(MYREF joiner) $(MYREF map) $(MYREF reduce) $(MYREF\nsplitter) $(MYREF uniq) )\n)\n$(TR $(TDNW Sorting) $(TD $(MYREF completeSort) $(MYREF isPartitioned)\n$(MYREF isSorted) $(MYREF makeIndex) $(MYREF partialSort) $(MYREF\npartition) $(MYREF partition3) $(MYREF schwartzSort) $(MYREF sort)\n$(MYREF topN) $(MYREF topNCopy) $(MYREF nextPermutation)\n$(MYREF nextEvenPermutation) )\n)\n$(TR $(TDNW Set&nbsp;operations) $(TD $(MYREF cartesianProduct) $(MYREF\nlargestPartialIntersection) $(MYREF largestPartialIntersectionWeighted)\n$(MYREF nWayUnion) $(MYREF setDifference) $(MYREF setIntersection) $(MYREF\nsetSymmetricDifference) $(MYREF setUnion) )\n)\n$(TR $(TDNW Mutation) $(TD $(MYREF bringToFront) $(MYREF copy) $(MYREF\nfill) $(MYREF initializeAll) $(MYREF move) $(MYREF moveAll) $(MYREF\nmoveSome) $(MYREF remove) $(MYREF reverse) $(MYREF swap) $(MYREF\nswapRanges) $(MYREF uninitializedFill) ))\n)\n\nImplements algorithms oriented mainly towards processing of\nsequences. Some functions are semantic equivalents or supersets of\nthose found in the $(D $(LESS)_algorithm$(GREATER)) header in $(WEB\nsgi.com/tech/stl/, Alexander Stepanov's Standard Template Library) for\nC++.\n\nMany functions in this module are parameterized with a function or a\n$(GLOSSARY predicate). The predicate may be passed either as a\nfunction name, a delegate name, a $(GLOSSARY functor) name, or a\ncompile-time string. The string may consist of $(B any) legal D\nexpression that uses the symbol $(D a) (for unary functions) or the\nsymbols $(D a) and $(D b) (for binary functions). These names will NOT\ninterfere with other homonym symbols in user code because they are\nevaluated in a different context. The default for all binary\ncomparison predicates is $(D \"a == b\") for unordered operations and\n$(D \"a < b\") for ordered operations.\n\nExample:\n\n----\nint[] a = ...;\nstatic bool greater(int a, int b)\n{\n    return a > b;\n}\nsort!(greater)(a);  // predicate as alias\nsort!(\"a > b\")(a);  // predicate as string\n                    // (no ambiguity with array name)\nsort(a);            // no predicate, \"a < b\" is implicit\n----\n\n$(BOOKTABLE Cheat Sheet,\n$(TR $(TH Function Name) $(TH Description)\n)\n$(LEADINGROW Searching\n)\n$(TR $(TDNW $(LREF balancedParens)) $(TD $(D\nbalancedParens(\"((1 + 1) / 2)\")) returns $(D true) because the string\nhas balanced parentheses.)\n)\n$(TR $(TDNW $(LREF boyerMooreFinder)) $(TD $(D find(\"hello\nworld\", boyerMooreFinder(\"or\"))) returns $(D \"orld\") using the $(LUCKY\nBoyer-Moore _algorithm).)\n)\n$(TR $(TDNW $(LREF canFind)) $(TD $(D canFind(\"hello world\",\n\"or\")) returns $(D true).)\n)\n$(TR $(TDNW $(LREF count)) $(TD Counts elements that are equal\nto a specified value or satisfy a predicate. $(D count([1, 2, 1], 1))\nreturns $(D 2) and $(D count!\"a < 0\"([1, -3, 0])) returns $(D 1).)\n)\n$(TR $(TDNW $(LREF countUntil)) $(TD $(D countUntil(a, b))\nreturns the number of steps taken in $(D a) to reach $(D b); for\nexample, $(D countUntil(\"hello!\", \"o\")) returns $(D 4).)\n)\n$(TR $(TDNW $(LREF endsWith)) $(TD $(D endsWith(\"rocks\", \"ks\"))\nreturns $(D true).)\n)\n$(TR $(TD $(LREF find)) $(TD $(D find(\"hello world\",\n\"or\")) returns $(D \"orld\") using linear search. (For binary search refer\nto $(XREF range,sortedRange).))\n)\n$(TR $(TDNW $(LREF findAdjacent)) $(TD $(D findAdjacent([1, 2,\n3, 3, 4])) returns the subrange starting with two equal adjacent\nelements, i.e. $(D [3, 3, 4]).)\n)\n$(TR $(TDNW $(LREF findAmong)) $(TD $(D findAmong(\"abcd\",\n\"qcx\")) returns $(D \"cd\") because $(D 'c') is among $(D \"qcx\").)\n)\n$(TR $(TDNW $(LREF findSkip)) $(TD If $(D a = \"abcde\"), then\n$(D findSkip(a, \"x\")) returns $(D false) and leaves $(D a) unchanged,\nwhereas $(D findSkip(a, 'c')) advances $(D a) to $(D \"cde\") and\nreturns $(D true).)\n)\n$(TR $(TDNW $(LREF findSplit)) $(TD $(D findSplit(\"abcdefg\",\n\"de\")) returns the three ranges $(D \"abc\"), $(D \"de\"), and $(D\n\"fg\").)\n)\n$(TR $(TDNW $(LREF findSplitAfter)) $(TD $(D\nfindSplitAfter(\"abcdefg\", \"de\")) returns the two ranges $(D \"abcde\")\nand $(D \"fg\").)\n)\n$(TR $(TDNW $(LREF findSplitBefore)) $(TD $(D\nfindSplitBefore(\"abcdefg\", \"de\")) returns the two ranges $(D \"abc\") and\n$(D \"defg\").)\n)\n$(TR $(TDNW $(LREF minCount)) $(TD $(D minCount([2, 1, 1, 4,\n1])) returns $(D tuple(1, 3)).)\n)\n$(TR $(TDNW $(LREF minPos)) $(TD $(D minPos([2, 3, 1, 3, 4,\n1])) returns the subrange $(D [1, 3, 4, 1]), i.e., positions the range\nat the first occurrence of its minimal element.)\n)\n$(TR $(TDNW $(LREF skipOver)) $(TD Assume $(D a = \"blah\"). Then\n$(D skipOver(a, \"bi\")) leaves $(D a) unchanged and returns $(D false),\nwhereas $(D skipOver(a, \"bl\")) advances $(D a) to refer to $(D \"ah\")\nand returns $(D true).)\n)\n$(TR $(TDNW $(LREF startsWith)) $(TD $(D startsWith(\"hello,\nworld\", \"hello\")) returns $(D true).)\n)\n$(TR $(TDNW $(LREF until)) $(TD Lazily iterates a range\nuntil a specific value is found.)\n)\n$(LEADINGROW Comparison\n)\n$(TR $(TDNW $(LREF cmp)) $(TD $(D cmp(\"abc\", \"abcd\")) is $(D\n-1), $(D cmp(\"abc\", \"aba\")) is $(D 1), and $(D cmp(\"abc\", \"abc\")) is\n$(D 0).)\n)\n$(TR $(TDNW $(LREF equal)) $(TD Compares ranges for\nelement-by-element equality, e.g. $(D equal([1, 2, 3], [1.0, 2.0,\n3.0])) returns $(D true).)\n)\n$(TR $(TDNW $(LREF levenshteinDistance)) $(TD $(D\nlevenshteinDistance(\"kitten\", \"sitting\")) returns $(D 3) by using the\n$(LUCKY Levenshtein distance _algorithm).)\n)\n$(TR $(TDNW $(LREF levenshteinDistanceAndPath)) $(TD $(D\nlevenshteinDistanceAndPath(\"kitten\", \"sitting\")) returns $(D tuple(3,\n\"snnnsni\")) by using the $(LUCKY Levenshtein distance _algorithm).)\n)\n$(TR $(TDNW $(LREF max)) $(TD $(D max(3, 4, 2)) returns $(D\n4).)\n)\n$(TR $(TDNW $(LREF min)) $(TD $(D min(3, 4, 2)) returns $(D\n2).)\n)\n$(TR $(TDNW $(LREF mismatch)) $(TD $(D mismatch(\"oh hi\",\n\"ohayo\")) returns $(D tuple(\" hi\", \"ayo\")).)\n)\n$(LEADINGROW Iteration\n)\n$(TR $(TDNW $(LREF filter)) $(TD $(D filter!\"a > 0\"([1, -1, 2,\n0, -3])) iterates over elements $(D 1), $(D 2), and $(D 0).)\n)\n$(TR $(TDNW $(LREF filterBidirectional)) $(TD Similar to $(D\nfilter), but also provides $(D back) and $(D popBack) at a small\nincrease in cost.)\n)\n$(TR $(TDNW $(LREF group)) $(TD $(D group([5, 2, 2, 3, 3]))\nreturns a range containing the tuples $(D tuple(5, 1)),\n$(D tuple(2, 2)), and $(D tuple(3, 2)).)\n)\n$(TR $(TDNW $(LREF joiner)) $(TD $(D joiner([\"hello\",\n\"world!\"], \";\")) returns a range that iterates over the characters $(D\n\"hello; world!\"). No new string is created - the existing inputs are\niterated.)\n)\n$(TR $(TDNW $(LREF map)) $(TD $(D map!\"2 * a\"([1, 2, 3]))\nlazily returns a range with the numbers $(D 2), $(D 4), $(D 6).)\n)\n$(TR $(TDNW $(LREF reduce)) $(TD $(D reduce!\"a + b\"([1, 2, 3,\n4])) returns $(D 10).)\n)\n$(TR $(TDNW $(LREF splitter)) $(TD Lazily splits a range by a\nseparator.)\n)\n$(TR $(TDNW $(LREF uniq)) $(TD Iterates over the unique elements\nin a range, which is assumed sorted.)\n)\n$(LEADINGROW Sorting\n)\n$(TR $(TDNW $(LREF completeSort)) $(TD If $(D a = [10, 20, 30])\nand $(D b = [40, 6, 15]), then $(D completeSort(a, b)) leaves $(D a =\n[6, 10, 15]) and $(D b = [20, 30, 40]). The range $(D a) must be\nsorted prior to the call, and as a result the combination $(D $(XREF\nrange,chain)(a, b)) is sorted.)\n)\n$(TR $(TDNW $(LREF isPartitioned)) $(TD $(D isPartitioned!\"a <\n0\"([-1, -2, 1, 0, 2])) returns $(D true) because the predicate is $(D\ntrue) for a portion of the range and $(D false) afterwards.)\n)\n$(TR $(TDNW $(LREF isSorted)) $(TD $(D isSorted([1, 1, 2, 3]))\nreturns $(D true).)\n)\n$(TR $(TDNW $(LREF makeIndex)) $(TD Creates a separate index\nfor a range.)\n)\n$(TR $(TDNW $(LREF partialSort)) $(TD If $(D a = [5, 4, 3, 2,\n1]), then $(D partialSort(a, 3)) leaves $(D a[0 .. 3] = [1, 2,\n3]). The other elements of $(D a) are left in an unspecified order.)\n)\n$(TR $(TDNW $(LREF partition)) $(TD Partitions a range\naccording to a predicate.)\n)\n$(TR $(TDNW $(LREF schwartzSort)) $(TD Sorts with the help of\nthe $(LUCKY Schwartzian transform).)\n)\n$(TR $(TDNW $(LREF sort)) $(TD Sorts.)\n)\n$(TR $(TDNW $(LREF topN)) $(TD Separates the top elements in a\nrange.)\n)\n$(TR $(TDNW $(LREF topNCopy)) $(TD Copies out the top elements\nof a range.)\n)\n$(TR $(TDNW $(LREF nextPermutation)) $(TD Computes the next lexicographically\ngreater permutation of a range in-place.)\n)\n$(TR $(TDNW $(LREF nextEvenPermutation)) $(TD Computes the next\nlexicographically greater even permutation of a range in-place.)\n)\n$(LEADINGROW Set operations\n)\n$(TR $(TDNW $(LREF cartesianProduct)) $(TD Computes Cartesian product of two\nranges.)\n)\n$(TR $(TDNW $(LREF largestPartialIntersection)) $(TD Copies out\nthe values that occur most frequently in a range of ranges.)\n)\n$(TR $(TDNW $(LREF largestPartialIntersectionWeighted)) $(TD\nCopies out the values that occur most frequently (multiplied by\nper-value weights) in a range of ranges.)\n)\n$(TR $(TDNW $(LREF nWayUnion)) $(TD Computes the union of a set\nof sets implemented as a range of sorted ranges.)\n)\n$(TR $(TDNW $(LREF setDifference)) $(TD Lazily computes the set\ndifference of two or more sorted ranges.)\n)\n$(TR $(TDNW $(LREF setIntersection)) $(TD Lazily computes the\nintersection of two or more sorted ranges.)\n)\n$(TR $(TDNW $(LREF setSymmetricDifference)) $(TD Lazily\ncomputes the symmetric set difference of two or more sorted ranges.)\n)\n$(TR $(TDNW $(LREF setUnion)) $(TD Lazily computes the set\nunion of two or more sorted ranges.)\n)\n$(LEADINGROW Mutation\n)\n$(TR $(TDNW $(LREF bringToFront)) $(TD If $(D a = [1, 2, 3])\nand $(D b = [4, 5, 6, 7]), $(D bringToFront(a, b)) leaves $(D a = [4,\n5, 6]) and $(D b = [7, 1, 2, 3]).)\n)\n$(TR $(TDNW $(LREF copy)) $(TD Copies a range to another. If\n$(D a = [1, 2, 3]) and $(D b = new int[5]), then $(D copy(a, b))\nleaves $(D b = [1, 2, 3, 0, 0]) and returns $(D b[3 .. $]).)\n)\n$(TR $(TDNW $(LREF fill)) $(TD Fills a range with a pattern,\ne.g., if $(D a = new int[3]), then $(D fill(a, 4)) leaves $(D a = [4,\n4, 4]) and $(D fill(a, [3, 4])) leaves $(D a = [3, 4, 3]).)\n)\n$(TR $(TDNW $(LREF initializeAll)) $(TD If $(D a = [1.2, 3.4]),\nthen $(D initializeAll(a)) leaves $(D a = [double.init,\ndouble.init]).)\n)\n$(TR $(TDNW $(LREF move)) $(TD $(D move(a, b)) moves $(D a)\ninto $(D b). $(D move(a)) reads $(D a) destructively.)\n)\n$(TR $(TDNW $(LREF moveAll)) $(TD Moves all elements from one\nrange to another.)\n)\n$(TR $(TDNW $(LREF moveSome)) $(TD Moves as many elements as\npossible from one range to another.)\n)\n$(TR $(TDNW $(LREF reverse)) $(TD If $(D a = [1, 2, 3]), $(D\nreverse(a)) changes it to $(D [3, 2, 1]).)\n)\n$(TR $(TDNW $(LREF swap)) $(TD Swaps two values.)\n)\n$(TR $(TDNW $(LREF swapRanges)) $(TD Swaps all elements of two\nranges.)\n)\n$(TR $(TDNW $(LREF uninitializedFill)) $(TD Fills a range\n(assumed uninitialized) with a value.)\n)\n)\n\nMacros:\nWIKI = Phobos/StdAlgorithm\nMYREF = <font face='Consolas, \"Bitstream Vera Sans Mono\", \"Andale Mono\", Monaco, \"DejaVu Sans Mono\", \"Lucida Console\", monospace'><a href=\"#$1\">$1</a>&nbsp;</font>\n\nCopyright: Andrei Alexandrescu 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu)\n\nSource: $(PHOBOSSRC std/_algorithm.d)\n \n",
  "members" : [
   {
    "name" : "std.c.string",
    "kind" : "import",
    "line" : 327,
    "protection" : "private"
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 327,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 328,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 328,
    "protection" : "private"
   },
   {
    "name" : "std.container",
    "kind" : "import",
    "line" : 328,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 328,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 328,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 329,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 329,
    "protection" : "private"
   },
   {
    "name" : "std.random",
    "kind" : "import",
    "line" : 329,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 329,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 329,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 330,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 330,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 330,
    "protection" : "private"
   },
   {
    "name" : "std.uni",
    "kind" : "import",
    "line" : 330,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 330,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\n$(D auto map(Range)(Range r) if (isInputRange!(Unqual!Range));)\n\nImplements the homonym function (also known as $(D transform)) present\nin many languages of functional flavor. The call $(D map!(fun)(range))\nreturns a range of which elements are obtained by applying $(D fun(x))\nleft to right for all $(D x) in $(D range). The original ranges are\nnot changed. Evaluation is done lazily.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nauto squares = map!(a => a * a)(chain(arr1, arr2));\nassert(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));\n----\n\nMultiple functions can be passed to $(D map). In that case, the\nelement type of $(D map) is a tuple containing one element for each\nfunction.\n\nExample:\n\n----\nauto arr1 = [ 1, 2, 3, 4 ];\nforeach (e; map!(\"a + a\", \"a * a\")(arr1))\n{\n    writeln(e[0], \" \", e[1]);\n}\n----\n\nYou may alias $(D map) with some function(s) to a symbol and use\nit separately:\n\n----\nalias map!(to!string) stringize;\nassert(equal(stringize([ 1, 2, 3, 4 ]), [ \"1\", \"2\", \"3\", \"4\" ]));\n----\n",
    "line" : 377,
    "name" : "map",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 379,
      "name" : "map",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "map",
        "kind" : "function",
        "line" : 379,
        "storageClass" : [
         "auto"
        ],
        "type" : "(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 391
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 395,
    "name" : "MapResult",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "MapResult",
      "kind" : "struct",
      "line" : 395,
      "members" : [
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 396,
        "type" : "Unqual!(Range)"
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 398,
        "type" : "R"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 413,
        "type" : "(R input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "R"
         }
        ],
        "endline" : 416
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 431,
        "type" : "void()",
        "endline" : 434
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 437,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 439
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL488_11",
    "kind" : "function",
    "line" : 488,
    "endline" : 503
   },
   {
    "name" : "__unittestL503_12",
    "kind" : "function",
    "line" : 503,
    "endline" : 591
   },
   {
    "name" : "__unittestL591_13",
    "kind" : "function",
    "line" : 591,
    "endline" : 686
   },
   {
    "kind" : "template",
    "comment" : "\n$(D auto reduce(Args...)(Args args)\n    if (Args.length > 0 && Args.length <= 2 && isIterable!(Args[$ - 1]));)\n\nImplements the homonym function (also known as $(D accumulate), $(D\ncompress), $(D inject), or $(D foldl)) present in various programming\nlanguages of functional flavor. The call $(D reduce!(fun)(seed,\nrange)) first assigns $(D seed) to an internal variable $(D result),\nalso called the accumulator. Then, for each element $(D x) in $(D\nrange), $(D result = fun(result, x)) gets evaluated. Finally, $(D\nresult) is returned. The one-argument version $(D reduce!(fun)(range))\nworks similarly, but it uses the first element of the range as the\nseed (the range must be non-empty).\n\nMany aggregate range operations turn out to be solved with $(D reduce)\nquickly and easily. The example below illustrates $(D reduce)'s\nremarkable power and flexibility.\n\nExample:\n----\nint[] arr = [ 1, 2, 3, 4, 5 ];\n// Sum all elements\nauto sum = reduce!((a,b) => a + b)(0, arr);\nassert(sum == 15);\n\n// Sum again, using a string predicate with \"a\" and \"b\"\nsum = reduce!\"a + b\"(0, arr);\nassert(sum == 15);\n\n// Compute the maximum of all elements\nauto largest = reduce!(max)(arr);\nassert(largest == 5);\n\n// Max again, but with Uniform Function Call Syntax (UFCS)\nlargest = arr.reduce!(max);\nassert(largest == 5);\n\n// Compute the number of odd elements\nauto odds = reduce!((a,b) => a + (b & 1))(0, arr);\nassert(odds == 3);\n\n// Compute the sum of squares\nauto ssquares = reduce!((a,b) => a + b * b)(0, arr);\nassert(ssquares == 55);\n\n// Chain multiple ranges into seed\nint[] a = [ 3, 4 ];\nint[] b = [ 100 ];\nauto r = reduce!(\"a + b\")(chain(a, b));\nassert(r == 107);\n\n// Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = reduce!(\"a + b\")(chain(a, b, c));\nassert(approxEqual(r1, 112.5));\n\n// To minimize nesting of parentheses, Uniform Function Call Syntax can be used\nauto r2 = chain(a, b, c).reduce!(\"a + b\");\nassert(approxEqual(r2, 112.5));\n----\n\n$(DDOC_SECTION_H Multiple functions:) Sometimes it is very useful to\ncompute multiple aggregates in one pass. One advantage is that the\ncomputation is faster because the looping overhead is shared. That's\nwhy $(D reduce) accepts multiple functions. If two or more functions\nare passed, $(D reduce) returns a $(XREF typecons, Tuple) object with\none member per passed-in function. The number of seeds must be\ncorrespondingly increased.\n\nExample:\n----\ndouble[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];\n// Compute minimum and maximum in one pass\nauto r = reduce!(min, max)(a);\n// The type of r is Tuple!(int, int)\nassert(approxEqual(r[0], 2));  // minimum\nassert(approxEqual(r[1], 11)); // maximum\n\n// Compute sum and sum of squares in one pass\nr = reduce!(\"a + b\", \"a + b * b\")(tuple(0.0, 0.0), a);\nassert(approxEqual(r[0], 35));  // sum\nassert(approxEqual(r[1], 233)); // sum of squares\n// Compute average and standard deviation from the above\nauto avg = r[0] / a.length;\nauto stdev = sqrt(r[1] / a.length - avg * avg);\n----\n \n",
    "line" : 686,
    "name" : "reduce",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 688,
      "name" : "reduce",
      "parameters" : [
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "reduce",
        "kind" : "function",
        "line" : 688,
        "storageClass" : [
         "auto"
        ],
        "type" : "(Args args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "Args"
         }
        ],
        "endline" : 811
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL814_14",
    "kind" : "function",
    "line" : 814,
    "endline" : 879
   },
   {
    "name" : "__unittestL879_15",
    "kind" : "function",
    "line" : 879,
    "endline" : 900
   },
   {
    "kind" : "template",
    "comment" : "\nFills $(D range) with a $(D filler).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4 ];\nfill(a, 5);\nassert(a == [ 5, 5, 5, 5 ]);\n----\n \n",
    "line" : 900,
    "name" : "fill",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Value",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "fill",
      "kind" : "function",
      "comment" : "\nFills $(D range) with a $(D filler).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4 ];\nfill(a, 5);\nassert(a == [ 5, 5, 5, 5 ]);\n----\n \n",
      "line" : 900,
      "type" : "void(Range range, Value filler)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "filler",
        "type" : "Value"
       }
      ],
      "endline" : 920
     }
    ]
   },
   {
    "name" : "__unittestL922_16",
    "kind" : "function",
    "line" : 922,
    "endline" : 947
   },
   {
    "name" : "__unittestL947_17",
    "kind" : "function",
    "line" : 947,
    "endline" : 967
   },
   {
    "name" : "__unittestL967_18",
    "kind" : "function",
    "line" : 967,
    "endline" : 994
   },
   {
    "kind" : "template",
    "comment" : "\nFills $(D range) with a pattern copied from $(D filler). The length of\n$(D range) does not have to be a multiple of the length of $(D\nfiller). If $(D filler) is empty, an exception is thrown.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = [ 8, 9 ];\nfill(a, b);\nassert(a == [ 8, 9, 8, 9, 8 ]);\n----\n \n",
    "line" : 994,
    "name" : "fill",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "fill",
      "kind" : "function",
      "comment" : "\nFills $(D range) with a pattern copied from $(D filler). The length of\n$(D range) does not have to be a multiple of the length of $(D\nfiller). If $(D filler) is empty, an exception is thrown.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nint[] b = [ 8, 9 ];\nfill(a, b);\nassert(a == [ 8, 9, 8, 9, 8 ]);\n----\n \n",
      "line" : 994,
      "type" : "void(Range1 range, Range2 filler)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range1"
       },
       {
        "name" : "filler",
        "type" : "Range2"
       }
      ],
      "endline" : 1059
     }
    ]
   },
   {
    "name" : "__unittestL1061_19",
    "kind" : "function",
    "line" : 1061,
    "endline" : 1106
   },
   {
    "kind" : "template",
    "comment" : "\nFills a range with a value. Assumes that the range does not currently\ncontain meaningful content. This is of interest for structs that\ndefine copy constructors (for all other types, fill and\nuninitializedFill are equivalent).\n\nuninitializedFill will only operate on ranges that expose references to its\nmembers and have assignable elements.\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\nuninitializedFill(s, 42);\nassert(s == [ 42, 42, 42, 42, 42 ]);\n----\n \n",
    "line" : 1106,
    "name" : "uninitializedFill",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Value",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uninitializedFill",
      "kind" : "function",
      "comment" : "\nFills a range with a value. Assumes that the range does not currently\ncontain meaningful content. This is of interest for structs that\ndefine copy constructors (for all other types, fill and\nuninitializedFill are equivalent).\n\nuninitializedFill will only operate on ranges that expose references to its\nmembers and have assignable elements.\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\nuninitializedFill(s, 42);\nassert(s == [ 42, 42, 42, 42, 42 ]);\n----\n \n",
      "line" : 1106,
      "type" : "void(Range range, Value filler)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "filler",
        "type" : "Value"
       }
      ],
      "endline" : 1117
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1120,
    "name" : "uninitializedFill",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Value",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uninitializedFill",
      "kind" : "function",
      "line" : 1120,
      "type" : "void(Range range, Value filler)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "filler",
        "type" : "Value"
       }
      ],
      "endline" : 1125
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nInitializes all elements of a range with their $(D .init)\nvalue. Assumes that the range does not currently contain meaningful\ncontent.\n\ninitializeAll will operate on ranges that expose references to its\nmembers and have assignable elements, as well as on (mutable) strings.\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\ninitializeAll(s);\nassert(s == [ 0, 0, 0, 0, 0 ]);\n----\n \n",
    "line" : 1143,
    "name" : "initializeAll",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "initializeAll",
      "kind" : "function",
      "comment" : "\nInitializes all elements of a range with their $(D .init)\nvalue. Assumes that the range does not currently contain meaningful\ncontent.\n\ninitializeAll will operate on ranges that expose references to its\nmembers and have assignable elements, as well as on (mutable) strings.\n\nExample:\n----\nstruct S { ... }\nS[] s = (cast(S*) malloc(5 * S.sizeof))[0 .. 5];\ninitializeAll(s);\nassert(s == [ 0, 0, 0, 0, 0 ]);\n----\n \n",
      "line" : 1143,
      "type" : "void(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 1166
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1169,
    "name" : "initializeAll",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "initializeAll",
      "kind" : "function",
      "line" : 1169,
      "type" : "void(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 1174
     }
    ]
   },
   {
    "name" : "__unittestL1176_20",
    "kind" : "function",
    "line" : 1176,
    "endline" : 1291
   },
   {
    "kind" : "template",
    "comment" : "\n$(D auto filter(Range)(Range rs) if (isInputRange!(Unqual!Range));)\n\nImplements the homonym function present in various programming\nlanguages of functional flavor. The call $(D filter!(predicate)(range))\nreturns a new range only containing elements $(D x) in $(D range) for\nwhich $(D predicate(x)) is $(D true).\n\nExample:\n----\nint[] arr = [ 1, 2, 3, 4, 5 ];\n\n// Sum all elements\nauto small = filter!(a => a < 3)(arr);\nassert(equal(small, [ 1, 2 ]));\n\n// Sum again, but with Uniform Function Call Syntax (UFCS)\nauto sum = arr.filter!(a => a < 3);\nassert(equal(sum, [ 1, 2 ]));\n\n// In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = chain(a, b).filter!(a => a > 0);\nassert(equal(r, [ 3, 400, 100, 102 ]));\n\n// Mixing convertible types is fair game, too\ndouble[] c = [ 2.5, 3.0 ];\nauto r1 = chain(c, a, b).filter!(a => cast(int) a != a);\nassert(approxEqual(r1, [ 2.5 ]));\n----\n \n",
    "line" : 1291,
    "name" : "filter",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1293,
      "name" : "filter",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "filter",
        "kind" : "function",
        "line" : 1293,
        "storageClass" : [
         "auto"
        ],
        "type" : "(Range rs)",
        "parameters" : [
         {
          "name" : "rs",
          "type" : "Range"
         }
        ],
        "endline" : 1296
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1300,
    "name" : "FilterResult",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "FilterResult",
      "kind" : "struct",
      "line" : 1300,
      "members" : [
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 1301,
        "type" : "Unqual!(Range)"
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 1302,
        "type" : "R"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1304,
        "type" : "(R r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "R"
         }
        ],
        "endline" : 1311
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 1313,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 1313
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 1324,
        "type" : "void()",
        "endline" : 1330
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 1333,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 1335
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1346_21",
    "kind" : "function",
    "line" : 1346,
    "endline" : 1398
   },
   {
    "name" : "__unittestL1398_22",
    "kind" : "function",
    "line" : 1398,
    "endline" : 1416
   },
   {
    "name" : "__unittestL1416_23",
    "kind" : "function",
    "line" : 1416,
    "endline" : 1424
   },
   {
    "name" : "__unittestL1424_24",
    "kind" : "function",
    "line" : 1424,
    "endline" : 1456
   },
   {
    "kind" : "template",
    "comment" : "\n $(D auto filterBidirectional(Range)(Range r) if (isBidirectionalRange!(Unqual!Range));)\n\n Similar to $(D filter), except it defines a bidirectional\n range. There is a speed disadvantage - the constructor spends time\n finding the last element in the range that satisfies the filtering\n condition (in addition to finding the first one). The advantage is\n that the filtered range can be spanned from both directions. Also,\n $(XREF range, retro) can be applied against the filtered range.\n\nExample:\n----\nint[] arr = [ 1, 2, 3, 4, 5 ];\nauto small = filterBidirectional!(\"a < 3\")(arr);\nassert(small.back == 2);\nassert(equal(small, [ 1, 2 ]));\nassert(equal(retro(small), [ 2, 1 ]));\n// In combination with chain() to span multiple ranges\nint[] a = [ 3, -2, 400 ];\nint[] b = [ 100, -101, 102 ];\nauto r = filterBidirectional!(\"a > 0\")(chain(a, b));\nassert(r.back == 102);\n----\n \n",
    "line" : 1456,
    "name" : "filterBidirectional",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1458,
      "name" : "filterBidirectional",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "filterBidirectional",
        "kind" : "function",
        "line" : 1458,
        "storageClass" : [
         "auto"
        ],
        "type" : "(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 1461
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1465,
    "name" : "FilterBidiResult",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "FilterBidiResult",
      "kind" : "struct",
      "line" : 1465,
      "members" : [
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 1466,
        "type" : "Unqual!(Range)"
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 1467,
        "type" : "R"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1469,
        "type" : "(R r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "R"
         }
        ],
        "endline" : 1474
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 1476,
        "type" : "bool()",
        "endline" : 1476
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 1478,
        "type" : "void()",
        "endline" : 1484
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 1487,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 1489
       },
       {
        "name" : "popBack",
        "kind" : "function",
        "line" : 1491,
        "type" : "void()",
        "endline" : 1497
       },
       {
        "name" : "back",
        "kind" : "function",
        "line" : 1500,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 1502
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 1505,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 1507
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1510_25",
    "kind" : "function",
    "line" : 1510,
    "endline" : 1537
   },
   {
    "kind" : "template",
    "comment" : "\nMoves $(D source) into $(D target) via a destructive\ncopy. Specifically: $(UL $(LI If $(D hasAliasing!T) is true (see\n$(XREF traits, hasAliasing)), then the representation of $(D source)\nis bitwise copied into $(D target) and then $(D source = T.init) is\nevaluated.)  $(LI Otherwise, $(D target = source) is evaluated.)) See\nalso $(XREF exception, pointsTo).\n\nPreconditions:\n$(D &source == &target || !pointsTo(source, source))\n",
    "line" : 1537,
    "name" : "move",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "move",
      "kind" : "function",
      "comment" : "\nMoves $(D source) into $(D target) via a destructive\ncopy. Specifically: $(UL $(LI If $(D hasAliasing!T) is true (see\n$(XREF traits, hasAliasing)), then the representation of $(D source)\nis bitwise copied into $(D target) and then $(D source = T.init) is\nevaluated.)  $(LI Otherwise, $(D target = source) is evaluated.)) See\nalso $(XREF exception, pointsTo).\n\nPreconditions:\n$(D &source == &target || !pointsTo(source, source))\n",
      "line" : 1537,
      "type" : "void(ref T source, ref T target)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "target",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1577
     }
    ]
   },
   {
    "name" : "__unittestL1579_26",
    "kind" : "function",
    "line" : 1579,
    "endline" : 1630
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1630,
    "name" : "move",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "move",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1630,
      "type" : "T(ref T source)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1665
     }
    ]
   },
   {
    "name" : "__unittestL1667_27",
    "kind" : "function",
    "line" : 1667,
    "endline" : 1714
   },
   {
    "name" : "__unittestL1714_28",
    "kind" : "function",
    "line" : 1714,
    "endline" : 1720
   },
   {
    "name" : "__unittestL1720_29",
    "kind" : "function",
    "line" : 1720,
    "endline" : 1740
   },
   {
    "name" : "__unittestL1740_30",
    "kind" : "function",
    "line" : 1740,
    "endline" : 1786
   },
   {
    "kind" : "template",
    "comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Returns\nthe leftover portion of $(D tgt). Throws an exeption if there is not\nenough room in $(D tgt) to acommodate all of $(D src).\n\nPreconditions:\n$(D walkLength(src) <= walkLength(tgt))\n \n",
    "line" : 1786,
    "name" : "moveAll",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "moveAll",
      "kind" : "function",
      "comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Returns\nthe leftover portion of $(D tgt). Throws an exeption if there is not\nenough room in $(D tgt) to acommodate all of $(D src).\n\nPreconditions:\n$(D walkLength(src) <= walkLength(tgt))\n \n",
      "line" : 1786,
      "type" : "Range2(Range1 src, Range2 tgt)",
      "parameters" : [
       {
        "name" : "src",
        "type" : "Range1"
       },
       {
        "name" : "tgt",
        "type" : "Range2"
       }
      ],
      "endline" : 1808
     }
    ]
   },
   {
    "name" : "__unittestL1810_31",
    "kind" : "function",
    "line" : 1810,
    "endline" : 1828
   },
   {
    "kind" : "template",
    "comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Stops\nwhen either $(D src) or $(D tgt) have been exhausted. Returns the\nleftover portions of the two ranges.\n \n",
    "line" : 1828,
    "name" : "moveSome",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "moveSome",
      "kind" : "function",
      "comment" : "\nFor each element $(D a) in $(D src) and each element $(D b) in $(D\ntgt) in lockstep in increasing order, calls $(D move(a, b)). Stops\nwhen either $(D src) or $(D tgt) have been exhausted. Returns the\nleftover portions of the two ranges.\n \n",
      "line" : 1828,
      "type" : "Tuple!(Range1, Range2)(Range1 src, Range2 tgt)",
      "parameters" : [
       {
        "name" : "src",
        "type" : "Range1"
       },
       {
        "name" : "tgt",
        "type" : "Range2"
       }
      ],
      "endline" : 1838
     }
    ]
   },
   {
    "name" : "__unittestL1840_32",
    "kind" : "function",
    "line" : 1840,
    "endline" : 1860
   },
   {
    "kind" : "template",
    "comment" : "\nSwaps $(D lhs) and $(D rhs). See also $(XREF exception, pointsTo).\n\nPreconditions:\n\n$(D !pointsTo(lhs, lhs) && !pointsTo(lhs, rhs) && !pointsTo(rhs, lhs)\n&& !pointsTo(rhs, rhs))\n \n",
    "line" : 1860,
    "name" : "swap",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swap",
      "kind" : "function",
      "comment" : "\nSwaps $(D lhs) and $(D rhs). See also $(XREF exception, pointsTo).\n\nPreconditions:\n\n$(D !pointsTo(lhs, lhs) && !pointsTo(lhs, rhs) && !pointsTo(rhs, lhs)\n&& !pointsTo(rhs, rhs))\n \n",
      "line" : 1860,
      "type" : "pure nothrow @trusted void(ref T lhs, ref T rhs)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "rhs",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1898
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1901,
    "name" : "swap",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swap",
      "kind" : "function",
      "line" : 1901,
      "type" : "void(T lhs, T rhs)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "T"
       },
       {
        "name" : "rhs",
        "type" : "T"
       }
      ],
      "endline" : 1904
     }
    ]
   },
   {
    "name" : "__unittestL1906_33",
    "kind" : "function",
    "line" : 1906,
    "endline" : 1931
   },
   {
    "name" : "__unittestL1931_34",
    "kind" : "function",
    "line" : 1931,
    "endline" : 1969
   },
   {
    "name" : "__unittestL1969_35",
    "kind" : "function",
    "line" : 1969,
    "endline" : 1976
   },
   {
    "kind" : "template",
    "line" : 1976,
    "name" : "swapFront",
    "parameters" : [
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swapFront",
      "kind" : "function",
      "line" : 1976,
      "type" : "void(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 1989
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nForwards function arguments with saving ref-ness.\n\nExample:\n---\nint foo(int n) { return 1; }\nint foo(ref int n) { return 2; }\nint bar()(auto ref int x) { return foo(forward!x); }\n\nassert(bar(1) == 1);\nint i;\nassert(bar(i) == 2);\n---\n\n---\nvoid foo(int n, ref string s) { s = null; foreach (i; 0..n) s ~= \"Hello\"; }\n\n// forwards all arguments which are bound to parameter tuple\nvoid bar(Args...)(auto ref Args args) { return foo(forward!args); }\n\n// forwards all arguments with swapping order\nvoid baz(Args...)(auto ref Args args) { return foo(forward!args[$/2..$], forward!args[0..$/2]); }\n\nstring s;\nbar(1, s);\nassert(s == \"Hello\");\nbaz(s, 2);\nassert(s == \"HelloHello\");\n---\n",
    "line" : 2021,
    "name" : "forward",
    "parameters" : [
     {
      "name" : "args",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL2036_36",
    "kind" : "function",
    "line" : 2036,
    "endline" : 2050
   },
   {
    "name" : "__unittestL2050_37",
    "kind" : "function",
    "line" : 2050,
    "endline" : 2065
   },
   {
    "name" : "__unittestL2065_38",
    "kind" : "function",
    "line" : 2065,
    "endline" : 2096
   },
   {
    "name" : "__unittestL2096_40",
    "kind" : "function",
    "line" : 2096,
    "endline" : 2135
   },
   {
    "kind" : "template",
    "comment" : "\nSplits a range using an element as a separator. This can be used with\nany narrow string type or sliceable range type, but is most popular\nwith string types.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range.\n\nIf the empty range is given, the result is a range with one empty\nelement. If a range with one separator is given, the result is a range\nwith two empty elements.\n\nExample:\n---\nassert(equal(splitter(\"hello  world\", ' '), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5] ];\nassert(equal(splitter(a, 0), w));\na = null;\nassert(equal(splitter(a, 0), [ (int[]).init ]));\na = [ 0 ];\nassert(equal(splitter(a, 0), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter(a, 0), [ [], [1] ]));\n----\n",
    "line" : 2135,
    "name" : "splitter",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitter",
      "kind" : "function",
      "comment" : "\nSplits a range using an element as a separator. This can be used with\nany narrow string type or sliceable range type, but is most popular\nwith string types.\n\nTwo adjacent separators are considered to surround an empty element in\nthe split range.\n\nIf the empty range is given, the result is a range with one empty\nelement. If a range with one separator is given, the result is a range\nwith two empty elements.\n\nExample:\n---\nassert(equal(splitter(\"hello  world\", ' '), [ \"hello\", \"\", \"world\" ]));\nint[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];\nint[][] w = [ [1, 2], [], [3], [4, 5] ];\nassert(equal(splitter(a, 0), w));\na = null;\nassert(equal(splitter(a, 0), [ (int[]).init ]));\na = [ 0 ];\nassert(equal(splitter(a, 0), [ (int[]).init, (int[]).init ]));\na = [ 0, 1 ];\nassert(equal(splitter(a, 0), [ [], [1] ]));\n----\n",
      "line" : 2135,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r, Separator s)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "s",
        "type" : "Separator"
       }
      ],
      "endline" : 2276
     }
    ]
   },
   {
    "name" : "__unittestL2278_41",
    "kind" : "function",
    "line" : 2278,
    "endline" : 2338
   },
   {
    "name" : "__unittestL2338_42",
    "kind" : "function",
    "line" : 2338,
    "endline" : 2354
   },
   {
    "kind" : "template",
    "comment" : "\nSplits a range using another range as a separator. This can be used\nwith any narrow string type or sliceable range type, but is most popular\nwith string types.\n \n",
    "line" : 2354,
    "name" : "splitter",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitter",
      "kind" : "function",
      "comment" : "\nSplits a range using another range as a separator. This can be used\nwith any narrow string type or sliceable range type, but is most popular\nwith string types.\n \n",
      "line" : 2354,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r, Separator s)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "s",
        "type" : "Separator"
       }
      ],
      "endline" : 2497
     }
    ]
   },
   {
    "name" : "__unittestL2499_43",
    "kind" : "function",
    "line" : 2499,
    "endline" : 2538
   },
   {
    "name" : "__unittestL2538_44",
    "kind" : "function",
    "line" : 2538,
    "endline" : 2551
   },
   {
    "kind" : "template",
    "line" : 2551,
    "name" : "splitter",
    "parameters" : [
     {
      "name" : "isTerminator",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitter",
      "kind" : "function",
      "line" : 2551,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range input)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range"
       }
      ],
      "endline" : 2555
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2558,
    "name" : "SplitterResult",
    "parameters" : [
     {
      "name" : "isTerminator",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SplitterResult",
      "kind" : "struct",
      "line" : 2558,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 2559,
        "type" : "Range"
       },
       {
        "name" : "_end",
        "kind" : "variable",
        "line" : 2560,
        "type" : "size_t"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 2562,
        "type" : "(Range input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         }
        ],
        "endline" : 2577
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 2591,
        "type" : "Range()",
        "endline" : 2595
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 2597,
        "type" : "void()",
        "endline" : 2630
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2643_45",
    "kind" : "function",
    "line" : 2643,
    "endline" : 2654
   },
   {
    "name" : "__unittestL2654_46",
    "kind" : "function",
    "line" : 2654,
    "endline" : 2691
   },
   {
    "kind" : "template",
    "line" : 2691,
    "name" : "splitter",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitter",
      "kind" : "function",
      "line" : 2691,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range input)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range"
       }
      ],
      "endline" : 2695
     }
    ]
   },
   {
    "name" : "__unittestL2697_47",
    "kind" : "function",
    "line" : 2697,
    "endline" : 2738
   },
   {
    "kind" : "template",
    "comment" : "\nLazily joins a range of ranges with a separator. The separator itself\nis a range. If you do not provide a separator, then the ranges are\njoined directly without anything in between them.\n\nExample:\n----\nassert(equal(joiner([\"\"], \"xyz\"), \"\"));\nassert(equal(joiner([\"\", \"\"], \"xyz\"), \"xyz\"));\nassert(equal(joiner([\"\", \"abc\"], \"xyz\"), \"xyzabc\"));\nassert(equal(joiner([\"abc\", \"\"], \"xyz\"), \"abcxyz\"));\nassert(equal(joiner([\"abc\", \"def\"], \"xyz\"), \"abcxyzdef\"));\nassert(equal(joiner([\"Mary\", \"has\", \"a\", \"little\", \"lamb\"], \"...\"),\n  \"Mary...has...a...little...lamb\"));\nassert(equal(joiner([\"abc\", \"def\"]), \"abcdef\"));\n----\n \n",
    "line" : 2738,
    "name" : "joiner",
    "parameters" : [
     {
      "name" : "RoR",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "joiner",
      "kind" : "function",
      "comment" : "\nLazily joins a range of ranges with a separator. The separator itself\nis a range. If you do not provide a separator, then the ranges are\njoined directly without anything in between them.\n\nExample:\n----\nassert(equal(joiner([\"\"], \"xyz\"), \"\"));\nassert(equal(joiner([\"\", \"\"], \"xyz\"), \"xyz\"));\nassert(equal(joiner([\"\", \"abc\"], \"xyz\"), \"xyzabc\"));\nassert(equal(joiner([\"abc\", \"\"], \"xyz\"), \"abcxyz\"));\nassert(equal(joiner([\"abc\", \"def\"], \"xyz\"), \"abcxyzdef\"));\nassert(equal(joiner([\"Mary\", \"has\", \"a\", \"little\", \"lamb\"], \"...\"),\n  \"Mary...has...a...little...lamb\"));\nassert(equal(joiner([\"abc\", \"def\"]), \"abcdef\"));\n----\n \n",
      "line" : 2738,
      "storageClass" : [
       "auto"
      ],
      "type" : "(RoR r, Separator sep)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "RoR"
       },
       {
        "name" : "sep",
        "type" : "Separator"
       }
      ],
      "endline" : 2871
     }
    ]
   },
   {
    "name" : "__unittestL2873_48",
    "kind" : "function",
    "line" : 2873,
    "endline" : 2889
   },
   {
    "name" : "__unittestL2889_49",
    "kind" : "function",
    "line" : 2889,
    "endline" : 2896
   },
   {
    "name" : "__unittestL2896_50",
    "kind" : "function",
    "line" : 2896,
    "endline" : 2936
   },
   {
    "name" : "__unittestL2936_51",
    "kind" : "function",
    "line" : 2936,
    "endline" : 2981
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 2981,
    "name" : "joiner",
    "parameters" : [
     {
      "name" : "RoR",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "joiner",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 2981,
      "storageClass" : [
       "auto"
      ],
      "type" : "(RoR r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "RoR"
       }
      ],
      "endline" : 3051
     }
    ]
   },
   {
    "name" : "__unittestL3053_52",
    "kind" : "function",
    "line" : 3053,
    "endline" : 3092
   },
   {
    "name" : "__unittestL3092_53",
    "kind" : "function",
    "line" : 3092,
    "endline" : 3134
   },
   {
    "name" : "__unittestL3178_55",
    "kind" : "function",
    "line" : 3178,
    "endline" : 3201
   },
   {
    "kind" : "template",
    "comment" : "\nIterates unique consecutive elements of the given range (functionality\nakin to the $(WEB wikipedia.org/wiki/_Uniq, _uniq) system\nutility). Equivalence of elements is assessed by using the predicate\n$(D pred), by default $(D \"a == b\"). If the given range is\nbidirectional, $(D uniq) also yields a bidirectional range.\n\nExample:\n----\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));\n----\n",
    "line" : 3201,
    "name" : "uniq",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniq",
      "kind" : "function",
      "comment" : "\nIterates unique consecutive elements of the given range (functionality\nakin to the $(WEB wikipedia.org/wiki/_Uniq, _uniq) system\nutility). Equivalence of elements is assessed by using the predicate\n$(D pred), by default $(D \"a == b\"). If the given range is\nbidirectional, $(D uniq) also yields a bidirectional range.\n\nExample:\n----\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(uniq(arr), [ 1, 2, 3, 4, 5 ][]));\n----\n",
      "line" : 3201,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 3205
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3208,
    "name" : "UniqResult",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "UniqResult",
      "kind" : "struct",
      "line" : 3208,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 3209,
        "type" : "Range"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3211,
        "type" : "(Range input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         }
        ],
        "endline" : 3214
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 3217,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 3219
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 3221,
        "type" : "void()",
        "endline" : 3229
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 3231,
        "type" : "ElementType!(Range)()",
        "endline" : 3231
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL3264_56",
    "kind" : "function",
    "line" : 3264,
    "endline" : 3306
   },
   {
    "kind" : "template",
    "comment" : "\nSimilarly to $(D uniq), $(D group) iterates unique consecutive\nelements of the given range. The element type is $(D\nTuple!(ElementType!R, uint)) because it includes the count of\nequivalent elements seen. Equivalence of elements is assessed by using\nthe predicate $(D pred), by default $(D \"a == b\").\n\n$(D Group) is an input range if $(D R) is an input range, and a\nforward range in all other cases.\n\nExample:\n----\nint[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];\nassert(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),\n    tuple(4, 3u), tuple(5, 1u) ][]));\n----\n",
    "line" : 3307,
    "name" : "Group",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Group",
      "kind" : "struct",
      "line" : 3307,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 3308,
        "type" : "R"
       },
       {
        "name" : "_current",
        "kind" : "variable",
        "line" : 3309,
        "type" : "Tuple!(ElementType!(R), uint)"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 3310,
        "type" : "binaryFun!(pred)"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3312,
        "type" : "(R input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "R"
         }
        ],
        "endline" : 3316
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 3318,
        "type" : "void()",
        "endline" : 3334
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 3348,
        "type" : "Tuple!(ElementType!(R), uint)()",
        "endline" : 3352
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3365,
    "name" : "group",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "group",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3365,
      "type" : "Group!(pred, Range)(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 3368
     }
    ]
   },
   {
    "name" : "__unittestL3370_57",
    "kind" : "function",
    "line" : 3370,
    "endline" : 3504
   },
   {
    "kind" : "template",
    "comment" : "\nFinds an individual element in an input range. Elements of $(D\nhaystack) are compared with $(D needle) by using predicate $(D\npred). Performs $(BIGOH walkLength(haystack)) evaluations of $(D\npred). See also $(WEB sgi.com/tech/stl/_find.html, STL's _find).\n\nTo _find the last occurence of $(D needle) in $(D haystack), call $(D\nfind(retro(haystack), needle)). See also $(XREF range, retro).\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The element searched for.\n\nConstraints:\n\n$(D isInputRange!R && is(typeof(binaryFun!pred(haystack.front, needle)\n: bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D binaryFun!pred(haystack.front,\nneedle)) is $(D true) (if no such position exists, returns $(D\nhaystack) after exhaustion).\n\nExample:\n\n----\nassert(find(\"hello, world\", ',') == \", world\");\nassert(find([1, 2, 3, 5], 4) == []);\nassert(find(SList!int(1, 2, 3, 4, 5)[], 4) == SList!int(4, 5)[]);\nassert(find!\"a > b\"([1, 2, 3, 5], 2) == [3, 5]);\n\nauto a = [ 1, 2, 3 ];\nassert(find(a, 5).empty);       // not found\nassert(!find(a, 2).empty);      // found\n\n// Case-insensitive find of a string\nstring[] s = [ \"Hello\", \"world\", \"!\" ];\nassert(!find!(\"toLower(a) == b\")(s, \"hello\").empty);\n----\n \n",
    "line" : 3504,
    "name" : "find",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "comment" : "\nFinds an individual element in an input range. Elements of $(D\nhaystack) are compared with $(D needle) by using predicate $(D\npred). Performs $(BIGOH walkLength(haystack)) evaluations of $(D\npred). See also $(WEB sgi.com/tech/stl/_find.html, STL's _find).\n\nTo _find the last occurence of $(D needle) in $(D haystack), call $(D\nfind(retro(haystack), needle)). See also $(XREF range, retro).\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The element searched for.\n\nConstraints:\n\n$(D isInputRange!R && is(typeof(binaryFun!pred(haystack.front, needle)\n: bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D binaryFun!pred(haystack.front,\nneedle)) is $(D true) (if no such position exists, returns $(D\nhaystack) after exhaustion).\n\nExample:\n\n----\nassert(find(\"hello, world\", ',') == \", world\");\nassert(find([1, 2, 3, 5], 4) == []);\nassert(find(SList!int(1, 2, 3, 4, 5)[], 4) == SList!int(4, 5)[]);\nassert(find!\"a > b\"([1, 2, 3, 5], 2) == [3, 5]);\n\nauto a = [ 1, 2, 3 ];\nassert(find(a, 5).empty);       // not found\nassert(!find(a, 2).empty);      // found\n\n// Case-insensitive find of a string\nstring[] s = [ \"Hello\", \"world\", \"!\" ];\nassert(!find!(\"toLower(a) == b\")(s, \"hello\").empty);\n----\n \n",
      "line" : 3504,
      "type" : "R(R haystack, E needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R"
       },
       {
        "name" : "needle",
        "type" : "E"
       }
      ],
      "endline" : 3513
     }
    ]
   },
   {
    "name" : "__unittestL3515_58",
    "kind" : "function",
    "line" : 3515,
    "endline" : 3555
   },
   {
    "kind" : "template",
    "comment" : "\nFinds a forward range in another. Elements are compared for\nequality. Performs $(BIGOH walkLength(haystack) * walkLength(needle))\ncomparisons in the worst case. Specializations taking advantage of\nbidirectional or random access (where present) may accelerate search\ndepending on the statistics of the two ranges' content.\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The range searched for.\n\nConstraints:\n\n$(D isForwardRange!R1 && isForwardRange!R2 &&\nis(typeof(binaryFun!pred(haystack.front, needle.front) : bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D needle) is a prefix of it (if no\nsuch position exists, returns $(D haystack) advanced to termination).\n\n----\nassert(find(\"hello, world\", \"World\").empty);\nassert(find(\"hello, world\", \"wo\") == \"world\");\nassert(find([1, 2, 3, 4], SList!(2, 3)[]) == [2, 3, 4]);\n----\n \n",
    "line" : 3555,
    "name" : "find",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "comment" : "\nFinds a forward range in another. Elements are compared for\nequality. Performs $(BIGOH walkLength(haystack) * walkLength(needle))\ncomparisons in the worst case. Specializations taking advantage of\nbidirectional or random access (where present) may accelerate search\ndepending on the statistics of the two ranges' content.\n\nParams:\n\nhaystack = The range searched in.\n\nneedle = The range searched for.\n\nConstraints:\n\n$(D isForwardRange!R1 && isForwardRange!R2 &&\nis(typeof(binaryFun!pred(haystack.front, needle.front) : bool)))\n\nReturns:\n\n$(D haystack) advanced such that $(D needle) is a prefix of it (if no\nsuch position exists, returns $(D haystack) advanced to termination).\n\n----\nassert(find(\"hello, world\", \"World\").empty);\nassert(find(\"hello, world\", \"wo\") == \"world\");\nassert(find([1, 2, 3, 4], SList!(2, 3)[]) == [2, 3, 4]);\n----\n \n",
      "line" : 3555,
      "type" : "R1(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 3576
     }
    ]
   },
   {
    "name" : "__unittestL3578_59",
    "kind" : "function",
    "line" : 3578,
    "endline" : 3591
   },
   {
    "kind" : "template",
    "line" : 3591,
    "name" : "find",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "line" : 3591,
      "type" : "R1(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 3636
     }
    ]
   },
   {
    "name" : "__unittestL3638_60",
    "kind" : "function",
    "line" : 3638,
    "endline" : 3663
   },
   {
    "kind" : "template",
    "line" : 3663,
    "name" : "find",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "line" : 3663,
      "type" : "R1(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 3721
     }
    ]
   },
   {
    "name" : "__unittestL3723_61",
    "kind" : "function",
    "line" : 3723,
    "endline" : 3730
   },
   {
    "name" : "__unittestL3730_62",
    "kind" : "function",
    "line" : 3730,
    "endline" : 3744
   },
   {
    "kind" : "template",
    "line" : 3744,
    "name" : "simpleMindedFind",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "simpleMindedFind",
      "kind" : "function",
      "line" : 3744,
      "type" : "R1(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 3810
     }
    ]
   },
   {
    "name" : "__unittestL3812_63",
    "kind" : "function",
    "line" : 3812,
    "endline" : 3895
   },
   {
    "kind" : "template",
    "comment" : "\nFinds two or more $(D needles) into a $(D haystack). The predicate $(D\npred) is used throughout to compare elements. By default, elements are\ncompared for equality.\n\nParams:\n\nhaystack = The target of the search. Must be an $(GLOSSARY input\nrange). If any of $(D needles) is a range with elements comparable to\nelements in $(D haystack), then $(D haystack) must be a $(GLOSSARY\nforward range) such that the search can backtrack.\n\nneedles = One or more items to search for. Each of $(D needles) must\nbe either comparable to one element in $(D haystack), or be itself a\n$(GLOSSARY forward range) with elements comparable with elements in\n$(D haystack).\n\nReturns:\n\nA tuple containing $(D haystack) positioned to match one of the\nneedles and also the 1-based index of the matching element in $(D\nneedles) (0 if none of $(D needles) matched, 1 if $(D needles[0])\nmatched, 2 if $(D needles[1]) matched...). The first needle to be found\nwill be the one that matches. If multiple needles are found at the\nsame spot in the range, then the shortest one is the one which matches\n(if multiple needles of the same length are found at the same spot (e.g\n$(D \"a\") and $(D 'a')), then the left-most of them in the argument list\nmatches).\n\nThe relationship between $(D haystack) and $(D needles) simply means\nthat one can e.g. search for individual $(D int)s or arrays of $(D\nint)s in an array of $(D int)s. In addition, if elements are\nindividually comparable, searches of heterogeneous types are allowed\nas well: a $(D double[]) can be searched for an $(D int) or a $(D\nshort[]), and conversely a $(D long) can be searched for a $(D float)\nor a $(D double[]). This makes for efficient searches without the need\nto coerce one side of the comparison into the other's side type.\n\nExample:\n----\nint[] a = [ 1, 4, 2, 3 ];\nassert(find(a, 4) == [ 4, 2, 3 ]);\nassert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);\nassert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));\n// Mixed types allowed if comparable\nassert(find(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));\n----\n\nThe complexity of the search is $(BIGOH haystack.length *\nmax(needles.length)). (For needles that are individual items, length\nis considered to be 1.) The strategy used in searching several\nsubranges at once maximizes cache usage by moving in $(D haystack) as\nfew times as possible.\n \n",
    "line" : 3895,
    "name" : "find",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "comment" : "\nFinds two or more $(D needles) into a $(D haystack). The predicate $(D\npred) is used throughout to compare elements. By default, elements are\ncompared for equality.\n\nParams:\n\nhaystack = The target of the search. Must be an $(GLOSSARY input\nrange). If any of $(D needles) is a range with elements comparable to\nelements in $(D haystack), then $(D haystack) must be a $(GLOSSARY\nforward range) such that the search can backtrack.\n\nneedles = One or more items to search for. Each of $(D needles) must\nbe either comparable to one element in $(D haystack), or be itself a\n$(GLOSSARY forward range) with elements comparable with elements in\n$(D haystack).\n\nReturns:\n\nA tuple containing $(D haystack) positioned to match one of the\nneedles and also the 1-based index of the matching element in $(D\nneedles) (0 if none of $(D needles) matched, 1 if $(D needles[0])\nmatched, 2 if $(D needles[1]) matched...). The first needle to be found\nwill be the one that matches. If multiple needles are found at the\nsame spot in the range, then the shortest one is the one which matches\n(if multiple needles of the same length are found at the same spot (e.g\n$(D \"a\") and $(D 'a')), then the left-most of them in the argument list\nmatches).\n\nThe relationship between $(D haystack) and $(D needles) simply means\nthat one can e.g. search for individual $(D int)s or arrays of $(D\nint)s in an array of $(D int)s. In addition, if elements are\nindividually comparable, searches of heterogeneous types are allowed\nas well: a $(D double[]) can be searched for an $(D int) or a $(D\nshort[]), and conversely a $(D long) can be searched for a $(D float)\nor a $(D double[]). This makes for efficient searches without the need\nto coerce one side of the comparison into the other's side type.\n\nExample:\n----\nint[] a = [ 1, 4, 2, 3 ];\nassert(find(a, 4) == [ 4, 2, 3 ]);\nassert(find(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);\nassert(find(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));\n// Mixed types allowed if comparable\nassert(find(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));\n----\n\nThe complexity of the search is $(BIGOH haystack.length *\nmax(needles.length)). (For needles that are individual items, length\nis considered to be 1.) The strategy used in searching several\nsubranges at once maximizes cache usage by moving in $(D haystack) as\nfew times as possible.\n \n",
      "line" : 3895,
      "type" : "Tuple!(Range, size_t)(Range haystack, Ranges needles)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "Range"
       },
       {
        "name" : "needles",
        "type" : "Ranges"
       }
      ],
      "endline" : 3907
     }
    ]
   },
   {
    "name" : "__unittestL3909_64",
    "kind" : "function",
    "line" : 3909,
    "endline" : 3921
   },
   {
    "name" : "__unittestL3921_65",
    "kind" : "function",
    "line" : 3921,
    "endline" : 3947
   },
   {
    "name" : "__unittestL3947_66",
    "kind" : "function",
    "line" : 3947,
    "endline" : 3966
   },
   {
    "name" : "__unittestL3966_67",
    "kind" : "function",
    "line" : 3966,
    "endline" : 3983
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3984,
    "name" : "BoyerMooreFinder",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "BoyerMooreFinder",
      "kind" : "struct",
      "line" : 3984,
      "members" : [
       {
        "name" : "skip",
        "kind" : "variable",
        "line" : 3986,
        "type" : "size_t[]"
       },
       {
        "name" : "occ",
        "kind" : "variable",
        "line" : 3987,
        "type" : "ptrdiff_t[ElementType!(Range)]"
       },
       {
        "name" : "needle",
        "kind" : "variable",
        "line" : 3988,
        "type" : "Range"
       },
       {
        "name" : "occurrence",
        "kind" : "function",
        "line" : 3990,
        "type" : "ptrdiff_t(ElementType!(Range) c)",
        "parameters" : [
         {
          "name" : "c",
          "type" : "ElementType!(Range)"
         }
        ],
        "endline" : 3994
       },
       {
        "kind" : "template",
        "line" : 4004,
        "name" : "needlematch",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "needlematch",
          "kind" : "function",
          "line" : 4004,
          "type" : "bool(R needle, size_t portion, size_t offset)",
          "parameters" : [
           {
            "name" : "needle",
            "type" : "R"
           },
           {
            "name" : "portion",
            "type" : "size_t"
           },
           {
            "name" : "offset",
            "type" : "size_t"
           }
          ],
          "endline" : 4020
         }
        ]
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 4023,
        "type" : "(Range needle)",
        "parameters" : [
         {
          "name" : "needle",
          "type" : "Range"
         }
        ],
        "endline" : 4047
       },
       {
        "name" : "beFound",
        "kind" : "function",
        "line" : 4049,
        "type" : "Range(Range haystack)",
        "parameters" : [
         {
          "name" : "haystack",
          "type" : "Range"
         }
        ],
        "endline" : 4066
       },
       {
        "name" : "length",
        "kind" : "function",
        "line" : 4068,
        "type" : "size_t()",
        "endline" : 4071
       },
       {
        "name" : "opDollar",
        "kind" : "alias",
        "line" : 4073,
        "type" : "length"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4077,
    "name" : "boyerMooreFinder",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "boyerMooreFinder",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4077,
      "type" : "BoyerMooreFinder!(binaryFun!(pred), Range)(Range needle)",
      "parameters" : [
       {
        "name" : "needle",
        "type" : "Range"
       }
      ],
      "endline" : 4082
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 4085,
    "name" : "find",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "line" : 4085,
      "type" : "Range1(Range1 haystack, BoyerMooreFinder!(pred, Range2) needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "Range1"
       },
       {
        "name" : "needle",
        "type" : "BoyerMooreFinder!(pred, Range2)"
       }
      ],
      "endline" : 4089
     }
    ]
   },
   {
    "name" : "__unittestL4091_68",
    "kind" : "function",
    "line" : 4091,
    "endline" : 4111
   },
   {
    "name" : "__unittestL4111_69",
    "kind" : "function",
    "line" : 4111,
    "endline" : 4138
   },
   {
    "kind" : "template",
    "comment" : "\nAdvances the input range $(D haystack) by calling $(D haystack.popFront)\nuntil either $(D pred(haystack.front)), or $(D\nhaystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D\npred). See also $(WEB sgi.com/tech/stl/find_if.html, STL's find_if).\n\nTo find the last element of a bidirectional $(D haystack) satisfying\n$(D pred), call $(D find!(pred)(retro(haystack))). See also $(XREF\nrange, retro).\n\nExample:\n----\nauto arr = [ 1, 2, 3, 4, 1 ];\nassert(find!(\"a > 2\")(arr) == [ 3, 4, 1 ]);\n\n// with predicate alias\nbool pred(int x) { return x + 1 > 1.5; }\nassert(find!(pred)(arr) == arr);\n----\n",
    "line" : 4138,
    "name" : "find",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "find",
      "kind" : "function",
      "comment" : "\nAdvances the input range $(D haystack) by calling $(D haystack.popFront)\nuntil either $(D pred(haystack.front)), or $(D\nhaystack.empty). Performs $(BIGOH haystack.length) evaluations of $(D\npred). See also $(WEB sgi.com/tech/stl/find_if.html, STL's find_if).\n\nTo find the last element of a bidirectional $(D haystack) satisfying\n$(D pred), call $(D find!(pred)(retro(haystack))). See also $(XREF\nrange, retro).\n\nExample:\n----\nauto arr = [ 1, 2, 3, 4, 1 ];\nassert(find!(\"a > 2\")(arr) == [ 3, 4, 1 ]);\n\n// with predicate alias\nbool pred(int x) { return x + 1 > 1.5; }\nassert(find!(pred)(arr) == arr);\n----\n",
      "line" : 4138,
      "type" : "Range(Range haystack)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "Range"
       }
      ],
      "endline" : 4145
     }
    ]
   },
   {
    "name" : "__unittestL4147_70",
    "kind" : "function",
    "line" : 4147,
    "endline" : 4172
   },
   {
    "kind" : "template",
    "comment" : "\n If $(D needle) occurs in $(D haystack), positions $(D haystack)\n right after the first occurrence of $(D needle) and returns $(D\n true). Otherwise, leaves $(D haystack) as is and returns $(D\n false).\n\n Example:\n----\nstring s = \"abcdef\";\nassert(findSkip(s, \"cd\") && s == \"ef\");\ns = \"abcdef\";\nassert(!findSkip(s, \"cxd\") && s == \"abcdef\");\nassert(findSkip(s, \"def\") && s.empty);\n----\n \n",
    "line" : 4172,
    "name" : "findSkip",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findSkip",
      "kind" : "function",
      "comment" : "\n If $(D needle) occurs in $(D haystack), positions $(D haystack)\n right after the first occurrence of $(D needle) and returns $(D\n true). Otherwise, leaves $(D haystack) as is and returns $(D\n false).\n\n Example:\n----\nstring s = \"abcdef\";\nassert(findSkip(s, \"cd\") && s == \"ef\");\ns = \"abcdef\";\nassert(!findSkip(s, \"cxd\") && s == \"abcdef\");\nassert(findSkip(s, \"def\") && s.empty);\n----\n \n",
      "line" : 4172,
      "type" : "bool(ref R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 4181
     }
    ]
   },
   {
    "name" : "__unittestL4183_71",
    "kind" : "function",
    "line" : 4183,
    "endline" : 4244
   },
   {
    "kind" : "template",
    "comment" : "\nThese functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2])\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\n\nExample:\n----\nauto a = \"Carl Sagan Memorial Station\";\nauto r = findSplit(a, \"Velikovsky\");\nassert(r[0] == a);\nassert(r[1].empty);\nassert(r[2].empty);\nr = findSplit(a, \" \");\nassert(r[0] == \"Carl\");\nassert(r[1] == \" \");\nassert(r[2] == \"Sagan Memorial Station\");\nauto r1 = findSplitBefore(a, \"Sagan\");\nassert(r1[0] == \"Carl \", r1[0]);\nassert(r1[1] == \"Sagan Memorial Station\");\nauto r2 = findSplitAfter(a, \"Sagan\");\nassert(r2[0] == \"Carl Sagan\");\nassert(r2[1] == \" Memorial Station\");\n----\n \n",
    "line" : 4244,
    "name" : "findSplit",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findSplit",
      "kind" : "function",
      "comment" : "\nThese functions find the first occurrence of $(D needle) in $(D\nhaystack) and then split $(D haystack) as follows.\n\n$(D findSplit) returns a tuple $(D result) containing $(I three)\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), $(D result[1]) is the portion of $(D haystack) that matches\n$(D needle), and $(D result[2]) is the portion of $(D haystack) after\nthe match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) and $(D result[2])\nare empty.\n\n$(D findSplitBefore) returns a tuple $(D result) containing two\nranges. $(D result[0]) is the portion of $(D haystack) before $(D\nneedle), and $(D result[1]) is the balance of $(D haystack) starting\nwith the match. If $(D needle) was not found, $(D result[0])\ncomprehends $(D haystack) entirely and $(D result[1]) is empty.\n\n$(D findSplitAfter) returns a tuple $(D result) containing two ranges.\n$(D result[0]) is the portion of $(D haystack) up to and including the\nmatch, and $(D result[1]) is the balance of $(D haystack) starting\nafter the match. If $(D needle) was not found, $(D result[0]) is empty\nand $(D result[1]) is $(D haystack).\n\nIn all cases, the concatenation of the returned ranges spans the\nentire $(D haystack).\n\nIf $(D haystack) is a random-access range, all three components of the\ntuple have the same type as $(D haystack). Otherwise, $(D haystack)\nmust be a forward range and the type of $(D result[0]) and $(D\nresult[1]) is the same as $(XREF range,takeExactly).\n\nExample:\n----\nauto a = \"Carl Sagan Memorial Station\";\nauto r = findSplit(a, \"Velikovsky\");\nassert(r[0] == a);\nassert(r[1].empty);\nassert(r[2].empty);\nr = findSplit(a, \" \");\nassert(r[0] == \"Carl\");\nassert(r[1] == \" \");\nassert(r[2] == \"Sagan Memorial Station\");\nauto r1 = findSplitBefore(a, \"Sagan\");\nassert(r1[0] == \"Carl \", r1[0]);\nassert(r1[1] == \"Sagan Memorial Station\");\nauto r2 = findSplitAfter(a, \"Sagan\");\nassert(r2[0] == \"Carl Sagan\");\nassert(r2[1] == \" Memorial Station\");\n----\n \n",
      "line" : 4244,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 4283
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4286,
    "name" : "findSplitBefore",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findSplitBefore",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4286,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 4319
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4322,
    "name" : "findSplitAfter",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findSplitAfter",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4322,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 4361
     }
    ]
   },
   {
    "name" : "__unittestL4363_72",
    "kind" : "function",
    "line" : 4363,
    "endline" : 4390
   },
   {
    "name" : "__unittestL4390_73",
    "kind" : "function",
    "line" : 4390,
    "endline" : 4441
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the number of elements which must be popped from the front of\n    $(D haystack) before reaching an element for which\n    $(D startsWith!pred(haystack, needles)) is $(D true). If\n    $(D startsWith!pred(haystack, needles)) is not $(D true) for any element in\n    $(D haystack), then $(D -1) is returned.\n\n    $(D needles) may be either an element or a range.\n\n    Examples:\n--------------------\nassert(countUntil(\"hello world\", \"world\") == 6);\nassert(countUntil(\"hello world\", 'r') == 8);\nassert(countUntil(\"hello world\", \"programming\") == -1);\nassert(countUntil(\"日本語\", \"本語\") == 1);\nassert(countUntil(\"日本語\", '語')   == 2);\nassert(countUntil(\"日本語\", \"五\") == -1);\nassert(countUntil(\"日本語\", '五') == -1);\nassert(countUntil([0, 7, 12, 22, 9], [12, 22]) == 2);\nassert(countUntil([0, 7, 12, 22, 9], 9) == 4);\nassert(countUntil!\"a > b\"([0, 7, 12, 22, 9], 20) == 3);\n--------------------\n  \n",
    "line" : 4441,
    "name" : "countUntil",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Rs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "countUntil",
      "kind" : "function",
      "comment" : "\n    Returns the number of elements which must be popped from the front of\n    $(D haystack) before reaching an element for which\n    $(D startsWith!pred(haystack, needles)) is $(D true). If\n    $(D startsWith!pred(haystack, needles)) is not $(D true) for any element in\n    $(D haystack), then $(D -1) is returned.\n\n    $(D needles) may be either an element or a range.\n\n    Examples:\n--------------------\nassert(countUntil(\"hello world\", \"world\") == 6);\nassert(countUntil(\"hello world\", 'r') == 8);\nassert(countUntil(\"hello world\", \"programming\") == -1);\nassert(countUntil(\"日本語\", \"本語\") == 1);\nassert(countUntil(\"日本語\", '語')   == 2);\nassert(countUntil(\"日本語\", \"五\") == -1);\nassert(countUntil(\"日本語\", '五') == -1);\nassert(countUntil([0, 7, 12, 22, 9], [12, 22]) == 2);\nassert(countUntil([0, 7, 12, 22, 9], 9) == 4);\nassert(countUntil!\"a > b\"([0, 7, 12, 22, 9], 20) == 3);\n--------------------\n  \n",
      "line" : 4441,
      "type" : "ptrdiff_t(R haystack, Rs needles)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R"
       },
       {
        "name" : "needles",
        "type" : "Rs"
       }
      ],
      "endline" : 4524
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 4526,
    "name" : "countUntil",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "N",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "countUntil",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 4526,
      "type" : "ptrdiff_t(R haystack, N needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R"
       },
       {
        "name" : "needle",
        "type" : "N"
       }
      ],
      "endline" : 4532
     }
    ]
   },
   {
    "name" : "__unittestL4535_74",
    "kind" : "function",
    "line" : 4535,
    "endline" : 4548
   },
   {
    "name" : "__unittestL4548_75",
    "kind" : "function",
    "line" : 4548,
    "endline" : 4572
   },
   {
    "name" : "__unittestL4572_76",
    "kind" : "function",
    "line" : 4572,
    "endline" : 4591
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the number of elements which must be popped from $(D haystack)\n    before $(D pred(haystack.front)) is $(D true).\n\n    Examples:\n--------------------\nassert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\nassert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\nassert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n--------------------\n  \n",
    "line" : 4591,
    "name" : "countUntil",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "countUntil",
      "kind" : "function",
      "comment" : "\n    Returns the number of elements which must be popped from $(D haystack)\n    before $(D pred(haystack.front)) is $(D true).\n\n    Examples:\n--------------------\nassert(countUntil!(std.uni.isWhite)(\"hello world\") == 5);\nassert(countUntil!(std.ascii.isDigit)(\"hello world\") == -1);\nassert(countUntil!\"a > 20\"([0, 7, 12, 22, 9]) == 3);\n--------------------\n  \n",
      "line" : 4591,
      "type" : "ptrdiff_t(R haystack)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R"
       }
      ],
      "endline" : 4632
     }
    ]
   },
   {
    "name" : "__unittestL4635_77",
    "kind" : "function",
    "line" : 4635,
    "endline" : 4641
   },
   {
    "name" : "__unittestL4641_78",
    "kind" : "function",
    "line" : 4641,
    "endline" : 4669
   },
   {
    "kind" : "template",
    "line" : 4670,
    "name" : "indexOf",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "indexOf",
      "kind" : "function",
      "line" : 4670,
      "type" : "ptrdiff_t(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 4674
     }
    ]
   },
   {
    "name" : "OpenRight",
    "kind" : "enum",
    "comment" : "\nInterval option specifier for $(D until) (below) and others.\n \n",
    "line" : 4680,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " Interval is closed to the right (last element included)\n",
      "line" : 4681
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " Interval is open to the right (last element is not included)\n",
      "line" : 4682
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nLazily iterates $(D range) until value $(D sentinel) is found, at\nwhich point it stops.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];\nassert(equal(a.until(7), [1, 2, 4][]));\nassert(equal(a.until(7, OpenRight.no), [1, 2, 4, 7][]));\n----\n \n",
    "line" : 4697,
    "name" : "Until",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Sentinel",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Until",
      "kind" : "struct",
      "line" : 4697,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 4698,
        "type" : "Range"
       },
       {
        "name" : "_openRight",
        "kind" : "variable",
        "line" : 4707,
        "type" : "OpenRight"
       },
       {
        "name" : "_done",
        "kind" : "variable",
        "line" : 4708,
        "deco" : "b"
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 4727,
        "type" : "bool()",
        "endline" : 4730
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 4732,
        "type" : "ElementType!(Range)()",
        "endline" : 4736
       },
       {
        "name" : "predSatisfied",
        "kind" : "function",
        "line" : 4738,
        "type" : "bool()",
        "endline" : 4744
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 4746,
        "type" : "void()",
        "endline" : 4764
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4792,
    "name" : "until",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Sentinel",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "until",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4792,
      "type" : "Until!(pred, Range, Sentinel)(Range range, Sentinel sentinel, OpenRight openRight = OpenRight.yes)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "sentinel",
        "type" : "Sentinel"
       },
       {
        "name" : "openRight",
        "type" : "OpenRight",
        "default" : "OpenRight.yes"
       }
      ],
      "endline" : 4797
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4801,
    "name" : "until",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "until",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4801,
      "type" : "Until!(pred, Range, void)(Range range, OpenRight openRight = OpenRight.yes)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "openRight",
        "type" : "OpenRight",
        "default" : "OpenRight.yes"
       }
      ],
      "endline" : 4805
     }
    ]
   },
   {
    "name" : "__unittestL4807_79",
    "kind" : "function",
    "line" : 4807,
    "endline" : 4846
   },
   {
    "kind" : "template",
    "comment" : "\nIf the range $(D doesThisStart) starts with $(I any) of the $(D\nwithOneOfThese) ranges or elements, returns 1 if it starts with $(D\nwithOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so\non. If none match, returns 0. In the case where $(D doesThisStart) starts\nwith multiple of the ranges or elements in $(D withOneOfThese), then the\nshortest one matches (if there are two which match which are of the same\nlength (e.g. $(D \"a\") and $(D 'a')), then the left-most of them in the argument\nlist matches).\n\nExample:\n----\nassert(startsWith(\"abc\", \"\"));\nassert(startsWith(\"abc\", \"a\"));\nassert(!startsWith(\"abc\", \"b\"));\nassert(startsWith(\"abc\", 'a', \"b\") == 1);\nassert(startsWith(\"abc\", \"b\", \"a\") == 2);\nassert(startsWith(\"abc\", \"a\", \"a\") == 1);\nassert(startsWith(\"abc\", \"ab\", \"a\") == 2);\nassert(startsWith(\"abc\", \"x\", \"a\", \"b\") == 2);\nassert(startsWith(\"abc\", \"x\", \"aa\", \"ab\") == 3);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"a\", \"sab\") == 3);\n----\n \n",
    "line" : 4846,
    "name" : "startsWith",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Needles",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "startsWith",
      "kind" : "function",
      "comment" : "\nIf the range $(D doesThisStart) starts with $(I any) of the $(D\nwithOneOfThese) ranges or elements, returns 1 if it starts with $(D\nwithOneOfThese[0]), 2 if it starts with $(D withOneOfThese[1]), and so\non. If none match, returns 0. In the case where $(D doesThisStart) starts\nwith multiple of the ranges or elements in $(D withOneOfThese), then the\nshortest one matches (if there are two which match which are of the same\nlength (e.g. $(D \"a\") and $(D 'a')), then the left-most of them in the argument\nlist matches).\n\nExample:\n----\nassert(startsWith(\"abc\", \"\"));\nassert(startsWith(\"abc\", \"a\"));\nassert(!startsWith(\"abc\", \"b\"));\nassert(startsWith(\"abc\", 'a', \"b\") == 1);\nassert(startsWith(\"abc\", \"b\", \"a\") == 2);\nassert(startsWith(\"abc\", \"a\", \"a\") == 1);\nassert(startsWith(\"abc\", \"ab\", \"a\") == 2);\nassert(startsWith(\"abc\", \"x\", \"a\", \"b\") == 2);\nassert(startsWith(\"abc\", \"x\", \"aa\", \"ab\") == 3);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(startsWith(\"abc\", \"x\", \"aaa\", \"a\", \"sab\") == 3);\n----\n \n",
      "line" : 4846,
      "type" : "uint(Range doesThisStart, Needles withOneOfThese)",
      "parameters" : [
       {
        "name" : "doesThisStart",
        "type" : "Range"
       },
       {
        "name" : "withOneOfThese",
        "type" : "Needles"
       }
      ],
      "endline" : 4916
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4919,
    "name" : "startsWith",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "startsWith",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4919,
      "type" : "bool(R1 doesThisStart, R2 withThis)",
      "parameters" : [
       {
        "name" : "doesThisStart",
        "type" : "R1"
       },
       {
        "name" : "withThis",
        "type" : "R2"
       }
      ],
      "endline" : 4985
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4988,
    "name" : "startsWith",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "startsWith",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4988,
      "type" : "bool(R doesThisStart, E withThis)",
      "parameters" : [
       {
        "name" : "doesThisStart",
        "type" : "R"
       },
       {
        "name" : "withThis",
        "type" : "E"
       }
      ],
      "endline" : 4995
     }
    ]
   },
   {
    "name" : "__unittestL4997_80",
    "kind" : "function",
    "line" : 4997,
    "endline" : 5092
   },
   {
    "kind" : "template",
    "comment" : "\nIf $(D startsWith(r1, r2)), consume the corresponding elements off $(D\nr1) and return $(D true). Otherwise, leave $(D r1) unchanged and\nreturn $(D false).\n \n",
    "line" : 5092,
    "name" : "skipOver",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "skipOver",
      "kind" : "function",
      "comment" : "\nIf $(D startsWith(r1, r2)), consume the corresponding elements off $(D\nr1) and return $(D true). Otherwise, leave $(D r1) unchanged and\nreturn $(D false).\n \n",
      "line" : 5092,
      "type" : "bool(ref R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 5102
     }
    ]
   },
   {
    "name" : "__unittestL5104_87",
    "kind" : "function",
    "line" : 5104,
    "endline" : 5125
   },
   {
    "kind" : "template",
    "comment" : "\nChecks whether a range starts with an element, and if so, consume that\nelement off $(D r) and return $(D true). Otherwise, leave $(D r)\nunchanged and return $(D false).\n \n",
    "line" : 5125,
    "name" : "skipOver",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "skipOver",
      "kind" : "function",
      "comment" : "\nChecks whether a range starts with an element, and if so, consume that\nelement off $(D r) and return $(D true). Otherwise, leave $(D r)\nunchanged and return $(D false).\n \n",
      "line" : 5125,
      "type" : "bool(ref R r, E e)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "e",
        "type" : "E"
       }
      ],
      "endline" : 5131
     }
    ]
   },
   {
    "name" : "__unittestL5133_94",
    "kind" : "function",
    "line" : 5133,
    "endline" : 5151
   },
   {
    "kind" : "template",
    "line" : 5151,
    "name" : "skipAll",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Es",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "skipAll",
      "kind" : "function",
      "line" : 5151,
      "type" : "void(ref R r, Es es)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "es",
        "type" : "Es"
       }
      ],
      "endline" : 5166
     }
    ]
   },
   {
    "name" : "__unittestL5168_95",
    "kind" : "function",
    "line" : 5168,
    "endline" : 5193
   },
   {
    "kind" : "template",
    "comment" : "\nThe reciprocal of $(D startsWith).\n\nExample:\n----\nassert(endsWith(\"abc\", \"\"));\nassert(!endsWith(\"abc\", \"b\"));\nassert(endsWith(\"abc\", \"a\", 'c') == 2);\nassert(endsWith(\"abc\", \"c\", \"a\") == 1);\nassert(endsWith(\"abc\", \"c\", \"c\") == 1);\nassert(endsWith(\"abc\", \"bc\", \"c\") == 2);\nassert(endsWith(\"abc\", \"x\", \"c\", \"b\") == 2);\nassert(endsWith(\"abc\", \"x\", \"aa\", \"bc\") == 3);\nassert(endsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(endsWith(\"abc\", \"x\", \"aaa\", 'c', \"sab\") == 3);\n----\n \n",
    "line" : 5193,
    "name" : "endsWith",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Needles",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "endsWith",
      "kind" : "function",
      "comment" : "\nThe reciprocal of $(D startsWith).\n\nExample:\n----\nassert(endsWith(\"abc\", \"\"));\nassert(!endsWith(\"abc\", \"b\"));\nassert(endsWith(\"abc\", \"a\", 'c') == 2);\nassert(endsWith(\"abc\", \"c\", \"a\") == 1);\nassert(endsWith(\"abc\", \"c\", \"c\") == 1);\nassert(endsWith(\"abc\", \"bc\", \"c\") == 2);\nassert(endsWith(\"abc\", \"x\", \"c\", \"b\") == 2);\nassert(endsWith(\"abc\", \"x\", \"aa\", \"bc\") == 3);\nassert(endsWith(\"abc\", \"x\", \"aaa\", \"sab\") == 0);\nassert(endsWith(\"abc\", \"x\", \"aaa\", 'c', \"sab\") == 3);\n----\n \n",
      "line" : 5193,
      "type" : "uint(Range doesThisEnd, Needles withOneOfThese)",
      "parameters" : [
       {
        "name" : "doesThisEnd",
        "type" : "Range"
       },
       {
        "name" : "withOneOfThese",
        "type" : "Needles"
       }
      ],
      "endline" : 5257
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5260,
    "name" : "endsWith",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "endsWith",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5260,
      "type" : "bool(R1 doesThisEnd, R2 withThis)",
      "parameters" : [
       {
        "name" : "doesThisEnd",
        "type" : "R1"
       },
       {
        "name" : "withThis",
        "type" : "R2"
       }
      ],
      "endline" : 5284
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5287,
    "name" : "endsWith",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "endsWith",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5287,
      "type" : "bool(R doesThisEnd, E withThis)",
      "parameters" : [
       {
        "name" : "doesThisEnd",
        "type" : "R"
       },
       {
        "name" : "withThis",
        "type" : "E"
       }
      ],
      "endline" : 5294
     }
    ]
   },
   {
    "name" : "__unittestL5296_96",
    "kind" : "function",
    "line" : 5296,
    "endline" : 5393
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the common prefix of two ranges. Example:\n\n----\nassert(commonPrefix(\"hello, world\", \"hello, there\") == \"hello, \");\n----\n\nIf the first argument is a string, then the result is a slice of $(D r1) which\ncontains the characters that both ranges start with. For all other types, the\ntype of the result is the same as the result of $(D takeExactly(r1, n)), where\n$(D n) is the number of elements that both ranges start with.\n\nSee_Also:\n    $(XREF range, takeExactly)\n \n",
    "line" : 5393,
    "name" : "commonPrefix",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "commonPrefix",
      "kind" : "function",
      "comment" : "\nReturns the common prefix of two ranges. Example:\n\n----\nassert(commonPrefix(\"hello, world\", \"hello, there\") == \"hello, \");\n----\n\nIf the first argument is a string, then the result is a slice of $(D r1) which\ncontains the characters that both ranges start with. For all other types, the\ntype of the result is the same as the result of $(D takeExactly(r1, n)), where\n$(D n) is the number of elements that both ranges start with.\n\nSee_Also:\n    $(XREF range, takeExactly)\n \n",
      "line" : 5393,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 5422
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 5424,
    "name" : "commonPrefix",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "commonPrefix",
      "kind" : "function",
      "line" : 5424,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 5440
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 5442,
    "name" : "commonPrefix",
    "parameters" : [
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "commonPrefix",
      "kind" : "function",
      "line" : 5442,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 5447
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 5449,
    "name" : "commonPrefix",
    "parameters" : [
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "commonPrefix",
      "kind" : "function",
      "line" : 5449,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 5473
     }
    ]
   },
   {
    "name" : "__unittestL5475_97",
    "kind" : "function",
    "line" : 5475,
    "endline" : 5549
   },
   {
    "kind" : "template",
    "comment" : "\nAdvances $(D r) until it finds the first two adjacent elements $(D a),\n$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)\nevaluations of $(D pred). See also $(WEB\nsgi.com/tech/stl/adjacent_find.html, STL's adjacent_find).\n\nExample:\n----\nint[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];\nauto r = findAdjacent(a);\nassert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);\np = findAdjacent!(\"a < b\")(a);\nassert(p == [ 7, 8, 9 ]);\n----\n",
    "line" : 5549,
    "name" : "findAdjacent",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findAdjacent",
      "kind" : "function",
      "comment" : "\nAdvances $(D r) until it finds the first two adjacent elements $(D a),\n$(D b) that satisfy $(D pred(a, b)). Performs $(BIGOH r.length)\nevaluations of $(D pred). See also $(WEB\nsgi.com/tech/stl/adjacent_find.html, STL's adjacent_find).\n\nExample:\n----\nint[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];\nauto r = findAdjacent(a);\nassert(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);\np = findAdjacent!(\"a < b\")(a);\nassert(p == [ 7, 8, 9 ]);\n----\n",
      "line" : 5549,
      "type" : "Range(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 5562
     }
    ]
   },
   {
    "name" : "__unittestL5564_98",
    "kind" : "function",
    "line" : 5564,
    "endline" : 5604
   },
   {
    "kind" : "template",
    "comment" : "\nAdvances $(D seq) by calling $(D seq.popFront) until either $(D\nfind!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes\nempty. Performs $(BIGOH seq.length * choices.length) evaluations of\n$(D pred). See also $(WEB sgi.com/tech/stl/find_first_of.html, STL's\nfind_first_of).\n\nExample:\n----\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 3, 1, 2 ];\nassert(findAmong(a, b) == a[2 .. $]);\n----\n",
    "line" : 5604,
    "name" : "findAmong",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findAmong",
      "kind" : "function",
      "comment" : "\nAdvances $(D seq) by calling $(D seq.popFront) until either $(D\nfind!(pred)(choices, seq.front)) is $(D true), or $(D seq) becomes\nempty. Performs $(BIGOH seq.length * choices.length) evaluations of\n$(D pred). See also $(WEB sgi.com/tech/stl/find_first_of.html, STL's\nfind_first_of).\n\nExample:\n----\nint[] a = [ -1, 0, 1, 2, 3, 4, 5 ];\nint[] b = [ 3, 1, 2 ];\nassert(findAmong(a, b) == a[2 .. $]);\n----\n",
      "line" : 5604,
      "type" : "Range1(Range1 seq, Range2 choices)",
      "parameters" : [
       {
        "name" : "seq",
        "type" : "Range1"
       },
       {
        "name" : "choices",
        "type" : "Range2"
       }
      ],
      "endline" : 5612
     }
    ]
   },
   {
    "name" : "__unittestL5614_99",
    "kind" : "function",
    "line" : 5614,
    "endline" : 5659
   },
   {
    "kind" : "template",
    "comment" : "\nThe first version counts the number of elements $(D x) in $(D r) for\nwhich $(D pred(x, value)) is $(D true). $(D pred) defaults to\nequality. Performs $(BIGOH r.length) evaluations of $(D pred).\n\nThe second version returns the number of times $(D needle) occurs in\n$(D haystack). Throws an exception if $(D needle.empty), as the _count\nof the empty range in any range would be infinite. Overlapped counts\nare not considered, for example $(D count(\"aaa\", \"aa\")) is $(D 1), not\n$(D 2).\n\nThe third version counts the elements for which $(D pred(x)) is $(D\ntrue). Performs $(BIGOH r.length) evaluations of $(D pred).\n\nNote: Regardless of the overload, $(D count) will not accept\ninfinite ranges for $(D haystack).\n\nExample:\n----\n// count elements in range\nint[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];\nassert(count(a, 2) == 3);\nassert(count!(\"a > b\")(a, 2) == 5);\n// count range in range\nassert(count(\"abcadfabf\", \"ab\") == 2);\nassert(count(\"ababab\", \"abab\") == 1);\nassert(count(\"ababab\", \"abx\") == 0);\n// fuzzy count range in range\nassert(count!\"std.uni.toLower(a) == std.uni.toLower(b)\"(\"AbcAdFaBf\", \"ab\") == 2);\n// count predicate in range\nassert(count!(\"a > 1\")(a) == 8);\n----\n",
    "line" : 5659,
    "name" : "count",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "count",
      "kind" : "function",
      "comment" : "\nThe first version counts the number of elements $(D x) in $(D r) for\nwhich $(D pred(x, value)) is $(D true). $(D pred) defaults to\nequality. Performs $(BIGOH r.length) evaluations of $(D pred).\n\nThe second version returns the number of times $(D needle) occurs in\n$(D haystack). Throws an exception if $(D needle.empty), as the _count\nof the empty range in any range would be infinite. Overlapped counts\nare not considered, for example $(D count(\"aaa\", \"aa\")) is $(D 1), not\n$(D 2).\n\nThe third version counts the elements for which $(D pred(x)) is $(D\ntrue). Performs $(BIGOH r.length) evaluations of $(D pred).\n\nNote: Regardless of the overload, $(D count) will not accept\ninfinite ranges for $(D haystack).\n\nExample:\n----\n// count elements in range\nint[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];\nassert(count(a, 2) == 3);\nassert(count!(\"a > b\")(a, 2) == 5);\n// count range in range\nassert(count(\"abcadfabf\", \"ab\") == 2);\nassert(count(\"ababab\", \"abab\") == 1);\nassert(count(\"ababab\", \"abx\") == 0);\n// fuzzy count range in range\nassert(count!\"std.uni.toLower(a) == std.uni.toLower(b)\"(\"AbcAdFaBf\", \"ab\") == 2);\n// count predicate in range\nassert(count!(\"a > 1\")(a) == 8);\n----\n",
      "line" : 5659,
      "type" : "size_t(Range haystack, E needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "Range"
       },
       {
        "name" : "needle",
        "type" : "E"
       }
      ],
      "endline" : 5665
     }
    ]
   },
   {
    "name" : "__unittestL5667_100",
    "kind" : "function",
    "line" : 5667,
    "endline" : 5685
   },
   {
    "name" : "__unittestL5685_101",
    "kind" : "function",
    "line" : 5685,
    "endline" : 5694
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5694,
    "name" : "count",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "count",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5694,
      "type" : "size_t(R1 haystack, R2 needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R1"
       },
       {
        "name" : "needle",
        "type" : "R2"
       }
      ],
      "endline" : 5714
     }
    ]
   },
   {
    "name" : "__unittestL5716_102",
    "kind" : "function",
    "line" : 5716,
    "endline" : 5725
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5725,
    "name" : "count",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"true\""
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "count",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5725,
      "type" : "size_t(R haystack)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R"
       }
      ],
      "endline" : 5734
     }
    ]
   },
   {
    "name" : "__unittestL5736_103",
    "kind" : "function",
    "line" : 5736,
    "endline" : 5766
   },
   {
    "kind" : "template",
    "comment" : "\nChecks whether $(D r) has \"balanced parentheses\", i.e. all instances\nof $(D lPar) are closed by corresponding instances of $(D rPar). The\nparameter $(D maxNestingLevel) controls the nesting level allowed. The\nmost common uses are the default or $(D 0). In the latter case, no\nnesting is allowed.\n\nExample:\n----\nauto s = \"1 + $(LPAREN)2 * (3 + 1 / 2)\";\nassert(!balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(!balancedParens(s, '(', ')', 1));\ns = \"1 + (2 * 3 + 1) / (2 - 5)\";\nassert(balancedParens(s, '(', ')', 1));\n----\n",
    "line" : 5766,
    "name" : "balancedParens",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "balancedParens",
      "kind" : "function",
      "comment" : "\nChecks whether $(D r) has \"balanced parentheses\", i.e. all instances\nof $(D lPar) are closed by corresponding instances of $(D rPar). The\nparameter $(D maxNestingLevel) controls the nesting level allowed. The\nmost common uses are the default or $(D 0). In the latter case, no\nnesting is allowed.\n\nExample:\n----\nauto s = \"1 + $(LPAREN)2 * (3 + 1 / 2)\";\nassert(!balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(balancedParens(s, '(', ')'));\ns = \"1 + (2 * (3 + 1) / 2)\";\nassert(!balancedParens(s, '(', ')', 1));\ns = \"1 + (2 * 3 + 1) / (2 - 5)\";\nassert(balancedParens(s, '(', ')', 1));\n----\n",
      "line" : 5766,
      "type" : "bool(Range r, E lPar, E rPar, size_t maxNestingLevel = size_t.max)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "lPar",
        "type" : "E"
       },
       {
        "name" : "rPar",
        "type" : "E"
       },
       {
        "name" : "maxNestingLevel",
        "type" : "size_t",
        "default" : "size_t.max"
       }
      ],
      "endline" : 5785
     }
    ]
   },
   {
    "name" : "__unittestL5787_104",
    "kind" : "function",
    "line" : 5787,
    "endline" : 5824
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if the two ranges compare equal element\nfor element, according to binary predicate $(D pred). The ranges may\nhave different element types, as long as $(D pred(a, b)) evaluates to\n$(D bool) for $(D a) in $(D r1) and $(D b) in $(D r2). Performs\n$(BIGOH min(r1.length, r2.length)) evaluations of $(D pred). See also\n$(WEB sgi.com/tech/stl/_equal.html, STL's _equal).\n\nExample:\n----\nint[] a = [ 1, 2, 4, 3 ];\nassert(!equal(a, a[1..$]));\nassert(equal(a, a));\n\n// different types\ndouble[] b = [ 1.0, 2, 4, 3];\nassert(!equal(a, b[1..$]));\nassert(equal(a, b));\n\n// predicated: ensure that two vectors are approximately equal\ndouble[] c = [ 1.005, 2, 4, 3];\nassert(equal!(approxEqual)(b, c));\n----\n",
    "line" : 5824,
    "name" : "equal",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "equal",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if and only if the two ranges compare equal element\nfor element, according to binary predicate $(D pred). The ranges may\nhave different element types, as long as $(D pred(a, b)) evaluates to\n$(D bool) for $(D a) in $(D r1) and $(D b) in $(D r2). Performs\n$(BIGOH min(r1.length, r2.length)) evaluations of $(D pred). See also\n$(WEB sgi.com/tech/stl/_equal.html, STL's _equal).\n\nExample:\n----\nint[] a = [ 1, 2, 4, 3 ];\nassert(!equal(a, a[1..$]));\nassert(equal(a, a));\n\n// different types\ndouble[] b = [ 1.0, 2, 4, 3];\nassert(!equal(a, b[1..$]));\nassert(equal(a, b));\n\n// predicated: ensure that two vectors are approximately equal\ndouble[] c = [ 1.005, 2, 4, 3];\nassert(equal!(approxEqual)(b, c));\n----\n",
      "line" : 5824,
      "type" : "bool(Range1 r1, Range2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "Range1"
       },
       {
        "name" : "r2",
        "type" : "Range2"
       }
      ],
      "endline" : 5839
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5842,
    "name" : "equal",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "equal",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5842,
      "type" : "bool(Range1 r1, Range2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "Range1"
       },
       {
        "name" : "r2",
        "type" : "Range2"
       }
      ],
      "endline" : 5872
     }
    ]
   },
   {
    "name" : "__unittestL5874_105",
    "kind" : "function",
    "line" : 5874,
    "endline" : 5957
   },
   {
    "kind" : "template",
    "comment" : "\nPerforms three-way lexicographical comparison on two input ranges\naccording to predicate $(D pred). Iterating $(D r1) and $(D r2) in\nlockstep, $(D cmp) compares each element $(D e1) of $(D r1) with the\ncorresponding element $(D e2) in $(D r2). If $(D binaryFun!pred(e1,\ne2)), $(D cmp) returns a negative value. If $(D binaryFun!pred(e2,\ne1)), $(D cmp) returns a positive value. If one of the ranges has been\nfinished, $(D cmp) returns a negative value if $(D r1) has fewer\nelements than $(D r2), a positive value if $(D r1) has more elements\nthan $(D r2), and $(D 0) if the ranges have the same number of\nelements.\n\nIf the ranges are strings, $(D cmp) performs UTF decoding\nappropriately and compares the ranges one code point at a time.\n",
    "line" : 5957,
    "name" : "cmp",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cmp",
      "kind" : "function",
      "comment" : "\nPerforms three-way lexicographical comparison on two input ranges\naccording to predicate $(D pred). Iterating $(D r1) and $(D r2) in\nlockstep, $(D cmp) compares each element $(D e1) of $(D r1) with the\ncorresponding element $(D e2) in $(D r2). If $(D binaryFun!pred(e1,\ne2)), $(D cmp) returns a negative value. If $(D binaryFun!pred(e2,\ne1)), $(D cmp) returns a positive value. If one of the ranges has been\nfinished, $(D cmp) returns a negative value if $(D r1) has fewer\nelements than $(D r2), a positive value if $(D r1) has more elements\nthan $(D r2), and $(D 0) if the ranges have the same number of\nelements.\n\nIf the ranges are strings, $(D cmp) performs UTF decoding\nappropriately and compares the ranges one code point at a time.\n",
      "line" : 5957,
      "type" : "int(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 5968
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 5971,
    "name" : "cmp",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cmp",
      "kind" : "function",
      "line" : 5971,
      "type" : "int(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 6026
     }
    ]
   },
   {
    "name" : "__unittestL6028_106",
    "kind" : "function",
    "line" : 6028,
    "endline" : 6066
   },
   {
    "kind" : "template",
    "line" : 6066,
    "name" : "MinType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the minimum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n",
    "line" : 6098,
    "name" : "min",
    "parameters" : [
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "min",
      "kind" : "function",
      "comment" : "\nReturns the minimum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n",
      "line" : 6098,
      "type" : "MinType!(T1, T2, T)(T1 a, T2 b, T xs)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T1"
       },
       {
        "name" : "b",
        "type" : "T2"
       },
       {
        "name" : "xs",
        "type" : "T"
       }
      ],
      "endline" : 6119
     }
    ]
   },
   {
    "name" : "__unittestL6121_107",
    "kind" : "function",
    "line" : 6121,
    "endline" : 6153
   },
   {
    "kind" : "template",
    "line" : 6153,
    "name" : "MaxType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the maximum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n\nExample:\n----\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = max(a, b);\nassert(is(typeof(d) == int));\nassert(d == 6);\nauto e = min(a, b, c);\nassert(is(typeof(e) == double));\nassert(e == 2);\n----\n",
    "line" : 6189,
    "name" : "max",
    "parameters" : [
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "max",
      "kind" : "function",
      "comment" : "\nReturns the maximum of the passed-in values. The type of the result is\ncomputed by using $(XREF traits, CommonType).\n\nExample:\n----\nint a = 5;\nshort b = 6;\ndouble c = 2;\nauto d = max(a, b);\nassert(is(typeof(d) == int));\nassert(d == 6);\nauto e = min(a, b, c);\nassert(is(typeof(e) == double));\nassert(e == 2);\n----\n",
      "line" : 6189,
      "type" : "MaxType!(T1, T2, T)(T1 a, T2 b, T xs)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T1"
       },
       {
        "name" : "b",
        "type" : "T2"
       },
       {
        "name" : "xs",
        "type" : "T"
       }
      ],
      "endline" : 6210
     }
    ]
   },
   {
    "name" : "__unittestL6212_108",
    "kind" : "function",
    "line" : 6212,
    "endline" : 6258
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the minimum element of a range together with the number of\noccurrences. The function can actually be used for counting the\nmaximum or any other ordering predicate (that's why $(D maxCount) is\nnot provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and occurs 3 times\nassert(minCount(a) == tuple(1, 3));\n// Maximum is 4 and occurs 2 times\nassert(minCount!(\"a > b\")(a) == tuple(4, 2));\n----\n \n",
    "line" : 6259,
    "name" : "minCount",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "minCount",
      "kind" : "function",
      "comment" : "\nReturns the minimum element of a range together with the number of\noccurrences. The function can actually be used for counting the\nmaximum or any other ordering predicate (that's why $(D maxCount) is\nnot provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and occurs 3 times\nassert(minCount(a) == tuple(1, 3));\n// Maximum is 4 and occurs 2 times\nassert(minCount!(\"a > b\")(a) == tuple(4, 2));\n----\n \n",
      "line" : 6259,
      "type" : "Tuple!(ElementType!(Range), size_t)(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 6282
     }
    ]
   },
   {
    "name" : "__unittestL6284_109",
    "kind" : "function",
    "line" : 6284,
    "endline" : 6321
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the position of the minimum element of forward range $(D\nrange), i.e. a subrange of $(D range) starting at the position of its\nsmallest element and with the same ending as $(D range). The function\ncan actually be used for counting the maximum or any other ordering\npredicate (that's why $(D maxPos) is not provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and first occurs in position 3\nassert(minPos(a) == [ 1, 2, 4, 1, 1, 2 ]);\n// Maximum is 4 and first occurs in position 2\nassert(minPos!(\"a > b\")(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);\n----\n \n",
    "line" : 6321,
    "name" : "minPos",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "minPos",
      "kind" : "function",
      "comment" : "\nReturns the position of the minimum element of forward range $(D\nrange), i.e. a subrange of $(D range) starting at the position of its\nsmallest element and with the same ending as $(D range). The function\ncan actually be used for counting the maximum or any other ordering\npredicate (that's why $(D maxPos) is not provided).\n\nExample:\n----\nint[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];\n// Minimum is 1 and first occurs in position 3\nassert(minPos(a) == [ 1, 2, 4, 1, 1, 2 ]);\n// Maximum is 4 and first occurs in position 2\nassert(minPos!(\"a > b\")(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);\n----\n \n",
      "line" : 6321,
      "type" : "Range(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 6338
     }
    ]
   },
   {
    "name" : "__unittestL6340_110",
    "kind" : "function",
    "line" : 6340,
    "endline" : 6357
   },
   {
    "name" : "__unittestL6357_111",
    "kind" : "function",
    "line" : 6357,
    "endline" : 6367
   },
   {
    "name" : "__unittestL6367_112",
    "kind" : "function",
    "line" : 6367,
    "endline" : 6401
   },
   {
    "kind" : "template",
    "comment" : "\nSequentially compares elements in $(D r1) and $(D r2) in lockstep, and\nstops at the first mismatch (according to $(D pred), by default\nequality). Returns a tuple with the reduced ranges that start with the\ntwo mismatched values. Performs $(BIGOH min(r1.length, r2.length))\nevaluations of $(D pred). See also $(WEB\nsgi.com/tech/stl/_mismatch.html, STL's _mismatch).\n\nExample:\n----\nint[]    x = [ 1,  5, 2, 7,   4, 3 ];\ndouble[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];\nauto m = mismatch(x, y);\nassert(m[0] == x[3 .. $]);\nassert(m[1] == y[3 .. $]);\n----\n",
    "line" : 6402,
    "name" : "mismatch",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "mismatch",
      "kind" : "function",
      "comment" : "\nSequentially compares elements in $(D r1) and $(D r2) in lockstep, and\nstops at the first mismatch (according to $(D pred), by default\nequality). Returns a tuple with the reduced ranges that start with the\ntwo mismatched values. Performs $(BIGOH min(r1.length, r2.length))\nevaluations of $(D pred). See also $(WEB\nsgi.com/tech/stl/_mismatch.html, STL's _mismatch).\n\nExample:\n----\nint[]    x = [ 1,  5, 2, 7,   4, 3 ];\ndouble[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];\nauto m = mismatch(x, y);\nassert(m[0] == x[3 .. $]);\nassert(m[1] == y[3 .. $]);\n----\n",
      "line" : 6402,
      "type" : "Tuple!(Range1, Range2)(Range1 r1, Range2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "Range1"
       },
       {
        "name" : "r2",
        "type" : "Range2"
       }
      ],
      "endline" : 6410
     }
    ]
   },
   {
    "name" : "__unittestL6412_113",
    "kind" : "function",
    "line" : 6412,
    "endline" : 6446
   },
   {
    "name" : "EditOp",
    "kind" : "enum",
    "comment" : "\nEncodes $(WEB realityinteractive.com/rgrzywinski/archives/000249.html,\nedit operations) necessary to transform one sequence into\nanother. Given sequences $(D s) (source) and $(D t) (target), a\nsequence of $(D EditOp) encodes the steps that need to be taken to\nconvert $(D s) into $(D t). For example, if $(D s = \"cat\") and $(D\n\"cars\"), the minimal sequence that transforms $(D s) into $(D t) is:\nskip two characters, replace 't' with 'r', and insert an 's'. Working\nwith edit operations is useful in applications such as spell-checkers\n(to find the closest word to a given misspelled word), approximate\nsearches, diff-style programs that compute the difference between\nfiles, efficient encoding of patches, DNA sequence analysis, and\nplagiarism detection.\n",
    "line" : 6446,
    "baseDeco" : "a",
    "members" : [
     {
      "name" : "none",
      "kind" : "enum member",
      "comment" : " Current items are equal; no editing is necessary. \n",
      "line" : 6449
     },
     {
      "name" : "substitute",
      "kind" : "enum member",
      "comment" : " Substitute current item in target with current item in source. \n",
      "line" : 6451
     },
     {
      "name" : "insert",
      "kind" : "enum member",
      "comment" : " Insert current item from the source into the target. \n",
      "line" : 6453
     },
     {
      "name" : "remove",
      "kind" : "enum member",
      "comment" : " Remove current item from the target. \n",
      "line" : 6455
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 6459,
    "name" : "Levenshtein",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "equals",
      "kind" : "alias"
     },
     {
      "name" : "CostType",
      "kind" : "type",
      "default" : "size_t"
     }
    ],
    "members" : [
     {
      "name" : "Levenshtein",
      "kind" : "struct",
      "line" : 6459,
      "members" : [
       {
        "name" : "deletionIncrement",
        "kind" : "function",
        "line" : 6460,
        "type" : "void(CostType n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "CostType"
         }
        ],
        "endline" : 6464
       },
       {
        "name" : "insertionIncrement",
        "kind" : "function",
        "line" : 6466,
        "type" : "void(CostType n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "CostType"
         }
        ],
        "endline" : 6470
       },
       {
        "name" : "distance",
        "kind" : "function",
        "line" : 6472,
        "type" : "CostType(Range s, Range t)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "Range"
         },
         {
          "name" : "t",
          "type" : "Range"
         }
        ],
        "endline" : 6502
       },
       {
        "name" : "path",
        "kind" : "function",
        "line" : 6504,
        "type" : "EditOp[](Range s, Range t)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "Range"
         },
         {
          "name" : "t",
          "type" : "Range"
         }
        ],
        "endline" : 6508
       },
       {
        "name" : "path",
        "kind" : "function",
        "line" : 6510,
        "type" : "EditOp[]()",
        "endline" : 6541
       },
       {
        "name" : "_deletionIncrement",
        "kind" : "variable",
        "line" : 6544,
        "type" : "CostType",
        "init" : "1"
       },
       {
        "name" : "_insertionIncrement",
        "kind" : "variable",
        "line" : 6545,
        "type" : "CostType",
        "init" : "1"
       },
       {
        "name" : "_substitutionIncrement",
        "kind" : "variable",
        "line" : 6546,
        "type" : "CostType",
        "init" : "1"
       },
       {
        "name" : "_matrix",
        "kind" : "variable",
        "line" : 6547,
        "type" : "CostType[][]"
       },
       {
        "name" : "rows",
        "kind" : "variable",
        "line" : 6548,
        "type" : "size_t"
       },
       {
        "name" : "cols",
        "kind" : "variable",
        "line" : 6548,
        "type" : "size_t"
       },
       {
        "name" : "AllocMatrix",
        "kind" : "function",
        "line" : 6550,
        "type" : "void(size_t r, size_t c)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "size_t"
         },
         {
          "name" : "c",
          "type" : "size_t"
         }
        ],
        "endline" : 6558
       },
       {
        "name" : "InitMatrix",
        "kind" : "function",
        "line" : 6560,
        "type" : "void()",
        "endline" : 6568
       },
       {
        "name" : "min_index",
        "kind" : "function",
        "line" : 6570,
        "type" : "uint(CostType i0, CostType i1, CostType i2)",
        "parameters" : [
         {
          "name" : "i0",
          "type" : "CostType"
         },
         {
          "name" : "i1",
          "type" : "CostType"
         },
         {
          "name" : "i2",
          "type" : "CostType"
         }
        ],
        "endline" : 6580
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the $(WEB wikipedia.org/wiki/Levenshtein_distance, Levenshtein\ndistance) between $(D s) and $(D t). The Levenshtein distance computes\nthe minimal amount of edit operations necessary to transform $(D s)\ninto $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D\nequals) and occupies $(BIGOH s.length * t.length) storage.\n\nExample:\n----\nassert(levenshteinDistance(\"cat\", \"rat\") == 1);\nassert(levenshteinDistance(\"parks\", \"spark\") == 2);\nassert(levenshteinDistance(\"kitten\", \"sitting\") == 3);\n// ignore case\nassert(levenshteinDistance!(\"std.uni.toUpper(a) == std.uni.toUpper(b)\")\n    (\"parks\", \"SPARK\") == 2);\n----\n",
    "line" : 6600,
    "name" : "levenshteinDistance",
    "parameters" : [
     {
      "name" : "equals",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "levenshteinDistance",
      "kind" : "function",
      "comment" : "\nReturns the $(WEB wikipedia.org/wiki/Levenshtein_distance, Levenshtein\ndistance) between $(D s) and $(D t). The Levenshtein distance computes\nthe minimal amount of edit operations necessary to transform $(D s)\ninto $(D t).  Performs $(BIGOH s.length * t.length) evaluations of $(D\nequals) and occupies $(BIGOH s.length * t.length) storage.\n\nExample:\n----\nassert(levenshteinDistance(\"cat\", \"rat\") == 1);\nassert(levenshteinDistance(\"parks\", \"spark\") == 2);\nassert(levenshteinDistance(\"kitten\", \"sitting\") == 3);\n// ignore case\nassert(levenshteinDistance!(\"std.uni.toUpper(a) == std.uni.toUpper(b)\")\n    (\"parks\", \"SPARK\") == 2);\n----\n",
      "line" : 6600,
      "type" : "size_t(Range1 s, Range2 t)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Range1"
       },
       {
        "name" : "t",
        "type" : "Range2"
       }
      ],
      "endline" : 6606
     }
    ]
   },
   {
    "name" : "__unittestL6609_114",
    "kind" : "function",
    "line" : 6609,
    "endline" : 6630
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the Levenshtein distance and the edit path between $(D s) and\n$(D t).\n\nExample:\n---\nstring a = \"Saturday\", b = \"Sunday\";\nauto p = levenshteinDistanceAndPath(a, b);\nassert(p[0] == 3);\nassert(equal(p[1], \"nrrnsnnn\"));\n---\n",
    "line" : 6631,
    "name" : "levenshteinDistanceAndPath",
    "parameters" : [
     {
      "name" : "equals",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "levenshteinDistanceAndPath",
      "kind" : "function",
      "comment" : "\nReturns the Levenshtein distance and the edit path between $(D s) and\n$(D t).\n\nExample:\n---\nstring a = \"Saturday\", b = \"Sunday\";\nauto p = levenshteinDistanceAndPath(a, b);\nassert(p[0] == 3);\nassert(equal(p[1], \"nrrnsnnn\"));\n---\n",
      "line" : 6631,
      "type" : "Tuple!(size_t, EditOp[])(Range1 s, Range2 t)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Range1"
       },
       {
        "name" : "t",
        "type" : "Range2"
       }
      ],
      "endline" : 6638
     }
    ]
   },
   {
    "name" : "__unittestL6640_115",
    "kind" : "function",
    "line" : 6640,
    "endline" : 6700
   },
   {
    "kind" : "template",
    "comment" : "\nCopies the content of $(D source) into $(D target) and returns the\nremaining (unfilled) part of $(D target). See also $(WEB\nsgi.com/tech/stl/_copy.html, STL's _copy). If a behavior similar to\n$(WEB sgi.com/tech/stl/copy_backward.html, STL's copy_backward) is\nneeded, use $(D copy(retro(source), retro(target))). See also $(XREF\nrange, retro).\n\nExample:\n----\nint[] a = [ 1, 5 ];\nint[] b = [ 9, 8 ];\nint[] c = new int[a.length + b.length + 10];\nauto d = copy(b, copy(a, c));\nassert(c[0 .. a.length + b.length] == a ~ b);\nassert(d.length == 10);\n----\n\nAs long as the target range elements support assignment from source\nrange elements, different types of ranges are accepted.\n\nExample:\n----\nfloat[] a = [ 1.0f, 5 ];\ndouble[] b = new double[a.length];\nauto d = copy(a, b);\n----\n\nTo copy at most $(D n) elements from range $(D a) to range $(D b), you\nmay want to use $(D copy(take(a, n), b)). To copy those elements from\nrange $(D a) that satisfy predicate $(D pred) to range $(D b), you may\nwant to use $(D copy(filter!(pred)(a), b)).\n\nExample:\n----\nint[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];\nauto b = new int[a.length];\nauto c = copy(filter!(\"(a & 1) == 1\")(a), b);\nassert(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);\n----\n\n \n",
    "line" : 6700,
    "name" : "copy",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "copy",
      "kind" : "function",
      "comment" : "\nCopies the content of $(D source) into $(D target) and returns the\nremaining (unfilled) part of $(D target). See also $(WEB\nsgi.com/tech/stl/_copy.html, STL's _copy). If a behavior similar to\n$(WEB sgi.com/tech/stl/copy_backward.html, STL's copy_backward) is\nneeded, use $(D copy(retro(source), retro(target))). See also $(XREF\nrange, retro).\n\nExample:\n----\nint[] a = [ 1, 5 ];\nint[] b = [ 9, 8 ];\nint[] c = new int[a.length + b.length + 10];\nauto d = copy(b, copy(a, c));\nassert(c[0 .. a.length + b.length] == a ~ b);\nassert(d.length == 10);\n----\n\nAs long as the target range elements support assignment from source\nrange elements, different types of ranges are accepted.\n\nExample:\n----\nfloat[] a = [ 1.0f, 5 ];\ndouble[] b = new double[a.length];\nauto d = copy(a, b);\n----\n\nTo copy at most $(D n) elements from range $(D a) to range $(D b), you\nmay want to use $(D copy(take(a, n), b)). To copy those elements from\nrange $(D a) that satisfy predicate $(D pred) to range $(D b), you may\nwant to use $(D copy(filter!(pred)(a), b)).\n\nExample:\n----\nint[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];\nauto b = new int[a.length];\nauto c = copy(filter!(\"(a & 1) == 1\")(a), b);\nassert(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);\n----\n\n \n",
      "line" : 6700,
      "type" : "Range2(Range1 source, Range2 target)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "Range1"
       },
       {
        "name" : "target",
        "type" : "Range2"
       }
      ],
      "endline" : 6750
     }
    ]
   },
   {
    "name" : "__unittestL6752_117",
    "kind" : "function",
    "line" : 6752,
    "endline" : 6807
   },
   {
    "kind" : "template",
    "comment" : "\nSwaps all elements of $(D r1) with successive elements in $(D r2).\nReturns a tuple containing the remainder portions of $(D r1) and $(D\nr2) that were not swapped (one of them will be empty). The ranges may\nbe of different types but must have the same element type and support\nswapping.\n\nExample:\n----\nint[] a = [ 100, 101, 102, 103 ];\nint[] b = [ 0, 1, 2, 3 ];\nauto c = swapRanges(a[1 .. 3], b[2 .. 4]);\nassert(c[0].empty && c[1].empty);\nassert(a == [ 100, 2, 3, 103 ]);\nassert(b == [ 0, 1, 101, 102 ]);\n----\n",
    "line" : 6808,
    "name" : "swapRanges",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swapRanges",
      "kind" : "function",
      "comment" : "\nSwaps all elements of $(D r1) with successive elements in $(D r2).\nReturns a tuple containing the remainder portions of $(D r1) and $(D\nr2) that were not swapped (one of them will be empty). The ranges may\nbe of different types but must have the same element type and support\nswapping.\n\nExample:\n----\nint[] a = [ 100, 101, 102, 103 ];\nint[] b = [ 0, 1, 2, 3 ];\nauto c = swapRanges(a[1 .. 3], b[2 .. 4]);\nassert(c[0].empty && c[1].empty);\nassert(a == [ 100, 2, 3, 103 ]);\nassert(b == [ 0, 1, 101, 102 ]);\n----\n",
      "line" : 6808,
      "type" : "Tuple!(Range1, Range2)(Range1 r1, Range2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "Range1"
       },
       {
        "name" : "r2",
        "type" : "Range2"
       }
      ],
      "endline" : 6818
     }
    ]
   },
   {
    "name" : "__unittestL6820_118",
    "kind" : "function",
    "line" : 6820,
    "endline" : 6844
   },
   {
    "kind" : "template",
    "comment" : "\nReverses $(D r) in-place.  Performs $(D r.length / 2) evaluations of $(D\nswap). See also $(WEB sgi.com/tech/stl/_reverse.html, STL's _reverse).\n\nExample:\n----\nint[] arr = [ 1, 2, 3 ];\nreverse(arr);\nassert(arr == [ 3, 2, 1 ]);\n----\n",
    "line" : 6844,
    "name" : "reverse",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "reverse",
      "kind" : "function",
      "comment" : "\nReverses $(D r) in-place.  Performs $(D r.length / 2) evaluations of $(D\nswap). See also $(WEB sgi.com/tech/stl/_reverse.html, STL's _reverse).\n\nExample:\n----\nint[] arr = [ 1, 2, 3 ];\nreverse(arr);\nassert(arr == [ 3, 2, 1 ]);\n----\n",
      "line" : 6844,
      "type" : "void(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 6855
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 6858,
    "name" : "reverse",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "reverse",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 6858,
      "type" : "void(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 6868
     }
    ]
   },
   {
    "name" : "__unittestL6870_119",
    "kind" : "function",
    "line" : 6870,
    "endline" : 6899
   },
   {
    "kind" : "template",
    "comment" : "\nReverses $(D r) in-place, where $(D r) is a narrow string (having\nelements of type $(D char) or $(D wchar)). UTF sequences consisting of\nmultiple code units are preserved properly.\n\nExample:\n----\nchar[] arr = \"hello\\U00010143\\u0100\\U00010143\".dup;\nreverse(arr);\nassert(arr == \"\\U00010143\\u0100\\U00010143olleh\");\n----\n",
    "line" : 6899,
    "name" : "reverse",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "reverse",
      "kind" : "function",
      "comment" : "\nReverses $(D r) in-place, where $(D r) is a narrow string (having\nelements of type $(D char) or $(D wchar)). UTF sequences consisting of\nmultiple code units are preserved properly.\n\nExample:\n----\nchar[] arr = \"hello\\U00010143\\u0100\\U00010143\".dup;\nreverse(arr);\nassert(arr == \"\\U00010143\\u0100\\U00010143olleh\");\n----\n",
      "line" : 6899,
      "type" : "void(Char[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Char[]"
       }
      ],
      "endline" : 6917
     }
    ]
   },
   {
    "name" : "__unittestL6919_120",
    "kind" : "function",
    "line" : 6919,
    "endline" : 6999
   },
   {
    "kind" : "template",
    "comment" : "\nThe $(D bringToFront) function has considerable flexibility and\nusefulness. It can rotate elements in one buffer left or right, swap\nbuffers of equal length, and even move elements across disjoint\nbuffers of different types and different lengths.\n\n$(D bringToFront) takes two ranges $(D front) and $(D back), which may\nbe of different types. Considering the concatenation of $(D front) and\n$(D back) one unified range, $(D bringToFront) rotates that unified\nrange such that all elements in $(D back) are brought to the beginning\nof the unified range. The relative ordering of elements in $(D front)\nand $(D back), respectively, remains unchanged.\n\nThe simplest use of $(D bringToFront) is for rotating elements in a\nbuffer. For example:\n\n----\nauto arr = [4, 5, 6, 7, 1, 2, 3];\nbringToFront(arr[0 .. 4], arr[4 .. $]);\nassert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);\n----\n\nThe $(D front) range may actually \"step over\" the $(D back)\nrange. This is very useful with forward ranges that cannot compute\ncomfortably right-bounded subranges like $(D arr[0 .. 4]) above. In\nthe example below, $(D r2) is a right subrange of $(D r1).\n\n----\nauto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);\nauto r1 = list[];\nauto r2 = list[]; popFrontN(r2, 4);\nassert(equal(r2, [ 1, 2, 3 ]));\nbringToFront(r1, r2);\nassert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));\n----\n\nElements can be swapped across ranges of different types:\n\n----\nauto list = SList!(int)(4, 5, 6, 7);\nauto vec = [ 1, 2, 3 ];\nbringToFront(list[], vec);\nassert(equal(list[], [ 1, 2, 3, 4 ]));\nassert(equal(vec, [ 5, 6, 7 ]));\n----\n\nPerforms $(BIGOH max(front.length, back.length)) evaluations of $(D\nswap). See also $(WEB sgi.com/tech/stl/_rotate.html, STL's rotate).\n\nPreconditions:\n\nEither $(D front) and $(D back) are disjoint, or $(D back) is\nreachable from $(D front) and $(D front) is not reachable from $(D\nback).\n\nReturns:\n\nThe number of elements brought to the front, i.e., the length of $(D\nback).\n",
    "line" : 6999,
    "name" : "bringToFront",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "bringToFront",
      "kind" : "function",
      "comment" : "\nThe $(D bringToFront) function has considerable flexibility and\nusefulness. It can rotate elements in one buffer left or right, swap\nbuffers of equal length, and even move elements across disjoint\nbuffers of different types and different lengths.\n\n$(D bringToFront) takes two ranges $(D front) and $(D back), which may\nbe of different types. Considering the concatenation of $(D front) and\n$(D back) one unified range, $(D bringToFront) rotates that unified\nrange such that all elements in $(D back) are brought to the beginning\nof the unified range. The relative ordering of elements in $(D front)\nand $(D back), respectively, remains unchanged.\n\nThe simplest use of $(D bringToFront) is for rotating elements in a\nbuffer. For example:\n\n----\nauto arr = [4, 5, 6, 7, 1, 2, 3];\nbringToFront(arr[0 .. 4], arr[4 .. $]);\nassert(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);\n----\n\nThe $(D front) range may actually \"step over\" the $(D back)\nrange. This is very useful with forward ranges that cannot compute\ncomfortably right-bounded subranges like $(D arr[0 .. 4]) above. In\nthe example below, $(D r2) is a right subrange of $(D r1).\n\n----\nauto list = SList!(int)(4, 5, 6, 7, 1, 2, 3);\nauto r1 = list[];\nauto r2 = list[]; popFrontN(r2, 4);\nassert(equal(r2, [ 1, 2, 3 ]));\nbringToFront(r1, r2);\nassert(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));\n----\n\nElements can be swapped across ranges of different types:\n\n----\nauto list = SList!(int)(4, 5, 6, 7);\nauto vec = [ 1, 2, 3 ];\nbringToFront(list[], vec);\nassert(equal(list[], [ 1, 2, 3, 4 ]));\nassert(equal(vec, [ 5, 6, 7 ]));\n----\n\nPerforms $(BIGOH max(front.length, back.length)) evaluations of $(D\nswap). See also $(WEB sgi.com/tech/stl/_rotate.html, STL's rotate).\n\nPreconditions:\n\nEither $(D front) and $(D back) are disjoint, or $(D back) is\nreachable from $(D front) and $(D front) is not reachable from $(D\nback).\n\nReturns:\n\nThe number of elements brought to the front, i.e., the length of $(D\nback).\n",
      "line" : 6999,
      "type" : "size_t(Range1 front, Range2 back)",
      "parameters" : [
       {
        "name" : "front",
        "type" : "Range1"
       },
       {
        "name" : "back",
        "type" : "Range2"
       }
      ],
      "endline" : 7057
     }
    ]
   },
   {
    "name" : "__unittestL7059_121",
    "kind" : "function",
    "line" : 7059,
    "endline" : 7174
   },
   {
    "name" : "SwapStrategy",
    "kind" : "enum",
    "comment" : "\nDefines the swapping strategy for algorithms that need to swap\nelements in a range (such as partition and sort). The strategy\nconcerns the swapping of elements that are not the core concern of the\nalgorithm. For example, consider an algorithm that sorts $(D [ \"abc\",\n\"b\", \"aBc\" ]) according to $(D toUpper(a) < toUpper(b)). That\nalgorithm might choose to swap the two equivalent strings $(D \"abc\")\nand $(D \"aBc\"). That does not affect the sorting since both $(D [\n\"abc\", \"aBc\", \"b\" ]) and $(D [ \"aBc\", \"abc\", \"b\" ]) are valid\noutcomes.\n\nSome situations require that the algorithm must NOT ever change the\nrelative ordering of equivalent elements (in the example above, only\n$(D [ \"abc\", \"aBc\", \"b\" ]) would be the correct result). Such\nalgorithms are called $(B stable). If the ordering algorithm may swap\nequivalent elements discretionarily, the ordering is called $(B\nunstable).\n\nYet another class of algorithms may choose an intermediate tradeoff by\nbeing stable only on a well-defined subrange of the range. There is no\nestablished terminology for such behavior; this library calls it $(B\nsemistable).\n\nGenerally, the $(D stable) ordering strategy may be more costly in\ntime and/or space than the other two because it imposes additional\nconstraints. Similarly, $(D semistable) may be costlier than $(D\nunstable). As (semi-)stability is not needed very often, the ordering\nalgorithms in this module parameterized by $(D SwapStrategy) all\nchoose $(D SwapStrategy.unstable) as the default.\n",
    "line" : 7175,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "unstable",
      "kind" : "enum member",
      "comment" : "\n       Allows freely swapping of elements as long as the output\n       satisfies the algorithm's requirements.\n    \n",
      "line" : 7180
     },
     {
      "name" : "semistable",
      "kind" : "enum member",
      "comment" : "\n       In algorithms partitioning ranges in two, preserve relative\n       ordering of elements only to the left of the partition point.\n    \n",
      "line" : 7185
     },
     {
      "name" : "stable",
      "kind" : "enum member",
      "comment" : "\n       Preserve the relative ordering of elements to the largest\n       extent allowed by the algorithm's requirements.\n    \n",
      "line" : 7190
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nEliminates elements at given offsets from $(D range) and returns the\nshortened range. In the simplest call, one element is removed.\n\n----\nint[] a = [ 3, 5, 7, 8 ];\nassert(remove(a, 1) == [ 3, 7, 8 ]);\nassert(a == [ 3, 7, 8, 8 ]);\n----\n\nIn the case above the element at offset $(D 1) is removed and $(D\nremove) returns the range smaller by one element. The original array\nhas remained of the same length because all functions in $(D\nstd.algorithm) only change $(I content), not $(I topology). The value\n$(D 8) is repeated because $(XREF algorithm, move) was invoked to move\nelements around and on integers $(D move) simply copies the source to\nthe destination. To replace $(D a) with the effect of the removal,\nsimply assign $(D a = remove(a, 1)). The slice will be rebound to the\nshorter array and the operation completes with maximal efficiency.\n\nMultiple indices can be passed into $(D remove). In that case,\nelements at the respective indices are all removed. The indices must\nbe passed in increasing order, otherwise an exception occurs.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, 3, 5) ==\n    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);\n----\n\n(Note how all indices refer to slots in the $(I original) array, not\nin the array as it is being progressively shortened.) Finally, any\ncombination of integral offsets and tuples composed of two integral\noffsets can be passed in.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);\n----\n\nIn this case, the slots at positions 1, 3, 4, and 9 are removed from\nthe array. The tuple passes in a range closed to the left and open to\nthe right (consistent with built-in slices), e.g. $(D tuple(3, 5))\nmeans indices $(D 3) and $(D 4) but not $(D 5).\n\nIf the need is to remove some elements in the range but the order of\nthe remaining elements does not have to be preserved, you may want to\npass $(D SwapStrategy.unstable) to $(D remove).\n\n----\nint[] a = [ 0, 1, 2, 3 ];\nassert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);\n----\n\nIn the case above, the element at slot $(D 1) is removed, but replaced\nwith the last element of the range. Taking advantage of the relaxation\nof the stability requirement, $(D remove) moved elements from the end\nof the array over the slots to be removed. This way there is less data\nmovement to be done which improves the execution time of the function.\n\nThe function $(D remove) works on any forward range. The moving\nstrategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==\nSwapStrategy.unstable && isRandomAccessRange!Range &&\nhasLength!Range), then elements are moved from the end of the range\ninto the slots to be filled. In this case, the absolute minimum of\nmoves is performed.)  $(LI Otherwise, if $(D s ==\nSwapStrategy.unstable && isBidirectionalRange!Range &&\nhasLength!Range), then elements are still moved from the end of the\nrange, but time is spent on advancing between slots by repeated calls\nto $(D range.popFront).)  $(LI Otherwise, elements are moved incrementally\ntowards the front of $(D range); a given element is never moved\nseveral times, but more elements are moved than in the previous\ncases.))\n \n",
    "line" : 7267,
    "name" : "remove",
    "parameters" : [
     {
      "name" : "s",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.stable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Offset",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "remove",
      "kind" : "function",
      "comment" : "\nEliminates elements at given offsets from $(D range) and returns the\nshortened range. In the simplest call, one element is removed.\n\n----\nint[] a = [ 3, 5, 7, 8 ];\nassert(remove(a, 1) == [ 3, 7, 8 ]);\nassert(a == [ 3, 7, 8, 8 ]);\n----\n\nIn the case above the element at offset $(D 1) is removed and $(D\nremove) returns the range smaller by one element. The original array\nhas remained of the same length because all functions in $(D\nstd.algorithm) only change $(I content), not $(I topology). The value\n$(D 8) is repeated because $(XREF algorithm, move) was invoked to move\nelements around and on integers $(D move) simply copies the source to\nthe destination. To replace $(D a) with the effect of the removal,\nsimply assign $(D a = remove(a, 1)). The slice will be rebound to the\nshorter array and the operation completes with maximal efficiency.\n\nMultiple indices can be passed into $(D remove). In that case,\nelements at the respective indices are all removed. The indices must\nbe passed in increasing order, otherwise an exception occurs.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, 3, 5) ==\n    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);\n----\n\n(Note how all indices refer to slots in the $(I original) array, not\nin the array as it is being progressively shortened.) Finally, any\ncombination of integral offsets and tuples composed of two integral\noffsets can be passed in.\n\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nassert(remove(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);\n----\n\nIn this case, the slots at positions 1, 3, 4, and 9 are removed from\nthe array. The tuple passes in a range closed to the left and open to\nthe right (consistent with built-in slices), e.g. $(D tuple(3, 5))\nmeans indices $(D 3) and $(D 4) but not $(D 5).\n\nIf the need is to remove some elements in the range but the order of\nthe remaining elements does not have to be preserved, you may want to\npass $(D SwapStrategy.unstable) to $(D remove).\n\n----\nint[] a = [ 0, 1, 2, 3 ];\nassert(remove!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);\n----\n\nIn the case above, the element at slot $(D 1) is removed, but replaced\nwith the last element of the range. Taking advantage of the relaxation\nof the stability requirement, $(D remove) moved elements from the end\nof the array over the slots to be removed. This way there is less data\nmovement to be done which improves the execution time of the function.\n\nThe function $(D remove) works on any forward range. The moving\nstrategy is (listed from fastest to slowest): $(UL $(LI If $(D s ==\nSwapStrategy.unstable && isRandomAccessRange!Range &&\nhasLength!Range), then elements are moved from the end of the range\ninto the slots to be filled. In this case, the absolute minimum of\nmoves is performed.)  $(LI Otherwise, if $(D s ==\nSwapStrategy.unstable && isBidirectionalRange!Range &&\nhasLength!Range), then elements are still moved from the end of the\nrange, but time is spent on advancing between slots by repeated calls\nto $(D range.popFront).)  $(LI Otherwise, elements are moved incrementally\ntowards the front of $(D range); a given element is never moved\nseveral times, but more elements are moved than in the previous\ncases.))\n \n",
      "line" : 7267,
      "type" : "Range(Range range, Offset offset)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "offset",
        "type" : "Offset"
       }
      ],
      "endline" : 7370
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 7373,
    "name" : "remove",
    "parameters" : [
     {
      "name" : "s",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.stable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Offset",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "remove",
      "kind" : "function",
      "line" : 7373,
      "type" : "Range(Range range, Offset offset)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "offset",
        "type" : "Offset"
       }
      ],
      "endline" : 7407
     }
    ]
   },
   {
    "name" : "__unittestL7409_122",
    "kind" : "function",
    "line" : 7409,
    "endline" : 7459
   },
   {
    "kind" : "template",
    "comment" : "\nReduces the length of the bidirectional range $(D range) by removing\nelements that satisfy $(D pred). If $(D s = SwapStrategy.unstable),\nelements are moved from the right end of the range over the elements\nto eliminate. If $(D s = SwapStrategy.stable) (the default),\nelements are moved progressively to front such that their relative\norder is preserved. Returns the filtered range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];\nassert(remove!(\"a == 2\")(a) == [ 1, 3, 3, 4, 5, 5, 6 ]);\n----\n \n",
    "line" : 7459,
    "name" : "remove",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "s",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.stable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "remove",
      "kind" : "function",
      "comment" : "\nReduces the length of the bidirectional range $(D range) by removing\nelements that satisfy $(D pred). If $(D s = SwapStrategy.unstable),\nelements are moved from the right end of the range over the elements\nto eliminate. If $(D s = SwapStrategy.stable) (the default),\nelements are moved progressively to front such that their relative\norder is preserved. Returns the filtered range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];\nassert(remove!(\"a == 2\")(a) == [ 1, 3, 3, 4, 5, 5, 6 ]);\n----\n \n",
      "line" : 7459,
      "type" : "Range(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 7495
     }
    ]
   },
   {
    "name" : "__unittestL7497_123",
    "kind" : "function",
    "line" : 7497,
    "endline" : 7639
   },
   {
    "kind" : "template",
    "comment" : "\nPartitions a range in two using $(D pred) as a\npredicate. Specifically, reorders the range $(D r = [left,\nright$(RPAREN)) using $(D swap) such that all elements $(D i) for\nwhich $(D pred(i)) is $(D true) come before all elements $(D j) for\nwhich $(D pred(j)) returns $(D false).\n\nPerforms $(BIGOH r.length) (if unstable or semistable) or $(BIGOH\nr.length * log(r.length)) (if stable) evaluations of $(D less) and $(D\nswap). The unstable version computes the minimum possible evaluations\nof $(D swap) (roughly half of those performed by the semistable\nversion).\n\nSee also STL's $(WEB sgi.com/tech/stl/_partition.html, _partition) and\n$(WEB sgi.com/tech/stl/stable_partition.html, stable_partition).\n\nReturns:\n\nThe right part of $(D r) after partitioning.\n\nIf $(D ss == SwapStrategy.stable), $(D partition) preserves the\nrelative ordering of all elements $(D a), $(D b) in $(D r) for which\n$(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D\npartition) preserves the relative ordering of all elements $(D a), $(D\nb) in the left part of $(D r) for which $(D pred(a) == pred(b)).\n\nExample:\n\n----\nauto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto arr = Arr.dup;\nstatic bool even(int a) { return (a & 1) == 0; }\n// Partition arr such that even numbers come first\nauto r = partition!(even)(arr);\n// Now arr is separated in evens and odds.\n// Numbers may have become shuffled due to instability\nassert(r == arr[5 .. $]);\nassert(count!(even)(arr[0 .. 5]) == 5);\nassert(find!(even)(r).empty);\n\n// Can also specify the predicate as a string.\n// Use 'a' as the predicate argument name\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0})(arr);\nassert(r == arr[5 .. $]);\n\n// Now for a stable partition:\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);\n// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1\nassert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && r == arr[5 .. $]);\n\n// In case the predicate needs to hold its own state, use a delegate:\narr[] = Arr[];\nint x = 3;\n// Put stuff greater than 3 on the left\nbool fun(int a) { return a > x; }\nr = partition!(fun, SwapStrategy.semistable)(arr);\n// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2\nassert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && r == arr[7 .. $]);\n----\n",
    "line" : 7639,
    "name" : "partition",
    "parameters" : [
     {
      "name" : "predicate",
      "kind" : "alias"
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "partition",
      "kind" : "function",
      "comment" : "\nPartitions a range in two using $(D pred) as a\npredicate. Specifically, reorders the range $(D r = [left,\nright$(RPAREN)) using $(D swap) such that all elements $(D i) for\nwhich $(D pred(i)) is $(D true) come before all elements $(D j) for\nwhich $(D pred(j)) returns $(D false).\n\nPerforms $(BIGOH r.length) (if unstable or semistable) or $(BIGOH\nr.length * log(r.length)) (if stable) evaluations of $(D less) and $(D\nswap). The unstable version computes the minimum possible evaluations\nof $(D swap) (roughly half of those performed by the semistable\nversion).\n\nSee also STL's $(WEB sgi.com/tech/stl/_partition.html, _partition) and\n$(WEB sgi.com/tech/stl/stable_partition.html, stable_partition).\n\nReturns:\n\nThe right part of $(D r) after partitioning.\n\nIf $(D ss == SwapStrategy.stable), $(D partition) preserves the\nrelative ordering of all elements $(D a), $(D b) in $(D r) for which\n$(D pred(a) == pred(b)). If $(D ss == SwapStrategy.semistable), $(D\npartition) preserves the relative ordering of all elements $(D a), $(D\nb) in the left part of $(D r) for which $(D pred(a) == pred(b)).\n\nExample:\n\n----\nauto Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto arr = Arr.dup;\nstatic bool even(int a) { return (a & 1) == 0; }\n// Partition arr such that even numbers come first\nauto r = partition!(even)(arr);\n// Now arr is separated in evens and odds.\n// Numbers may have become shuffled due to instability\nassert(r == arr[5 .. $]);\nassert(count!(even)(arr[0 .. 5]) == 5);\nassert(find!(even)(r).empty);\n\n// Can also specify the predicate as a string.\n// Use 'a' as the predicate argument name\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0})(arr);\nassert(r == arr[5 .. $]);\n\n// Now for a stable partition:\narr[] = Arr[];\nr = partition!(q{(a & 1) == 0}, SwapStrategy.stable)(arr);\n// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1\nassert(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] && r == arr[5 .. $]);\n\n// In case the predicate needs to hold its own state, use a delegate:\narr[] = Arr[];\nint x = 3;\n// Put stuff greater than 3 on the left\nbool fun(int a) { return a > x; }\nr = partition!(fun, SwapStrategy.semistable)(arr);\n// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2\nassert(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] && r == arr[7 .. $]);\n----\n",
      "line" : 7639,
      "type" : "Range(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 7716
     }
    ]
   },
   {
    "name" : "__unittestL7718_124",
    "kind" : "function",
    "line" : 7718,
    "endline" : 7769
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D r) is partitioned according to predicate $(D\npred).\n\nExample:\n----\nint[] r = [ 1, 3, 5, 7, 8, 2, 4, ];\nassert(isPartitioned!(\"a & 1\")(r));\n----\n \n",
    "line" : 7769,
    "name" : "isPartitioned",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isPartitioned",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if $(D r) is partitioned according to predicate $(D\npred).\n\nExample:\n----\nint[] r = [ 1, 3, 5, 7, 8, 2, 4, ];\nassert(isPartitioned!(\"a & 1\")(r));\n----\n \n",
      "line" : 7769,
      "type" : "bool(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 7782
     }
    ]
   },
   {
    "name" : "__unittestL7784_125",
    "kind" : "function",
    "line" : 7784,
    "endline" : 7814
   },
   {
    "kind" : "template",
    "comment" : "\nRearranges elements in $(D r) in three adjacent ranges and returns\nthem. The first and leftmost range only contains elements in $(D r)\nless than $(D pivot). The second and middle range only contains\nelements in $(D r) that are equal to $(D pivot). Finally, the third\nand rightmost range only contains elements in $(D r) that are greater\nthan $(D pivot). The less-than test is defined by the binary function\n$(D less).\n\nExample:\n----\nauto a = [ 8, 3, 4, 1, 4, 7, 4 ];\nauto pieces = partition3(a, 4);\nassert(a == [ 1, 3, 4, 4, 4, 7, 8 ]);\nassert(pieces[0] == [ 1, 3 ]);\nassert(pieces[1] == [ 4, 4, 4 ]);\nassert(pieces[2] == [ 7, 8 ]);\n----\n\nBUGS: stable $(D partition3) has not been implemented yet.\n \n",
    "line" : 7815,
    "name" : "partition3",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "partition3",
      "kind" : "function",
      "comment" : "\nRearranges elements in $(D r) in three adjacent ranges and returns\nthem. The first and leftmost range only contains elements in $(D r)\nless than $(D pivot). The second and middle range only contains\nelements in $(D r) that are equal to $(D pivot). Finally, the third\nand rightmost range only contains elements in $(D r) that are greater\nthan $(D pivot). The less-than test is defined by the binary function\n$(D less).\n\nExample:\n----\nauto a = [ 8, 3, 4, 1, 4, 7, 4 ];\nauto pieces = partition3(a, 4);\nassert(a == [ 1, 3, 4, 4, 4, 7, 8 ]);\nassert(pieces[0] == [ 1, 3 ]);\nassert(pieces[1] == [ 4, 4, 4 ]);\nassert(pieces[2] == [ 7, 8 ]);\n----\n\nBUGS: stable $(D partition3) has not been implemented yet.\n \n",
      "line" : 7815,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r, E pivot)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "pivot",
        "type" : "E"
       }
      ],
      "endline" : 7863
     }
    ]
   },
   {
    "name" : "__unittestL7865_126",
    "kind" : "function",
    "line" : 7865,
    "endline" : 7932
   },
   {
    "kind" : "template",
    "comment" : "\nReorders the range $(D r) using $(D swap) such that $(D r[nth]) refers\nto the element that would fall there if the range were fully\nsorted. In addition, it also partitions $(D r) such that all elements\n$(D e1) from $(D r[0]) to $(D r[nth]) satisfy $(D !less(r[nth], e1)),\nand all elements $(D e2) from $(D r[nth]) to $(D r[r.length]) satisfy\n$(D !less(e2, r[nth])). Effectively, it finds the nth smallest\n(according to $(D less)) elements in $(D r). Performs an expected\n$(BIGOH r.length) (if unstable) or $(BIGOH r.length * log(r.length))\n(if stable) evaluations of $(D less) and $(D swap). See also $(WEB\nsgi.com/tech/stl/nth_element.html, STL's nth_element).\n\nIf $(D n >= r.length), the algorithm has no effect.\n\nExamples:\n----\nint[] v = [ 25, 7, 9, 2, 0, 5, 21 ];\nauto n = 4;\ntopN!(less)(v, n);\nassert(v[n] == 9);\n// Equivalent form:\ntopN!(\"a < b\")(v, n);\nassert(v[n] == 9);\n----\n\nBUGS:\n\nStable topN has not been implemented yet.\n",
    "line" : 7932,
    "name" : "topN",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "topN",
      "kind" : "function",
      "comment" : "\nReorders the range $(D r) using $(D swap) such that $(D r[nth]) refers\nto the element that would fall there if the range were fully\nsorted. In addition, it also partitions $(D r) such that all elements\n$(D e1) from $(D r[0]) to $(D r[nth]) satisfy $(D !less(r[nth], e1)),\nand all elements $(D e2) from $(D r[nth]) to $(D r[r.length]) satisfy\n$(D !less(e2, r[nth])). Effectively, it finds the nth smallest\n(according to $(D less)) elements in $(D r). Performs an expected\n$(BIGOH r.length) (if unstable) or $(BIGOH r.length * log(r.length))\n(if stable) evaluations of $(D less) and $(D swap). See also $(WEB\nsgi.com/tech/stl/nth_element.html, STL's nth_element).\n\nIf $(D n >= r.length), the algorithm has no effect.\n\nExamples:\n----\nint[] v = [ 25, 7, 9, 2, 0, 5, 21 ];\nauto n = 4;\ntopN!(less)(v, n);\nassert(v[n] == 9);\n// Equivalent form:\ntopN!(\"a < b\")(v, n);\nassert(v[n] == 9);\n----\n\nBUGS:\n\nStable topN has not been implemented yet.\n",
      "line" : 7932,
      "type" : "void(Range r, size_t nth)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "nth",
        "type" : "size_t"
       }
      ],
      "endline" : 7964
     }
    ]
   },
   {
    "name" : "__unittestL7966_132",
    "kind" : "function",
    "line" : 7966,
    "endline" : 8014
   },
   {
    "name" : "__unittestL8014_133",
    "kind" : "function",
    "line" : 8014,
    "endline" : 8037
   },
   {
    "kind" : "template",
    "comment" : "\nStores the smallest elements of the two ranges in the left-hand range.\n \n",
    "line" : 8037,
    "name" : "topN",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "topN",
      "kind" : "function",
      "comment" : "\nStores the smallest elements of the two ranges in the left-hand range.\n \n",
      "line" : 8037,
      "type" : "void(Range1 r1, Range2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "Range1"
       },
       {
        "name" : "r2",
        "type" : "Range2"
       }
      ],
      "endline" : 8050
     }
    ]
   },
   {
    "name" : "__unittestL8053_134",
    "kind" : "function",
    "comment" : " Ditto\n",
    "line" : 8053,
    "endline" : 8103
   },
   {
    "kind" : "template",
    "comment" : "\nSorts a random-access range according to the predicate $(D less). Performs\n$(BIGOH r.length * log(r.length)) (if unstable) or $(BIGOH r.length *\nlog(r.length) * log(r.length)) (if stable) evaluations of $(D less)\nand $(D swap). See also STL's $(WEB sgi.com/tech/stl/_sort.html, _sort)\nand $(WEB sgi.com/tech/stl/stable_sort.html, stable_sort).\n\n$(D sort) returns a $(XREF range, SortedRange) over the original range, which\nfunctions that can take advantage of sorted data can then use to know that the\nrange is sorted and adjust accordingly. The $(XREF range, SortedRange) is a\nwrapper around the original range, so both it and the original range are sorted,\nbut other functions won't know that the original range has been sorted, whereas\nthey $(I can) know that $(XREF range, SortedRange) has been sorted.\n\nSee_Also:\n    $(XREF range, assumeSorted)\n\nRemark: Stable sort is implementated as Timsort, the original code at\n$(WEB github.com/Xinok/XSort, XSort) by Xinok, public domain.\n\nExample:\n----\nint[] array = [ 1, 2, 3, 4 ];\n// sort in descending order\nsort!(\"a > b\")(array);\nassert(array == [ 4, 3, 2, 1 ]);\n// sort in ascending order\nsort(array);\nassert(array == [ 1, 2, 3, 4 ]);\n// sort with a delegate\nbool myComp(int x, int y) { return x > y; }\nsort!(myComp)(array);\nassert(array == [ 4, 3, 2, 1 ]);\n// Showcase stable sorting\nstring[] words = [ \"aBc\", \"a\", \"abc\", \"b\", \"ABC\", \"c\" ];\nsort!(\"toUpper(a) < toUpper(b)\", SwapStrategy.stable)(words);\nassert(words == [ \"a\", \"aBc\", \"abc\", \"ABC\", \"b\", \"c\" ]);\n----\n",
    "line" : 8104,
    "name" : "sort",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sort",
      "kind" : "function",
      "comment" : "\nSorts a random-access range according to the predicate $(D less). Performs\n$(BIGOH r.length * log(r.length)) (if unstable) or $(BIGOH r.length *\nlog(r.length) * log(r.length)) (if stable) evaluations of $(D less)\nand $(D swap). See also STL's $(WEB sgi.com/tech/stl/_sort.html, _sort)\nand $(WEB sgi.com/tech/stl/stable_sort.html, stable_sort).\n\n$(D sort) returns a $(XREF range, SortedRange) over the original range, which\nfunctions that can take advantage of sorted data can then use to know that the\nrange is sorted and adjust accordingly. The $(XREF range, SortedRange) is a\nwrapper around the original range, so both it and the original range are sorted,\nbut other functions won't know that the original range has been sorted, whereas\nthey $(I can) know that $(XREF range, SortedRange) has been sorted.\n\nSee_Also:\n    $(XREF range, assumeSorted)\n\nRemark: Stable sort is implementated as Timsort, the original code at\n$(WEB github.com/Xinok/XSort, XSort) by Xinok, public domain.\n\nExample:\n----\nint[] array = [ 1, 2, 3, 4 ];\n// sort in descending order\nsort!(\"a > b\")(array);\nassert(array == [ 4, 3, 2, 1 ]);\n// sort in ascending order\nsort(array);\nassert(array == [ 1, 2, 3, 4 ]);\n// sort with a delegate\nbool myComp(int x, int y) { return x > y; }\nsort!(myComp)(array);\nassert(array == [ 4, 3, 2, 1 ]);\n// Showcase stable sorting\nstring[] words = [ \"aBc\", \"a\", \"abc\", \"b\", \"ABC\", \"c\" ];\nsort!(\"toUpper(a) < toUpper(b)\", SwapStrategy.stable)(words);\nassert(words == [ \"a\", \"aBc\", \"abc\", \"ABC\", \"b\", \"c\" ]);\n----\n",
      "line" : 8104,
      "type" : "SortedRange!(Range, less)(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 8143
     }
    ]
   },
   {
    "name" : "__unittestL8145_135",
    "kind" : "function",
    "line" : 8145,
    "endline" : 8191
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 8191,
    "name" : "validPredicates",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "less",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n$(D void multiSort(Range)(Range r)\n    if (validPredicates!(ElementType!Range, less));)\n\nSorts a range by multiple keys. The call $(D multiSort!(\"a.id < b.id\",\n\"a.date > b.date\")(r)) sorts the range $(D r) by $(D id) ascending,\nand sorts elements that have the same $(D id) by $(D date)\ndescending. Such a call is equivalent to $(D sort!\"a.id != b.id ? a.id\n< b.id : a.date > b.date\"(r)), but $(D multiSort) is faster because it\ndoes fewer comparisons (in addition to being more convenient).\n\nExample:\n----\nstatic struct Point { int x, y; }\nauto pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];\nauto pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];\nmultiSort!(\"a.x < b.x\", \"a.y < b.y\", SwapStrategy.unstable)(pts1);\nassert(pts1 == pts2);\n----\n \n",
    "line" : 8222,
    "name" : "multiSort",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 8224,
      "name" : "multiSort",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "multiSort",
        "kind" : "function",
        "line" : 8224,
        "type" : "void(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 8263
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL8266_137",
    "kind" : "function",
    "line" : 8266,
    "endline" : 8280
   },
   {
    "name" : "__unittestL8280_138",
    "kind" : "function",
    "line" : 8280,
    "endline" : 8304
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 8304,
    "name" : "getPivot",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "getPivot",
      "kind" : "function",
      "line" : 8304,
      "type" : "size_t(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 8342
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 8344,
    "name" : "optimisticInsertionSort",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "optimisticInsertionSort",
      "kind" : "function",
      "line" : 8344,
      "type" : "void(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 8362
     }
    ]
   },
   {
    "name" : "__unittestL8364_139",
    "kind" : "function",
    "line" : 8364,
    "endline" : 8379
   },
   {
    "kind" : "template",
    "line" : 8379,
    "name" : "swapAt",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swapAt",
      "kind" : "function",
      "line" : 8379,
      "type" : "void(R r, size_t i1, size_t i2)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       },
       {
        "name" : "i1",
        "type" : "size_t"
       },
       {
        "name" : "i2",
        "type" : "size_t"
       }
      ],
      "endline" : 8393
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 8395,
    "name" : "quickSortImpl",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "quickSortImpl",
      "kind" : "function",
      "line" : 8395,
      "type" : "void(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 8441
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 8453,
    "name" : "TimSortImpl",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "T",
      "kind" : "alias",
      "line" : 8460,
      "type" : "ElementType!(R)"
     },
     {
      "name" : "less",
      "kind" : "alias",
      "line" : 8462,
      "type" : "binaryFun!(pred)"
     },
     {
      "name" : "greater",
      "kind" : "function",
      "line" : 8463,
      "type" : "bool(T a, T b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T"
       },
       {
        "name" : "b",
        "type" : "T"
       }
      ],
      "endline" : 8463
     },
     {
      "name" : "greaterEqual",
      "kind" : "function",
      "line" : 8464,
      "type" : "bool(T a, T b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T"
       },
       {
        "name" : "b",
        "type" : "T"
       }
      ],
      "endline" : 8464
     },
     {
      "name" : "lessEqual",
      "kind" : "function",
      "line" : 8465,
      "type" : "bool(T a, T b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T"
       },
       {
        "name" : "b",
        "type" : "T"
       }
      ],
      "endline" : 8465
     },
     {
      "name" : "minimalMerge",
      "kind" : "variable",
      "line" : 8467,
      "storageClass" : [
       "enum"
      ],
      "init" : "128"
     },
     {
      "name" : "minimalGallop",
      "kind" : "variable",
      "line" : 8468,
      "storageClass" : [
       "enum"
      ],
      "init" : "7"
     },
     {
      "name" : "minimalStorage",
      "kind" : "variable",
      "line" : 8469,
      "storageClass" : [
       "enum"
      ],
      "init" : "256"
     },
     {
      "name" : "stackSize",
      "kind" : "variable",
      "line" : 8470,
      "storageClass" : [
       "enum"
      ],
      "init" : "40"
     },
     {
      "name" : "Slice",
      "kind" : "struct",
      "line" : 8472,
      "members" : [
       {
        "name" : "base",
        "kind" : "variable",
        "line" : 8472,
        "type" : "size_t"
       },
       {
        "name" : "length",
        "kind" : "variable",
        "line" : 8472,
        "type" : "size_t"
       }
      ]
     },
     {
      "name" : "sort",
      "kind" : "function",
      "line" : 8475,
      "type" : "void(R range, T[] temp)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "temp",
        "type" : "T[]"
       }
      ],
      "endline" : 8549
     },
     {
      "name" : "minRunLength",
      "kind" : "function",
      "line" : 8553,
      "type" : "size_t(size_t n)",
      "parameters" : [
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 8558
     },
     {
      "name" : "firstRun",
      "kind" : "function",
      "line" : 8561,
      "type" : "size_t(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 8581
     },
     {
      "name" : "binaryInsertionSort",
      "kind" : "function",
      "line" : 8584,
      "type" : "void(R range, size_t sortedLen = 1)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "sortedLen",
        "type" : "size_t",
        "default" : "1"
       }
      ],
      "endline" : 8611
     },
     {
      "name" : "mergeAt",
      "kind" : "function",
      "line" : 8614,
      "type" : "void(R range, Slice[] stack, immutable size_t at, ref size_t minGallop, ref T[] temp)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "stack",
        "type" : "Slice[]"
       },
       {
        "name" : "at",
        "type" : "size_t",
        "storageClass" : [
         "immutable"
        ]
       },
       {
        "name" : "minGallop",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "temp",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 8632
     },
     {
      "name" : "merge",
      "kind" : "function",
      "line" : 8636,
      "type" : "void(R range, size_t mid, ref size_t minGallop, ref T[] temp)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "mid",
        "type" : "size_t"
       },
       {
        "name" : "minGallop",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "temp",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 8668
     },
     {
      "name" : "ensureCapacity",
      "kind" : "function",
      "line" : 8671,
      "type" : "T[](size_t minCapacity, T[] temp)",
      "parameters" : [
       {
        "name" : "minCapacity",
        "type" : "size_t"
       },
       {
        "name" : "temp",
        "type" : "T[]"
       }
      ],
      "endline" : 8688
     },
     {
      "name" : "mergeLo",
      "kind" : "function",
      "line" : 8692,
      "type" : "size_t(R range, immutable size_t mid, size_t minGallop, T[] temp)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "mid",
        "type" : "size_t",
        "storageClass" : [
         "immutable"
        ]
       },
       {
        "name" : "minGallop",
        "type" : "size_t"
       },
       {
        "name" : "temp",
        "type" : "T[]"
       }
      ],
      "endline" : 8769
     },
     {
      "name" : "mergeHi",
      "kind" : "function",
      "line" : 8773,
      "type" : "size_t(R range, immutable size_t mid, size_t minGallop, T[] temp)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "mid",
        "type" : "size_t",
        "storageClass" : [
         "immutable"
        ]
       },
       {
        "name" : "minGallop",
        "type" : "size_t"
       },
       {
        "name" : "temp",
        "type" : "T[]"
       }
      ],
      "endline" : 8871
     },
     {
      "kind" : "template",
      "line" : 8874,
      "name" : "gallopSearch",
      "parameters" : [
       {
        "name" : "forwardReverse",
        "kind" : "value",
        "deco" : "b"
       },
       {
        "name" : "lowerUpper",
        "kind" : "value",
        "deco" : "b"
       }
      ],
      "members" : [
       {
        "kind" : "template",
        "line" : 8877,
        "name" : "gallopSearch",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "gallopSearch",
          "kind" : "function",
          "line" : 8877,
          "type" : "size_t(R range, T value)",
          "parameters" : [
           {
            "name" : "range",
            "type" : "R"
           },
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 8945
         }
        ]
       }
      ]
     },
     {
      "name" : "gallopForwardLower",
      "kind" : "alias",
      "line" : 8948,
      "type" : "gallopSearch!(false, false)"
     },
     {
      "name" : "gallopForwardUpper",
      "kind" : "alias",
      "line" : 8949,
      "type" : "gallopSearch!(false, true)"
     },
     {
      "name" : "gallopReverseLower",
      "kind" : "alias",
      "line" : 8950,
      "type" : "gallopSearch!(true, false)"
     },
     {
      "name" : "gallopReverseUpper",
      "kind" : "alias",
      "line" : 8951,
      "type" : "gallopSearch!(true, true)"
     }
    ]
   },
   {
    "name" : "__unittestL8954_140",
    "kind" : "function",
    "line" : 8954,
    "endline" : 9028
   },
   {
    "name" : "__unittestL9028_141",
    "kind" : "function",
    "line" : 9028,
    "endline" : 9037
   },
   {
    "name" : "__unittestL9037_142",
    "kind" : "function",
    "line" : 9037,
    "endline" : 9085
   },
   {
    "kind" : "template",
    "comment" : "\nSorts a range using an algorithm akin to the $(WEB\nwikipedia.org/wiki/Schwartzian_transform, Schwartzian transform), also\nknown as the decorate-sort-undecorate pattern in Python and Lisp. (Not\nto be confused with $(WEB youtube.com/watch?v=UHw6KXbvazs, the other\nSchwartz).) This function is helpful when the sort comparison includes\nan expensive computation. The complexity is the same as that of the\ncorresponding $(D sort), but $(D schwartzSort) evaluates $(D\ntransform) only $(D r.length) times (less than half when compared to\nregular sorting). The usage can be best illustrated with an example.\n\nExamples:\n----\nuint hashFun(string) { ... expensive computation ... }\nstring[] array = ...;\n// Sort strings by hash, slow\nsort!((a, b) => hashFun(a) < hashFun(b))(array);\n// Sort strings by hash, fast (only computes arr.length hashes):\nschwartzSort!(hashFun, \"a < b\")(array);\n----\n\nThe $(D schwartzSort) function might require less temporary data and\nbe faster than the Perl idiom or the decorate-sort-undecorate idiom\npresent in Python and Lisp. This is because sorting is done in-place\nand only minimal extra data (one array of transformed elements) is\ncreated.\n\nTo check whether an array was sorted and benefit of the speedup of\nSchwartz sorting, a function $(D schwartzIsSorted) is not provided\nbecause the effect can be achieved by calling $(D\nisSorted!less(map!transform(r))).\n\nReturns: The initial range wrapped as a $(D SortedRange) with the\npredicate $(D (a, b) => binaryFun!less(transform(a),\ntransform(b))).\n \n",
    "line" : 9087,
    "name" : "schwartzSort",
    "parameters" : [
     {
      "name" : "transform",
      "kind" : "alias"
     },
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "schwartzSort",
      "kind" : "function",
      "comment" : "\nSorts a range using an algorithm akin to the $(WEB\nwikipedia.org/wiki/Schwartzian_transform, Schwartzian transform), also\nknown as the decorate-sort-undecorate pattern in Python and Lisp. (Not\nto be confused with $(WEB youtube.com/watch?v=UHw6KXbvazs, the other\nSchwartz).) This function is helpful when the sort comparison includes\nan expensive computation. The complexity is the same as that of the\ncorresponding $(D sort), but $(D schwartzSort) evaluates $(D\ntransform) only $(D r.length) times (less than half when compared to\nregular sorting). The usage can be best illustrated with an example.\n\nExamples:\n----\nuint hashFun(string) { ... expensive computation ... }\nstring[] array = ...;\n// Sort strings by hash, slow\nsort!((a, b) => hashFun(a) < hashFun(b))(array);\n// Sort strings by hash, fast (only computes arr.length hashes):\nschwartzSort!(hashFun, \"a < b\")(array);\n----\n\nThe $(D schwartzSort) function might require less temporary data and\nbe faster than the Perl idiom or the decorate-sort-undecorate idiom\npresent in Python and Lisp. This is because sorting is done in-place\nand only minimal extra data (one array of transformed elements) is\ncreated.\n\nTo check whether an array was sorted and benefit of the speedup of\nSchwartz sorting, a function $(D schwartzIsSorted) is not provided\nbecause the effect can be achieved by calling $(D\nisSorted!less(map!transform(r))).\n\nReturns: The initial range wrapped as a $(D SortedRange) with the\npredicate $(D (a, b) => binaryFun!less(transform(a),\ntransform(b))).\n \n",
      "line" : 9087,
      "type" : "SortedRange!(R, (a, b) => binaryFun!(less)(unaryFun!(transform)(a), unaryFun!(transform)(b)))(R r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       }
      ],
      "endline" : 9119
     }
    ]
   },
   {
    "name" : "__unittestL9121_149",
    "kind" : "function",
    "line" : 9121,
    "endline" : 9128
   },
   {
    "name" : "__unittestL9128_151",
    "kind" : "function",
    "line" : 9128,
    "endline" : 9135
   },
   {
    "name" : "__unittestL9135_152",
    "kind" : "function",
    "line" : 9135,
    "endline" : 9164
   },
   {
    "name" : "__unittestL9164_153",
    "kind" : "function",
    "line" : 9164,
    "endline" : 9209
   },
   {
    "kind" : "template",
    "comment" : "\nReorders the random-access range $(D r) such that the range $(D r[0\n.. mid]) is the same as if the entire $(D r) were sorted, and leaves\nthe range $(D r[mid .. r.length]) in no particular order. Performs\n$(BIGOH r.length * log(mid)) evaluations of $(D pred). The\nimplementation simply calls $(D topN!(less, ss)(r, n)) and then $(D\nsort!(less, ss)(r[0 .. n])).\n\nExample:\n----\nint[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];\npartialSort(a, 5);\nassert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);\n----\n",
    "line" : 9209,
    "name" : "partialSort",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "partialSort",
      "kind" : "function",
      "comment" : "\nReorders the random-access range $(D r) such that the range $(D r[0\n.. mid]) is the same as if the entire $(D r) were sorted, and leaves\nthe range $(D r[mid .. r.length]) in no particular order. Performs\n$(BIGOH r.length * log(mid)) evaluations of $(D pred). The\nimplementation simply calls $(D topN!(less, ss)(r, n)) and then $(D\nsort!(less, ss)(r[0 .. n])).\n\nExample:\n----\nint[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];\npartialSort(a, 5);\nassert(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);\n----\n",
      "line" : 9209,
      "type" : "void(Range r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 9215
     }
    ]
   },
   {
    "name" : "__unittestL9217_154",
    "kind" : "function",
    "line" : 9217,
    "endline" : 9245
   },
   {
    "kind" : "template",
    "comment" : "\nSorts the random-access range $(D chain(lhs, rhs)) according to\npredicate $(D less). The left-hand side of the range $(D lhs) is\nassumed to be already sorted; $(D rhs) is assumed to be unsorted. The\nexact strategy chosen depends on the relative sizes of $(D lhs) and\n$(D rhs).  Performs $(BIGOH lhs.length + rhs.length * log(rhs.length))\n(best case) to $(BIGOH (lhs.length + rhs.length) * log(lhs.length +\nrhs.length)) (worst-case) evaluations of $(D swap).\n\nExample:\n----\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 4, 0, 6, 5 ];\ncompleteSort(assumeSorted(a), b);\nassert(a == [ 0, 1, 2 ]);\nassert(b == [ 3, 4, 5, 6 ]);\n----\n",
    "line" : 9245,
    "name" : "completeSort",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "completeSort",
      "kind" : "function",
      "comment" : "\nSorts the random-access range $(D chain(lhs, rhs)) according to\npredicate $(D less). The left-hand side of the range $(D lhs) is\nassumed to be already sorted; $(D rhs) is assumed to be unsorted. The\nexact strategy chosen depends on the relative sizes of $(D lhs) and\n$(D rhs).  Performs $(BIGOH lhs.length + rhs.length * log(rhs.length))\n(best case) to $(BIGOH (lhs.length + rhs.length) * log(lhs.length +\nrhs.length)) (worst-case) evaluations of $(D swap).\n\nExample:\n----\nint[] a = [ 1, 2, 3 ];\nint[] b = [ 4, 0, 6, 5 ];\ncompleteSort(assumeSorted(a), b);\nassert(a == [ 0, 1, 2 ]);\nassert(b == [ 3, 4, 5, 6 ]);\n----\n",
      "line" : 9245,
      "type" : "void(SortedRange!(Range1, less) lhs, Range2 rhs)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "SortedRange!(Range1, less)"
       },
       {
        "name" : "rhs",
        "type" : "Range2"
       }
      ],
      "endline" : 9259
     }
    ]
   },
   {
    "name" : "__unittestL9261_155",
    "kind" : "function",
    "line" : 9261,
    "endline" : 9291
   },
   {
    "kind" : "template",
    "comment" : "\nChecks whether a forward range is sorted according to the comparison\noperation $(D less). Performs $(BIGOH r.length) evaluations of $(D\nless).\n\nExample:\n----\nint[] arr = [4, 3, 2, 1];\nassert(!isSorted(arr));\nsort(arr);\nassert(isSorted(arr));\nsort!(\"a > b\")(arr);\nassert(isSorted!(\"a > b\")(arr));\n----\n",
    "line" : 9291,
    "name" : "isSorted",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSorted",
      "kind" : "function",
      "comment" : "\nChecks whether a forward range is sorted according to the comparison\noperation $(D less). Performs $(BIGOH r.length) evaluations of $(D\nless).\n\nExample:\n----\nint[] arr = [4, 3, 2, 1];\nassert(!isSorted(arr));\nsort(arr);\nassert(isSorted(arr));\nsort!(\"a > b\")(arr);\nassert(isSorted!(\"a > b\")(arr));\n----\n",
      "line" : 9291,
      "type" : "bool(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 9330
     }
    ]
   },
   {
    "name" : "__unittestL9332_156",
    "kind" : "function",
    "line" : 9332,
    "endline" : 9398
   },
   {
    "kind" : "template",
    "comment" : "\nComputes an index for $(D r) based on the comparison $(D less). The\nindex is a sorted array of pointers or indices into the original\nrange. This technique is similar to sorting, but it is more flexible\nbecause (1) it allows \"sorting\" of immutable collections, (2) allows\nbinary search even if the original collection does not offer random\naccess, (3) allows multiple indexes, each on a different predicate,\nand (4) may be faster when dealing with large objects. However, using\nan index may also be slower under certain circumstances due to the\nextra indirection, and is always larger than a sorting-based solution\nbecause it needs space for the index in addition to the original\ncollection. The complexity is the same as $(D sort)'s.\n\nThe first overload of $(D makeIndex) writes to a range containing\npointers, and the second writes to a range containing offsets. The\nfirst overload requires $(D Range) to be a forward range, and the\nlatter requires it to be a random-access range.\n\n$(D makeIndex) overwrites its second argument with the result, but\nnever reallocates it.\n\nReturns: The pointer-based version returns a $(D SortedRange) wrapper\nover index, of type $(D SortedRange!(RangeIndex, (a, b) =>\nbinaryFun!less(*a, *b))) thus reflecting the ordering of the\nindex. The index-based version returns $(D void) because the ordering\nrelation involves not only $(D index) but also $(D r).\n\nThrows: If the second argument's length is less than that of the range\nindexed, an exception is thrown.\n\nExample:\n----\nimmutable(int[]) arr = [ 2, 3, 1, 5, 0 ];\n// index using pointers\nauto index1 = new immutable(int)*[arr.length];\nmakeIndex!(\"a < b\")(arr, index1);\nassert(isSorted!(\"*a < *b\")(index1));\n// index using offsets\nauto index2 = new size_t[arr.length];\nmakeIndex!(\"a < b\")(arr, index2);\nassert(isSorted!\n    ((size_t a, size_t b){ return arr[a] < arr[b];})\n    (index2));\n----\n",
    "line" : 9399,
    "name" : "makeIndex",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RangeIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "makeIndex",
      "kind" : "function",
      "comment" : "\nComputes an index for $(D r) based on the comparison $(D less). The\nindex is a sorted array of pointers or indices into the original\nrange. This technique is similar to sorting, but it is more flexible\nbecause (1) it allows \"sorting\" of immutable collections, (2) allows\nbinary search even if the original collection does not offer random\naccess, (3) allows multiple indexes, each on a different predicate,\nand (4) may be faster when dealing with large objects. However, using\nan index may also be slower under certain circumstances due to the\nextra indirection, and is always larger than a sorting-based solution\nbecause it needs space for the index in addition to the original\ncollection. The complexity is the same as $(D sort)'s.\n\nThe first overload of $(D makeIndex) writes to a range containing\npointers, and the second writes to a range containing offsets. The\nfirst overload requires $(D Range) to be a forward range, and the\nlatter requires it to be a random-access range.\n\n$(D makeIndex) overwrites its second argument with the result, but\nnever reallocates it.\n\nReturns: The pointer-based version returns a $(D SortedRange) wrapper\nover index, of type $(D SortedRange!(RangeIndex, (a, b) =>\nbinaryFun!less(*a, *b))) thus reflecting the ordering of the\nindex. The index-based version returns $(D void) because the ordering\nrelation involves not only $(D index) but also $(D r).\n\nThrows: If the second argument's length is less than that of the range\nindexed, an exception is thrown.\n\nExample:\n----\nimmutable(int[]) arr = [ 2, 3, 1, 5, 0 ];\n// index using pointers\nauto index1 = new immutable(int)*[arr.length];\nmakeIndex!(\"a < b\")(arr, index1);\nassert(isSorted!(\"*a < *b\")(index1));\n// index using offsets\nauto index2 = new size_t[arr.length];\nmakeIndex!(\"a < b\")(arr, index2);\nassert(isSorted!\n    ((size_t a, size_t b){ return arr[a] < arr[b];})\n    (index2));\n----\n",
      "line" : 9399,
      "type" : "SortedRange!(RangeIndex, (a, b) => binaryFun!(less)(*a, *b))(Range r, RangeIndex index)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "index",
        "type" : "RangeIndex"
       }
      ],
      "endline" : 9416
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 9419,
    "name" : "makeIndex",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RangeIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "makeIndex",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 9419,
      "type" : "void(Range r, RangeIndex index)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "index",
        "type" : "RangeIndex"
       }
      ],
      "endline" : 9447
     }
    ]
   },
   {
    "name" : "__unittestL9449_168",
    "kind" : "function",
    "line" : 9449,
    "endline" : 9486
   },
   {
    "name" : "SortOutput",
    "kind" : "enum",
    "comment" : "\nSpecifies whether the output of certain algorithm is desired in sorted\nformat.\n \n",
    "line" : 9486,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " Don't sort output\n",
      "line" : 9487
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " Sort output\n",
      "line" : 9488
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 9491,
    "name" : "topNIndex",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RangeIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "topNIndex",
      "kind" : "function",
      "line" : 9491,
      "type" : "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "index",
        "type" : "RangeIndex"
       },
       {
        "name" : "sorted",
        "type" : "SortOutput",
        "default" : "SortOutput.no"
       }
      ],
      "endline" : 9513
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 9515,
    "name" : "topNIndex",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "ss",
      "kind" : "value",
      "deco" : "E3std9algorithm12SwapStrategy",
      "defaultValue" : "SwapStrategy.unstable"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RangeIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "topNIndex",
      "kind" : "function",
      "line" : 9515,
      "type" : "void(Range r, RangeIndex index, SortOutput sorted = SortOutput.no)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "index",
        "type" : "RangeIndex"
       },
       {
        "name" : "sorted",
        "type" : "SortOutput",
        "default" : "SortOutput.no"
       }
      ],
      "endline" : 9537
     }
    ]
   },
   {
    "name" : "__unittestL9539_169",
    "kind" : "function",
    "line" : 9539,
    "endline" : 9835
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange). Performs $(BIGOH needle.length) evaluations of $(D pred).\n \n",
    "line" : 9835,
    "name" : "canFind",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "canFind",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange). Performs $(BIGOH needle.length) evaluations of $(D pred).\n \n",
      "line" : 9835,
      "type" : "bool(R haystack, E needle)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "R"
       },
       {
        "name" : "needle",
        "type" : "E"
       }
      ],
      "endline" : 9839
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the 1-based index of the first needle found in $(D haystack). If no\n    needle is found, then $(D 0) is returned.\n\n    So, if used directly in the condition of an if statement or loop, the result\n    will be $(D true) if one of the needles is found and $(D false) if none are\n    found, whereas if the result is used elsewhere, it can either be cast to\n    $(D bool) for the same effect or used to get which needle was found first\n    without having to deal with the tuple that $(D LREF find) returns for the\n    same operation.\n \n",
    "line" : 9852,
    "name" : "canFind",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "canFind",
      "kind" : "function",
      "comment" : "\n    Returns the 1-based index of the first needle found in $(D haystack). If no\n    needle is found, then $(D 0) is returned.\n\n    So, if used directly in the condition of an if statement or loop, the result\n    will be $(D true) if one of the needles is found and $(D false) if none are\n    found, whereas if the result is used elsewhere, it can either be cast to\n    $(D bool) for the same effect or used to get which needle was found first\n    without having to deal with the tuple that $(D LREF find) returns for the\n    same operation.\n \n",
      "line" : 9852,
      "type" : "size_t(Range haystack, Ranges needles)",
      "parameters" : [
       {
        "name" : "haystack",
        "type" : "Range"
       },
       {
        "name" : "needles",
        "type" : "Ranges"
       }
      ],
      "endline" : 9858
     }
    ]
   },
   {
    "name" : "__unittestL9860_170",
    "kind" : "function",
    "line" : 9860,
    "endline" : 9884
   },
   {
    "kind" : "template",
    "line" : 9884,
    "name" : "canFind",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "canFind",
      "kind" : "function",
      "line" : 9884,
      "type" : "bool(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 9887
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if a value $(D v) satisfying the\npredicate $(D pred) can be found in the forward range $(D\nrange). Performs $(BIGOH r.length) evaluations of $(D pred).\n \n",
    "line" : 9894,
    "name" : "any",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "any",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if and only if a value $(D v) satisfying the\npredicate $(D pred) can be found in the forward range $(D\nrange). Performs $(BIGOH r.length) evaluations of $(D pred).\n \n",
      "line" : 9894,
      "type" : "bool(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 9898
     }
    ]
   },
   {
    "name" : "__unittestL9900_171",
    "kind" : "function",
    "line" : 9900,
    "endline" : 9918
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if all values in $(D range) satisfy the\npredicate $(D pred).  Performs $(BIGOH r.length) evaluations of $(D pred).\n\nExamples:\n---\nassert(all!\"a & 1\"([1, 3, 5, 7, 9]));\nassert(!all!\"a & 1\"([1, 2, 3, 5, 7, 9]));\n---\n",
    "line" : 9918,
    "name" : "all",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "all",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if and only if all values in $(D range) satisfy the\npredicate $(D pred).  Performs $(BIGOH r.length) evaluations of $(D pred).\n\nExamples:\n---\nassert(all!\"a & 1\"([1, 3, 5, 7, 9]));\nassert(!all!\"a & 1\"([1, 2, 3, 5, 7, 9]));\n---\n",
      "line" : 9918,
      "type" : "bool(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 9925
     }
    ]
   },
   {
    "name" : "__unittestL9927_174",
    "kind" : "function",
    "line" : 9927,
    "endline" : 9950
   },
   {
    "kind" : "template",
    "comment" : "\nCopies the top $(D n) elements of the input range $(D source) into the\nrandom-access range $(D target), where $(D n =\ntarget.length). Elements of $(D source) are not touched. If $(D\nsorted) is $(D true), the target is sorted. Otherwise, the target\nrespects the $(WEB en.wikipedia.org/wiki/Binary_heap, heap property).\n\nExample:\n----\nint[] a = [ 10, 16, 2, 3, 1, 5, 0 ];\nint[] b = new int[3];\ntopNCopy(a, b, true);\nassert(b == [ 0, 1, 2 ]);\n----\n \n",
    "line" : 9950,
    "name" : "topNCopy",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "SRange",
      "kind" : "type"
     },
     {
      "name" : "TRange",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "topNCopy",
      "kind" : "function",
      "comment" : "\nCopies the top $(D n) elements of the input range $(D source) into the\nrandom-access range $(D target), where $(D n =\ntarget.length). Elements of $(D source) are not touched. If $(D\nsorted) is $(D true), the target is sorted. Otherwise, the target\nrespects the $(WEB en.wikipedia.org/wiki/Binary_heap, heap property).\n\nExample:\n----\nint[] a = [ 10, 16, 2, 3, 1, 5, 0 ];\nint[] b = new int[3];\ntopNCopy(a, b, true);\nassert(b == [ 0, 1, 2 ]);\n----\n \n",
      "line" : 9950,
      "type" : "TRange(SRange source, TRange target, SortOutput sorted = SortOutput.no)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "SRange"
       },
       {
        "name" : "target",
        "type" : "TRange"
       },
       {
        "name" : "sorted",
        "type" : "SortOutput",
        "default" : "SortOutput.no"
       }
      ],
      "endline" : 9964
     }
    ]
   },
   {
    "name" : "__unittestL9966_175",
    "kind" : "function",
    "line" : 9966,
    "endline" : 9976
   },
   {
    "name" : "__unittestL9976_176",
    "kind" : "function",
    "line" : 9976,
    "endline" : 10008
   },
   {
    "kind" : "template",
    "comment" : "\nLazily computes the union of two or more ranges $(D rs). The ranges\nare assumed to be sorted by $(D less). Elements in the output are not\nunique; the length of the output is the sum of the lengths of the\ninputs. (The $(D length) member is offered if all ranges also have\nlength.) The element types of all ranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nint[] c = [ 10 ];\nassert(setUnion(a, b).length == a.length + b.length);\nassert(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));\nassert(equal(setUnion(a, c, b),\n    [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10][]));\n----\n \n",
    "line" : 10009,
    "name" : "SetUnion",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Rs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "SetUnion",
      "kind" : "struct",
      "line" : 10009,
      "members" : [
       {
        "name" : "_r",
        "kind" : "variable",
        "line" : 10011,
        "type" : "Rs"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 10012,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "_crt",
        "kind" : "variable",
        "line" : 10013,
        "deco" : "k"
       },
       {
        "kind" : "template",
        "line" : 10015,
        "name" : "adjustPosition",
        "parameters" : [
         {
          "name" : "candidate",
          "kind" : "value",
          "deco" : "k",
          "defaultValue" : "0"
         }
        ],
        "members" : [
         {
          "name" : "adjustPosition",
          "kind" : "function",
          "line" : 10015,
          "type" : "void()",
          "endline" : 10042
         }
        ]
       },
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 10045,
        "type" : "CommonType!(staticMap!(.ElementType, Rs))"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 10047,
        "type" : "(Rs rs)",
        "parameters" : [
         {
          "name" : "rs",
          "type" : "Rs"
         }
        ],
        "endline" : 10051
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 10053,
        "type" : "bool()",
        "endline" : 10056
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 10058,
        "type" : "void()",
        "endline" : 10072
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 10074,
        "type" : "ElementType()",
        "endline" : 10085
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 10117,
    "name" : "setUnion",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Rs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "setUnion",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 10117,
      "type" : "SetUnion!(less, Rs)(Rs rs)",
      "parameters" : [
       {
        "name" : "rs",
        "type" : "Rs"
       }
      ],
      "endline" : 10121
     }
    ]
   },
   {
    "name" : "__unittestL10123_177",
    "kind" : "function",
    "line" : 10123,
    "endline" : 10154
   },
   {
    "kind" : "template",
    "comment" : "\nLazily computes the intersection of two or more input ranges $(D\nrs). The ranges are assumed to be sorted by $(D less). The element\ntypes of all ranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nint[] c = [ 0, 1, 4, 5, 7, 8 ];\nassert(equal(setIntersection(a, a), a));\nassert(equal(setIntersection(a, b), [1, 2, 4, 7][]));\nassert(equal(setIntersection(a, b, c), [1, 4, 7][]));\n----\n \n",
    "line" : 10156,
    "name" : "SetIntersection",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Rs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "SetIntersection",
      "kind" : "struct",
      "line" : 10156,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 10159,
        "type" : "Rs"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 10160,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 10161,
        "type" : "CommonType!(staticMap!(.ElementType, Rs))"
       },
       {
        "name" : "adjustPosition",
        "kind" : "function",
        "line" : 10163,
        "type" : "void()",
        "endline" : 10181
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 10184,
        "type" : "(Rs input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Rs"
         }
        ],
        "endline" : 10189
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 10191,
        "type" : "bool()",
        "endline" : 10198
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 10200,
        "type" : "void()",
        "endline" : 10208
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 10210,
        "type" : "ElementType()",
        "endline" : 10214
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 10231,
    "name" : "setIntersection",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Rs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "setIntersection",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 10231,
      "type" : "SetIntersection!(less, Rs)(Rs ranges)",
      "parameters" : [
       {
        "name" : "ranges",
        "type" : "Rs"
       }
      ],
      "endline" : 10236
     }
    ]
   },
   {
    "name" : "__unittestL10238_178",
    "kind" : "function",
    "line" : 10238,
    "endline" : 10271
   },
   {
    "kind" : "template",
    "comment" : "\nLazily computes the difference of $(D r1) and $(D r2). The two ranges\nare assumed to be sorted by $(D less). The element types of the two\nranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setDifference(a, b), [5, 9][]));\n----\n \n",
    "line" : 10273,
    "name" : "SetDifference",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SetDifference",
      "kind" : "struct",
      "line" : 10273,
      "members" : [
       {
        "name" : "r1",
        "kind" : "variable",
        "line" : 10275,
        "type" : "R1"
       },
       {
        "name" : "r2",
        "kind" : "variable",
        "line" : 10276,
        "type" : "R2"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 10277,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "adjustPosition",
        "kind" : "function",
        "line" : 10279,
        "type" : "void()",
        "endline" : 10295
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 10298,
        "type" : "(R1 r1, R2 r2)",
        "parameters" : [
         {
          "name" : "r1",
          "type" : "R1"
         },
         {
          "name" : "r2",
          "type" : "R2"
         }
        ],
        "endline" : 10304
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 10306,
        "type" : "void()",
        "endline" : 10310
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 10312,
        "type" : "ElementType!(R1)()",
        "endline" : 10316
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 10329,
        "type" : "bool()",
        "endline" : 10329
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 10333,
    "name" : "setDifference",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "setDifference",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 10333,
      "type" : "SetDifference!(less, R1, R2)(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 10337
     }
    ]
   },
   {
    "name" : "__unittestL10339_179",
    "kind" : "function",
    "line" : 10339,
    "endline" : 10364
   },
   {
    "kind" : "template",
    "comment" : "\nLazily computes the symmetric difference of $(D r1) and $(D r2),\ni.e. the elements that are present in exactly one of $(D r1) and $(D\nr2). The two ranges are assumed to be sorted by $(D less), and the\noutput is also sorted by $(D less). The element types of the two\nranges must have a common type.\n\nExample:\n----\nint[] a = [ 1, 2, 4, 5, 7, 9 ];\nint[] b = [ 0, 1, 2, 4, 7, 8 ];\nassert(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));\n----\n \n",
    "line" : 10366,
    "name" : "SetSymmetricDifference",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SetSymmetricDifference",
      "kind" : "struct",
      "line" : 10366,
      "members" : [
       {
        "name" : "r1",
        "kind" : "variable",
        "line" : 10368,
        "type" : "R1"
       },
       {
        "name" : "r2",
        "kind" : "variable",
        "line" : 10369,
        "type" : "R2"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 10371,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "adjustPosition",
        "kind" : "function",
        "line" : 10373,
        "type" : "void()",
        "endline" : 10385
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 10388,
        "type" : "(R1 r1, R2 r2)",
        "parameters" : [
         {
          "name" : "r1",
          "type" : "R1"
         },
         {
          "name" : "r2",
          "type" : "R2"
         }
        ],
        "endline" : 10394
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 10396,
        "type" : "void()",
        "endline" : 10415
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 10417,
        "type" : "ElementType!(R1)()",
        "endline" : 10426
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 10439,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref ()",
        "endline" : 10439
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 10441,
        "type" : "bool()",
        "endline" : 10441
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 10446,
    "name" : "setSymmetricDifference",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "setSymmetricDifference",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 10446,
      "type" : "SetSymmetricDifference!(less, R1, R2)(R1 r1, R2 r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R1"
       },
       {
        "name" : "r2",
        "type" : "R2"
       }
      ],
      "endline" : 10450
     }
    ]
   },
   {
    "name" : "__unittestL10452_180",
    "kind" : "function",
    "line" : 10452,
    "endline" : 10466
   },
   {
    "kind" : "template",
    "comment" : "\nComputes the union of multiple sets. The input sets are passed as a\nrange of ranges and each is assumed to be sorted by $(D\nless). Computation is done lazily, one union element at a time. The\ncomplexity of one $(D popFront) operation is $(BIGOH\nlog(ror.length)). However, the length of $(D ror) decreases as ranges\nin it are exhausted, so the complexity of a full pass through $(D\nNWayUnion) is dependent on the distribution of the lengths of ranges\ncontained within $(D ror). If all ranges have the same length $(D n)\n(worst case scenario), the complexity of a full pass through $(D\nNWayUnion) is $(BIGOH n * ror.length * log(ror.length)), i.e., $(D\nlog(ror.length)) times worse than just spanning all ranges in\nturn. The output comes sorted (unstably) by $(D less).\n\nWarning: Because $(D NWayUnion) does not allocate extra memory, it\nwill leave $(D ror) modified. Namely, $(D NWayUnion) assumes ownership\nof $(D ror) and discretionarily swaps and advances elements of it. If\nyou want $(D ror) to preserve its contents after the call, you may\nwant to pass a duplicate to $(D NWayUnion) (and perhaps cache the\nduplicate in between calls).\n\nExample:\n----\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto witness = [\n    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8\n];\nassert(equal(nWayUnion(a), witness[]));\n----\n \n",
    "line" : 10597,
    "name" : "NWayUnion",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias"
     },
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "NWayUnion",
      "kind" : "struct",
      "line" : 10597,
      "members" : [
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 10598,
        "type" : ".ElementType!(.ElementType!(RangeOfRanges))"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 10599,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "_ror",
        "kind" : "variable",
        "line" : 10600,
        "type" : "RangeOfRanges"
       },
       {
        "name" : "compFront",
        "kind" : "function",
        "line" : 10601,
        "type" : "bool(.ElementType!(RangeOfRanges) a, .ElementType!(RangeOfRanges) b)",
        "parameters" : [
         {
          "name" : "a",
          "type" : ".ElementType!(RangeOfRanges)"
         },
         {
          "name" : "b",
          "type" : ".ElementType!(RangeOfRanges)"
         }
        ],
        "endline" : 10606
       },
       {
        "name" : "_heap",
        "kind" : "variable",
        "line" : 10607,
        "type" : "BinaryHeap!(RangeOfRanges, compFront)"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 10609,
        "type" : "(RangeOfRanges ror)",
        "parameters" : [
         {
          "name" : "ror",
          "type" : "RangeOfRanges"
         }
        ],
        "endline" : 10616
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 10618,
        "type" : "bool()",
        "endline" : 10618
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 10621,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 10623
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 10625,
        "type" : "void()",
        "endline" : 10639
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 10643,
    "name" : "nWayUnion",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nWayUnion",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 10643,
      "type" : "NWayUnion!(less, RangeOfRanges)(RangeOfRanges ror)",
      "parameters" : [
       {
        "name" : "ror",
        "type" : "RangeOfRanges"
       }
      ],
      "endline" : 10648
     }
    ]
   },
   {
    "name" : "__unittestL10650_181",
    "kind" : "function",
    "line" : 10650,
    "endline" : 10718
   },
   {
    "kind" : "template",
    "comment" : "\nGiven a range of sorted forward ranges $(D ror), copies to $(D tgt)\nthe elements that are common to most ranges, along with their number\nof occurrences. All ranges in $(D ror) are assumed to be sorted by $(D\nless). Only the most frequent $(D tgt.length) elements are returned.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below.\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\nlargestPartialIntersection(a, b);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(7.0, 4u));\n----\n\n$(D 7.0) is the correct answer because it occurs in $(D 4) out of the\n$(D 5) inputs, more than any other number. The second member of the\nresulting tuple is indeed $(D 4) (recording the number of occurrences\nof $(D 7.0)). If more of the top-frequent numbers are needed, just\ncreate a larger $(D tgt) range. In the axample above, creating $(D b)\nwith length $(D 2) yields $(D tuple(1.0, 3u)) in the second position.\n\nThe function $(D largestPartialIntersection) is useful for\ne.g. searching an $(LUCKY inverted index) for the documents most\nlikely to contain some terms of interest. The complexity of the search\nis $(BIGOH n * log(tgt.length)), where $(D n) is the sum of lengths of\nall input ranges. This approach is faster than keeping an associative\narray of the occurrences and then selecting its top items, and also\nrequires less memory ($(D largestPartialIntersection) builds its\nresult directly in $(D tgt) and requires no extra memory).\n\nWarning: Because $(D largestPartialIntersection) does not allocate\nextra memory, it will leave $(D ror) modified. Namely, $(D\nlargestPartialIntersection) assumes ownership of $(D ror) and\ndiscretionarily swaps and advances elements of it. If you want $(D\nror) to preserve its contents after the call, you may want to pass a\nduplicate to $(D largestPartialIntersection) (and perhaps cache the\nduplicate in between calls).\n \n",
    "line" : 10718,
    "name" : "largestPartialIntersection",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "largestPartialIntersection",
      "kind" : "function",
      "comment" : "\nGiven a range of sorted forward ranges $(D ror), copies to $(D tgt)\nthe elements that are common to most ranges, along with their number\nof occurrences. All ranges in $(D ror) are assumed to be sorted by $(D\nless). Only the most frequent $(D tgt.length) elements are returned.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below.\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\nlargestPartialIntersection(a, b);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(7.0, 4u));\n----\n\n$(D 7.0) is the correct answer because it occurs in $(D 4) out of the\n$(D 5) inputs, more than any other number. The second member of the\nresulting tuple is indeed $(D 4) (recording the number of occurrences\nof $(D 7.0)). If more of the top-frequent numbers are needed, just\ncreate a larger $(D tgt) range. In the axample above, creating $(D b)\nwith length $(D 2) yields $(D tuple(1.0, 3u)) in the second position.\n\nThe function $(D largestPartialIntersection) is useful for\ne.g. searching an $(LUCKY inverted index) for the documents most\nlikely to contain some terms of interest. The complexity of the search\nis $(BIGOH n * log(tgt.length)), where $(D n) is the sum of lengths of\nall input ranges. This approach is faster than keeping an associative\narray of the occurrences and then selecting its top items, and also\nrequires less memory ($(D largestPartialIntersection) builds its\nresult directly in $(D tgt) and requires no extra memory).\n\nWarning: Because $(D largestPartialIntersection) does not allocate\nextra memory, it will leave $(D ror) modified. Namely, $(D\nlargestPartialIntersection) assumes ownership of $(D ror) and\ndiscretionarily swaps and advances elements of it. If you want $(D\nror) to preserve its contents after the call, you may want to pass a\nduplicate to $(D largestPartialIntersection) (and perhaps cache the\nduplicate in between calls).\n \n",
      "line" : 10718,
      "type" : "void(RangeOfRanges ror, Range tgt, SortOutput sorted = SortOutput.no)",
      "parameters" : [
       {
        "name" : "ror",
        "type" : "RangeOfRanges"
       },
       {
        "name" : "tgt",
        "type" : "Range"
       },
       {
        "name" : "sorted",
        "type" : "SortOutput",
        "default" : "SortOutput.no"
       }
      ],
      "endline" : 10728
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nSimilar to $(D largestPartialIntersection), but associates a weight\nwith each distinct element in the intersection.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below, with specific per-element weights\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\ndouble[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];\nlargestPartialIntersectionWeighted(a, b, weights);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(4.0, 2u));\n----\n\nThe correct answer in this case is $(D 4.0), which, although only\nappears two times, has a total weight $(D 4.6) (three times its weight\n$(D 2.3)). The value $(D 7) is weighted with $(D 1.1) and occurs four\ntimes for a total weight $(D 4.4).\n \n",
    "line" : 10759,
    "name" : "largestPartialIntersectionWeighted",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "WeightsAA",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "largestPartialIntersectionWeighted",
      "kind" : "function",
      "comment" : "\nSimilar to $(D largestPartialIntersection), but associates a weight\nwith each distinct element in the intersection.\n\nExample:\n----\n// Figure which number can be found in most arrays of the set of\n// arrays below, with specific per-element weights\ndouble[][] a =\n[\n    [ 1, 4, 7, 8 ],\n    [ 1, 7 ],\n    [ 1, 7, 8],\n    [ 4 ],\n    [ 7 ],\n];\nauto b = new Tuple!(double, uint)[1];\ndouble[double] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];\nlargestPartialIntersectionWeighted(a, b, weights);\n// First member is the item, second is the occurrence count\nassert(b[0] == tuple(4.0, 2u));\n----\n\nThe correct answer in this case is $(D 4.0), which, although only\nappears two times, has a total weight $(D 4.6) (three times its weight\n$(D 2.3)). The value $(D 7) is weighted with $(D 1.1) and occurs four\ntimes for a total weight $(D 4.4).\n \n",
      "line" : 10759,
      "type" : "void(RangeOfRanges ror, Range tgt, WeightsAA weights, SortOutput sorted = SortOutput.no)",
      "parameters" : [
       {
        "name" : "ror",
        "type" : "RangeOfRanges"
       },
       {
        "name" : "tgt",
        "type" : "Range"
       },
       {
        "name" : "weights",
        "type" : "WeightsAA"
       },
       {
        "name" : "sorted",
        "type" : "SortOutput",
        "default" : "SortOutput.no"
       }
      ],
      "endline" : 10770
     }
    ]
   },
   {
    "name" : "__unittestL10772_182",
    "kind" : "function",
    "line" : 10772,
    "endline" : 10792
   },
   {
    "name" : "__unittestL10792_183",
    "kind" : "function",
    "line" : 10792,
    "endline" : 10810
   },
   {
    "name" : "__unittestL10810_184",
    "kind" : "function",
    "line" : 10810,
    "endline" : 10831
   },
   {
    "name" : "__unittestL10831_185",
    "kind" : "function",
    "line" : 10831,
    "endline" : 10897
   },
   {
    "kind" : "template",
    "comment" : "\n Permutes $(D range) in-place to the next lexicographically greater\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n If the range is currently the lexicographically greatest permutation, it is\n permuted back to the least permutation and false is returned.  Otherwise,\n true is returned. One can thus generate all permutations of a range by\n sorting it according to $(D less), which produces the lexicographically\n least permutation, and then calling nextPermutation until it returns false.\n This is guaranteed to generate all distinct permutations of the range\n exactly once.  If there are $(I N) elements in the range and all of them are\n unique, then $(I N)! permutations will be generated. Otherwise, if there are\n some duplicated elements, fewer permutations will be produced.\n----\n// Enumerate all permutations\nint[] a = [1,2,3,4,5];\nwhile (nextPermutation(a))\n{\n    // a now contains the next permutation of the array.\n}\n----\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\n\n Example:\n----\n// Step through all permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextPermutation(a) == true);\nassert(a == [1,3,2]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,3]);\nassert(nextPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextPermutation(a) == true);\nassert(a == [3,2,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,2,3]);\n----\n----\n// Step through permutations of an array containing duplicate elements:\nint[] a = [1,1,2];\nassert(nextPermutation(a) == true);\nassert(a == [1,2,1]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,1,2]);\n----\n \n",
    "line" : 10897,
    "name" : "nextPermutation",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a<b\""
     },
     {
      "name" : "BidirectionalRange",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nextPermutation",
      "kind" : "function",
      "comment" : "\n Permutes $(D range) in-place to the next lexicographically greater\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n If the range is currently the lexicographically greatest permutation, it is\n permuted back to the least permutation and false is returned.  Otherwise,\n true is returned. One can thus generate all permutations of a range by\n sorting it according to $(D less), which produces the lexicographically\n least permutation, and then calling nextPermutation until it returns false.\n This is guaranteed to generate all distinct permutations of the range\n exactly once.  If there are $(I N) elements in the range and all of them are\n unique, then $(I N)! permutations will be generated. Otherwise, if there are\n some duplicated elements, fewer permutations will be produced.\n----\n// Enumerate all permutations\nint[] a = [1,2,3,4,5];\nwhile (nextPermutation(a))\n{\n    // a now contains the next permutation of the array.\n}\n----\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\n\n Example:\n----\n// Step through all permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextPermutation(a) == true);\nassert(a == [1,3,2]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,3]);\nassert(nextPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextPermutation(a) == true);\nassert(a == [3,2,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,2,3]);\n----\n----\n// Step through permutations of an array containing duplicate elements:\nint[] a = [1,1,2];\nassert(nextPermutation(a) == true);\nassert(a == [1,2,1]);\nassert(nextPermutation(a) == true);\nassert(a == [2,1,1]);\nassert(nextPermutation(a) == false);\nassert(a == [1,1,2]);\n----\n \n",
      "line" : 10897,
      "type" : "bool(ref BidirectionalRange range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "BidirectionalRange",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 10932
     }
    ]
   },
   {
    "name" : "__unittestL10934_188",
    "kind" : "function",
    "line" : 10934,
    "endline" : 10946
   },
   {
    "name" : "__unittestL10946_189",
    "kind" : "function",
    "line" : 10946,
    "endline" : 10963
   },
   {
    "name" : "__unittestL10963_190",
    "kind" : "function",
    "line" : 10963,
    "endline" : 11040
   },
   {
    "name" : "__unittestL11040_191",
    "kind" : "function",
    "line" : 11040,
    "endline" : 11052
   },
   {
    "name" : "__unittestL11052_192",
    "kind" : "function",
    "line" : 11052,
    "endline" : 11177
   },
   {
    "kind" : "template",
    "comment" : "\n Permutes $(D range) in-place to the next lexicographically greater $(I even)\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n An even permutation is one which is produced by swapping an even number of\n pairs of elements in the original range. The set of $(I even) permutations\n is distinct from the set of $(I all) permutations only when there are no\n duplicate elements in the range. If the range has $(I N) unique elements,\n then there are exactly $(I N)!/2 even permutations.\n\n If the range is already the lexicographically greatest even permutation, it\n is permuted back to the least even permutation and false is returned.\n Otherwise, true is returned, and the range is modified in-place to be the\n lexicographically next even permutation.\n\n One can thus generate the even permutations of a range with unique elements\n by starting with the lexicographically smallest permutation, and repeatedly\n calling nextEvenPermutation until it returns false.\n----\n// Enumerate even permutations\nint[] a = [1,2,3,4,5];\nwhile (nextEvenPermutation(a))\n{\n    // a now contains the next even permutation of the array.\n}\n----\n One can also generate the $(I odd) permutations of a range by noting that\n permutations obey the rule that even + even = even, and odd + even = odd.\n Thus, by swapping the last two elements of a lexicographically least range,\n it is turned into the first odd permutation. Then calling\n nextEvenPermutation on this first odd permutation will generate the next\n even permutation relative to this odd permutation, which is actually the\n next odd permutation of the original range. Thus, by repeatedly calling\n nextEvenPermutation until it returns false, one enumerates the odd\n permutations of the original range.\n----\n// Enumerate odd permutations\nint[] a = [1,2,3,4,5];\nswap(a[$-2], a[$-1]);    // a is now the first odd permutation of [1,2,3,4,5]\nwhile (nextEvenPermutation(a))\n{\n    // a now contains the next odd permutation of the original array\n    // (which is an even permutation of the first odd permutation).\n}\n----\n\n Warning: Since even permutations are only distinct from all permutations\n when the range elements are unique, this function assumes that there are no\n duplicate elements under the specified ordering. If this is not _true, some\n permutations may fail to be generated. When the range has non-unique\n elements, you should use $(MYREF nextPermutation) instead.\n\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\n\n Examples:\n----\n// Step through even permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextEvenPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextEvenPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextEvenPermutation(a) == false);\nassert(a == [1,2,3]);\n----\n Even permutations are useful for generating coordinates of certain geometric\n shapes. Here's a non-trivial example:\n----\n// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)\nimport std.math, std.stdio;\nenum real Phi = (1.0 + sqrt(5.0)) / 2.0;    // Golden ratio\nreal[][] seeds = [\n    [0.0, 1.0, 3.0*Phi],\n    [1.0, 2.0+Phi, 2.0*Phi],\n    [Phi, 2.0, Phi^^3]\n];\nforeach (seed; seeds)\n{\n    // Loop over even permutations of each seed\n    do\n    {\n        // Loop over all sign changes of each permutation\n        size_t i;\n        do\n        {\n            // Generate all possible sign changes\n            for (i=0; i < seed.length; i++)\n            {\n                if (seed[i] != 0.0)\n                {\n                    seed[i] = -seed[i];\n                    if (seed[i] < 0.0)\n                        break;\n                }\n            }\n            writeln(seed);\n        } while (i < seed.length);\n    } while (nextEvenPermutation(seed));\n}\n----\n \n",
    "line" : 11177,
    "name" : "nextEvenPermutation",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a<b\""
     },
     {
      "name" : "BidirectionalRange",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nextEvenPermutation",
      "kind" : "function",
      "comment" : "\n Permutes $(D range) in-place to the next lexicographically greater $(I even)\n permutation.\n\n The predicate $(D less) defines the lexicographical ordering to be used on\n the range.\n\n An even permutation is one which is produced by swapping an even number of\n pairs of elements in the original range. The set of $(I even) permutations\n is distinct from the set of $(I all) permutations only when there are no\n duplicate elements in the range. If the range has $(I N) unique elements,\n then there are exactly $(I N)!/2 even permutations.\n\n If the range is already the lexicographically greatest even permutation, it\n is permuted back to the least even permutation and false is returned.\n Otherwise, true is returned, and the range is modified in-place to be the\n lexicographically next even permutation.\n\n One can thus generate the even permutations of a range with unique elements\n by starting with the lexicographically smallest permutation, and repeatedly\n calling nextEvenPermutation until it returns false.\n----\n// Enumerate even permutations\nint[] a = [1,2,3,4,5];\nwhile (nextEvenPermutation(a))\n{\n    // a now contains the next even permutation of the array.\n}\n----\n One can also generate the $(I odd) permutations of a range by noting that\n permutations obey the rule that even + even = even, and odd + even = odd.\n Thus, by swapping the last two elements of a lexicographically least range,\n it is turned into the first odd permutation. Then calling\n nextEvenPermutation on this first odd permutation will generate the next\n even permutation relative to this odd permutation, which is actually the\n next odd permutation of the original range. Thus, by repeatedly calling\n nextEvenPermutation until it returns false, one enumerates the odd\n permutations of the original range.\n----\n// Enumerate odd permutations\nint[] a = [1,2,3,4,5];\nswap(a[$-2], a[$-1]);    // a is now the first odd permutation of [1,2,3,4,5]\nwhile (nextEvenPermutation(a))\n{\n    // a now contains the next odd permutation of the original array\n    // (which is an even permutation of the first odd permutation).\n}\n----\n\n Warning: Since even permutations are only distinct from all permutations\n when the range elements are unique, this function assumes that there are no\n duplicate elements under the specified ordering. If this is not _true, some\n permutations may fail to be generated. When the range has non-unique\n elements, you should use $(MYREF nextPermutation) instead.\n\n Returns: false if the range was lexicographically the greatest, in which\n case the range is reversed back to the lexicographically smallest\n permutation; otherwise returns true.\n\n Examples:\n----\n// Step through even permutations of a sorted array in lexicographic order\nint[] a = [1,2,3];\nassert(nextEvenPermutation(a) == true);\nassert(a == [2,3,1]);\nassert(nextEvenPermutation(a) == true);\nassert(a == [3,1,2]);\nassert(nextEvenPermutation(a) == false);\nassert(a == [1,2,3]);\n----\n Even permutations are useful for generating coordinates of certain geometric\n shapes. Here's a non-trivial example:\n----\n// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)\nimport std.math, std.stdio;\nenum real Phi = (1.0 + sqrt(5.0)) / 2.0;    // Golden ratio\nreal[][] seeds = [\n    [0.0, 1.0, 3.0*Phi],\n    [1.0, 2.0+Phi, 2.0*Phi],\n    [Phi, 2.0, Phi^^3]\n];\nforeach (seed; seeds)\n{\n    // Loop over even permutations of each seed\n    do\n    {\n        // Loop over all sign changes of each permutation\n        size_t i;\n        do\n        {\n            // Generate all possible sign changes\n            for (i=0; i < seed.length; i++)\n            {\n                if (seed[i] != 0.0)\n                {\n                    seed[i] = -seed[i];\n                    if (seed[i] < 0.0)\n                        break;\n                }\n            }\n            writeln(seed);\n        } while (i < seed.length);\n    } while (nextEvenPermutation(seed));\n}\n----\n \n",
      "line" : 11177,
      "type" : "bool(ref BidirectionalRange range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "BidirectionalRange",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 11226
     }
    ]
   },
   {
    "name" : "__unittestL11228_195",
    "kind" : "function",
    "line" : 11228,
    "endline" : 11247
   },
   {
    "name" : "__unittestL11247_196",
    "kind" : "function",
    "line" : 11247,
    "endline" : 11260
   },
   {
    "name" : "__unittestL11260_197",
    "kind" : "function",
    "line" : 11260,
    "endline" : 11272
   },
   {
    "name" : "__unittestL11272_198",
    "kind" : "function",
    "line" : 11272,
    "endline" : 11369
   },
   {
    "kind" : "template",
    "comment" : "\nLazily computes the Cartesian product of two or more ranges. The product is a\n_range of tuples of elements from each respective range.\n\nThe conditions for the two-range case are as follows:\n\nIf both ranges are finite, then one must be (at least) a forward range and the\nother an input range.\n\nIf one _range is infinite and the other finite, then the finite _range must\nbe a forward _range, and the infinite range can be an input _range.\n\nIf both ranges are infinite, then both must be forward ranges.\n\nWhen there are more than two ranges, the above conditions apply to each\nadjacent pair of ranges.\n\nExamples:\n---\nauto N = sequence!\"n\"(0);         // the range of natural numbers\nauto N2 = cartesianProduct(N, N); // the range of all pairs of natural numbers\n\n// Various arbitrary number pairs can be found in the range in finite time.\nassert(canFind(N2, tuple(0, 0)));\nassert(canFind(N2, tuple(123, 321)));\nassert(canFind(N2, tuple(11, 35)));\nassert(canFind(N2, tuple(279, 172)));\n---\n\n---\nauto B = [ 1, 2, 3 ];\nauto C = [ 4, 5, 6 ];\nauto BC = cartesianProduct(B, C);\n\nforeach (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],\n             [2, 6], [3, 6]])\n{\n    assert(canFind(BC, tuple(n[0], n[1])));\n}\n---\n\n---\nauto A = [ 1, 2, 3 ];\nauto B = [ 'a', 'b', 'c' ];\nauto C = [ \"x\", \"y\", \"z\" ];\nauto ABC = cartesianProduct(A, B, C);\n\nassert(ABC.equal([\n    tuple(1, 'a', \"x\"), tuple(2, 'a', \"x\"), tuple(3, 'a', \"x\"),\n    tuple(1, 'b', \"x\"), tuple(2, 'b', \"x\"), tuple(3, 'b', \"x\"),\n    tuple(1, 'c', \"x\"), tuple(2, 'c', \"x\"), tuple(3, 'c', \"x\"),\n    tuple(1, 'a', \"y\"), tuple(2, 'a', \"y\"), tuple(3, 'a', \"y\"),\n    tuple(1, 'b', \"y\"), tuple(2, 'b', \"y\"), tuple(3, 'b', \"y\"),\n    tuple(1, 'c', \"y\"), tuple(2, 'c', \"y\"), tuple(3, 'c', \"y\"),\n    tuple(1, 'a', \"z\"), tuple(2, 'a', \"z\"), tuple(3, 'a', \"z\"),\n    tuple(1, 'b', \"z\"), tuple(2, 'b', \"z\"), tuple(3, 'b', \"z\"),\n    tuple(1, 'c', \"z\"), tuple(2, 'c', \"z\"), tuple(3, 'c', \"z\")\n]));\n---\n",
    "line" : 11369,
    "name" : "cartesianProduct",
    "parameters" : [
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cartesianProduct",
      "kind" : "function",
      "comment" : "\nLazily computes the Cartesian product of two or more ranges. The product is a\n_range of tuples of elements from each respective range.\n\nThe conditions for the two-range case are as follows:\n\nIf both ranges are finite, then one must be (at least) a forward range and the\nother an input range.\n\nIf one _range is infinite and the other finite, then the finite _range must\nbe a forward _range, and the infinite range can be an input _range.\n\nIf both ranges are infinite, then both must be forward ranges.\n\nWhen there are more than two ranges, the above conditions apply to each\nadjacent pair of ranges.\n\nExamples:\n---\nauto N = sequence!\"n\"(0);         // the range of natural numbers\nauto N2 = cartesianProduct(N, N); // the range of all pairs of natural numbers\n\n// Various arbitrary number pairs can be found in the range in finite time.\nassert(canFind(N2, tuple(0, 0)));\nassert(canFind(N2, tuple(123, 321)));\nassert(canFind(N2, tuple(11, 35)));\nassert(canFind(N2, tuple(279, 172)));\n---\n\n---\nauto B = [ 1, 2, 3 ];\nauto C = [ 4, 5, 6 ];\nauto BC = cartesianProduct(B, C);\n\nforeach (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],\n             [2, 6], [3, 6]])\n{\n    assert(canFind(BC, tuple(n[0], n[1])));\n}\n---\n\n---\nauto A = [ 1, 2, 3 ];\nauto B = [ 'a', 'b', 'c' ];\nauto C = [ \"x\", \"y\", \"z\" ];\nauto ABC = cartesianProduct(A, B, C);\n\nassert(ABC.equal([\n    tuple(1, 'a', \"x\"), tuple(2, 'a', \"x\"), tuple(3, 'a', \"x\"),\n    tuple(1, 'b', \"x\"), tuple(2, 'b', \"x\"), tuple(3, 'b', \"x\"),\n    tuple(1, 'c', \"x\"), tuple(2, 'c', \"x\"), tuple(3, 'c', \"x\"),\n    tuple(1, 'a', \"y\"), tuple(2, 'a', \"y\"), tuple(3, 'a', \"y\"),\n    tuple(1, 'b', \"y\"), tuple(2, 'b', \"y\"), tuple(3, 'b', \"y\"),\n    tuple(1, 'c', \"y\"), tuple(2, 'c', \"y\"), tuple(3, 'c', \"y\"),\n    tuple(1, 'a', \"z\"), tuple(2, 'a', \"z\"), tuple(3, 'a', \"z\"),\n    tuple(1, 'b', \"z\"), tuple(2, 'b', \"z\"), tuple(3, 'b', \"z\"),\n    tuple(1, 'c', \"z\"), tuple(2, 'c', \"z\"), tuple(3, 'c', \"z\")\n]));\n---\n",
      "line" : 11369,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 range1, R2 range2)",
      "parameters" : [
       {
        "name" : "range1",
        "type" : "R1"
       },
       {
        "name" : "range2",
        "type" : "R2"
       }
      ],
      "endline" : 11402
     }
    ]
   },
   {
    "name" : "__unittestL11404_203",
    "kind" : "function",
    "line" : 11404,
    "endline" : 11423
   },
   {
    "name" : "__unittestL11423_204",
    "kind" : "function",
    "line" : 11423,
    "endline" : 11459
   },
   {
    "name" : "__unittestL11459_205",
    "kind" : "function",
    "line" : 11459,
    "endline" : 11483
   },
   {
    "name" : "__unittestL11483_206",
    "kind" : "function",
    "line" : 11483,
    "endline" : 11572
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 11572,
    "name" : "cartesianProduct",
    "parameters" : [
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     },
     {
      "name" : "RR",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "cartesianProduct",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 11572,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R1 range1, R2 range2, RR otherRanges)",
      "parameters" : [
       {
        "name" : "range1",
        "type" : "R1"
       },
       {
        "name" : "range2",
        "type" : "R2"
       },
       {
        "name" : "otherRanges",
        "type" : "RR"
       }
      ],
      "endline" : 11584
     }
    ]
   },
   {
    "name" : "__unittestL11586_207",
    "kind" : "function",
    "line" : 11586,
    "endline" : 11599
   },
   {
    "name" : "__unittestL11614_209",
    "kind" : "function",
    "line" : 11614,
    "endline" : 11633
   }
  ]
 },
 {
  "name" : "std.array",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/array.d",
  "comment" : "\nFunctions and types that manipulate built-in arrays.\n\nCopyright: Copyright Andrei Alexandrescu 2008- and Jonathan M Davis 2011-.\n\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n\nSource: $(PHOBOSSRC std/_array.d)\n",
  "members" : [
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 15,
    "protection" : "private"
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 15,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 16,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 16,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 16,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 16,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 16,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 16,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 17,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 17,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 17,
    "protection" : "private"
   },
   {
    "name" : "std.uni",
    "kind" : "import",
    "line" : 17,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 17,
    "protection" : "private"
   },
   {
    "name" : "std.c.string",
    "kind" : "import",
    "line" : 18,
    "protection" : "private",
    "selective" : [
     "memcpy"
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a newly-allocated dynamic array consisting of a copy of the\ninput range, static array, dynamic array, or class or struct with an\n$(D opApply) function $(D r).  Note that narrow strings are handled as\na special case in an overload.\n\nExample:\n\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = array([1, 2, 3, 4, 5][]);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 37,
    "name" : "array",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "array",
      "kind" : "function",
      "comment" : "\nReturns a newly-allocated dynamic array consisting of a copy of the\ninput range, static array, dynamic array, or class or struct with an\n$(D opApply) function $(D r).  Note that narrow strings are handled as\na special case in an overload.\n\nExample:\n\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = array([1, 2, 3, 4, 5][]);\nassert(a == [ 1, 2, 3, 4, 5 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
      "line" : 37,
      "type" : "ForeachType!(Range)[](Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 73
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nConvert a narrow string to an array type that fully supports random access.\nThis is handled as a special case and always returns a $(D dchar[]),\n$(D const(dchar)[]), or $(D immutable(dchar)[]) depending on the constness of\nthe input.\n",
    "line" : 81,
    "name" : "array",
    "parameters" : [
     {
      "name" : "String",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "array",
      "kind" : "function",
      "comment" : "\nConvert a narrow string to an array type that fully supports random access.\nThis is handled as a special case and always returns a $(D dchar[]),\n$(D const(dchar)[]), or $(D immutable(dchar)[]) depending on the constness of\nthe input.\n",
      "line" : 81,
      "type" : "ElementType!(String)[](String str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "String"
       }
      ],
      "endline" : 84
     }
    ]
   },
   {
    "name" : "__unittestL86_210",
    "kind" : "function",
    "line" : 86,
    "endline" : 145
   },
   {
    "name" : "__unittestL145_211",
    "kind" : "function",
    "line" : 145,
    "endline" : 189
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a newly allocated associative array out of elements of the input range,\nwhich must be a range of tuples (Key, Value).\n\nExample:\n\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = assocArray(zip([0, 1, 2], [\"a\", \"b\", \"c\"]));\nassert(a == [0:\"a\", 1:\"b\", 2:\"c\"]);\nauto b = assocArray([ tuple(\"foo\", \"bar\"), tuple(\"baz\", \"quux\") ]);\nassert(b == [\"foo\":\"bar\", \"baz\":\"quux\"]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 189,
    "name" : "assocArray",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assocArray",
      "kind" : "function",
      "comment" : "\nReturns a newly allocated associative array out of elements of the input range,\nwhich must be a range of tuples (Key, Value).\n\nExample:\n\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = assocArray(zip([0, 1, 2], [\"a\", \"b\", \"c\"]));\nassert(a == [0:\"a\", 1:\"b\", 2:\"c\"]);\nauto b = assocArray([ tuple(\"foo\", \"bar\"), tuple(\"baz\", \"quux\") ]);\nassert(b == [\"foo\":\"bar\", \"baz\":\"quux\"]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
      "line" : 189,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 199
     }
    ]
   },
   {
    "name" : "__unittestL201_212",
    "kind" : "function",
    "line" : 201,
    "endline" : 216
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 216,
    "name" : "blockAttribute",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL227_213",
    "kind" : "function",
    "line" : 227,
    "endline" : 232
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 232,
    "name" : "nDimensions",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL244_214",
    "kind" : "function",
    "line" : 244,
    "endline" : 269
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap\nwithout initializing its elements.  This can be a useful optimization if every\nelement will be immediately initialized.  $(D T) may be a multidimensional\narray.  In this case sizes may be specified for any number of dimensions from 1\nto the number in $(D T).\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n---\ndouble[] arr = uninitializedArray!(double[])(100);\nassert(arr.length == 100);\n\ndouble[][] matrix = uninitializedArray!(double[][])(42, 31);\nassert(matrix.length == 42);\nassert(matrix[0].length == 31);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
    "line" : 269,
    "name" : "uninitializedArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "I",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "uninitializedArray",
      "kind" : "function",
      "comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap\nwithout initializing its elements.  This can be a useful optimization if every\nelement will be immediately initialized.  $(D T) may be a multidimensional\narray.  In this case sizes may be specified for any number of dimensions from 1\nto the number in $(D T).\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n---\ndouble[] arr = uninitializedArray!(double[])(100);\nassert(arr.length == 100);\n\ndouble[][] matrix = uninitializedArray!(double[][])(42, 31);\nassert(matrix.length == 42);\nassert(matrix[0].length == 31);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
      "line" : 269,
      "storageClass" : [
       "auto"
      ],
      "type" : "(I sizes)",
      "parameters" : [
       {
        "name" : "sizes",
        "type" : "I"
       }
      ],
      "endline" : 273
     }
    ]
   },
   {
    "name" : "__unittestL275_215",
    "kind" : "function",
    "line" : 275,
    "endline" : 290
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap.\nInitialization is guaranteed only for pointers, references and slices,\nfor preservation of memory safety.\n",
    "line" : 290,
    "name" : "minimallyInitializedArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "I",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "minimallyInitializedArray",
      "kind" : "function",
      "comment" : "\nReturns a new array of type $(D T) allocated on the garbage collected heap.\nInitialization is guaranteed only for pointers, references and slices,\nfor preservation of memory safety.\n",
      "line" : 290,
      "storageClass" : [
       "auto"
      ],
      "type" : "@trusted (I sizes)",
      "parameters" : [
       {
        "name" : "sizes",
        "type" : "I"
       }
      ],
      "endline" : 294
     }
    ]
   },
   {
    "name" : "__unittestL296_216",
    "kind" : "function",
    "line" : 296,
    "endline" : 309
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 309,
    "name" : "arrayAllocImpl",
    "parameters" : [
     {
      "name" : "minimallyInitialized",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "I",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "arrayAllocImpl",
      "kind" : "function",
      "line" : 309,
      "storageClass" : [
       "auto"
      ],
      "type" : "(I sizes)",
      "parameters" : [
       {
        "name" : "sizes",
        "type" : "I"
       }
      ],
      "endline" : 337
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the range interface primitive $(D empty) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.empty) is\nequivalent to $(D empty(array)).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = [ 1, 2, 3 ];\nassert(!a.empty);\nassert(a[3 .. $].empty);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 356,
    "name" : "empty",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "empty",
      "kind" : "function",
      "line" : 356,
      "type" : "pure nothrow @safe bool(in T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 359
     }
    ]
   },
   {
    "name" : "__unittestL361_217",
    "kind" : "function",
    "line" : 361,
    "endline" : 386
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the range interface primitive $(D save) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.save) is\nequivalent to $(D save(array)). The function does not duplicate the\ncontent of the array, it simply returns its argument.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = [ 1, 2, 3 ];\nauto b = a.save;\nassert(b is a);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 386,
    "name" : "save",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "save",
      "kind" : "function",
      "line" : 386,
      "type" : "pure nothrow @safe T[](T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]"
       }
      ],
      "endline" : 389
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the range interface primitive $(D popFront) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popFront) is\nequivalent to $(D popFront(array)). For $(GLOSSARY narrow strings),\n$(D popFront) automaticaly advances to the next $(GLOSSARY code\npoint).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popFront();\nassert(a == [ 2, 3 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
    "line" : 410,
    "name" : "popFront",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popFront",
      "kind" : "function",
      "comment" : "\nImplements the range interface primitive $(D popFront) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popFront) is\nequivalent to $(D popFront(array)). For $(GLOSSARY narrow strings),\n$(D popFront) automaticaly advances to the next $(GLOSSARY code\npoint).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popFront();\nassert(a == [ 2, 3 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
      "line" : 410,
      "type" : "void(ref T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 415
     }
    ]
   },
   {
    "name" : "__unittestL417_221",
    "kind" : "function",
    "line" : 417,
    "endline" : 429
   },
   {
    "kind" : "template",
    "line" : 429,
    "name" : "popFront",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popFront",
      "kind" : "function",
      "line" : 429,
      "type" : "pure nothrow @trusted void(ref C[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 460
     }
    ]
   },
   {
    "name" : "__unittestL462_224",
    "kind" : "function",
    "line" : 462,
    "endline" : 514
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the range interface primitive $(D popBack) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popBack) is\nequivalent to $(D popBack(array)). For $(GLOSSARY narrow strings), $(D\npopFront) automaticaly eliminates the last $(GLOSSARY code point).\n\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popBack();\nassert(a == [ 1, 2 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
    "line" : 514,
    "name" : "popBack",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popBack",
      "kind" : "function",
      "comment" : "\nImplements the range interface primitive $(D popBack) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.popBack) is\nequivalent to $(D popBack(array)). For $(GLOSSARY narrow strings), $(D\npopFront) automaticaly eliminates the last $(GLOSSARY code point).\n\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\na.popBack();\nassert(a == [ 1, 2 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
      "line" : 514,
      "type" : "void(ref T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 519
     }
    ]
   },
   {
    "name" : "__unittestL521_228",
    "kind" : "function",
    "line" : 521,
    "endline" : 533
   },
   {
    "kind" : "template",
    "line" : 533,
    "name" : "popBack",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popBack",
      "kind" : "function",
      "line" : 533,
      "type" : "void(ref T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 538
     }
    ]
   },
   {
    "name" : "__unittestL540_231",
    "kind" : "function",
    "line" : 540,
    "endline" : 584
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the range interface primitive $(D front) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.front) is\nequivalent to $(D front(array)). For $(GLOSSARY narrow strings), $(D\nfront) automaticaly returns the first $(GLOSSARY code point) as a $(D\ndchar).\n\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\nassert(a.front == 1);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
    "line" : 584,
    "name" : "front",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "front",
      "kind" : "function",
      "line" : 584,
      "type" : "T(T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]"
       }
      ],
      "endline" : 589
     }
    ]
   },
   {
    "name" : "__unittestL591_232",
    "kind" : "function",
    "line" : 591,
    "endline" : 605
   },
   {
    "kind" : "template",
    "line" : 605,
    "name" : "front",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "front",
      "kind" : "function",
      "line" : 605,
      "type" : "dchar(T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]"
       }
      ],
      "endline" : 610
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the range interface primitive $(D back) for built-in\narrays. Due to the fact that nonmember functions can be called with\nthe first argument using the dot notation, $(D array.back) is\nequivalent to $(D back(array)). For $(GLOSSARY narrow strings), $(D\nback) automaticaly returns the last $(GLOSSARY code point) as a $(D\ndchar).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nint[] a = [ 1, 2, 3 ];\nassert(a.back == 3);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n",
    "line" : 629,
    "name" : "back",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "back",
      "kind" : "function",
      "line" : 629,
      "type" : "T(T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]"
       }
      ],
      "endline" : 633
     }
    ]
   },
   {
    "name" : "__unittestL635_233",
    "kind" : "function",
    "line" : 635,
    "endline" : 650
   },
   {
    "kind" : "template",
    "line" : 650,
    "name" : "back",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "back",
      "kind" : "function",
      "line" : 650,
      "type" : "dchar(T[] a)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T[]"
       }
      ],
      "endline" : 655
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 678,
    "name" : "overlap",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "overlap",
      "kind" : "function",
      "line" : 678,
      "type" : "pure nothrow @trusted inout(T)[](inout(T)[] r1, inout(T)[] r2)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "inout(T)[]"
       },
       {
        "name" : "r2",
        "type" : "inout(T)[]"
       }
      ],
      "endline" : 687
     }
    ]
   },
   {
    "name" : "__unittestL689_234",
    "kind" : "function",
    "line" : 689,
    "endline" : 716
   },
   {
    "name" : "__unittestL716_235",
    "kind" : "function",
    "line" : 716,
    "endline" : 847
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 847,
    "name" : "copyBackwards",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "copyBackwards",
      "kind" : "function",
      "line" : 847,
      "type" : "void(T[] src, T[] dest)",
      "parameters" : [
       {
        "name" : "src",
        "type" : "T[]"
       },
       {
        "name" : "dest",
        "type" : "T[]"
       }
      ],
      "endline" : 861
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Inserts $(D stuff) (which must be an input range or any number of\n    implicitly convertible items) in $(D array) at position $(D pos).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.insertInPlace(2, [ 1, 2 ]);\nassert(a == [ 1, 2, 1, 2, 3, 4 ]);\na.insertInPlace(3, 10u, 11);\nassert(a == [ 1, 2, 1, 10, 11, 2, 3, 4]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 879,
    "name" : "insertInPlace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "insertInPlace",
      "kind" : "function",
      "comment" : "\n    Inserts $(D stuff) (which must be an input range or any number of\n    implicitly convertible items) in $(D array) at position $(D pos).\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.insertInPlace(2, [ 1, 2 ]);\nassert(a == [ 1, 2, 1, 2, 3, 4 ]);\na.insertInPlace(3, 10u, 11);\nassert(a == [ 1, 2, 1, 10, 11, 2, 3, 4]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
      "line" : 879,
      "type" : "void(ref T[] array, size_t pos, U stuff)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "pos",
        "type" : "size_t"
       },
       {
        "name" : "stuff",
        "type" : "U"
       }
      ],
      "endline" : 922
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 925,
    "name" : "insertInPlace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "insertInPlace",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 925,
      "type" : "void(ref T[] array, size_t pos, U stuff)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "pos",
        "type" : "size_t"
       },
       {
        "name" : "stuff",
        "type" : "U"
       }
      ],
      "endline" : 997
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1000,
    "name" : "isInputRangeWithLengthOrConvertible",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1002,
      "name" : "isInputRangeWithLengthOrConvertible",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "isInputRangeWithLengthOrConvertible",
        "kind" : "variable",
        "line" : 1007,
        "storageClass" : [
         "enum"
        ],
        "init" : "isInputRange!(R) && is(typeof(R.init.length)) && is(ElementType!(R) : E) || is(R : E)"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1012,
    "name" : "isCharOrStringOrDcharRange",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isCharOrStringOrDcharRange",
      "kind" : "variable",
      "line" : 1015,
      "storageClass" : [
       "enum"
      ],
      "init" : "isSomeString!(T) || isSomeChar!(T) || isInputRange!(T) && is(ElementType!(T) : dchar)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1019,
    "name" : "isInputRangeOrConvertible",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1021,
      "name" : "isInputRangeOrConvertible",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "isInputRangeOrConvertible",
        "kind" : "variable",
        "line" : 1024,
        "storageClass" : [
         "enum"
        ],
        "init" : "isInputRange!(R) && is(ElementType!(R) : E) || is(R : E)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1030_236",
    "kind" : "function",
    "line" : 1030,
    "endline" : 1039
   },
   {
    "name" : "__unittestL1039_237",
    "kind" : "function",
    "line" : 1039,
    "endline" : 1127
   },
   {
    "name" : "__unittestL1127_238",
    "kind" : "function",
    "line" : 1127,
    "endline" : 1159
   },
   {
    "name" : "__unittestL1159_239",
    "kind" : "function",
    "line" : 1159,
    "endline" : 1171
   },
   {
    "name" : "__unittestL1171_240",
    "kind" : "function",
    "line" : 1171,
    "endline" : 1194
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns whether the $(D front)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    starts at index $(D 0).\n  \n",
    "line" : 1194,
    "name" : "sameHead",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sameHead",
      "kind" : "function",
      "line" : 1194,
      "type" : "bool(T[] lhs, T[] rhs)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "T[]"
       },
       {
        "name" : "rhs",
        "type" : "T[]"
       }
      ],
      "endline" : 1197
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns whether the $(D back)s of $(D lhs) and $(D rhs) both refer to the\n    same place in memory, making one of the arrays a slice of the other which\n    end at index $(D $).\n  \n",
    "line" : 1205,
    "name" : "sameTail",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sameTail",
      "kind" : "function",
      "line" : 1205,
      "type" : "bool(T[] lhs, T[] rhs)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "T[]"
       },
       {
        "name" : "rhs",
        "type" : "T[]"
       }
      ],
      "endline" : 1208
     }
    ]
   },
   {
    "name" : "__unittestL1210_241",
    "kind" : "function",
    "line" : 1210,
    "endline" : 1243
   },
   {
    "kind" : "template",
    "comment" : "\nReturns an array that consists of $(D s) (which must be an input\nrange) repeated $(D n) times. This function allocates, fills, and\nreturns a new array. For a lazy version, refer to $(XREF range, repeat).\n \n",
    "line" : 1243,
    "name" : "replicate",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replicate",
      "kind" : "function",
      "comment" : "\nReturns an array that consists of $(D s) (which must be an input\nrange) repeated $(D n) times. This function allocates, fills, and\nreturns a new array. For a lazy version, refer to $(XREF range, repeat).\n \n",
      "line" : 1243,
      "type" : "ElementEncodingType!(S)[](S s, size_t n)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 1264
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1266,
    "name" : "replicate",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replicate",
      "kind" : "function",
      "line" : 1266,
      "type" : "ElementType!(S)[](S s, size_t n)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 1270
     }
    ]
   },
   {
    "name" : "__unittestL1272_242",
    "kind" : "function",
    "line" : 1272,
    "endline" : 1295
   },
   {
    "kind" : "template",
    "comment" : "\nSplit the string $(D s) into an array of words, using whitespace as\ndelimiter. Runs of whitespace are merged together (no empty words are produced).\n \n",
    "line" : 1295,
    "name" : "split",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "split",
      "kind" : "function",
      "comment" : "\nSplit the string $(D s) into an array of words, using whitespace as\ndelimiter. Runs of whitespace are merged together (no empty words are produced).\n \n",
      "line" : 1295,
      "type" : "S[](S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       }
      ],
      "endline" : 1324
     }
    ]
   },
   {
    "name" : "__unittestL1326_243",
    "kind" : "function",
    "line" : 1326,
    "endline" : 1354
   },
   {
    "kind" : "template",
    "comment" : "\nSplits a string by whitespace.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = \" a     bcd   ef gh \";\nassert(equal(splitter(a), [\"\", \"a\", \"bcd\", \"ef\", \"gh\"][]));\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array, std.algorithm: equal;))\n \n",
    "line" : 1354,
    "name" : "splitter",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitter",
      "kind" : "function",
      "comment" : "\nSplits a string by whitespace.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto a = \" a     bcd   ef gh \";\nassert(equal(splitter(a), [\"\", \"a\", \"bcd\", \"ef\", \"gh\"][]));\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array, std.algorithm: equal;))\n \n",
      "line" : 1354,
      "storageClass" : [
       "auto"
      ],
      "type" : "(C[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "C[]"
       }
      ],
      "endline" : 1358
     }
    ]
   },
   {
    "name" : "__unittestL1360_244",
    "kind" : "function",
    "line" : 1360,
    "endline" : 1377
   },
   {
    "kind" : "template",
    "comment" : "\n Splits $(D s) into an array, using $(D delim) as the delimiter.\n \n",
    "line" : 1377,
    "name" : "split",
    "parameters" : [
     {
      "name" : "S1",
      "kind" : "type"
     },
     {
      "name" : "S2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "split",
      "kind" : "function",
      "comment" : "\n Splits $(D s) into an array, using $(D delim) as the delimiter.\n \n",
      "line" : 1377,
      "type" : "Unqual!(S1)[](S1 s, S2 delim)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S1"
       },
       {
        "name" : "delim",
        "type" : "S2"
       }
      ],
      "endline" : 1387
     }
    ]
   },
   {
    "name" : "__unittestL1389_245",
    "kind" : "function",
    "line" : 1389,
    "endline" : 1457
   },
   {
    "kind" : "template",
    "comment" : "\n   Concatenates all of the ranges in $(D ror) together into one array using\n   $(D sep) as the separator if present.\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n--------------------\nassert(join([\"hello\", \"silly\", \"world\"], \" \") == \"hello silly world\");\nassert(join([\"hello\", \"silly\", \"world\"]) == \"hellosillyworld\");\n\nassert(join([[1, 2, 3], [4, 5]], [72, 73]) == [1, 2, 3, 72, 73, 4, 5]);\nassert(join([[1, 2, 3], [4, 5]]) == [1, 2, 3, 4, 5]);\n--------------------\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n  \n",
    "line" : 1457,
    "name" : "join",
    "parameters" : [
     {
      "name" : "RoR",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "join",
      "kind" : "function",
      "comment" : "\n   Concatenates all of the ranges in $(D ror) together into one array using\n   $(D sep) as the separator if present.\n\nExamples:\n$(D_RUN_CODE\n$(ARGS\n--------------------\nassert(join([\"hello\", \"silly\", \"world\"], \" \") == \"hello silly world\");\nassert(join([\"hello\", \"silly\", \"world\"]) == \"hellosillyworld\");\n\nassert(join([[1, 2, 3], [4, 5]], [72, 73]) == [1, 2, 3, 72, 73, 4, 5]);\nassert(join([[1, 2, 3], [4, 5]]) == [1, 2, 3, 4, 5]);\n--------------------\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n  \n",
      "line" : 1457,
      "type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror, R sep)",
      "parameters" : [
       {
        "name" : "ror",
        "type" : "RoR"
       },
       {
        "name" : "sep",
        "type" : "R"
       }
      ],
      "endline" : 1501
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1504,
    "name" : "join",
    "parameters" : [
     {
      "name" : "RoR",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "join",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1504,
      "type" : "ElementEncodingType!(ElementType!(RoR))[](RoR ror)",
      "parameters" : [
       {
        "name" : "ror",
        "type" : "RoR"
       }
      ],
      "endline" : 1525
     }
    ]
   },
   {
    "name" : "__unittestL1528_246",
    "kind" : "function",
    "line" : 1528,
    "endline" : 1537
   },
   {
    "name" : "__unittestL1537_247",
    "kind" : "function",
    "line" : 1537,
    "endline" : 1643
   },
   {
    "kind" : "template",
    "comment" : "\n    Replace occurrences of $(D from) with $(D to) in $(D subject). Returns a new\n    array without changing the contents of $(D subject), or the original array\n    if no match is found.\n \n",
    "line" : 1643,
    "name" : "replace",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replace",
      "kind" : "function",
      "comment" : "\n    Replace occurrences of $(D from) with $(D to) in $(D subject). Returns a new\n    array without changing the contents of $(D subject), or the original array\n    if no match is found.\n \n",
      "line" : 1643,
      "type" : "E[](E[] subject, R1 from, R2 to)",
      "parameters" : [
       {
        "name" : "subject",
        "type" : "E[]"
       },
       {
        "name" : "from",
        "type" : "R1"
       },
       {
        "name" : "to",
        "type" : "R2"
       }
      ],
      "endline" : 1659
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Same as above, but outputs the result via OutputRange $(D sink).\n    If no match is found the original array is transfered to $(D sink) as is.\n",
    "line" : 1665,
    "name" : "replaceInto",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "Sink",
      "kind" : "type"
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replaceInto",
      "kind" : "function",
      "comment" : "\n    Same as above, but outputs the result via OutputRange $(D sink).\n    If no match is found the original array is transfered to $(D sink) as is.\n",
      "line" : 1665,
      "type" : "void(Sink sink, E[] subject, R1 from, R2 to)",
      "parameters" : [
       {
        "name" : "sink",
        "type" : "Sink"
       },
       {
        "name" : "subject",
        "type" : "E[]"
       },
       {
        "name" : "from",
        "type" : "R1"
       },
       {
        "name" : "to",
        "type" : "R2"
       }
      ],
      "endline" : 1687
     }
    ]
   },
   {
    "name" : "__unittestL1689_248",
    "kind" : "function",
    "line" : 1689,
    "endline" : 1716
   },
   {
    "name" : "__unittestL1716_249",
    "kind" : "function",
    "line" : 1716,
    "endline" : 1856
   },
   {
    "kind" : "template",
    "comment" : "\n    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Expands or\n    shrinks the array as needed.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.replaceInPlace(1, 3, [ 9, 9, 9 ]);\nassert(a == [ 1, 9, 9, 9, 4 ]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 1856,
    "name" : "replaceInPlace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replaceInPlace",
      "kind" : "function",
      "comment" : "\n    Replaces elements from $(D array) with indices ranging from $(D from)\n    (inclusive) to $(D to) (exclusive) with the range $(D stuff). Expands or\n    shrinks the array as needed.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n---\nint[] a = [ 1, 2, 3, 4 ];\na.replaceInPlace(1, 3, [ 9, 9, 9 ]);\nassert(a == [ 1, 9, 9, 9, 4 ]);\n---\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
      "line" : 1856,
      "type" : "void(ref T[] array, size_t from, size_t to, Range stuff)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "from",
        "type" : "size_t"
       },
       {
        "name" : "to",
        "type" : "size_t"
       },
       {
        "name" : "stuff",
        "type" : "Range"
       }
      ],
      "endline" : 1882
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1884,
    "name" : "replaceInPlace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replaceInPlace",
      "kind" : "function",
      "line" : 1884,
      "type" : "void(ref T[] array, size_t from, size_t to, Range stuff)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "from",
        "type" : "size_t"
       },
       {
        "name" : "to",
        "type" : "size_t"
       },
       {
        "name" : "stuff",
        "type" : "Range"
       }
      ],
      "endline" : 1900
     }
    ]
   },
   {
    "name" : "__unittestL1903_250",
    "kind" : "function",
    "line" : 1903,
    "endline" : 1914
   },
   {
    "name" : "__unittestL1914_251",
    "kind" : "function",
    "line" : 1914,
    "endline" : 1985
   },
   {
    "kind" : "template",
    "comment" : "\n    Replaces the first occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\n \n",
    "line" : 1985,
    "name" : "replaceFirst",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replaceFirst",
      "kind" : "function",
      "comment" : "\n    Replaces the first occurrence of $(D from) with $(D to) in $(D a). Returns a\n    new array without changing the contents of $(D subject), or the original\n    array if no match is found.\n \n",
      "line" : 1985,
      "type" : "E[](E[] subject, R1 from, R2 to)",
      "parameters" : [
       {
        "name" : "subject",
        "type" : "E[]"
       },
       {
        "name" : "from",
        "type" : "R1"
       },
       {
        "name" : "to",
        "type" : "R2"
       }
      ],
      "endline" : 1999
     }
    ]
   },
   {
    "name" : "__unittestL2001_252",
    "kind" : "function",
    "line" : 2001,
    "endline" : 2028
   },
   {
    "name" : "__unittestL2028_253",
    "kind" : "function",
    "line" : 2028,
    "endline" : 2039
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns an array that is $(D s) with $(D slice) replaced by\n    $(D replacement[]).\n \n",
    "line" : 2039,
    "name" : "replaceSlice",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replaceSlice",
      "kind" : "function",
      "comment" : "\n    Returns an array that is $(D s) with $(D slice) replaced by\n    $(D replacement[]).\n \n",
      "line" : 2039,
      "type" : "inout(T)[](inout(T)[] s, in T[] slice, in T[] replacement)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "inout(T)[]"
       },
       {
        "name" : "slice",
        "type" : "T[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "replacement",
        "type" : "T[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2055
     }
    ]
   },
   {
    "name" : "__unittestL2057_254",
    "kind" : "function",
    "line" : 2057,
    "endline" : 2092
   },
   {
    "kind" : "template",
    "comment" : "\nImplements an output range that appends data to an array. This is\nrecommended over $(D a ~= data) when appending many elements because it is more\nefficient.\n\nExample:\n$(D_RUN_CODE\n$(ARGS\n----\nauto app = appender!string();\nstring b = \"abcdefg\";\nforeach (char c; b) app.put(c);\nassert(app.data == \"abcdefg\");\n\nint[] a = [ 1, 2 ];\nauto app2 = appender(a);\napp2.put(3);\napp2.put([ 4, 5, 6 ]);\nassert(app2.data == [ 1, 2, 3, 4, 5, 6 ]);\n----\n), $(ARGS), $(ARGS), $(ARGS import std.array;))\n \n",
    "line" : 2093,
    "name" : "Appender",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "type",
      "type" : "T[]"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Appender",
      "kind" : "struct",
      "line" : 2093,
      "members" : [
       {
        "name" : "Data",
        "kind" : "struct",
        "line" : 2095,
        "members" : [
         {
          "name" : "capacity",
          "kind" : "variable",
          "line" : 2096,
          "type" : "size_t"
         },
         {
          "name" : "arr",
          "kind" : "variable",
          "line" : 2097,
          "type" : "Unqual!(T)[]"
         }
        ]
       },
       {
        "name" : "_data",
        "kind" : "variable",
        "line" : 2100,
        "type" : "Data*"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\nConstruct an appender with a given array.  Note that this does not copy the\ndata.  If the array has a larger capacity as determined by arr.capacity,\nit will be used by the appender.  After initializing an appender on an array,\nappending to the original array will reallocate.\n",
        "line" : 2108,
        "type" : "(T[] arr)",
        "parameters" : [
         {
          "name" : "arr",
          "type" : "T[]"
         }
        ],
        "endline" : 2126
       },
       {
        "name" : "reserve",
        "kind" : "function",
        "comment" : "\nReserve at least newCapacity elements for appending.  Note that more elements\nmay be reserved than requested.  If newCapacity < capacity, then nothing is\ndone.\n",
        "line" : 2133,
        "type" : "void(size_t newCapacity)",
        "parameters" : [
         {
          "name" : "newCapacity",
          "type" : "size_t"
         }
        ],
        "endline" : 2179
       },
       {
        "name" : "capacity",
        "kind" : "function",
        "comment" : "\nReturns the capacity of the array (the maximum number of elements the\nmanaged array can accommodate before triggering a reallocation).  If any\nappending will reallocate, $(D capacity) returns $(D 0).\n \n",
        "line" : 2186,
        "type" : "const size_t()",
        "endline" : 2189
       },
       {
        "name" : "data",
        "kind" : "function",
        "comment" : "\nReturns the managed array.\n \n",
        "line" : 2194,
        "type" : "inout inout(T)[]()",
        "endline" : 2197
       },
       {
        "name" : "ensureAddable",
        "kind" : "function",
        "line" : 2200,
        "type" : "void(size_t nelems)",
        "parameters" : [
         {
          "name" : "nelems",
          "type" : "size_t"
         }
        ],
        "endline" : 2249
       },
       {
        "name" : "newCapacity",
        "kind" : "function",
        "line" : 2251,
        "type" : "size_t(size_t newlength)",
        "parameters" : [
         {
          "name" : "newlength",
          "type" : "size_t"
         }
        ],
        "endline" : 2259
       },
       {
        "kind" : "template",
        "line" : 2261,
        "name" : "canPutItem",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "canPutItem",
          "kind" : "variable",
          "line" : 2263,
          "storageClass" : [
           "enum"
          ],
          "deco" : "b",
          "init" : "isImplicitlyConvertible!(U, T) || isSomeChar!(T) && isSomeChar!(U)"
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2267,
        "name" : "canPutConstRange",
        "parameters" : [
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "canPutConstRange",
          "kind" : "variable",
          "line" : 2269,
          "storageClass" : [
           "enum"
          ],
          "deco" : "b",
          "init" : "isInputRange!(Unqual!(Range)) && !isInputRange!(Range)"
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2273,
        "name" : "canPutRange",
        "parameters" : [
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "canPutRange",
          "kind" : "variable",
          "line" : 2275,
          "storageClass" : [
           "enum"
          ],
          "deco" : "b",
          "init" : "isInputRange!(Range) && is(typeof(Appender.init.put(Range.init.front)))"
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAppends one item to the managed array.\n \n",
        "line" : 2282,
        "name" : "put",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "put",
          "kind" : "function",
          "comment" : "\nAppends one item to the managed array.\n \n",
          "line" : 2282,
          "type" : "void(U item)",
          "parameters" : [
           {
            "name" : "item",
            "type" : "U"
           }
          ],
          "endline" : 2298
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2301,
        "name" : "put",
        "parameters" : [
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "put",
          "kind" : "function",
          "line" : 2301,
          "type" : "void(Range items)",
          "parameters" : [
           {
            "name" : "items",
            "type" : "Range"
           }
          ],
          "endline" : 2305
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAppends an entire range to the managed array.\n \n",
        "line" : 2310,
        "name" : "put",
        "parameters" : [
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "put",
          "kind" : "function",
          "comment" : "\nAppends an entire range to the managed array.\n \n",
          "line" : 2310,
          "type" : "void(Range items)",
          "parameters" : [
           {
            "name" : "items",
            "type" : "Range"
           }
          ],
          "endline" : 2356
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAppends one item to the managed array.\n \n",
        "line" : 2361,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string",
          "specValue" : "\"~\""
         },
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nAppends one item to the managed array.\n \n",
          "line" : 2361,
          "type" : "void(U item)",
          "parameters" : [
           {
            "name" : "item",
            "type" : "U"
           }
          ],
          "endline" : 2364
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2367,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string",
          "specValue" : "\"~\""
         },
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 2367,
          "type" : "void(Range items)",
          "parameters" : [
           {
            "name" : "items",
            "type" : "Range"
           }
          ],
          "endline" : 2370
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAppends an entire range to the managed array.\n \n",
        "line" : 2375,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string",
          "specValue" : "\"~\""
         },
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nAppends an entire range to the managed array.\n \n",
          "line" : 2375,
          "type" : "void(Range items)",
          "parameters" : [
           {
            "name" : "items",
            "type" : "Range"
           }
          ],
          "endline" : 2378
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nAn appender that can update an array in-place.  It forwards all calls to an\nunderlying appender implementation.  Any calls made to the appender also update\nthe pointer to the original array passed in.\n",
    "line" : 2422,
    "name" : "RefAppender",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "type",
      "type" : "T[]"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RefAppender",
      "kind" : "struct",
      "line" : 2422,
      "members" : [
       {
        "name" : "impl",
        "kind" : "variable",
        "line" : 2425,
        "type" : "Appender!(A, T)"
       },
       {
        "name" : "arr",
        "kind" : "variable",
        "line" : 2426,
        "type" : "T[]*"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\nConstruct a ref appender with a given array reference.  This does not copy the\ndata.  If the array has a larger capacity as determined by arr.capacity, it\nwill be used by the appender.  $(D RefAppender) assumes that arr is a non-null\nvalue.\n\nNote, do not use builtin appending (i.e. ~=) on the original array passed in\nuntil you are done with the appender, because calls to the appender override\nthose appends.\n",
        "line" : 2439,
        "type" : "(T[]* arr)",
        "parameters" : [
         {
          "name" : "arr",
          "type" : "T[]*"
         }
        ],
        "endline" : 2443
       },
       {
        "kind" : "template",
        "line" : 2445,
        "name" : "opDispatch",
        "parameters" : [
         {
          "name" : "fn",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Args",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "opDispatch",
          "kind" : "function",
          "line" : 2445,
          "storageClass" : [
           "auto"
          ],
          "type" : "(Args args)",
          "parameters" : [
           {
            "name" : "args",
            "type" : "Args"
           }
          ],
          "endline" : 2450
         }
        ]
       },
       {
        "name" : "AppenderType",
        "kind" : "alias",
        "line" : 2452,
        "type" : "Appender!(A, T)"
       },
       {
        "kind" : "template",
        "comment" : "\nAppends one item to the managed array.\n \n",
        "line" : 2457,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string",
          "specValue" : "\"~\""
         },
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nAppends one item to the managed array.\n \n",
          "line" : 2457,
          "type" : "void(U item)",
          "parameters" : [
           {
            "name" : "item",
            "type" : "U"
           }
          ],
          "endline" : 2461
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2464,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string",
          "specValue" : "\"~\""
         },
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 2464,
          "type" : "void(Range items)",
          "parameters" : [
           {
            "name" : "items",
            "type" : "Range"
           }
          ],
          "endline" : 2468
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAppends an entire range to the managed array.\n \n",
        "line" : 2473,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string",
          "specValue" : "\"~\""
         },
         {
          "name" : "Range",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nAppends an entire range to the managed array.\n \n",
          "line" : 2473,
          "type" : "void(Range items)",
          "parameters" : [
           {
            "name" : "items",
            "type" : "Range"
           }
          ],
          "endline" : 2477
         }
        ]
       },
       {
        "name" : "capacity",
        "kind" : "function",
        "comment" : "\nReturns the capacity of the array (the maximum number of elements the\nmanaged array can accommodate before triggering a reallocation).  If any\nappending will reallocate, $(D capacity) returns $(D 0).\n \n",
        "line" : 2484,
        "type" : "const size_t()",
        "endline" : 2487
       },
       {
        "name" : "data",
        "kind" : "function",
        "comment" : "\nReturns the managed array.\n \n",
        "line" : 2492,
        "type" : "inout inout(T)[]()",
        "endline" : 2495
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Convenience function that returns an $(D Appender!(A)) object initialized\n    with $(D array).\n \n",
    "line" : 2502,
    "name" : "appender",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "type",
      "type" : "E[]"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "appender",
      "kind" : "function",
      "comment" : "\n    Convenience function that returns an $(D Appender!(A)) object initialized\n    with $(D array).\n \n",
      "line" : 2502,
      "type" : "Appender!(E[])(A array = null)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "A",
        "default" : "null"
       }
      ],
      "endline" : 2505
     }
    ]
   },
   {
    "name" : "__unittestL2507_256",
    "kind" : "function",
    "line" : 2507,
    "endline" : 2611
   },
   {
    "kind" : "template",
    "comment" : "\n    Convenience function that returns a $(D RefAppender!(A)) object initialized\n    with $(D array).  Don't use null for the $(D array) pointer, use the other\n    version of $(D appender) instead.\n \n",
    "line" : 2611,
    "name" : "appender",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "type",
      "type" : "E[]*"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "appender",
      "kind" : "function",
      "comment" : "\n    Convenience function that returns a $(D RefAppender!(A)) object initialized\n    with $(D array).  Don't use null for the $(D array) pointer, use the other\n    version of $(D appender) instead.\n \n",
      "line" : 2611,
      "type" : "RefAppender!(E[])(A array)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "A"
       }
      ],
      "endline" : 2614
     }
    ]
   },
   {
    "name" : "__unittestL2616_257",
    "kind" : "function",
    "line" : 2616,
    "endline" : 2671
   },
   {
    "kind" : "template",
    "line" : 2672,
    "name" : "SimpleSlice",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SimpleSlice",
      "kind" : "struct",
      "line" : 2672,
      "members" : [
       {
        "name" : "_b",
        "kind" : "variable",
        "line" : 2673,
        "type" : "T*"
       },
       {
        "name" : "_e",
        "kind" : "variable",
        "line" : 2673,
        "type" : "T*"
       },
       {
        "kind" : "template",
        "line" : 2675,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2675,
          "type" : "(U values)",
          "parameters" : [
           {
            "name" : "values",
            "type" : "U"
           }
          ],
          "endline" : 2680
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2682,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "line" : 2682,
          "type" : "void(R anotherSlice)",
          "parameters" : [
           {
            "name" : "anotherSlice",
            "type" : "R"
           }
          ],
          "endline" : 2703
         }
        ]
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n   Range primitives.\n \n",
        "line" : 2708,
        "type" : "const bool()",
        "endline" : 2712
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2715,
        "type" : "T()",
        "endline" : 2719
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2722,
        "type" : "void()",
        "endline" : 2726
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2729,
        "type" : "T()",
        "endline" : 2733
       },
       {
        "name" : "popBack",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2736,
        "type" : "void()",
        "endline" : 2740
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2743,
        "type" : "T(size_t n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "size_t"
         }
        ],
        "endline" : 2747
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2750,
        "type" : "const const(T)(size_t n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "size_t"
         }
        ],
        "endline" : 2754
       },
       {
        "name" : "opIndexAssign",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2757,
        "type" : "void(T value, size_t n)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         },
         {
          "name" : "n",
          "type" : "size_t"
         }
        ],
        "endline" : 2761
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2764,
        "type" : "SimpleSliceLvalue!(T)()",
        "endline" : 2770
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2773,
        "type" : "SimpleSliceLvalue!(T)(size_t x, size_t y)",
        "parameters" : [
         {
          "name" : "x",
          "type" : "size_t"
         },
         {
          "name" : "y",
          "type" : "size_t"
         }
        ],
        "endline" : 2778
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : " Returns the length of the slice.\n",
        "line" : 2783,
        "type" : "const size_t()",
        "endline" : 2786
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\n        Sets the length of the slice. Newly added elements will be filled with\n        $(D T.init).\n         \n",
        "line" : 2792,
        "type" : "void(size_t newLength)",
        "parameters" : [
         {
          "name" : "newLength",
          "type" : "size_t"
         }
        ],
        "endline" : 2798
       },
       {
        "kind" : "template",
        "comment" : " Concatenation.\n",
        "line" : 2802,
        "name" : "opCat",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCat",
          "kind" : "function",
          "comment" : " Concatenation.\n",
          "line" : 2802,
          "type" : "SimpleSlice(R another)",
          "parameters" : [
           {
            "name" : "another",
            "type" : "R"
           }
          ],
          "endline" : 2812
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Concatenation with rebinding.\n",
        "line" : 2815,
        "name" : "opCatAssign",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCatAssign",
          "kind" : "function",
          "comment" : " Concatenation with rebinding.\n",
          "line" : 2815,
          "type" : "void(R another)",
          "parameters" : [
           {
            "name" : "another",
            "type" : "R"
           }
          ],
          "endline" : 2819
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2824,
    "name" : "SimpleSliceLvalue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SimpleSliceLvalue",
      "kind" : "struct",
      "line" : 2824,
      "members" : [
       {
        "name" : "_s",
        "kind" : "variable",
        "line" : 2825,
        "type" : "SimpleSlice!(T)"
       },
       {
        "kind" : "template",
        "line" : 2828,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "line" : 2828,
          "type" : "void(R anotherSlice)",
          "parameters" : [
           {
            "name" : "anotherSlice",
            "type" : "R"
           }
          ],
          "endline" : 2849
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2852_258",
    "kind" : "function",
    "line" : 2852,
    "endline" : 2888
   }
  ]
 },
 {
  "name" : "std.ascii",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/ascii.d",
  "comment" : "\n    Functions which operate on ASCII characters.\n\n    All of the functions in std.ascii accept unicode characters but effectively\n    ignore them. All $(D isX) functions return $(D false) for unicode\n    characters, and all $(D toX) functions do nothing to unicode characters.\n\n    For functions which operate on unicode characters, see\n    $(LINK2 std_uni.html, std.uni).\n\n    References:\n        $(LINK2 http://www.digitalmars.com/d/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org/wiki/Ascii, Wikipedia)\n\n    Macros:\n        WIKI=Phobos/StdASCII\n\n    Copyright: Copyright 2000 -\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_ascii.d)\n  \n",
  "members" : [
   {
    "name" : "hexDigits",
    "kind" : "variable",
    "comment" : " 0..9A..F\n",
    "line" : 30,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"0123456789ABCDEF\""
   },
   {
    "name" : "fullHexDigits",
    "kind" : "variable",
    "comment" : " 0..9A..Fa..f\n",
    "line" : 31,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"0123456789ABCDEFabcdef\""
   },
   {
    "name" : "digits",
    "kind" : "variable",
    "comment" : " 0..9\n",
    "line" : 32,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"0123456789\""
   },
   {
    "name" : "octalDigits",
    "kind" : "variable",
    "comment" : " 0..7\n",
    "line" : 33,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"01234567\""
   },
   {
    "name" : "lowercase",
    "kind" : "variable",
    "comment" : " a..z\n",
    "line" : 34,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"abcdefghijklmnopqrstuvwxyz\""
   },
   {
    "name" : "letters",
    "kind" : "variable",
    "comment" : " A..Za..z\n",
    "line" : 36,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\""
   },
   {
    "name" : "uppercase",
    "kind" : "variable",
    "comment" : " A..Z\n",
    "line" : 37,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\""
   },
   {
    "name" : "whitespace",
    "kind" : "variable",
    "comment" : " ASCII whitespace\n",
    "line" : 38,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\" \\x09\\x0b\\x0d\\x0a\\x0c\""
   },
   {
    "name" : "newline",
    "kind" : "variable",
    "comment" : " Newline sequence for this system.\n",
    "line" : 49,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"\\x0a\""
   },
   {
    "name" : "isAlphaNum",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a letter or a number (0..9, a..z, A..Z).\n  \n",
    "line" : 58,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 61
   },
   {
    "name" : "__unittestL63_259",
    "kind" : "function",
    "line" : 63,
    "endline" : 76
   },
   {
    "name" : "isAlpha",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is an ASCII letter (A..Z, a..z).\n  \n",
    "line" : 76,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 79
   },
   {
    "name" : "__unittestL81_260",
    "kind" : "function",
    "line" : 81,
    "endline" : 94
   },
   {
    "name" : "isLower",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a lowercase ASCII letter (a..z).\n  \n",
    "line" : 94,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 97
   },
   {
    "name" : "__unittestL99_261",
    "kind" : "function",
    "line" : 99,
    "endline" : 112
   },
   {
    "name" : "isUpper",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is an uppercase ASCII letter (A..Z).\n  \n",
    "line" : 112,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 115
   },
   {
    "name" : "__unittestL117_262",
    "kind" : "function",
    "line" : 117,
    "endline" : 130
   },
   {
    "name" : "isDigit",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a digit (0..9).\n  \n",
    "line" : 130,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 133
   },
   {
    "name" : "__unittestL135_263",
    "kind" : "function",
    "line" : 135,
    "endline" : 148
   },
   {
    "name" : "isOctalDigit",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a digit in base 8 (0..7).\n  \n",
    "line" : 148,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 151
   },
   {
    "name" : "__unittestL153_264",
    "kind" : "function",
    "line" : 153,
    "endline" : 166
   },
   {
    "name" : "isHexDigit",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a digit in base 16 (0..9, A..F, a..f).\n  \n",
    "line" : 166,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 169
   },
   {
    "name" : "__unittestL171_265",
    "kind" : "function",
    "line" : 171,
    "endline" : 185
   },
   {
    "name" : "isWhite",
    "kind" : "function",
    "comment" : "\n    Whether or not $(D c) is a whitespace character. That includes the space,\n    tab, vertical tab, form feed, carriage return, and linefeed characters.\n  \n",
    "line" : 185,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 188
   },
   {
    "name" : "__unittestL190_266",
    "kind" : "function",
    "line" : 190,
    "endline" : 203
   },
   {
    "name" : "isControl",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a control character.\n  \n",
    "line" : 203,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 206
   },
   {
    "name" : "__unittestL208_267",
    "kind" : "function",
    "line" : 208,
    "endline" : 223
   },
   {
    "name" : "isPunctuation",
    "kind" : "function",
    "comment" : "\n    Whether or not $(D c) is a punctuation character. That includes all ASCII\n    characters which are not control characters, letters, digits, or whitespace.\n  \n",
    "line" : 223,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 226
   },
   {
    "name" : "__unittestL228_268",
    "kind" : "function",
    "line" : 228,
    "endline" : 244
   },
   {
    "name" : "isGraphical",
    "kind" : "function",
    "comment" : "\n    Whether or not $(D c) is a printable character other than the space\n    character.\n  \n",
    "line" : 244,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 247
   },
   {
    "name" : "__unittestL249_269",
    "kind" : "function",
    "line" : 249,
    "endline" : 264
   },
   {
    "name" : "isPrintable",
    "kind" : "function",
    "comment" : "\n    Whether or not $(D c) is a printable character - including the space\n    character.\n  \n",
    "line" : 264,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 267
   },
   {
    "name" : "__unittestL269_270",
    "kind" : "function",
    "line" : 269,
    "endline" : 285
   },
   {
    "name" : "isASCII",
    "kind" : "function",
    "comment" : "\n    Whether or not $(D c) is in the ASCII character set - i.e. in the range\n    0..0x7F.\n  \n",
    "line" : 285,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 288
   },
   {
    "name" : "__unittestL290_271",
    "kind" : "function",
    "line" : 290,
    "endline" : 303
   },
   {
    "name" : "toLower",
    "kind" : "function",
    "comment" : "\n    If $(D c) is an uppercase ASCII character, then its corresponding lowercase\n    letter is returned. Otherwise, $(D c) is returned.\n  \n",
    "line" : 303,
    "deco" : "FNaNbNfwZw",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 311
   },
   {
    "name" : "__unittestL313_272",
    "kind" : "function",
    "line" : 313,
    "endline" : 330
   },
   {
    "name" : "toUpper",
    "kind" : "function",
    "comment" : "\n    If $(D c) is a lowercase ASCII character, then its corresponding uppercase\n    letter is returned. Otherwise, $(D c) is returned.\n  \n",
    "line" : 330,
    "deco" : "FNaNbNfwZw",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 338
   },
   {
    "name" : "__unittestL340_273",
    "kind" : "function",
    "line" : 340,
    "endline" : 356
   },
   {
    "name" : "_SPC",
    "kind" : "enum member",
    "line" : 360
   },
   {
    "name" : "_CTL",
    "kind" : "enum member",
    "line" : 361
   },
   {
    "name" : "_BLK",
    "kind" : "enum member",
    "line" : 362
   },
   {
    "name" : "_HEX",
    "kind" : "enum member",
    "line" : 363
   },
   {
    "name" : "_UC",
    "kind" : "enum member",
    "line" : 364
   },
   {
    "name" : "_LC",
    "kind" : "enum member",
    "line" : 365
   },
   {
    "name" : "_PNC",
    "kind" : "enum member",
    "line" : 366
   },
   {
    "name" : "_DIG",
    "kind" : "enum member",
    "line" : 367
   },
   {
    "name" : "_ALP",
    "kind" : "enum member",
    "line" : 368
   },
   {
    "name" : "_ctype",
    "kind" : "variable",
    "protection" : "private",
    "line" : 371,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG128h",
    "originalType" : "ubyte[128]",
    "init" : "[cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)40u, cast(ubyte)40u, cast(ubyte)40u, cast(ubyte)40u, cast(ubyte)40u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)32u, cast(ubyte)72u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)132u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)129u, cast(ubyte)129u, cast(ubyte)129u, cast(ubyte)129u, cast(ubyte)129u, cast(ubyte)129u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)1u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)130u, cast(ubyte)130u, cast(ubyte)130u, cast(ubyte)130u, cast(ubyte)130u, cast(ubyte)130u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)16u, cast(ubyte)32u]"
   }
  ]
 },
 {
  "name" : "std.base64",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/base64.d",
  "comment" : "\n Encoding / Decoding Base64 format.\n\n Implemented according to $(WEB tools.ietf.org/html/rfc4648,\n RFC 4648 - The Base16, Base32, and Base64 Data Encodings).\n\n Example:\n $(D_RUN_CODE\n $(ARGS\n -----\nubyte[] data = [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e];\n\nconst(char)[] encoded = Base64.encode(data);\nassert(encoded == \"FPucA9l+\");\n\nubyte[] decoded = Base64.decode(\"FPucA9l+\");\nassert(decoded == [0x14, 0xfb, 0x9c, 0x03, 0xd9, 0x7e]);\n -----\n ), $(ARGS), $(ARGS), $(ARGS import std.base64;))\n Support Range interface using Encoder / Decoder.\n\n Example:\n $(D_RUN_CODE\n $(ARGS\n -----\n // Create MIME Base64 with CRLF, per line 76.\nFile f = File(\"./text.txt\", \"r\");\nscope(exit) f.close();\n\nAppender!string mime64 = appender!string;\n\nforeach (encoded; Base64.encoder(f.byChunk(57)))\n{\n    mime64.put(encoded);\n    mime64.put(\"\\r\\n\");\n}\n\nwriteln(mime64.data);\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.array, std.stdio: File, writeln;))\n\n Copyright: Masahiro Nakagawa 2010-.\n License:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n Authors:   Masahiro Nakagawa, Daniel Murphy (Single value Encoder and Decoder)\n Source:    $(PHOBOSSRC std/_base64.d)\n \n",
  "members" : [
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 51,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 52,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 53,
    "protection" : "private"
   },
   {
    "name" : "Base64",
    "kind" : "alias",
    "comment" : "\n The Base64\n \n",
    "line" : 61
   },
   {
    "name" : "Base64URL",
    "kind" : "alias",
    "comment" : "\n The \"URL and Filename safe\" Base64\n \n",
    "line" : 67
   },
   {
    "kind" : "template",
    "comment" : "\n Core implementation for Base64 format.\n\n Example:\n -----\n alias Base64Impl!('+', '/')                   Base64;    // The Base64 format(Already defined).\n alias Base64Impl!('!', '=', Base64.NoPadding) Base64Re;  // non-standard Base64 format for Regular expression\n -----\n\n NOTE:\n  encoded-string doesn't have padding character if set Padding parameter to NoPadding.\n \n",
    "line" : 82,
    "name" : "Base64Impl",
    "parameters" : [
     {
      "name" : "Map62th",
      "kind" : "value",
      "deco" : "a"
     },
     {
      "name" : "Map63th",
      "kind" : "value",
      "deco" : "a"
     },
     {
      "name" : "Padding",
      "kind" : "value",
      "deco" : "a",
      "defaultValue" : "'='"
     }
    ],
    "members" : [
     {
      "name" : "NoPadding",
      "kind" : "variable",
      "comment" : " represents no-padding encoding\n",
      "line" : 84,
      "storageClass" : [
       "enum"
      ],
      "init" : "'\\x00'"
     },
     {
      "name" : "EncodeMap",
      "kind" : "variable",
      "line" : 107,
      "storageClass" : [
       "immutable"
      ],
      "init" : "\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\" ~ Map62th ~ Map63th"
     },
     {
      "name" : "encodeLength",
      "kind" : "function",
      "comment" : "\n Calculates the minimum length for encoding.\n\n Params:\n  sourceLength = the length of source array.\n\n Returns:\n  the calculated length using $(D_PARAM sourceLength).\n     \n",
      "line" : 120,
      "type" : "size_t(in size_t sourceLength)",
      "parameters" : [
       {
        "name" : "sourceLength",
        "type" : "size_t",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 126
     },
     {
      "kind" : "template",
      "comment" : "\n Encodes $(D_PARAM source) into $(D_PARAM buffer).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = a buffer to store encoded result.\n\n Returns:\n  the encoded string that slices buffer.\n     \n",
      "line" : 143,
      "name" : "encode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encode",
        "kind" : "function",
        "line" : 143,
        "type" : "char[](in R1 source, R2 buffer)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "buffer",
          "type" : "R2"
         }
        ],
        "endline" : 195
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n ditto\n     \n",
      "line" : 204,
      "name" : "encode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encode",
        "kind" : "function",
        "comment" : "\n ditto\n     \n",
        "line" : 204,
        "type" : "char[](R1 source, R2 buffer)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1"
         },
         {
          "name" : "buffer",
          "type" : "R2"
         }
        ],
        "endline" : 267
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Encodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = an $(D OutputRange) to put encoded result.\n\n Returns:\n  the number of calling put.\n     \n",
      "line" : 283,
      "name" : "encode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encode",
        "kind" : "function",
        "comment" : "\n Encodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to encode.\n  range  = an $(D OutputRange) to put encoded result.\n\n Returns:\n  the number of calling put.\n     \n",
        "line" : 283,
        "type" : "size_t(in R1 source, R2 range)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "range",
          "type" : "R2"
         }
        ],
        "endline" : 337
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n ditto\n     \n",
      "line" : 346,
      "name" : "encode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encode",
        "kind" : "function",
        "comment" : "\n ditto\n     \n",
        "line" : 346,
        "type" : "size_t(R1 source, R2 range)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1"
         },
         {
          "name" : "range",
          "type" : "R2"
         }
        ],
        "endline" : 411
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Encodes $(D_PARAM source) to new buffer.\n\n Shortcut to encode(source, buffer) function.\n     \n",
      "line" : 420,
      "name" : "encode",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encode",
        "kind" : "function",
        "line" : 420,
        "type" : "char[](Range source)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "Range"
         }
        ],
        "endline" : 423
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n ditto\n     \n",
      "line" : 429,
      "name" : "encode",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encode",
        "kind" : "function",
        "comment" : "\n ditto\n     \n",
        "line" : 429,
        "type" : "char[](Range source)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "Range"
         }
        ],
        "endline" : 433
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Range that encodes chunk data at a time.\n     \n",
      "line" : 441,
      "name" : "Encoder",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "Encoder",
        "kind" : "struct",
        "line" : 441,
        "members" : [
         {
          "name" : "range_",
          "kind" : "variable",
          "line" : 443,
          "type" : "Range"
         },
         {
          "name" : "buffer_",
          "kind" : "variable",
          "line" : 444,
          "type" : "char[]"
         },
         {
          "name" : "encoded_",
          "kind" : "variable",
          "line" : 444,
          "type" : "char[]"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 448,
          "type" : "(Range range)",
          "parameters" : [
           {
            "name" : "range",
            "type" : "Range"
           }
          ],
          "endline" : 452
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
          "line" : 462,
          "type" : "const bool()",
          "endline" : 465
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the encoded string.\n         \n",
          "line" : 475,
          "type" : "char[]()",
          "endline" : 478
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
          "line" : 487,
          "type" : "void()",
          "endline" : 501
         },
         {
          "name" : "doEncoding",
          "kind" : "function",
          "line" : 526,
          "type" : "void()",
          "endline" : 534
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Range that encodes single character at a time.\n     \n",
      "line" : 542,
      "name" : "Encoder",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "Encoder",
        "kind" : "struct",
        "line" : 542,
        "members" : [
         {
          "name" : "range_",
          "kind" : "variable",
          "line" : 544,
          "type" : "Range"
         },
         {
          "name" : "first",
          "kind" : "variable",
          "line" : 545,
          "deco" : "h"
         },
         {
          "name" : "pos",
          "kind" : "variable",
          "line" : 546,
          "deco" : "i"
         },
         {
          "name" : "padding",
          "kind" : "variable",
          "line" : 546,
          "deco" : "i"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 550,
          "type" : "(Range range)",
          "parameters" : [
           {
            "name" : "range",
            "type" : "Range"
           }
          ],
          "endline" : 560
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
          "line" : 570,
          "type" : "const bool()",
          "endline" : 576
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the encoded character.\n         \n",
          "line" : 586,
          "type" : "ubyte()",
          "endline" : 589
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
          "line" : 598,
          "type" : "void()",
          "endline" : 648
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Encoder).\n\n Default $(D Encoder) encodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nFile f = File(\"text.txt\", \"r\");\nscope(exit) f.close();\n\nuint line = 0;\nforeach (encoded; Base64.encoder(f.byLine()))\n{\n    writeln(++line, \". \", encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: File, writeln;))\n\n In addition, You can use $(D Encoder) that returns encoded single character.\n This $(D Encoder) performs Range-based and lazy encoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nubyte[] data = cast(ubyte[]) \"0123456789\";\n\n // The ElementType of data is not aggregation type\nforeach (encoded; Base64.encoder(data))\n{\n    writeln(encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;))\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Encoder) object instantiated and initialized according to the arguments.\n     \n",
      "line" : 712,
      "name" : "encoder",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encoder",
        "kind" : "function",
        "comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Encoder).\n\n Default $(D Encoder) encodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nFile f = File(\"text.txt\", \"r\");\nscope(exit) f.close();\n\nuint line = 0;\nforeach (encoded; Base64.encoder(f.byLine()))\n{\n    writeln(++line, \". \", encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: File, writeln;))\n\n In addition, You can use $(D Encoder) that returns encoded single character.\n This $(D Encoder) performs Range-based and lazy encoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nubyte[] data = cast(ubyte[]) \"0123456789\";\n\n // The ElementType of data is not aggregation type\nforeach (encoded; Base64.encoder(data))\n{\n    writeln(encoded);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;))\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Encoder) object instantiated and initialized according to the arguments.\n     \n",
        "line" : 712,
        "type" : "Encoder!(Range)(Range range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "Range"
         }
        ],
        "endline" : 715
       }
      ]
     },
     {
      "name" : "DecodeMap",
      "kind" : "variable",
      "line" : 721,
      "type" : "int[(char).max + 1]",
      "init" : "['A':0, 'B':1, 'C':2, 'D':3, 'E':4, 'F':5, 'G':6, 'H':7, 'I':8, 'J':9, 'K':10, 'L':11, 'M':12, 'N':13, 'O':14, 'P':15, 'Q':16, 'R':17, 'S':18, 'T':19, 'U':20, 'V':21, 'W':22, 'X':23, 'Y':24, 'Z':25, 'a':26, 'b':27, 'c':28, 'd':29, 'e':30, 'f':31, 'g':32, 'h':33, 'i':34, 'j':35, 'k':36, 'l':37, 'm':38, 'n':39, 'o':40, 'p':41, 'q':42, 'r':43, 's':44, 't':45, 'u':46, 'v':47, 'w':48, 'x':49, 'y':50, 'z':51, '0':52, '1':53, '2':54, '3':55, '4':56, '5':57, '6':58, '7':59, '8':60, '9':61, Map62th:62, Map63th:63, Padding:-1]"
     },
     {
      "name" : "decodeLength",
      "kind" : "function",
      "comment" : "\n Calculates the minimum length for decoding.\n\n Params:\n  sourceLength = the length of source array.\n\n Returns:\n  calculated length using $(D_PARAM sourceLength).\n     \n",
      "line" : 748,
      "type" : "size_t(in size_t sourceLength)",
      "parameters" : [
       {
        "name" : "sourceLength",
        "type" : "size_t",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 754
     },
     {
      "kind" : "template",
      "line" : 760,
      "name" : "realDecodeLength",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "realDecodeLength",
        "kind" : "function",
        "line" : 760,
        "type" : "size_t(R source)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R"
         }
        ],
        "endline" : 773
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Decodes $(D_PARAM source) into $(D_PARAM buffer).\n\n Params:\n  source = an $(D InputRange) to decode.\n  buffer = a buffer to store decoded result.\n\n Returns:\n  the decoded string that slices buffer.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n     \n",
      "line" : 793,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "line" : 793,
        "type" : "ubyte[](in R1 source, R2 buffer)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "buffer",
          "type" : "R2"
         }
        ],
        "endline" : 850
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n ditto\n     \n",
      "line" : 859,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "comment" : "\n ditto\n     \n",
        "line" : 859,
        "type" : "ubyte[](R1 source, R2 buffer)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1"
         },
         {
          "name" : "buffer",
          "type" : "R2"
         }
        ],
        "endline" : 924
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Decodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to decode.\n  range  = an $(D OutputRange) to put decoded result\n\n Returns:\n  the number of calling put.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n     \n",
      "line" : 943,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "comment" : "\n Decodes $(D_PARAM source) into $(D_PARAM range).\n\n Params:\n  source = an $(D InputRange) to decode.\n  range  = an $(D OutputRange) to put decoded result\n\n Returns:\n  the number of calling put.\n\n Throws:\n  an Exception if $(D_PARAM source) has character outside base-alphabet.\n     \n",
        "line" : 943,
        "type" : "size_t(in R1 source, R2 range)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "range",
          "type" : "R2"
         }
        ],
        "endline" : 1002
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n ditto\n     \n",
      "line" : 1011,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "R1",
        "kind" : "type"
       },
       {
        "name" : "R2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "comment" : "\n ditto\n     \n",
        "line" : 1011,
        "type" : "size_t(R1 source, R2 range)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "R1"
         },
         {
          "name" : "range",
          "type" : "R2"
         }
        ],
        "endline" : 1077
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Decodes $(D_PARAM source) into new buffer.\n\n Shortcut to decode(source, buffer) function.\n     \n",
      "line" : 1086,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "line" : 1086,
        "type" : "ubyte[](Range source)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "Range"
         }
        ],
        "endline" : 1089
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n ditto\n     \n",
      "line" : 1095,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "comment" : "\n ditto\n     \n",
        "line" : 1095,
        "type" : "ubyte[](Range source)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "Range"
         }
        ],
        "endline" : 1099
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Range that decodes chunk data at a time.\n     \n",
      "line" : 1107,
      "name" : "Decoder",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "Decoder",
        "kind" : "struct",
        "line" : 1107,
        "members" : [
         {
          "name" : "range_",
          "kind" : "variable",
          "line" : 1109,
          "type" : "Range"
         },
         {
          "name" : "buffer_",
          "kind" : "variable",
          "line" : 1110,
          "type" : "ubyte[]"
         },
         {
          "name" : "decoded_",
          "kind" : "variable",
          "line" : 1110,
          "type" : "ubyte[]"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1114,
          "type" : "(Range range)",
          "parameters" : [
           {
            "name" : "range",
            "type" : "Range"
           }
          ],
          "endline" : 1118
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
          "line" : 1128,
          "type" : "const bool()",
          "endline" : 1131
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the decoded result.\n         \n",
          "line" : 1141,
          "type" : "ubyte[]()",
          "endline" : 1144
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
          "line" : 1153,
          "type" : "void()",
          "endline" : 1164
         },
         {
          "name" : "doDecoding",
          "kind" : "function",
          "line" : 1189,
          "type" : "void()",
          "endline" : 1210
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Range that decodes single character at a time.\n     \n",
      "line" : 1218,
      "name" : "Decoder",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "Decoder",
        "kind" : "struct",
        "line" : 1218,
        "members" : [
         {
          "name" : "range_",
          "kind" : "variable",
          "line" : 1220,
          "type" : "Range"
         },
         {
          "name" : "first",
          "kind" : "variable",
          "line" : 1221,
          "deco" : "h"
         },
         {
          "name" : "pos",
          "kind" : "variable",
          "line" : 1222,
          "deco" : "i"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1226,
          "type" : "(Range range)",
          "parameters" : [
           {
            "name" : "range",
            "type" : "Range"
           }
          ],
          "endline" : 1239
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : "\n Range primitive operation that checks iteration state.\n\n Returns:\n  true if there are no more elements to be iterated.\n         \n",
          "line" : 1249,
          "type" : "const bool()",
          "endline" : 1252
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : "\n Range primitive operation that returns the currently iterated element.\n\n Returns:\n  the decoded result.\n         \n",
          "line" : 1262,
          "type" : "ubyte()",
          "endline" : 1265
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : "\n Range primitive operation that advances the range to its next element.\n\n Throws:\n  an Exception when you try to call popFront on empty range.\n         \n",
          "line" : 1274,
          "type" : "void()",
          "endline" : 1333
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Decoder).\n\n Default $(D Decoder) decodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nforeach (decoded; Base64.decoder(stdin.byLine()))\n{\n    writeln(decoded);\n}\n -----\n), $(ARGS FPucA9l+), $(ARGS), $(ARGS import std.base64, std.stdio;))\n\n In addition, You can use $(D Decoder) that returns decoded single character.\n This $(D Decoder) performs Range-based and lazy decoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nauto encoded = Base64.encoder(cast(ubyte[])\"0123456789\");\nforeach (n; map!q{a - '0'}(Base64.decoder(encoded)))\n{\n    writeln(n);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;\nimport std.algorithm: map;))\n\n NOTE:\n  If you use $(D ByChunk), chunk-size should be the multiple of 4.\n  $(D Decoder) can't judge a encode-boundary.\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Decoder) object instantiated and initialized according to the arguments.\n     \n",
      "line" : 1396,
      "name" : "decoder",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decoder",
        "kind" : "function",
        "comment" : "\n Iterates through an $(D InputRange) at a time by using $(D Decoder).\n\n Default $(D Decoder) decodes chunk data.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nforeach (decoded; Base64.decoder(stdin.byLine()))\n{\n    writeln(decoded);\n}\n -----\n), $(ARGS FPucA9l+), $(ARGS), $(ARGS import std.base64, std.stdio;))\n\n In addition, You can use $(D Decoder) that returns decoded single character.\n This $(D Decoder) performs Range-based and lazy decoding.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n -----\nauto encoded = Base64.encoder(cast(ubyte[])\"0123456789\");\nforeach (n; map!q{a - '0'}(Base64.decoder(encoded)))\n{\n    writeln(n);\n}\n -----\n), $(ARGS), $(ARGS), $(ARGS import std.base64, std.stdio: writeln;\nimport std.algorithm: map;))\n\n NOTE:\n  If you use $(D ByChunk), chunk-size should be the multiple of 4.\n  $(D Decoder) can't judge a encode-boundary.\n\n Params:\n  range = an $(D InputRange) to iterate.\n\n Returns:\n  a $(D Decoder) object instantiated and initialized according to the arguments.\n     \n",
        "line" : 1396,
        "type" : "Decoder!(Range)(Range range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "Range"
         }
        ],
        "endline" : 1399
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1404,
      "name" : "decodeChar",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeChar",
        "kind" : "function",
        "line" : 1404,
        "type" : "int(char chr)",
        "parameters" : [
         {
          "name" : "chr",
          "deco" : "a"
         }
        ],
        "endline" : 1413
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1417,
      "name" : "decodeChar",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeChar",
        "kind" : "function",
        "line" : 1417,
        "type" : "int(dchar chr)",
        "parameters" : [
         {
          "name" : "chr",
          "deco" : "w"
         }
        ],
        "endline" : 1424
       }
      ]
     }
    ]
   },
   {
    "name" : "Base64Exception",
    "kind" : "class",
    "comment" : "\n Exception thrown on Base64 errors.\n \n",
    "line" : 1431,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1433,
      "deco" : "FAyaAyamZC3std6base6415Base64Exception",
      "originalType" : "(string s, string fn = __FILE__, size_t ln = __LINE__)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aya"
       },
       {
        "name" : "fn",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 1436
     }
    ]
   },
   {
    "name" : "__unittestL1440_274",
    "kind" : "function",
    "line" : 1440,
    "endline" : 1690
   }
  ]
 },
 {
  "name" : "std.bigint",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/bigint.d",
  "comment" : " Arbitrary-precision ('bignum') arithmetic\n\n Performance is optimized for numbers below ~1000 decimal digits.\n For X86 machines, highly optimised assembly routines are used.\n\n The following algorithms are currently implemented:\n $(UL\n $(LI Karatsuba multiplication)\n $(LI Squaring is optimized independently of multiplication)\n $(LI Divide-and-conquer division)\n $(LI Binary exponentiation)\n )\n\n For very large numbers, consider using the $(WEB gmplib.org, GMP library) instead.\n\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   Don Clugston\n Source: $(PHOBOSSRC std/_bigint.d)\n \n",
  "members" : [
   {
    "name" : "std.internal.math.biguintcore",
    "kind" : "import",
    "line" : 28,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 29,
    "protection" : "private",
    "selective" : [
     "FormatSpec",
     "FormatException"
    ]
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "BigInt",
    "kind" : "struct",
    "comment" : " A struct representing an arbitrary precision integer\n\n All arithmetic operations are supported, except\n unsigned shift right (>>>). Logical operations are not currently supported.\n\n BigInt implements value semantics using copy-on-write. This means that\n assignment is cheap, but operations such as x++ will cause heap\n allocation. (But note that for most bigint operations, heap allocation is\n inevitable anyway).\n\n Example:\n----------------------------------------------------\n        BigInt a = \"9588669891916142\";\n        BigInt b = \"7452469135154800\";\n        auto c = a * b;\n        assert(c == BigInt(\"71459266416693160362545788781600\"));\n        auto d = b * a;\n        assert(d == BigInt(\"71459266416693160362545788781600\"));\n        assert(d == c);\n        d = c * BigInt(\"794628672112\");\n        assert(d == BigInt(\"56783581982794522489042432639320434378739200\"));\n        auto e = c + d;\n        assert(e == BigInt(\"56783581982865981755459125799682980167520800\"));\n        auto f = d + c;\n        assert(f == e);\n        auto g = f - c;\n        assert(g == d);\n        g = f - d;\n        assert(g == c);\n        e = 12345678;\n        g = c + e;\n        auto h = g / b;\n        auto i = g % b;\n        assert(h == a);\n        assert(i == e);\n        BigInt j = \"-0x9A56_57f4_7B83_AB78\";\n        j ^^= 11;\n----------------------------------------------------\n\n \n",
    "line" : 73,
    "members" : [
     {
      "name" : "data",
      "kind" : "variable",
      "protection" : "private",
      "line" : 75,
      "deco" : "S3std8internal4math11biguintcore7BigUint",
      "offset" : 0
     },
     {
      "name" : "sign",
      "kind" : "variable",
      "protection" : "private",
      "line" : 76,
      "deco" : "b",
      "init" : "false",
      "offset" : 16
     },
     {
      "kind" : "template",
      "comment" : " Construct a BigInt from a decimal or hexadecimal string.\n The number must be in the form of a D decimal or hex literal:\n It may have a leading + or - sign; followed by \"0x\" if hexadecimal.\n Underscores are permitted.\n BUG: Should throw a IllegalArgumentException/ConvError if invalid character found\n",
      "line" : 83,
      "name" : "this",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "Axa"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 83,
        "type" : "pure (T s)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "T"
         }
        ],
        "endline" : 106
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 109,
      "name" : "this",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 109,
        "type" : "pure (T x)",
        "parameters" : [
         {
          "name" : "x",
          "type" : "T"
         }
        ],
        "endline" : 113
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 116,
      "name" : "opAssign",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n",
        "line" : 116,
        "type" : "pure BigInt(T x)",
        "parameters" : [
         {
          "name" : "x",
          "type" : "T"
         }
        ],
        "endline" : 121
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 124,
      "name" : "opAssign",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "S3std6bigint6BigInt"
       }
      ],
      "members" : [
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n",
        "line" : 124,
        "type" : "pure BigInt(T x)",
        "parameters" : [
         {
          "name" : "x",
          "type" : "T"
         }
        ],
        "endline" : 129
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 132,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "line" : 132,
        "type" : "pure BigInt(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 201
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 204,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "line" : 204,
        "type" : "pure BigInt(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 243
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 246,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "line" : 246,
        "type" : "pure BigInt(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 252
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 255,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "line" : 255,
        "type" : "pure BigInt(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 261
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 264,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "i"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "line" : 264,
        "type" : "pure int(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 273
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 276,
      "name" : "opBinaryRight",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinaryRight",
        "kind" : "function",
        "line" : 276,
        "type" : "pure BigInt(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 280
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 283,
      "name" : "opBinaryRight",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinaryRight",
        "kind" : "function",
        "line" : 283,
        "type" : "pure BigInt(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 295
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 298,
      "name" : "opBinaryRight",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinaryRight",
        "kind" : "function",
        "line" : 298,
        "type" : "pure T(T x)",
        "parameters" : [
         {
          "name" : "x",
          "type" : "T"
         }
        ],
        "endline" : 319
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 321,
      "name" : "opUnary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opUnary",
        "kind" : "function",
        "line" : 321,
        "type" : "pure BigInt()",
        "endline" : 331
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 334,
      "name" : "opUnary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opUnary",
        "kind" : "function",
        "line" : 334,
        "type" : "pure BigInt()",
        "endline" : 346
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 349,
      "name" : "opEquals",
      "parameters" : [],
      "members" : [
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\n",
        "line" : 349,
        "type" : "const pure bool(auto ref const BigInt y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "BigInt",
          "storageClass" : [
           "auto",
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 352
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 355,
      "name" : "opEquals",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\n",
        "line" : 355,
        "type" : "const pure bool(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 360
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 363,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "b"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "comment" : "\n",
        "line" : 363,
        "type" : "pure T()",
        "endline" : 366
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 369,
      "name" : "opCmp",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opCmp",
        "kind" : "function",
        "comment" : "\n",
        "line" : 369,
        "type" : "pure int(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 375
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 377,
      "name" : "opCmp",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "S3std6bigint6BigInt"
       }
      ],
      "members" : [
       {
        "name" : "opCmp",
        "kind" : "function",
        "comment" : "\n",
        "line" : 377,
        "type" : "pure int(T y)",
        "parameters" : [
         {
          "name" : "y",
          "type" : "T"
         }
        ],
        "endline" : 383
       }
      ]
     },
     {
      "name" : "toLong",
      "kind" : "function",
      "comment" : " Returns the value of this BigInt as a long,\n or +- long.max if outside the representable range.\n",
      "line" : 386,
      "deco" : "xFNaZl",
      "endline" : 392
     },
     {
      "name" : "toInt",
      "kind" : "function",
      "comment" : " Returns the value of this BigInt as an int,\n or +- int.max if outside the representable range.\n",
      "line" : 395,
      "deco" : "xFNaZi",
      "endline" : 401
     },
     {
      "name" : "uintLength",
      "kind" : "function",
      "comment" : " Number of significant uints which are used in storing this number.\n The absolute value of this BigInt is always < 2^^(32*uintLength)\n",
      "line" : 404,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNdZm",
      "originalType" : "const pure size_t()",
      "endline" : 407
     },
     {
      "name" : "ulongLength",
      "kind" : "function",
      "comment" : " Number of significant ulongs which are used in storing this number.\n The absolute value of this BigInt is always < 2^^(64*ulongLength)\n",
      "line" : 410,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNdZm",
      "originalType" : "const pure size_t()",
      "endline" : 413
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : " Convert the BigInt to string, passing it to 'sink'.\n\n $(TABLE  The output format is controlled via formatString:\n $(TR $(TD \"d\") $(TD  Decimal))\n $(TR $(TD \"x\") $(TD  Hexadecimal, lower case))\n $(TR $(TD \"X\") $(TD  Hexadecimal, upper case))\n $(TR $(TD \"s\") $(TD  Default formatting (same as \"d\") ))\n $(TR $(TD null) $(TD Default formatting (same as \"d\") ))\n )\n     \n",
      "line" : 425,
      "deco" : "xFMDFAxaZvAyaZv",
      "parameters" : [
       {
        "name" : "sink",
        "deco" : "DFAxaZv",
        "storageClass" : [
         "scope"
        ]
       },
       {
        "name" : "formatString",
        "deco" : "Aya"
       }
      ],
      "endline" : 430
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 431,
      "deco" : "xFMDFAxaZvKS3std6format18__T10FormatSpecTaZ10FormatSpecZv",
      "parameters" : [
       {
        "name" : "sink",
        "deco" : "DFAxaZv",
        "storageClass" : [
         "scope"
        ]
       },
       {
        "name" : "f",
        "deco" : "S3std6format18__T10FormatSpecTaZ10FormatSpec",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 472
     },
     {
      "name" : "negate",
      "kind" : "function",
      "protection" : "private",
      "line" : 488,
      "deco" : "FNaNbNfZv",
      "endline" : 492
     },
     {
      "name" : "isZero",
      "kind" : "function",
      "protection" : "private",
      "line" : 493,
      "deco" : "xFNaNbNfZb",
      "endline" : 496
     },
     {
      "name" : "isNegative",
      "kind" : "function",
      "protection" : "private",
      "line" : 497,
      "deco" : "xFNaNbNfZb",
      "endline" : 500
     },
     {
      "name" : "checkDivByZero",
      "kind" : "function",
      "protection" : "private",
      "line" : 502,
      "deco" : "xFNaNfZv",
      "endline" : 506
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std6bigint6BigIntKxS3std6bigint6BigIntZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std6bigint6BigInt",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std6bigint6BigInt",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "toDecimalString",
    "kind" : "function",
    "line" : 509,
    "deco" : "FS3std6bigint6BigIntZAya",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "S3std6bigint6BigInt"
     }
    ],
    "endline" : 515
   },
   {
    "name" : "toHex",
    "kind" : "function",
    "line" : 517,
    "deco" : "FS3std6bigint6BigIntZAya",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "S3std6bigint6BigInt"
     }
    ],
    "endline" : 523
   },
   {
    "name" : "__unittestL525_275",
    "kind" : "function",
    "line" : 525,
    "endline" : 558
   },
   {
    "name" : "__unittestL558_276",
    "kind" : "function",
    "line" : 558,
    "endline" : 604
   },
   {
    "name" : "__unittestL604_277",
    "kind" : "function",
    "line" : 604,
    "endline" : 655
   },
   {
    "name" : "__unittestL655_278",
    "kind" : "function",
    "line" : 655,
    "endline" : 707
   },
   {
    "name" : "__unittestL707_279",
    "kind" : "function",
    "line" : 707,
    "endline" : 733
   },
   {
    "name" : "__unittestL733_280",
    "kind" : "function",
    "line" : 733,
    "endline" : 744
   },
   {
    "name" : "__unittestL744_281",
    "kind" : "function",
    "line" : 744,
    "endline" : 755
   }
  ]
 },
 {
  "name" : "std.bitmanip",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/bitmanip.d",
  "comment" : "\nBit-level manipulation facilities.\n\nMacros:\n\nWIKI = StdBitarray\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis,\n           Alex Rønne Petersen,\n           Damian Ziemba\nSource: $(PHOBOSSRC std/_bitmanip.d)\n",
  "members" : [
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 29,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.system",
    "kind" : "import",
    "line" : 31,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 32,
    "protection" : "private"
   },
   {
    "name" : "myToStringx",
    "kind" : "function",
    "protection" : "private",
    "line" : 41,
    "deco" : "FmZAya",
    "parameters" : [
     {
      "name" : "n",
      "deco" : "m"
     }
    ],
    "endline" : 48
   },
   {
    "name" : "myToString",
    "kind" : "function",
    "protection" : "private",
    "line" : 50,
    "deco" : "FmZAya",
    "parameters" : [
     {
      "name" : "n",
      "deco" : "m"
     }
    ],
    "endline" : 53
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 55,
    "name" : "createAccessors",
    "parameters" : [
     {
      "name" : "store",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "name",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "len",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "offset",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 130,
    "name" : "createStoreName",
    "parameters" : [
     {
      "name" : "Ts",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 138,
    "name" : "createFields",
    "parameters" : [
     {
      "name" : "store",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "offset",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "Ts",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nAllows creating bit fields inside $(D_PARAM struct)s and $(D_PARAM\nclass)es.\n\nExample:\n\n----\nstruct A\n{\n    int a;\n    mixin(bitfields!(\n        uint, \"x\",    2,\n        int,  \"y\",    3,\n        uint, \"z\",    2,\n        bool, \"flag\", 1));\n}\nA obj;\nobj.x = 2;\nobj.z = obj.x;\n----\n\nThe example above creates a bitfield pack of eight bits, which fit in\none $(D_PARAM ubyte). The bitfields are allocated starting from the\nleast significant bit, i.e. x occupies the two least significant bits\nof the bitfields storage.\n\nThe sum of all bit lengths in one $(D_PARAM bitfield) instantiation\nmust be exactly 8, 16, 32, or 64. If padding is needed, just allocate\none bitfield with an empty name.\n\nExample:\n\n----\nstruct A\n{\n    mixin(bitfields!(\n        bool, \"flag1\",    1,\n        bool, \"flag2\",    1,\n        uint, \"\",         6));\n}\n----\n\nThe type of a bit field can be any integral type or enumerated\ntype. The most efficient type to store in bitfields is $(D_PARAM\nbool), followed by unsigned types, followed by signed types.\n",
    "line" : 212,
    "name" : "bitfields",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "bitfields",
      "kind" : "enum member",
      "line" : 214
     }
    ]
   },
   {
    "name" : "__unittestL217_282",
    "kind" : "function",
    "line" : 217,
    "endline" : 242
   },
   {
    "name" : "__unittestL242_283",
    "kind" : "function",
    "line" : 242,
    "endline" : 338
   },
   {
    "name" : "FloatRep",
    "kind" : "struct",
    "comment" : "\n   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM float) separately. The definition is:\n\n----\nstruct FloatRep\n{\n    union\n    {\n        float value;\n        mixin(bitfields!(\n                  uint,  \"fraction\", 23,\n                  ubyte, \"exponent\",  8,\n                  bool,  \"sign\",      1));\n    }\n    enum uint bias = 127, fractionBits = 23, exponentBits = 8, signBits = 1;\n}\n----\n",
    "line" : 339,
    "members" : [
     {
      "name" : "value",
      "kind" : "variable",
      "line" : 342,
      "deco" : "f",
      "offset" : 0
     },
     {
      "name" : "fraction",
      "kind" : "function",
      "line" : 343,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZk",
      "originalType" : "const pure nothrow uint()",
      "endline" : 343
     },
     {
      "name" : "fraction",
      "kind" : "function",
      "line" : 344,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfkZv",
      "originalType" : "pure nothrow void(uint v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "k"
       }
      ],
      "endline" : 344
     },
     {
      "name" : "fraction_min",
      "kind" : "variable",
      "line" : 345,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "0u"
     },
     {
      "name" : "fraction_max",
      "kind" : "variable",
      "line" : 345,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "8388607u"
     },
     {
      "name" : "exponent",
      "kind" : "function",
      "line" : 345,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 345
     },
     {
      "name" : "exponent",
      "kind" : "function",
      "line" : 346,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfhZv",
      "originalType" : "pure nothrow void(ubyte v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "h"
       }
      ],
      "endline" : 346
     },
     {
      "name" : "exponent_min",
      "kind" : "variable",
      "line" : 347,
      "storageClass" : [
       "enum"
      ],
      "deco" : "h",
      "init" : "cast(ubyte)0u"
     },
     {
      "name" : "exponent_max",
      "kind" : "variable",
      "line" : 347,
      "storageClass" : [
       "enum"
      ],
      "deco" : "h",
      "init" : "cast(ubyte)255u"
     },
     {
      "name" : "sign",
      "kind" : "function",
      "line" : 347,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 347
     },
     {
      "name" : "sign",
      "kind" : "function",
      "line" : 348,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfbZv",
      "originalType" : "pure nothrow void(bool v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "b"
       }
      ],
      "endline" : 348
     },
     {
      "name" : "_fraction_exponent_sign",
      "kind" : "variable",
      "protection" : "private",
      "line" : 349,
      "deco" : "k",
      "offset" : 0
     },
     {
      "name" : "bias",
      "kind" : "variable",
      "line" : 348,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "127u"
     },
     {
      "name" : "fractionBits",
      "kind" : "variable",
      "line" : 348,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "23u"
     },
     {
      "name" : "exponentBits",
      "kind" : "variable",
      "line" : 348,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "8u"
     },
     {
      "name" : "signBits",
      "kind" : "variable",
      "line" : 348,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "1u"
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std8bitmanip8FloatRepKxS3std8bitmanip8FloatRepZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std8bitmanip8FloatRep",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std8bitmanip8FloatRep",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "DoubleRep",
    "kind" : "struct",
    "comment" : "\n   Allows manipulating the fraction, exponent, and sign parts of a\n   $(D_PARAM double) separately. The definition is:\n\n----\nstruct DoubleRep\n{\n    union\n    {\n        double value;\n        mixin(bitfields!(\n                  ulong,   \"fraction\", 52,\n                  ushort,  \"exponent\", 11,\n                  bool,    \"sign\",      1));\n    }\n    enum uint bias = 1023, signBits = 1, fractionBits = 52, exponentBits = 11;\n}\n----\n",
    "line" : 372,
    "members" : [
     {
      "name" : "value",
      "kind" : "variable",
      "line" : 375,
      "deco" : "d",
      "offset" : 0
     },
     {
      "name" : "fraction",
      "kind" : "function",
      "line" : 376,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZm",
      "originalType" : "const pure nothrow ulong()",
      "endline" : 376
     },
     {
      "name" : "fraction",
      "kind" : "function",
      "line" : 377,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfmZv",
      "originalType" : "pure nothrow void(ulong v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "m"
       }
      ],
      "endline" : 377
     },
     {
      "name" : "fraction_min",
      "kind" : "variable",
      "line" : 378,
      "storageClass" : [
       "enum"
      ],
      "deco" : "m",
      "init" : "0LU"
     },
     {
      "name" : "fraction_max",
      "kind" : "variable",
      "line" : 378,
      "storageClass" : [
       "enum"
      ],
      "deco" : "m",
      "init" : "4503599627370495LU"
     },
     {
      "name" : "exponent",
      "kind" : "function",
      "line" : 378,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZt",
      "originalType" : "const pure nothrow ushort()",
      "endline" : 378
     },
     {
      "name" : "exponent",
      "kind" : "function",
      "line" : 379,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNftZv",
      "originalType" : "pure nothrow void(ushort v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "t"
       }
      ],
      "endline" : 379
     },
     {
      "name" : "exponent_min",
      "kind" : "variable",
      "line" : 380,
      "storageClass" : [
       "enum"
      ],
      "deco" : "t",
      "init" : "cast(ushort)0u"
     },
     {
      "name" : "exponent_max",
      "kind" : "variable",
      "line" : 380,
      "storageClass" : [
       "enum"
      ],
      "deco" : "t",
      "init" : "cast(ushort)2047u"
     },
     {
      "name" : "sign",
      "kind" : "function",
      "line" : 380,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 380
     },
     {
      "name" : "sign",
      "kind" : "function",
      "line" : 381,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfbZv",
      "originalType" : "pure nothrow void(bool v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "b"
       }
      ],
      "endline" : 381
     },
     {
      "name" : "_fraction_exponent_sign",
      "kind" : "variable",
      "protection" : "private",
      "line" : 382,
      "deco" : "m",
      "offset" : 0
     },
     {
      "name" : "bias",
      "kind" : "variable",
      "line" : 381,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "1023u"
     },
     {
      "name" : "signBits",
      "kind" : "variable",
      "line" : 381,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "1u"
     },
     {
      "name" : "fractionBits",
      "kind" : "variable",
      "line" : 381,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "52u"
     },
     {
      "name" : "exponentBits",
      "kind" : "variable",
      "line" : 381,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "11u"
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std8bitmanip9DoubleRepKxS3std8bitmanip9DoubleRepZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std8bitmanip9DoubleRep",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std8bitmanip9DoubleRep",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL384_284",
    "kind" : "function",
    "line" : 384,
    "endline" : 416
   },
   {
    "name" : "BitArray",
    "kind" : "struct",
    "comment" : "\n An array of bits.\n \n",
    "line" : 417,
    "members" : [
     {
      "name" : "len",
      "kind" : "variable",
      "line" : 418,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 0
     },
     {
      "name" : "ptr",
      "kind" : "variable",
      "line" : 419,
      "deco" : "Pm",
      "originalType" : "size_t*",
      "offset" : 8
     },
     {
      "name" : "bitsPerSizeT",
      "kind" : "variable",
      "line" : 420,
      "storageClass" : [
       "enum"
      ],
      "deco" : "m",
      "init" : "64LU"
     },
     {
      "name" : "dim",
      "kind" : "function",
      "comment" : "\n Gets the amount of native words backing this $(D BitArray).\n     \n",
      "line" : 425,
      "storageClass" : [
       "const",
       "@property"
      ],
      "deco" : "xFNdZm",
      "originalType" : "size_t()",
      "endline" : 428
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "\n Gets the amount of bits in the $(D BitArray).\n     \n",
      "line" : 433,
      "storageClass" : [
       "const",
       "@property"
      ],
      "deco" : "xFNdZm",
      "originalType" : "size_t()",
      "endline" : 436
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "\n Sets the amount of bits in the $(D BitArray).\n     \n",
      "line" : 441,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdmZm",
      "originalType" : "size_t(size_t newlen)",
      "parameters" : [
       {
        "name" : "newlen",
        "deco" : "m"
       }
      ],
      "endline" : 463
     },
     {
      "name" : "opIndex",
      "kind" : "function",
      "comment" : "\n Gets the $(D i)'th bit in the $(D BitArray).\n     \n",
      "line" : 468,
      "deco" : "xFmZb",
      "originalType" : "const bool(size_t i)",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 477
     },
     {
      "name" : "__unittestL479_285",
      "kind" : "function",
      "line" : 479,
      "endline" : 495
     },
     {
      "name" : "opIndexAssign",
      "kind" : "function",
      "comment" : "\n Sets the $(D i)'th bit in the $(D BitArray).\n     \n",
      "line" : 495,
      "deco" : "FbmZb",
      "originalType" : "bool(bool b, size_t i)",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "b"
       },
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 507
     },
     {
      "name" : "dup",
      "kind" : "function",
      "comment" : "\n Duplicates the $(D BitArray) and its contents.\n     \n",
      "line" : 512,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZS3std8bitmanip8BitArray",
      "originalType" : "const BitArray()",
      "endline" : 520
     },
     {
      "name" : "__unittestL522_286",
      "kind" : "function",
      "line" : 522,
      "endline" : 543
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : "\n Support for $(D foreach) loops for $(D BitArray).\n     \n",
      "line" : 543,
      "deco" : "FMDFKbZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKbZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 556
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : " ditto \n",
      "line" : 559,
      "deco" : "xFMDFbZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFbZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 571
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : " ditto \n",
      "line" : 574,
      "deco" : "FMDFKmKbZiZi",
      "originalType" : "int(scope int delegate(ref size_t, ref bool) dg)",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKmKbZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 587
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : " ditto \n",
      "line" : 590,
      "deco" : "xFMDFmbZiZi",
      "originalType" : "const int(scope int delegate(size_t, bool) dg)",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFmbZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 602
     },
     {
      "name" : "__unittestL604_287",
      "kind" : "function",
      "line" : 604,
      "endline" : 641
     },
     {
      "name" : "reverse",
      "kind" : "function",
      "comment" : "\n Reverses the bits of the $(D BitArray).\n     \n",
      "line" : 641,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std8bitmanip8BitArray",
      "originalType" : "BitArray()",
      "endline" : 663
     },
     {
      "name" : "__unittestL665_288",
      "kind" : "function",
      "line" : 665,
      "endline" : 685
     },
     {
      "name" : "sort",
      "kind" : "function",
      "comment" : "\n Sorts the $(D BitArray)'s elements.\n     \n",
      "line" : 685,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std8bitmanip8BitArray",
      "originalType" : "BitArray()",
      "endline" : 728
     },
     {
      "name" : "__unittestL730_289",
      "kind" : "function",
      "line" : 730,
      "endline" : 747
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Support for operators == and != for $(D BitArray).\n     \n",
      "line" : 747,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFKxS3std8bitmanip8BitArrayZb",
      "originalType" : "bool(ref const BitArray a2)",
      "parameters" : [
       {
        "name" : "a2",
        "deco" : "xS3std8bitmanip8BitArray",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 766
     },
     {
      "name" : "__unittestL768_290",
      "kind" : "function",
      "line" : 768,
      "endline" : 793
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Supports comparison operators for $(D BitArray).\n     \n",
      "line" : 793,
      "deco" : "xFS3std8bitmanip8BitArrayZi",
      "parameters" : [
       {
        "name" : "a2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 816
     },
     {
      "name" : "__unittestL818_291",
      "kind" : "function",
      "line" : 818,
      "endline" : 860
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Support for hashing for $(D BitArray).\n     \n",
      "line" : 860,
      "deco" : "xFNaNbZm",
      "originalType" : "const pure nothrow size_t()",
      "endline" : 875
     },
     {
      "name" : "init",
      "kind" : "function",
      "comment" : "\n Set this $(D BitArray) to the contents of $(D ba).\n     \n",
      "line" : 880,
      "deco" : "FAbZv",
      "parameters" : [
       {
        "name" : "ba",
        "deco" : "Ab"
       }
      ],
      "endline" : 887
     },
     {
      "name" : "init",
      "kind" : "function",
      "comment" : "\n Map the $(D BitArray) onto $(D v), with $(D numbits) being the number of bits\n in the array. Does not copy the data.\n\n This is the inverse of $(D opCast).\n     \n",
      "line" : 896,
      "deco" : "FAvmZv",
      "originalType" : "void(void[] v, size_t numbits)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "Av"
       },
       {
        "name" : "numbits",
        "deco" : "m"
       }
      ],
      "endline" : 906
     },
     {
      "name" : "__unittestL908_292",
      "kind" : "function",
      "line" : 908,
      "endline" : 936
     },
     {
      "kind" : "template",
      "comment" : "\n Convert to $(D void[]).\n     \n",
      "line" : 936,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "Av"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "comment" : "\n Convert to $(D void[]).\n     \n",
        "line" : 936,
        "type" : "void[]()",
        "endline" : 939
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n Convert to $(D size_t[]).\n     \n",
      "line" : 944,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type",
        "deco" : "Am"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "comment" : "\n Convert to $(D size_t[]).\n     \n",
        "line" : 944,
        "type" : "size_t[]()",
        "endline" : 947
       }
      ]
     },
     {
      "name" : "__unittestL949_293",
      "kind" : "function",
      "line" : 949,
      "endline" : 964
     },
     {
      "name" : "opCom",
      "kind" : "function",
      "comment" : "\n Support for unary operator ~ for $(D BitArray).\n     \n",
      "line" : 964,
      "deco" : "FZS3std8bitmanip8BitArray",
      "endline" : 976
     },
     {
      "name" : "__unittestL978_294",
      "kind" : "function",
      "line" : 978,
      "endline" : 998
     },
     {
      "name" : "opAnd",
      "kind" : "function",
      "comment" : "\n Support for binary operator & for $(D BitArray).\n     \n",
      "line" : 998,
      "deco" : "FS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1013
     },
     {
      "name" : "__unittestL1015_295",
      "kind" : "function",
      "line" : 1015,
      "endline" : 1038
     },
     {
      "name" : "opOr",
      "kind" : "function",
      "comment" : "\n Support for binary operator | for $(D BitArray).\n     \n",
      "line" : 1038,
      "deco" : "xFS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1053
     },
     {
      "name" : "__unittestL1055_296",
      "kind" : "function",
      "line" : 1055,
      "endline" : 1078
     },
     {
      "name" : "opXor",
      "kind" : "function",
      "comment" : "\n Support for binary operator ^ for $(D BitArray).\n     \n",
      "line" : 1078,
      "deco" : "xFS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1093
     },
     {
      "name" : "__unittestL1095_297",
      "kind" : "function",
      "line" : 1095,
      "endline" : 1120
     },
     {
      "name" : "opSub",
      "kind" : "function",
      "comment" : "\n Support for binary operator - for $(D BitArray).\n\n $(D a - b) for $(D BitArray) means the same thing as $(D a &amp; ~b).\n     \n",
      "line" : 1120,
      "deco" : "xFS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1135
     },
     {
      "name" : "__unittestL1137_298",
      "kind" : "function",
      "line" : 1137,
      "endline" : 1160
     },
     {
      "name" : "opAndAssign",
      "kind" : "function",
      "comment" : "\n Support for operator &= for $(D BitArray).\n     \n",
      "line" : 1160,
      "deco" : "FS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1172
     },
     {
      "name" : "__unittestL1174_299",
      "kind" : "function",
      "line" : 1174,
      "endline" : 1196
     },
     {
      "name" : "opOrAssign",
      "kind" : "function",
      "comment" : "\n Support for operator |= for $(D BitArray).\n     \n",
      "line" : 1196,
      "deco" : "FS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1208
     },
     {
      "name" : "__unittestL1210_300",
      "kind" : "function",
      "line" : 1210,
      "endline" : 1231
     },
     {
      "name" : "opXorAssign",
      "kind" : "function",
      "comment" : "\n Support for operator ^= for $(D BitArray).\n     \n",
      "line" : 1231,
      "deco" : "FS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1243
     },
     {
      "name" : "__unittestL1245_301",
      "kind" : "function",
      "line" : 1245,
      "endline" : 1268
     },
     {
      "name" : "opSubAssign",
      "kind" : "function",
      "comment" : "\n Support for operator -= for $(D BitArray).\n\n $(D a -= b) for $(D BitArray) means the same thing as $(D a &amp;= ~b).\n     \n",
      "line" : 1268,
      "deco" : "FS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "e2",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1280
     },
     {
      "name" : "__unittestL1282_302",
      "kind" : "function",
      "line" : 1282,
      "endline" : 1304
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n Support for operator ~= for $(D BitArray).\n     \n",
      "line" : 1304,
      "deco" : "FbZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "b"
       }
      ],
      "endline" : 1309
     },
     {
      "name" : "__unittestL1311_303",
      "kind" : "function",
      "line" : 1311,
      "endline" : 1335
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n ditto\n     \n",
      "line" : 1335,
      "deco" : "FS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1342
     },
     {
      "name" : "__unittestL1344_304",
      "kind" : "function",
      "line" : 1344,
      "endline" : 1369
     },
     {
      "name" : "opCat",
      "kind" : "function",
      "comment" : "\n Support for binary operator ~ for $(D BitArray).\n     \n",
      "line" : 1369,
      "deco" : "xFbZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "b"
       }
      ],
      "endline" : 1377
     },
     {
      "name" : "opCat_r",
      "kind" : "function",
      "comment" : " ditto \n",
      "line" : 1380,
      "deco" : "xFbZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "b"
       }
      ],
      "endline" : 1389
     },
     {
      "name" : "opCat",
      "kind" : "function",
      "comment" : " ditto \n",
      "line" : 1392,
      "deco" : "xFS3std8bitmanip8BitArrayZS3std8bitmanip8BitArray",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "S3std8bitmanip8BitArray"
       }
      ],
      "endline" : 1399
     },
     {
      "name" : "__unittestL1401_305",
      "kind" : "function",
      "line" : 1401,
      "endline" : 1432
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std8bitmanip8BitArrayKxS3std8bitmanip8BitArrayZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std8bitmanip8BitArray",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std8bitmanip8BitArray",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Swaps the endianness of the given integral value or character.\n  \n",
    "line" : 1437,
    "name" : "swapEndian",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swapEndian",
      "kind" : "function",
      "comment" : "\n    Swaps the endianness of the given integral value or character.\n  \n",
      "line" : 1437,
      "type" : "pure nothrow @safe T(T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1452
     }
    ]
   },
   {
    "name" : "swapEndianImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 1454,
    "deco" : "FNaNbNftZt",
    "parameters" : [
     {
      "name" : "val",
      "deco" : "t"
     }
    ],
    "endline" : 1458
   },
   {
    "name" : "swapEndianImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 1460,
    "deco" : "FNaNbNekZk",
    "parameters" : [
     {
      "name" : "val",
      "deco" : "k"
     }
    ],
    "endline" : 1463
   },
   {
    "name" : "swapEndianImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 1465,
    "deco" : "FNaNbNemZm",
    "parameters" : [
     {
      "name" : "val",
      "deco" : "m"
     }
    ],
    "endline" : 1469
   },
   {
    "name" : "__unittestL1471_306",
    "kind" : "function",
    "line" : 1471,
    "endline" : 1519
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1521,
    "name" : "EndianSwapper",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "EndianSwapper",
      "kind" : "union",
      "line" : 1521,
      "members" : [
       {
        "name" : "value",
        "kind" : "variable",
        "line" : 1522,
        "type" : "Unqual!(T)"
       },
       {
        "name" : "array",
        "kind" : "variable",
        "line" : 1523,
        "type" : "ubyte[T.sizeof]"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Converts the given value from the native endianness to big endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToBigEndian(d);\nassert(d == bigEndianToNative!double(swappedD));\n--------------------\n  \n",
    "line" : 1557,
    "name" : "nativeToBigEndian",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nativeToBigEndian",
      "kind" : "function",
      "comment" : "\n    Converts the given value from the native endianness to big endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToBigEndian(d);\nassert(d == bigEndianToNative!double(swappedD));\n--------------------\n  \n",
      "line" : 1557,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1561
     }
    ]
   },
   {
    "name" : "__unittestL1564_307",
    "kind" : "function",
    "line" : 1564,
    "endline" : 1575
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1575,
    "name" : "nativeToBigEndianImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nativeToBigEndianImpl",
      "kind" : "function",
      "line" : 1575,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1586
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1588,
    "name" : "nativeToBigEndianImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nativeToBigEndianImpl",
      "kind" : "function",
      "line" : 1588,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1595
     }
    ]
   },
   {
    "name" : "__unittestL1597_308",
    "kind" : "function",
    "line" : 1597,
    "endline" : 1689
   },
   {
    "kind" : "template",
    "comment" : "\n    Converts the given value from big endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToBigEndian(c);\nassert(c == bigEndianToNative!dchar(swappedC));\n--------------------\n  \n",
    "line" : 1689,
    "name" : "bigEndianToNative",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "bigEndianToNative",
      "kind" : "function",
      "comment" : "\n    Converts the given value from big endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToBigEndian(i);\nassert(i == bigEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToBigEndian(c);\nassert(c == bigEndianToNative!dchar(swappedC));\n--------------------\n  \n",
      "line" : 1689,
      "type" : "pure nothrow @safe T(ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1693
     }
    ]
   },
   {
    "name" : "__unittestL1696_309",
    "kind" : "function",
    "line" : 1696,
    "endline" : 1707
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1707,
    "name" : "bigEndianToNativeImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "bigEndianToNativeImpl",
      "kind" : "function",
      "line" : 1707,
      "type" : "pure nothrow @safe T(ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1720
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1722,
    "name" : "bigEndianToNativeImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "bigEndianToNativeImpl",
      "kind" : "function",
      "line" : 1722,
      "type" : "pure nothrow @safe T(ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1729
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Converts the given value from the native endianness to little endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToLittleEndian(d);\nassert(d == littleEndianToNative!double(swappedD));\n--------------------\n  \n",
    "line" : 1752,
    "name" : "nativeToLittleEndian",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nativeToLittleEndian",
      "kind" : "function",
      "comment" : "\n    Converts the given value from the native endianness to little endian and\n    returns it as a $(D ubyte[n]) where $(D n) is the size of the given type.\n\n    Returning a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n        Examples:\n--------------------\nint i = 12345;\nubyte[4] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!int(swappedI));\n\ndouble d = 123.45;\nubyte[8] swappedD = nativeToLittleEndian(d);\nassert(d == littleEndianToNative!double(swappedD));\n--------------------\n  \n",
      "line" : 1752,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1756
     }
    ]
   },
   {
    "name" : "__unittestL1759_310",
    "kind" : "function",
    "line" : 1759,
    "endline" : 1770
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1770,
    "name" : "nativeToLittleEndianImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nativeToLittleEndianImpl",
      "kind" : "function",
      "line" : 1770,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1781
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1783,
    "name" : "nativeToLittleEndianImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nativeToLittleEndianImpl",
      "kind" : "function",
      "line" : 1783,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1790
     }
    ]
   },
   {
    "name" : "__unittestL1792_311",
    "kind" : "function",
    "line" : 1792,
    "endline" : 1857
   },
   {
    "kind" : "template",
    "comment" : "\n    Converts the given value from little endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToLittleEndian(c);\nassert(c == littleEndianToNative!dchar(swappedC));\n--------------------\n  \n",
    "line" : 1857,
    "name" : "littleEndianToNative",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "littleEndianToNative",
      "kind" : "function",
      "comment" : "\n    Converts the given value from little endian to the native endianness and\n    returns it. The value is given as a $(D ubyte[n]) where $(D n) is the size\n    of the target type. You must give the target type as a template argument,\n    because there are multiple types with the same size and so the type of the\n    argument is not enough to determine the return type.\n\n    Taking a $(D ubyte[n]) helps prevent accidentally using a swapped value\n    as a regular one (and in the case of floating point values, it's necessary,\n    because the FPU will mess up any swapped floating point values. So, you\n    can't actually have swapped floating point values as floating point values).\n\n    $(D real) is not supported, because its size is implementation-dependent\n    and therefore could vary from machine to machine (which could make it\n    unusable if you tried to transfer it to another machine).\n\n        Examples:\n--------------------\nushort i = 12345;\nubyte[2] swappedI = nativeToLittleEndian(i);\nassert(i == littleEndianToNative!ushort(swappedI));\n\ndchar c = 'D';\nubyte[4] swappedC = nativeToLittleEndian(c);\nassert(c == littleEndianToNative!dchar(swappedC));\n--------------------\n  \n",
      "line" : 1857,
      "type" : "pure nothrow @safe T(ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1861
     }
    ]
   },
   {
    "name" : "__unittestL1864_312",
    "kind" : "function",
    "line" : 1864,
    "endline" : 1875
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1875,
    "name" : "littleEndianToNativeImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "littleEndianToNativeImpl",
      "kind" : "function",
      "line" : 1875,
      "type" : "pure nothrow @safe T(ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1888
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1890,
    "name" : "littleEndianToNativeImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "littleEndianToNativeImpl",
      "kind" : "function",
      "line" : 1890,
      "type" : "pure nothrow @safe T(ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1898
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1900,
    "name" : "floatEndianImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "swap",
      "kind" : "value",
      "deco" : "b"
     }
    ],
    "members" : [
     {
      "name" : "floatEndianImpl",
      "kind" : "function",
      "line" : 1900,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T"
       }
      ],
      "endline" : 1910
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1912,
    "name" : "floatEndianImpl",
    "parameters" : [
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "swap",
      "kind" : "value",
      "deco" : "b"
     }
    ],
    "members" : [
     {
      "name" : "floatEndianImpl",
      "kind" : "function",
      "line" : 1912,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (ubyte[n] val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "ubyte[n]"
       }
      ],
      "endline" : 1924
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1926,
    "name" : "isFloatOrDouble",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isFloatOrDouble",
      "kind" : "variable",
      "line" : 1929,
      "storageClass" : [
       "enum"
      ],
      "init" : "isFloatingPoint!(T) && !is(Unqual!(FloatingPointTypeOf!(T)) == real)"
     }
    ]
   },
   {
    "name" : "__unittestL1932_313",
    "kind" : "function",
    "line" : 1932,
    "endline" : 1952
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1952,
    "name" : "canSwapEndianness",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "canSwapEndianness",
      "kind" : "variable",
      "line" : 1957,
      "storageClass" : [
       "enum"
      ],
      "init" : "isIntegral!(T) || isSomeChar!(T) || isBoolean!(T) || isFloatOrDouble!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL1960_314",
    "kind" : "function",
    "line" : 1960,
    "endline" : 2022
   },
   {
    "kind" : "template",
    "comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The range is not consumed.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n        index = The index to start reading from (instead of starting at the\n                front). If index is a pointer, then it is updated to the index\n                after the bytes read. The overloads with index are only\n                available if $(D hasSlicing!R) is $(D true).\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.peek!uint() == 17110537);\nassert(buffer.peek!ushort() == 261);\nassert(buffer.peek!ubyte() == 1);\n\nassert(buffer.peek!uint(2) == 369700095);\nassert(buffer.peek!ushort(2) == 5641);\nassert(buffer.peek!ubyte(2) == 22);\n\nsize_t index = 0;\nassert(buffer.peek!ushort(&index) == 261);\nassert(index == 2);\n\nassert(buffer.peek!uint(&index) == 369700095);\nassert(index == 6);\n\nassert(buffer.peek!ubyte(&index) == 8);\nassert(index == 7);\n--------------------\n  \n",
    "line" : 2022,
    "name" : "peek",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "peek",
      "kind" : "function",
      "comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The range is not consumed.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n        index = The index to start reading from (instead of starting at the\n                front). If index is a pointer, then it is updated to the index\n                after the bytes read. The overloads with index are only\n                available if $(D hasSlicing!R) is $(D true).\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.peek!uint() == 17110537);\nassert(buffer.peek!ushort() == 261);\nassert(buffer.peek!ubyte() == 1);\n\nassert(buffer.peek!uint(2) == 369700095);\nassert(buffer.peek!ushort(2) == 5641);\nassert(buffer.peek!ubyte(2) == 22);\n\nsize_t index = 0;\nassert(buffer.peek!ushort(&index) == 261);\nassert(index == 2);\n\nassert(buffer.peek!uint(&index) == 369700095);\nassert(index == 6);\n\nassert(buffer.peek!ubyte(&index) == 8);\nassert(index == 7);\n--------------------\n  \n",
      "line" : 2022,
      "type" : "T(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 2046
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 2049,
    "name" : "peek",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "peek",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 2049,
      "type" : "T(R range, size_t index)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 2056
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 2059,
    "name" : "peek",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "peek",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 2059,
      "type" : "T(R range, size_t* index)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "index",
        "type" : "size_t*"
       }
      ],
      "endline" : 2076
     }
    ]
   },
   {
    "name" : "__unittestL2079_315",
    "kind" : "function",
    "line" : 2079,
    "endline" : 2101
   },
   {
    "name" : "__unittestL2101_316",
    "kind" : "function",
    "line" : 2101,
    "endline" : 2302
   },
   {
    "name" : "__unittestL2302_317",
    "kind" : "function",
    "line" : 2302,
    "endline" : 2339
   },
   {
    "kind" : "template",
    "comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The $(D T.sizeof) bytes which are read are consumed from\n    the range.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.length == 7);\n\nassert(buffer.read!ushort() == 261);\nassert(buffer.length == 5);\n\nassert(buffer.read!uint() == 369700095);\nassert(buffer.length == 1);\n\nassert(buffer.read!ubyte() == 8);\nassert(buffer.empty);\n--------------------\n  \n",
    "line" : 2339,
    "name" : "read",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "read",
      "kind" : "function",
      "comment" : "\n    Takes a range of $(D ubyte)s and converts the first $(D T.sizeof) bytes to\n    $(D T). The value returned is converted from the given endianness to the\n    native endianness. The $(D T.sizeof) bytes which are read are consumed from\n    the range.\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness that the bytes are assumed to be in.\n        range = The range to read from.\n\n        Examples:\n--------------------\nubyte[] buffer = [1, 5, 22, 9, 44, 255, 8];\nassert(buffer.length == 7);\n\nassert(buffer.read!ushort() == 261);\nassert(buffer.length == 5);\n\nassert(buffer.read!uint() == 369700095);\nassert(buffer.length == 1);\n\nassert(buffer.read!ubyte() == 8);\nassert(buffer.empty);\n--------------------\n  \n",
      "line" : 2339,
      "type" : "T(ref R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2362
     }
    ]
   },
   {
    "name" : "__unittestL2365_318",
    "kind" : "function",
    "line" : 2365,
    "endline" : 2380
   },
   {
    "name" : "__unittestL2380_319",
    "kind" : "function",
    "line" : 2380,
    "endline" : 2553
   },
   {
    "name" : "__unittestL2553_320",
    "kind" : "function",
    "line" : 2553,
    "endline" : 2626
   },
   {
    "kind" : "template",
    "comment" : "\n    Takes an integral value, converts it to the given endianness, and writes it\n    to the given range of $(D ubyte)s as a sequence of $(D T.sizeof) $(D ubyte)s\n    starting at index. $(D hasSlicing!R) must be $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to write to.\n        index = The index to start writing to. If index is a pointer, then it\n                is updated to the index after the bytes read.\n\n        Examples:\n--------------------\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(29110231u, 0);\n    assert(buffer == [1, 188, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ushort(927, 0);\n    assert(buffer == [3, 159, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ubyte(42, 0);\n    assert(buffer == [42, 159, 47, 215, 0, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(142700095u, 2);\n    assert(buffer == [0, 0, 8, 129, 110, 63, 0, 0, 0]);\n\n    buffer.write!ushort(19839, 2);\n    assert(buffer == [0, 0, 77, 127, 110, 63, 0, 0, 0]);\n\n    buffer.write!ubyte(132, 2);\n    assert(buffer == [0, 0, 132, 127, 110, 63, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    size_t index = 0;\n    buffer.write!ushort(261, &index);\n    assert(buffer == [1, 5, 0, 0, 0, 0, 0, 0]);\n    assert(index == 2);\n\n    buffer.write!uint(369700095u, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 0, 0]);\n    assert(index == 6);\n\n    buffer.write!ubyte(8, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 8, 0]);\n    assert(index == 7);\n}\n--------------------\n  \n",
    "line" : 2626,
    "name" : "write",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "write",
      "kind" : "function",
      "comment" : "\n    Takes an integral value, converts it to the given endianness, and writes it\n    to the given range of $(D ubyte)s as a sequence of $(D T.sizeof) $(D ubyte)s\n    starting at index. $(D hasSlicing!R) must be $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to write to.\n        index = The index to start writing to. If index is a pointer, then it\n                is updated to the index after the bytes read.\n\n        Examples:\n--------------------\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(29110231u, 0);\n    assert(buffer == [1, 188, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ushort(927, 0);\n    assert(buffer == [3, 159, 47, 215, 0, 0, 0, 0]);\n\n    buffer.write!ubyte(42, 0);\n    assert(buffer == [42, 159, 47, 215, 0, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n    buffer.write!uint(142700095u, 2);\n    assert(buffer == [0, 0, 8, 129, 110, 63, 0, 0, 0]);\n\n    buffer.write!ushort(19839, 2);\n    assert(buffer == [0, 0, 77, 127, 110, 63, 0, 0, 0]);\n\n    buffer.write!ubyte(132, 2);\n    assert(buffer == [0, 0, 132, 127, 110, 63, 0, 0, 0]);\n}\n\n{\n    ubyte[] buffer = [0, 0, 0, 0, 0, 0, 0, 0];\n    size_t index = 0;\n    buffer.write!ushort(261, &index);\n    assert(buffer == [1, 5, 0, 0, 0, 0, 0, 0]);\n    assert(index == 2);\n\n    buffer.write!uint(369700095u, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 0, 0]);\n    assert(index == 6);\n\n    buffer.write!ubyte(8, &index);\n    assert(buffer == [1, 5, 22, 9, 44, 255, 8, 0]);\n    assert(index == 7);\n}\n--------------------\n  \n",
      "line" : 2626,
      "type" : "void(R range, T value, size_t index)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 2633
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 2636,
    "name" : "write",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 2636,
      "type" : "void(R range, T value, size_t* index)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "index",
        "type" : "size_t*"
       }
      ],
      "endline" : 2653
     }
    ]
   },
   {
    "name" : "__unittestL2656_321",
    "kind" : "function",
    "line" : 2656,
    "endline" : 2699
   },
   {
    "name" : "__unittestL2699_322",
    "kind" : "function",
    "line" : 2699,
    "endline" : 2982
   },
   {
    "kind" : "template",
    "comment" : "\n    Takes an integral value, converts it to the given endianness, and appends\n    it to the given range of $(D ubyte)s (using $(D put)) as a sequence of\n    $(D T.sizeof) $(D ubyte)s starting at index. $(D hasSlicing!R) must be\n    $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to append to.\n\n        Examples:\n--------------------\nauto buffer = appender!(const ubyte[])();\nbuffer.append!ushort(261);\nassert(buffer.data == [1, 5]);\n\nbuffer.append!uint(369700095u);\nassert(buffer.data == [1, 5, 22, 9, 44, 255]);\n\nbuffer.append!ubyte(8);\nassert(buffer.data == [1, 5, 22, 9, 44, 255, 8]);\n--------------------\n  \n",
    "line" : 2982,
    "name" : "append",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "endianness",
      "kind" : "value",
      "deco" : "E3std6system6Endian",
      "defaultValue" : "Endian.bigEndian"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "append",
      "kind" : "function",
      "comment" : "\n    Takes an integral value, converts it to the given endianness, and appends\n    it to the given range of $(D ubyte)s (using $(D put)) as a sequence of\n    $(D T.sizeof) $(D ubyte)s starting at index. $(D hasSlicing!R) must be\n    $(D true).\n\n    Parems:\n        T     = The integral type to convert the first $(D T.sizeof) bytes to.\n        endianness = The endianness to write the bytes in.\n        range = The range to append to.\n\n        Examples:\n--------------------\nauto buffer = appender!(const ubyte[])();\nbuffer.append!ushort(261);\nassert(buffer.data == [1, 5]);\n\nbuffer.append!uint(369700095u);\nassert(buffer.data == [1, 5, 22, 9, 44, 255]);\n\nbuffer.append!ubyte(8);\nassert(buffer.data == [1, 5, 22, 9, 44, 255, 8]);\n--------------------\n  \n",
      "line" : 2982,
      "type" : "void(R range, T value)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "value",
        "type" : "T"
       }
      ],
      "endline" : 2991
     }
    ]
   },
   {
    "name" : "__unittestL2994_323",
    "kind" : "function",
    "line" : 2994,
    "endline" : 3007
   },
   {
    "name" : "__unittestL3007_324",
    "kind" : "function",
    "line" : 3007,
    "endline" : 3137
   },
   {
    "name" : "__unittestL3137_325",
    "kind" : "function",
    "line" : 3137,
    "endline" : 3175
   }
  ]
 },
 {
  "name" : "std.compiler",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/compiler.d",
  "comment" : "\n Identify the compiler used and its various features.\n\n Macros:\n      WIKI = Phobos/StdCompiler\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright), Alex Rønne Petersen\n Source:    $(PHOBOSSRC std/_compiler.d)\n \n",
  "members" : [
   {
    "name" : "name",
    "kind" : "variable",
    "comment" : " Vendor specific string naming the compiler, for example: \"Digital Mars D\".\n",
    "line" : 24,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"Digital Mars D\""
   },
   {
    "name" : "Vendor",
    "kind" : "enum",
    "comment" : " Master list of D compiler vendors.\n",
    "line" : 28,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "unknown",
      "kind" : "enum member",
      "comment" : " Compiler vendor could not be detected\n",
      "line" : 29
     },
     {
      "name" : "digitalMars",
      "kind" : "enum member",
      "comment" : " Digital Mars D (DMD)\n",
      "line" : 30
     },
     {
      "name" : "gnu",
      "kind" : "enum member",
      "comment" : " GNU D Compiler (GDC)\n",
      "line" : 31
     },
     {
      "name" : "llvm",
      "kind" : "enum member",
      "comment" : " LLVM D Compiler (LDC)\n",
      "line" : 32
     },
     {
      "name" : "dotNET",
      "kind" : "enum member",
      "comment" : " D.NET\n",
      "line" : 33
     },
     {
      "name" : "sdc",
      "kind" : "enum member",
      "comment" : " Stupid D Compiler (SDC)\n",
      "line" : 34
     }
    ]
   },
   {
    "name" : "vendor",
    "kind" : "variable",
    "comment" : " Which vendor produced this compiler.\n",
    "line" : 39,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yE3std8compiler6Vendor",
    "originalType" : "Vendor",
    "init" : "cast(Vendor)1"
   },
   {
    "name" : "version_major",
    "kind" : "variable",
    "comment" : "\n The vendor specific version number, as in\n version_major.version_minor\n     \n",
    "line" : 51,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yk",
    "originalType" : "uint",
    "init" : "2u"
   },
   {
    "name" : "version_minor",
    "kind" : "variable",
    "comment" : " ditto\n",
    "line" : 52,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yk",
    "originalType" : "uint",
    "init" : "63u"
   },
   {
    "name" : "D_major",
    "kind" : "variable",
    "comment" : "\n The version of the D Programming Language Specification\n supported by the compiler.\n     \n",
    "line" : 59,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yk",
    "originalType" : "uint",
    "init" : "2u"
   },
   {
    "name" : "D_minor",
    "kind" : "variable",
    "line" : 60,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yk",
    "originalType" : "uint",
    "init" : "0u"
   }
  ]
 },
 {
  "name" : "std.complex",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/complex.d",
  "comment" : " This module contains the $(LREF Complex) type, which is used to represent\n    _complex numbers, along with related mathematical operations and functions.\n\n    $(LREF Complex) will eventually $(LINK2 ../deprecate.html, replace)\n    the built-in types $(D cfloat), $(D cdouble), $(D creal), $(D ifloat),\n    $(D idouble), and $(D ireal).\n\n    Authors:    Lars Tandle Kyllingstad, Don Clugston\n    Copyright:  Copyright (c) 2010, Lars T. Kyllingstad.\n    License:    $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Source:     $(PHOBOSSRC std/_complex.d)\n",
  "members" : [
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 18,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 19,
    "protection" : "private"
   },
   {
    "name" : "std.numeric",
    "kind" : "import",
    "line" : 20,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : " Helper function that returns a _complex number with the specified\n    real and imaginary parts.\n\n    If neither $(D re) nor $(D im) are floating-point numbers, this\n    function returns a $(D Complex!double).  Otherwise, the return type\n    is deduced using $(D std.traits.CommonType!(R, I)).\n\n    Examples:\n    ---\n    auto c = complex(2.0);\n    static assert (is(typeof(c) == Complex!double));\n    assert (c.re == 2.0);\n    assert (c.im == 0.0);\n\n    auto w = complex(2);\n    static assert (is(typeof(w) == Complex!double));\n    assert (w == c);\n\n    auto z = complex(1, 3.14L);\n    static assert (is(typeof(z) == Complex!real));\n    assert (z.re == 1.0L);\n    assert (z.im == 3.14L);\n    ---\n",
    "line" : 48,
    "name" : "complex",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "complex",
      "kind" : "function",
      "comment" : " Helper function that returns a _complex number with the specified\n    real and imaginary parts.\n\n    If neither $(D re) nor $(D im) are floating-point numbers, this\n    function returns a $(D Complex!double).  Otherwise, the return type\n    is deduced using $(D std.traits.CommonType!(R, I)).\n\n    Examples:\n    ---\n    auto c = complex(2.0);\n    static assert (is(typeof(c) == Complex!double));\n    assert (c.re == 2.0);\n    assert (c.im == 0.0);\n\n    auto w = complex(2);\n    static assert (is(typeof(w) == Complex!double));\n    assert (w == c);\n\n    auto z = complex(1, 3.14L);\n    static assert (is(typeof(z) == Complex!real));\n    assert (z.re == 1.0L);\n    assert (z.im == 3.14L);\n    ---\n",
      "line" : 48,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (T re)",
      "parameters" : [
       {
        "name" : "re",
        "type" : "T"
       }
      ],
      "endline" : 54
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 57,
    "name" : "complex",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "I",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "complex",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 57,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (R re, I im)",
      "parameters" : [
       {
        "name" : "re",
        "type" : "R"
       },
       {
        "name" : "im",
        "type" : "I"
       }
      ],
      "endline" : 64
     }
    ]
   },
   {
    "name" : "__unittestL66_326",
    "kind" : "function",
    "line" : 66,
    "endline" : 108
   },
   {
    "kind" : "template",
    "comment" : " A complex number parametrised by a type $(D T), which must be either\n    $(D float), $(D double) or $(D real).\n",
    "line" : 109,
    "name" : "Complex",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Complex",
      "kind" : "struct",
      "line" : 109,
      "members" : [
       {
        "name" : "re",
        "kind" : "variable",
        "comment" : " The real part of the number. \n",
        "line" : 111,
        "type" : "T"
       },
       {
        "name" : "im",
        "kind" : "variable",
        "comment" : " The imaginary part of the number. \n",
        "line" : 114,
        "type" : "T"
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : " Converts the complex number to a string representation.\n\n        If a $(D sink) delegate is specified, the string is passed to it\n        and this function returns $(D null).  Otherwise, this function\n        returns the string representation directly.\n\n        The output format is controlled via $(D formatSpec), which should consist\n        of a single POSIX format specifier, including the percent (%) character.\n        Note that complex numbers are floating point numbers, so the only\n        valid format characters are 'e', 'f', 'g', 'a', and 's', where 's'\n        gives the default behaviour. Positional parameters are not valid\n        in this context.\n\n        See the $(LINK2 std_format.html, std.format documentation) for\n        more information.\n    \n",
        "line" : 132,
        "type" : "const string(scope void delegate(const(char)[]) sink = null, string formatSpec = \"%s\")",
        "parameters" : [
         {
          "name" : "sink",
          "type" : "void delegate(const(char)[])",
          "storageClass" : [
           "scope"
          ],
          "default" : "null"
         },
         {
          "name" : "formatSpec",
          "type" : "string",
          "default" : "\"%s\""
         }
        ],
        "endline" : 149
       },
       {
        "kind" : "template",
        "line" : 153,
        "name" : "this",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 153,
          "type" : "(Complex!(R) z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "Complex!(R)"
           }
          ],
          "endline" : 157
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 159,
        "name" : "this",
        "parameters" : [
         {
          "name" : "Rx",
          "kind" : "type",
          "type" : "T"
         },
         {
          "name" : "Ry",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 159,
          "type" : "(Rx x, Ry y)",
          "parameters" : [
           {
            "name" : "x",
            "type" : "Rx"
           },
           {
            "name" : "y",
            "type" : "Ry"
           }
          ],
          "endline" : 163
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 165,
        "name" : "this",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 165,
          "type" : "(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 169
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 174,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "line" : 174,
          "type" : "Complex(Complex!(R) z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "Complex!(R)"
           }
          ],
          "endline" : 179
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 182,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "line" : 182,
          "type" : "Complex(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 187
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 192,
        "name" : "opEquals",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "opEquals",
          "kind" : "function",
          "line" : 192,
          "type" : "const bool(Complex!(R) z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "Complex!(R)"
           }
          ],
          "endline" : 195
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 198,
        "name" : "opEquals",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "opEquals",
          "kind" : "function",
          "line" : 198,
          "type" : "const bool(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 201
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 206,
        "name" : "opUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opUnary",
          "kind" : "function",
          "line" : 206,
          "type" : "const Complex()",
          "endline" : 210
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 213,
        "name" : "opUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opUnary",
          "kind" : "function",
          "line" : 213,
          "type" : "const Complex()",
          "endline" : 217
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 222,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "line" : 222,
          "type" : "const Complex!(CommonType!(T, R))(Complex!(R) z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "Complex!(R)"
           }
          ],
          "endline" : 227
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 230,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "line" : 230,
          "type" : "const Complex!(CommonType!(T, R))(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 236
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 239,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "line" : 239,
          "type" : "const Complex!(CommonType!(T, R))(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 243
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 246,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "line" : 246,
          "type" : "const Complex!(CommonType!(T, R))(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 250
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 253,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "line" : 253,
          "type" : "const Complex!(CommonType!(T, R))(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 277
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 282,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "C",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 282,
          "type" : "Complex(C z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "C"
           }
          ],
          "endline" : 288
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 291,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "C",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 291,
          "type" : "Complex(C z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "C"
           }
          ],
          "endline" : 298
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 301,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "C",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 301,
          "type" : "Complex(C z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "C"
           }
          ],
          "endline" : 323
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 326,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "C",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 326,
          "type" : "Complex(C z)",
          "parameters" : [
           {
            "name" : "z",
            "type" : "C"
           }
          ],
          "endline" : 337
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 340,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "U",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 340,
          "type" : "Complex(U a)",
          "parameters" : [
           {
            "name" : "a",
            "type" : "U"
           }
          ],
          "endline" : 345
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 348,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "U",
          "kind" : "type",
          "type" : "T"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 348,
          "type" : "Complex(U a)",
          "parameters" : [
           {
            "name" : "a",
            "type" : "U"
           }
          ],
          "endline" : 354
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 357,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 357,
          "type" : "Complex(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 365
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 368,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "line" : 368,
          "type" : "Complex(U i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "U"
           }
          ],
          "endline" : 392
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL395_328",
    "kind" : "function",
    "line" : 395,
    "endline" : 488
   },
   {
    "name" : "__unittestL488_329",
    "kind" : "function",
    "line" : 488,
    "endline" : 499
   },
   {
    "name" : "__unittestL499_330",
    "kind" : "function",
    "line" : 499,
    "endline" : 527
   },
   {
    "name" : "__unittestL527_333",
    "kind" : "function",
    "line" : 527,
    "endline" : 560
   },
   {
    "kind" : "template",
    "line" : 560,
    "name" : "Complex",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Complex",
      "kind" : "alias",
      "line" : 562,
      "type" : "T"
     }
    ]
   },
   {
    "name" : "__unittestL565_334",
    "kind" : "function",
    "line" : 565,
    "endline" : 584
   },
   {
    "kind" : "template",
    "comment" : " Calculates the absolute value (or modulus) of a complex number. \n",
    "line" : 584,
    "name" : "abs",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "abs",
      "kind" : "function",
      "comment" : " Calculates the absolute value (or modulus) of a complex number. \n",
      "line" : 584,
      "type" : "pure nothrow @safe T(Complex!(T) z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Complex!(T)"
       }
      ],
      "endline" : 587
     }
    ]
   },
   {
    "name" : "__unittestL589_335",
    "kind" : "function",
    "line" : 589,
    "endline" : 598
   },
   {
    "kind" : "template",
    "comment" : " Calculates the argument (or phase) of a complex number. \n",
    "line" : 598,
    "name" : "arg",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "arg",
      "kind" : "function",
      "comment" : " Calculates the argument (or phase) of a complex number. \n",
      "line" : 598,
      "type" : "pure nothrow @safe T(Complex!(T) z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Complex!(T)"
       }
      ],
      "endline" : 601
     }
    ]
   },
   {
    "name" : "__unittestL603_336",
    "kind" : "function",
    "line" : 603,
    "endline" : 612
   },
   {
    "kind" : "template",
    "comment" : " Returns the complex conjugate of a complex number. \n",
    "line" : 612,
    "name" : "conj",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "conj",
      "kind" : "function",
      "comment" : " Returns the complex conjugate of a complex number. \n",
      "line" : 612,
      "type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Complex!(T)"
       }
      ],
      "endline" : 615
     }
    ]
   },
   {
    "name" : "__unittestL617_337",
    "kind" : "function",
    "line" : 617,
    "endline" : 625
   },
   {
    "kind" : "template",
    "comment" : " Constructs a complex number given its absolute value and argument. \n",
    "line" : 625,
    "name" : "fromPolar",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "fromPolar",
      "kind" : "function",
      "comment" : " Constructs a complex number given its absolute value and argument. \n",
      "line" : 625,
      "type" : "pure nothrow @safe Complex!(CommonType!(T, U))(T modulus, U argument)",
      "parameters" : [
       {
        "name" : "modulus",
        "type" : "T"
       },
       {
        "name" : "argument",
        "type" : "U"
       }
      ],
      "endline" : 630
     }
    ]
   },
   {
    "name" : "__unittestL632_338",
    "kind" : "function",
    "line" : 632,
    "endline" : 641
   },
   {
    "kind" : "template",
    "comment" : " Trigonometric functions. \n",
    "line" : 641,
    "name" : "sin",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sin",
      "kind" : "function",
      "comment" : " Trigonometric functions. \n",
      "line" : 641,
      "type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Complex!(T)"
       }
      ],
      "endline" : 646
     }
    ]
   },
   {
    "name" : "__unittestL648_339",
    "kind" : "function",
    "line" : 648,
    "endline" : 656
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 656,
    "name" : "cos",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cos",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 656,
      "type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Complex!(T)"
       }
      ],
      "endline" : 661
     }
    ]
   },
   {
    "name" : "__unittestL663_340",
    "kind" : "function",
    "line" : 663,
    "endline" : 678
   },
   {
    "name" : "expi",
    "kind" : "function",
    "comment" : " Calculates cos(y) + i sin(y).\n\n    Note:\n    $(D expi) is included here for convenience and for easy migration of code\n    that uses $(XREF math,_expi).  Unlike $(XREF math,_expi), which uses the\n    x87 $(I fsincos) instruction when possible, this function is no faster\n    than calculating cos(y) and sin(y) separately.\n",
    "line" : 678,
    "deco" : "FNaNbNeeZS3std7complex14__T7ComplexTeZ7Complex",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 681
   },
   {
    "name" : "__unittestL683_341",
    "kind" : "function",
    "line" : 683,
    "endline" : 694
   },
   {
    "kind" : "template",
    "comment" : " Square root. \n",
    "line" : 694,
    "name" : "sqrt",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sqrt",
      "kind" : "function",
      "comment" : " Square root. \n",
      "line" : 694,
      "type" : "pure nothrow @safe Complex!(T)(Complex!(T) z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Complex!(T)"
       }
      ],
      "endline" : 735
     }
    ]
   },
   {
    "name" : "__unittestL737_342",
    "kind" : "function",
    "line" : 737,
    "endline" : 743
   }
  ]
 },
 {
  "name" : "std.concurrency",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/concurrency.d",
  "comment" : "\n This is a low-level messaging API upon which more structured or restrictive\n APIs may be built.  The general idea is that every messageable entity is\n represented by a common handle type (called a Cid in this implementation),\n which allows messages to be sent to in-process threads, on-host processes,\n and foreign-host processes using the same interface.  This is an important\n aspect of scalability because it allows the components of a program to be\n spread across available resources with few to no changes to the actual\n implementation.\n\n Right now, only in-process threads are supported and referenced by a more\n specialized handle called a Tid.  It is effectively a subclass of Cid, with\n additional features specific to in-process messaging.\n\n Synposis:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio;\n import std.concurrency;\n\n void spawnedFunc(Tid tid)\n {\n     // Receive a message from the owner thread.\n     receive(\n         (int i) { writeln(\"Received the number \", i);}\n     );\n\n     // Send a message back to the owner thread\n     // indicating success.\n     send(tid, true);\n }\n\n void main()\n {\n     // Start spawnedFunc in a new thread.\n     auto tid = spawn(&spawnedFunc, thisTid);\n\n     // Send the number 42 to this new thread.\n     send(tid, 42);\n\n     // Receive the result code.\n     auto wasSuccessful = receiveOnly!(bool);\n     assert(wasSuccessful);\n     writeln(\"Successfully printed number.\");\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n\n Copyright: Copyright Sean Kelly 2009 - 2010.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   Sean Kelly, Alex Rønne Petersen\n Source:    $(PHOBOSSRC std/_concurrency.d)\n \n",
  "members" : [
   {
    "name" : "std.variant",
    "kind" : "import",
    "line" : 65
   },
   {
    "name" : "core.thread",
    "kind" : "import",
    "line" : 69,
    "protection" : "private"
   },
   {
    "name" : "core.sync.mutex",
    "kind" : "import",
    "line" : 70,
    "protection" : "private"
   },
   {
    "name" : "core.sync.condition",
    "kind" : "import",
    "line" : 71,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 72,
    "protection" : "private"
   },
   {
    "name" : "std.datetime",
    "kind" : "import",
    "line" : 73,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 74,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 75,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 76,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 77,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 78,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 79,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 81,
    "name" : "hasLocalAliasing",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "MsgType",
    "kind" : "enum",
    "line" : 91,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "standard",
      "kind" : "enum member",
      "line" : 92
     },
     {
      "name" : "priority",
      "kind" : "enum member",
      "line" : 93
     },
     {
      "name" : "linkDead",
      "kind" : "enum member",
      "line" : 94
     }
    ]
   },
   {
    "name" : "Message",
    "kind" : "struct",
    "protection" : "private",
    "line" : 98,
    "members" : [
     {
      "name" : "type",
      "kind" : "variable",
      "line" : 99,
      "deco" : "E3std11concurrency7MsgType",
      "offset" : 0
     },
     {
      "name" : "data",
      "kind" : "variable",
      "line" : 100,
      "deco" : "S3std7variant17__T8VariantNVm32Z8VariantN",
      "originalType" : "Variant",
      "offset" : 8
     },
     {
      "kind" : "template",
      "line" : 102,
      "name" : "this",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 102,
        "type" : "(MsgType t, T vals)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "MsgType"
         },
         {
          "name" : "vals",
          "type" : "T"
         }
        ],
        "endline" : 106
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 108,
      "name" : "this",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 108,
        "type" : "(MsgType t, T vals)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "MsgType"
         },
         {
          "name" : "vals",
          "type" : "T"
         }
        ],
        "endline" : 113
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 115,
      "name" : "this",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 115,
        "type" : "(MsgType t, T vals)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "MsgType"
         },
         {
          "name" : "vals",
          "type" : "T"
         }
        ],
        "endline" : 120
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 122,
      "name" : "convertsTo",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "convertsTo",
        "kind" : "function",
        "line" : 122,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 129
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 131,
      "name" : "get",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "get",
        "kind" : "function",
        "line" : 131,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 144
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 146,
      "name" : "map",
      "parameters" : [
       {
        "name" : "Op",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "map",
        "kind" : "function",
        "line" : 146,
        "storageClass" : [
         "auto"
        ],
        "type" : "(Op op)",
        "parameters" : [
         {
          "name" : "op",
          "type" : "Op"
         }
        ],
        "endline" : 161
       }
      ]
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 98,
      "deco" : "FNcS3std11concurrency7MessageZS3std11concurrency7Message",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std11concurrency7Message"
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std11concurrency7MessageKxS3std11concurrency7MessageZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std11concurrency7Message",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std11concurrency7Message",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 164,
    "name" : "checkops",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "checkops",
      "kind" : "function",
      "line" : 164,
      "type" : "void(T ops)",
      "parameters" : [
       {
        "name" : "ops",
        "type" : "T"
       }
      ],
      "endline" : 189
     }
    ]
   },
   {
    "name" : "mbox",
    "kind" : "variable",
    "protection" : "private",
    "line" : 191,
    "deco" : "C3std11concurrency10MessageBox",
    "originalType" : "MessageBox"
   },
   {
    "name" : "links",
    "kind" : "variable",
    "protection" : "private",
    "line" : 192,
    "deco" : "HS3std11concurrency3Tidb"
   },
   {
    "name" : "owner",
    "kind" : "variable",
    "protection" : "private",
    "line" : 193,
    "deco" : "S3std11concurrency3Tid"
   },
   {
    "name" : "_sharedStaticCtor1",
    "kind" : "function",
    "line" : 197,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 205
   },
   {
    "name" : "_staticDtor2",
    "kind" : "function",
    "line" : 208,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 219
   },
   {
    "name" : "MessageMismatch",
    "kind" : "class",
    "comment" : "\n\n\n Thrown on calls to $(D receiveOnly) if a message other than the type\n the receiving thread expected is sent.\n \n",
    "line" : 231,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 233,
      "deco" : "FAyaZC3std11concurrency15MessageMismatch",
      "originalType" : "(string msg = \"Unexpected message type\")",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya",
        "default" : "\"Unexpected message type\""
       }
      ],
      "endline" : 236
     }
    ]
   },
   {
    "name" : "OwnerTerminated",
    "kind" : "class",
    "comment" : "\n Thrown on calls to $(D receive) if the thread that spawned the receiving\n thread has terminated and no more messages exist.\n \n",
    "line" : 244,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 246,
      "deco" : "FS3std11concurrency3TidAyaZC3std11concurrency15OwnerTerminated",
      "originalType" : "(Tid t, string msg = \"Owner terminated\")",
      "parameters" : [
       {
        "name" : "t",
        "deco" : "S3std11concurrency3Tid"
       },
       {
        "name" : "msg",
        "deco" : "Aya",
        "default" : "\"Owner terminated\""
       }
      ],
      "endline" : 250
     },
     {
      "name" : "tid",
      "kind" : "variable",
      "line" : 252,
      "deco" : "S3std11concurrency3Tid",
      "offset" : 72
     }
    ]
   },
   {
    "name" : "LinkTerminated",
    "kind" : "class",
    "comment" : "\n Thrown if a linked thread has terminated.\n \n",
    "line" : 259,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 261,
      "deco" : "FS3std11concurrency3TidAyaZC3std11concurrency14LinkTerminated",
      "originalType" : "(Tid t, string msg = \"Link terminated\")",
      "parameters" : [
       {
        "name" : "t",
        "deco" : "S3std11concurrency3Tid"
       },
       {
        "name" : "msg",
        "deco" : "Aya",
        "default" : "\"Link terminated\""
       }
      ],
      "endline" : 265
     },
     {
      "name" : "tid",
      "kind" : "variable",
      "line" : 267,
      "deco" : "S3std11concurrency3Tid",
      "offset" : 72
     }
    ]
   },
   {
    "name" : "PriorityMessageException",
    "kind" : "class",
    "comment" : "\n Thrown if a message was sent to a thread via\n $(XREF concurrency, prioritySend) and the receiver does not have a handler\n for a message of this type.\n \n",
    "line" : 276,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 278,
      "deco" : "FS3std7variant17__T8VariantNVm32Z8VariantNZC3std11concurrency24PriorityMessageException",
      "originalType" : "(Variant vals)",
      "parameters" : [
       {
        "name" : "vals",
        "deco" : "S3std7variant17__T8VariantNVm32Z8VariantN"
       }
      ],
      "endline" : 282
     },
     {
      "name" : "message",
      "kind" : "variable",
      "comment" : "\n The message that was sent.\n     \n",
      "line" : 287,
      "deco" : "S3std7variant17__T8VariantNVm32Z8VariantN",
      "originalType" : "Variant",
      "offset" : 72
     }
    ]
   },
   {
    "name" : "MailboxFull",
    "kind" : "class",
    "comment" : "\n Thrown on mailbox crowding if the mailbox is configured with\n $(D OnCrowding.throwException).\n \n",
    "line" : 295,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 297,
      "deco" : "FS3std11concurrency3TidAyaZC3std11concurrency11MailboxFull",
      "originalType" : "(Tid t, string msg = \"Mailbox full\")",
      "parameters" : [
       {
        "name" : "t",
        "deco" : "S3std11concurrency3Tid"
       },
       {
        "name" : "msg",
        "deco" : "Aya",
        "default" : "\"Mailbox full\""
       }
      ],
      "endline" : 301
     },
     {
      "name" : "tid",
      "kind" : "variable",
      "line" : 303,
      "deco" : "S3std11concurrency3Tid",
      "offset" : 72
     }
    ]
   },
   {
    "name" : "TidMissingException",
    "kind" : "class",
    "comment" : "\n Thrown when a Tid is missing, e.g. when $(D ownerTid) doesn't\n find an owner thread.\n \n",
    "line" : 311,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 313,
      "deco" : "FAyaAyamZC3std11concurrency19TidMissingException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 316
     }
    ]
   },
   {
    "name" : "Tid",
    "kind" : "struct",
    "comment" : "\n\n\n An opaque type used to represent a logical local process.\n \n",
    "line" : 329,
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 331,
      "deco" : "FNcC3std11concurrency10MessageBoxZS3std11concurrency3Tid",
      "originalType" : "(MessageBox m)",
      "parameters" : [
       {
        "name" : "m",
        "deco" : "C3std11concurrency10MessageBox"
       }
      ],
      "endline" : 334
     },
     {
      "name" : "mbox",
      "kind" : "variable",
      "protection" : "private",
      "line" : 337,
      "deco" : "C3std11concurrency10MessageBox",
      "originalType" : "MessageBox",
      "offset" : 0
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std11concurrency3TidKxS3std11concurrency3TidZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std11concurrency3Tid",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std11concurrency3Tid",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "thisTid",
    "kind" : "function",
    "comment" : "\n Returns the caller's Tid.\n \n",
    "line" : 344,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdZS3std11concurrency3Tid",
    "originalType" : "Tid()",
    "endline" : 350
   },
   {
    "name" : "ownerTid",
    "kind" : "function",
    "comment" : "\n Return the Tid of the thread which\n spawned the caller's thread.\n\n Throws: A $(D TidMissingException) exception if\n there is no owner thread.\n \n",
    "line" : 359,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdZS3std11concurrency3Tid",
    "originalType" : "Tid()",
    "endline" : 363
   },
   {
    "name" : "__unittestL365_343",
    "kind" : "function",
    "line" : 365,
    "endline" : 385
   },
   {
    "kind" : "template",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 385,
    "name" : "isSpawnable",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 387,
      "name" : "isParamsImplicitlyConvertible",
      "parameters" : [
       {
        "name" : "F1",
        "kind" : "type"
       },
       {
        "name" : "F2",
        "kind" : "type"
       },
       {
        "name" : "i",
        "kind" : "value",
        "deco" : "i",
        "defaultValue" : "0"
       }
      ],
      "members" : [
       {
        "name" : "param1",
        "kind" : "alias",
        "line" : 389,
        "type" : "ParameterTypeTuple!(F1)"
       },
       {
        "name" : "param2",
        "kind" : "alias",
        "line" : 390,
        "type" : "ParameterTypeTuple!(F2)"
       }
      ]
     },
     {
      "name" : "isSpawnable",
      "kind" : "variable",
      "line" : 404,
      "storageClass" : [
       "enum"
      ],
      "init" : "isCallable!(F) && is(ReturnType!(F) == void) && isParamsImplicitlyConvertible!(F, void function(T)) && (isFunctionPointer!(F) || !hasUnsharedAliasing!(F))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Executes the supplied function in a new context represented by $(D Tid).  The\n calling context is designated as the owner of the new context.  When the\n owner context terminated an $(D OwnerTerminated) message will be sent to the\n new context, causing an $(D OwnerTerminated) exception to be thrown on\n $(D receive()).\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n\n Notes:\n  $(D args) must not have unshared aliasing.  In other words, all arguments\n  to $(D fn) must either be $(D shared) or $(D immutable) or have no\n  pointer indirection.  This is necessary for enforcing isolation among\n  threads.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio, std.concurrency;\n\n void f1(string str)\n {\n     writeln(str);\n }\n\n void f2(char[] str)\n {\n     writeln(str);\n }\n\n void main()\n {\n     auto str = \"Hello, world\";\n\n     // Works:  string is immutable.\n     auto tid1 = spawn(&f1, str);\n\n     // Fails:  char[] has mutable aliasing.\n     auto tid2 = spawn(&f2, str.dup);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
    "line" : 456,
    "name" : "spawn",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "spawn",
      "kind" : "function",
      "comment" : "\n Executes the supplied function in a new context represented by $(D Tid).  The\n calling context is designated as the owner of the new context.  When the\n owner context terminated an $(D OwnerTerminated) message will be sent to the\n new context, causing an $(D OwnerTerminated) exception to be thrown on\n $(D receive()).\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n\n Notes:\n  $(D args) must not have unshared aliasing.  In other words, all arguments\n  to $(D fn) must either be $(D shared) or $(D immutable) or have no\n  pointer indirection.  This is necessary for enforcing isolation among\n  threads.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio, std.concurrency;\n\n void f1(string str)\n {\n     writeln(str);\n }\n\n void f2(char[] str)\n {\n     writeln(str);\n }\n\n void main()\n {\n     auto str = \"Hello, world\";\n\n     // Works:  string is immutable.\n     auto tid1 = spawn(&f1, str);\n\n     // Fails:  char[] has mutable aliasing.\n     auto tid2 = spawn(&f2, str.dup);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
      "line" : 456,
      "type" : "Tid(F fn, T args)",
      "parameters" : [
       {
        "name" : "fn",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 462
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Executes the supplied function in a new context represented by Tid.  This\n new context is linked to the calling context so that if either it or the\n calling context terminates a LinkTerminated message will be sent to the\n other, causing a LinkTerminated exception to be thrown on receive().  The\n owner relationship from spawn() is preserved as well, so if the link\n between threads is broken, owner termination will still result in an\n OwnerTerminated exception to be thrown on receive().\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n \n",
    "line" : 481,
    "name" : "spawnLinked",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "spawnLinked",
      "kind" : "function",
      "comment" : "\n Executes the supplied function in a new context represented by Tid.  This\n new context is linked to the calling context so that if either it or the\n calling context terminates a LinkTerminated message will be sent to the\n other, causing a LinkTerminated exception to be thrown on receive().  The\n owner relationship from spawn() is preserved as well, so if the link\n between threads is broken, owner termination will still result in an\n OwnerTerminated exception to be thrown on receive().\n\n Params:\n  fn   = The function to execute.\n  args = Arguments to the function.\n\n Returns:\n  A Tid representing the new context.\n \n",
      "line" : 481,
      "type" : "Tid(F fn, T args)",
      "parameters" : [
       {
        "name" : "fn",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 487
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 493,
    "name" : "_spawn",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "_spawn",
      "kind" : "function",
      "line" : 493,
      "type" : "Tid(bool linked, F fn, T args)",
      "parameters" : [
       {
        "name" : "linked",
        "deco" : "b"
       },
       {
        "name" : "fn",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 511
     }
    ]
   },
   {
    "name" : "__unittestL513_344",
    "kind" : "function",
    "line" : 513,
    "endline" : 569
   },
   {
    "kind" : "template",
    "comment" : "\n\n\n Sends the supplied value to the context represented by tid.  As with\n $(XREF concurrency, spawn), $(D T) must not have unshared aliasing.\n \n",
    "line" : 569,
    "name" : "send",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "send",
      "kind" : "function",
      "comment" : "\n\n\n Sends the supplied value to the context represented by tid.  As with\n $(XREF concurrency, spawn), $(D T) must not have unshared aliasing.\n \n",
      "line" : 569,
      "type" : "void(Tid tid, T vals)",
      "parameters" : [
       {
        "name" : "tid",
        "type" : "Tid"
       },
       {
        "name" : "vals",
        "type" : "T"
       }
      ],
      "endline" : 574
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Send a message to $(D tid) but place it at the front of $(D tid)'s message\n queue instead of at the back.  This function is typically used for\n out-of-band communication, to signal exceptional conditions, etc.\n \n",
    "line" : 582,
    "name" : "prioritySend",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "prioritySend",
      "kind" : "function",
      "comment" : "\n Send a message to $(D tid) but place it at the front of $(D tid)'s message\n queue instead of at the back.  This function is typically used for\n out-of-band communication, to signal exceptional conditions, etc.\n \n",
      "line" : 582,
      "type" : "void(Tid tid, T vals)",
      "parameters" : [
       {
        "name" : "tid",
        "type" : "Tid"
       },
       {
        "name" : "vals",
        "type" : "T"
       }
      ],
      "endline" : 587
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 593,
    "name" : "_send",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "_send",
      "kind" : "function",
      "line" : 593,
      "type" : "void(Tid tid, T vals)",
      "parameters" : [
       {
        "name" : "tid",
        "type" : "Tid"
       },
       {
        "name" : "vals",
        "type" : "T"
       }
      ],
      "endline" : 596
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 603,
    "name" : "_send",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "_send",
      "kind" : "function",
      "line" : 603,
      "type" : "void(MsgType type, Tid tid, T vals)",
      "parameters" : [
       {
        "name" : "type",
        "type" : "MsgType"
       },
       {
        "name" : "tid",
        "type" : "Tid"
       },
       {
        "name" : "vals",
        "type" : "T"
       }
      ],
      "endline" : 607
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Receive a message from another thread, or block if no messages of the\n specified types are available.  This function works by pattern matching\n a message against a set of delegates and executing the first match found.\n\n If a delegate that accepts a $(XREF variant, Variant) is included as\n the last argument to $(D receive), it will match any message that was not\n matched by an earlier delegate.  If more than one argument is sent,\n the $(D Variant) will contain a $(XREF typecons, Tuple) of all values\n sent.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio;\n import std.variant;\n import std.concurrency;\n\n void spawnedFunction()\n {\n     receive(\n         (int i) { writeln(\"Received an int.\"); },\n         (float f) { writeln(\"Received a float.\"); },\n         (Variant v) { writeln(\"Received some other type.\"); }\n     );\n }\n\n void main()\n {\n      auto tid = spawn(&spawnedFunction);\n      send(tid, 42);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
    "line" : 646,
    "name" : "receive",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "receive",
      "kind" : "function",
      "comment" : "\n Receive a message from another thread, or block if no messages of the\n specified types are available.  This function works by pattern matching\n a message against a set of delegates and executing the first match found.\n\n If a delegate that accepts a $(XREF variant, Variant) is included as\n the last argument to $(D receive), it will match any message that was not\n matched by an earlier delegate.  If more than one argument is sent,\n the $(D Variant) will contain a $(XREF typecons, Tuple) of all values\n sent.\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.stdio;\n import std.variant;\n import std.concurrency;\n\n void spawnedFunction()\n {\n     receive(\n         (int i) { writeln(\"Received an int.\"); },\n         (float f) { writeln(\"Received a float.\"); },\n         (Variant v) { writeln(\"Received some other type.\"); }\n     );\n }\n\n void main()\n {\n      auto tid = spawn(&spawnedFunction);\n      send(tid, 42);\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
      "line" : 646,
      "type" : "void(T ops)",
      "parameters" : [
       {
        "name" : "ops",
        "type" : "T"
       }
      ],
      "endline" : 650
     }
    ]
   },
   {
    "name" : "__unittestL653_355",
    "kind" : "function",
    "line" : 653,
    "endline" : 673
   },
   {
    "name" : "__unittestL677_358",
    "kind" : "function",
    "line" : 677,
    "endline" : 687
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 687,
    "name" : "receiveOnlyRet",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n Receives only messages with arguments of types $(D T).\n\n Throws:  $(D MessageMismatch) if a message of types other than $(D T)\n          is received.\n\n Returns: The received message.  If $(D T.length) is greater than one,\n          the message will be packed into a $(XREF typecons, Tuple).\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.concurrency;\n\n void spawnedFunc()\n {\n     auto msg = receiveOnly!(int, string)();\n     assert(msg[0] == 42);\n     assert(msg[1] == \"42\");\n }\n\n void main()\n {\n     auto tid = spawn(&spawnedFunc);\n     send(tid, 42, \"42\");\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
    "line" : 725,
    "name" : "receiveOnly",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "receiveOnly",
      "kind" : "function",
      "comment" : "\n Receives only messages with arguments of types $(D T).\n\n Throws:  $(D MessageMismatch) if a message of types other than $(D T)\n          is received.\n\n Returns: The received message.  If $(D T.length) is greater than one,\n          the message will be packed into a $(XREF typecons, Tuple).\n\n Example:\n$(D_RUN_CODE\n$(ARGS\n ---\n import std.concurrency;\n\n void spawnedFunc()\n {\n     auto msg = receiveOnly!(int, string)();\n     assert(msg[0] == 42);\n     assert(msg[1] == \"42\");\n }\n\n void main()\n {\n     auto tid = spawn(&spawnedFunc);\n     send(tid, 42, \"42\");\n }\n ---\n), $(ARGS), $(ARGS), $(ARGS))\n \n",
      "line" : 725,
      "type" : "receiveOnlyRet!(T)()",
      "endline" : 757
     }
    ]
   },
   {
    "name" : "__unittestL759_363",
    "kind" : "function",
    "line" : 759,
    "endline" : 786
   },
   {
    "kind" : "template",
    "comment" : "\n    Same as $(D receive) except that rather than wait forever for a message,\n    it waits until either it receives a message or the given\n    $(CXREF time, Duration) has passed. It returns $(D true) if it received a\n    message and $(D false) if it timed out waiting for one.\n  \n",
    "line" : 786,
    "name" : "receiveTimeout",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "receiveTimeout",
      "kind" : "function",
      "comment" : "\n    Same as $(D receive) except that rather than wait forever for a message,\n    it waits until either it receives a message or the given\n    $(CXREF time, Duration) has passed. It returns $(D true) if it received a\n    message and $(D false) if it timed out waiting for one.\n  \n",
      "line" : 786,
      "type" : "bool(Duration duration, T ops)",
      "parameters" : [
       {
        "name" : "duration",
        "type" : "Duration"
       },
       {
        "name" : "ops",
        "type" : "T"
       }
      ],
      "endline" : 790
     }
    ]
   },
   {
    "name" : "__unittestL792_377",
    "kind" : "function",
    "line" : 792,
    "endline" : 825
   },
   {
    "name" : "OnCrowding",
    "kind" : "enum",
    "comment" : "\n\n\n These behaviors may be specified when a mailbox is full.\n \n",
    "line" : 826,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "block",
      "kind" : "enum member",
      "comment" : " Wait until room is available.\n",
      "line" : 827
     },
     {
      "name" : "throwException",
      "kind" : "enum member",
      "comment" : " Throw a MailboxFull exception.\n",
      "line" : 828
     },
     {
      "name" : "ignore",
      "kind" : "enum member",
      "comment" : " Abort the send and return.\n",
      "line" : 829
     }
    ]
   },
   {
    "name" : "onCrowdingBlock",
    "kind" : "function",
    "protection" : "private",
    "line" : 835,
    "deco" : "FS3std11concurrency3TidZb",
    "parameters" : [
     {
      "name" : "tid",
      "deco" : "S3std11concurrency3Tid"
     }
    ],
    "endline" : 838
   },
   {
    "name" : "onCrowdingThrow",
    "kind" : "function",
    "protection" : "private",
    "line" : 841,
    "deco" : "FS3std11concurrency3TidZb",
    "parameters" : [
     {
      "name" : "tid",
      "deco" : "S3std11concurrency3Tid"
     }
    ],
    "endline" : 844
   },
   {
    "name" : "onCrowdingIgnore",
    "kind" : "function",
    "protection" : "private",
    "line" : 847,
    "deco" : "FS3std11concurrency3TidZb",
    "parameters" : [
     {
      "name" : "tid",
      "deco" : "S3std11concurrency3Tid"
     }
    ],
    "endline" : 850
   },
   {
    "name" : "setMaxMailboxSize",
    "kind" : "function",
    "comment" : "\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute the behavior specified by doThis.  If messages is zero, the mailbox\n is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  doThis   = The behavior executed when a message is sent to a full\n             mailbox.\n \n",
    "line" : 866,
    "deco" : "FS3std11concurrency3TidmE3std11concurrency10OnCrowdingZv",
    "originalType" : "void(Tid tid, size_t messages, OnCrowding doThis)",
    "parameters" : [
     {
      "name" : "tid",
      "deco" : "S3std11concurrency3Tid"
     },
     {
      "name" : "messages",
      "deco" : "m"
     },
     {
      "name" : "doThis",
      "deco" : "E3std11concurrency10OnCrowding"
     }
    ],
    "endline" : 877
   },
   {
    "name" : "setMaxMailboxSize",
    "kind" : "function",
    "comment" : "\n Sets a limit on the maximum number of user messages allowed in the mailbox.\n If this limit is reached, the caller attempting to add a new message will\n execute onCrowdingDoThis.  If messages is zero, the mailbox is unbounded.\n\n Params:\n  tid      = The Tid of the thread for which this limit should be set.\n  messages = The maximum number of messages or zero if no limit.\n  onCrowdingDoThis = The routine called when a message is sent to a full\n                     mailbox.\n \n",
    "line" : 891,
    "deco" : "FS3std11concurrency3TidmPFS3std11concurrency3TidZbZv",
    "originalType" : "void(Tid tid, size_t messages, bool function(Tid) onCrowdingDoThis)",
    "parameters" : [
     {
      "name" : "tid",
      "deco" : "S3std11concurrency3Tid"
     },
     {
      "name" : "messages",
      "deco" : "m"
     },
     {
      "name" : "onCrowdingDoThis",
      "deco" : "PFS3std11concurrency3TidZb"
     }
    ],
    "endline" : 894
   },
   {
    "name" : "tidByName",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 904,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "HAyaS3std11concurrency3Tid"
   },
   {
    "name" : "namesByTid",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 905,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "HS3std11concurrency3TidAAya"
   },
   {
    "name" : "registryLock",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 906,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "C4core4sync5mutex5Mutex",
    "originalType" : "Mutex"
   },
   {
    "name" : "_sharedStaticCtor3",
    "kind" : "function",
    "line" : 910,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 913
   },
   {
    "name" : "_staticDtor4",
    "kind" : "function",
    "line" : 916,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 929
   },
   {
    "name" : "register",
    "kind" : "function",
    "comment" : "\n Associates name with tid in a process-local map.  When the thread\n represented by tid termiantes, any names associated with it will be\n automatically unregistered.\n\n Params:\n  name = The name to associate with tid.\n  tid  = The tid register by name.\n\n Returns:\n  true if the name is available and tid is not known to represent a\n  defunct thread.\n \n",
    "line" : 945,
    "deco" : "FAyaS3std11concurrency3TidZb",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "Aya"
     },
     {
      "name" : "tid",
      "deco" : "S3std11concurrency3Tid"
     }
    ],
    "endline" : 957
   },
   {
    "name" : "unregister",
    "kind" : "function",
    "comment" : "\n Removes the registered name associated with a tid.\n\n Params:\n  name = The name to unregister.\n\n Returns:\n  true if the name is registered, false if not.\n \n",
    "line" : 969,
    "deco" : "FAyaZb",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "Aya"
     }
    ],
    "endline" : 983
   },
   {
    "name" : "locate",
    "kind" : "function",
    "comment" : "\n Gets the Tid associated with name.\n\n Params:\n  name = The name to locate within the registry.\n\n Returns:\n  The associated Tid or Tid.init if name is not registered.\n \n",
    "line" : 995,
    "deco" : "FAyaZS3std11concurrency3Tid",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "Aya"
     }
    ],
    "endline" : 1003
   },
   {
    "name" : "MessageBox",
    "kind" : "class",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 1021,
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1022,
      "deco" : "FZC3std11concurrency10MessageBox",
      "originalType" : "()",
      "endline" : 1028
     },
     {
      "name" : "isClosed",
      "kind" : "function",
      "line" : 1034,
      "storageClass" : [
       "final",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "const bool()",
      "endline" : 1040
     },
     {
      "name" : "setMaxMsgs",
      "kind" : "function",
      "line" : 1054,
      "storageClass" : [
       "final"
      ],
      "deco" : "FmPFS3std11concurrency3TidZbZv",
      "originalType" : "void(size_t num, bool function(Tid) call)",
      "parameters" : [
       {
        "name" : "num",
        "deco" : "m"
       },
       {
        "name" : "call",
        "deco" : "PFS3std11concurrency3TidZb"
       }
      ],
      "endline" : 1061
     },
     {
      "name" : "put",
      "kind" : "function",
      "line" : 1078,
      "storageClass" : [
       "final"
      ],
      "deco" : "FKS3std11concurrency7MessageZv",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "S3std11concurrency7Message",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1110
     },
     {
      "kind" : "template",
      "line" : 1129,
      "name" : "get",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "get",
        "kind" : "function",
        "line" : 1129,
        "type" : "bool(scope T vals)",
        "parameters" : [
         {
          "name" : "vals",
          "type" : "T",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 1334
       }
      ]
     },
     {
      "name" : "close",
      "kind" : "function",
      "line" : 1342,
      "storageClass" : [
       "final"
      ],
      "deco" : "FZv",
      "endline" : 1373
     },
     {
      "name" : "mboxFull",
      "kind" : "function",
      "protection" : "private",
      "comment" : "\n\n",
      "line" : 1382,
      "deco" : "FZb",
      "endline" : 1386
     },
     {
      "name" : "updateMsgCount",
      "kind" : "function",
      "protection" : "private",
      "line" : 1389,
      "deco" : "FZv",
      "endline" : 1392
     },
     {
      "name" : "isControlMsg",
      "kind" : "function",
      "protection" : "private",
      "comment" : "\n\n",
      "line" : 1401,
      "storageClass" : [
       "final",
       "pure"
      ],
      "deco" : "FNaKS3std11concurrency7MessageZb",
      "originalType" : "bool(ref Message msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "S3std11concurrency7Message",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1405
     },
     {
      "name" : "isPriorityMsg",
      "kind" : "function",
      "protection" : "private",
      "line" : 1408,
      "storageClass" : [
       "final",
       "pure"
      ],
      "deco" : "FNaKS3std11concurrency7MessageZb",
      "originalType" : "bool(ref Message msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "S3std11concurrency7Message",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1411
     },
     {
      "name" : "isLinkDeadMsg",
      "kind" : "function",
      "protection" : "private",
      "line" : 1414,
      "storageClass" : [
       "final",
       "pure"
      ],
      "deco" : "FNaKS3std11concurrency7MessageZb",
      "originalType" : "bool(ref Message msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "S3std11concurrency7Message",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1417
     },
     {
      "name" : "OnMaxFn",
      "kind" : "alias",
      "protection" : "private",
      "comment" : "\n\n",
      "line" : 1426,
      "deco" : "PFS3std11concurrency3TidZb"
     },
     {
      "name" : "ListT",
      "kind" : "alias",
      "protection" : "private",
      "line" : 1427,
      "deco" : "S3std11concurrency36__T4ListTS3std11concurrency7MessageZ4List"
     },
     {
      "name" : "m_localBox",
      "kind" : "variable",
      "protection" : "private",
      "comment" : "\n\n",
      "line" : 1435,
      "deco" : "S3std11concurrency36__T4ListTS3std11concurrency7MessageZ4List",
      "originalType" : "ListT",
      "offset" : 16
     },
     {
      "name" : "m_localPty",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1436,
      "deco" : "S3std11concurrency36__T4ListTS3std11concurrency7MessageZ4List",
      "originalType" : "ListT",
      "offset" : 40
     },
     {
      "name" : "m_lock",
      "kind" : "variable",
      "protection" : "private",
      "comment" : "\n\n",
      "line" : 1445,
      "deco" : "C4core4sync5mutex5Mutex",
      "originalType" : "Mutex",
      "offset" : 64
     },
     {
      "name" : "m_putMsg",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1446,
      "deco" : "C4core4sync9condition9Condition",
      "originalType" : "Condition",
      "offset" : 72
     },
     {
      "name" : "m_notFull",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1447,
      "deco" : "C4core4sync9condition9Condition",
      "originalType" : "Condition",
      "offset" : 80
     },
     {
      "name" : "m_putQueue",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1448,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 88
     },
     {
      "name" : "m_sharedBox",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1449,
      "deco" : "S3std11concurrency36__T4ListTS3std11concurrency7MessageZ4List",
      "originalType" : "ListT",
      "offset" : 96
     },
     {
      "name" : "m_sharedPty",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1450,
      "deco" : "S3std11concurrency36__T4ListTS3std11concurrency7MessageZ4List",
      "originalType" : "ListT",
      "offset" : 120
     },
     {
      "name" : "m_onMaxMsgs",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1451,
      "deco" : "PFS3std11concurrency3TidZb",
      "originalType" : "OnMaxFn",
      "offset" : 144
     },
     {
      "name" : "m_localMsgs",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1452,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 152
     },
     {
      "name" : "m_maxMsgs",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1453,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 160
     },
     {
      "name" : "m_closed",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1454,
      "deco" : "b",
      "offset" : 168
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 1462,
    "name" : "List",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "List",
      "kind" : "struct",
      "line" : 1462,
      "members" : [
       {
        "name" : "Range",
        "kind" : "struct",
        "line" : 1464,
        "members" : [
         {
          "name" : "empty",
          "kind" : "function",
          "line" : 1465,
          "type" : "const bool()",
          "endline" : 1468
         },
         {
          "name" : "front",
          "kind" : "function",
          "line" : 1470,
          "type" : "T()",
          "endline" : 1474
         },
         {
          "name" : "front",
          "kind" : "function",
          "line" : 1476,
          "type" : "void(T val)",
          "parameters" : [
           {
            "name" : "val",
            "type" : "T"
           }
          ],
          "endline" : 1480
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "line" : 1482,
          "type" : "void()",
          "endline" : 1486
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1494,
          "type" : "(Node* p)",
          "parameters" : [
           {
            "name" : "p",
            "type" : "Node*"
           }
          ],
          "endline" : 1497
         },
         {
          "name" : "m_prev",
          "kind" : "variable",
          "line" : 1499,
          "type" : "Node*"
         }
        ]
       },
       {
        "name" : "put",
        "kind" : "function",
        "line" : 1506,
        "type" : "void(T val)",
        "parameters" : [
         {
          "name" : "val",
          "type" : "T"
         }
        ],
        "endline" : 1509
       },
       {
        "name" : "put",
        "kind" : "function",
        "line" : 1515,
        "type" : "void(ref List!(T) rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "List!(T)",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 1529
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 1535,
        "type" : "Range()",
        "endline" : 1538
       },
       {
        "name" : "removeAt",
        "kind" : "function",
        "line" : 1544,
        "type" : "void(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 1558
       },
       {
        "name" : "length",
        "kind" : "function",
        "line" : 1564,
        "type" : "size_t()",
        "endline" : 1567
       },
       {
        "name" : "clear",
        "kind" : "function",
        "line" : 1573,
        "type" : "void()",
        "endline" : 1577
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 1583,
        "type" : "bool()",
        "endline" : 1586
       },
       {
        "name" : "Node",
        "kind" : "struct",
        "line" : 1591,
        "members" : [
         {
          "name" : "next",
          "kind" : "variable",
          "line" : 1592,
          "type" : "Node*"
         },
         {
          "name" : "val",
          "kind" : "variable",
          "line" : 1593,
          "type" : "T"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1595,
          "type" : "(T v)",
          "parameters" : [
           {
            "name" : "v",
            "type" : "T"
           }
          ],
          "endline" : 1598
         }
        ]
       },
       {
        "name" : "put",
        "kind" : "function",
        "line" : 1605,
        "type" : "void(Node* n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "Node*"
         }
        ],
        "endline" : 1616
       },
       {
        "name" : "m_first",
        "kind" : "variable",
        "line" : 1619,
        "type" : "Node*"
       },
       {
        "name" : "m_last",
        "kind" : "variable",
        "line" : 1620,
        "type" : "Node*"
       },
       {
        "name" : "m_count",
        "kind" : "variable",
        "line" : 1621,
        "type" : "size_t"
       }
      ]
     }
    ]
   }
  ]
 },
 {
  "name" : "std.container",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/container.d",
  "comment" : "\nDefines generic _containers.\n\nSource: $(PHOBOSSRC std/_container.d)\nMacros:\nWIKI = Phobos/StdContainer\nTEXTWITHCOMMAS = $0\n\nCopyright: Red-black tree code copyright (C) 2008- by Steven Schveighoffer. Other code\ncopyright 2010- Andrei Alexandrescu. All rights reserved by the respective holders.\n\nLicense: Distributed under the Boost Software License, Version 1.0.\n(See accompanying file LICENSE_1_0.txt or copy at $(WEB\nboost.org/LICENSE_1_0.txt)).\n\nAuthors: Steven Schveighoffer, $(WEB erdani.com, Andrei Alexandrescu)\n\n$(BOOKTABLE $(TEXTWITHCOMMAS Container primitives. Below, $(D C) means\na _container type, $(D c) is a value of _container type, $(D n$(SUB\nx)) represents the effective length of value $(D x), which could be a\nsingle element (in which case $(D n$(SUB x)) is $(D 1)), a _container,\nor a range.),\n\n$(TR $(TH Syntax) $(TH $(BIGOH &middot;)) $(TH Description))\n\n$(TR $(TDNW $(D C(x))) $(TDNW $(D n$(SUB x))) $(TD Creates a\n_container of type $(D C) from either another _container or a range.))\n\n$(TR $(TDNW $(D c.dup)) $(TDNW $(D n$(SUB c))) $(TD Returns a\nduplicate of the _container.))\n\n$(TR $(TDNW $(D c ~ x)) $(TDNW $(D n$(SUB c) + n$(SUB x))) $(TD\nReturns the concatenation of $(D c) and $(D r). $(D x) may be a single\nelement or an input range.))\n\n$(TR $(TDNW $(D x ~ c)) $(TDNW $(D n$(SUB c) + n$(SUB x))) $(TD\nReturns the concatenation of $(D x) and $(D c).  $(D x) may be a\nsingle element or an input range type.))\n\n$(LEADINGROW Iteration)\n\n$(TR  $(TD $(D c.Range)) $(TD) $(TD The primary range\ntype associated with the _container.))\n\n$(TR $(TD $(D c[])) $(TDNW $(D log n$(SUB c))) $(TD Returns a range\niterating over the entire _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c[a .. b])) $(TDNW $(D log n$(SUB c))) $(TD Fetches a\nportion of the _container from key $(D a) to key $(D b).))\n\n$(LEADINGROW Capacity)\n\n$(TR $(TD $(D c.empty)) $(TD $(D 1)) $(TD Returns $(D true) if the\n_container has no elements, $(D false) otherwise.))\n\n$(TR  $(TD $(D c.length)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nnumber of elements in the _container.))\n\n$(TR $(TDNW $(D c.length = n)) $(TDNW $(D n$(SUB c) + n)) $(TD Forces\nthe number of elements in the _container to $(D n). If the _container\nends up growing, the added elements are initialized in a\n_container-dependent manner (usually with $(D T.init)).))\n\n$(TR $(TD $(D c.capacity)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nmaximum number of elements that can be stored in the _container\nwithout triggering a reallocation.))\n\n$(TR $(TD $(D c.reserve(x))) $(TD $(D n$(SUB c))) $(TD Forces $(D\ncapacity) to at least $(D x) without reducing it.))\n\n$(LEADINGROW Access)\n\n$(TR $(TDNW $(D c.front)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nfirst element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveFront)) $(TDNW $(D log n$(SUB c))) $(TD\nDestructively reads and returns the first element of the\n_container. The slot is not removed from the _container; it is left\ninitalized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.front = v)) $(TDNW $(D log n$(SUB c))) $(TD Assigns\n$(D v) to the first element of the _container.))\n\n$(TR $(TDNW $(D c.back)) $(TDNW $(D log n$(SUB c))) $(TD Returns the\nlast element of the _container, in a _container-defined order.))\n\n$(TR $(TDNW $(D c.moveBack)) $(TDNW $(D log n$(SUB c))) $(TD\nDestructively reads and returns the last element of the\ncontainer. The slot is not removed from the _container; it is left\ninitalized with $(D T.init). This routine need not be defined if $(D\nfront) returns a $(D ref).))\n\n$(TR $(TDNW $(D c.back = v)) $(TDNW $(D log n$(SUB c))) $(TD Assigns\n$(D v) to the last element of the _container.))\n\n$(TR $(TDNW $(D c[x])) $(TDNW $(D log n$(SUB c))) $(TD Provides\nindexed access into the _container. The index type is\n_container-defined. A container may define several index types (and\nconsequently overloaded indexing).))\n\n$(TR  $(TDNW $(D c.moveAt(x))) $(TDNW $(D log n$(SUB c))) $(TD\nDestructively reads and returns the value at position $(D x). The slot\nis not removed from the _container; it is left initialized with $(D\nT.init).))\n\n$(TR  $(TDNW $(D c[x] = v)) $(TDNW $(D log n$(SUB c))) $(TD Sets\nelement at specified index into the _container.))\n\n$(TR  $(TDNW $(D c[x] $(I op)= v)) $(TDNW $(D log n$(SUB c)))\n$(TD Performs read-modify-write operation at specified index into the\n_container.))\n\n$(LEADINGROW Operations)\n\n$(TR $(TDNW $(D e in c)) $(TDNW $(D log n$(SUB c))) $(TD\nReturns nonzero if e is found in $(D c).))\n\n$(TR  $(TDNW $(D c.lowerBound(v))) $(TDNW $(D log n$(SUB c))) $(TD\nReturns a range of all elements strictly less than $(D v).))\n\n$(TR  $(TDNW $(D c.upperBound(v))) $(TDNW $(D log n$(SUB c))) $(TD\nReturns a range of all elements strictly greater than $(D v).))\n\n$(TR  $(TDNW $(D c.equalRange(v))) $(TDNW $(D log n$(SUB c))) $(TD\nReturns a range of all elements in $(D c) that are equal to $(D v).))\n\n$(LEADINGROW Modifiers)\n\n$(TR $(TDNW $(D c ~= x)) $(TDNW $(D n$(SUB c) + n$(SUB x)))\n$(TD Appends $(D x) to $(D c). $(D x) may be a single element or an\ninput range type.))\n\n$(TR  $(TDNW $(D c.clear())) $(TDNW $(D n$(SUB c))) $(TD Removes all\nelements in $(D c).))\n\n$(TR  $(TDNW $(D c.insert(x))) $(TDNW $(D n$(SUB x) * log n$(SUB c)))\n$(TD Inserts $(D x) in $(D c) at a position (or positions) chosen by $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsert(x)))\n$(TDNW $(D n$(SUB x) * log n$(SUB c))) $(TD Same as $(D c.insert(x)),\nbut is guaranteed to not invalidate any ranges.))\n\n$(TR  $(TDNW $(D c.linearInsert(v))) $(TDNW $(D n$(SUB c))) $(TD Same\nas $(D c.insert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.stableLinearInsert(v))) $(TDNW $(D n$(SUB c)))\n$(TD Same as $(D c.stableInsert(v)) but relaxes complexity to linear.))\n\n$(TR  $(TDNW $(D c.removeAny())) $(TDNW $(D log n$(SUB c)))\n$(TD Removes some element from $(D c) and returns it.))\n\n$(TR  $(TDNW $(D c.stableRemoveAny())) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.removeAny()), but is guaranteed to not invalidate any\niterators.))\n\n$(TR  $(TDNW $(D c.insertFront(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Inserts $(D v) at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertFront(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.insertFront(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.insertBack(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Inserts $(D v) at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableInsertBack(v))) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.insertBack(v)), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeFront())) $(TDNW $(D log n$(SUB c)))\n$(TD Removes the element at the front of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveFront())) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.removeFront()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeBack())) $(TDNW $(D log n$(SUB c)))\n$(TD Removes the value at the back of $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemoveBack())) $(TDNW $(D log n$(SUB c)))\n$(TD Same as $(D c.removeBack()), but guarantees no ranges will be\ninvalidated.))\n\n$(TR  $(TDNW $(D c.remove(r))) $(TDNW $(D n$(SUB r) * log n$(SUB c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableRemove(r)))\n$(TDNW $(D n$(SUB r) * log n$(SUB c)))\n$(TD Same as $(D c.remove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.linearRemove(r))) $(TDNW $(D n$(SUB c)))\n$(TD Removes range $(D r) from $(D c).))\n\n$(TR  $(TDNW $(D c.stableLinearRemove(r))) $(TDNW $(D n$(SUB c)))\n$(TD Same as $(D c.linearRemove(r)), but guarantees iterators are not\ninvalidated.))\n\n$(TR  $(TDNW $(D c.removeKey(k))) $(TDNW $(D log n$(SUB c)))\n$(TD Removes an element from $(D c) by using its key $(D k).\nThe key's type is defined by the _container.))\n\n$(TR  $(TDNW $(D )) $(TDNW $(D )) $(TD ))\n\n)\n \n",
  "members" : [
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 212,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 212,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 212,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 212,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 213,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 213,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 213,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 213,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 213,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 214,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 214,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "line" : 255,
    "name" : "TotalContainer",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "TotalContainer",
      "kind" : "struct",
      "line" : 255,
      "members" : [
       {
        "name" : "KeyType",
        "kind" : "alias",
        "comment" : "\nIf the container has a notion of key-value mapping, $(D KeyType)\ndefines the type of the key of the container.\n \n",
        "line" : 260,
        "type" : "T"
       },
       {
        "name" : "KeyTypes",
        "kind" : "alias",
        "comment" : "\nIf the container has a notion of multikey-value mapping, $(D\nKeyTypes[k]), where $(D k) is a zero-based unsigned number, defines\nthe type of the $(D k)th key of the container.\n\nA container may define both $(D KeyType) and $(D KeyTypes), e.g. in\nthe case it has the notion of primary/preferred key.\n \n",
        "line" : 270,
        "type" : "TypeTuple!(T)"
       },
       {
        "name" : "ValueType",
        "kind" : "alias",
        "comment" : "\nIf the container has a notion of key-value mapping, $(D ValueType)\ndefines the type of the value of the container. Typically, a map-style\ncontainer mapping values of type $(D K) to values of type $(D V)\ndefines $(D KeyType) to be $(D K) and $(D ValueType) to be $(D V).\n \n",
        "line" : 278,
        "type" : "T"
       },
       {
        "name" : "Range",
        "kind" : "struct",
        "comment" : "\nDefines the container's primary range, which embodies one of the\nranges defined in $(XREFMODULE range).\n\nGenerally a container may define several types of ranges.\n \n",
        "line" : 287,
        "members" : [
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : " Range primitives.\n",
          "line" : 289,
          "type" : "bool()",
          "endline" : 292
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 294,
          "type" : "T()",
          "endline" : 297
         },
         {
          "name" : "moveFront",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 299,
          "type" : "T()",
          "endline" : 302
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 304,
          "type" : "void()",
          "endline" : 307
         },
         {
          "name" : "back",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 309,
          "type" : "T()",
          "endline" : 312
         },
         {
          "name" : "moveBack",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 314,
          "type" : "T()",
          "endline" : 317
         },
         {
          "name" : "popBack",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 319,
          "type" : "void()",
          "endline" : 322
         },
         {
          "name" : "opIndex",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 324,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 327
         },
         {
          "name" : "opIndexAssign",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 329,
          "type" : "void(T value, size_t i)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 332
         },
         {
          "kind" : "template",
          "comment" : " Ditto\n",
          "line" : 334,
          "name" : "opIndexOpAssign",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opIndexOpAssign",
            "kind" : "function",
            "comment" : " Ditto\n",
            "line" : 334,
            "type" : "void(T value, uint i)",
            "parameters" : [
             {
              "name" : "value",
              "type" : "T"
             },
             {
              "name" : "i",
              "deco" : "k"
             }
            ],
            "endline" : 337
           }
          ]
         },
         {
          "name" : "moveAt",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 339,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 342
         },
         {
          "name" : "length",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 344,
          "type" : "size_t()",
          "endline" : 347
         }
        ]
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n \n",
        "line" : 356,
        "type" : "bool()",
        "endline" : 359
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\nReturns a duplicate of the container. The elements themselves are not\ntransitively duplicated.\n\nComplexity: $(BIGOH n).\n \n",
        "line" : 367,
        "type" : "TotalContainer()",
        "endline" : 370
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\nReturns the number of elements in the container.\n\nComplexity: $(BIGOH log(n)).\n",
        "line" : 377,
        "type" : "size_t()",
        "endline" : 380
       },
       {
        "name" : "capacity",
        "kind" : "function",
        "comment" : "\nReturns the maximum number of elements the container can store without\n(a) allocating memory, (b) invalidating iterators upon insertion.\n\nComplexity: $(BIGOH log(n)).\n \n",
        "line" : 388,
        "type" : "size_t()",
        "endline" : 391
       },
       {
        "name" : "reserve",
        "kind" : "function",
        "comment" : "\nEnsures sufficient capacity to accommodate $(D n) elements.\n\nPostcondition: $(D capacity >= n)\n\nComplexity: $(BIGOH log(e - capacity)) if $(D e > capacity), otherwise\n$(BIGOH 1).\n \n",
        "line" : 401,
        "type" : "void(size_t e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "size_t"
         }
        ],
        "endline" : 404
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\nReturns a range that iterates over all elements of the container, in a\ncontainer-defined order. The container should choose the most\nconvenient and fast method of iteration for $(D opSlice()).\n\nComplexity: $(BIGOH log(n))\n \n",
        "line" : 413,
        "type" : "Range()",
        "endline" : 416
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\n       Returns a range that iterates the container between two\n       specified positions.\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 424,
        "type" : "Range(size_t a, size_t b)",
        "parameters" : [
         {
          "name" : "a",
          "type" : "size_t"
         },
         {
          "name" : "b",
          "type" : "size_t"
         }
        ],
        "endline" : 427
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\nForward to $(D opSlice().front) and $(D opSlice().back), respectively.\n\nComplexity: $(BIGOH log(n))\n \n",
        "line" : 434,
        "type" : "T()",
        "endline" : 437
       },
       {
        "name" : "moveFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 439,
        "type" : "T()",
        "endline" : 442
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 444,
        "type" : "T()",
        "endline" : 447
       },
       {
        "name" : "moveBack",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 449,
        "type" : "T()",
        "endline" : 452
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : "\nIndexing operators yield or modify the value at a specified index.\n \n\n       Indexing operators yield or modify the value at a specified index.\n     \n",
        "line" : 460,
        "type" : "ValueType(KeyType)",
        "parameters" : [
         {
          "type" : "KeyType"
         }
        ],
        "endline" : 463
       },
       {
        "name" : "opIndexAssign",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 465,
        "type" : "void(KeyType)",
        "parameters" : [
         {
          "type" : "KeyType"
         }
        ],
        "endline" : 468
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 470,
        "name" : "opIndexOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opIndexOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 470,
          "type" : "void(KeyType)",
          "parameters" : [
           {
            "type" : "KeyType"
           }
          ],
          "endline" : 473
         }
        ]
       },
       {
        "name" : "moveAt",
        "kind" : "function",
        "line" : 474,
        "type" : "T(size_t i)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "size_t"
         }
        ],
        "endline" : 477
       },
       {
        "kind" : "template",
        "comment" : "\n$(D k in container) returns true if the given key is in the container.\n \n",
        "line" : 482,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : "\n$(D k in container) returns true if the given key is in the container.\n \n",
          "line" : 482,
          "type" : "bool(KeyType k)",
          "parameters" : [
           {
            "name" : "k",
            "type" : "KeyType"
           }
          ],
          "endline" : 485
         }
        ]
       },
       {
        "name" : "equalRange",
        "kind" : "function",
        "comment" : "\nReturns a range of all elements containing $(D k) (could be empty or a\nsingleton range).\n \n",
        "line" : 491,
        "type" : "Range(KeyType k)",
        "parameters" : [
         {
          "name" : "k",
          "type" : "KeyType"
         }
        ],
        "endline" : 494
       },
       {
        "name" : "lowerBound",
        "kind" : "function",
        "comment" : "\nReturns a range of all elements with keys less than $(D k) (could be\nempty or a singleton range). Only defined by containers that store\ndata sorted at all times.\n \n",
        "line" : 501,
        "type" : "Range(KeyType k)",
        "parameters" : [
         {
          "name" : "k",
          "type" : "KeyType"
         }
        ],
        "endline" : 504
       },
       {
        "name" : "upperBound",
        "kind" : "function",
        "comment" : "\nReturns a range of all elements with keys larger than $(D k) (could be\nempty or a singleton range).  Only defined by containers that store\ndata sorted at all times.\n \n",
        "line" : 511,
        "type" : "Range(KeyType k)",
        "parameters" : [
         {
          "name" : "k",
          "type" : "KeyType"
         }
        ],
        "endline" : 514
       },
       {
        "kind" : "template",
        "comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n \n",
        "line" : 524,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n \n",
          "line" : 524,
          "type" : "TotalContainer(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 527
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 530,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 530,
          "type" : "TotalContainer(Stuff lhs)",
          "parameters" : [
           {
            "name" : "lhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 533
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nForwards to $(D insertAfter(this[], stuff)).\n \n",
        "line" : 538,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nForwards to $(D insertAfter(this[], stuff)).\n \n",
          "line" : 538,
          "type" : "void(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 541
         }
        ]
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\nRemoves all contents from the container. The container decides how $(D\ncapacity) is affected.\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH n)\n \n",
        "line" : 551,
        "type" : "void()",
        "endline" : 554
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\nSets the number of elements in the container to $(D newSize). If $(D\nnewSize) is greater than $(D length), the added elements are added to\nunspecified positions in the container and initialized with $(D\n.init).\n\nComplexity: $(BIGOH abs(n - newLength))\n\nPostcondition: $(D _length == newLength)\n \n",
        "line" : 566,
        "type" : "void(size_t newLength)",
        "parameters" : [
         {
          "name" : "newLength",
          "type" : "size_t"
         }
        ],
        "endline" : 569
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) in an unspecified position in the\ncontainer. Implementations should choose whichever insertion means is\nthe most advantageous for the container, but document the exact\nbehavior. $(D stuff) can be a value convertible to the element type of\nthe container, or a range of values convertible to it.\n\nThe $(D stable) version guarantees that ranges iterating over the\ncontainer are never invalidated. Client code that counts on\nnon-invalidating insertion should use $(D stableInsert). Such code would\nnot compile against containers that don't support it.\n\nReturns: The number of elements added.\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n \n",
        "line" : 588,
        "name" : "insert",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insert",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) in an unspecified position in the\ncontainer. Implementations should choose whichever insertion means is\nthe most advantageous for the container, but document the exact\nbehavior. $(D stuff) can be a value convertible to the element type of\nthe container, or a range of values convertible to it.\n\nThe $(D stable) version guarantees that ranges iterating over the\ncontainer are never invalidated. Client code that counts on\nnon-invalidating insertion should use $(D stableInsert). Such code would\nnot compile against containers that don't support it.\n\nReturns: The number of elements added.\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n \n",
          "line" : 588,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 591
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 593,
        "name" : "stableInsert",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableInsert",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 593,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 596
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nSame as $(D insert(stuff)) and $(D stableInsert(stuff)) respectively,\nbut relax the complexity constraint to linear.\n \n",
        "line" : 602,
        "name" : "linearInsert",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "linearInsert",
          "kind" : "function",
          "comment" : "\nSame as $(D insert(stuff)) and $(D stableInsert(stuff)) respectively,\nbut relax the complexity constraint to linear.\n \n",
          "line" : 602,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 605
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 607,
        "name" : "stableLinearInsert",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableLinearInsert",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 607,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 610
         }
        ]
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\nPicks one value in an unspecified position in the container, removes\nit from the container, and returns it. Implementations should pick the\nvalue that's the most advantageous for the container, but document the\nexact behavior. The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH log(n)).\n \n",
        "line" : 625,
        "type" : "T()",
        "endline" : 628
       },
       {
        "name" : "stableRemoveAny",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 630,
        "type" : "T()",
        "endline" : 633
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof values convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n)).\n \n",
        "line" : 646,
        "name" : "insertFront",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertFront",
          "kind" : "function",
          "comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof values convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n)).\n \n",
          "line" : 646,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 649
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 651,
        "name" : "stableInsertFront",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableInsertFront",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 651,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 654
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 656,
        "name" : "insertBack",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBack",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 656,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 659
         }
        ]
       },
       {
        "name" : "stableInsertBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 661,
        "type" : "size_t(T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         }
        ],
        "endline" : 664
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves the value at the front or back of the container. The stable\nversion behaves the same, but guarantees that ranges iterating over\nthe container are never invalidated. The optional parameter $(D\nhowMany) instructs removal of that many elements. If $(D howMany > n),\nall elements are removed and no exception is thrown.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH log(n)).\n \n",
        "line" : 677,
        "type" : "void()",
        "endline" : 680
       },
       {
        "name" : "stableRemoveFront",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 682,
        "type" : "void()",
        "endline" : 685
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 687,
        "type" : "void()",
        "endline" : 690
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 692,
        "type" : "void()",
        "endline" : 695
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n \n",
        "line" : 710,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 713
       },
       {
        "name" : "stableRemoveFront",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 715,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 718
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 720,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 723
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 725,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 728
       },
       {
        "name" : "removeKey",
        "kind" : "function",
        "comment" : "\nRemoves all values corresponding to key $(D k).\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements with the same key.\n\nReturns: The number of elements removed.\n \n",
        "line" : 738,
        "type" : "size_t(KeyType k)",
        "parameters" : [
         {
          "name" : "k",
          "type" : "KeyType"
         }
        ],
        "endline" : 741
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof objects convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n \n",
        "line" : 755,
        "name" : "insertBefore",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBefore",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to the container's element type or a range\nof objects convertible to it. The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n \n",
          "line" : 755,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 758
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 760,
        "name" : "stableInsertBefore",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableInsertBefore",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 760,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 763
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 765,
        "name" : "insertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertAfter",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 765,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 768
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 770,
        "name" : "stableInsertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableInsertAfter",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 770,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 773
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 775,
        "name" : "replace",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "replace",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 775,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 778
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 780,
        "name" : "stableReplace",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableReplace",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 780,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 783
         }
        ]
       },
       {
        "name" : "remove",
        "kind" : "function",
        "comment" : "\nRemoves all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves the\nsame, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D r)\n \n",
        "line" : 797,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 800
       },
       {
        "name" : "stableRemove",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 802,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 805
       },
       {
        "name" : "linearRemove",
        "kind" : "function",
        "comment" : "\nSame as $(D remove) above, but has complexity relaxed to linear.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH n)\n \n",
        "line" : 815,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 818
       },
       {
        "name" : "stableLinearRemove",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 820,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 823
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL826_386",
    "kind" : "function",
    "line" : 826,
    "endline" : 848
   },
   {
    "kind" : "template",
    "comment" : "\nReturns an initialized object. This function is mainly for eliminating\nconstruction differences between structs and classes. It allows code to not\nworry about whether the type it's constructing is a struct or a class.\n\nExamples:\n--------------------\nauto arr = make!(Array!int)([4, 2, 3, 1]);\nassert(equal(arr[], [4, 2, 3, 1]));\n\nauto rbt = make!(RedBlackTree!(int, \"a > b\"))([4, 2, 3, 1]);\nassert(equal(rbt[], [4, 3, 2, 1]));\n\nalias make!(DList!int) makeList;\nauto list = makeList([1, 7, 42]);\nassert(equal(list[], [1, 7, 42]));\n--------------------\n \n",
    "line" : 848,
    "name" : "make",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 851,
      "name" : "make",
      "parameters" : [
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "make",
        "kind" : "function",
        "line" : 851,
        "type" : "T(Args arguments)",
        "parameters" : [
         {
          "name" : "arguments",
          "type" : "Args"
         }
        ],
        "endline" : 855
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 857,
      "name" : "make",
      "parameters" : [
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "make",
        "kind" : "function",
        "line" : 857,
        "type" : "T(Args arguments)",
        "parameters" : [
         {
          "name" : "arguments",
          "type" : "Args"
         }
        ],
        "endline" : 861
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL865_387",
    "kind" : "function",
    "line" : 865,
    "endline" : 878
   },
   {
    "name" : "__unittestL878_388",
    "kind" : "function",
    "line" : 878,
    "endline" : 894
   },
   {
    "kind" : "template",
    "comment" : "\n   Implements a simple and fast singly-linked list.\n \n",
    "line" : 895,
    "name" : "SList",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SList",
      "kind" : "struct",
      "line" : 895,
      "members" : [
       {
        "name" : "Node",
        "kind" : "struct",
        "line" : 897,
        "members" : [
         {
          "name" : "_payload",
          "kind" : "variable",
          "line" : 898,
          "type" : "T"
         },
         {
          "name" : "_next",
          "kind" : "variable",
          "line" : 899,
          "type" : "Node*"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 900,
          "type" : "(T a, Node* b)",
          "parameters" : [
           {
            "name" : "a",
            "type" : "T"
           },
           {
            "name" : "b",
            "type" : "Node*"
           }
          ],
          "endline" : 900
         }
        ]
       },
       {
        "name" : "_root",
        "kind" : "variable",
        "line" : 902,
        "type" : "Node*"
       },
       {
        "name" : "findLastNode",
        "kind" : "function",
        "line" : 904,
        "type" : "Node*(Node* n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "Node*"
         }
        ],
        "endline" : 914
       },
       {
        "name" : "findLastNode",
        "kind" : "function",
        "line" : 916,
        "type" : "Node*(Node* n, size_t limit)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "Node*"
         },
         {
          "name" : "limit",
          "type" : "size_t"
         }
        ],
        "endline" : 927
       },
       {
        "name" : "findNode",
        "kind" : "function",
        "line" : 929,
        "type" : "Node*(Node* n, Node* findMe)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "Node*"
         },
         {
          "name" : "findMe",
          "type" : "Node*"
         }
        ],
        "endline" : 940
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor taking a number of nodes\n     \n",
        "line" : 945,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 945,
          "type" : "(U[] values...)",
          "parameters" : [
           {
            "name" : "values",
            "type" : "U[]"
           }
          ],
          "endline" : 948
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor taking an input range\n     \n",
        "line" : 953,
        "name" : "this",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 953,
          "type" : "(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 959
         }
        ]
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\nComparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n     \n",
        "line" : 967,
        "type" : "const bool(const SList rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "SList",
          "storageClass" : [
           "const"
          ]
         }
        ],
        "endline" : 970
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 973,
        "type" : "const bool(ref const SList rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "SList",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 982
       },
       {
        "name" : "Range",
        "kind" : "struct",
        "comment" : "\nDefines the container's primary range, which embodies a forward range.\n     \n",
        "line" : 988,
        "members" : [
         {
          "name" : "_head",
          "kind" : "variable",
          "line" : 989,
          "type" : "Node*"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 990,
          "type" : "(Node* p)",
          "parameters" : [
           {
            "name" : "p",
            "type" : "Node*"
           }
          ],
          "endline" : 990
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : " Input range primitives.\n",
          "line" : 993,
          "type" : "const bool()",
          "endline" : 993
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 996,
          "type" : "T()",
          "endline" : 1000
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1013,
          "type" : "void()",
          "endline" : 1017
         },
         {
          "name" : "save",
          "kind" : "function",
          "comment" : " Forward range primitive.\n",
          "line" : 1020,
          "type" : "Range()",
          "endline" : 1020
         },
         {
          "name" : "moveFront",
          "kind" : "function",
          "line" : 1022,
          "type" : "T()",
          "endline" : 1026
         },
         {
          "name" : "sameHead",
          "kind" : "function",
          "line" : 1028,
          "type" : "bool(Range rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Range"
           }
          ],
          "endline" : 1031
         }
        ]
       },
       {
        "name" : "__unittestL1034_389",
        "kind" : "function",
        "line" : 1034,
        "endline" : 1045
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1045,
        "type" : "const bool()",
        "endline" : 1048
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\nDuplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n     \n",
        "line" : 1056,
        "type" : "SList()",
        "endline" : 1059
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\nReturns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1067,
        "type" : "Range()",
        "endline" : 1070
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\nForward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1077,
        "type" : "T()",
        "endline" : 1081
       },
       {
        "name" : "__unittestL1097_390",
        "kind" : "function",
        "line" : 1097,
        "endline" : 1109
       },
       {
        "kind" : "template",
        "comment" : "\nReturns a new $(D SList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n     \n",
        "line" : 1109,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : "\nReturns a new $(D SList) that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n     \n",
          "line" : 1109,
          "type" : "SList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1123
         }
        ]
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\nRemoves all contents from the $(D SList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1132,
        "type" : "void()",
        "endline" : 1135
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) to the front of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m), where $(D m) is the length of $(D stuff)\n     \n",
        "line" : 1147,
        "name" : "insertFront",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertFront",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) to the front of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m), where $(D m) is the length of $(D stuff)\n     \n",
          "line" : 1147,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1164
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1167,
        "name" : "insertFront",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertFront",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1167,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1173
         }
        ]
       },
       {
        "name" : "insert",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1176,
        "type" : "insertFront"
       },
       {
        "name" : "stableInsert",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1179,
        "type" : "insert"
       },
       {
        "name" : "stableInsertFront",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1182,
        "type" : "insertFront"
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\nPicks one value from the front of the container, removes it from the\ncontainer, and returns it.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n     \n",
        "line" : 1194,
        "type" : "T()",
        "endline" : 1200
       },
       {
        "name" : "stableRemoveAny",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1202,
        "type" : "removeAny"
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves the value at the front of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n     \n",
        "line" : 1213,
        "type" : "void()",
        "endline" : 1217
       },
       {
        "name" : "stableRemoveFront",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1220,
        "type" : "removeFront"
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n     \n",
        "line" : 1235,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 1244
       },
       {
        "name" : "stableRemoveFront",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1247,
        "type" : "removeFront"
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) after range $(D r), which must be a range\npreviously extracted from this container. Given that all ranges for a\nlist end at the end of the list, this function essentially appends to\nthe list and uses $(D r) as a potentially fast way to reach the last\nnode in the list. Ideally $(D r) is positioned near or at the last\nelement of the list.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n\nExamples:\n--------------------\nauto sl = SList!string([\"a\", \"b\", \"d\"]);\nsl.insertAfter(sl[], \"e\"); // insert at the end (slowest)\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"d\", \"e\"]));\nsl.insertAfter(std.range.take(sl[], 2), \"c\"); // insert after \"b\"\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"c\", \"d\", \"e\"]));\n--------------------\n     \n",
        "line" : 1277,
        "name" : "insertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertAfter",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) after range $(D r), which must be a range\npreviously extracted from this container. Given that all ranges for a\nlist end at the end of the list, this function essentially appends to\nthe list and uses $(D r) as a potentially fast way to reach the last\nnode in the list. Ideally $(D r) is positioned near or at the last\nelement of the list.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n\nExamples:\n--------------------\nauto sl = SList!string([\"a\", \"b\", \"d\"]);\nsl.insertAfter(sl[], \"e\"); // insert at the end (slowest)\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"d\", \"e\"]));\nsl.insertAfter(std.range.take(sl[], 2), \"c\"); // insert after \"b\"\nassert(std.algorithm.equal(sl[], [\"a\", \"b\", \"c\", \"d\", \"e\"]));\n--------------------\n     \n",
          "line" : 1277,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1290
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nSimilar to $(D insertAfter) above, but accepts a range bounded in\ncount. This is important for ensuring fast insertions in the middle of\nthe list.  For fast insertions after a specified position $(D r), use\n$(D insertAfter(take(r, 1), stuff)). The complexity of that operation\nonly depends on the number of elements in $(D stuff).\n\nPrecondition: $(D r.original.empty || r.maxLength > 0)\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
        "line" : 1306,
        "name" : "insertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertAfter",
          "kind" : "function",
          "comment" : "\nSimilar to $(D insertAfter) above, but accepts a range bounded in\ncount. This is important for ensuring fast insertions in the middle of\nthe list.  For fast insertions after a specified position $(D r), use\n$(D insertAfter(take(r, 1), stuff)). The complexity of that operation\nonly depends on the number of elements in $(D stuff).\n\nPrecondition: $(D r.original.empty || r.maxLength > 0)\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
          "line" : 1306,
          "type" : "size_t(Take!(Range) r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Take!(Range)"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1328
         }
        ]
       },
       {
        "name" : "stableInsertAfter",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1331,
        "type" : "insertAfter"
       },
       {
        "name" : "linearRemove",
        "kind" : "function",
        "comment" : "\nRemoves a range from the list in linear time.\n\nReturns: An empty range.\n\nComplexity: $(BIGOH n)\n     \n",
        "line" : 1340,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 1350
       },
       {
        "name" : "linearRemove",
        "kind" : "function",
        "comment" : "\nRemoves a $(D Take!Range) from the list in linear time.\n\nReturns: A range comprehending the elements after the removed range.\n\nComplexity: $(BIGOH n)\n     \n",
        "line" : 1359,
        "type" : "Range(Take!(Range) r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Take!(Range)"
         }
        ],
        "endline" : 1383
       },
       {
        "name" : "stableLinearRemove",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1386,
        "type" : "linearRemove"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1389_391",
    "kind" : "function",
    "line" : 1389,
    "endline" : 1396
   },
   {
    "name" : "__unittestL1396_392",
    "kind" : "function",
    "line" : 1396,
    "endline" : 1402
   },
   {
    "name" : "__unittestL1402_393",
    "kind" : "function",
    "line" : 1402,
    "endline" : 1409
   },
   {
    "name" : "__unittestL1409_394",
    "kind" : "function",
    "line" : 1409,
    "endline" : 1420
   },
   {
    "name" : "__unittestL1420_395",
    "kind" : "function",
    "line" : 1420,
    "endline" : 1427
   },
   {
    "name" : "__unittestL1427_396",
    "kind" : "function",
    "line" : 1427,
    "endline" : 1434
   },
   {
    "name" : "__unittestL1434_397",
    "kind" : "function",
    "line" : 1434,
    "endline" : 1443
   },
   {
    "name" : "__unittestL1443_398",
    "kind" : "function",
    "line" : 1443,
    "endline" : 1452
   },
   {
    "name" : "__unittestL1452_399",
    "kind" : "function",
    "line" : 1452,
    "endline" : 1459
   },
   {
    "name" : "__unittestL1459_400",
    "kind" : "function",
    "line" : 1459,
    "endline" : 1466
   },
   {
    "name" : "__unittestL1466_401",
    "kind" : "function",
    "line" : 1466,
    "endline" : 1474
   },
   {
    "name" : "__unittestL1474_402",
    "kind" : "function",
    "line" : 1474,
    "endline" : 1484
   },
   {
    "name" : "__unittestL1484_403",
    "kind" : "function",
    "line" : 1484,
    "endline" : 1494
   },
   {
    "name" : "__unittestL1494_404",
    "kind" : "function",
    "line" : 1494,
    "endline" : 1506
   },
   {
    "name" : "__unittestL1506_405",
    "kind" : "function",
    "line" : 1506,
    "endline" : 1520
   },
   {
    "name" : "__unittestL1520_406",
    "kind" : "function",
    "line" : 1520,
    "endline" : 1525
   },
   {
    "name" : "__unittestL1525_407",
    "kind" : "function",
    "line" : 1525,
    "endline" : 1535
   },
   {
    "name" : "__unittestL1535_408",
    "kind" : "function",
    "line" : 1535,
    "endline" : 1592
   },
   {
    "kind" : "template",
    "comment" : "\nImplements a doubly-linked list.\n\n$(D DList) uses neither reference nor value semantics. They can be seen as\nseveral different handles into an external chain of nodes. Several different\n$(D DList)s can all reference different points in a same chain.\n\n$(D DList.Range) is, for all intents and purposes, a DList with range\nsemantics. The $(D DList.Range) has a view directly into the chain itself.\nIt is not tied to its parent $(D DList), and may be used to operate on\nother lists (that point to the same chain).\n\nThe ONLY operation that can invalidate a $(D DList) or $(D DList.Range), but\nwhich will invalidate BOTH, is the $(D remove) operation, if the cut Range\noverlaps with the boundaries of another DList or DList.Range.\n\nExample:\n----\nauto a = DList!int([3, 4]); //Create a new chain\nauto b = a; //Point to the same chain\n// (3 - 4)\nassert(a[].equal([3, 4]));\nassert(b[].equal([3, 4]));\n\nb.stableInsertFront(1); //insert before of b\nb.stableInsertBack(5); //insert after of b\n// (2 - (3 - 4) - 5)\nassert(a[].equal([3, 4])); //a is not changed\nassert(b[].equal([1, 3, 4, 5])); // but b is changed\n\na.stableInsertFront(2); //insert in front of a, this will insert \"inside\" the chain\n// (1 - (2 - 3 - 4) - 5)\nassert(a[].equal([2, 3, 4])); //a is modified\nassert(b[].equal([1, 2, 3, 4, 5])); //and so is b;\n\na.remove(a[]); //remove all the elements of a: This will cut them from the chain;\n// (1 - 5)\nassert(a[].empty); //a is empty\nassert(b[].equal([1, 5])); //b has lost some of its elements;\n\na.insert(2); //insert in a. This will create a new chain\n// (2)\n// (1 - 5)\nassert(a[].equal([2])); //a is a new chain\nassert(b[].equal([1, 5])); //b is unchanged;\n----\n \n",
    "line" : 1593,
    "name" : "DList",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "DList",
      "kind" : "struct",
      "line" : 1593,
      "members" : [
       {
        "name" : "Node",
        "kind" : "struct",
        "line" : 1595,
        "members" : [
         {
          "name" : "_payload",
          "kind" : "variable",
          "line" : 1596,
          "type" : "T"
         },
         {
          "name" : "_prev",
          "kind" : "variable",
          "line" : 1597,
          "type" : "Node*"
         },
         {
          "name" : "_next",
          "kind" : "variable",
          "line" : 1598,
          "type" : "Node*"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1599,
          "type" : "(T a, Node* p, Node* n)",
          "parameters" : [
           {
            "name" : "a",
            "type" : "T"
           },
           {
            "name" : "p",
            "type" : "Node*"
           },
           {
            "name" : "n",
            "type" : "Node*"
           }
          ],
          "endline" : 1605
         }
        ]
       },
       {
        "name" : "_first",
        "kind" : "variable",
        "line" : 1607,
        "type" : "Node*"
       },
       {
        "name" : "_last",
        "kind" : "variable",
        "line" : 1608,
        "type" : "Node*"
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor taking a number of nodes\n     \n",
        "line" : 1613,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1613,
          "type" : "(U[] values...)",
          "parameters" : [
           {
            "name" : "values",
            "type" : "U[]"
           }
          ],
          "endline" : 1616
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor taking an input range\n     \n",
        "line" : 1621,
        "name" : "this",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1621,
          "type" : "(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1627
         }
        ]
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\nComparison for equality.\n\nComplexity: $(BIGOH min(n, n1)) where $(D n1) is the number of\nelements in $(D rhs).\n     \n",
        "line" : 1635,
        "type" : "const bool(ref const DList rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "DList",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 1648
       },
       {
        "name" : "Range",
        "kind" : "struct",
        "comment" : "\n    Defines the container's primary range, which embodies a bidirectional range.\n     \n",
        "line" : 1654,
        "members" : [
         {
          "name" : "_first",
          "kind" : "variable",
          "line" : 1655,
          "type" : "Node*"
         },
         {
          "name" : "_last",
          "kind" : "variable",
          "line" : 1656,
          "type" : "Node*"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1657,
          "type" : "(Node* first, Node* last)",
          "parameters" : [
           {
            "name" : "first",
            "type" : "Node*"
           },
           {
            "name" : "last",
            "type" : "Node*"
           }
          ],
          "endline" : 1661
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1662,
          "type" : "(Node* n)",
          "parameters" : [
           {
            "name" : "n",
            "type" : "Node*"
           }
          ],
          "endline" : 1662
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : " Input range primitives.\n",
          "line" : 1666,
          "type" : "bool()",
          "endline" : 1670
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1673,
          "type" : "T()",
          "endline" : 1677
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1690,
          "type" : "void()",
          "endline" : 1701
         },
         {
          "name" : "save",
          "kind" : "function",
          "comment" : " Forward range primitive.\n",
          "line" : 1704,
          "type" : "Range()",
          "endline" : 1704
         },
         {
          "name" : "back",
          "kind" : "function",
          "comment" : " Bidirectional range primitives.\n",
          "line" : 1707,
          "type" : "T()",
          "endline" : 1711
         },
         {
          "name" : "popBack",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1724,
          "type" : "void()",
          "endline" : 1735
         }
        ]
       },
       {
        "name" : "__unittestL1738_409",
        "kind" : "function",
        "line" : 1738,
        "endline" : 1749
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1750,
        "type" : "bool()",
        "endline" : 1754
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\nDuplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n     \n",
        "line" : 1762,
        "type" : "DList()",
        "endline" : 1765
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\nReturns a range that iterates over all elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1773,
        "type" : "Range()",
        "endline" : 1776
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\nForward to $(D opSlice().front).\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1783,
        "type" : "T()",
        "endline" : 1787
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : "\nForward to $(D opSlice().back).\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1808,
        "type" : "T()",
        "endline" : 1812
       },
       {
        "kind" : "template",
        "comment" : "\nReturns a new $(D DList) that's the concatenation of $(D this) and its\nargument.\n     \n",
        "line" : 1832,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : "\nReturns a new $(D DList) that's the concatenation of $(D this) and its\nargument.\n     \n",
          "line" : 1832,
          "type" : "DList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1838
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1840,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1840,
          "type" : "DList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1846
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nReturns a new $(D DList) that's the concatenation of the argument and $(D this)\n     \n",
        "line" : 1851,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "comment" : "\nReturns a new $(D DList) that's the concatenation of the argument and $(D this)\n     \n",
          "line" : 1851,
          "type" : "DList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1857
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1860,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1860,
          "type" : "DList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1866
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAppends the contents of stuff into this.\n     \n",
        "line" : 1871,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nAppends the contents of stuff into this.\n     \n",
          "line" : 1871,
          "type" : "DList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1876
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1879,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1879,
          "type" : "DList(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1884
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 1887,
        "name" : "opOpAssignRightPrivate",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssignRightPrivate",
          "kind" : "function",
          "line" : 1887,
          "type" : "DList(Stuff lhs)",
          "parameters" : [
           {
            "name" : "lhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 1892
         }
        ]
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\nRemoves all contents from the $(D DList).\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 1901,
        "type" : "void()",
        "endline" : 1905
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) to the front/back of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n     \n",
        "line" : 1917,
        "name" : "insertFront",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertFront",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) to the front/back of the container. $(D stuff) can be a\nvalue convertible to $(D T) or a range of objects convertible to $(D\nT). The stable version behaves the same, but guarantees that ranges\niterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH log(n))\n     \n",
          "line" : 1917,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1920
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1923,
        "name" : "insertBack",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBack",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1923,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 1926
         }
        ]
       },
       {
        "name" : "insert",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1929,
        "type" : "insertBack"
       },
       {
        "name" : "stableInsert",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1932,
        "type" : "insert"
       },
       {
        "name" : "stableInsertFront",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1935,
        "type" : "insertFront"
       },
       {
        "name" : "stableInsertBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1938,
        "type" : "insertBack"
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\nPicks one value from the front of the container, removes it from the\ncontainer, and returns it.\n\nElements are not actually removed from the chain, but the $(D DList)'s,\nfirst/last pointer is advanced.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH 1).\n     \n",
        "line" : 1953,
        "type" : "T()",
        "endline" : 1963
       },
       {
        "name" : "stableRemoveAny",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1965,
        "type" : "removeAny"
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves the value at the front/back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nElements are not actually removed from the chain, but the $(D DList)'s,\nfirst/last pointer is advanced.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1).\n     \n",
        "line" : 1979,
        "type" : "void()",
        "endline" : 1987
       },
       {
        "name" : "stableRemoveFront",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 1990,
        "type" : "removeFront"
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 1993,
        "type" : "void()",
        "endline" : 2001
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 2004,
        "type" : "removeBack"
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nElements are not actually removed from the chain, but the $(D DList)'s,\nfirst/last pointer is advanced.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany * log(n)).\n     \n",
        "line" : 2022,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 2035
       },
       {
        "name" : "stableRemoveFront",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 2038,
        "type" : "removeFront"
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 2041,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 2054
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 2057,
        "type" : "removeBack"
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) after range $(D r), which must be a non-empty range\npreviously extracted from this container.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nElements are not actually removed from the chain, but the $(D DList)'s,\nfirst/last pointer is advanced.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
        "line" : 2076,
        "name" : "insertBefore",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBefore",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) after range $(D r), which must be a non-empty range\npreviously extracted from this container.\n\n$(D stuff) can be a value convertible to $(D T) or a range of objects\nconvertible to $(D T). The stable version behaves the same, but\nguarantees that ranges iterating over the container are never\ninvalidated.\n\nElements are not actually removed from the chain, but the $(D DList)'s,\nfirst/last pointer is advanced.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH k + m), where $(D k) is the number of elements in\n$(D r) and $(D m) is the length of $(D stuff).\n     \n",
          "line" : 2076,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 2080
         }
        ]
       },
       {
        "name" : "stableInsertBefore",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 2083,
        "type" : "insertBefore"
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 2086,
        "name" : "insertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertAfter",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 2086,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 2090
         }
        ]
       },
       {
        "name" : "stableInsertAfter",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 2093,
        "type" : "insertAfter"
       },
       {
        "kind" : "template",
        "line" : 2096,
        "name" : "insertBeforeNode",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBeforeNode",
          "kind" : "function",
          "line" : 2096,
          "type" : "size_t(Node* n, Stuff stuff)",
          "parameters" : [
           {
            "name" : "n",
            "type" : "Node*"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 2152
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 2155,
        "name" : "insertBeforeNode",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBeforeNode",
          "kind" : "function",
          "line" : 2155,
          "type" : "size_t(Node* n, Stuff stuff)",
          "parameters" : [
           {
            "name" : "n",
            "type" : "Node*"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 2160
         }
        ]
       },
       {
        "name" : "remove",
        "kind" : "function",
        "comment" : "\nRemoves all elements belonging to $(D r), which must be a range\nobtained originally from this container.\n\nThis function actually removes the elements from the chain. This is the\nonly function that may invalidate a range, as it cuts the chain of elements:\nRanges (and other DList) that contain $(D r) or that are inside $(D r),\nas well a $(D r) itself, are never invalidated.\nRanges (and other DList) which partially overlap with $(D r) will be cut,\nand invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2178,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 2231
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 2234,
        "name" : "linearRemove",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "linearRemove",
          "kind" : "function",
          "line" : 2236,
          "type" : "Range(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 2236
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 2240,
        "name" : "linearRemove",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "linearRemove",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 2240,
          "type" : "Range(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 2244
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n$(D linearRemove) functions as $(D remove), but also accepts ranges that are\nresult the of a $(D take) operation. This is a convenient way to remove a\nfixed amount of elements from the range.\n\nComplexity: $(BIGOH r.walkLength)\n     \n",
        "line" : 2253,
        "name" : "linearRemove",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "linearRemove",
          "kind" : "function",
          "comment" : "\n$(D linearRemove) functions as $(D remove), but also accepts ranges that are\nresult the of a $(D take) operation. This is a convenient way to remove a\nfixed amount of elements from the range.\n\nComplexity: $(BIGOH r.walkLength)\n     \n",
          "line" : 2253,
          "type" : "Range(R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R"
           }
          ],
          "endline" : 2269
         }
        ]
       },
       {
        "name" : "stableRemove",
        "kind" : "alias",
        "comment" : " $(RED Scheduled for deprecation. These methods are not actually stable.\n    Use the standard $(D remove) or $(D linearRemove) instead.)\n         \n",
        "line" : 2274,
        "type" : "remove"
       },
       {
        "name" : "stableLinearRemove",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 2276,
        "type" : "linearRemove"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2279_410",
    "kind" : "function",
    "line" : 2279,
    "endline" : 2310
   },
   {
    "name" : "__unittestL2310_411",
    "kind" : "function",
    "line" : 2310,
    "endline" : 2325
   },
   {
    "name" : "__unittestL2325_412",
    "kind" : "function",
    "line" : 2325,
    "endline" : 2377
   },
   {
    "name" : "__unittestL2377_413",
    "kind" : "function",
    "line" : 2377,
    "endline" : 2388
   },
   {
    "name" : "__unittestL2388_414",
    "kind" : "function",
    "line" : 2388,
    "endline" : 2399
   },
   {
    "name" : "__unittestL2399_415",
    "kind" : "function",
    "line" : 2399,
    "endline" : 2410
   },
   {
    "name" : "__unittestL2410_416",
    "kind" : "function",
    "line" : 2410,
    "endline" : 2421
   },
   {
    "name" : "__unittestL2421_417",
    "kind" : "function",
    "line" : 2421,
    "endline" : 2431
   },
   {
    "name" : "__unittestL2431_418",
    "kind" : "function",
    "line" : 2431,
    "endline" : 2440
   },
   {
    "name" : "__unittestL2440_419",
    "kind" : "function",
    "line" : 2440,
    "endline" : 2478
   },
   {
    "name" : "__unittestL2478_420",
    "kind" : "function",
    "line" : 2478,
    "endline" : 2495
   },
   {
    "kind" : "template",
    "comment" : "\nArray type with deterministic control of memory. The memory allocated\nfor the array is reclaimed as soon as possible; there is no reliance\non the garbage collector. $(D Array) uses $(D malloc) and $(D free)\nfor managing its own memory.\n \n",
    "line" : 2496,
    "name" : "Array",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Array",
      "kind" : "struct",
      "line" : 2496,
      "members" : [
       {
        "name" : "Payload",
        "kind" : "struct",
        "line" : 2499,
        "members" : [
         {
          "name" : "_capacity",
          "kind" : "variable",
          "line" : 2500,
          "type" : "size_t"
         },
         {
          "name" : "_payload",
          "kind" : "variable",
          "line" : 2501,
          "type" : "T[]"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2504,
          "type" : "(T[] p)",
          "parameters" : [
           {
            "name" : "p",
            "type" : "T[]"
           }
          ],
          "endline" : 2504
         },
         {
          "name" : "~this",
          "kind" : "destructor",
          "line" : 2507,
          "endline" : 2513
         },
         {
          "name" : "opAssign",
          "kind" : "function",
          "line" : 2520,
          "type" : "void(Array!(T).Payload rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Array!(T).Payload"
           }
          ],
          "endline" : 2523
         },
         {
          "name" : "length",
          "kind" : "function",
          "line" : 2536,
          "type" : "const size_t()",
          "endline" : 2539
         },
         {
          "name" : "length",
          "kind" : "function",
          "line" : 2542,
          "type" : "void(size_t newLength)",
          "parameters" : [
           {
            "name" : "newLength",
            "type" : "size_t"
           }
          ],
          "endline" : 2562
         },
         {
          "name" : "capacity",
          "kind" : "function",
          "line" : 2565,
          "type" : "const size_t()",
          "endline" : 2568
         },
         {
          "name" : "reserve",
          "kind" : "function",
          "line" : 2571,
          "type" : "void(size_t elements)",
          "parameters" : [
           {
            "name" : "elements",
            "type" : "size_t"
           }
          ],
          "endline" : 2607
         },
         {
          "kind" : "template",
          "line" : 2610,
          "name" : "insertBack",
          "parameters" : [
           {
            "name" : "Stuff",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "insertBack",
            "kind" : "function",
            "line" : 2610,
            "type" : "size_t(Stuff stuff)",
            "parameters" : [
             {
              "name" : "stuff",
              "type" : "Stuff"
             }
            ],
            "endline" : 2621
           }
          ]
         },
         {
          "kind" : "template",
          "comment" : " Insert a range of items\n",
          "line" : 2624,
          "name" : "insertBack",
          "parameters" : [
           {
            "name" : "Stuff",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "insertBack",
            "kind" : "function",
            "comment" : " Insert a range of items\n",
            "line" : 2624,
            "type" : "size_t(Stuff stuff)",
            "parameters" : [
             {
              "name" : "stuff",
              "type" : "Stuff"
             }
            ],
            "endline" : 2643
           }
          ]
         }
        ]
       },
       {
        "name" : "Data",
        "kind" : "alias",
        "line" : 2645,
        "type" : "RefCounted!(Payload, RefCountedAutoInitialize.no)"
       },
       {
        "name" : "_data",
        "kind" : "variable",
        "line" : 2646,
        "type" : "Data"
       },
       {
        "kind" : "template",
        "line" : 2648,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2648,
          "type" : "(U[] values...)",
          "parameters" : [
           {
            "name" : "values",
            "type" : "U[]"
           }
          ],
          "endline" : 2661
         }
        ]
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\nComparison for equality.\n     \n",
        "line" : 2666,
        "type" : "const bool(const Array rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "Array",
          "storageClass" : [
           "const"
          ]
         }
        ],
        "endline" : 2669
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 2672,
        "type" : "const bool(ref const Array rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "Array",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 2677
       },
       {
        "name" : "Range",
        "kind" : "struct",
        "comment" : "\nDefines the container's primary range, which is a random-access range.\n     \n",
        "line" : 2683,
        "members" : [
         {
          "name" : "_outer",
          "kind" : "variable",
          "line" : 2684,
          "type" : "Array"
         },
         {
          "name" : "_a",
          "kind" : "variable",
          "line" : 2685,
          "type" : "size_t"
         },
         {
          "name" : "_b",
          "kind" : "variable",
          "line" : 2685,
          "type" : "size_t"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2687,
          "type" : "(Array data, size_t a, size_t b)",
          "parameters" : [
           {
            "name" : "data",
            "type" : "Array"
           },
           {
            "name" : "a",
            "type" : "size_t"
           },
           {
            "name" : "b",
            "type" : "size_t"
           }
          ],
          "endline" : 2692
         },
         {
          "name" : "save",
          "kind" : "function",
          "line" : 2694,
          "type" : "Range()",
          "endline" : 2698
         },
         {
          "name" : "empty",
          "kind" : "function",
          "line" : 2700,
          "type" : "const bool()",
          "endline" : 2704
         },
         {
          "name" : "length",
          "kind" : "function",
          "line" : 2706,
          "type" : "const size_t()",
          "endline" : 2710
         },
         {
          "name" : "opDollar",
          "kind" : "function",
          "line" : 2712,
          "type" : "const size_t()",
          "endline" : 2715
         },
         {
          "name" : "front",
          "kind" : "function",
          "line" : 2717,
          "type" : "T()",
          "endline" : 2721
         },
         {
          "name" : "back",
          "kind" : "function",
          "line" : 2723,
          "type" : "T()",
          "endline" : 2727
         },
         {
          "name" : "front",
          "kind" : "function",
          "line" : 2729,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 2733
         },
         {
          "name" : "back",
          "kind" : "function",
          "line" : 2735,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 2739
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "line" : 2741,
          "type" : "void()",
          "endline" : 2745
         },
         {
          "name" : "popBack",
          "kind" : "function",
          "line" : 2747,
          "type" : "void()",
          "endline" : 2751
         },
         {
          "name" : "moveFront",
          "kind" : "function",
          "line" : 2753,
          "type" : "T()",
          "endline" : 2757
         },
         {
          "name" : "moveBack",
          "kind" : "function",
          "line" : 2759,
          "type" : "T()",
          "endline" : 2763
         },
         {
          "name" : "moveAt",
          "kind" : "function",
          "line" : 2765,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 2770
         },
         {
          "name" : "opIndex",
          "kind" : "function",
          "line" : 2772,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 2777
         },
         {
          "kind" : "template",
          "line" : 2779,
          "name" : "opIndexUnary",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opIndexUnary",
            "kind" : "function",
            "line" : 2779,
            "type" : "void(size_t i)",
            "parameters" : [
             {
              "name" : "i",
              "type" : "size_t"
             }
            ],
            "endline" : 2785
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 2787,
          "name" : "opIndexUnary",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opIndexUnary",
            "kind" : "function",
            "line" : 2787,
            "type" : "T(size_t i)",
            "parameters" : [
             {
              "name" : "i",
              "type" : "size_t"
             }
            ],
            "endline" : 2793
           }
          ]
         },
         {
          "name" : "opIndexAssign",
          "kind" : "function",
          "line" : 2795,
          "type" : "void(T value, size_t i)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 2800
         },
         {
          "kind" : "template",
          "line" : 2802,
          "name" : "opIndexOpAssign",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opIndexOpAssign",
            "kind" : "function",
            "line" : 2802,
            "type" : "void(T value, size_t i)",
            "parameters" : [
             {
              "name" : "value",
              "type" : "T"
             },
             {
              "name" : "i",
              "type" : "size_t"
             }
            ],
            "endline" : 2807
           }
          ]
         },
         {
          "name" : "opSlice",
          "kind" : "function",
          "line" : 2809,
          "type" : "typeof(this)()",
          "endline" : 2813
         },
         {
          "name" : "opSlice",
          "kind" : "function",
          "line" : 2815,
          "type" : "typeof(this)(size_t a, size_t b)",
          "parameters" : [
           {
            "name" : "a",
            "type" : "size_t"
           },
           {
            "name" : "b",
            "type" : "size_t"
           }
          ],
          "endline" : 2822
         },
         {
          "name" : "opSliceAssign",
          "kind" : "function",
          "line" : 2824,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 2828
         },
         {
          "name" : "opSliceAssign",
          "kind" : "function",
          "line" : 2830,
          "type" : "void(T value, size_t i, size_t j)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "size_t"
           },
           {
            "name" : "j",
            "type" : "size_t"
           }
          ],
          "endline" : 2838
         },
         {
          "kind" : "template",
          "line" : 2840,
          "name" : "opSliceUnary",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opSliceUnary",
            "kind" : "function",
            "line" : 2840,
            "type" : "void()",
            "endline" : 2845
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 2847,
          "name" : "opSliceUnary",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opSliceUnary",
            "kind" : "function",
            "line" : 2847,
            "type" : "void(size_t i, size_t j)",
            "parameters" : [
             {
              "name" : "i",
              "type" : "size_t"
             },
             {
              "name" : "j",
              "type" : "size_t"
             }
            ],
            "endline" : 2856
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 2858,
          "name" : "opSliceOpAssign",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opSliceOpAssign",
            "kind" : "function",
            "line" : 2858,
            "type" : "void(T value)",
            "parameters" : [
             {
              "name" : "value",
              "type" : "T"
             }
            ],
            "endline" : 2862
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 2864,
          "name" : "opSliceOpAssign",
          "parameters" : [
           {
            "name" : "op",
            "kind" : "value",
            "type" : "string"
           }
          ],
          "members" : [
           {
            "name" : "opSliceOpAssign",
            "kind" : "function",
            "line" : 2864,
            "type" : "void(T value, size_t i, size_t j)",
            "parameters" : [
             {
              "name" : "value",
              "type" : "T"
             },
             {
              "name" : "i",
              "type" : "size_t"
             },
             {
              "name" : "j",
              "type" : "size_t"
             }
            ],
            "endline" : 2872
           }
          ]
         }
        ]
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\nDuplicates the container. The elements themselves are not transitively\nduplicated.\n\nComplexity: $(BIGOH n).\n     \n",
        "line" : 2881,
        "type" : "Array()",
        "endline" : 2885
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\nProperty returning $(D true) if and only if the container has no\nelements.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2893,
        "type" : "const bool()",
        "endline" : 2896
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\nReturns the number of elements in the container.\n\nComplexity: $(BIGOH 1).\n     \n",
        "line" : 2903,
        "type" : "const size_t()",
        "endline" : 2906
       },
       {
        "name" : "opDollar",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 2909,
        "type" : "const size_t()",
        "endline" : 2913
       },
       {
        "name" : "capacity",
        "kind" : "function",
        "comment" : "\nReturns the maximum number of elements the container can store without\n   (a) allocating memory, (b) invalidating iterators upon insertion.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2921,
        "type" : "size_t()",
        "endline" : 2924
       },
       {
        "name" : "reserve",
        "kind" : "function",
        "comment" : "\nEnsures sufficient capacity to accommodate $(D e) elements.\n\nPostcondition: $(D capacity >= e)\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2933,
        "type" : "void(size_t elements)",
        "parameters" : [
         {
          "name" : "elements",
          "type" : "size_t"
         }
        ],
        "endline" : 2951
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\nReturns a range that iterates over elements of the container, in\nforward order.\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2959,
        "type" : "Range()",
        "endline" : 2965
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\nReturns a range that iterates over elements of the container from\nindex $(D a) up to (excluding) index $(D b).\n\nPrecondition: $(D a <= b && b <= length)\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2975,
        "type" : "Range(size_t a, size_t b)",
        "parameters" : [
         {
          "name" : "a",
          "type" : "size_t"
         },
         {
          "name" : "b",
          "type" : "size_t"
         }
        ],
        "endline" : 2982
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\nForward to $(D opSlice().front) and $(D opSlice().back), respectively.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 2991,
        "type" : "T()",
        "endline" : 2995
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 2998,
        "type" : "void(T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         }
        ],
        "endline" : 3002
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 3005,
        "type" : "T()",
        "endline" : 3009
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 3012,
        "type" : "void(T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         }
        ],
        "endline" : 3016
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : "\nIndexing operators yield or modify the value at a specified index.\n\nPrecondition: $(D i < length)\n\nComplexity: $(BIGOH 1)\n     \n",
        "line" : 3025,
        "type" : "T(size_t i)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "size_t"
         }
        ],
        "endline" : 3029
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3032,
        "name" : "opIndexUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opIndexUnary",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3032,
          "type" : "void(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 3037
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3040,
        "name" : "opIndexUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opIndexUnary",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3040,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 3045
         }
        ]
       },
       {
        "name" : "opIndexAssign",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 3048,
        "type" : "void(T value, size_t i)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         },
         {
          "name" : "i",
          "type" : "size_t"
         }
        ],
        "endline" : 3052
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3055,
        "name" : "opIndexOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opIndexOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3055,
          "type" : "void(T value, size_t i)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 3059
         }
        ]
       },
       {
        "name" : "opSliceAssign",
        "kind" : "function",
        "comment" : "\nSlicing operations execute an operation on an entire slice.\n\nPrecondition: $(D i < j && j < length)\n\nComplexity: $(BIGOH slice.length)\n     \n",
        "line" : 3069,
        "type" : "void(T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         }
        ],
        "endline" : 3073
       },
       {
        "name" : "opSliceAssign",
        "kind" : "function",
        "line" : 3075,
        "type" : "void(T value, size_t i, size_t j)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         },
         {
          "name" : "i",
          "type" : "size_t"
         },
         {
          "name" : "j",
          "type" : "size_t"
         }
        ],
        "endline" : 3079
       },
       {
        "kind" : "template",
        "line" : 3081,
        "name" : "opSliceUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opSliceUnary",
          "kind" : "function",
          "line" : 3081,
          "type" : "void()",
          "endline" : 3086
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3089,
        "name" : "opSliceUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opSliceUnary",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3089,
          "type" : "void(size_t i, size_t j)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           },
           {
            "name" : "j",
            "type" : "size_t"
           }
          ],
          "endline" : 3094
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3097,
        "name" : "opSliceOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opSliceOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3097,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 3101
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3104,
        "name" : "opSliceOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opSliceOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3104,
          "type" : "void(T value, size_t i, size_t j)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "size_t"
           },
           {
            "name" : "j",
            "type" : "size_t"
           }
          ],
          "endline" : 3108
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n     \n",
        "line" : 3118,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : "\nReturns a new container that's the concatenation of $(D this) and its\nargument. $(D opBinaryRight) is only defined if $(D Stuff) does not\ndefine $(D opBinary).\n\nComplexity: $(BIGOH n + m), where m is the number of elements in $(D\nstuff)\n     \n",
          "line" : 3118,
          "type" : "Array(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3129
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nForwards to $(D insertBack(stuff)).\n     \n",
        "line" : 3134,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\nForwards to $(D insertBack(stuff)).\n     \n",
          "line" : 3134,
          "type" : "void(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3145
         }
        ]
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\nRemoves all contents from the container. The container decides how $(D\ncapacity) is affected.\n\nPostcondition: $(D empty)\n\nComplexity: $(BIGOH n)\n     \n",
        "line" : 3155,
        "type" : "void()",
        "endline" : 3158
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\nSets the number of elements in the container to $(D newSize). If $(D\nnewSize) is greater than $(D length), the added elements are added to\nunspecified positions in the container and initialized with $(D\nT.init).\n\nComplexity: $(BIGOH abs(n - newLength))\n\nPostcondition: $(D length == newLength)\n     \n",
        "line" : 3170,
        "type" : "void(size_t newLength)",
        "parameters" : [
         {
          "name" : "newLength",
          "type" : "size_t"
         }
        ],
        "endline" : 3174
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\nPicks one value in an unspecified position in the container, removes\nit from the container, and returns it. Implementations should pick the\nvalue that's the most advantageous for the container, but document the\nexact behavior. The stable version behaves the same, but guarantees\nthat ranges iterating over the container are never invalidated.\n\nPrecondition: $(D !empty)\n\nReturns: The element removed.\n\nComplexity: $(BIGOH log(n)).\n     \n",
        "line" : 3189,
        "type" : "T()",
        "endline" : 3194
       },
       {
        "name" : "stableRemoveAny",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 3196,
        "type" : "removeAny"
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n     \n",
        "line" : 3209,
        "name" : "insertBack",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBack",
          "kind" : "function",
          "comment" : "\nInserts $(D value) to the front or back of the container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of elements inserted\n\nComplexity: $(BIGOH m * log(n)), where $(D m) is the number of\nelements in $(D stuff)\n     \n",
          "line" : 3209,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3215
         }
        ]
       },
       {
        "name" : "insert",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 3217,
        "type" : "insertBack"
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : "\nRemoves the value at the back of the container. The stable version\nbehaves the same, but guarantees that ranges iterating over the\ncontainer are never invalidated.\n\nPrecondition: $(D !empty)\n\nComplexity: $(BIGOH log(n)).\n     \n",
        "line" : 3228,
        "type" : "void()",
        "endline" : 3237
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 3239,
        "type" : "removeBack"
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : "\nRemoves $(D howMany) values at the front or back of the\ncontainer. Unlike the unparameterized versions above, these functions\ndo not throw if they could not remove $(D howMany) elements. Instead,\nif $(D howMany > n), all elements are removed. The returned value is\nthe effective number of elements removed. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: The number of elements removed\n\nComplexity: $(BIGOH howMany).\n     \n",
        "line" : 3254,
        "type" : "size_t(size_t howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "type" : "size_t"
         }
        ],
        "endline" : 3267
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 3269,
        "type" : "removeBack"
       },
       {
        "kind" : "template",
        "comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
        "line" : 3282,
        "name" : "insertBefore",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBefore",
          "kind" : "function",
          "comment" : "\nInserts $(D stuff) before, after, or instead range $(D r), which must\nbe a valid range previously extracted from this container. $(D stuff)\ncan be a value convertible to $(D T) or a range of objects convertible\nto $(D T). The stable version behaves the same, but guarantees that\nranges iterating over the container are never invalidated.\n\nReturns: The number of values inserted.\n\nComplexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
          "line" : 3282,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3295
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3298,
        "name" : "insertBefore",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBefore",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3298,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3333
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3336,
        "name" : "insertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertAfter",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3336,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3346
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3349,
        "name" : "replace",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "replace",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3349,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3368
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 3371,
        "name" : "replace",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "replace",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 3371,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 3386
         }
        ]
       },
       {
        "name" : "linearRemove",
        "kind" : "function",
        "comment" : "\nRemoves all elements belonging to $(D r), which must be a range\nobtained originally from this container. The stable version behaves\nthe same, but guarantees that ranges iterating over the container are\nnever invalidated.\n\nReturns: A range spanning the remaining elements in the container that\ninitially were right after $(D r).\n\nComplexity: $(BIGOH n - m), where $(D m) is the number of elements in\n$(D r)\n     \n",
        "line" : 3400,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 3412
       },
       {
        "name" : "stableLinearRemove",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 3414,
        "type" : "remove"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL3423_421",
    "kind" : "function",
    "line" : 3423,
    "endline" : 3434
   },
   {
    "name" : "__unittestL3434_422",
    "kind" : "function",
    "line" : 3434,
    "endline" : 3440
   },
   {
    "name" : "__unittestL3440_423",
    "kind" : "function",
    "line" : 3440,
    "endline" : 3455
   },
   {
    "name" : "__unittestL3455_424",
    "kind" : "function",
    "line" : 3455,
    "endline" : 3462
   },
   {
    "name" : "__unittestL3462_425",
    "kind" : "function",
    "line" : 3462,
    "endline" : 3472
   },
   {
    "name" : "__unittestL3472_426",
    "kind" : "function",
    "line" : 3472,
    "endline" : 3480
   },
   {
    "name" : "__unittestL3480_427",
    "kind" : "function",
    "line" : 3480,
    "endline" : 3487
   },
   {
    "name" : "__unittestL3487_428",
    "kind" : "function",
    "line" : 3487,
    "endline" : 3498
   },
   {
    "name" : "__unittestL3498_429",
    "kind" : "function",
    "line" : 3498,
    "endline" : 3509
   },
   {
    "name" : "__unittestL3509_430",
    "kind" : "function",
    "line" : 3509,
    "endline" : 3525
   },
   {
    "name" : "__unittestL3539_431",
    "kind" : "function",
    "line" : 3539,
    "endline" : 3567
   },
   {
    "name" : "__unittestL3567_432",
    "kind" : "function",
    "line" : 3567,
    "endline" : 3583
   },
   {
    "name" : "__unittestL3583_433",
    "kind" : "function",
    "line" : 3583,
    "endline" : 3591
   },
   {
    "name" : "__unittestL3591_434",
    "kind" : "function",
    "line" : 3591,
    "endline" : 3597
   },
   {
    "name" : "__unittestL3597_435",
    "kind" : "function",
    "line" : 3597,
    "endline" : 3603
   },
   {
    "name" : "__unittestL3603_436",
    "kind" : "function",
    "line" : 3603,
    "endline" : 3609
   },
   {
    "name" : "__unittestL3609_437",
    "kind" : "function",
    "line" : 3609,
    "endline" : 3616
   },
   {
    "name" : "__unittestL3616_438",
    "kind" : "function",
    "line" : 3616,
    "endline" : 3627
   },
   {
    "name" : "__unittestL3627_439",
    "kind" : "function",
    "line" : 3627,
    "endline" : 3657
   },
   {
    "name" : "__unittestL3657_440",
    "kind" : "function",
    "line" : 3657,
    "endline" : 3722
   },
   {
    "kind" : "template",
    "comment" : "\nImplements a $(WEB en.wikipedia.org/wiki/Binary_heap, binary heap)\ncontainer on top of a given random-access range type (usually $(D\nT[])) or a random-access container type (usually $(D Array!T)). The\ndocumentation of $(D BinaryHeap) will refer to the underlying range or\ncontainer as the $(I store) of the heap.\n\nThe binary heap induces structure over the underlying store such that\naccessing the largest element (by using the $(D front) property) is a\n$(BIGOH 1) operation and extracting it (by using the $(D\nremoveFront()) method) is done fast in $(BIGOH log n) time.\n\nIf $(D less) is the less-than operator, which is the default option,\nthen $(D BinaryHeap) defines a so-called max-heap that optimizes\nextraction of the $(I largest) elements. To define a min-heap,\ninstantiate BinaryHeap with $(D \"a > b\") as its predicate.\n\nSimply extracting elements from a $(D BinaryHeap) container is\ntantamount to lazily fetching elements of $(D Store) in descending\norder. Extracting elements from the $(D BinaryHeap) to completion\nleaves the underlying store sorted in ascending order but, again,\nyields elements in descending order.\n\nIf $(D Store) is a range, the $(D BinaryHeap) cannot grow beyond the\nsize of that range. If $(D Store) is a container that supports $(D\ninsertBack), the $(D BinaryHeap) may grow by adding elements to the\ncontainer.\n\nExample:\n----\n// Example from \"Introduction to Algorithms\" Cormen et al, p 146\nint[] a = [ 4, 1, 3, 2, 16, 9, 10, 14, 8, 7 ];\nauto h = heapify(a);\n// largest element\nassert(h.front == 16);\n// a has the heap property\nassert(equal(a, [ 16, 14, 10, 9, 8, 7, 4, 3, 2, 1 ]));\n----\n     \n",
    "line" : 3724,
    "name" : "BinaryHeap",
    "parameters" : [
     {
      "name" : "Store",
      "kind" : "type"
     },
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     }
    ],
    "members" : [
     {
      "name" : "BinaryHeap",
      "kind" : "struct",
      "line" : 3724,
      "members" : [
       {
        "name" : "_payload",
        "kind" : "variable",
        "line" : 3731,
        "type" : "RefCounted!(Tuple!(Store, \"_store\", size_t, \"_length\"), RefCountedAutoInitialize.no)"
       },
       {
        "name" : "comp",
        "kind" : "alias",
        "line" : 3733,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "_store",
        "kind" : "function",
        "line" : 3735,
        "type" : "Store()",
        "endline" : 3739
       },
       {
        "name" : "_length",
        "kind" : "function",
        "line" : 3740,
        "type" : "size_t()",
        "endline" : 3744
       },
       {
        "name" : "assertValid",
        "kind" : "function",
        "line" : 3747,
        "type" : "void()",
        "endline" : 3759
       },
       {
        "name" : "percolateDown",
        "kind" : "function",
        "line" : 3764,
        "type" : "void(Store r, size_t i, size_t length)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Store"
         },
         {
          "name" : "i",
          "type" : "size_t"
         },
         {
          "name" : "length",
          "type" : "size_t"
         }
        ],
        "endline" : 3783
       },
       {
        "name" : "pop",
        "kind" : "function",
        "line" : 3786,
        "type" : "void(Store store)",
        "parameters" : [
         {
          "name" : "store",
          "type" : "Store"
         }
        ],
        "endline" : 3795
       },
       {
        "name" : "swap",
        "kind" : "function",
        "line" : 3797,
        "type" : "void(Store _store, size_t i, size_t j)",
        "parameters" : [
         {
          "name" : "_store",
          "type" : "Store"
         },
         {
          "name" : "i",
          "type" : "size_t"
         },
         {
          "name" : "j",
          "type" : "size_t"
         }
        ],
        "endline" : 3817
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n       Converts the store $(D s) into a heap. If $(D initialSize) is\n       specified, only the first $(D initialSize) elements in $(D s)\n       are transformed into a heap, after which the heap can grow up\n       to $(D r.length) (if $(D Store) is a range) or indefinitely (if\n       $(D Store) is a container with $(D insertBack)). Performs\n       $(BIGOH min(r.length, initialSize)) evaluations of $(D less).\n     \n",
        "line" : 3829,
        "type" : "(Store s, size_t initialSize = size_t.max)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "Store"
         },
         {
          "name" : "initialSize",
          "type" : "size_t",
          "default" : "size_t.max"
         }
        ],
        "endline" : 3832
       },
       {
        "name" : "acquire",
        "kind" : "function",
        "comment" : "\nTakes ownership of a store. After this, manipulating $(D s) may make\nthe heap work incorrectly.\n     \n",
        "line" : 3838,
        "type" : "void(Store s, size_t initialSize = size_t.max)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "Store"
         },
         {
          "name" : "initialSize",
          "type" : "size_t",
          "default" : "size_t.max"
         }
        ],
        "endline" : 3850
       },
       {
        "name" : "assume",
        "kind" : "function",
        "comment" : "\nTakes ownership of a store assuming it already was organized as a\nheap.\n     \n",
        "line" : 3856,
        "type" : "void(Store s, size_t initialSize = size_t.max)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "Store"
         },
         {
          "name" : "initialSize",
          "type" : "size_t",
          "default" : "size_t.max"
         }
        ],
        "endline" : 3862
       },
       {
        "name" : "release",
        "kind" : "function",
        "comment" : "\nClears the heap. Returns the portion of the store from $(D 0) up to\n$(D length), which satisfies the $(LUCKY heap property).\n     \n",
        "line" : 3869,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 3878
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\nReturns $(D true) if the heap is _empty, $(D false) otherwise.\n     \n",
        "line" : 3883,
        "type" : "bool()",
        "endline" : 3886
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\nReturns a duplicate of the heap. The underlying store must also\nsupport a $(D dup) method.\n     \n",
        "line" : 3892,
        "type" : "BinaryHeap()",
        "endline" : 3898
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\nReturns the _length of the heap.\n     \n",
        "line" : 3903,
        "type" : "size_t()",
        "endline" : 3906
       },
       {
        "name" : "capacity",
        "kind" : "function",
        "comment" : "\nReturns the _capacity of the heap, which is the length of the\nunderlying store (if the store is a range) or the _capacity of the\nunderlying store (if the store is a container).\n     \n",
        "line" : 3913,
        "type" : "size_t()",
        "endline" : 3924
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\nReturns a copy of the _front of the heap, which is the largest element\naccording to $(D less).\n     \n",
        "line" : 3930,
        "type" : "ElementType!(Store)()",
        "endline" : 3934
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\nClears the heap by detaching it from the underlying store.\n     \n",
        "line" : 3939,
        "type" : "void()",
        "endline" : 3942
       },
       {
        "name" : "insert",
        "kind" : "function",
        "comment" : "\nInserts $(D value) into the store. If the underlying store is a range\nand $(D length == capacity), throws an exception.\n     \n",
        "line" : 3948,
        "type" : "size_t(ElementType!(Store) value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "ElementType!(Store)"
         }
        ],
        "endline" : 3984
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\nRemoves the largest element from the heap.\n     \n",
        "line" : 3989,
        "type" : "void()",
        "endline" : 4001
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\nRemoves the largest element from the heap and returns a copy of\nit. The element still resides in the heap's store. For performance\nreasons you may want to use $(D removeFront) with heaps of objects\nthat are expensive to copy.\n     \n",
        "line" : 4009,
        "type" : "ElementType!(Store)()",
        "endline" : 4013
       },
       {
        "name" : "replaceFront",
        "kind" : "function",
        "comment" : "\nReplaces the largest element in the store with $(D value).\n     \n",
        "line" : 4018,
        "type" : "void(ElementType!(Store) value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "ElementType!(Store)"
         }
        ],
        "endline" : 4025
       },
       {
        "name" : "conditionalInsert",
        "kind" : "function",
        "comment" : "\nIf the heap has room to grow, inserts $(D value) into the store and\nreturns $(D true). Otherwise, if $(D less(value, front)), calls $(D\nreplaceFront(value)) and returns again $(D true). Otherwise, leaves\nthe heap unaffected and returns $(D false). This method is useful in\nscenarios where the smallest $(D k) elements of a set of candidates\nmust be collected.\n     \n",
        "line" : 4035,
        "type" : "bool(ElementType!(Store) value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "ElementType!(Store)"
         }
        ],
        "endline" : 4050
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nConvenience function that returns a $(D BinaryHeap!Store) object\ninitialized with $(D s) and $(D initialSize).\n \n",
    "line" : 4057,
    "name" : "heapify",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "Store",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "heapify",
      "kind" : "function",
      "comment" : "\nConvenience function that returns a $(D BinaryHeap!Store) object\ninitialized with $(D s) and $(D initialSize).\n \n",
      "line" : 4057,
      "type" : "BinaryHeap!(Store, less)(Store s, size_t initialSize = size_t.max)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Store"
       },
       {
        "name" : "initialSize",
        "type" : "size_t",
        "default" : "size_t.max"
       }
      ],
      "endline" : 4061
     }
    ]
   },
   {
    "name" : "__unittestL4063_441",
    "kind" : "function",
    "line" : 4063,
    "endline" : 4100
   },
   {
    "kind" : "template",
    "comment" : "\n\n\n_Array specialized for $(D bool). Packs together values efficiently by\nallocating one bit per element.\n \n",
    "line" : 4101,
    "name" : "Array",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Array",
      "kind" : "struct",
      "line" : 4101,
      "members" : [
       {
        "name" : "bitsPerWord",
        "kind" : "variable",
        "line" : 4102,
        "deco" : "k",
        "init" : "size_t.sizeof * 8"
       },
       {
        "name" : "Data",
        "kind" : "alias",
        "line" : 4104,
        "type" : "Tuple!(Array!(size_t).Payload, \"_backend\", ulong, \"_length\")"
       },
       {
        "name" : "_store",
        "kind" : "variable",
        "line" : 4105,
        "type" : "RefCounted!(Data, RefCountedAutoInitialize.no)"
       },
       {
        "name" : "data",
        "kind" : "function",
        "line" : 4107,
        "type" : "size_t[]()",
        "endline" : 4111
       },
       {
        "name" : "Range",
        "kind" : "struct",
        "comment" : "\n       Defines the container's primary range.\n     \n",
        "line" : 4117,
        "members" : [
         {
          "name" : "_outer",
          "kind" : "variable",
          "line" : 4118,
          "type" : "Array!(bool)"
         },
         {
          "name" : "_a",
          "kind" : "variable",
          "line" : 4119,
          "deco" : "m"
         },
         {
          "name" : "_b",
          "kind" : "variable",
          "line" : 4119,
          "deco" : "m"
         },
         {
          "name" : "save",
          "kind" : "function",
          "comment" : " Range primitives\n",
          "line" : 4121,
          "type" : "Range()",
          "endline" : 4132
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4134,
          "type" : "bool()",
          "endline" : 4137
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4139,
          "type" : "T()",
          "endline" : 4143
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4145,
          "type" : "void(bool value)",
          "parameters" : [
           {
            "name" : "value",
            "deco" : "b"
           }
          ],
          "endline" : 4149
         },
         {
          "name" : "moveFront",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4151,
          "type" : "T()",
          "endline" : 4155
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4157,
          "type" : "void()",
          "endline" : 4161
         },
         {
          "name" : "back",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4163,
          "type" : "T()",
          "endline" : 4167
         },
         {
          "name" : "moveBack",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4169,
          "type" : "T()",
          "endline" : 4173
         },
         {
          "name" : "popBack",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4175,
          "type" : "void()",
          "endline" : 4179
         },
         {
          "name" : "opIndex",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4181,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 4184
         },
         {
          "name" : "opIndexAssign",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4186,
          "type" : "void(T value, size_t i)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 4189
         },
         {
          "name" : "moveAt",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4191,
          "type" : "T(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 4194
         },
         {
          "name" : "length",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4196,
          "type" : "const ulong()",
          "endline" : 4200
         }
        ]
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n       Property returning $(D true) if and only if the container has\n       no elements.\n\n       Complexity: $(BIGOH 1)\n     \n",
        "line" : 4209,
        "type" : "bool()",
        "endline" : 4212
       },
       {
        "name" : "__unittestL4214_442",
        "kind" : "function",
        "line" : 4214,
        "endline" : 4229
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\n       Returns a duplicate of the container. The elements themselves\n       are not transitively duplicated.\n\n       Complexity: $(BIGOH n).\n     \n",
        "line" : 4229,
        "type" : "Array!(bool)()",
        "endline" : 4234
       },
       {
        "name" : "__unittestL4236_443",
        "kind" : "function",
        "line" : 4236,
        "endline" : 4251
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\n       Returns the number of elements in the container.\n\n       Complexity: $(BIGOH log(n)).\n    \n",
        "line" : 4251,
        "type" : "ulong()",
        "endline" : 4254
       },
       {
        "name" : "__unittestL4256_444",
        "kind" : "function",
        "line" : 4256,
        "endline" : 4271
       },
       {
        "name" : "capacity",
        "kind" : "function",
        "comment" : "\n       Returns the maximum number of elements the container can store\n       without (a) allocating memory, (b) invalidating iterators upon\n       insertion.\n\n       Complexity: $(BIGOH log(n)).\n     \n",
        "line" : 4271,
        "type" : "ulong()",
        "endline" : 4276
       },
       {
        "name" : "__unittestL4278_445",
        "kind" : "function",
        "line" : 4278,
        "endline" : 4297
       },
       {
        "name" : "reserve",
        "kind" : "function",
        "comment" : "\n       Ensures sufficient capacity to accommodate $(D n) elements.\n\n       Postcondition: $(D capacity >= n)\n\n       Complexity: $(BIGOH log(e - capacity)) if $(D e > capacity),\n       otherwise $(BIGOH 1).\n     \n",
        "line" : 4297,
        "type" : "void(ulong e)",
        "parameters" : [
         {
          "name" : "e",
          "deco" : "m"
         }
        ],
        "endline" : 4301
       },
       {
        "name" : "__unittestL4303_446",
        "kind" : "function",
        "line" : 4303,
        "endline" : 4319
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\n       Returns a range that iterates over all elements of the\n       container, in a container-defined order. The container should\n       choose the most convenient and fast method of iteration for $(D\n       opSlice()).\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 4319,
        "type" : "Range()",
        "endline" : 4322
       },
       {
        "name" : "__unittestL4324_447",
        "kind" : "function",
        "line" : 4324,
        "endline" : 4337
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\n       Returns a range that iterates the container between two\n       specified positions.\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 4337,
        "type" : "Range(ulong a, ulong b)",
        "parameters" : [
         {
          "name" : "a",
          "deco" : "m"
         },
         {
          "name" : "b",
          "deco" : "m"
         }
        ],
        "endline" : 4341
       },
       {
        "name" : "__unittestL4343_448",
        "kind" : "function",
        "line" : 4343,
        "endline" : 4356
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n       Equivalent to $(D opSlice().front) and $(D opSlice().back),\n       respectively.\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 4356,
        "type" : "bool()",
        "endline" : 4360
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 4363,
        "type" : "void(bool value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "b"
         }
        ],
        "endline" : 4368
       },
       {
        "name" : "__unittestL4370_449",
        "kind" : "function",
        "line" : 4370,
        "endline" : 4380
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 4380,
        "type" : "bool()",
        "endline" : 4384
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 4387,
        "type" : "void(bool value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "b"
         }
        ],
        "endline" : 4399
       },
       {
        "name" : "__unittestL4401_450",
        "kind" : "function",
        "line" : 4401,
        "endline" : 4413
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : "\n       Indexing operators yield or modify the value at a specified index.\n     \n",
        "line" : 4413,
        "type" : "bool(ulong i)",
        "parameters" : [
         {
          "name" : "i",
          "deco" : "m"
         }
        ],
        "endline" : 4419
       },
       {
        "name" : "opIndexAssign",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 4421,
        "type" : "void(bool value, ulong i)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "b"
         },
         {
          "name" : "i",
          "deco" : "m"
         }
        ],
        "endline" : 4428
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 4430,
        "name" : "opIndexOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opIndexOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 4430,
          "type" : "void(bool value, ulong i)",
          "parameters" : [
           {
            "name" : "value",
            "deco" : "b"
           },
           {
            "name" : "i",
            "deco" : "m"
           }
          ],
          "endline" : 4444
         }
        ]
       },
       {
        "name" : "moveAt",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 4446,
        "type" : "T(ulong i)",
        "parameters" : [
         {
          "name" : "i",
          "deco" : "m"
         }
        ],
        "endline" : 4449
       },
       {
        "name" : "__unittestL4451_451",
        "kind" : "function",
        "line" : 4451,
        "endline" : 4467
       },
       {
        "kind" : "template",
        "comment" : "\n       Returns a new container that's the concatenation of $(D this)\n       and its argument.\n\n       Complexity: $(BIGOH n + m), where m is the number of elements\n       in $(D stuff)\n     \n",
        "line" : 4467,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : "\n       Returns a new container that's the concatenation of $(D this)\n       and its argument.\n\n       Complexity: $(BIGOH n + m), where m is the number of elements\n       in $(D stuff)\n     \n",
          "line" : 4467,
          "type" : "Array!(bool)(Stuff rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "Stuff"
           }
          ],
          "endline" : 4471
         }
        ]
       },
       {
        "name" : "__unittestL4473_452",
        "kind" : "function",
        "line" : 4473,
        "endline" : 4494
       },
       {
        "kind" : "template",
        "comment" : "\n       Forwards to $(D insertAfter(this[], stuff)).\n     \n",
        "line" : 4494,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : "\n       Forwards to $(D insertAfter(this[], stuff)).\n     \n",
          "line" : 4494,
          "type" : "Array!(bool)(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 4499
         }
        ]
       },
       {
        "name" : "__unittestL4501_453",
        "kind" : "function",
        "line" : 4501,
        "endline" : 4521
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\n       Removes all contents from the container. The container decides\n       how $(D capacity) is affected.\n\n       Postcondition: $(D empty)\n\n       Complexity: $(BIGOH n)\n     \n",
        "line" : 4521,
        "type" : "void()",
        "endline" : 4524
       },
       {
        "name" : "__unittestL4526_454",
        "kind" : "function",
        "line" : 4526,
        "endline" : 4544
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\n       Sets the number of elements in the container to $(D\n       newSize). If $(D newSize) is greater than $(D length), the\n       added elements are added to the container and initialized with\n       $(D ElementType.init).\n\n       Complexity: $(BIGOH abs(n - newLength))\n\n       Postcondition: $(D _length == newLength)\n     \n",
        "line" : 4544,
        "type" : "void(ulong newLength)",
        "parameters" : [
         {
          "name" : "newLength",
          "deco" : "m"
         }
        ],
        "endline" : 4551
       },
       {
        "name" : "__unittestL4553_455",
        "kind" : "function",
        "line" : 4553,
        "endline" : 4578
       },
       {
        "name" : "insert",
        "kind" : "alias",
        "comment" : "\n       Inserts $(D stuff) in the container. $(D stuff) can be a value\n       convertible to $(D ElementType) or a range of objects\n       convertible to $(D ElementType).\n\n       The $(D stable) version guarantees that ranges iterating over\n       the container are never invalidated. Client code that counts on\n       non-invalidating insertion should use $(D stableInsert).\n\n       Returns: The number of elements added.\n\n       Complexity: $(BIGOH m * log(n)), where $(D m) is the number of\n       elements in $(D stuff)\n     \n",
        "line" : 4578,
        "type" : "insertBack"
       },
       {
        "name" : "stableInsert",
        "kind" : "alias",
        "comment" : "ditto\n",
        "line" : 4580,
        "type" : "insertBack"
       },
       {
        "name" : "linearInsert",
        "kind" : "alias",
        "comment" : "\n       Same as $(D insert(stuff)) and $(D stableInsert(stuff))\n       respectively, but relax the complexity constraint to linear.\n     \n",
        "line" : 4586,
        "type" : "insertBack"
       },
       {
        "name" : "stableLinearInsert",
        "kind" : "alias",
        "comment" : "ditto\n",
        "line" : 4588,
        "type" : "insertBack"
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\n       Picks one value in the container, removes it from the\n       container, and returns it. The stable version behaves the same,\n       but guarantees that ranges iterating over the container are\n       never invalidated.\n\n       Precondition: $(D !empty)\n\n       Returns: The element removed.\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 4602,
        "type" : "T()",
        "endline" : 4607
       },
       {
        "name" : "stableRemoveAny",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4609,
        "type" : "removeAny"
       },
       {
        "name" : "__unittestL4611_456",
        "kind" : "function",
        "line" : 4611,
        "endline" : 4634
       },
       {
        "kind" : "template",
        "comment" : "\n       Inserts $(D value) to the back of the container. $(D stuff) can\n       be a value convertible to $(D ElementType) or a range of\n       objects convertible to $(D ElementType). The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: The number of elements inserted\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 4634,
        "name" : "insertBack",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBack",
          "kind" : "function",
          "comment" : "\n       Inserts $(D value) to the back of the container. $(D stuff) can\n       be a value convertible to $(D ElementType) or a range of\n       objects convertible to $(D ElementType). The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: The number of elements inserted\n\n       Complexity: $(BIGOH log(n))\n     \n",
          "line" : 4634,
          "type" : "ulong(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 4657
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Ditto\n",
        "line" : 4659,
        "name" : "insertBack",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBack",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 4659,
          "type" : "ulong(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 4670
         }
        ]
       },
       {
        "name" : "stableInsertBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4672,
        "type" : "insertBack"
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : "\n       Removes the value at the front or back of the container. The\n       stable version behaves the same, but guarantees that ranges\n       iterating over the container are never invalidated. The\n       optional parameter $(D howMany) instructs removal of that many\n       elements. If $(D howMany > n), all elements are removed and no\n       exception is thrown.\n\n       Precondition: $(D !empty)\n\n       Complexity: $(BIGOH log(n)).\n     \n",
        "line" : 4686,
        "type" : "void()",
        "endline" : 4700
       },
       {
        "name" : "stableRemoveBack",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4702,
        "type" : "removeBack"
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : "\n       Removes $(D howMany) values at the front or back of the\n       container. Unlike the unparameterized versions above, these\n       functions do not throw if they could not remove $(D howMany)\n       elements. Instead, if $(D howMany > n), all elements are\n       removed. The returned value is the effective number of elements\n       removed. The stable version behaves the same, but guarantees\n       that ranges iterating over the container are never invalidated.\n\n       Returns: The number of elements removed\n\n       Complexity: $(BIGOH howMany * log(n)).\n     \n ditto\n",
        "line" : 4718,
        "type" : "ulong(ulong howMany)",
        "parameters" : [
         {
          "name" : "howMany",
          "deco" : "m"
         }
        ],
        "endline" : 4730
       },
       {
        "name" : "__unittestL4732_457",
        "kind" : "function",
        "line" : 4732,
        "endline" : 4757
       },
       {
        "kind" : "template",
        "comment" : "\n       Inserts $(D stuff) before, after, or instead range $(D r),\n       which must be a valid range previously extracted from this\n       container. $(D stuff) can be a value convertible to $(D\n       ElementType) or a range of objects convertible to $(D\n       ElementType). The stable version behaves the same, but\n       guarantees that ranges iterating over the container are never\n       invalidated.\n\n       Returns: The number of values inserted.\n\n       Complexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
        "line" : 4757,
        "name" : "insertBefore",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertBefore",
          "kind" : "function",
          "comment" : "\n       Inserts $(D stuff) before, after, or instead range $(D r),\n       which must be a valid range previously extracted from this\n       container. $(D stuff) can be a value convertible to $(D\n       ElementType) or a range of objects convertible to $(D\n       ElementType). The stable version behaves the same, but\n       guarantees that ranges iterating over the container are never\n       invalidated.\n\n       Returns: The number of values inserted.\n\n       Complexity: $(BIGOH n + m), where $(D m) is the length of $(D stuff)\n     \n",
          "line" : 4757,
          "type" : "ulong(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 4766
         }
        ]
       },
       {
        "name" : "stableInsertBefore",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4768,
        "type" : "insertBefore"
       },
       {
        "name" : "__unittestL4770_458",
        "kind" : "function",
        "line" : 4770,
        "endline" : 4784
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 4784,
        "name" : "insertAfter",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "insertAfter",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 4784,
          "type" : "ulong(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 4793
         }
        ]
       },
       {
        "name" : "stableInsertAfter",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4795,
        "type" : "insertAfter"
       },
       {
        "name" : "__unittestL4797_459",
        "kind" : "function",
        "line" : 4797,
        "endline" : 4806
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 4806,
        "name" : "replace",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "replace",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 4806,
          "type" : "size_t(Range r, Stuff stuff)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "Range"
           },
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 4821
         }
        ]
       },
       {
        "name" : "stableReplace",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4823,
        "type" : "replace"
       },
       {
        "name" : "__unittestL4825_460",
        "kind" : "function",
        "line" : 4825,
        "endline" : 4845
       },
       {
        "name" : "linearRemove",
        "kind" : "function",
        "comment" : "\n       Removes all elements belonging to $(D r), which must be a range\n       obtained originally from this container. The stable version\n       behaves the same, but guarantees that ranges iterating over the\n       container are never invalidated.\n\n       Returns: A range spanning the remaining elements in the container that\n       initially were right after $(D r).\n\n       Complexity: $(BIGOH n)\n     \n",
        "line" : 4845,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 4850
       },
       {
        "name" : "stableLinearRemove",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 4852,
        "type" : "linearRemove"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4855_461",
    "kind" : "function",
    "line" : 4855,
    "endline" : 4873
   },
   {
    "kind" : "template",
    "line" : 4874,
    "name" : "RBNode",
    "parameters" : [
     {
      "name" : "V",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RBNode",
      "kind" : "struct",
      "line" : 4874,
      "members" : [
       {
        "name" : "Node",
        "kind" : "alias",
        "line" : 4878,
        "type" : "RBNode*"
       },
       {
        "name" : "_left",
        "kind" : "variable",
        "line" : 4880,
        "type" : "Node"
       },
       {
        "name" : "_right",
        "kind" : "variable",
        "line" : 4881,
        "type" : "Node"
       },
       {
        "name" : "_parent",
        "kind" : "variable",
        "line" : 4882,
        "type" : "Node"
       },
       {
        "name" : "value",
        "kind" : "variable",
        "comment" : "\n The value held by this node\n     \n",
        "line" : 4887,
        "type" : "V"
       },
       {
        "name" : "Color",
        "kind" : "enum",
        "comment" : "\n Enumeration determining what color the node is.  Null nodes are assumed\n to be black.\n     \n",
        "line" : 4893,
        "baseDeco" : "g",
        "members" : [
         {
          "name" : "Red",
          "kind" : "enum member",
          "line" : 4895
         },
         {
          "name" : "Black",
          "kind" : "enum member",
          "line" : 4896
         }
        ]
       },
       {
        "name" : "color",
        "kind" : "variable",
        "comment" : "\n The color of the node.\n     \n",
        "line" : 4902,
        "type" : "Color"
       },
       {
        "name" : "left",
        "kind" : "function",
        "comment" : "\n Get the left child\n     \n",
        "line" : 4907,
        "type" : "Node()",
        "endline" : 4910
       },
       {
        "name" : "right",
        "kind" : "function",
        "comment" : "\n Get the right child\n     \n",
        "line" : 4915,
        "type" : "Node()",
        "endline" : 4918
       },
       {
        "name" : "parent",
        "kind" : "function",
        "comment" : "\n Get the parent\n     \n",
        "line" : 4923,
        "type" : "Node()",
        "endline" : 4926
       },
       {
        "name" : "left",
        "kind" : "function",
        "comment" : "\n Set the left child.  Also updates the new child's parent node.  This\n does not update the previous child.\n\n Returns newNode\n     \n",
        "line" : 4934,
        "type" : "Node(Node newNode)",
        "parameters" : [
         {
          "name" : "newNode",
          "type" : "Node"
         }
        ],
        "endline" : 4940
       },
       {
        "name" : "right",
        "kind" : "function",
        "comment" : "\n Set the right child.  Also updates the new child's parent node.  This\n does not update the previous child.\n\n Returns newNode\n     \n",
        "line" : 4948,
        "type" : "Node(Node newNode)",
        "parameters" : [
         {
          "name" : "newNode",
          "type" : "Node"
         }
        ],
        "endline" : 4954
       },
       {
        "name" : "rotateR",
        "kind" : "function",
        "comment" : "\n Rotate right.  This performs the following operations:\n  - The left child becomes the parent of this node.\n  - This node becomes the new parent's right child.\n  - The old right child of the new parent becomes the left child of this\n    node.\n     \n",
        "line" : 4976,
        "type" : "Node()",
        "endline" : 4997
       },
       {
        "name" : "rotateL",
        "kind" : "function",
        "comment" : "\n Rotate left.  This performs the following operations:\n  - The right child becomes the parent of this node.\n  - This node becomes the new parent's left child.\n  - The old left child of the new parent becomes the right child of this\n    node.\n     \n",
        "line" : 5019,
        "type" : "Node()",
        "endline" : 5039
       },
       {
        "name" : "isLeftNode",
        "kind" : "function",
        "comment" : "\n Returns true if this node is a left child.\n\n Note that this should always return a value because the root has a\n parent which is the marker node.\n     \n",
        "line" : 5048,
        "type" : "const bool()",
        "endline" : 5056
       },
       {
        "name" : "setColor",
        "kind" : "function",
        "comment" : "\n Set the color of the node after it is inserted.  This performs an\n update to the whole tree, possibly rotating nodes to keep the Red-Black\n properties correct.  This is an O(lg(n)) operation, where n is the\n number of nodes in the tree.\n\n end is the marker node, which is the parent of the topmost valid node.\n     \n",
        "line" : 5066,
        "type" : "void(Node end)",
        "parameters" : [
         {
          "name" : "end",
          "type" : "Node"
         }
        ],
        "endline" : 5158
       },
       {
        "name" : "remove",
        "kind" : "function",
        "comment" : "\n Remove this node from the tree.  The 'end' node is used as the marker\n which is root's parent.  Note that this cannot be null!\n\n Returns the next highest valued node in the tree after this one, or end\n if this was the highest-valued node.\n     \n",
        "line" : 5167,
        "type" : "Node(Node end)",
        "parameters" : [
         {
          "name" : "end",
          "type" : "Node"
         }
        ],
        "endline" : 5347
       },
       {
        "name" : "leftmost",
        "kind" : "function",
        "comment" : "\n Return the leftmost descendant of this node.\n     \n",
        "line" : 5352,
        "type" : "Node()",
        "endline" : 5358
       },
       {
        "name" : "rightmost",
        "kind" : "function",
        "comment" : "\n Return the rightmost descendant of this node\n     \n",
        "line" : 5363,
        "type" : "Node()",
        "endline" : 5369
       },
       {
        "name" : "next",
        "kind" : "function",
        "comment" : "\n Returns the next valued node in the tree.\n\n You should never call this on the marker node, as it is assumed that\n there is a valid next node.\n     \n",
        "line" : 5377,
        "type" : "Node()",
        "endline" : 5388
       },
       {
        "name" : "prev",
        "kind" : "function",
        "comment" : "\n Returns the previous valued node in the tree.\n\n You should never call this on the leftmost node of the tree as it is\n assumed that there is a valid previous node.\n     \n",
        "line" : 5396,
        "type" : "Node()",
        "endline" : 5407
       },
       {
        "name" : "dup",
        "kind" : "function",
        "line" : 5409,
        "type" : "Node(scope Node delegate(V v) alloc)",
        "parameters" : [
         {
          "name" : "alloc",
          "type" : "Node delegate(V v)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 5424
       },
       {
        "name" : "dup",
        "kind" : "function",
        "line" : 5426,
        "type" : "Node()",
        "endline" : 5436
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Implementation of a $(LUCKY red-black tree) container.\n\n All inserts, removes, searches, and any function in general has complexity\n of $(BIGOH lg(n)).\n\n To use a different comparison than $(D \"a < b\"), pass a different operator string\n that can be used by $(XREF functional, binaryFun), or pass in a\n function, delegate, functor, or any type where $(D less(a, b)) results in a $(D bool)\n value.\n\n Note that less should produce a strict ordering.  That is, for two unequal\n elements $(D a) and $(D b), $(D less(a, b) == !less(b, a)). $(D less(a, a)) should\n always equal $(D false).\n\n If $(D allowDuplicates) is set to $(D true), then inserting the same element more than\n once continues to add more elements.  If it is $(D false), duplicate elements are\n ignored on insertion.  If duplicates are allowed, then new elements are\n inserted after all existing duplicate elements.\n \n",
    "line" : 5461,
    "name" : "RedBlackTree",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "less",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "allowDuplicates",
      "kind" : "value",
      "deco" : "b",
      "defaultValue" : "false"
     }
    ],
    "members" : [
     {
      "name" : "RedBlackTree",
      "kind" : "class",
      "line" : 5461,
      "members" : [
       {
        "name" : "_less",
        "kind" : "alias",
        "line" : 5462,
        "type" : "binaryFun!(less)"
       },
       {
        "name" : "_add",
        "kind" : "function",
        "line" : 5470,
        "storageClass" : [
         "auto"
        ],
        "type" : "(Elem n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "Elem"
         }
        ],
        "endline" : 5543
       },
       {
        "name" : "Elem",
        "kind" : "alias",
        "comment" : "\n Element type for the tree\n      \n",
        "line" : 5572,
        "type" : "T"
       },
       {
        "name" : "Node",
        "kind" : "alias",
        "line" : 5575,
        "type" : "RBNode!(Elem).Node"
       },
       {
        "name" : "_end",
        "kind" : "variable",
        "line" : 5577,
        "type" : "Node"
       },
       {
        "name" : "_begin",
        "kind" : "variable",
        "line" : 5578,
        "type" : "Node"
       },
       {
        "name" : "_length",
        "kind" : "variable",
        "line" : 5579,
        "type" : "size_t"
       },
       {
        "name" : "_setup",
        "kind" : "function",
        "line" : 5581,
        "type" : "void()",
        "endline" : 5585
       },
       {
        "name" : "allocate",
        "kind" : "function",
        "line" : 5587,
        "type" : "Node()",
        "endline" : 5590
       },
       {
        "name" : "allocate",
        "kind" : "function",
        "line" : 5592,
        "type" : "Node(Elem v)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "Elem"
         }
        ],
        "endline" : 5597
       },
       {
        "name" : "Range",
        "kind" : "struct",
        "comment" : "\n The range type for $(D RedBlackTree)\n     \n",
        "line" : 5603,
        "members" : [
         {
          "name" : "_begin",
          "kind" : "variable",
          "line" : 5604,
          "type" : "Node"
         },
         {
          "name" : "_end",
          "kind" : "variable",
          "line" : 5605,
          "type" : "Node"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 5607,
          "type" : "(Node b, Node e)",
          "parameters" : [
           {
            "name" : "b",
            "type" : "Node"
           },
           {
            "name" : "e",
            "type" : "Node"
           }
          ],
          "endline" : 5611
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : "\n Returns $(D true) if the range is _empty\n         \n",
          "line" : 5616,
          "type" : "const bool()",
          "endline" : 5619
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : "\n Returns the first element in the range\n         \n",
          "line" : 5624,
          "type" : "Elem()",
          "endline" : 5627
         },
         {
          "name" : "back",
          "kind" : "function",
          "comment" : "\n Returns the last element in the range\n         \n",
          "line" : 5632,
          "type" : "Elem()",
          "endline" : 5635
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : "\n pop the front element from the range\n\n complexity: amortized $(BIGOH 1)\n         \n",
          "line" : 5642,
          "type" : "void()",
          "endline" : 5645
         },
         {
          "name" : "popBack",
          "kind" : "function",
          "comment" : "\n pop the back element from the range\n\n complexity: amortized $(BIGOH 1)\n         \n",
          "line" : 5652,
          "type" : "void()",
          "endline" : 5655
         },
         {
          "name" : "save",
          "kind" : "function",
          "comment" : "\n Trivial _save implementation, needed for $(D isForwardRange).\n         \n",
          "line" : 5660,
          "type" : "Range()",
          "endline" : 5663
         }
        ]
       },
       {
        "name" : "_find",
        "kind" : "function",
        "line" : 5691,
        "type" : "Node(Elem e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "Elem"
         }
        ],
        "endline" : 5726
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n Check if any elements exist in the container.  Returns $(D false) if at least\n one element exists.\n     \n",
        "line" : 5732,
        "type" : "bool()",
        "endline" : 5735
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\n        Returns the number of elements in the container.\n\n        Complexity: $(BIGOH 1).\n    \n",
        "line" : 5742,
        "type" : "size_t()",
        "endline" : 5745
       },
       {
        "name" : "dup",
        "kind" : "function",
        "comment" : "\n Duplicate this container.  The resulting container contains a shallow\n copy of the elements.\n\n Complexity: $(BIGOH n)\n     \n",
        "line" : 5753,
        "type" : "RedBlackTree()",
        "endline" : 5756
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\n Fetch a range that spans all the elements in the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5775,
        "type" : "Range()",
        "endline" : 5778
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n The front element in the container\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5785,
        "type" : "Elem()",
        "endline" : 5788
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : "\n The last element in the container\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5795,
        "type" : "Elem()",
        "endline" : 5798
       },
       {
        "kind" : "template",
        "comment" : "\n        $(D in) operator. Check to see if the given element exists in the\n        container.\n\n       Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5806,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "comment" : "\n        $(D in) operator. Check to see if the given element exists in the\n        container.\n\n       Complexity: $(BIGOH log(n))\n     \n",
          "line" : 5806,
          "type" : "bool(Elem e)",
          "parameters" : [
           {
            "name" : "e",
            "type" : "Elem"
           }
          ],
          "endline" : 5809
         }
        ]
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\n Compares two trees for equality.\n\n Complexity: $(BIGOH n*log(n))\n     \n",
        "line" : 5823,
        "type" : "bool(Object rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "Object"
         }
        ],
        "endline" : 5836
       },
       {
        "name" : "clear",
        "kind" : "function",
        "comment" : "\n Removes all elements from the container.\n\n Complexity: $(BIGOH 1)\n     \n",
        "line" : 5857,
        "type" : "void()",
        "endline" : 5862
       },
       {
        "kind" : "template",
        "comment" : "\n Insert a single element in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5878,
        "name" : "stableInsert",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableInsert",
          "kind" : "function",
          "comment" : "\n Insert a single element in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
          "line" : 5878,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 5889
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n Insert a range of elements in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH m * log(n))\n     \n",
        "line" : 5897,
        "name" : "stableInsert",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "stableInsert",
          "kind" : "function",
          "comment" : "\n Insert a range of elements in the container.  Note that this does not\n invalidate any ranges currently iterating the container.\n\n Complexity: $(BIGOH m * log(n))\n     \n",
          "line" : 5897,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 5917
         }
        ]
       },
       {
        "name" : "insert",
        "kind" : "alias",
        "comment" : " ditto\n",
        "line" : 5920,
        "type" : "stableInsert"
       },
       {
        "name" : "removeAny",
        "kind" : "function",
        "comment" : "\n Remove an element from the container and return its value.\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5958,
        "type" : "Elem()",
        "endline" : 5968
       },
       {
        "name" : "removeFront",
        "kind" : "function",
        "comment" : "\n Remove the front element from the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 5987,
        "type" : "void()",
        "endline" : 5994
       },
       {
        "name" : "removeBack",
        "kind" : "function",
        "comment" : "\n Remove the back element from the container.\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 6001,
        "type" : "void()",
        "endline" : 6012
       },
       {
        "name" : "remove",
        "kind" : "function",
        "comment" : "\n        Removes the given range from the container.\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n     \n",
        "line" : 6039,
        "type" : "Range(Range r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 6053
       },
       {
        "name" : "remove",
        "kind" : "function",
        "comment" : "\n        Removes the given $(D Take!Range) from the container\n\n        Returns: A range containing all of the elements that were after the\n                 given range.\n\n        Complexity: $(BIGOH m * log(n)) (where m is the number of elements in\n                    the range)\n     \n",
        "line" : 6082,
        "type" : "Range(Take!(Range) r)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Take!(Range)"
         }
        ],
        "endline" : 6098
       },
       {
        "kind" : "template",
        "comment" : "\n       Removes elements from the container that are equal to the given values\n       according to the less comparator. One element is removed for each value\n       given which is in the container. If $(D allowDuplicates) is true,\n       duplicates are removed only if duplicate values are given.\n\n       Returns: The number of elements removed.\n\n       Complexity: $(BIGOH m log(n)) (where m is the number of elements to remove)\n\n        Examples:\n--------------------\nauto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);\nrbt.removeKey(1, 4, 7);\nassert(std.algorithm.equal(rbt[], [0, 1, 1, 5]));\nrbt.removeKey(1, 1, 0);\nassert(std.algorithm.equal(rbt[], [5]));\n--------------------\n      \n",
        "line" : 6143,
        "name" : "removeKey",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "removeKey",
          "kind" : "function",
          "comment" : "\n       Removes elements from the container that are equal to the given values\n       according to the less comparator. One element is removed for each value\n       given which is in the container. If $(D allowDuplicates) is true,\n       duplicates are removed only if duplicate values are given.\n\n       Returns: The number of elements removed.\n\n       Complexity: $(BIGOH m log(n)) (where m is the number of elements to remove)\n\n        Examples:\n--------------------\nauto rbt = redBlackTree!true(0, 1, 1, 1, 4, 5, 7);\nrbt.removeKey(1, 4, 7);\nassert(std.algorithm.equal(rbt[], [0, 1, 1, 5]));\nrbt.removeKey(1, 1, 0);\nassert(std.algorithm.equal(rbt[], [5]));\n--------------------\n      \n",
          "line" : 6143,
          "type" : "size_t(U elems)",
          "parameters" : [
           {
            "name" : "elems",
            "type" : "U"
           }
          ],
          "endline" : 6152
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Ditto \n",
        "line" : 6155,
        "name" : "removeKey",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "removeKey",
          "kind" : "function",
          "comment" : " Ditto \n",
          "line" : 6155,
          "type" : "size_t(U[] elems)",
          "parameters" : [
           {
            "name" : "elems",
            "type" : "U[]"
           }
          ],
          "endline" : 6174
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Ditto \n",
        "line" : 6177,
        "name" : "removeKey",
        "parameters" : [
         {
          "name" : "Stuff",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "removeKey",
          "kind" : "function",
          "comment" : " Ditto \n",
          "line" : 6177,
          "type" : "size_t(Stuff stuff)",
          "parameters" : [
           {
            "name" : "stuff",
            "type" : "Stuff"
           }
          ],
          "endline" : 6185
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 6188,
        "name" : "isImplicitlyConvertibleToElem",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "isImplicitlyConvertibleToElem",
          "kind" : "variable",
          "line" : 6190,
          "storageClass" : [
           "enum"
          ],
          "init" : "isImplicitlyConvertible!(U, Elem)"
         }
        ]
       },
       {
        "name" : "_firstGreater",
        "kind" : "function",
        "line" : 6237,
        "type" : "Node(Elem e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "Elem"
         }
        ],
        "endline" : 6253
       },
       {
        "name" : "_firstGreaterEqual",
        "kind" : "function",
        "line" : 6256,
        "type" : "Node(Elem e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "Elem"
         }
        ],
        "endline" : 6273
       },
       {
        "name" : "upperBound",
        "kind" : "function",
        "comment" : "\n Get a range from the container with all elements that are > e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 6281,
        "type" : "Range(Elem e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "Elem"
         }
        ],
        "endline" : 6284
       },
       {
        "name" : "lowerBound",
        "kind" : "function",
        "comment" : "\n Get a range from the container with all elements that are < e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 6292,
        "type" : "Range(Elem e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "Elem"
         }
        ],
        "endline" : 6295
       },
       {
        "name" : "equalRange",
        "kind" : "function",
        "comment" : "\n Get a range from the container with all elements that are == e according\n to the less comparator\n\n Complexity: $(BIGOH log(n))\n     \n",
        "line" : 6303,
        "type" : "Range(Elem e)",
        "parameters" : [
         {
          "name" : "e",
          "type" : "Elem"
         }
        ],
        "endline" : 6319
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : " \n",
        "line" : 6451,
        "type" : "()",
        "endline" : 6454
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n       Constructor.  Pass in an array of elements, or individual elements to\n       initialize the tree with.\n     \n",
        "line" : 6460,
        "type" : "(Elem[] elems...)",
        "parameters" : [
         {
          "name" : "elems",
          "type" : "Elem[]"
         }
        ],
        "endline" : 6464
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 6466,
        "type" : "(Node end, size_t length)",
        "parameters" : [
         {
          "name" : "end",
          "type" : "Node"
         },
         {
          "name" : "length",
          "type" : "size_t"
         }
        ],
        "endline" : 6471
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL6475_475",
    "kind" : "function",
    "line" : 6475,
    "endline" : 6485
   },
   {
    "name" : "__unittestL6485_476",
    "kind" : "function",
    "line" : 6485,
    "endline" : 6514
   },
   {
    "name" : "__unittestL6514_477",
    "kind" : "function",
    "line" : 6514,
    "endline" : 6547
   },
   {
    "kind" : "template",
    "comment" : "\n    Convenience function for creating a $(D RedBlackTree!E) from a list of\n    values.\n\n        Examples:\n--------------------\nauto rbt1 = redBlackTree(0, 1, 5, 7);\nauto rbt2 = redBlackTree!string(\"hello\", \"world\");\nauto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);\nauto rbt4 = redBlackTree!\"a > b\"(0, 1, 5, 7);\nauto rbt5 = redBlackTree!(\"a > b\", true)(0.1, 1.3, 5.9, 7.2, 5.9);\n--------------------\n  \n",
    "line" : 6547,
    "name" : "redBlackTree",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "redBlackTree",
      "kind" : "function",
      "comment" : "\n    Convenience function for creating a $(D RedBlackTree!E) from a list of\n    values.\n\n        Examples:\n--------------------\nauto rbt1 = redBlackTree(0, 1, 5, 7);\nauto rbt2 = redBlackTree!string(\"hello\", \"world\");\nauto rbt3 = redBlackTree!true(0, 1, 5, 7, 5);\nauto rbt4 = redBlackTree!\"a > b\"(0, 1, 5, 7);\nauto rbt5 = redBlackTree!(\"a > b\", true)(0.1, 1.3, 5.9, 7.2, 5.9);\n--------------------\n  \n",
      "line" : 6547,
      "storageClass" : [
       "auto"
      ],
      "type" : "(E[] elems...)",
      "parameters" : [
       {
        "name" : "elems",
        "type" : "E[]"
       }
      ],
      "endline" : 6550
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 6553,
    "name" : "redBlackTree",
    "parameters" : [
     {
      "name" : "allowDuplicates",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "redBlackTree",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 6553,
      "storageClass" : [
       "auto"
      ],
      "type" : "(E[] elems...)",
      "parameters" : [
       {
        "name" : "elems",
        "type" : "E[]"
       }
      ],
      "endline" : 6556
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 6559,
    "name" : "redBlackTree",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "redBlackTree",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 6559,
      "storageClass" : [
       "auto"
      ],
      "type" : "(E[] elems...)",
      "parameters" : [
       {
        "name" : "elems",
        "type" : "E[]"
       }
      ],
      "endline" : 6562
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 6565,
    "name" : "redBlackTree",
    "parameters" : [
     {
      "name" : "less",
      "kind" : "alias"
     },
     {
      "name" : "allowDuplicates",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "redBlackTree",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 6565,
      "storageClass" : [
       "auto"
      ],
      "type" : "(E[] elems...)",
      "parameters" : [
       {
        "name" : "elems",
        "type" : "E[]"
       }
      ],
      "endline" : 6572
     }
    ]
   },
   {
    "name" : "__unittestL6575_478",
    "kind" : "function",
    "line" : 6575,
    "endline" : 6585
   },
   {
    "name" : "__unittestL6585_482",
    "kind" : "function",
    "line" : 6585,
    "endline" : 6592
   },
   {
    "name" : "__unittestL6592_483",
    "kind" : "function",
    "line" : 6592,
    "endline" : 6611
   },
   {
    "name" : "__unittestL6615_484",
    "kind" : "function",
    "line" : 6615,
    "endline" : 6619
   }
  ]
 },
 {
  "name" : "std.conv",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/conv.d",
  "comment" : "\nA one-stop shop for converting values from one type to another.\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Shin Fujishiro,\n           Adam D. Ruppe,\n           Kenji Hara\n\nSource:    $(PHOBOSSRC std/_conv.d)\n",
  "members" : [
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 20,
    "protection" : "private",
    "selective" : [
     "ldexp"
    ]
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.uni",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "ConvException",
    "kind" : "class",
    "comment" : "\n Thrown on conversion errors.\n \n",
    "line" : 34,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 36,
      "deco" : "FAyaAyamZC3std4conv13ConvException",
      "originalType" : "(string s, string fn = __FILE__, size_t ln = __LINE__)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aya"
       },
       {
        "name" : "fn",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 39
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 42,
    "name" : "convError_unexpected",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "convError_unexpected",
      "kind" : "function",
      "line" : 42,
      "type" : "string(S source)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "S"
       }
      ],
      "endline" : 44
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 46,
    "name" : "convError",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "convError",
      "kind" : "function",
      "line" : 46,
      "type" : "void(S source, string fn = __FILE__, size_t ln = __LINE__)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "S"
       },
       {
        "name" : "fn",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 52
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 54,
    "name" : "convError",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "convError",
      "kind" : "function",
      "line" : 54,
      "type" : "void(S source, int radix, string fn = __FILE__, size_t ln = __LINE__)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "S"
       },
       {
        "name" : "radix",
        "deco" : "i"
       },
       {
        "name" : "fn",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 61
     }
    ]
   },
   {
    "name" : "parseError",
    "kind" : "function",
    "protection" : "private",
    "line" : 63,
    "deco" : "FLAyaAyamZv",
    "originalType" : "void(lazy string msg, string fn = __FILE__, size_t ln = __LINE__)",
    "parameters" : [
     {
      "name" : "msg",
      "deco" : "Aya",
      "storageClass" : [
       "lazy"
      ]
     },
     {
      "name" : "fn",
      "deco" : "Aya",
      "default" : "__FILE__"
     },
     {
      "name" : "ln",
      "deco" : "m",
      "default" : "cast(ulong)__LINE__"
     }
    ],
    "endline" : 66
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 68,
    "name" : "parseCheck",
    "parameters" : [
     {
      "name" : "source",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "parseCheck",
      "kind" : "function",
      "line" : 68,
      "type" : "void(dchar c, string fn = __FILE__, size_t ln = __LINE__)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "fn",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 74
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 78,
    "name" : "isImaginary",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isImaginary",
      "kind" : "variable",
      "line" : 80,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "staticIndexOf!(Unqual!(T), ifloat, idouble, ireal) >= 0"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 83,
    "name" : "isComplex",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isComplex",
      "kind" : "variable",
      "line" : 85,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "staticIndexOf!(Unqual!(T), cfloat, cdouble, creal) >= 0"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 88,
    "name" : "isNarrowInteger",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isNarrowInteger",
      "kind" : "variable",
      "line" : 90,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "staticIndexOf!(Unqual!(T), byte, ubyte, short, ushort) >= 0"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 94,
    "name" : "toStr",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toStr",
      "kind" : "function",
      "line" : 94,
      "type" : "T(S src)",
      "parameters" : [
       {
        "name" : "src",
        "type" : "S"
       }
      ],
      "endline" : 101
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 103,
    "name" : "isExactSomeString",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isExactSomeString",
      "kind" : "variable",
      "line" : 105,
      "storageClass" : [
       "enum"
      ],
      "init" : "isSomeString!(T) && !is(T == enum)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 108,
    "name" : "isEnumStrToStr",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isEnumStrToStr",
      "kind" : "variable",
      "line" : 111,
      "storageClass" : [
       "enum"
      ],
      "init" : "isImplicitlyConvertible!(S, T) && is(S == enum) && isExactSomeString!(T)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 113,
    "name" : "isNullToStr",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isNullToStr",
      "kind" : "variable",
      "line" : 116,
      "storageClass" : [
       "enum"
      ],
      "init" : "isImplicitlyConvertible!(S, T) && is(S == typeof(null)) && isExactSomeString!(T)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 119,
    "name" : "isRawStaticArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "isRawStaticArray",
      "kind" : "variable",
      "line" : 127,
      "storageClass" : [
       "enum"
      ],
      "init" : "A.length == 0 && isStaticArray!(T) && !is(T == class) && !is(T == interface) && !is(T == struct) && !is(T == union)"
     }
    ]
   },
   {
    "name" : "ConvOverflowException",
    "kind" : "class",
    "comment" : "\n Thrown on conversion overflow errors.\n \n",
    "line" : 134,
    "base" : "ConvException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 136,
      "deco" : "FAyaAyamZC3std4conv21ConvOverflowException",
      "originalType" : "(string s, string fn = __FILE__, size_t ln = __LINE__)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aya"
       },
       {
        "name" : "fn",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 139
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n\nThe $(D_PARAM to) family of functions converts a value from type\n$(D_PARAM Source) to type $(D_PARAM Target). The source type is\ndeduced and the target type must be specified, for example the\nexpression $(D_PARAM to!int(42.0)) converts the number 42 from\n$(D_PARAM double) to $(D_PARAM int). The conversion is \"safe\", i.e.,\nit checks for overflow; $(D_PARAM to!int(4.2e10)) would throw the\n$(D_PARAM ConvOverflowException) exception. Overflow checks are only\ninserted when necessary, e.g., $(D_PARAM to!double(42)) does not do\nany checking because any int fits in a double.\n\nConverting a value to its own type (useful mostly for generic code)\nsimply returns its argument.\n\nExample:\n-------------------------\nint a = 42;\nauto b = to!int(a); // b is int with value 42\nauto c = to!double(3.14); // c is double with value 3.14\n-------------------------\n\nConverting among numeric types is a safe way to cast them around.\n\nConversions from floating-point types to integral types allow loss of\nprecision (the fractional part of a floating-point number). The\nconversion is truncating towards zero, the same way a cast would\ntruncate. (To round a floating point value when casting to an\nintegral, use $(D_PARAM roundTo).)\n\nExamples:\n-------------------------\nint a = 420;\nauto b = to!long(a); // same as long b = a;\nauto c = to!byte(a / 10); // fine, c = 42\nauto d = to!byte(a); // throw ConvOverflowException\ndouble e = 4.2e6;\nauto f = to!int(e); // f == 4200000\ne = -3.14;\nauto g = to!uint(e); // fails: floating-to-integral negative overflow\ne = 3.14;\nauto h = to!uint(e); // h = 3\ne = 3.99;\nh = to!uint(a); // h = 3\ne = -3.99;\nf = to!int(a); // f = -3\n-------------------------\n\nConversions from integral types to floating-point types always\nsucceed, but might lose accuracy. The largest integers with a\npredecessor representable in floating-point format are 2^24-1 for\nfloat, 2^53-1 for double, and 2^64-1 for $(D_PARAM real) (when\n$(D_PARAM real) is 80-bit, e.g. on Intel machines).\n\nExample:\n-------------------------\nint a = 16_777_215; // 2^24 - 1, largest proper integer representable as float\nassert(to!int(to!float(a)) == a);\nassert(to!int(to!float(-a)) == -a);\na += 2;\nassert(to!int(to!float(a)) == a); // fails!\n-------------------------\n\nConversions from string to numeric types differ from the C equivalents\n$(D_PARAM atoi()) and $(D_PARAM atol()) by checking for overflow and\nnot allowing whitespace.\n\nFor conversion of strings to signed types, the grammar recognized is:\n<pre>\n$(I Integer): $(I Sign UnsignedInteger)\n$(I UnsignedInteger)\n$(I Sign):\n    $(B +)\n    $(B -)\n</pre>\n\nFor conversion to unsigned types, the grammar recognized is:\n<pre>\n$(I UnsignedInteger):\n    $(I DecimalDigit)\n    $(I DecimalDigit) $(I UnsignedInteger)\n</pre>\n\nConverting an array to another array type works by converting each\nelement in turn. Associative arrays can be converted to associative\narrays as long as keys and values can in turn be converted.\n\nExample:\n-------------------------\nint[] a = ([1, 2, 3]).dup;\nauto b = to!(float[])(a);\nassert(b == [1.0f, 2, 3]);\nstring str = \"1 2 3 4 5 6\";\nauto numbers = to!(double[])(split(str));\nassert(numbers == [1.0, 2, 3, 4, 5, 6]);\nint[string] c;\nc[\"a\"] = 1;\nc[\"b\"] = 2;\nauto d = to!(double[wstring])(c);\nassert(d[\"a\"w] == 1 && d[\"b\"w] == 2);\n-------------------------\n\nConversions operate transitively, meaning that they work on arrays and\nassociative arrays of any complexity:\n\n-------------------------\nint[string][double[int[]]] a;\n...\nauto b = to!(short[wstring][string[double[]]])(a);\n-------------------------\n\nThis conversion works because $(D_PARAM to!short) applies to an\n$(D_PARAM int), $(D_PARAM to!wstring) applies to a $(D_PARAM\nstring), $(D_PARAM to!string) applies to a $(D_PARAM double), and\n$(D_PARAM to!(double[])) applies to an $(D_PARAM int[]). The\nconversion might throw an exception because $(D_PARAM to!short)\nmight fail the range check.\n\nMacros: WIKI=Phobos/StdConv\n \n\n   Entry point that dispatches to the appropriate conversion\n   primitive. Client code normally calls $(D _to!TargetType(value))\n   (and not some variant of $(D toImpl)).\n \n",
    "line" : 268,
    "name" : "to",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 270,
      "name" : "to",
      "parameters" : [
       {
        "name" : "A",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "to",
        "kind" : "function",
        "line" : 270,
        "type" : "T(A args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "A"
         }
        ],
        "endline" : 274
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 277,
      "name" : "to",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "to",
        "kind" : "function",
        "line" : 277,
        "type" : "T(ref S arg)",
        "parameters" : [
         {
          "name" : "arg",
          "type" : "S",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 281
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL285_485",
    "kind" : "function",
    "line" : 285,
    "endline" : 294
   },
   {
    "name" : "__unittestL294_486",
    "kind" : "function",
    "line" : 294,
    "endline" : 301
   },
   {
    "name" : "__unittestL301_487",
    "kind" : "function",
    "line" : 301,
    "endline" : 329
   },
   {
    "kind" : "template",
    "comment" : "\nIf the source type is implicitly convertible to the target type, $(D\nto) simply performs the implicit conversion.\n \n",
    "line" : 329,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nIf the source type is implicitly convertible to the target type, $(D\nto) simply performs the implicit conversion.\n \n",
      "line" : 329,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 348
     }
    ]
   },
   {
    "name" : "__unittestL350_488",
    "kind" : "function",
    "line" : 350,
    "endline" : 357
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 357,
    "name" : "isSignedInt",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSignedInt",
      "kind" : "variable",
      "line" : 359,
      "storageClass" : [
       "enum"
      ],
      "init" : "isIntegral!(T) && isSigned!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL362_489",
    "kind" : "function",
    "line" : 362,
    "endline" : 371
   },
   {
    "name" : "__unittestL371_490",
    "kind" : "function",
    "line" : 371,
    "endline" : 442
   },
   {
    "kind" : "template",
    "line" : 442,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 442,
      "type" : "T(ref S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 446
     }
    ]
   },
   {
    "name" : "__unittestL448_491",
    "kind" : "function",
    "line" : 448,
    "endline" : 458
   },
   {
    "kind" : "template",
    "comment" : "\nWhen source type supports member template function opCast, is is used.\n",
    "line" : 458,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nWhen source type supports member template function opCast, is is used.\n",
      "line" : 458,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 463
     }
    ]
   },
   {
    "name" : "__unittestL465_492",
    "kind" : "function",
    "line" : 465,
    "endline" : 489
   },
   {
    "kind" : "template",
    "comment" : "\nWhen target type supports 'converting construction', it is used.\n$(UL $(LI If target type is struct, $(D T(value)) is used.)\n     $(LI If target type is class, $(D new T(value)) is used.))\n",
    "line" : 489,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nWhen target type supports 'converting construction', it is used.\n$(UL $(LI If target type is struct, $(D T(value)) is used.)\n     $(LI If target type is class, $(D new T(value)) is used.))\n",
      "line" : 489,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 494
     }
    ]
   },
   {
    "name" : "__unittestL497_493",
    "kind" : "function",
    "line" : 497,
    "endline" : 527
   },
   {
    "name" : "__unittestL527_494",
    "kind" : "function",
    "line" : 527,
    "endline" : 539
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 539,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 539,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 544
     }
    ]
   },
   {
    "name" : "__unittestL546_495",
    "kind" : "function",
    "line" : 546,
    "endline" : 577
   },
   {
    "name" : "__unittestL588_496",
    "kind" : "function",
    "line" : 588,
    "endline" : 611
   },
   {
    "kind" : "template",
    "comment" : "\nObject-to-object conversions by dynamic casting throw exception when the source is\nnon-null and the target is null.\n \n",
    "line" : 611,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nObject-to-object conversions by dynamic casting throw exception when the source is\nnon-null and the target is null.\n \n",
      "line" : 611,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 660
     }
    ]
   },
   {
    "name" : "__unittestL662_497",
    "kind" : "function",
    "line" : 662,
    "endline" : 676
   },
   {
    "name" : "__unittestL692_498",
    "kind" : "function",
    "line" : 692,
    "endline" : 772
   },
   {
    "kind" : "template",
    "comment" : "\nStringize conversion from all types is supported.\n$(UL\n  $(LI String _to string conversion works for any two string types having\n       ($(D char), $(D wchar), $(D dchar)) character widths and any\n       combination of qualifiers (mutable, $(D const), or $(D immutable)).)\n  $(LI Converts array (other than strings) to string.\n       Each element is converted by calling $(D to!T).)\n  $(LI Associative array to string conversion.\n       Each element is printed by calling $(D to!T).)\n  $(LI Object to string conversion calls $(D toString) against the object or\n       returns $(D \"null\") if the object is null.)\n  $(LI Struct to string conversion calls $(D toString) against the struct if\n       it is defined.)\n  $(LI For structs that do not define $(D toString), the conversion to string\n       produces the list of fields.)\n  $(LI Enumerated types are converted to strings as their symbolic names.)\n  $(LI Boolean values are printed as $(D \"true\") or $(D \"false\").)\n  $(LI $(D char), $(D wchar), $(D dchar) to a string type.)\n  $(LI Unsigned or signed integers to strings.\n       $(DL $(DT [special case])\n            $(DD Convert integral value to string in $(D_PARAM radix) radix.\n            radix must be a value from 2 to 36.\n            value is treated as a signed value only if radix is 10.\n            The characters A through Z are used to represent values 10 through 36.)))\n  $(LI All floating point types to all string types.)\n  $(LI Pointer to string conversions prints the pointer as a $(D size_t) value.\n       If pointer is $(D char*), treat it as C-style strings.))\n",
    "line" : 772,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nStringize conversion from all types is supported.\n$(UL\n  $(LI String _to string conversion works for any two string types having\n       ($(D char), $(D wchar), $(D dchar)) character widths and any\n       combination of qualifiers (mutable, $(D const), or $(D immutable)).)\n  $(LI Converts array (other than strings) to string.\n       Each element is converted by calling $(D to!T).)\n  $(LI Associative array to string conversion.\n       Each element is printed by calling $(D to!T).)\n  $(LI Object to string conversion calls $(D toString) against the object or\n       returns $(D \"null\") if the object is null.)\n  $(LI Struct to string conversion calls $(D toString) against the struct if\n       it is defined.)\n  $(LI For structs that do not define $(D toString), the conversion to string\n       produces the list of fields.)\n  $(LI Enumerated types are converted to strings as their symbolic names.)\n  $(LI Boolean values are printed as $(D \"true\") or $(D \"false\").)\n  $(LI $(D char), $(D wchar), $(D dchar) to a string type.)\n  $(LI Unsigned or signed integers to strings.\n       $(DL $(DT [special case])\n            $(DD Convert integral value to string in $(D_PARAM radix) radix.\n            radix must be a value from 2 to 36.\n            value is treated as a signed value only if radix is 10.\n            The characters A through Z are used to represent values 10 through 36.)))\n  $(LI All floating point types to all string types.)\n  $(LI Pointer to string conversions prints the pointer as a $(D size_t) value.\n       If pointer is $(D char*), treat it as C-style strings.))\n",
      "line" : 772,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 818
     }
    ]
   },
   {
    "name" : "__unittestL820_499",
    "kind" : "function",
    "line" : 820,
    "endline" : 861
   },
   {
    "name" : "__unittestL861_500",
    "kind" : "function",
    "line" : 861,
    "endline" : 874
   },
   {
    "name" : "__unittestL874_501",
    "kind" : "function",
    "line" : 874,
    "endline" : 884
   },
   {
    "name" : "__unittestL884_502",
    "kind" : "function",
    "line" : 884,
    "endline" : 895
   },
   {
    "name" : "__unittestL895_503",
    "kind" : "function",
    "line" : 895,
    "endline" : 925
   },
   {
    "name" : "__unittestL925_504",
    "kind" : "function",
    "line" : 925,
    "endline" : 964
   },
   {
    "name" : "__unittestL964_505",
    "kind" : "function",
    "line" : 964,
    "endline" : 977
   },
   {
    "name" : "__unittestL977_506",
    "kind" : "function",
    "line" : 977,
    "endline" : 984
   },
   {
    "name" : "__unittestL984_507",
    "kind" : "function",
    "line" : 984,
    "endline" : 1005
   },
   {
    "name" : "__unittestL1005_508",
    "kind" : "function",
    "line" : 1005,
    "endline" : 1035
   },
   {
    "name" : "__unittestL1035_509",
    "kind" : "function",
    "line" : 1035,
    "endline" : 1062
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1062,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1062,
      "type" : "T(S value, uint radix)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       },
       {
        "name" : "radix",
        "deco" : "k"
       }
      ],
      "endline" : 1096
     }
    ]
   },
   {
    "name" : "__unittestL1098_510",
    "kind" : "function",
    "line" : 1098,
    "endline" : 1121
   },
   {
    "kind" : "template",
    "line" : 1122,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 1122,
      "type" : "T(S s, in T leftBracket, in T separator = \", \", in T rightBracket = \"]\")",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "leftBracket",
        "type" : "T",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "separator",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\", \""
       },
       {
        "name" : "rightBracket",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\"]\""
       }
      ],
      "endline" : 1153
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1157,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 1157,
      "type" : "T(ref S s, in T leftBracket, in T separator = \" \", in T rightBracket = \"]\")",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "leftBracket",
        "type" : "T",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "separator",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\" \""
       },
       {
        "name" : "rightBracket",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\"]\""
       }
      ],
      "endline" : 1162
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1166,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 1166,
      "type" : "T(S s, in T leftBracket, in T keyval = \":\", in T separator = \", \", in T rightBracket = \"]\")",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "leftBracket",
        "type" : "T",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "keyval",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\":\""
       },
       {
        "name" : "separator",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\", \""
       },
       {
        "name" : "rightBracket",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\"]\""
       }
      ],
      "endline" : 1186
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1190,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 1190,
      "type" : "T(S s, in T nullstr)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "nullstr",
        "type" : "T",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 1197
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1201,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 1201,
      "type" : "T(S s, in T left, in T separator = \", \", in T right = \")\")",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "left",
        "type" : "T",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "separator",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\", \""
       },
       {
        "name" : "right",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\")\""
       }
      ],
      "endline" : 1227
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1232,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "line" : 1232,
      "type" : "T(S s, in T left = to!(T)(S.stringof ~ \"(\"), in T right = \")\")",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "left",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "to!(T)(S.stringof ~ \"(\")"
       },
       {
        "name" : "right",
        "type" : "T",
        "storageClass" : [
         "in"
        ],
        "default" : "\")\""
       }
      ],
      "endline" : 1241
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nNarrowing numeric-numeric conversions throw when the value does not\nfit in the narrower type.\n \n",
    "line" : 1248,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nNarrowing numeric-numeric conversions throw when the value does not\nfit in the narrower type.\n \n",
      "line" : 1248,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 1277
     }
    ]
   },
   {
    "name" : "__unittestL1279_511",
    "kind" : "function",
    "line" : 1279,
    "endline" : 1306
   },
   {
    "kind" : "template",
    "comment" : "\nArray-to-array conversion (except when target is a string type)\nconverts each element in turn by using $(D to).\n \n",
    "line" : 1306,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nArray-to-array conversion (except when target is a string type)\nconverts each element in turn by using $(D to).\n \n",
      "line" : 1306,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 1321
     }
    ]
   },
   {
    "name" : "__unittestL1323_512",
    "kind" : "function",
    "line" : 1323,
    "endline" : 1356
   },
   {
    "kind" : "template",
    "comment" : "\nAssociative array to associative array conversion converts each key\nand each value in turn.\n \n",
    "line" : 1356,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nAssociative array to associative array conversion converts each key\nand each value in turn.\n \n",
      "line" : 1356,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 1373
     }
    ]
   },
   {
    "name" : "__unittestL1375_513",
    "kind" : "function",
    "line" : 1375,
    "endline" : 1384
   },
   {
    "name" : "__unittestL1384_514",
    "kind" : "function",
    "line" : 1384,
    "endline" : 1391
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1401,
    "name" : "testIntegralToFloating",
    "parameters" : [
     {
      "name" : "Integral",
      "kind" : "type"
     },
     {
      "name" : "Floating",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "testIntegralToFloating",
      "kind" : "function",
      "line" : 1401,
      "type" : "void()",
      "endline" : 1407
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1409,
    "name" : "testFloatingToIntegral",
    "parameters" : [
     {
      "name" : "Floating",
      "kind" : "type"
     },
     {
      "name" : "Integral",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "testFloatingToIntegral",
      "kind" : "function",
      "line" : 1409,
      "type" : "void()",
      "endline" : 1468
     }
    ]
   },
   {
    "name" : "__unittestL1470_516",
    "kind" : "function",
    "line" : 1470,
    "endline" : 1584
   },
   {
    "kind" : "template",
    "comment" : "\nString to non-string conversion runs parsing.\n$(UL\n  $(LI When the source is a wide string, it is first converted to a narrow\n       string and then parsed.)\n  $(LI When the source is a narrow string, normal text parsing occurs.))\n",
    "line" : 1584,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nString to non-string conversion runs parsing.\n$(UL\n  $(LI When the source is a wide string, it is first converted to a narrow\n       string and then parsed.)\n  $(LI When the source is a narrow string, normal text parsing occurs.))\n",
      "line" : 1584,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 1596
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1599,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1599,
      "type" : "T(S value, uint radix)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       },
       {
        "name" : "radix",
        "deco" : "k"
       }
      ],
      "endline" : 1611
     }
    ]
   },
   {
    "name" : "__unittestL1613_517",
    "kind" : "function",
    "line" : 1613,
    "endline" : 1620
   },
   {
    "name" : "__unittestL1620_518",
    "kind" : "function",
    "line" : 1620,
    "endline" : 1641
   },
   {
    "kind" : "template",
    "comment" : "\nConvert a value that is implicitly convertible to the enum base type\ninto an Enum value. If the value does not match any enum member values\na ConvException is thrown.\nEnums with floating-point or string base types are not supported.\n",
    "line" : 1641,
    "name" : "toImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toImpl",
      "kind" : "function",
      "comment" : "\nConvert a value that is implicitly convertible to the enum base type\ninto an Enum value. If the value does not match any enum member values\na ConvException is thrown.\nEnums with floating-point or string base types are not supported.\n",
      "line" : 1641,
      "type" : "T(S value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "S"
       }
      ],
      "endline" : 1652
     }
    ]
   },
   {
    "name" : "__unittestL1654_519",
    "kind" : "function",
    "line" : 1654,
    "endline" : 1684
   },
   {
    "kind" : "template",
    "comment" : "\n Rounded conversion from floating point to integral.\n\nExample:\n---------------\nassert(roundTo!int(3.14) == 3);\nassert(roundTo!int(3.49) == 3);\nassert(roundTo!int(3.5) == 4);\nassert(roundTo!int(3.999) == 4);\nassert(roundTo!int(-3.14) == -3);\nassert(roundTo!int(-3.49) == -3);\nassert(roundTo!int(-3.5) == -4);\nassert(roundTo!int(-3.999) == -4);\n---------------\nRounded conversions do not work with non-integral target types.\n \n",
    "line" : 1684,
    "name" : "roundTo",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1686,
      "name" : "roundTo",
      "parameters" : [
       {
        "name" : "Source",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "roundTo",
        "kind" : "function",
        "line" : 1686,
        "type" : "Target(Source value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "Source"
         }
        ],
        "endline" : 1691
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1694_520",
    "kind" : "function",
    "line" : 1694,
    "endline" : 1740
   },
   {
    "kind" : "template",
    "comment" : "\n The $(D_PARAM parse) family of functions works quite like the\n $(D_PARAM to) family, except that (1) it only works with character ranges\n as input, (2) takes the input by reference and advances it to\n the position following the conversion, and (3) does not throw if it\n could not convert the entire input. It still throws if an overflow\n occurred during conversion or if no character of the input\n was meaningfully converted.\n\n Example:\n--------------\nstring test = \"123 \\t  76.14\";\nauto a = parse!uint(test);\nassert(a == 123);\nassert(test == \" \\t  76.14\"); // parse bumps string\nmunch(test, \" \\t\\n\\r\"); // skip ws\nassert(test == \"76.14\");\nauto b = parse!double(test);\nassert(b == 76.14);\nassert(test == \"\");\n--------------\n \n",
    "line" : 1740,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\n The $(D_PARAM parse) family of functions works quite like the\n $(D_PARAM to) family, except that (1) it only works with character ranges\n as input, (2) takes the input by reference and advances it to\n the position following the conversion, and (3) does not throw if it\n could not convert the entire input. It still throws if an overflow\n occurred during conversion or if no character of the input\n was meaningfully converted.\n\n Example:\n--------------\nstring test = \"123 \\t  76.14\";\nauto a = parse!uint(test);\nassert(a == 123);\nassert(test == \" \\t  76.14\"); // parse bumps string\nmunch(test, \" \\t\\n\\r\"); // skip ws\nassert(test == \"76.14\");\nauto b = parse!double(test);\nassert(b == 76.14);\nassert(test == \"\");\n--------------\n \n",
      "line" : 1740,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1808
     }
    ]
   },
   {
    "name" : "__unittestL1810_521",
    "kind" : "function",
    "line" : 1810,
    "endline" : 1817
   },
   {
    "name" : "__unittestL1817_522",
    "kind" : "function",
    "line" : 1817,
    "endline" : 1914
   },
   {
    "name" : "__unittestL1914_523",
    "kind" : "function",
    "line" : 1914,
    "endline" : 1993
   },
   {
    "name" : "__unittestL1993_527",
    "kind" : "function",
    "line" : 1993,
    "endline" : 2002
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2002,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2002,
      "type" : "Target(ref Source s, uint radix)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "radix",
        "deco" : "k"
       }
      ],
      "endline" : 2054
     }
    ]
   },
   {
    "name" : "__unittestL2056_528",
    "kind" : "function",
    "line" : 2056,
    "endline" : 2091
   },
   {
    "name" : "__unittestL2091_529",
    "kind" : "function",
    "line" : 2091,
    "endline" : 2099
   },
   {
    "kind" : "template",
    "line" : 2099,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "line" : 2099,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2125
     }
    ]
   },
   {
    "name" : "__unittestL2127_530",
    "kind" : "function",
    "line" : 2127,
    "endline" : 2148
   },
   {
    "name" : "__unittestL2148_531",
    "kind" : "function",
    "line" : 2148,
    "endline" : 2158
   },
   {
    "kind" : "template",
    "line" : 2158,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "line" : 2158,
      "type" : "Target(ref Source p)",
      "parameters" : [
       {
        "name" : "p",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2473
     }
    ]
   },
   {
    "name" : "__unittestL2475_532",
    "kind" : "function",
    "line" : 2475,
    "endline" : 2546
   },
   {
    "name" : "__unittestL2546_533",
    "kind" : "function",
    "line" : 2546,
    "endline" : 2594
   },
   {
    "name" : "__unittestL2594_534",
    "kind" : "function",
    "line" : 2594,
    "endline" : 2603
   },
   {
    "name" : "__unittestL2603_535",
    "kind" : "function",
    "line" : 2603,
    "endline" : 2610
   },
   {
    "name" : "__unittestL2610_536",
    "kind" : "function",
    "line" : 2610,
    "endline" : 2617
   },
   {
    "name" : "__unittestL2617_537",
    "kind" : "function",
    "line" : 2617,
    "endline" : 2624
   },
   {
    "name" : "__unittestL2624_538",
    "kind" : "function",
    "line" : 2624,
    "endline" : 2628
   },
   {
    "name" : "__unittestL2628_539",
    "kind" : "function",
    "line" : 2628,
    "endline" : 2644
   },
   {
    "kind" : "template",
    "comment" : "\nParsing one character off a string returns the character and bumps the\nstring up one position.\n \n",
    "line" : 2644,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\nParsing one character off a string returns the character and bumps the\nstring up one position.\n \n",
      "line" : 2644,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2662
     }
    ]
   },
   {
    "name" : "__unittestL2664_540",
    "kind" : "function",
    "line" : 2664,
    "endline" : 2681
   },
   {
    "kind" : "template",
    "line" : 2681,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "line" : 2681,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2689
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2692,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "line" : 2692,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2708
     }
    ]
   },
   {
    "name" : "__unittestL2713_541",
    "kind" : "function",
    "line" : 2713,
    "endline" : 2740
   },
   {
    "kind" : "template",
    "line" : 2740,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "line" : 2740,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2751
     }
    ]
   },
   {
    "name" : "__unittestL2753_542",
    "kind" : "function",
    "line" : 2753,
    "endline" : 2773
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 2773,
    "name" : "skipWS",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "skipWS",
      "kind" : "function",
      "line" : 2773,
      "type" : "void(ref R r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2794
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Parses an array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), and element separator (by\n default $(D ',')).\n \n",
    "line" : 2801,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\n Parses an array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), and element separator (by\n default $(D ',')).\n \n",
      "line" : 2801,
      "type" : "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "lbracket",
        "deco" : "w",
        "default" : "'['"
       },
       {
        "name" : "rbracket",
        "deco" : "w",
        "default" : "']'"
       },
       {
        "name" : "comma",
        "deco" : "w",
        "default" : "','"
       }
      ],
      "endline" : 2826
     }
    ]
   },
   {
    "name" : "__unittestL2828_543",
    "kind" : "function",
    "line" : 2828,
    "endline" : 2835
   },
   {
    "name" : "__unittestL2835_544",
    "kind" : "function",
    "line" : 2835,
    "endline" : 2842
   },
   {
    "name" : "__unittestL2842_545",
    "kind" : "function",
    "line" : 2842,
    "endline" : 2853
   },
   {
    "name" : "__unittestL2853_546",
    "kind" : "function",
    "line" : 2853,
    "endline" : 2864
   },
   {
    "name" : "__unittestL2864_547",
    "kind" : "function",
    "line" : 2864,
    "endline" : 2876
   },
   {
    "name" : "__unittestL2876_548",
    "kind" : "function",
    "line" : 2876,
    "endline" : 2905
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2905,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2905,
      "type" : "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar comma = ',')",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "lbracket",
        "deco" : "w",
        "default" : "'['"
       },
       {
        "name" : "rbracket",
        "deco" : "w",
        "default" : "']'"
       },
       {
        "name" : "comma",
        "deco" : "w",
        "default" : "','"
       }
      ],
      "endline" : 2949
     }
    ]
   },
   {
    "name" : "__unittestL2951_549",
    "kind" : "function",
    "line" : 2951,
    "endline" : 2973
   },
   {
    "kind" : "template",
    "comment" : "\n Parses an associative array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), key-value separator (default $(D\n ':')), and element seprator (by default $(D ',')).\n \n",
    "line" : 2973,
    "name" : "parse",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\n Parses an associative array from a string given the left bracket (default $(D\n '[')), right bracket (default $(D ']')), key-value separator (default $(D\n ':')), and element seprator (by default $(D ',')).\n \n",
      "line" : 2973,
      "type" : "Target(ref Source s, dchar lbracket = '[', dchar rbracket = ']', dchar keyval = ':', dchar comma = ',')",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "lbracket",
        "deco" : "w",
        "default" : "'['"
       },
       {
        "name" : "rbracket",
        "deco" : "w",
        "default" : "']'"
       },
       {
        "name" : "keyval",
        "deco" : "w",
        "default" : "':'"
       },
       {
        "name" : "comma",
        "deco" : "w",
        "default" : "','"
       }
      ],
      "endline" : 3005
     }
    ]
   },
   {
    "name" : "__unittestL3007_550",
    "kind" : "function",
    "line" : 3007,
    "endline" : 3022
   },
   {
    "name" : "__unittestL3022_551",
    "kind" : "function",
    "line" : 3022,
    "endline" : 3034
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3034,
    "name" : "parseEscape",
    "parameters" : [
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseEscape",
      "kind" : "function",
      "line" : 3034,
      "type" : "dchar(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3098
     }
    ]
   },
   {
    "name" : "__unittestL3100_552",
    "kind" : "function",
    "line" : 3100,
    "endline" : 3125
   },
   {
    "name" : "__unittestL3125_553",
    "kind" : "function",
    "line" : 3125,
    "endline" : 3145
   },
   {
    "kind" : "template",
    "line" : 3145,
    "name" : "parseElement",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseElement",
      "kind" : "function",
      "line" : 3145,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3182
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3185,
    "name" : "parseElement",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseElement",
      "kind" : "function",
      "line" : 3185,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3203
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3206,
    "name" : "parseElement",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseElement",
      "kind" : "function",
      "line" : 3206,
      "type" : "Target(ref Source s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Source",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3211
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Convenience functions for converting any number and types of\n   arguments into _text (the three character widths).\n\n   Example:\n----\nassert(text(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\");\nassert(wtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"w);\nassert(dtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"d);\n----\n",
    "line" : 3225,
    "name" : "text",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "text",
      "kind" : "function",
      "comment" : "\n   Convenience functions for converting any number and types of\n   arguments into _text (the three character widths).\n\n   Example:\n----\nassert(text(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\");\nassert(wtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"w);\nassert(dtext(42, ' ', 1.5, \": xyz\") == \"42 1.5: xyz\"d);\n----\n",
      "line" : 3225,
      "type" : "string(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 3228
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 3230,
    "name" : "wtext",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "wtext",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 3230,
      "type" : "wstring(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 3233
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 3235,
    "name" : "dtext",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "dtext",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 3235,
      "type" : "dstring(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 3238
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3240,
    "name" : "textImpl",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "textImpl",
      "kind" : "function",
      "line" : 3240,
      "type" : "S(U args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "U"
       }
      ],
      "endline" : 3243
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3245,
    "name" : "textImpl",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "textImpl",
      "kind" : "function",
      "line" : 3245,
      "type" : "S(U args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "U"
       }
      ],
      "endline" : 3250
     }
    ]
   },
   {
    "name" : "__unittestL3252_554",
    "kind" : "function",
    "line" : 3252,
    "endline" : 3288
   },
   {
    "kind" : "template",
    "comment" : "\nThe $(D octal) facility is intended as an experimental facility to\nreplace _octal literals starting with $(D '0'), which many find\nconfusing. Using $(D octal!177) or $(D octal!\"177\") instead of $(D\n0177) as an _octal literal makes code clearer and the intent more\nvisible. If use of this facility becomes preponderent, a future\nversion of the language may deem old-style _octal literals deprecated.\n\nThe rules for strings are the usual for literals: If it can fit in an\n$(D int), it is an $(D int). Otherwise, it is a $(D long). But, if the\nuser specifically asks for a $(D long) with the $(D L) suffix, always\ngive the $(D long). Give an unsigned iff it is asked for with the $(D\nU) or $(D u) suffix. _Octals created from integers preserve the type\nof the passed-in integral.\n\nExample:\n----\n// same as 0177\nauto x = octal!177;\n// octal is a compile-time device\nenum y = octal!160;\n// Create an unsigned octal\nauto z = octal!\"1_000_000u\";\n----\n \n",
    "line" : 3288,
    "name" : "octal",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "octal",
      "kind" : "function",
      "line" : 3288,
      "type" : "int()",
      "endline" : 3292
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3295,
    "name" : "octal",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "octal",
      "kind" : "function",
      "line" : 3295,
      "type" : "long()",
      "endline" : 3299
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3302,
    "name" : "octal",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "octal",
      "kind" : "function",
      "line" : 3302,
      "type" : "uint()",
      "endline" : 3306
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3309,
    "name" : "octal",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "octal",
      "kind" : "function",
      "line" : 3309,
      "type" : "ulong()",
      "endline" : 3313
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3316,
    "name" : "octal",
    "parameters" : [
     {
      "name" : "s",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "octal",
      "kind" : "variable",
      "line" : 3319,
      "storageClass" : [
       "auto",
       "enum"
      ],
      "init" : "octal!(typeof(s), to!(string)(s))"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3332,
    "name" : "octal",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "octal",
      "kind" : "function",
      "line" : 3332,
      "type" : "T()",
      "endline" : 3351
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3357,
    "name" : "octalFitsInInt",
    "parameters" : [
     {
      "name" : "octalNum",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "octalFitsInInt",
      "kind" : "variable",
      "line" : 3362,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "strippedOctalLiteral(octalNum).length < 11 || strippedOctalLiteral(octalNum).length == 11 && strippedOctalLiteral(octalNum)[0] == '1'"
     }
    ]
   },
   {
    "name" : "strippedOctalLiteral",
    "kind" : "function",
    "line" : 3367,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "original",
      "deco" : "Aya"
     }
    ],
    "endline" : 3374
   },
   {
    "kind" : "template",
    "line" : 3376,
    "name" : "literalIsLong",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "line" : 3385,
    "name" : "literalIsUnsigned",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : []
   },
   {
    "name" : "isOctalLiteralString",
    "kind" : "function",
    "line" : 3402,
    "deco" : "FAyaZb",
    "parameters" : [
     {
      "name" : "num",
      "deco" : "Aya"
     }
    ],
    "endline" : 3439
   },
   {
    "kind" : "template",
    "line" : 3444,
    "name" : "isOctalLiteral",
    "parameters" : [
     {
      "name" : "num",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "isOctalLiteral",
      "kind" : "variable",
      "line" : 3446,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isOctalLiteralString(num)"
     }
    ]
   },
   {
    "name" : "__unittestL3449_555",
    "kind" : "function",
    "line" : 3449,
    "endline" : 3518
   },
   {
    "kind" : "template",
    "comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas $(D T)), constructs an object of non-$(D class) type $(D T) at that\naddress.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
    "line" : 3518,
    "name" : "emplace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "emplace",
      "kind" : "function",
      "comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas $(D T)), constructs an object of non-$(D class) type $(D T) at that\naddress.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
      "line" : 3518,
      "type" : "T*(T* chunk)",
      "parameters" : [
       {
        "name" : "chunk",
        "type" : "T*"
       }
      ],
      "endline" : 3524
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 3526,
    "name" : "emplace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "emplace",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 3526,
      "type" : "T*(T* chunk)",
      "parameters" : [
       {
        "name" : "chunk",
        "type" : "T*"
       }
      ],
      "endline" : 3531
     }
    ]
   },
   {
    "name" : "__unittestL3570_556",
    "kind" : "function",
    "line" : 3570,
    "endline" : 3577
   },
   {
    "name" : "__unittestL3577_557",
    "kind" : "function",
    "line" : 3577,
    "endline" : 3603
   },
   {
    "kind" : "template",
    "comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas a non-class type $(D T)), constructs an object of type $(D T) at\nthat address from arguments $(D args).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
    "line" : 3603,
    "name" : "emplace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "emplace",
      "kind" : "function",
      "comment" : "\nGiven a pointer $(D chunk) to uninitialized memory (but already typed\nas a non-class type $(D T)), constructs an object of type $(D T) at\nthat address from arguments $(D args).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object (which is the same\nas $(D chunk)).\n \n",
      "line" : 3603,
      "type" : "T*(T* chunk, Args args)",
      "parameters" : [
       {
        "name" : "chunk",
        "type" : "T*"
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 3608
     }
    ]
   },
   {
    "name" : "__unittestL3610_558",
    "kind" : "function",
    "line" : 3610,
    "endline" : 3618
   },
   {
    "name" : "__unittestL3618_559",
    "kind" : "function",
    "line" : 3618,
    "endline" : 3635
   },
   {
    "kind" : "template",
    "line" : 3635,
    "name" : "emplace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "emplace",
      "kind" : "function",
      "line" : 3635,
      "type" : "T*(T* chunk, auto ref Args args)",
      "parameters" : [
       {
        "name" : "chunk",
        "type" : "T*"
       },
       {
        "name" : "args",
        "type" : "Args",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 3667
     }
    ]
   },
   {
    "name" : "__unittestL3671_560",
    "kind" : "function",
    "line" : 3671,
    "endline" : 3691
   },
   {
    "name" : "__unittestL3691_561",
    "kind" : "function",
    "line" : 3691,
    "endline" : 3698
   },
   {
    "name" : "__unittestL3698_562",
    "kind" : "function",
    "line" : 3698,
    "endline" : 3709
   },
   {
    "name" : "__unittestL3709_563",
    "kind" : "function",
    "line" : 3709,
    "endline" : 3717
   },
   {
    "name" : "__unittestL3717_564",
    "kind" : "function",
    "line" : 3717,
    "endline" : 3724
   },
   {
    "name" : "__unittestL3724_565",
    "kind" : "function",
    "line" : 3724,
    "endline" : 3740
   },
   {
    "name" : "testEmplaceChunk",
    "kind" : "function",
    "protection" : "private",
    "line" : 3740,
    "deco" : "FAvmmAyaZv",
    "originalType" : "void(void[] chunk, size_t typeSize, size_t typeAlignment, string typeName)",
    "parameters" : [
     {
      "name" : "chunk",
      "deco" : "Av"
     },
     {
      "name" : "typeSize",
      "deco" : "m"
     },
     {
      "name" : "typeAlignment",
      "deco" : "m"
     },
     {
      "name" : "typeName",
      "deco" : "Aya"
     }
    ],
    "endline" : 3748
   },
   {
    "kind" : "template",
    "comment" : "\nGiven a raw memory area $(D chunk), constructs an object of $(D class)\ntype $(D T) at that address. The constructor is passed the arguments\n$(D Args). The $(D chunk) must be as least as large as $(D T) needs\nand should have an alignment multiple of $(D T)'s alignment. (The size\nof a $(D class) instance is obtained by using $(D\n__traits(classInstanceSize, T))).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
    "line" : 3763,
    "name" : "emplace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "emplace",
      "kind" : "function",
      "comment" : "\nGiven a raw memory area $(D chunk), constructs an object of $(D class)\ntype $(D T) at that address. The constructor is passed the arguments\n$(D Args). The $(D chunk) must be as least as large as $(D T) needs\nand should have an alignment multiple of $(D T)'s alignment. (The size\nof a $(D class) instance is obtained by using $(D\n__traits(classInstanceSize, T))).\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
      "line" : 3763,
      "type" : "T(void[] chunk, auto ref Args args)",
      "parameters" : [
       {
        "name" : "chunk",
        "type" : "void[]"
       },
       {
        "name" : "args",
        "type" : "Args",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 3786
     }
    ]
   },
   {
    "name" : "__unittestL3788_566",
    "kind" : "function",
    "line" : 3788,
    "endline" : 3808
   },
   {
    "kind" : "template",
    "comment" : "\nGiven a raw memory area $(D chunk), constructs an object of non-$(D\nclass) type $(D T) at that address. The constructor is passed the\narguments $(D args), if any. The $(D chunk) must be as least as large\nas $(D T) needs and should have an alignment multiple of $(D T)'s\nalignment.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
    "line" : 3808,
    "name" : "emplace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "emplace",
      "kind" : "function",
      "comment" : "\nGiven a raw memory area $(D chunk), constructs an object of non-$(D\nclass) type $(D T) at that address. The constructor is passed the\narguments $(D args), if any. The $(D chunk) must be as least as large\nas $(D T) needs and should have an alignment multiple of $(D T)'s\nalignment.\n\nThis function can be $(D @trusted) if the corresponding constructor of\n$(D T) is $(D @safe).\n\nReturns: A pointer to the newly constructed object.\n \n",
      "line" : 3808,
      "type" : "T*(void[] chunk, auto ref Args args)",
      "parameters" : [
       {
        "name" : "chunk",
        "type" : "void[]"
       },
       {
        "name" : "args",
        "type" : "Args",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 3813
     }
    ]
   },
   {
    "name" : "__unittestL3815_567",
    "kind" : "function",
    "line" : 3815,
    "endline" : 3829
   },
   {
    "name" : "__unittestL3829_568",
    "kind" : "function",
    "line" : 3829,
    "endline" : 3837
   },
   {
    "name" : "__unittestL3837_569",
    "kind" : "function",
    "line" : 3837,
    "endline" : 3866
   },
   {
    "name" : "__unittestL3866_570",
    "kind" : "function",
    "line" : 3866,
    "endline" : 3874
   },
   {
    "kind" : "template",
    "line" : 3874,
    "name" : "toTextRange",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "W",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toTextRange",
      "kind" : "function",
      "line" : 3874,
      "type" : "void(T value, W writer)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "writer",
        "type" : "W"
       }
      ],
      "endline" : 3894
     }
    ]
   },
   {
    "name" : "__unittestL3896_571",
    "kind" : "function",
    "line" : 3896,
    "endline" : 3902
   }
  ]
 },
 {
  "name" : "std.cstream",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/cstream.d",
  "comment" : "\n $(RED Warning: This module is considered out-dated and not up to Phobos'\n       current standards. It will remain until we have a suitable replacement,\n       but be aware that it will not remain long term.)\n\n The std.cstream module bridges std.c.stdio (or std.stdio) and std.stream.\n Both std.c.stdio and std.stream are publicly imported by std.cstream.\n\n Macros:\n      WIKI=Phobos/StdCstream\n\n Copyright: Copyright Ben Hinkle 2007 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   Ben Hinkle\n Source:    $(PHOBOSSRC std/_cstream.d)\n \n",
  "members" : [
   {
    "name" : "std.stream",
    "kind" : "import",
    "line" : 26
   },
   {
    "name" : "std.c.stdio",
    "kind" : "import",
    "line" : 27
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "CFile",
    "kind" : "class",
    "comment" : "\n A Stream wrapper for a C file of type FILE*.\n \n",
    "line" : 35,
    "base" : "Stream",
    "members" : [
     {
      "name" : "cfile",
      "kind" : "variable",
      "line" : 36,
      "deco" : "POS4core4stdc5stdio6_iobuf",
      "originalType" : "FILE*",
      "offset" : 56
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create the stream wrapper for the given C file.\n Params:\n   mode = a bitwise combination of $(B FileMode.In) for a readable file\n          and $(B FileMode.Out) for a writeable file.\n   seekable = indicates if the stream should be _seekable.\n   \n",
      "line" : 45,
      "deco" : "FPOS4core4stdc5stdio6_iobufE3std6stream8FileModebZC3std7cstream5CFile",
      "originalType" : "(FILE* cfile, FileMode mode, bool seekable = false)",
      "parameters" : [
       {
        "name" : "cfile",
        "deco" : "POS4core4stdc5stdio6_iobuf"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode"
       },
       {
        "name" : "seekable",
        "deco" : "b",
        "default" : "false"
       }
      ],
      "endline" : 51
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "comment" : "\n Closes the stream.\n   \n",
      "line" : 56,
      "deco" : "FZv",
      "endline" : 56
     },
     {
      "name" : "file",
      "kind" : "function",
      "comment" : "\n Property to get or set the underlying file for this stream.\n Setting the file marks the stream as open.\n   \n",
      "line" : 62,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZPOS4core4stdc5stdio6_iobuf",
      "originalType" : "FILE*()",
      "endline" : 62
     },
     {
      "name" : "file",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 67,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdPOS4core4stdc5stdio6_iobufZv",
      "originalType" : "void(FILE* cfile)",
      "parameters" : [
       {
        "name" : "cfile",
        "deco" : "POS4core4stdc5stdio6_iobuf"
       }
      ],
      "endline" : 70
     },
     {
      "name" : "flush",
      "kind" : "function",
      "comment" : "\n Overrides of the $(B Stream) methods to call the underlying $(B FILE*)\n C functions.\n   \n",
      "line" : 76,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 76,
      "overrides" : [
       "std.stream.Stream.flush"
      ]
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 81,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 85,
      "overrides" : [
       "std.stream.Stream.close"
      ]
     },
     {
      "name" : "eof",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 90,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZb",
      "endline" : 92,
      "overrides" : [
       "std.stream.Stream.eof"
      ]
     },
     {
      "name" : "getc",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 97,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZa",
      "endline" : 99,
      "overrides" : [
       "std.stream.Stream.getc"
      ]
     },
     {
      "name" : "ungetc",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 104,
      "storageClass" : [
       "override"
      ],
      "deco" : "FaZa",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "a"
       }
      ],
      "endline" : 106,
      "overrides" : [
       "std.stream.Stream.ungetc"
      ]
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 111,
      "storageClass" : [
       "override"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 115,
      "overrides" : [
       "std.stream.Stream.readBlock"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 120,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 122,
      "overrides" : [
       "std.stream.Stream.writeBlock"
      ]
     },
     {
      "name" : "seek",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 127,
      "storageClass" : [
       "override"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "rel",
        "deco" : "E3std6stream7SeekPos"
       }
      ],
      "endline" : 132,
      "overrides" : [
       "std.stream.Stream.seek"
      ]
     },
     {
      "name" : "writeLine",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 137,
      "storageClass" : [
       "override"
      ],
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ],
      "endline" : 140,
      "overrides" : [
       "std.stream.Stream.writeLine"
      ]
     },
     {
      "name" : "writeLineW",
      "kind" : "function",
      "comment" : "\n Ditto\n   \n",
      "line" : 145,
      "storageClass" : [
       "override"
      ],
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ],
      "endline" : 148,
      "overrides" : [
       "std.stream.Stream.writeLineW"
      ]
     },
     {
      "name" : "__unittestL151_572",
      "kind" : "function",
      "line" : 151,
      "endline" : 222
     }
    ]
   },
   {
    "name" : "din",
    "kind" : "variable",
    "comment" : "\n CFile wrapper of std.c.stdio.stdin (not seekable).\n \n",
    "line" : 227,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "C3std7cstream5CFile",
    "originalType" : "CFile"
   },
   {
    "name" : "dout",
    "kind" : "variable",
    "comment" : "\n CFile wrapper of std.c.stdio.stdout (not seekable).\n \n",
    "line" : 232,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "C3std7cstream5CFile",
    "originalType" : "CFile"
   },
   {
    "name" : "derr",
    "kind" : "variable",
    "comment" : "\n CFile wrapper of std.c.stdio.stderr (not seekable).\n \n",
    "line" : 237,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "C3std7cstream5CFile",
    "originalType" : "CFile"
   },
   {
    "name" : "_sharedStaticCtor5",
    "kind" : "function",
    "line" : 239,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 244
   }
  ]
 },
 {
  "name" : "std.csv",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/csv.d",
  "comment" : "\n Implements functionality to read Comma Separated Values and its variants\n from a input range of $(D dchar).\n\n Comma Separated Values provide a simple means to transfer and store\n tabular data. It has been common for programs to use their own\n variant of the CSV format. This parser will loosely follow the\n $(WEB tools.ietf.org/html/rfc4180, RFC-4180). CSV input should adhered\n to the following criteria, differences from RFC-4180 in parentheses.\n\n $(UL\n     $(LI A record is separated by a new line (CRLF,LF,CR))\n     $(LI A final record may end with a new line)\n     $(LI A header may be provided as the first record in input)\n     $(LI A record has fields separated by a comma (customizable))\n     $(LI A field containing new lines, commas, or double quotes\n          should be enclosed in double quotes (customizable))\n     $(LI Double quotes in a field are escaped with a double quote)\n     $(LI Each record should contain the same number of fields)\n   )\n\n Example:\n\n -------\n import std.algorithm;\n import std.array;\n import std.csv;\n import std.stdio;\n import std.typecons;\n\n void main()\n {\n     auto text = \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n     foreach(record; csvReader!(Tuple!(string,string,int))(text))\n     {\n         writefln(\"%s works as a %s and earns $%d per year\",\n                  record[0], record[1], record[2]);\n     }\n }\n -------\n\n When an input contains a header the $(D Contents) can be specified as an\n associative array. Passing null to signify that a header is present.\n\n -------\n auto text = \"Name,Occupation,Salary\\r\"\n     \"Joe,Carpenter,300000\\nFred,Blacksmith,400000\\r\\n\";\n\n foreach(record; csvReader!(string[string])\n         (text, null))\n {\n     writefln(\"%s works as a %s and earns $%s per year.\",\n              record[\"Name\"], record[\"Occupation\"],\n              record[\"Salary\"]);\n }\n -------\n\n This module allows content to be iterated by record stored in a struct,\n class, associative array, or as a range of fields. Upon detection of an\n error an CSVException is thrown (can be disabled). csvNextToken has been\n made public to allow for attempted recovery.\n\n Disabling exceptions will lift many restrictions specified above. A quote\n can appear in a field if the field was not quoted. If in a quoted field any\n quote by itself, not at the end of a field, will end processing for that\n field. The field is ended when there is no input, even if the quote was not\n closed.\n\n   See_Also:\n      $(WEB en.wikipedia.org/wiki/Comma-separated_values, Wikipedia\n      Comma-separated values)\n\n   Copyright: Copyright 2011\n   License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n   Authors:   Jesse Phillips\n   Source:    $(PHOBOSSRC std/_csv.d)\n \n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 83,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 84,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 85,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 86,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 87,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 88,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 89,
    "protection" : "private"
   },
   {
    "name" : "CSVException",
    "kind" : "class",
    "comment" : "\n Exception containing the row and column for when an exception was thrown.\n\n Numbering of both row and col start at one and corresponds to the location\n in the file rather than any specified header. Special consideration should\n be made when there is failure to match the header see $(LREF\n HeaderMismatchException) for details.\n\n When performing type conversions, $(XREF ConvException) is stored in the $(D\n next) field.\n \n",
    "line" : 102,
    "base" : "Exception",
    "members" : [
     {
      "name" : "row",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 105,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 72
     },
     {
      "name" : "col",
      "kind" : "variable",
      "comment" : "\n",
      "line" : 105,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 80
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 107,
      "deco" : "FAyaAyamC6object9ThrowableZC3std3csv12CSVException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 111
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 113,
      "deco" : "FAyaC6object9ThrowableAyamZC3std3csv12CSVException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 117
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 119,
      "deco" : "FAyammC6object9ThrowableAyamZC3std3csv12CSVException",
      "originalType" : "(string msg, size_t row, size_t col, Throwable next = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "row",
        "deco" : "m"
       },
       {
        "name" : "col",
        "deco" : "m"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 125
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 127,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZAya",
      "endline" : 130,
      "overrides" : [
       "object.Throwable.toString"
      ]
     }
    ]
   },
   {
    "name" : "IncompleteCellException",
    "kind" : "class",
    "comment" : "\n Exception thrown when a Token is identified to not be completed: a quote is\n found in an unquoted field, data continues after a closing quote, or the\n quoted field was not closed before data was empty.\n \n",
    "line" : 138,
    "base" : "CSVException",
    "members" : [
     {
      "name" : "partialData",
      "kind" : "variable",
      "comment" : " Data pulled from input before finding a problem\n\n This field is populated when using $(LREF csvReader)\n but not by $(LREF csvNextToken) as this data will have\n already been fed to the output range.\n",
      "line" : 145,
      "deco" : "Ayw",
      "originalType" : "dstring",
      "offset" : 88
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 147,
      "deco" : "FAyaAyamC6object9ThrowableZC3std3csv23IncompleteCellException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 150
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 152,
      "deco" : "FAyaC6object9ThrowableAyamZC3std3csv23IncompleteCellException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 155
     }
    ]
   },
   {
    "name" : "HeaderMismatchException",
    "kind" : "class",
    "comment" : "\n Exception thrown under different conditions based on the type of $(D\n Contents).\n\n Structure, Class, and Associative Array\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n  )\n\n Other\n $(UL\n     $(LI When a header is provided but a matching column is not found)\n     $(LI Order did not match that found in the input)\n  )\n\n Since a row and column is not meaningful when a column specified by the\n header is not found in the data, both row and col will be zero. Otherwise\n row is always one and col is the first instance found in header that\n occurred before the previous starting at one.\n \n",
    "line" : 178,
    "base" : "CSVException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 180,
      "deco" : "FAyaAyamC6object9ThrowableZC3std3csv23HeaderMismatchException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 183
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 185,
      "deco" : "FAyaC6object9ThrowableAyamZC3std3csv23HeaderMismatchException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 188
     }
    ]
   },
   {
    "name" : "Malformed",
    "kind" : "enum",
    "comment" : "\n Determines the behavior for when an error is detected.\n\n Disabling exception will follow these rules:\n $(UL\n     $(LI A quote can appear in a field if the field was not quoted.)\n     $(LI If in a quoted field any quote by itself, not at the end of a\n     field, will end processing for that field.)\n     $(LI The field is ended when there is no input, even if the quote was\n     not closed.)\n     $(LI If the given header does not match the order in the input, the\n     content will return as it is found in the input.)\n     $(LI If the given header contains columns not found in the input they\n     will be ignored.)\n  )\n",
    "line" : 208,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "ignore",
      "kind" : "enum member",
      "comment" : " No exceptions are thrown due to incorrect CSV.\n",
      "line" : 210
     },
     {
      "name" : "throwException",
      "kind" : "enum member",
      "comment" : " Use exceptions when input has incorrect CSV.\n",
      "line" : 212
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Returns an input range for iterating over records found in $(D\n input).\n\n The $(D Contents) of the input can be provided if all the records are the\n same type such as all integer data:\n\n -------\n string str = `76,26,22`;\n int[] ans = [76,26,22];\n auto records = csvReader!int(str);\n\n foreach(record; records)\n {\n     assert(equal(record, ans));\n }\n -------\n\n Example using a struct with modified delimiter:\n\n -------\n string str = \"Hello;65;63.63\\nWorld;123;3673.562\";\n struct Layout\n {\n     string name;\n     int value;\n     double other;\n }\n\n auto records = csvReader!Layout(str,';');\n\n foreach(record; records)\n {\n     writeln(record.name);\n     writeln(record.value);\n     writeln(record.other);\n }\n -------\n\n Specifying $(D ErrorLevel) as Malformed.ignore will lift restrictions\n on the format. This example shows that an exception is not thrown when\n finding a quote in a field not quoted.\n\n -------\n string str = \"A \\\" is now part of the data\";\n auto records = csvReader!(string,Malformed.ignore)(str);\n auto record = records.front;\n\n assert(record.front == str);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
    "line" : 283,
    "name" : "csvReader",
    "parameters" : [
     {
      "name" : "Contents",
      "kind" : "type",
      "default" : "string"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed",
      "defaultValue" : "Malformed.throwException"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type",
      "defaultDeco" : "a"
     }
    ],
    "members" : [
     {
      "name" : "csvReader",
      "kind" : "function",
      "comment" : "\n Returns an input range for iterating over records found in $(D\n input).\n\n The $(D Contents) of the input can be provided if all the records are the\n same type such as all integer data:\n\n -------\n string str = `76,26,22`;\n int[] ans = [76,26,22];\n auto records = csvReader!int(str);\n\n foreach(record; records)\n {\n     assert(equal(record, ans));\n }\n -------\n\n Example using a struct with modified delimiter:\n\n -------\n string str = \"Hello;65;63.63\\nWorld;123;3673.562\";\n struct Layout\n {\n     string name;\n     int value;\n     double other;\n }\n\n auto records = csvReader!Layout(str,';');\n\n foreach(record; records)\n {\n     writeln(record.name);\n     writeln(record.value);\n     writeln(record.other);\n }\n -------\n\n Specifying $(D ErrorLevel) as Malformed.ignore will lift restrictions\n on the format. This example shows that an exception is not thrown when\n finding a quote in a field not quoted.\n\n -------\n string str = \"A \\\" is now part of the data\";\n auto records = csvReader!(string,Malformed.ignore)(str);\n auto record = records.front;\n\n assert(record.front == str);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
      "line" : 283,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range input, Separator delimiter = ',', Separator quote = '\"')",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range"
       },
       {
        "name" : "delimiter",
        "type" : "Separator",
        "default" : "','"
       },
       {
        "name" : "quote",
        "type" : "Separator",
        "default" : "'\"'"
       }
      ],
      "endline" : 292
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n An optional $(D header) can be provided. The first record will be read in\n as the header. If $(D Contents) is a struct then the header provided is\n expected to correspond to the fields in the struct. When $(D Contents) is\n not a type which can contain the entire record, the $(D header) must be\n provided in the same order as the input or an exception is thrown.\n\n Read only column \"b\":\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader!int(str, [\"b\"]);\n\n auto ans = [[65],[123]];\n foreach(record; records)\n {\n     assert(equal(record, ans.front));\n     ans.popFront();\n }\n -------\n\n Read from header of different order:\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n struct Layout\n {\n     int value;\n     double other;\n     string name;\n }\n\n auto records = csvReader!Layout(str, [\"b\",\"c\",\"a\"]);\n -------\n\n The header can also be left empty if the input contains a header but\n all columns should be iterated. The header from the input can always\n be accessed from the header field.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader(str, null);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n        The returned range provides a header field for accessing the header\n        from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
    "line" : 370,
    "name" : "csvReader",
    "parameters" : [
     {
      "name" : "Contents",
      "kind" : "type",
      "default" : "string"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed",
      "defaultValue" : "Malformed.throwException"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Header",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type",
      "defaultDeco" : "a"
     }
    ],
    "members" : [
     {
      "name" : "csvReader",
      "kind" : "function",
      "comment" : "\n An optional $(D header) can be provided. The first record will be read in\n as the header. If $(D Contents) is a struct then the header provided is\n expected to correspond to the fields in the struct. When $(D Contents) is\n not a type which can contain the entire record, the $(D header) must be\n provided in the same order as the input or an exception is thrown.\n\n Read only column \"b\":\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader!int(str, [\"b\"]);\n\n auto ans = [[65],[123]];\n foreach(record; records)\n {\n     assert(equal(record, ans.front));\n     ans.popFront();\n }\n -------\n\n Read from header of different order:\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n struct Layout\n {\n     int value;\n     double other;\n     string name;\n }\n\n auto records = csvReader!Layout(str, [\"b\",\"c\",\"a\"]);\n -------\n\n The header can also be left empty if the input contains a header but\n all columns should be iterated. The header from the input can always\n be accessed from the header field.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\\nWorld,123,3673.562\";\n auto records = csvReader(str, null);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Returns:\n        An input range R as defined by $(XREF range, isInputRange). When $(D\n        Contents) is a struct, class, or an associative array, the element\n        type of R is $(D Contents), otherwise the element type of R is itself\n        a range with element type $(D Contents).\n\n        The returned range provides a header field for accessing the header\n        from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the row's\n       length does not match the previous length.\n\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found in\n       the input. Read the exception documentation for specific details of\n       when the exception is thrown for different types of $(D Contents).\n \n",
      "line" : 370,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range"
       },
       {
        "name" : "header",
        "type" : "Header"
       },
       {
        "name" : "delimiter",
        "type" : "Separator",
        "default" : "','"
       },
       {
        "name" : "quote",
        "type" : "Separator",
        "default" : "'\"'"
       }
      ],
      "endline" : 380
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 385,
    "name" : "csvReader",
    "parameters" : [
     {
      "name" : "Contents",
      "kind" : "type",
      "default" : "string"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed",
      "defaultValue" : "Malformed.throwException"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Header",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type",
      "defaultDeco" : "a"
     }
    ],
    "members" : [
     {
      "name" : "csvReader",
      "kind" : "function",
      "line" : 385,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range input, Header header, Separator delimiter = ',', Separator quote = '\"')",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range"
       },
       {
        "name" : "header",
        "type" : "Header"
       },
       {
        "name" : "delimiter",
        "type" : "Separator",
        "default" : "','"
       },
       {
        "name" : "quote",
        "type" : "Separator",
        "default" : "'\"'"
       }
      ],
      "endline" : 394
     }
    ]
   },
   {
    "name" : "__unittestL397_573",
    "kind" : "function",
    "line" : 397,
    "endline" : 414
   },
   {
    "name" : "__unittestL414_574",
    "kind" : "function",
    "line" : 414,
    "endline" : 424
   },
   {
    "name" : "__unittestL424_575",
    "kind" : "function",
    "line" : 424,
    "endline" : 453
   },
   {
    "name" : "__unittestL453_577",
    "kind" : "function",
    "line" : 453,
    "endline" : 474
   },
   {
    "name" : "__unittestL474_578",
    "kind" : "function",
    "line" : 474,
    "endline" : 506
   },
   {
    "name" : "__unittestL506_579",
    "kind" : "function",
    "line" : 506,
    "endline" : 519
   },
   {
    "name" : "__unittestL519_580",
    "kind" : "function",
    "line" : 519,
    "endline" : 552
   },
   {
    "name" : "__unittestL552_581",
    "kind" : "function",
    "line" : 552,
    "endline" : 594
   },
   {
    "name" : "__unittestL594_582",
    "kind" : "function",
    "line" : 594,
    "endline" : 603
   },
   {
    "name" : "__unittestL603_583",
    "kind" : "function",
    "line" : 603,
    "endline" : 627
   },
   {
    "name" : "__unittestL627_584",
    "kind" : "function",
    "line" : 627,
    "endline" : 644
   },
   {
    "name" : "__unittestL644_585",
    "kind" : "function",
    "line" : 644,
    "endline" : 660
   },
   {
    "name" : "__unittestL660_586",
    "kind" : "function",
    "line" : 660,
    "endline" : 676
   },
   {
    "name" : "__unittestL676_587",
    "kind" : "function",
    "line" : 676,
    "endline" : 718
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 719,
    "name" : "Input",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed"
     }
    ],
    "members" : [
     {
      "name" : "Input",
      "kind" : "struct",
      "line" : 719,
      "members" : [
       {
        "name" : "range",
        "kind" : "variable",
        "line" : 720,
        "type" : "Range"
       },
       {
        "name" : "row",
        "kind" : "variable",
        "line" : 721,
        "type" : "size_t"
       },
       {
        "name" : "col",
        "kind" : "variable",
        "line" : 721,
        "type" : "size_t"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 751,
    "name" : "CsvReader",
    "parameters" : [
     {
      "name" : "Contents",
      "kind" : "type"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type"
     },
     {
      "name" : "Header",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "CsvReader",
      "kind" : "struct",
      "line" : 751,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 753,
        "type" : "Input!(Range, ErrorLevel)*"
       },
       {
        "name" : "_separator",
        "kind" : "variable",
        "line" : 754,
        "type" : "Separator"
       },
       {
        "name" : "_quote",
        "kind" : "variable",
        "line" : 755,
        "type" : "Separator"
       },
       {
        "name" : "indices",
        "kind" : "variable",
        "line" : 756,
        "type" : "size_t[]"
       },
       {
        "name" : "_empty",
        "kind" : "variable",
        "line" : 757,
        "deco" : "b"
       },
       {
        "name" : "header",
        "kind" : "variable",
        "comment" : "\n Header from the input in array form.\n\n -------\n string str = \"a,b,c\\nHello,65,63.63\";\n auto records = csvReader(str, [\"a\"]);\n\n assert(records.header == [\"a\",\"b\",\"c\"]);\n -------\n     \n",
        "line" : 781,
        "type" : "string[]"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n Constructor to initialize the input, delimiter and quote for input\n without a header.\n\n -------\n string str = `76;^26^;22`;\n int[] ans = [76,26,22];\n auto records = CsvReader!(int,Malformed.ignore,string,char,string[])\n       (str, ';', '^');\n\n foreach(record; records) {\n    assert(equal(record, ans));\n }\n -------\n     \n",
        "line" : 798,
        "type" : "(Range input, Separator delimiter, Separator quote)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         },
         {
          "name" : "delimiter",
          "type" : "Separator"
         },
         {
          "name" : "quote",
          "type" : "Separator"
         }
        ],
        "endline" : 806
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n Constructor to initialize the input, delimiter and quote for input\n with a header.\n\n -------\n string str = `high;mean;low\\n76;^26^;22`;\n auto records = CsvReader!(int,Malformed.ignore,string,char,string[])\n       (str, [\"high\",\"low\"], ';', '^');\n\n int[] ans = [76,22];\n foreach(record; records) {\n    assert(equal(record, ans));\n }\n -------\n\n Throws:\n       $(LREF HeaderMismatchException)  when a header is provided but a\n       matching column is not found or the order did not match that found\n       in the input (non-struct).\n     \n",
        "line" : 828,
        "type" : "(Range input, Header colHeaders, Separator delimiter, Separator quote)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         },
         {
          "name" : "colHeaders",
          "type" : "Header"
         },
         {
          "name" : "delimiter",
          "type" : "Separator"
         },
         {
          "name" : "quote",
          "type" : "Separator"
         }
        ],
        "endline" : 894
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n\n Returns:\n      If $(D Contents) is a struct, will be filled with record data.\n\n      If $(D Contents) is a class, will be filled with record data.\n\n      If $(D Contents) is a associative array, will be filled\n      with record data.\n\n      If $(D Contents) is non-struct, a $(LREF CsvRecord) will be\n      returned.\n     \n",
        "line" : 911,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 925
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n     \n",
        "line" : 930,
        "type" : "bool()",
        "endline" : 933
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the\n       row's length does not match the previous length.\n     \n",
        "line" : 944,
        "type" : "void()",
        "endline" : 976
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 978,
        "type" : "void()",
        "endline" : 1054
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1057_588",
    "kind" : "function",
    "line" : 1057,
    "endline" : 1074
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1076,
    "name" : "CsvRecord",
    "parameters" : [
     {
      "name" : "Contents",
      "kind" : "type"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Separator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "CsvRecord",
      "kind" : "struct",
      "line" : 1076,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 1078,
        "type" : "Input!(Range, ErrorLevel)*"
       },
       {
        "name" : "_separator",
        "kind" : "variable",
        "line" : 1079,
        "type" : "Separator"
       },
       {
        "name" : "_quote",
        "kind" : "variable",
        "line" : 1080,
        "type" : "Separator"
       },
       {
        "name" : "curContentsoken",
        "kind" : "variable",
        "line" : 1081,
        "type" : "Contents"
       },
       {
        "name" : "_front",
        "kind" : "variable",
        "line" : 1082,
        "type" : "typeof(appender!(dchar[])())"
       },
       {
        "name" : "_empty",
        "kind" : "variable",
        "line" : 1083,
        "deco" : "b"
       },
       {
        "name" : "_popCount",
        "kind" : "variable",
        "line" : 1084,
        "type" : "size_t[]"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1094,
        "type" : "(Input!(Range, ErrorLevel)* input, Separator delimiter, Separator quote, size_t[] indices)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Input!(Range, ErrorLevel)*"
         },
         {
          "name" : "delimiter",
          "type" : "Separator"
         },
         {
          "name" : "quote",
          "type" : "Separator"
         },
         {
          "name" : "indices",
          "type" : "size_t[]"
         }
        ],
        "endline" : 1121
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n     \n",
        "line" : 1126,
        "type" : "Contents()",
        "endline" : 1130
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n     \n",
        "line" : 1135,
        "type" : "bool()",
        "endline" : 1138
       },
       {
        "name" : "recordEnd",
        "kind" : "function",
        "line" : 1144,
        "type" : "bool()",
        "endline" : 1153
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n Part of an input range as defined by $(XREF range, isInputRange).\n\n Throws:\n       $(LREF CSVException) When a quote is found in an unquoted field,\n       data continues after a closing quote, the quoted field was not\n       closed before data was empty, a conversion failed, or when the\n       row's length does not match the previous length.\n     \n",
        "line" : 1165,
        "type" : "void()",
        "endline" : 1204
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 1209,
        "type" : "void(size_t skipNum)",
        "parameters" : [
         {
          "name" : "skipNum",
          "type" : "size_t"
         }
        ],
        "endline" : 1233
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 1235,
        "type" : "void()",
        "endline" : 1272
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Lower level control over parsing CSV\n\n This function consumes the input. After each call the input will\n start with either a delimiter or record break (\\n, \\r\\n, \\r) which\n must be removed for subsequent calls.\n\n -------\n string str = \"65,63\\n123,3673\";\n\n auto a = appender!(char[])();\n\n csvNextToken(str,a,',','\"');\n assert(a.data == \"65\");\n assert(str == \",63\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"63\");\n assert(str == \"\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"123\");\n assert(str == \",3673\");\n -------\n\n params:\n       input = Any CSV input\n       ans   = The first field in the input\n       sep   = The character to represent a comma in the specification\n       quote = The character to represent a quote in the specification\n       startQuoted = Whether the input should be considered to already be in\n quotes\n\n Throws:\n       $(LREF IncompleteCellException) When a quote is found in an unquoted\n       field, data continues after a closing quote, or the quoted field was\n       not closed before data was empty.\n \n",
    "line" : 1317,
    "name" : "csvNextToken",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "ErrorLevel",
      "kind" : "value",
      "deco" : "E3std3csv9Malformed",
      "defaultValue" : "Malformed.throwException"
     },
     {
      "name" : "Separator",
      "kind" : "type"
     },
     {
      "name" : "Output",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "csvNextToken",
      "kind" : "function",
      "comment" : "\n Lower level control over parsing CSV\n\n This function consumes the input. After each call the input will\n start with either a delimiter or record break (\\n, \\r\\n, \\r) which\n must be removed for subsequent calls.\n\n -------\n string str = \"65,63\\n123,3673\";\n\n auto a = appender!(char[])();\n\n csvNextToken(str,a,',','\"');\n assert(a.data == \"65\");\n assert(str == \",63\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"63\");\n assert(str == \"\\n123,3673\");\n\n str.popFront();\n a.shrinkTo(0);\n csvNextToken(str,a,',','\"');\n assert(a.data == \"123\");\n assert(str == \",3673\");\n -------\n\n params:\n       input = Any CSV input\n       ans   = The first field in the input\n       sep   = The character to represent a comma in the specification\n       quote = The character to represent a quote in the specification\n       startQuoted = Whether the input should be considered to already be in\n quotes\n\n Throws:\n       $(LREF IncompleteCellException) When a quote is found in an unquoted\n       field, data continues after a closing quote, or the quoted field was\n       not closed before data was empty.\n \n",
      "line" : 1317,
      "type" : "void(ref Range input, ref Output ans, Separator sep, Separator quote, bool startQuoted = false)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "ans",
        "type" : "Output",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "sep",
        "type" : "Separator"
       },
       {
        "name" : "quote",
        "type" : "Separator"
       },
       {
        "name" : "startQuoted",
        "deco" : "b",
        "default" : "false"
       }
      ],
      "endline" : 1417
     }
    ]
   },
   {
    "name" : "__unittestL1420_589",
    "kind" : "function",
    "line" : 1420,
    "endline" : 1461
   },
   {
    "name" : "__unittestL1461_590",
    "kind" : "function",
    "line" : 1461,
    "endline" : 1502
   },
   {
    "name" : "__unittestL1502_591",
    "kind" : "function",
    "line" : 1502,
    "endline" : 1516
   },
   {
    "name" : "__unittestL1516_592",
    "kind" : "function",
    "line" : 1516,
    "endline" : 1559
   },
   {
    "name" : "__unittestL1559_593",
    "kind" : "function",
    "line" : 1559,
    "endline" : 1587
   },
   {
    "name" : "__unittestL1587_594",
    "kind" : "function",
    "line" : 1587,
    "endline" : 1618
   }
  ]
 },
 {
  "name" : "std.datetime",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/datetime.d",
  "comment" : "\n    Module containing Date/Time functionality.\n\n    This module provides:\n    $(UL\n        $(LI Types to represent points in time: $(D SysTime), $(D Date),\n             $(D TimeOfDay), and $(D DateTime).)\n        $(LI Types to represent intervals of time.)\n        $(LI Types to represent ranges over intervals of time.)\n        $(LI Types to represent time zones (used by $(D SysTime)).)\n        $(LI A platform-independent, high precision stopwatch type:\n             $(D StopWatch))\n        $(LI Benchmarking functions.)\n        $(LI Various helper functions.)\n    )\n\n    Closely related to std.datetime is <a href=\"core_time.html\">$(D core.time)</a>,\n    and some of the time types used in std.datetime come from there - such as\n    $(CXREF time, Duration), $(CXREF time, TickDuration), and\n    $(CXREF time, FracSec).\n    core.time is publically imported into std.datetime, it isn't necessary\n    to import it separately.\n\n    Three of the main concepts used in this module are time points, time\n    durations, and time intervals.\n\n    A time point is a specific point in time. e.g. January 5th, 2010\n    or 5:00.\n\n    A time duration is a length of time with units. e.g. 5 days or 231 seconds.\n\n    A time interval indicates a period of time associated with a fixed point in\n    time. It is either two time points associated with each other,\n    indicating the time starting at the first point up to, but not including,\n    the second point - e.g. [January 5th, 2010 - March 10th, 2010$(RPAREN) - or\n    it is a time point and a time duration associated with one another. e.g.\n    January 5th, 2010 and 5 days, indicating [January 5th, 2010 -\n    January 10th, 2010$(RPAREN).\n\n    Various arithmetic operations are supported between time points and\n    durations (e.g. the difference between two time points is a time duration),\n    and ranges can be gotten from time intervals, so range-based operations may\n    be done on a series of time points.\n\n    The types that the typical user is most likely to be interested in are\n    $(D Date) (if they want dates but don't care about time), $(D DateTime)\n    (if they want dates and times but don't care about time zones), $(D SysTime)\n    (if they want the date and time from the OS and/or do care about time\n    zones), and StopWatch (a platform-independent, high precision stop watch).\n    $(D Date) and $(D DateTime) are optimized for calendar-based operations,\n    while $(D SysTime) is designed for dealing with time from the OS. Check out\n    their specific documentation for more details.\n\n    To get the current time, use $(D Clock.currTime). It will return the current\n    time as a $(D SysTime). To print it, $(D toString) is\n    sufficient, but if using $(D toISOString), $(D toISOExtString), or\n    $(D toSimpleString), use the corresponding $(D fromISOString),\n    $(D fromISOExtString), or $(D fromISOExtString) to create a\n    $(D SysTime) from the string.\n\n--------------------\nauto currentTime = Clock.currTime();\nauto timeString = currentTime.toISOExtString();\nauto restoredTime = SysTime.fromISOExtString(timeString);\n--------------------\n\n    Various functions take a string (or strings) to represent a unit of time\n    (e.g. $(D convert!(\"days\", \"hours\")(numDays))). The valid strings to use\n    with such functions are $(D \"years\"), $(D \"months\"), $(D \"weeks\"),\n    $(D \"days\"), $(D \"hours\"), $(D \"minutes\"), $(D \"seconds\"),\n    $(D \"msecs\") (milliseconds), $(D \"usecs\") (microseconds),\n    $(D \"hnsecs\") (hecto-nanoseconds - i.e. 100 ns), or some subset thereof.\n    There are a few functions in core.time which take $(D \"nsecs\"), but because\n    nothing in std.datetime has precision greater than hnsecs, and very little\n    in core.time does, no functions in std.datetime accept $(D \"nsecs\").\n    To remember which units are abbreviated and which aren't,\n    all units seconds and greater use their full names, and all\n    sub-second units are abbreviated (since they'd be rather long if they\n    weren't).\n\n    Note:\n        $(D DateTimeException) is an alias for core.time's $(D TimeException),\n        so you don't need to worry about core.time functions and std.datetime\n        functions throwing different exception types (except in the rare case\n        that they throw something other than $(D TimeException) or\n        $(D DateTimeException)).\n\n    See_Also:\n        <a href=\"../intro-to-datetime.html\">Introduction to std&#46;_datetime </a><br>\n        $(WEB en.wikipedia.org/wiki/ISO_8601, ISO 8601)<br>\n        $(WEB en.wikipedia.org/wiki/Tz_database,\n              Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones,\n              List of Time Zones)<br>\n\n    Copyright: Copyright 2010 - 2011\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   Jonathan M Davis and Kato Shoichi\n    Source:    $(PHOBOSSRC std/_datetime.d)\n",
  "members" : [
   {
    "name" : "core.time",
    "kind" : "import",
    "line" : 105
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 107,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.time",
    "kind" : "import",
    "line" : 108,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 110,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 111,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 112,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 113,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 114,
    "protection" : "private"
   },
   {
    "name" : "std.file",
    "kind" : "import",
    "line" : 115,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 116,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 117,
    "protection" : "private"
   },
   {
    "name" : "std.path",
    "kind" : "import",
    "line" : 118,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 119,
    "protection" : "private"
   },
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 120,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 121,
    "protection" : "private"
   },
   {
    "name" : "std.system",
    "kind" : "import",
    "line" : 122,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 123,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 124,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 125,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.arpa.inet",
    "kind" : "import",
    "line" : 135,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.stdlib",
    "kind" : "import",
    "line" : 136,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.time",
    "kind" : "import",
    "line" : 137,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.time",
    "kind" : "import",
    "line" : 138,
    "protection" : "private"
   },
   {
    "name" : "stds_indexOf",
    "kind" : "alias",
    "protection" : "private",
    "line" : 154
   },
   {
    "name" : "__unittestL156_595",
    "kind" : "function",
    "line" : 156,
    "endline" : 162
   },
   {
    "name" : "__unittestL162_596",
    "kind" : "function",
    "line" : 162,
    "endline" : 170
   },
   {
    "name" : "__unittestL170_597",
    "kind" : "function",
    "line" : 170,
    "endline" : 193
   },
   {
    "name" : "Month",
    "kind" : "enum",
    "comment" : "\n    Represents the 12 months of the Gregorian year (January is 1).\n  \n",
    "line" : 193,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "jan",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 193
     },
     {
      "name" : "feb",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 194
     },
     {
      "name" : "mar",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 195
     },
     {
      "name" : "apr",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 196
     },
     {
      "name" : "may",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 197
     },
     {
      "name" : "jun",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 198
     },
     {
      "name" : "jul",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 199
     },
     {
      "name" : "aug",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 200
     },
     {
      "name" : "sep",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 201
     },
     {
      "name" : "oct",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 202
     },
     {
      "name" : "nov",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 203
     },
     {
      "name" : "dec",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 204
     }
    ]
   },
   {
    "name" : "DayOfWeek",
    "kind" : "enum",
    "comment" : "\n    Represents the 7 days of the Gregorian week (Sunday is 0).\n  \n",
    "line" : 210,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "sun",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 210
     },
     {
      "name" : "mon",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 211
     },
     {
      "name" : "tue",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 212
     },
     {
      "name" : "wed",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 213
     },
     {
      "name" : "thu",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 214
     },
     {
      "name" : "fri",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 215
     },
     {
      "name" : "sat",
      "kind" : "enum member",
      "comment" : "\n",
      "line" : 216
     }
    ]
   },
   {
    "name" : "AllowDayOverflow",
    "kind" : "enum",
    "comment" : "\n    In some date calculations, adding months or years can cause the date to fall\n    on a day of the month which is not valid (e.g. February 29th 2001 or\n    June 31st 2000). If overflow is allowed (as is the default), then the month\n    will be incremented accordingly (so, February 29th 2001 would become\n    March 1st 2001, and June 31st 2000 would become July 1st 2000). If overflow\n    is not allowed, then the day will be adjusted to the last valid day in that\n    month (so, February 29th 2001 would become February 28th 2001 and\n    June 31st 2000 would become June 30th 2000).\n\n    AllowDayOverflow only applies to calculations involving months or years.\n  \n",
    "line" : 232,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " No, don't allow day overflow.\n",
      "line" : 234
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " Yes, allow day overflow.\n",
      "line" : 237
     }
    ]
   },
   {
    "name" : "Direction",
    "kind" : "enum",
    "comment" : "\n    Indicates a direction in time. One example of its use is $(D Interval)'s\n    $(D expand) function which uses it to indicate whether the interval should\n    be expanded backwards (into the past), forwards (into the future), or both.\n  \n",
    "line" : 246,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "bwd",
      "kind" : "enum member",
      "comment" : " Backward.\n",
      "line" : 248
     },
     {
      "name" : "fwd",
      "kind" : "enum member",
      "comment" : " Forward.\n",
      "line" : 251
     },
     {
      "name" : "both",
      "kind" : "enum member",
      "comment" : " Both backward and forward.\n",
      "line" : 254
     }
    ]
   },
   {
    "name" : "PopFirst",
    "kind" : "enum",
    "comment" : "\n    Used to indicate whether $(D popFront) should be called immediately upon\n    creating a range. The idea is that for some functions used to generate a\n    range for an interval, $(D front) is not necessarily a time point which\n    would ever be generated by the range. To get the first time point\n    in the range to match what the function generates, then use\n    $(D PopFirst.yes) to indicate that the range should have $(D popFront)\n    called on it before the range is returned so that $(D front) is a time point\n    which the function would generate.\n\n    For instance, if the function used to generate a range of time points\n    generated successive Easters (i.e. you're iterating over all of the Easters\n    within the interval), the initial date probably isn't an Easter. Using\n    $(D PopFirst.yes) would tell the function which returned the\n    range that $(D popFront) was to be called so that front would then be\n    an Easter - the next one generated by the function (which when\n    iterating forward would be the Easter following the original $(D front),\n    while when iterating backward, it would be the Easter prior to the\n    original $(D front)). If $(D PopFirst.no) were used, then $(D front) would\n    remain the original time point and it would not necessarily be a time point\n    which would be generated by the range-generating function (which in many\n    cases is exactly what is desired -\n    e.g. if iterating over every day starting at the beginning\n    of the interval).\n  \n",
    "line" : 283,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " No, don't call popFront() before returning the range.\n",
      "line" : 285
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " Yes, call popFront() before returning the range.\n",
      "line" : 288
     }
    ]
   },
   {
    "name" : "AutoStart",
    "kind" : "enum",
    "comment" : "\n   Used by StopWatch to indicate whether it should start immediately upon\n   construction.\n  \n",
    "line" : 296,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " No, don't start the StopWatch when it is constructed.\n",
      "line" : 298
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " Yes, do start the StopWatch when it is constructed.\n",
      "line" : 301
     }
    ]
   },
   {
    "name" : "timeStrings",
    "kind" : "variable",
    "comment" : "\n    Array of the strings representing time units, starting with the smallest\n    unit and going to the largest. It does not include $(D \"nsecs\").\n\n   Includes $(D \"hnsecs\") (hecto-nanoseconds (100 ns)),\n   $(D \"usecs\") (microseconds), $(D \"msecs\") (milliseconds), $(D \"seconds\"),\n   $(D \"minutes\"), $(D \"hours\"), $(D \"days\"), $(D \"weeks\"), $(D \"months\"), and\n   $(D \"years\")\n  \n",
    "line" : 313,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAAa",
    "originalType" : "string[]",
    "init" : "[\"hnsecs\", \"usecs\", \"msecs\", \"seconds\", \"minutes\", \"hours\", \"days\", \"weeks\", \"months\", \"years\"]"
   },
   {
    "name" : "lastDayNonLeap",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n    Array of integers representing the last days of each month in a year.\n  \n",
    "line" : 324,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG13i",
    "originalType" : "int[13]",
    "init" : "[0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365]"
   },
   {
    "name" : "lastDayLeap",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n    Array of integers representing the last days of each month in a leap year.\n  \n",
    "line" : 329,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG13i",
    "originalType" : "int[13]",
    "init" : "[0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]"
   },
   {
    "name" : "longMonthNames",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n    Array of the long names of each month.\n  \n",
    "line" : 334,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG12Aa",
    "originalType" : "string[12]",
    "init" : "[\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]"
   },
   {
    "name" : "shortMonthNames",
    "kind" : "variable",
    "protection" : "private",
    "comment" : "\n    Array of the short (three letter) names of each month.\n  \n",
    "line" : 352,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG12Aa",
    "originalType" : "string[12]",
    "init" : "[\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]"
   },
   {
    "name" : "DateTimeException",
    "kind" : "alias",
    "comment" : "\n    Exception type used by std.datetime. It's an alias to TimeException, which\n    is what core.time uses. Either can be caught without concern about which\n    module it came from.\n  \n",
    "line" : 376,
    "deco" : "C4core4time13TimeException"
   },
   {
    "name" : "Clock",
    "kind" : "class",
    "comment" : "\n    Effectively a namespace to make it clear that the methods it contains are\n    getting the time from the system clock. It cannot be instantiated.\n \n",
    "line" : 383,
    "members" : [
     {
      "name" : "currTime",
      "kind" : "function",
      "comment" : "\n        Returns the current time in the given time zone.\n\n        Throws:\n            $(D ErrnoException) (on Posix) or $(D Exception) (on Windows)\n            if it fails to get the time of day.\n      \n",
      "line" : 393,
      "storageClass" : [
       "static"
      ],
      "deco" : "FyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
      "originalType" : "SysTime(immutable TimeZone tz = LocalTime())",
      "parameters" : [
       {
        "name" : "tz",
        "deco" : "yC3std8datetime8TimeZone",
        "default" : "cast(immutable(TimeZone))opCall()"
       }
      ],
      "endline" : 396
     },
     {
      "name" : "__unittestL398_598",
      "kind" : "function",
      "line" : 398,
      "endline" : 429
     },
     {
      "name" : "currStdTime",
      "kind" : "function",
      "comment" : "\n        Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the\n        current time.\n\n        Throws:\n            $(D DateTimeException) if it fails to get the time.\n      \n",
      "line" : 430,
      "storageClass" : [
       "static",
       "@property",
       "@trusted"
      ],
      "deco" : "FNdNeZl",
      "originalType" : "long()",
      "endline" : 466
     },
     {
      "name" : "currSystemTick",
      "kind" : "function",
      "comment" : "\n        The current system tick. The number of ticks per second varies from\n        system to system. currSystemTick uses a monotonic clock, so it's\n        intended for precision timing by comparing relative time values, not\n        for getting the current system time.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or Linux.\n\n        Throws:\n            $(D DateTimeException) if it fails to get the time.\n      \n",
      "line" : 485,
      "storageClass" : [
       "static",
       "@property",
       "@safe"
      ],
      "deco" : "FNdNfZS4core4time12TickDuration",
      "originalType" : "TickDuration()",
      "endline" : 488
     },
     {
      "name" : "__unittestL490_599",
      "kind" : "function",
      "line" : 490,
      "endline" : 510
     },
     {
      "name" : "currAppTick",
      "kind" : "function",
      "comment" : "\n        The current number of system ticks since the application started.\n        The number of ticks per second varies from system to system.\n        This uses a monotonic clock.\n\n        Warning:\n            On some systems, the monotonic clock may stop counting when\n            the computer goes to sleep or hibernates. So, the monotonic\n            clock could be off if that occurs. This is known to happen\n            on Mac OS X. It has not been tested whether it occurs on\n            either Windows or on Linux.\n\n        Throws:\n            $(D DateTimeException) if it fails to get the time.\n      \n",
      "line" : 511,
      "storageClass" : [
       "static",
       "@property",
       "@safe"
      ],
      "deco" : "FNdNfZS4core4time12TickDuration",
      "originalType" : "TickDuration()",
      "endline" : 514
     },
     {
      "name" : "__unittestL516_600",
      "kind" : "function",
      "line" : 516,
      "endline" : 525
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 527,
      "storageClass" : [
       "@disable"
      ],
      "deco" : "FZC3std8datetime5Clock",
      "originalType" : "()",
      "endline" : 527
     }
    ]
   },
   {
    "name" : "SysTime",
    "kind" : "struct",
    "comment" : "\n    $(D SysTime) is the type used to get the current time from the\n    system or doing anything that involves time zones. Unlike\n    $(D DateTime), the time zone is an integral part of $(D SysTime) (though for\n    local time applications, time zones can be ignored and\n    it will work, since it defaults to using the local time zone). It holds its\n    internal time in std time (hnsecs since midnight, January 1st, 1 A.D. UTC),\n    so it interfaces well with the system time. However, that means that, unlike\n    $(D DateTime), it is not optimized for calendar-based operations, and\n    getting individual units from it such as years or days is going to involve\n    conversions and be less efficient.\n\n    For calendar-based operations that don't\n    care about time zones, then $(D DateTime) would be the type to\n    use. For system time, use $(D SysTime).\n\n    $(D Clock.currTime) will return the current time as a $(D SysTime).\n    To convert a $(D SysTime) to a $(D Date) or $(D DateTime), simply cast\n    it. To convert a $(D Date) or $(D DateTime) to a\n    $(D SysTime), use $(D SysTime)'s constructor, and pass in the\n    intended time zone with it (or don't pass in a $(D TimeZone), and the local\n    time zone will be used). Be aware, however, that converting from a\n    $(D DateTime) to a $(D SysTime) will not necessarily be 100% accurate due to\n    DST (one hour of the year doesn't exist and another occurs twice).\n    To not risk any conversion errors, keep times as\n    $(D SysTime)s. Aside from DST though, there shouldn't be any conversion\n    problems.\n\n    For using time zones other than local time or UTC, use\n    $(D PosixTimeZone) on Posix systems (or on Windows, if providing the TZ\n    Database files), and use $(D WindowsTimeZone) on Windows systems.\n    The time in $(D SysTime) is kept internally in hnsecs from midnight,\n    January 1st, 1 A.D. UTC. Conversion error cannot happen when changing\n    the time zone of a $(D SysTime). $(D LocalTime) is the $(D TimeZone) class\n    which represents the local time, and $(D UTC) is the $(D TimeZone) class\n    which represents UTC. $(D SysTime) uses $(D LocalTime) if no $(D TimeZone)\n    is provided. For more details on time zones, see the documentation for\n    $(D TimeZone), $(D PosixTimeZone), and $(D WindowsTimeZone).\n\n    $(D SysTime)'s range is from approximately 29,000 B.C. to approximately\n    29,000 A.D.\n  \n",
    "line" : 577,
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            dateTime = The $(D DateTime) to use to set this $(D SysTime)'s\n                       internal std time. As $(D DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            tz       = The $(D TimeZone) to use for this $(D SysTime). If null,\n                       $(D LocalTime) will be used. The given $(D DateTime) is\n                       assumed to be in the given time zone.\n      \n",
      "line" : 589,
      "deco" : "FNbNcxS3std8datetime8DateTimeyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
      "originalType" : "nothrow (in DateTime dateTime, immutable TimeZone tz = null)",
      "parameters" : [
       {
        "name" : "dateTime",
        "deco" : "xS3std8datetime8DateTime"
       },
       {
        "name" : "tz",
        "deco" : "yC3std8datetime8TimeZone",
        "default" : "null"
       }
      ],
      "endline" : 595
     },
     {
      "name" : "__unittestL597_601",
      "kind" : "function",
      "line" : 597,
      "endline" : 632
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            dateTime = The $(D DateTime) to use to set this $(D SysTime)'s\n                       internal std time. As $(D DateTime) has no concept of\n                       time zone, tz is used as its time zone.\n            fracSec  = The fractional seconds portion of the time.\n            tz       = The $(D TimeZone) to use for this $(D SysTime). If null,\n                       $(D LocalTime) will be used. The given $(D DateTime) is\n                       assumed to be in the given time zone.\n\n        Throws:\n            $(D DateTimeException) if $(D fracSec) is negative.\n      \n",
      "line" : 632,
      "deco" : "FNcxS3std8datetime8DateTimexS4core4time7FracSecyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
      "originalType" : "(in DateTime dateTime, in FracSec fracSec, immutable TimeZone tz = null)",
      "parameters" : [
       {
        "name" : "dateTime",
        "deco" : "xS3std8datetime8DateTime"
       },
       {
        "name" : "fracSec",
        "deco" : "xS4core4time7FracSec"
       },
       {
        "name" : "tz",
        "deco" : "yC3std8datetime8TimeZone",
        "default" : "null"
       }
      ],
      "endline" : 653
     },
     {
      "name" : "__unittestL655_602",
      "kind" : "function",
      "line" : 655,
      "endline" : 690
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            date = The $(D Date) to use to set this $(D SysTime)'s internal std\n                   time. As $(D Date) has no concept of time zone, tz is used as\n                   its time zone.\n            tz   = The $(D TimeZone) to use for this $(D SysTime). If null,\n                   $(D LocalTime) will be used. The given $(D Date) is assumed\n                   to be in the given time zone.\n      \n",
      "line" : 690,
      "deco" : "FNbNcxS3std8datetime4DateyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
      "originalType" : "nothrow (in Date date, immutable TimeZone tz = null)",
      "parameters" : [
       {
        "name" : "date",
        "deco" : "xS3std8datetime4Date"
       },
       {
        "name" : "tz",
        "deco" : "yC3std8datetime8TimeZone",
        "default" : "null"
       }
      ],
      "endline" : 703
     },
     {
      "name" : "__unittestL705_603",
      "kind" : "function",
      "line" : 705,
      "endline" : 737
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Note:\n            Whereas the other constructors take in the given date/time, assume\n            that it's in the given time zone, and convert it to hnsecs in UTC\n            since midnight, January 1st, 1 A.D. UTC - i.e. std time - this\n            constructor takes a std time, which is specifically already in UTC,\n            so no conversion takes place. Of course, the various getter\n            properties and functions will use the given time zone's conversion\n            function to convert the results to that time zone, but no conversion\n            of the arguments to this constructor takes place.\n\n        Params:\n            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D. UTC.\n            tz      = The $(D TimeZone) to use for this $(D SysTime). If null,\n                      $(D LocalTime) will be used.\n      \n",
      "line" : 737,
      "deco" : "FNaNbNclyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
      "originalType" : "pure nothrow (long stdTime, immutable TimeZone tz = null)",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       },
       {
        "name" : "tz",
        "deco" : "yC3std8datetime8TimeZone",
        "default" : "null"
       }
      ],
      "endline" : 741
     },
     {
      "name" : "__unittestL743_604",
      "kind" : "function",
      "line" : 743,
      "endline" : 764
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "comment" : "\n        Params:\n            rhs = The $(D SysTime) to assign to this one.\n      \n",
      "line" : 764,
      "deco" : "FNaNbNcKxS3std8datetime7SysTimeZS3std8datetime7SysTime",
      "originalType" : "pure nothrow SysTime(ref const SysTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime7SysTime",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 770
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "comment" : "\n        Params:\n            rhs = The $(D SysTime) to assign to this one.\n      \n",
      "line" : 776,
      "deco" : "FNaNbNcS3std8datetime7SysTimeZS3std8datetime7SysTime",
      "originalType" : "pure nothrow SysTime(SysTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "S3std8datetime7SysTime"
       }
      ],
      "endline" : 782
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n        Checks for equality between this $(D SysTime) and the given\n        $(D SysTime).\n\n        Note that the time zone is ignored. Only the internal\n        std times (which are in UTC) are compared.\n     \n",
      "line" : 791,
      "deco" : "xFNaNbxS3std8datetime7SysTimeZb",
      "originalType" : "const pure nothrow bool(const SysTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime7SysTime"
       }
      ],
      "endline" : 794
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 797,
      "deco" : "xFNaNbKxS3std8datetime7SysTimeZb",
      "originalType" : "const pure nothrow bool(ref const SysTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime7SysTime",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 800
     },
     {
      "name" : "__unittestL802_605",
      "kind" : "function",
      "line" : 802,
      "endline" : 857
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n        Compares this $(D SysTime) with the given $(D SysTime).\n\n        Time zone is irrelevant when comparing $(D SysTime)s.\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
      "line" : 857,
      "deco" : "xFNaNbxS3std8datetime7SysTimeZi",
      "originalType" : "const pure nothrow int(in SysTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime7SysTime"
       }
      ],
      "endline" : 865
     },
     {
      "name" : "__unittestL867_606",
      "kind" : "function",
      "line" : 867,
      "endline" : 930
     },
     {
      "name" : "year",
      "kind" : "function",
      "comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n     \n",
      "line" : 930,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZs",
      "originalType" : "const nothrow short()",
      "endline" : 933
     },
     {
      "name" : "__unittestL935_607",
      "kind" : "function",
      "line" : 935,
      "endline" : 988
     },
     {
      "name" : "year",
      "kind" : "function",
      "comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(D SysTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).year == 1999);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).year == 2010);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).year == -7);\n--------------------\n     \n",
      "line" : 988,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int year)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       }
      ],
      "endline" : 1004
     },
     {
      "name" : "__unittestL1007_608",
      "kind" : "function",
      "line" : 1007,
      "endline" : 1014
     },
     {
      "name" : "__unittestL1014_609",
      "kind" : "function",
      "line" : 1014,
      "endline" : 1074
     },
     {
      "name" : "yearBC",
      "kind" : "function",
      "comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(D DateTimeException) if $(D isAD) is true.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(0, 1, 1, 12, 30, 33)).yearBC == 1);\nassert(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).yearBC == 2);\nassert(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).yearBC == 101);\n--------------------\n     \n",
      "line" : 1074,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZt",
      "originalType" : "const ushort()",
      "endline" : 1077
     },
     {
      "name" : "__unittestL1080_610",
      "kind" : "function",
      "line" : 1080,
      "endline" : 1087
     },
     {
      "name" : "__unittestL1087_611",
      "kind" : "function",
      "line" : 1087,
      "endline" : 1127
     },
     {
      "name" : "yearBC",
      "kind" : "function",
      "comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(D SysTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if a non-positive value is given.\n\n        Examples:\n--------------------\nauto st = SysTime(DateTime(2010, 1, 1, 7, 30, 0));\nst.yearBC = 1;\nassert(st == SysTime(DateTime(0, 1, 1, 7, 30, 0)));\n\nst.yearBC = 10;\nassert(st == SysTime(DateTime(-9, 1, 1, 7, 30, 0)));\n--------------------\n     \n",
      "line" : 1127,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int year)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       }
      ],
      "endline" : 1143
     },
     {
      "name" : "__unittestL1146_612",
      "kind" : "function",
      "line" : 1146,
      "endline" : 1156
     },
     {
      "name" : "__unittestL1156_613",
      "kind" : "function",
      "line" : 1156,
      "endline" : 1223
     },
     {
      "name" : "month",
      "kind" : "function",
      "comment" : "\n        Month of a Gregorian Year.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).month == 7);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).month == 10);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).month == 4);\n--------------------\n     \n",
      "line" : 1223,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZE3std8datetime5Month",
      "originalType" : "const nothrow Month()",
      "endline" : 1226
     },
     {
      "name" : "__unittestL1229_614",
      "kind" : "function",
      "line" : 1229,
      "endline" : 1236
     },
     {
      "name" : "__unittestL1236_615",
      "kind" : "function",
      "line" : 1236,
      "endline" : 1281
     },
     {
      "name" : "month",
      "kind" : "function",
      "comment" : "\n        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(D SysTime)'s month to.\n\n        Throws:\n            $(D DateTimeException) if the given month is not a valid month.\n     \n",
      "line" : 1281,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdE3std8datetime5MonthZv",
      "originalType" : "void(Month month)",
      "parameters" : [
       {
        "name" : "month",
        "deco" : "E3std8datetime5Month"
       }
      ],
      "endline" : 1297
     },
     {
      "name" : "__unittestL1299_618",
      "kind" : "function",
      "line" : 1299,
      "endline" : 1388
     },
     {
      "name" : "day",
      "kind" : "function",
      "comment" : "\n        Day of a Gregorian Month.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).day == 6);\nassert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).day == 4);\nassert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).day == 5);\n--------------------\n     \n",
      "line" : 1388,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZh",
      "originalType" : "const nothrow ubyte()",
      "endline" : 1391
     },
     {
      "name" : "__unittestL1394_619",
      "kind" : "function",
      "line" : 1394,
      "endline" : 1401
     },
     {
      "name" : "__unittestL1401_620",
      "kind" : "function",
      "line" : 1401,
      "endline" : 1447
     },
     {
      "name" : "day",
      "kind" : "function",
      "comment" : "\n        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(D SysTime)'s day to.\n\n        Throws:\n            $(D DateTimeException) if the given day is not a valid day of the\n            current month.\n     \n",
      "line" : 1447,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 1463
     },
     {
      "name" : "__unittestL1465_621",
      "kind" : "function",
      "line" : 1465,
      "endline" : 1539
     },
     {
      "name" : "hour",
      "kind" : "function",
      "comment" : "\n        Hours past midnight.\n     \n",
      "line" : 1539,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZh",
      "originalType" : "const nothrow ubyte()",
      "endline" : 1551
     },
     {
      "name" : "__unittestL1553_622",
      "kind" : "function",
      "line" : 1553,
      "endline" : 1606
     },
     {
      "name" : "hour",
      "kind" : "function",
      "comment" : "\n        Hours past midnight.\n\n        Params:\n            hour = The hours to set this $(D SysTime)'s hour to.\n\n        Throws:\n            $(D DateTimeException) if the given hour are not a valid hour of\n            the day.\n     \n",
      "line" : 1606,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int hour)",
      "parameters" : [
       {
        "name" : "hour",
        "deco" : "i"
       }
      ],
      "endline" : 1625
     },
     {
      "name" : "__unittestL1627_623",
      "kind" : "function",
      "line" : 1627,
      "endline" : 1657
     },
     {
      "name" : "minute",
      "kind" : "function",
      "comment" : "\n        Minutes past the current hour.\n     \n",
      "line" : 1657,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZh",
      "originalType" : "const nothrow ubyte()",
      "endline" : 1671
     },
     {
      "name" : "__unittestL1673_624",
      "kind" : "function",
      "line" : 1673,
      "endline" : 1726
     },
     {
      "name" : "minute",
      "kind" : "function",
      "comment" : "\n        Minutes past the current hour.\n\n        Params:\n            minutes = The minute to set this $(D SysTime)'s minute to.\n\n        Throws:\n            $(D DateTimeException) if the given minute are not a valid minute\n            of an hour.\n     \n",
      "line" : 1726,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int minute)",
      "parameters" : [
       {
        "name" : "minute",
        "deco" : "i"
       }
      ],
      "endline" : 1748
     },
     {
      "name" : "__unittestL1750_625",
      "kind" : "function",
      "line" : 1750,
      "endline" : 1780
     },
     {
      "name" : "second",
      "kind" : "function",
      "comment" : "\n        Seconds past the current minute.\n     \n",
      "line" : 1780,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZh",
      "originalType" : "const nothrow ubyte()",
      "endline" : 1795
     },
     {
      "name" : "__unittestL1797_626",
      "kind" : "function",
      "line" : 1797,
      "endline" : 1850
     },
     {
      "name" : "second",
      "kind" : "function",
      "comment" : "\n        Seconds past the current minute.\n\n        Params:\n            second = The second to set this $(D SysTime)'s second to.\n\n        Throws:\n            $(D DateTimeException) if the given second are not a valid second\n            of a minute.\n     \n",
      "line" : 1850,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int second)",
      "parameters" : [
       {
        "name" : "second",
        "deco" : "i"
       }
      ],
      "endline" : 1874
     },
     {
      "name" : "__unittestL1876_627",
      "kind" : "function",
      "line" : 1876,
      "endline" : 1906
     },
     {
      "name" : "fracSec",
      "kind" : "function",
      "comment" : "\n        Fractional seconds passed the second.\n     \n",
      "line" : 1906,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZS4core4time7FracSec",
      "originalType" : "const nothrow FracSec()",
      "endline" : 1921
     },
     {
      "name" : "__unittestL1923_628",
      "kind" : "function",
      "line" : 1923,
      "endline" : 1976
     },
     {
      "name" : "fracSec",
      "kind" : "function",
      "comment" : "\n        Fractional seconds passed the second.\n\n        Params:\n            fracSec = The fractional seconds to set this $(D SysTimes)'s\n                      fractional seconds to.\n\n        Throws:\n            $(D DateTimeException) if $(D fracSec) is negative.\n     \n",
      "line" : 1976,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdS4core4time7FracSecZv",
      "originalType" : "void(FracSec fracSec)",
      "parameters" : [
       {
        "name" : "fracSec",
        "deco" : "S4core4time7FracSec"
       }
      ],
      "endline" : 2002
     },
     {
      "name" : "__unittestL2004_629",
      "kind" : "function",
      "line" : 2004,
      "endline" : 2034
     },
     {
      "name" : "stdTime",
      "kind" : "function",
      "comment" : "\n        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(D SysTime).\n     \n",
      "line" : 2034,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZl",
      "originalType" : "const pure nothrow long()",
      "endline" : 2037
     },
     {
      "name" : "__unittestL2039_630",
      "kind" : "function",
      "line" : 2039,
      "endline" : 2063
     },
     {
      "name" : "stdTime",
      "kind" : "function",
      "comment" : "\n        The total hnsecs from midnight, January 1st, 1 A.D. UTC. This is the\n        internal representation of $(D SysTime).\n\n        Params:\n            stdTime = The number of hnsecs since January 1st, 1 A.D. UTC.\n     \n",
      "line" : 2063,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdlZv",
      "originalType" : "pure nothrow void(long stdTime)",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 2066
     },
     {
      "name" : "__unittestL2068_631",
      "kind" : "function",
      "line" : 2068,
      "endline" : 2096
     },
     {
      "name" : "timezone",
      "kind" : "function",
      "comment" : "\n        The current time zone of this $(D SysTime). Its internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(D SysTime)'s time zone before returning.\n      \n",
      "line" : 2096,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZyC3std8datetime8TimeZone",
      "originalType" : "const pure nothrow immutable(TimeZone)()",
      "endline" : 2099
     },
     {
      "name" : "timezone",
      "kind" : "function",
      "comment" : "\n        The current time zone of this $(D SysTime). It's internal time is always\n        kept in UTC, so there are no conversion issues between time zones due to\n        DST. Functions which return all or part of the time - such as hours -\n        adjust the time to this $(D SysTime)'s time zone before returning.\n\n        Params:\n            tz = The $(D TimeZone) to set this $(D SysTime)'s time zone to.\n      \n",
      "line" : 2111,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdyC3std8datetime8TimeZoneZv",
      "originalType" : "pure nothrow void(immutable TimeZone timezone)",
      "parameters" : [
       {
        "name" : "timezone",
        "deco" : "yC3std8datetime8TimeZone"
       }
      ],
      "endline" : 2117
     },
     {
      "name" : "dstInEffect",
      "kind" : "function",
      "comment" : "\n        Returns whether DST is in effect for this $(D SysTime).\n      \n",
      "line" : 2123,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 2127
     },
     {
      "name" : "utcOffset",
      "kind" : "function",
      "comment" : "\n        Returns what the offset from UTC is for this $(D SysTime).\n        It includes the DST offset in effect at that time (if any).\n      \n",
      "line" : 2134,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZS4core4time8Duration",
      "originalType" : "const nothrow Duration()",
      "endline" : 2137
     },
     {
      "name" : "toLocalTime",
      "kind" : "function",
      "comment" : "\n        Returns a $(D SysTime) with the same std time as this one, but with\n        $(D LocalTime) as its time zone.\n      \n",
      "line" : 2144,
      "deco" : "xFNbZS3std8datetime7SysTime",
      "endline" : 2147
     },
     {
      "name" : "__unittestL2149_632",
      "kind" : "function",
      "line" : 2149,
      "endline" : 2179
     },
     {
      "name" : "toUTC",
      "kind" : "function",
      "comment" : "\n        Returns a $(D SysTime) with the same std time as this one, but with\n        $(D UTC) as its time zone.\n      \n",
      "line" : 2179,
      "deco" : "xFNaNbZS3std8datetime7SysTime",
      "endline" : 2182
     },
     {
      "name" : "__unittestL2184_633",
      "kind" : "function",
      "line" : 2184,
      "endline" : 2202
     },
     {
      "name" : "toOtherTZ",
      "kind" : "function",
      "comment" : "\n        Returns a $(D SysTime) with the same std time as this one, but with\n        given time zone as its time zone.\n      \n",
      "line" : 2202,
      "deco" : "xFNaNbyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
      "originalType" : "const pure nothrow SysTime(immutable TimeZone tz)",
      "parameters" : [
       {
        "name" : "tz",
        "deco" : "yC3std8datetime8TimeZone"
       }
      ],
      "endline" : 2208
     },
     {
      "name" : "__unittestL2210_634",
      "kind" : "function",
      "line" : 2210,
      "endline" : 2237
     },
     {
      "name" : "toUnixTime",
      "kind" : "function",
      "comment" : "\n        Returns a $(D time_t) which represents the same time as this\n        $(D SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D time_t) is 32 bits, rather than 64, and the result can't fit in a\n        32-bit value, then the closest value that can be held in 32 bits will be\n        used (so $(D time_t.max) if it goes over and $(D time_t.min) if it goes\n        under).\n      \n",
      "line" : 2237,
      "deco" : "xFNaNbZl",
      "originalType" : "const pure nothrow time_t()",
      "endline" : 2240
     },
     {
      "name" : "__unittestL2242_635",
      "kind" : "function",
      "line" : 2242,
      "endline" : 2270
     },
     {
      "name" : "toTimeVal",
      "kind" : "function",
      "comment" : "\n        Returns a $(D timeval) which represents this $(D SysTime).\n\n        Note that like all conversions in std.datetime, this is a truncating\n        conversion.\n\n        If $(D time_t) is 32 bits, rather than 64, and the result can't fit in a\n        32-bit value, then the closest value that can be held in 32 bits will be\n        used for $(D tv_sec). (so $(D time_t.max) if it goes over and\n        $(D time_t.min) if it goes under).\n      \n",
      "line" : 2270,
      "deco" : "xFNaNbZS4core3sys5posix3sys4time7timeval",
      "endline" : 2278
     },
     {
      "name" : "__unittestL2280_636",
      "kind" : "function",
      "line" : 2280,
      "endline" : 2315
     },
     {
      "name" : "toTM",
      "kind" : "function",
      "comment" : "\n        Returns a $(D tm) which represents this $(D SysTime).\n      \n",
      "line" : 2315,
      "deco" : "xFNbZS4core4stdc4time2tm",
      "endline" : 2345
     },
     {
      "name" : "__unittestL2347_637",
      "kind" : "function",
      "line" : 2347,
      "endline" : 2446
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of years or months to this $(D SysTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 30, 33));\nst1.add!\"months\"(11);\nassert(st1 == SysTime(DateTime(2010, 12, 1, 12, 30, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 30, 33));\nst2.add!\"months\"(-11);\nassert(st2 == SysTime(DateTime(2009, 2, 1, 12, 30, 33)));\n\nauto st3 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst3.add!\"years\"(1);\nassert(st3 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st4 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst4.add!\"years\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n--------------------\n      \n",
      "line" : 2446,
      "name" : "add",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "add",
        "kind" : "function",
        "line" : 2446,
        "type" : "nothrow SysTime(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 2474
       }
      ]
     },
     {
      "name" : "__unittestL2477_638",
      "kind" : "function",
      "line" : 2477,
      "endline" : 2500
     },
     {
      "name" : "__unittestL2500_639",
      "kind" : "function",
      "line" : 2500,
      "endline" : 2699
     },
     {
      "name" : "__unittestL2699_640",
      "kind" : "function",
      "line" : 2699,
      "endline" : 2901
     },
     {
      "name" : "__unittestL2901_641",
      "kind" : "function",
      "line" : 2901,
      "endline" : 3244
     },
     {
      "name" : "__unittestL3244_642",
      "kind" : "function",
      "line" : 3244,
      "endline" : 3628
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of years or months to this $(D SysTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D SysTime) 12 months\n        gets the exact same $(D SysTime). However, the days can still be affected\n        due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst1.roll!\"months\"(1);\nassert(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst2.roll!\"months\"(-1);\nassert(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));\n\nauto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst3.roll!\"months\"(1);\nassert(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));\n\nauto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));\n\nauto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst5.roll!\"years\"(1);\nassert(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n--------------------\n      \n",
      "line" : 3628,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of years or months to this $(D SysTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D SysTime) 12 months\n        gets the exact same $(D SysTime). However, the days can still be affected\n        due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D SysTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst1.roll!\"months\"(1);\nassert(st1 == SysTime(DateTime(2010, 2, 1, 12, 33, 33)));\n\nauto st2 = SysTime(DateTime(2010, 1, 1, 12, 33, 33));\nst2.roll!\"months\"(-1);\nassert(st2 == SysTime(DateTime(2010, 12, 1, 12, 33, 33)));\n\nauto st3 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst3.roll!\"months\"(1);\nassert(st3 == SysTime(DateTime(1999, 3, 1, 12, 33, 33)));\n\nauto st4 = SysTime(DateTime(1999, 1, 29, 12, 33, 33));\nst4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(st4 == SysTime(DateTime(1999, 2, 28, 12, 33, 33)));\n\nauto st5 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst5.roll!\"years\"(1);\nassert(st5 == SysTime(DateTime(2001, 3, 1, 12, 30, 33)));\n\nauto st6 = SysTime(DateTime(2000, 2, 29, 12, 30, 33));\nst6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(st6 == SysTime(DateTime(2001, 2, 28, 12, 30, 33)));\n--------------------\n      \n",
        "line" : 3628,
        "type" : "nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 3632
       }
      ]
     },
     {
      "name" : "__unittestL3634_643",
      "kind" : "function",
      "line" : 3634,
      "endline" : 3665
     },
     {
      "name" : "__unittestL3665_644",
      "kind" : "function",
      "line" : 3665,
      "endline" : 3680
     },
     {
      "kind" : "template",
      "line" : 3680,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "line" : 3680,
        "type" : "nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 3705
       }
      ]
     },
     {
      "name" : "__unittestL3708_645",
      "kind" : "function",
      "line" : 3708,
      "endline" : 4100
     },
     {
      "name" : "__unittestL4100_646",
      "kind" : "function",
      "line" : 4100,
      "endline" : 4515
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of units to this $(D SysTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D SysTime) one\n        year's worth of days gets the exact same $(D SysTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\"), $(D \"usecs\"), and\n        $(D \"hnsecs\").\n\n        Note that when rolling msecs, usecs or hnsecs, they all add up to a\n        second. So, for example, rolling 1000 msecs is exactly the same as\n        rolling 100,000 usecs.\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D SysTime).\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));\nst1.roll!\"days\"(1);\nassert(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));\nst1.roll!\"days\"(365);\nassert(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));\nst1.roll!\"days\"(-32);\nassert(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));\n\nauto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));\nst2.roll!\"hours\"(1);\nassert(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));\n\nauto st3 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst3.roll!\"seconds\"(-1);\nassert(st3 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));\n\nauto st4 = SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                   FracSec.from!\"usecs\"(2_400));\nst4.roll!\"usecs\"(-1_200_000);\nassert(st4 == SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                      FracSec.from!\"usecs\"(802_400)));\n--------------------\n      \n",
      "line" : 4515,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of units to this $(D SysTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D SysTime) one\n        year's worth of days gets the exact same $(D SysTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), $(D \"seconds\"), $(D \"msecs\"), $(D \"usecs\"), and\n        $(D \"hnsecs\").\n\n        Note that when rolling msecs, usecs or hnsecs, they all add up to a\n        second. So, for example, rolling 1000 msecs is exactly the same as\n        rolling 100,000 usecs.\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D SysTime).\n\n        Examples:\n--------------------\nauto st1 = SysTime(DateTime(2010, 1, 1, 11, 23, 12));\nst1.roll!\"days\"(1);\nassert(st1 == SysTime(DateTime(2010, 1, 2, 11, 23, 12)));\nst1.roll!\"days\"(365);\nassert(st1 == SysTime(DateTime(2010, 1, 26, 11, 23, 12)));\nst1.roll!\"days\"(-32);\nassert(st1 == SysTime(DateTime(2010, 1, 25, 11, 23, 12)));\n\nauto st2 = SysTime(DateTime(2010, 7, 4, 12, 0, 0));\nst2.roll!\"hours\"(1);\nassert(st2 == SysTime(DateTime(2010, 7, 4, 13, 0, 0)));\n\nauto st3 = SysTime(DateTime(2010, 1, 1, 0, 0, 0));\nst3.roll!\"seconds\"(-1);\nassert(st3 == SysTime(DateTime(2010, 1, 1, 0, 0, 59)));\n\nauto st4 = SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                   FracSec.from!\"usecs\"(2_400));\nst4.roll!\"usecs\"(-1_200_000);\nassert(st4 == SysTime(DateTime(2010, 1, 1, 0, 0, 0),\n                      FracSec.from!\"usecs\"(802_400)));\n--------------------\n      \n",
        "line" : 4515,
        "type" : "nothrow void(long value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         }
        ],
        "endline" : 4540
       }
      ]
     },
     {
      "name" : "__unittestL4543_647",
      "kind" : "function",
      "line" : 4543,
      "endline" : 4571
     },
     {
      "name" : "__unittestL4571_648",
      "kind" : "function",
      "line" : 4571,
      "endline" : 4853
     },
     {
      "kind" : "template",
      "line" : 4853,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "line" : 4853,
        "type" : "nothrow void(long value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         }
        ],
        "endline" : 4893
       }
      ]
     },
     {
      "name" : "__unittestL4896_649",
      "kind" : "function",
      "line" : 4896,
      "endline" : 5131
     },
     {
      "name" : "__unittestL5131_650",
      "kind" : "function",
      "line" : 5131,
      "endline" : 5334
     },
     {
      "name" : "__unittestL5334_651",
      "kind" : "function",
      "line" : 5334,
      "endline" : 5516
     },
     {
      "kind" : "template",
      "line" : 5516,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "line" : 5516,
        "type" : "nothrow void(long value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         }
        ],
        "endline" : 5544
       }
      ]
     },
     {
      "name" : "__unittestL5548_652",
      "kind" : "function",
      "line" : 5548,
      "endline" : 5645
     },
     {
      "name" : "__unittestL5645_653",
      "kind" : "function",
      "line" : 5645,
      "endline" : 5760
     },
     {
      "name" : "__unittestL5760_654",
      "kind" : "function",
      "line" : 5760,
      "endline" : 5904
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
      "line" : 5904,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
        "line" : 5904,
        "type" : "const pure nothrow SysTime(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 5930
       }
      ]
     },
     {
      "name" : "__unittestL5932_655",
      "kind" : "function",
      "line" : 5932,
      "endline" : 6130
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime), as well as assigning the result to this $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
      "line" : 6130,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D SysTime), as well as assigning the result to this $(D SysTime).\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD +) $(TD duration) $(TD -->) $(TD SysTime))\n        $(TR $(TD SysTime) $(TD -) $(TD duration) $(TD -->) $(TD SysTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D SysTime).\n      \n",
        "line" : 6130,
        "type" : "pure nothrow SysTime(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 6154
       }
      ]
     },
     {
      "name" : "__unittestL6156_656",
      "kind" : "function",
      "line" : 6156,
      "endline" : 6333
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the difference between two $(D SysTime)s.\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD -) $(TD SysTime) $(TD -->) $(TD duration))\n        )\n      \n",
      "line" : 6333,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the difference between two $(D SysTime)s.\n\n        The legal types of arithmetic for $(D SysTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD SysTime) $(TD -) $(TD SysTime) $(TD -->) $(TD duration))\n        )\n      \n",
        "line" : 6333,
        "type" : "const pure nothrow Duration(in SysTime rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "SysTime",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 6337
       }
      ]
     },
     {
      "name" : "__unittestL6339_657",
      "kind" : "function",
      "line" : 6339,
      "endline" : 6459
     },
     {
      "name" : "diffMonths",
      "kind" : "function",
      "comment" : "\n        Returns the difference between the two $(D SysTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(D SysTime)s. To get the difference in days or weeks,\n        subtract the $(D SysTime)s themselves and use the $(D Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(D Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(D SysTime) to subtract from this one.\n\n        Examples:\n--------------------\nassert(SysTime(Date(1999, 2, 1)).diffMonths(SysTime(Date(1999, 1, 31))) == 1);\nassert(SysTime(Date(1999, 1, 31)).diffMonths(SysTime(Date(1999, 2, 1))) == -1);\nassert(SysTime(Date(1999, 3, 1)).diffMonths(SysTime(Date(1999, 1, 1))) == 2);\nassert(SysTime(Date(1999, 1, 1)).diffMonths(SysTime(Date(1999, 3, 31))) == -2);\n--------------------\n      \n",
      "line" : 6459,
      "deco" : "xFNbxS3std8datetime7SysTimeZi",
      "originalType" : "const nothrow int(in SysTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime7SysTime"
       }
      ],
      "endline" : 6462
     },
     {
      "name" : "__unittestL6464_658",
      "kind" : "function",
      "line" : 6464,
      "endline" : 6495
     },
     {
      "name" : "isLeapYear",
      "kind" : "function",
      "comment" : "\n        Whether this $(D SysTime) is in a leap year.\n     \n",
      "line" : 6495,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 6498
     },
     {
      "name" : "__unittestL6500_659",
      "kind" : "function",
      "line" : 6500,
      "endline" : 6517
     },
     {
      "name" : "dayOfWeek",
      "kind" : "function",
      "comment" : "\n        Day of the week this $(D SysTime) is on.\n      \n",
      "line" : 6517,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZE3std8datetime9DayOfWeek",
      "originalType" : "const nothrow DayOfWeek()",
      "endline" : 6520
     },
     {
      "name" : "__unittestL6522_660",
      "kind" : "function",
      "line" : 6522,
      "endline" : 6546
     },
     {
      "name" : "dayOfYear",
      "kind" : "function",
      "comment" : "\n        Day of the year this $(D SysTime) is on.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 1, 1, 12, 22, 7)).dayOfYear == 1);\nassert(SysTime(DateTime(1999, 12, 31, 7, 2, 59)).dayOfYear == 365);\nassert(SysTime(DateTime(2000, 12, 31, 21, 20, 0)).dayOfYear == 366);\n--------------------\n      \n",
      "line" : 6546,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZt",
      "originalType" : "const nothrow ushort()",
      "endline" : 6549
     },
     {
      "name" : "__unittestL6551_661",
      "kind" : "function",
      "line" : 6551,
      "endline" : 6577
     },
     {
      "name" : "dayOfYear",
      "kind" : "function",
      "comment" : "\n        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(D SysTime) is on.\n      \n",
      "line" : 6577,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdiZv",
      "originalType" : "void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 6589
     },
     {
      "name" : "__unittestL6591_662",
      "kind" : "function",
      "line" : 6591,
      "endline" : 6622
     },
     {
      "name" : "dayOfGregorianCal",
      "kind" : "function",
      "comment" : "\n        The Xth day of the Gregorian Calendar that this $(D SysTime) is on.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1, 1, 1, 0, 0, 0)).dayOfGregorianCal == 1);\nassert(SysTime(DateTime(1, 12, 31, 23, 59, 59)).dayOfGregorianCal == 365);\nassert(SysTime(DateTime(2, 1, 1, 2, 2, 2)).dayOfGregorianCal == 366);\n\nassert(SysTime(DateTime(0, 12, 31, 7, 7, 7)).dayOfGregorianCal == 0);\nassert(SysTime(DateTime(0, 1, 1, 19, 30, 0)).dayOfGregorianCal == -365);\nassert(SysTime(DateTime(-1, 12, 31, 4, 7, 0)).dayOfGregorianCal == -366);\n\nassert(SysTime(DateTime(2000, 1, 1, 9, 30, 20)).dayOfGregorianCal == 730_120);\nassert(SysTime(DateTime(2010, 12, 31, 15, 45, 50)).dayOfGregorianCal == 734_137);\n--------------------\n     \n",
      "line" : 6622,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZi",
      "originalType" : "const nothrow int()",
      "endline" : 6636
     },
     {
      "name" : "__unittestL6638_663",
      "kind" : "function",
      "line" : 6638,
      "endline" : 6823
     },
     {
      "name" : "__unittestL6823_664",
      "kind" : "function",
      "line" : 6823,
      "endline" : 7012
     },
     {
      "name" : "dayOfGregorianCal",
      "kind" : "function",
      "comment" : "\n        The Xth day of the Gregorian Calendar that this $(D SysTime) is on.\n        Setting this property does not affect the time portion of $(D SysTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(D SysTime)\n                   to.\n\n        Examples:\n--------------------\nauto st = SysTime(DateTime(0, 0, 0, 12, 0, 0));\nst.dayOfGregorianCal = 1;\nassert(st == SysTime(DateTime(1, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 365;\nassert(st == SysTime(DateTime(1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 366;\nassert(st == SysTime(DateTime(2, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 0;\nassert(st == SysTime(DateTime(0, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = -365;\nassert(st == SysTime(DateTime(-0, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = -366;\nassert(st == SysTime(DateTime(-1, 12, 31, 12, 0, 0)));\n\nst.dayOfGregorianCal = 730_120;\nassert(st == SysTime(DateTime(2000, 1, 1, 12, 0, 0)));\n\nst.dayOfGregorianCal = 734_137;\nassert(st == SysTime(DateTime(2010, 12, 31, 12, 0, 0)));\n--------------------\n     \n",
      "line" : 7012,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNbNdiZv",
      "originalType" : "nothrow void(int days)",
      "parameters" : [
       {
        "name" : "days",
        "deco" : "i"
       }
      ],
      "endline" : 7029
     },
     {
      "name" : "__unittestL7031_665",
      "kind" : "function",
      "line" : 7031,
      "endline" : 7258
     },
     {
      "name" : "isoWeek",
      "kind" : "function",
      "comment" : "\n        The ISO 8601 week of the year that this $(D SysTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date).\n      \n",
      "line" : 7258,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZh",
      "originalType" : "const nothrow ubyte()",
      "endline" : 7261
     },
     {
      "name" : "__unittestL7263_666",
      "kind" : "function",
      "line" : 7263,
      "endline" : 7303
     },
     {
      "name" : "endOfMonth",
      "kind" : "function",
      "comment" : "\n        $(D SysTime) for the last day in the month that this Date is in.\n        The time portion of endOfMonth is always 23:59:59.9999999.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).endOfMonth ==\n       SysTime(DateTime(1999, 1, 31, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0),\n               FracSec.from!\"msecs\"(24)).endOfMonth ==\n       SysTime(DateTime(1999, 2, 28, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27),\n               FracSec.from!\"usecs\"(5203)).endOfMonth ==\n       SysTime(DateTime(2000, 2, 29, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9),\n               FracSec.from!\"hnsecs\"(12345)).endOfMonth ==\n       SysTime(DateTime(2000, 6, 30, 23, 59, 59),\n               FracSec.from!\"hnsecs\"(9_999_999)));\n--------------------\n      \n",
      "line" : 7303,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZS3std8datetime7SysTime",
      "originalType" : "const nothrow SysTime()",
      "endline" : 7326
     },
     {
      "name" : "__unittestL7328_667",
      "kind" : "function",
      "line" : 7328,
      "endline" : 7387
     },
     {
      "name" : "daysInMonth",
      "kind" : "function",
      "comment" : "\n        The last day in the month that this $(D SysTime) is in.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1999, 1, 6, 0, 0, 0)).daysInMonth == 31);\nassert(SysTime(DateTime(1999, 2, 7, 19, 30, 0)).daysInMonth == 28);\nassert(SysTime(DateTime(2000, 2, 7, 5, 12, 27)).daysInMonth == 29);\nassert(SysTime(DateTime(2000, 6, 4, 12, 22, 9)).daysInMonth == 30);\n--------------------\n      \n",
      "line" : 7387,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZh",
      "originalType" : "const nothrow ubyte()",
      "endline" : 7390
     },
     {
      "name" : "__unittestL7392_668",
      "kind" : "function",
      "line" : 7392,
      "endline" : 7451
     },
     {
      "name" : "isAD",
      "kind" : "function",
      "comment" : "\n        Whether the current year is a date in A.D.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(1, 1, 1, 12, 7, 0)).isAD);\nassert(SysTime(DateTime(2010, 12, 31, 0, 0, 0)).isAD);\nassert(!SysTime(DateTime(0, 12, 31, 23, 59, 59)).isAD);\nassert(!SysTime(DateTime(-2010, 1, 1, 2, 2, 2)).isAD);\n--------------------\n      \n",
      "line" : 7451,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 7454
     },
     {
      "name" : "__unittestL7456_669",
      "kind" : "function",
      "line" : 7456,
      "endline" : 7487
     },
     {
      "name" : "julianDay",
      "kind" : "function",
      "comment" : "\n        The julian day for this $(D SysTime) at the given time. For example,\n        prior to noon, 1996-03-31 would be the julian day number 2_450_173, so\n        this function returns 2_450_173, while from noon onward, the julian\n        day number would be 2_450_174, so this function returns 2_450_174.\n      \n",
      "line" : 7487,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZl",
      "originalType" : "const nothrow long()",
      "endline" : 7492
     },
     {
      "name" : "__unittestL7494_670",
      "kind" : "function",
      "line" : 7494,
      "endline" : 7534
     },
     {
      "name" : "modJulianDay",
      "kind" : "function",
      "comment" : "\n        The modified julian day for any time on this date (since, the modified\n        julian day changes at midnight).\n      \n",
      "line" : 7534,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZl",
      "originalType" : "const nothrow long()",
      "endline" : 7537
     },
     {
      "name" : "__unittestL7539_671",
      "kind" : "function",
      "line" : 7539,
      "endline" : 7560
     },
     {
      "kind" : "template",
      "comment" : "\n        Returns a $(D Date) equivalent to this $(D SysTime).\n      \n",
      "line" : 7560,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "comment" : "\n        Returns a $(D Date) equivalent to this $(D SysTime).\n      \n",
        "line" : 7560,
        "type" : "const nothrow Date()",
        "endline" : 7564
       }
      ]
     },
     {
      "name" : "__unittestL7566_672",
      "kind" : "function",
      "line" : 7566,
      "endline" : 7597
     },
     {
      "kind" : "template",
      "comment" : "\n        Returns a $(D DateTime) equivalent to this $(D SysTime).\n      \n",
      "line" : 7597,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "comment" : "\n        Returns a $(D DateTime) equivalent to this $(D SysTime).\n      \n",
        "line" : 7597,
        "type" : "const nothrow DateTime()",
        "endline" : 7619
       }
      ]
     },
     {
      "name" : "__unittestL7621_673",
      "kind" : "function",
      "line" : 7621,
      "endline" : 7659
     },
     {
      "kind" : "template",
      "comment" : "\n        Returns a $(D TimeOfDay) equivalent to this $(D SysTime).\n      \n",
      "line" : 7659,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "comment" : "\n        Returns a $(D TimeOfDay) equivalent to this $(D SysTime).\n      \n",
        "line" : 7659,
        "type" : "const nothrow TimeOfDay()",
        "endline" : 7678
       }
      ]
     },
     {
      "name" : "__unittestL7680_674",
      "kind" : "function",
      "line" : 7680,
      "endline" : 7713
     },
     {
      "kind" : "template",
      "line" : 7713,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "line" : 7713,
        "type" : "const pure nothrow SysTime()",
        "endline" : 7717
       }
      ]
     },
     {
      "name" : "toISOString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D SysTime) to a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds and TZ is time\n        zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(D SysTime)'s time zone is $(D LocalTime), then TZ is empty.\n        If its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the\n        offset from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC\n        is $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               FracSec.from!\"msecs\"(24)).toISOString() ==\n       \"19981225T021500.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               FracSec.from!\"hnsecs\"(520_920)).toISOString() ==\n       \"-00040105T000002.052092\");\n--------------------\n      \n",
      "line" : 7755,
      "deco" : "xFNbZAya",
      "endline" : 7792
     },
     {
      "name" : "__unittestL7794_675",
      "kind" : "function",
      "line" : 7794,
      "endline" : 7900
     },
     {
      "name" : "toISOExtString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D SysTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(D SysTime)'s time zone is $(D LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               FracSec.from!\"msecs\"(24)).toISOExtString() ==\n       \"1998-12-25T02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               FracSec.from!\"hnsecs\"(520_920)).toISOExtString() ==\n       \"-0004-01-05T00:00:02.052092\");\n--------------------\n      \n",
      "line" : 7900,
      "deco" : "xFNbZAya",
      "endline" : 7937
     },
     {
      "name" : "__unittestL7939_676",
      "kind" : "function",
      "line" : 7939,
      "endline" : 8043
     },
     {
      "name" : "toSimpleString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D SysTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds and TZ\n        is the time zone).\n\n        Note that the number of digits in the fractional seconds varies with the\n        number of fractional seconds. It's a maximum of 7 (which would be\n        hnsecs), but only has as many as are necessary to hold the correct value\n        (so no trailing zeroes), and if there are no fractional seconds, then\n        there is no decimal point.\n\n        If this $(D SysTime)'s time zone is $(D LocalTime), then TZ is empty. If\n        its time zone is $(D UTC), then it is \"Z\". Otherwise, it is the offset\n        from UTC (e.g. +1:00 or -7:00). Note that the offset from UTC is\n        $(I not) enough to uniquely identify the time zone.\n\n        Time zone offsets will be in the form +HH:MM or -HH:MM.\n\n        Examples:\n--------------------\nassert(SysTime(DateTime(2010, 7, 4, 7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(SysTime(DateTime(1998, 12, 25, 2, 15, 0),\n               FracSec.from!\"msecs\"(24)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00.024\");\n\nassert(SysTime(DateTime(0, 1, 5, 23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(SysTime(DateTime(-4, 1, 5, 0, 0, 2),\n               FracSec.from!\"hnsecs\"(520_920)).toSimpleString() ==\n        \"-0004-Jan-05 00:00:02.052092\");\n--------------------\n      \n",
      "line" : 8043,
      "deco" : "xFNbZAya",
      "endline" : 8080
     },
     {
      "name" : "__unittestL8082_677",
      "kind" : "function",
      "line" : 8082,
      "endline" : 8158
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 8158,
      "deco" : "FZAya",
      "endline" : 8161
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D SysTime) to a string.\n      \n",
      "line" : 8169,
      "deco" : "xFNbZAya",
      "endline" : 8172
     },
     {
      "name" : "__unittestL8174_678",
      "kind" : "function",
      "line" : 8174,
      "endline" : 8241
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D SysTime) from a string with the format\n        YYYYMMDDTHHMMSS.FFFFFFFTZ (where F is fractional seconds is the time\n        zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOString) except that\n        trailing zeroes are permitted - including having fractional seconds with\n        all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(D LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(D SysTime) to be a particular time\n        zone, pass in that time zone and the $(D SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n            tz        = The time zone to convert the given time to (no\n                        conversion occurs if null).\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D SysTime) would not be valid.\n\n        Examples:\n--------------------\nassert(SysTime.fromISOString(\"20100704T070612\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOString(\"19981225T021500.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!\"msecs\"(7)));\nassert(SysTime.fromISOString(\"00000105T230959.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!\"usecs\"(20)));\nassert(SysTime.fromISOString(\"-00040105T000002\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOString(\" 20100704T070612 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOString(\"20100704T070612Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOString(\"20100704T070612-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromISOString(\"20100704T070612+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new SimpleTimeZone(dur!\"hours\"(8))));\n--------------------\n      \n",
      "line" : 8241,
      "name" : "fromISOString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOString",
        "kind" : "function",
        "line" : 8241,
        "type" : "SysTime(in S isoString, immutable TimeZone tz = null)",
        "parameters" : [
         {
          "name" : "isoString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "tz",
          "type" : "TimeZone",
          "storageClass" : [
           "immutable"
          ],
          "default" : "null"
         }
        ],
        "endline" : 8293
       }
      ]
     },
     {
      "name" : "__unittestL8295_679",
      "kind" : "function",
      "line" : 8295,
      "endline" : 8468
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D SysTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toISOExtString)\n        except that trailing zeroes are permitted - including having fractional\n        seconds with all zeroes. However, a decimal point with nothing following\n        it is invalid.\n\n        If there is no time zone in the string, then $(D LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(D SysTime) to be a particular time\n        zone, pass in that time zone and the $(D SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n        Params:\n            isoString = A string formatted in the ISO Extended format for dates\n                        and times.\n            tz        = The time zone to convert the given time to (no\n                        conversion occurs if null).\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D SysTime) would not be valid.\n\n        Examples:\n--------------------\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromISOExtString(\"1998-12-25T02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!\"msecs\"(7)));\nassert(SysTime.fromISOExtString(\"0000-01-05T23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!\"usecs\"(20)));\nassert(SysTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromISOExtString(\"2010-07-04T07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new SimpleTimeZone(dur!\"hours\"(8))));\n--------------------\n      \n",
      "line" : 8468,
      "name" : "fromISOExtString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOExtString",
        "kind" : "function",
        "line" : 8468,
        "type" : "SysTime(in S isoExtString, immutable TimeZone tz = null)",
        "parameters" : [
         {
          "name" : "isoExtString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "tz",
          "type" : "TimeZone",
          "storageClass" : [
           "immutable"
          ],
          "default" : "null"
         }
        ],
        "endline" : 8522
       }
      ]
     },
     {
      "name" : "__unittestL8524_680",
      "kind" : "function",
      "line" : 8524,
      "endline" : 8701
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D SysTime) from a string with the format\n        YYYY-MM-DD HH:MM:SS.FFFFFFFTZ (where F is fractional seconds is the\n        time zone). Whitespace is stripped from the given string.\n\n        The exact format is exactly as described in $(D toSimpleString) except\n        that trailing zeroes are permitted - including having fractional seconds\n        with all zeroes. However, a decimal point with nothing following it is\n        invalid.\n\n        If there is no time zone in the string, then $(D LocalTime) is used. If\n        the time zone is \"Z\", then $(D UTC) is used. Otherwise, a\n        $(LREF SimpleTimeZone) which corresponds to the given offset from UTC is\n        used. To get the returned $(D SysTime) to be a particular time\n        zone, pass in that time zone and the $(D SysTime) to be returned\n        will be converted to that time zone (though it will still be read in as\n        whatever time zone is in its string).\n\n        The accepted formats for time zone offsets\n        are +H, -H, +HH, -HH, +H:MM, -H:MM, +HH:MM, and -HH:MM.\n\n\n        Params:\n            simpleString = A string formatted in the way that\n                           $(D toSimpleString) formats dates and times.\n            tz           = The time zone to convert the given time to (no\n                           conversion occurs if null).\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D SysTime) would not be valid.\n\n        Examples:\n--------------------\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\nassert(SysTime.fromSimpleString(\"1998-Dec-25 02:15:00.007\") ==\n       SysTime(DateTime(1998, 12, 25, 2, 15, 0), FracSec.from!\"msecs\"(7)));\nassert(SysTime.fromSimpleString(\"0000-Jan-05 23:09:59.00002\") ==\n       SysTime(DateTime(0, 1, 5, 23, 9, 59), FracSec.from!\"usecs\"(20)));\nassert(SysTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       SysTime(DateTime(-4, 1, 5, 0, 0, 2)));\nassert(SysTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12)));\n\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12Z\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12), UTC()));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12-8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new SimpleTimeZone(dur!\"hours\"(-8))));\nassert(SysTime.fromSimpleString(\"2010-Jul-04 07:06:12+8:00\") ==\n       SysTime(DateTime(2010, 7, 4, 7, 6, 12),\n               new SimpleTimeZone(dur!\"hours\"(8))));\n--------------------\n      \n",
      "line" : 8701,
      "name" : "fromSimpleString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromSimpleString",
        "kind" : "function",
        "line" : 8701,
        "type" : "SysTime(in S simpleString, immutable TimeZone tz = null)",
        "parameters" : [
         {
          "name" : "simpleString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "tz",
          "type" : "TimeZone",
          "storageClass" : [
           "immutable"
          ],
          "default" : "null"
         }
        ],
        "endline" : 8755
       }
      ]
     },
     {
      "name" : "__unittestL8757_681",
      "kind" : "function",
      "line" : 8757,
      "endline" : 8891
     },
     {
      "name" : "min",
      "kind" : "function",
      "comment" : "\n        Returns the $(D SysTime) farthest in the past which is representable\n        by $(D SysTime).\n\n        The $(D SysTime) which is returned is in UTC.\n      \n",
      "line" : 8891,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime7SysTime",
      "originalType" : "pure nothrow SysTime()",
      "endline" : 8894
     },
     {
      "name" : "__unittestL8896_682",
      "kind" : "function",
      "line" : 8896,
      "endline" : 8912
     },
     {
      "name" : "max",
      "kind" : "function",
      "comment" : "\n        Returns the $(D SysTime) farthest in the future which is representable\n        by $(D SysTime).\n\n        The $(D SysTime) which is returned is in UTC.\n      \n",
      "line" : 8912,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime7SysTime",
      "originalType" : "pure nothrow SysTime()",
      "endline" : 8915
     },
     {
      "name" : "__unittestL8917_683",
      "kind" : "function",
      "line" : 8917,
      "endline" : 8927
     },
     {
      "name" : "adjTime",
      "kind" : "function",
      "protection" : "private",
      "line" : 8932,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZl",
      "originalType" : "const nothrow long()",
      "endline" : 8935
     },
     {
      "name" : "adjTime",
      "kind" : "function",
      "protection" : "private",
      "line" : 8941,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNbNdlZv",
      "originalType" : "nothrow void(long adjTime)",
      "parameters" : [
       {
        "name" : "adjTime",
        "deco" : "l"
       }
      ],
      "endline" : 8944
     },
     {
      "name" : "_stdTime",
      "kind" : "variable",
      "protection" : "private",
      "line" : 8956,
      "deco" : "l",
      "offset" : 0
     },
     {
      "name" : "_timezone",
      "kind" : "variable",
      "protection" : "private",
      "line" : 8957,
      "deco" : "S3std8typecons41__T10RebindableTyC3std8datetime8TimeZoneZ10Rebindable",
      "offset" : 8
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std8datetime7SysTimeKxS3std8datetime7SysTimeZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std8datetime7SysTime",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std8datetime7SysTime",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "Date",
    "kind" : "struct",
    "comment" : "\n    Represents a date in the Proleptic Gregorian Calendar ranging from\n    32,768 B.C. to 32,767 A.D. Positive years are A.D. Non-positive years are\n    B.C.\n\n    Year, month, and day are kept separately internally so that $(D Date) is\n    optimized for calendar-based operations.\n\n    $(D Date) uses the Proleptic Gregorian Calendar, so it assumes the Gregorian\n    leap year calculations for its entire length. And, as per\n    $(WEB en.wikipedia.org/wiki/ISO_8601, ISO 8601), it also treats 1 B.C. as\n    year 0. So, 1 B.C. is 0, 2 B.C. is -1, etc. Use $(D yearBC) if want B.C. as\n    a positive integer with 1 B.C. being the year prior to 1 A.D.\n\n    Year 0 is a leap year.\n \n",
    "line" : 8978,
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Throws:\n            $(D DateTimeException) if the resulting $(D Date) would not be valid.\n\n        Params:\n            year  = Year of the Gregorian Calendar. Positive values are A.D.\n                    Non-positive values are B.C. with year 0 being the year\n                    prior to 1 A.D.\n            month = Month of the year.\n            day   = Day of the month.\n     \n",
      "line" : 8992,
      "deco" : "FNaNciiiZS3std8datetime4Date",
      "originalType" : "pure (int year, int month, int day)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       },
       {
        "name" : "month",
        "deco" : "i"
       },
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 9000
     },
     {
      "name" : "__unittestL9002_684",
      "kind" : "function",
      "line" : 9002,
      "endline" : 9070
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            day = The Xth day of the Gregorian Calendar that the constructed\n                  $(D Date) will be for.\n     \n",
      "line" : 9070,
      "deco" : "FNaNbNciZS3std8datetime4Date",
      "originalType" : "pure nothrow (int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 9191
     },
     {
      "name" : "__unittestL9193_685",
      "kind" : "function",
      "line" : 9193,
      "endline" : 9211
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n        Compares this $(D Date) with the given $(D Date).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
      "line" : 9211,
      "deco" : "xFNaNbxS3std8datetime4DateZi",
      "originalType" : "const pure nothrow int(in Date rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime4Date"
       }
      ],
      "endline" : 9229
     },
     {
      "name" : "__unittestL9231_686",
      "kind" : "function",
      "line" : 9231,
      "endline" : 9329
     },
     {
      "name" : "year",
      "kind" : "function",
      "comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Examples:\n--------------------\nassert(Date(1999, 7, 6).year == 1999);\nassert(Date(2010, 10, 4).year == 2010);\nassert(Date(-7, 4, 5).year == -7);\n--------------------\n     \n",
      "line" : 9329,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZs",
      "originalType" : "const pure nothrow short()",
      "endline" : 9332
     },
     {
      "name" : "__unittestL9334_687",
      "kind" : "function",
      "line" : 9334,
      "endline" : 9365
     },
     {
      "name" : "year",
      "kind" : "function",
      "comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this Date's year to.\n\n        Throws:\n            $(D DateTimeException) if the new year is not a leap year and the\n            resulting date would be on February 29th.\n     \n",
      "line" : 9365,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int year)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       }
      ],
      "endline" : 9369
     },
     {
      "name" : "__unittestL9371_688",
      "kind" : "function",
      "line" : 9371,
      "endline" : 9418
     },
     {
      "name" : "yearBC",
      "kind" : "function",
      "comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(D DateTimeException) if $(D isAD) is true.\n\n        Examples:\n--------------------\nassert(Date(0, 1, 1).yearBC == 1);\nassert(Date(-1, 1, 1).yearBC == 2);\nassert(Date(-100, 1, 1).yearBC == 101);\n--------------------\n     \n",
      "line" : 9418,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNdZt",
      "originalType" : "const pure ushort()",
      "endline" : 9426
     },
     {
      "name" : "__unittestL9428_690",
      "kind" : "function",
      "line" : 9428,
      "endline" : 9468
     },
     {
      "name" : "yearBC",
      "kind" : "function",
      "comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(D Date)'s year to.\n\n        Throws:\n            $(D DateTimeException) if a non-positive value is given.\n\n        Examples:\n--------------------\nauto date = Date(2010, 1, 1);\ndate.yearBC = 1;\nassert(date == Date(0, 1, 1));\n\ndate.yearBC = 10;\nassert(date == Date(-9, 1, 1));\n--------------------\n     \n",
      "line" : 9468,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int year)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       }
      ],
      "endline" : 9474
     },
     {
      "name" : "__unittestL9476_692",
      "kind" : "function",
      "line" : 9476,
      "endline" : 9514
     },
     {
      "name" : "month",
      "kind" : "function",
      "comment" : "\n        Month of a Gregorian Year.\n\n        Examples:\n--------------------\nassert(Date(1999, 7, 6).month == 7);\nassert(Date(2010, 10, 4).month == 10);\nassert(Date(-7, 4, 5).month == 4);\n--------------------\n     \n",
      "line" : 9514,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZE3std8datetime5Month",
      "originalType" : "const pure nothrow Month()",
      "endline" : 9517
     },
     {
      "name" : "__unittestL9519_693",
      "kind" : "function",
      "line" : 9519,
      "endline" : 9549
     },
     {
      "name" : "month",
      "kind" : "function",
      "comment" : "\n        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(D Date)'s month to.\n\n        Throws:\n            $(D DateTimeException) if the given month is not a valid month or if\n            the current day would not be valid in the given month.\n     \n",
      "line" : 9549,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdE3std8datetime5MonthZv",
      "originalType" : "pure void(Month month)",
      "parameters" : [
       {
        "name" : "month",
        "deco" : "E3std8datetime5Month"
       }
      ],
      "endline" : 9554
     },
     {
      "name" : "__unittestL9556_694",
      "kind" : "function",
      "line" : 9556,
      "endline" : 9593
     },
     {
      "name" : "day",
      "kind" : "function",
      "comment" : "\n        Day of a Gregorian Month.\n\n        Examples:\n--------------------\nassert(Date(1999, 7, 6).day == 6);\nassert(Date(2010, 10, 4).day == 4);\nassert(Date(-7, 4, 5).day == 5);\n--------------------\n     \n",
      "line" : 9593,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 9596
     },
     {
      "name" : "__unittestL9599_695",
      "kind" : "function",
      "line" : 9599,
      "endline" : 9606
     },
     {
      "name" : "__unittestL9606_696",
      "kind" : "function",
      "line" : 9606,
      "endline" : 9636
     },
     {
      "name" : "day",
      "kind" : "function",
      "comment" : "\n        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(D Date)'s day to.\n\n        Throws:\n            $(D DateTimeException) if the given day is not a valid day of the\n            current month.\n     \n",
      "line" : 9636,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 9640
     },
     {
      "name" : "__unittestL9642_697",
      "kind" : "function",
      "line" : 9642,
      "endline" : 9769
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.add!\"months\"(11);\nassert(d1 == Date(2010, 12, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.add!\"months\"(-11);\nassert(d2 == Date(2009, 2, 1));\n\nauto d3 = Date(2000, 2, 29);\nd3.add!\"years\"(1);\nassert(d3 == Date(2001, 3, 1));\n\nauto d4 = Date(2000, 2, 29);\nd4.add!\"years\"(1, AllowDayOverflow.no);\nassert(d4 == Date(2001, 2, 28));\n--------------------\n      \n",
      "line" : 9769,
      "name" : "add",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "add",
        "kind" : "function",
        "comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n            allowOverflow = Whether the day should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.add!\"months\"(11);\nassert(d1 == Date(2010, 12, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.add!\"months\"(-11);\nassert(d2 == Date(2009, 2, 1));\n\nauto d3 = Date(2000, 2, 29);\nd3.add!\"years\"(1);\nassert(d3 == Date(2001, 3, 1));\n\nauto d4 = Date(2000, 2, 29);\nd4.add!\"years\"(1, AllowDayOverflow.no);\nassert(d4 == Date(2001, 2, 28));\n--------------------\n      \n",
        "line" : 9769,
        "type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 9786
       }
      ]
     },
     {
      "name" : "__unittestL9789_698",
      "kind" : "function",
      "line" : 9789,
      "endline" : 9812
     },
     {
      "name" : "__unittestL9812_699",
      "kind" : "function",
      "line" : 9812,
      "endline" : 9911
     },
     {
      "name" : "__unittestL9911_700",
      "kind" : "function",
      "line" : 9911,
      "endline" : 10006
     },
     {
      "kind" : "template",
      "line" : 10006,
      "name" : "add",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "add",
        "kind" : "function",
        "line" : 10006,
        "type" : "pure nothrow void(long months, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "months",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 10043
       }
      ]
     },
     {
      "name" : "__unittestL10046_701",
      "kind" : "function",
      "line" : 10046,
      "endline" : 10285
     },
     {
      "name" : "__unittestL10285_702",
      "kind" : "function",
      "line" : 10285,
      "endline" : 10563
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D Date) 12 months gets\n        the exact same $(D Date). However, the days can still be affected due to\n        the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.roll!\"months\"(1);\nassert(d1 == Date(2010, 2, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.roll!\"months\"(-1);\nassert(d2 == Date(2010, 12, 1));\n\nauto d3 = Date(1999, 1, 29);\nd3.roll!\"months\"(1);\nassert(d3 == Date(1999, 3, 1));\n\nauto d4 = Date(1999, 1, 29);\nd4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(d4 == Date(1999, 2, 28));\n\nauto d5 = Date(2000, 2, 29);\nd5.roll!\"years\"(1);\nassert(d5 == Date(2001, 3, 1));\n\nauto d6 = Date(2000, 2, 29);\nd6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(d6 == Date(2001, 2, 28));\n--------------------\n      \n",
      "line" : 10563,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of years or months to this $(D Date). A negative\n        number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D Date) 12 months gets\n        the exact same $(D Date). However, the days can still be affected due to\n        the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D Date).\n\n        Examples:\n--------------------\nauto d1 = Date(2010, 1, 1);\nd1.roll!\"months\"(1);\nassert(d1 == Date(2010, 2, 1));\n\nauto d2 = Date(2010, 1, 1);\nd2.roll!\"months\"(-1);\nassert(d2 == Date(2010, 12, 1));\n\nauto d3 = Date(1999, 1, 29);\nd3.roll!\"months\"(1);\nassert(d3 == Date(1999, 3, 1));\n\nauto d4 = Date(1999, 1, 29);\nd4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(d4 == Date(1999, 2, 28));\n\nauto d5 = Date(2000, 2, 29);\nd5.roll!\"years\"(1);\nassert(d5 == Date(2001, 3, 1));\n\nauto d6 = Date(2000, 2, 29);\nd6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(d6 == Date(2001, 2, 28));\n--------------------\n      \n",
        "line" : 10563,
        "type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 10567
       }
      ]
     },
     {
      "name" : "__unittestL10570_703",
      "kind" : "function",
      "line" : 10570,
      "endline" : 10600
     },
     {
      "name" : "__unittestL10600_704",
      "kind" : "function",
      "line" : 10600,
      "endline" : 10613
     },
     {
      "kind" : "template",
      "line" : 10613,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "line" : 10613,
        "type" : "pure nothrow void(long months, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "months",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 10645
       }
      ]
     },
     {
      "name" : "__unittestL10648_705",
      "kind" : "function",
      "line" : 10648,
      "endline" : 10936
     },
     {
      "name" : "__unittestL10936_706",
      "kind" : "function",
      "line" : 10936,
      "endline" : 11227
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of units to this $(D Date). A negative number will\n        subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D Date) one\n        year's worth of days gets the exact same $(D Date).\n\n        The only accepted units are $(D \"days\").\n\n        Params:\n            units = The units to add. Must be $(D \"days\").\n            value = The number of days to add to this $(D Date).\n\n        Examples:\n--------------------\nauto d = Date(2010, 1, 1);\nd.roll!\"days\"(1);\nassert(d == Date(2010, 1, 2));\nd.roll!\"days\"(365);\nassert(d == Date(2010, 1, 26));\nd.roll!\"days\"(-32);\nassert(d == Date(2010, 1, 25));\n--------------------\n      \n",
      "line" : 11227,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of units to this $(D Date). A negative number will\n        subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D Date) one\n        year's worth of days gets the exact same $(D Date).\n\n        The only accepted units are $(D \"days\").\n\n        Params:\n            units = The units to add. Must be $(D \"days\").\n            value = The number of days to add to this $(D Date).\n\n        Examples:\n--------------------\nauto d = Date(2010, 1, 1);\nd.roll!\"days\"(1);\nassert(d == Date(2010, 1, 2));\nd.roll!\"days\"(365);\nassert(d == Date(2010, 1, 26));\nd.roll!\"days\"(-32);\nassert(d == Date(2010, 1, 25));\n--------------------\n      \n",
        "line" : 11227,
        "type" : "pure nothrow void(long days)",
        "parameters" : [
         {
          "name" : "days",
          "deco" : "l"
         }
        ],
        "endline" : 11243
       }
      ]
     },
     {
      "name" : "__unittestL11246_707",
      "kind" : "function",
      "line" : 11246,
      "endline" : 11260
     },
     {
      "name" : "__unittestL11260_708",
      "kind" : "function",
      "line" : 11260,
      "endline" : 11472
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date).\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
      "line" : 11472,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date).\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
        "line" : 11472,
        "type" : "const pure nothrow Date(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 11496
       }
      ]
     },
     {
      "name" : "__unittestL11498_709",
      "kind" : "function",
      "line" : 11498,
      "endline" : 11584
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date), as well as assigning the result to this $(D Date).\n\n        The legal types of arithmetic for $(D Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
      "line" : 11584,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D Date), as well as assigning the result to this $(D Date).\n\n        The legal types of arithmetic for $(D Date) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD +) $(TD duration) $(TD -->) $(TD Date))\n        $(TR $(TD Date) $(TD -) $(TD duration) $(TD -->) $(TD Date))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this $(D Date).\n      \n",
        "line" : 11584,
        "type" : "pure nothrow Date(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 11606
       }
      ]
     },
     {
      "name" : "__unittestL11608_710",
      "kind" : "function",
      "line" : 11608,
      "endline" : 11672
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the difference between two $(D Date)s.\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD -) $(TD Date) $(TD -->) $(TD duration))\n        )\n      \n",
      "line" : 11672,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the difference between two $(D Date)s.\n\n        The legal types of arithmetic for Date using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD Date) $(TD -) $(TD Date) $(TD -->) $(TD duration))\n        )\n      \n",
        "line" : 11672,
        "type" : "const pure nothrow Duration(in Date rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "Date",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 11676
       }
      ]
     },
     {
      "name" : "__unittestL11678_711",
      "kind" : "function",
      "line" : 11678,
      "endline" : 11737
     },
     {
      "name" : "diffMonths",
      "kind" : "function",
      "comment" : "\n        Returns the difference between the two $(D Date)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(D SysTime)s. To get the difference in days or weeks,\n        subtract the $(D SysTime)s themselves and use the $(D Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(D Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either $(D Date) is is irrelevant. It is the difference in the month\n        property combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(D Date) to subtract from this one.\n\n        Examples:\n--------------------\nassert(Date(1999, 2, 1).diffMonths(Date(1999, 1, 31)) == 1);\nassert(Date(1999, 1, 31).diffMonths(Date(1999, 2, 1)) == -1);\nassert(Date(1999, 3, 1).diffMonths(Date(1999, 1, 1)) == 2);\nassert(Date(1999, 1, 1).diffMonths(Date(1999, 3, 31)) == -2);\n--------------------\n      \n",
      "line" : 11737,
      "deco" : "xFNaNbxS3std8datetime4DateZi",
      "originalType" : "const pure nothrow int(in Date rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime4Date"
       }
      ],
      "endline" : 11743
     },
     {
      "name" : "__unittestL11745_712",
      "kind" : "function",
      "line" : 11745,
      "endline" : 11975
     },
     {
      "name" : "isLeapYear",
      "kind" : "function",
      "comment" : "\n        Whether this $(D Date) is in a leap year.\n     \n",
      "line" : 11975,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 11978
     },
     {
      "name" : "__unittestL11980_713",
      "kind" : "function",
      "line" : 11980,
      "endline" : 11997
     },
     {
      "name" : "dayOfWeek",
      "kind" : "function",
      "comment" : "\n        Day of the week this $(D Date) is on.\n      \n",
      "line" : 11997,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZE3std8datetime9DayOfWeek",
      "originalType" : "const pure nothrow DayOfWeek()",
      "endline" : 12000
     },
     {
      "name" : "__unittestL12002_714",
      "kind" : "function",
      "line" : 12002,
      "endline" : 12026
     },
     {
      "name" : "dayOfYear",
      "kind" : "function",
      "comment" : "\n        Day of the year this $(D Date) is on.\n\n        Examples:\n--------------------\nassert(Date(1999, 1, 1).dayOfYear == 1);\nassert(Date(1999, 12, 31).dayOfYear == 365);\nassert(Date(2000, 12, 31).dayOfYear == 366);\n--------------------\n      \n",
      "line" : 12026,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZt",
      "originalType" : "const pure nothrow ushort()",
      "endline" : 12036
     },
     {
      "name" : "__unittestL12039_715",
      "kind" : "function",
      "line" : 12039,
      "endline" : 12046
     },
     {
      "name" : "__unittestL12046_720",
      "kind" : "function",
      "line" : 12046,
      "endline" : 12085
     },
     {
      "name" : "dayOfYear",
      "kind" : "function",
      "comment" : "\n        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(D Date) is on.\n\n        Throws:\n            $(D DateTimeException) if the given day is an invalid day of the\n            year.\n      \n",
      "line" : 12085,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 12102
     },
     {
      "name" : "__unittestL12104_721",
      "kind" : "function",
      "line" : 12104,
      "endline" : 12149
     },
     {
      "name" : "dayOfGregorianCal",
      "kind" : "function",
      "comment" : "\n        The Xth day of the Gregorian Calendar that this $(D Date) is on.\n\n        Examples:\n--------------------\nassert(Date(1, 1, 1).dayOfGregorianCal == 1);\nassert(Date(1, 12, 31).dayOfGregorianCal == 365);\nassert(Date(2, 1, 1).dayOfGregorianCal == 366);\n\nassert(Date(0, 12, 31).dayOfGregorianCal == 0);\nassert(Date(0, 1, 1).dayOfGregorianCal == -365);\nassert(Date(-1, 12, 31).dayOfGregorianCal == -366);\n\nassert(Date(2000, 1, 1).dayOfGregorianCal == 730_120);\nassert(Date(2010, 12, 31).dayOfGregorianCal == 734_137);\n--------------------\n     \n",
      "line" : 12149,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZi",
      "originalType" : "const pure nothrow int()",
      "endline" : 12200
     },
     {
      "name" : "__unittestL12203_722",
      "kind" : "function",
      "line" : 12203,
      "endline" : 12217
     },
     {
      "name" : "__unittestL12217_723",
      "kind" : "function",
      "line" : 12217,
      "endline" : 12264
     },
     {
      "name" : "dayOfGregorianCal",
      "kind" : "function",
      "comment" : "\n        The Xth day of the Gregorian Calendar that this $(D Date) is on.\n\n        Params:\n            day = The day of the Gregorian Calendar to set this $(D Date) to.\n\n        Examples:\n--------------------\nauto date = Date.init;\ndate.dayOfGregorianCal = 1;\nassert(date == Date(1, 1, 1));\n\ndate.dayOfGregorianCal = 365;\nassert(date == Date(1, 12, 31));\n\ndate.dayOfGregorianCal = 366;\nassert(date == Date(2, 1, 1));\n\ndate.dayOfGregorianCal = 0;\nassert(date == Date(0, 12, 31));\n\ndate.dayOfGregorianCal = -365;\nassert(date == Date(-0, 1, 1));\n\ndate.dayOfGregorianCal = -366;\nassert(date == Date(-1, 12, 31));\n\ndate.dayOfGregorianCal = 730_120;\nassert(date == Date(2000, 1, 1));\n\ndate.dayOfGregorianCal = 734_137;\nassert(date == Date(2010, 12, 31));\n--------------------\n     \n",
      "line" : 12264,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdiZv",
      "originalType" : "pure nothrow void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 12267
     },
     {
      "name" : "__unittestL12269_724",
      "kind" : "function",
      "line" : 12269,
      "endline" : 12319
     },
     {
      "name" : "isoWeek",
      "kind" : "function",
      "comment" : "\n        The ISO 8601 week of the year that this $(D Date) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date)\n      \n",
      "line" : 12319,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 12351
     },
     {
      "name" : "__unittestL12353_725",
      "kind" : "function",
      "line" : 12353,
      "endline" : 12429
     },
     {
      "name" : "endOfMonth",
      "kind" : "function",
      "comment" : "\n        $(D Date) for the last day in the month that this $(D Date) is in.\n\n        Examples:\n--------------------\nassert(Date(1999, 1, 6).endOfMonth == Date(1999, 1, 31));\nassert(Date(1999, 2, 7).endOfMonth == Date(1999, 2, 28));\nassert(Date(2000, 2, 7).endOfMonth == Date(1999, 2, 29));\nassert(Date(2000, 6, 4).endOfMonth == Date(1999, 6, 30));\n--------------------\n      \n",
      "line" : 12429,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZS3std8datetime4Date",
      "originalType" : "const pure nothrow Date()",
      "endline" : 12435
     },
     {
      "name" : "__unittestL12437_726",
      "kind" : "function",
      "line" : 12437,
      "endline" : 12496
     },
     {
      "name" : "daysInMonth",
      "kind" : "function",
      "comment" : "\n        The last day in the month that this $(D Date) is in.\n\n        Examples:\n--------------------\nassert(Date(1999, 1, 6).daysInMonth == 31);\nassert(Date(1999, 2, 7).daysInMonth == 28);\nassert(Date(2000, 2, 7).daysInMonth == 29);\nassert(Date(2000, 6, 4).daysInMonth == 30);\n--------------------\n      \n",
      "line" : 12496,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 12499
     },
     {
      "name" : "__unittestL12501_727",
      "kind" : "function",
      "line" : 12501,
      "endline" : 12560
     },
     {
      "name" : "isAD",
      "kind" : "function",
      "comment" : "\n        Whether the current year is a date in A.D.\n\n        Examples:\n--------------------\nassert(Date(1, 1, 1).isAD);\nassert(Date(2010, 12, 31).isAD);\nassert(!Date(0, 12, 31).isAD);\nassert(!Date(-2010, 1, 1).isAD);\n--------------------\n      \n",
      "line" : 12560,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 12563
     },
     {
      "name" : "__unittestL12565_728",
      "kind" : "function",
      "line" : 12565,
      "endline" : 12593
     },
     {
      "name" : "julianDay",
      "kind" : "function",
      "comment" : "\n        The julian day for this $(D Date) at noon (since the julian day changes\n        at noon).\n      \n",
      "line" : 12593,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZl",
      "originalType" : "const pure nothrow long()",
      "endline" : 12596
     },
     {
      "name" : "__unittestL12598_729",
      "kind" : "function",
      "line" : 12598,
      "endline" : 12623
     },
     {
      "name" : "modJulianDay",
      "kind" : "function",
      "comment" : "\n        The modified julian day for any time on this date (since, the modified\n        julian day changes at midnight).\n      \n",
      "line" : 12623,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZl",
      "originalType" : "const pure nothrow long()",
      "endline" : 12626
     },
     {
      "name" : "__unittestL12628_730",
      "kind" : "function",
      "line" : 12628,
      "endline" : 12654
     },
     {
      "name" : "toISOString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D Date) to a string with the format YYYYMMDD.\n\n        Examples:\n--------------------\nassert(Date(2010, 7, 4).toISOString() == \"20100704\");\nassert(Date(1998, 12, 25).toISOString() == \"19981225\");\nassert(Date(0, 1, 5).toISOString() == \"00000105\");\nassert(Date(-4, 1, 5).toISOString() == \"-00040105\");\n--------------------\n      \n",
      "line" : 12654,
      "deco" : "xFNbZAya",
      "endline" : 12672
     },
     {
      "name" : "__unittestL12674_731",
      "kind" : "function",
      "line" : 12674,
      "endline" : 12717
     },
     {
      "name" : "toISOExtString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D Date) to a string with the format YYYY-MM-DD.\n\n        Examples:\n--------------------\nassert(Date(2010, 7, 4).toISOExtString() == \"2010-07-04\");\nassert(Date(1998, 12, 25).toISOExtString() == \"1998-12-25\");\nassert(Date(0, 1, 5).toISOExtString() == \"0000-01-05\");\nassert(Date(-4, 1, 5).toISOExtString() == \"-0004-01-05\");\n--------------------\n      \n",
      "line" : 12717,
      "deco" : "xFNbZAya",
      "endline" : 12735
     },
     {
      "name" : "__unittestL12737_732",
      "kind" : "function",
      "line" : 12737,
      "endline" : 12780
     },
     {
      "name" : "toSimpleString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D Date) to a string with the format YYYY-Mon-DD.\n\n        Examples:\n--------------------\nassert(Date(2010, 7, 4).toSimpleString() == \"2010-Jul-04\");\nassert(Date(1998, 12, 25).toSimpleString() == \"1998-Dec-25\");\nassert(Date(0, 1, 5).toSimpleString() == \"0000-Jan-05\");\nassert(Date(-4, 1, 5).toSimpleString() == \"-0004-Jan-05\");\n--------------------\n      \n",
      "line" : 12780,
      "deco" : "xFNbZAya",
      "endline" : 12798
     },
     {
      "name" : "__unittestL12800_733",
      "kind" : "function",
      "line" : 12800,
      "endline" : 12841
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 12841,
      "deco" : "FZAya",
      "endline" : 12844
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D Date) to a string.\n      \n",
      "line" : 12852,
      "deco" : "xFNbZAya",
      "endline" : 12855
     },
     {
      "name" : "__unittestL12857_734",
      "kind" : "function",
      "line" : 12857,
      "endline" : 12891
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D Date) from a string with the format YYYYMMDD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D Date) would not be valid.\n\n        Examples:\n--------------------\nassert(Date.fromISOString(\"20100704\") == Date(2010, 7, 4));\nassert(Date.fromISOString(\"19981225\") == Date(1998, 12, 25));\nassert(Date.fromISOString(\"00000105\") == Date(0, 1, 5));\nassert(Date.fromISOString(\"-00040105\") == Date(-4, 1, 5));\nassert(Date.fromISOString(\" 20100704 \") == Date(2010, 7, 4));\n--------------------\n      \n",
      "line" : 12891,
      "name" : "fromISOString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOString",
        "kind" : "function",
        "line" : 12891,
        "type" : "Date(in S isoString)",
        "parameters" : [
         {
          "name" : "isoString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 12916
       }
      ]
     },
     {
      "name" : "__unittestL12918_735",
      "kind" : "function",
      "line" : 12918,
      "endline" : 13016
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D Date) from a string with the format YYYY-MM-DD. Whitespace\n        is stripped from the given string.\n\n        Params:\n            isoExtString = A string formatted in the ISO Extended format for\n                           dates.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(D Date) would not be valid.\n\n        Examples:\n--------------------\nassert(Date.fromISOExtString(\"2010-07-04\") == Date(2010, 7, 4));\nassert(Date.fromISOExtString(\"1998-12-25\") == Date(1998, 12, 25));\nassert(Date.fromISOExtString(\"0000-01-05\") == Date(0, 1, 5));\nassert(Date.fromISOExtString(\"-0004-01-05\") == Date(-4, 1, 5));\nassert(Date.fromISOExtString(\" 2010-07-04 \") == Date(2010, 7, 4));\n--------------------\n      \n",
      "line" : 13016,
      "name" : "fromISOExtString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOExtString",
        "kind" : "function",
        "line" : 13016,
        "type" : "Date(in S isoExtString)",
        "parameters" : [
         {
          "name" : "isoExtString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 13046
       }
      ]
     },
     {
      "name" : "__unittestL13048_736",
      "kind" : "function",
      "line" : 13048,
      "endline" : 13146
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D Date) from a string with the format YYYY-Mon-DD.\n        Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the correct\n            format or if the resulting $(D Date) would not be valid.\n\n        Examples:\n--------------------\nassert(Date.fromSimpleString(\"2010-Jul-04\") == Date(2010, 7, 4));\nassert(Date.fromSimpleString(\"1998-Dec-25\") == Date(1998, 12, 25));\nassert(Date.fromSimpleString(\"0000-Jan-05\") == Date(0, 1, 5));\nassert(Date.fromSimpleString(\"-0004-Jan-05\") == Date(-4, 1, 5));\nassert(Date.fromSimpleString(\" 2010-Jul-04 \") == Date(2010, 7, 4));\n--------------------\n      \n",
      "line" : 13146,
      "name" : "fromSimpleString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromSimpleString",
        "kind" : "function",
        "line" : 13146,
        "type" : "Date(in S simpleString)",
        "parameters" : [
         {
          "name" : "simpleString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 13173
       }
      ]
     },
     {
      "name" : "__unittestL13175_737",
      "kind" : "function",
      "line" : 13175,
      "endline" : 13263
     },
     {
      "name" : "min",
      "kind" : "function",
      "comment" : "\n        Returns the $(D Date) farthest in the past which is representable by\n        $(D Date).\n      \n",
      "line" : 13263,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime4Date",
      "originalType" : "pure nothrow Date()",
      "endline" : 13271
     },
     {
      "name" : "__unittestL13273_738",
      "kind" : "function",
      "line" : 13273,
      "endline" : 13287
     },
     {
      "name" : "max",
      "kind" : "function",
      "comment" : "\n        Returns the $(D Date) farthest in the future which is representable by\n        $(D Date).\n      \n",
      "line" : 13287,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime4Date",
      "originalType" : "pure nothrow Date()",
      "endline" : 13295
     },
     {
      "name" : "__unittestL13297_739",
      "kind" : "function",
      "line" : 13297,
      "endline" : 13307
     },
     {
      "name" : "_valid",
      "kind" : "function",
      "protection" : "private",
      "line" : 13317,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNaNbiiiZb",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       },
       {
        "name" : "month",
        "deco" : "i"
       },
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 13323
     },
     {
      "name" : "addDays",
      "kind" : "function",
      "protection" : "private",
      "line" : 13341,
      "deco" : "FNaNbNclZS3std8datetime4Date",
      "originalType" : "pure nothrow Date(long days)",
      "parameters" : [
       {
        "name" : "days",
        "deco" : "l"
       }
      ],
      "endline" : 13346
     },
     {
      "name" : "__unittestL13348_740",
      "kind" : "function",
      "protection" : "private",
      "line" : 13348,
      "endline" : 13510
     },
     {
      "name" : "__invariant6",
      "kind" : "function",
      "protection" : "private",
      "line" : 13510,
      "storageClass" : [
       "const",
       "pure"
      ],
      "deco" : "xFNaZv",
      "originalType" : "void()"
     },
     {
      "name" : "_year",
      "kind" : "variable",
      "protection" : "private",
      "line" : 13529,
      "deco" : "s",
      "init" : "cast(short)1",
      "offset" : 0
     },
     {
      "name" : "_month",
      "kind" : "variable",
      "protection" : "private",
      "line" : 13530,
      "deco" : "E3std8datetime5Month",
      "init" : "cast(Month)cast(ubyte)1u",
      "offset" : 2
     },
     {
      "name" : "_day",
      "kind" : "variable",
      "protection" : "private",
      "line" : 13531,
      "deco" : "h",
      "init" : "cast(ubyte)1u",
      "offset" : 3
     },
     {
      "name" : "__invariant",
      "kind" : "function",
      "line" : 8978,
      "storageClass" : [
       "const",
       "pure"
      ],
      "deco" : "xFNaZv",
      "originalType" : "pure void()"
     }
    ]
   },
   {
    "name" : "TimeOfDay",
    "kind" : "struct",
    "comment" : "\n    Represents a time of day with hours, minutes, and seconds. It uses 24 hour\n    time.\n",
    "line" : 13541,
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            hour   = Hour of the day [0 - 24$(RPAREN).\n            minute = Minute of the hour [0 - 60$(RPAREN).\n            second = Second of the minute [0 - 60$(RPAREN).\n\n        Throws:\n            $(D DateTimeException) if the resulting $(D TimeOfDay) would be not\n            be valid.\n     \n",
      "line" : 13554,
      "deco" : "FNaNciiiZS3std8datetime9TimeOfDay",
      "originalType" : "pure (int hour, int minute, int second = 0)",
      "parameters" : [
       {
        "name" : "hour",
        "deco" : "i"
       },
       {
        "name" : "minute",
        "deco" : "i"
       },
       {
        "name" : "second",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 13563
     },
     {
      "name" : "__unittestL13565_741",
      "kind" : "function",
      "line" : 13565,
      "endline" : 13609
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n        Compares this $(D TimeOfDay) with the given $(D TimeOfDay).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
      "line" : 13609,
      "deco" : "xFNaNbxS3std8datetime9TimeOfDayZi",
      "originalType" : "const pure nothrow int(in TimeOfDay rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime9TimeOfDay"
       }
      ],
      "endline" : 13627
     },
     {
      "name" : "__unittestL13629_742",
      "kind" : "function",
      "line" : 13629,
      "endline" : 13672
     },
     {
      "name" : "hour",
      "kind" : "function",
      "comment" : "\n        Hours passed midnight.\n     \n",
      "line" : 13672,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 13675
     },
     {
      "name" : "__unittestL13677_743",
      "kind" : "function",
      "line" : 13677,
      "endline" : 13702
     },
     {
      "name" : "hour",
      "kind" : "function",
      "comment" : "\n        Hours passed midnight.\n\n        Params:\n            hour = The hour of the day to set this $(D TimeOfDay)'s hour to.\n\n        Throws:\n            $(D DateTimeException) if the given hour would result in an invalid\n            $(D TimeOfDay).\n     \n",
      "line" : 13702,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int hour)",
      "parameters" : [
       {
        "name" : "hour",
        "deco" : "i"
       }
      ],
      "endline" : 13706
     },
     {
      "name" : "__unittestL13708_745",
      "kind" : "function",
      "line" : 13708,
      "endline" : 13729
     },
     {
      "name" : "minute",
      "kind" : "function",
      "comment" : "\n        Minutes passed the hour.\n     \n",
      "line" : 13729,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 13732
     },
     {
      "name" : "__unittestL13734_746",
      "kind" : "function",
      "line" : 13734,
      "endline" : 13759
     },
     {
      "name" : "minute",
      "kind" : "function",
      "comment" : "\n        Minutes passed the hour.\n\n        Params:\n            minute = The minute to set this $(D TimeOfDay)'s minute to.\n\n        Throws:\n            $(D DateTimeException) if the given minute would result in an\n            invalid $(D TimeOfDay).\n     \n",
      "line" : 13759,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int minute)",
      "parameters" : [
       {
        "name" : "minute",
        "deco" : "i"
       }
      ],
      "endline" : 13763
     },
     {
      "name" : "__unittestL13765_748",
      "kind" : "function",
      "line" : 13765,
      "endline" : 13786
     },
     {
      "name" : "second",
      "kind" : "function",
      "comment" : "\n        Seconds passed the minute.\n     \n",
      "line" : 13786,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 13789
     },
     {
      "name" : "__unittestL13791_749",
      "kind" : "function",
      "line" : 13791,
      "endline" : 13816
     },
     {
      "name" : "second",
      "kind" : "function",
      "comment" : "\n        Seconds passed the minute.\n\n        Params:\n            second = The second to set this $(D TimeOfDay)'s second to.\n\n        Throws:\n            $(D DateTimeException) if the given second would result in an\n            invalid $(D TimeOfDay).\n     \n",
      "line" : 13816,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int second)",
      "parameters" : [
       {
        "name" : "second",
        "deco" : "i"
       }
      ],
      "endline" : 13820
     },
     {
      "name" : "__unittestL13822_751",
      "kind" : "function",
      "line" : 13822,
      "endline" : 13883
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of units to this $(D TimeOfDay). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D TimeOfDay)\n        one hours's worth of minutes gets the exact same\n        $(D TimeOfDay).\n\n        Accepted units are $(D \"hours\"), $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this\n                    $(D TimeOfDay).\n\n        Examples:\n--------------------\nauto tod1 = TimeOfDay(7, 12, 0);\ntod1.roll!\"hours\"(1);\nassert(tod1 == TimeOfDay(8, 12, 0));\n\nauto tod2 = TimeOfDay(7, 12, 0);\ntod2.roll!\"hours\"(-1);\nassert(tod2 == TimeOfDay(6, 12, 0));\n\nauto tod3 = TimeOfDay(23, 59, 0);\ntod3.roll!\"minutes\"(1);\nassert(tod3 == TimeOfDay(23, 0, 0));\n\nauto tod4 = TimeOfDay(0, 0, 0);\ntod4.roll!\"minutes\"(-1);\nassert(tod4 == TimeOfDay(0, 59, 0));\n\nauto tod5 = TimeOfDay(23, 59, 59);\ntod5.roll!\"seconds\"(1);\nassert(tod5 == TimeOfDay(23, 59, 0));\n\nauto tod6 = TimeOfDay(0, 0, 0);\ntod6.roll!\"seconds\"(-1);\nassert(tod6 == TimeOfDay(0, 0, 59));\n--------------------\n      \n",
      "line" : 13883,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of units to this $(D TimeOfDay). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D TimeOfDay)\n        one hours's worth of minutes gets the exact same\n        $(D TimeOfDay).\n\n        Accepted units are $(D \"hours\"), $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this\n                    $(D TimeOfDay).\n\n        Examples:\n--------------------\nauto tod1 = TimeOfDay(7, 12, 0);\ntod1.roll!\"hours\"(1);\nassert(tod1 == TimeOfDay(8, 12, 0));\n\nauto tod2 = TimeOfDay(7, 12, 0);\ntod2.roll!\"hours\"(-1);\nassert(tod2 == TimeOfDay(6, 12, 0));\n\nauto tod3 = TimeOfDay(23, 59, 0);\ntod3.roll!\"minutes\"(1);\nassert(tod3 == TimeOfDay(23, 0, 0));\n\nauto tod4 = TimeOfDay(0, 0, 0);\ntod4.roll!\"minutes\"(-1);\nassert(tod4 == TimeOfDay(0, 59, 0));\n\nauto tod5 = TimeOfDay(23, 59, 59);\ntod5.roll!\"seconds\"(1);\nassert(tod5 == TimeOfDay(23, 59, 0));\n\nauto tod6 = TimeOfDay(0, 0, 0);\ntod6.roll!\"seconds\"(-1);\nassert(tod6 == TimeOfDay(0, 0, 59));\n--------------------\n      \n",
        "line" : 13883,
        "type" : "pure nothrow void(long value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         }
        ],
        "endline" : 13887
       }
      ]
     },
     {
      "name" : "__unittestL13890_752",
      "kind" : "function",
      "line" : 13890,
      "endline" : 13920
     },
     {
      "name" : "__unittestL13920_753",
      "kind" : "function",
      "line" : 13920,
      "endline" : 13933
     },
     {
      "kind" : "template",
      "line" : 13933,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "line" : 13933,
        "type" : "pure nothrow void(long value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         }
        ],
        "endline" : 13956
       }
      ]
     },
     {
      "name" : "__unittestL13959_754",
      "kind" : "function",
      "line" : 13959,
      "endline" : 14075
     },
     {
      "name" : "__unittestL14075_755",
      "kind" : "function",
      "line" : 14075,
      "endline" : 14162
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
      "line" : 14162,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
        "line" : 14162,
        "type" : "const pure nothrow TimeOfDay(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 14186
       }
      ]
     },
     {
      "name" : "__unittestL14188_756",
      "kind" : "function",
      "line" : 14188,
      "endline" : 14268
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay), as well as assigning the result to this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
      "line" : 14268,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D TimeOfDay), as well as assigning the result to this\n        $(D TimeOfDay).\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD +) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        $(TR $(TD TimeOfDay) $(TD -) $(TD duration) $(TD -->) $(TD TimeOfDay))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D TimeOfDay).\n      \n",
        "line" : 14268,
        "type" : "pure nothrow TimeOfDay(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 14290
       }
      ]
     },
     {
      "name" : "__unittestL14292_757",
      "kind" : "function",
      "line" : 14292,
      "endline" : 14348
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the difference between two $(D TimeOfDay)s.\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD -) $(TD TimeOfDay) $(TD -->) $(TD duration))\n        )\n\n        Params:\n            rhs = The $(D TimeOfDay) to subtract from this one.\n      \n",
      "line" : 14348,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the difference between two $(D TimeOfDay)s.\n\n        The legal types of arithmetic for $(D TimeOfDay) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD TimeOfDay) $(TD -) $(TD TimeOfDay) $(TD -->) $(TD duration))\n        )\n\n        Params:\n            rhs = The $(D TimeOfDay) to subtract from this one.\n      \n",
        "line" : 14348,
        "type" : "const pure nothrow Duration(in TimeOfDay rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "TimeOfDay",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 14355
       }
      ]
     },
     {
      "name" : "__unittestL14357_758",
      "kind" : "function",
      "line" : 14357,
      "endline" : 14398
     },
     {
      "name" : "toISOString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D TimeOfDay) to a string with the format HHMMSS.\n\n        Examples:\n--------------------\nassert(TimeOfDay(0, 0, 0).toISOString() == \"000000\");\nassert(TimeOfDay(12, 30, 33).toISOString() == \"123033\");\n--------------------\n      \n",
      "line" : 14398,
      "deco" : "xFNbZAya",
      "endline" : 14404
     },
     {
      "name" : "__unittestL14406_759",
      "kind" : "function",
      "line" : 14406,
      "endline" : 14433
     },
     {
      "name" : "toISOExtString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D TimeOfDay) to a string with the format HH:MM:SS.\n\n        Examples:\n--------------------\nassert(TimeOfDay(0, 0, 0).toISOExtString() == \"000000\");\nassert(TimeOfDay(12, 30, 33).toISOExtString() == \"123033\");\n--------------------\n      \n",
      "line" : 14433,
      "deco" : "xFNbZAya",
      "endline" : 14439
     },
     {
      "name" : "__unittestL14441_760",
      "kind" : "function",
      "line" : 14441,
      "endline" : 14465
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 14465,
      "deco" : "FZAya",
      "endline" : 14468
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n        Converts this TimeOfDay to a string.\n      \n",
      "line" : 14477,
      "deco" : "xFNbZAya",
      "endline" : 14480
     },
     {
      "name" : "__unittestL14482_761",
      "kind" : "function",
      "line" : 14482,
      "endline" : 14517
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D TimeOfDay) from a string with the format HHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D TimeOfDay) would not be valid.\n\n        Examples:\n--------------------\nassert(TimeOfDay.fromISOString(\"000000\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOString(\"123033\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOString(\" 123033 \") == TimeOfDay(12, 30, 33));\n--------------------\n      \n",
      "line" : 14517,
      "name" : "fromISOString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOString",
        "kind" : "function",
        "line" : 14517,
        "type" : "TimeOfDay(in S isoString)",
        "parameters" : [
         {
          "name" : "isoString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 14533
       }
      ]
     },
     {
      "name" : "__unittestL14535_762",
      "kind" : "function",
      "line" : 14535,
      "endline" : 14626
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D TimeOfDay) from a string with the format HH:MM:SS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO Extended format for times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(D TimeOfDay) would not be\n            valid.\n\n        Examples:\n--------------------\nassert(TimeOfDay.fromISOExtString(\"00:00:00\") == TimeOfDay(0, 0, 0));\nassert(TimeOfDay.fromISOExtString(\"12:30:33\") == TimeOfDay(12, 30, 33));\nassert(TimeOfDay.fromISOExtString(\" 12:30:33 \") == TimeOfDay(12, 30, 33));\n--------------------\n      \n",
      "line" : 14626,
      "name" : "fromISOExtString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOExtString",
        "kind" : "function",
        "line" : 14626,
        "type" : "TimeOfDay(in S isoExtString)",
        "parameters" : [
         {
          "name" : "isoExtString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 14647
       }
      ]
     },
     {
      "name" : "__unittestL14649_763",
      "kind" : "function",
      "line" : 14649,
      "endline" : 14731
     },
     {
      "name" : "min",
      "kind" : "function",
      "comment" : "\n        Returns midnight.\n      \n",
      "line" : 14731,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime9TimeOfDay",
      "originalType" : "pure nothrow TimeOfDay()",
      "endline" : 14734
     },
     {
      "name" : "__unittestL14736_764",
      "kind" : "function",
      "line" : 14736,
      "endline" : 14751
     },
     {
      "name" : "max",
      "kind" : "function",
      "comment" : "\n        Returns one second short of midnight.\n      \n",
      "line" : 14751,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime9TimeOfDay",
      "originalType" : "pure nothrow TimeOfDay()",
      "endline" : 14759
     },
     {
      "name" : "__unittestL14761_765",
      "kind" : "function",
      "line" : 14761,
      "endline" : 14773
     },
     {
      "name" : "addSeconds",
      "kind" : "function",
      "protection" : "private",
      "line" : 14786,
      "deco" : "FNaNbNclZS3std8datetime9TimeOfDay",
      "originalType" : "pure nothrow TimeOfDay(long seconds)",
      "parameters" : [
       {
        "name" : "seconds",
        "deco" : "l"
       }
      ],
      "endline" : 14807
     },
     {
      "name" : "__unittestL14809_766",
      "kind" : "function",
      "protection" : "private",
      "line" : 14809,
      "endline" : 14891
     },
     {
      "name" : "_valid",
      "kind" : "function",
      "protection" : "private",
      "line" : 14891,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNaNbiiiZb",
      "parameters" : [
       {
        "name" : "hour",
        "deco" : "i"
       },
       {
        "name" : "minute",
        "deco" : "i"
       },
       {
        "name" : "second",
        "deco" : "i"
       }
      ],
      "endline" : 14894
     },
     {
      "name" : "__invariant7",
      "kind" : "function",
      "protection" : "private",
      "line" : 14897,
      "storageClass" : [
       "const",
       "pure"
      ],
      "deco" : "xFNaZv",
      "originalType" : "void()"
     },
     {
      "name" : "_hour",
      "kind" : "variable",
      "protection" : "private",
      "line" : 14909,
      "deco" : "h",
      "offset" : 0
     },
     {
      "name" : "_minute",
      "kind" : "variable",
      "protection" : "private",
      "line" : 14910,
      "deco" : "h",
      "offset" : 1
     },
     {
      "name" : "_second",
      "kind" : "variable",
      "protection" : "private",
      "line" : 14911,
      "deco" : "h",
      "offset" : 2
     },
     {
      "name" : "maxHour",
      "kind" : "variable",
      "protection" : "private",
      "line" : 14913,
      "storageClass" : [
       "enum"
      ],
      "deco" : "h",
      "init" : "cast(ubyte)23u"
     },
     {
      "name" : "maxMinute",
      "kind" : "variable",
      "protection" : "private",
      "line" : 14914,
      "storageClass" : [
       "enum"
      ],
      "deco" : "h",
      "init" : "cast(ubyte)59u"
     },
     {
      "name" : "maxSecond",
      "kind" : "variable",
      "protection" : "private",
      "line" : 14915,
      "storageClass" : [
       "enum"
      ],
      "deco" : "h",
      "init" : "cast(ubyte)59u"
     },
     {
      "name" : "__invariant",
      "kind" : "function",
      "line" : 13541,
      "storageClass" : [
       "const",
       "pure"
      ],
      "deco" : "xFNaZv",
      "originalType" : "pure void()"
     }
    ]
   },
   {
    "name" : "DateTime",
    "kind" : "struct",
    "comment" : "\n   Combines the $(D Date) and $(D TimeOfDay) structs to give an object\n   which holds both the date and the time. It is optimized for calendar-based\n   operations and has no concept of time zone. For an object which is\n   optimized for time operations based on the system time, use\n   $(D SysTime). $(D SysTime) has a concept of time zone and has much higher\n   precision (hnsecs). $(D DateTime) is intended primarily for calendar-based\n   uses rather than precise time operations.\n  \n",
    "line" : 14929,
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            date = The date portion of $(D DateTime).\n            tod  = The time portion of $(D DateTime).\n      \n",
      "line" : 14937,
      "deco" : "FNaNbNcxS3std8datetime4DatexS3std8datetime9TimeOfDayZS3std8datetime8DateTime",
      "originalType" : "pure nothrow (in Date date, in TimeOfDay tod = TimeOfDay.init)",
      "parameters" : [
       {
        "name" : "date",
        "deco" : "xS3std8datetime4Date"
       },
       {
        "name" : "tod",
        "deco" : "xS3std8datetime9TimeOfDay",
        "default" : "TimeOfDay(cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u)"
       }
      ],
      "endline" : 14941
     },
     {
      "name" : "__unittestL14943_767",
      "kind" : "function",
      "line" : 14943,
      "endline" : 14977
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            year   = The year portion of the date.\n            month  = The month portion of the date.\n            day    = The day portion of the date.\n            hour   = The hour portion of the time;\n            minute = The minute portion of the time;\n            second = The second portion of the time;\n      \n",
      "line" : 14977,
      "deco" : "FNaNciiiiiiZS3std8datetime8DateTime",
      "originalType" : "pure (int year, int month, int day, int hour = 0, int minute = 0, int second = 0)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       },
       {
        "name" : "month",
        "deco" : "i"
       },
       {
        "name" : "day",
        "deco" : "i"
       },
       {
        "name" : "hour",
        "deco" : "i",
        "default" : "0"
       },
       {
        "name" : "minute",
        "deco" : "i",
        "default" : "0"
       },
       {
        "name" : "second",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 14982
     },
     {
      "name" : "__unittestL14984_768",
      "kind" : "function",
      "line" : 14984,
      "endline" : 15013
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n        Compares this $(D DateTime) with the given $(D DateTime.).\n\n        Returns:\n            $(BOOKTABLE,\n            $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n            $(TR $(TD this == rhs) $(TD 0))\n            $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n            )\n     \n",
      "line" : 15013,
      "deco" : "xFNaNbxS3std8datetime8DateTimeZi",
      "originalType" : "const pure nothrow int(in DateTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime8DateTime"
       }
      ],
      "endline" : 15021
     },
     {
      "name" : "__unittestL15023_769",
      "kind" : "function",
      "line" : 15023,
      "endline" : 15226
     },
     {
      "name" : "date",
      "kind" : "function",
      "comment" : "\n        The date portion of $(D DateTime).\n      \n",
      "line" : 15226,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZS3std8datetime4Date",
      "originalType" : "const pure nothrow Date()",
      "endline" : 15229
     },
     {
      "name" : "__unittestL15231_770",
      "kind" : "function",
      "line" : 15231,
      "endline" : 15259
     },
     {
      "name" : "date",
      "kind" : "function",
      "comment" : "\n        The date portion of $(D DateTime).\n\n        Params:\n            date = The Date to set this $(D DateTime)'s date portion to.\n      \n",
      "line" : 15259,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdxS3std8datetime4DateZv",
      "originalType" : "pure nothrow void(in Date date)",
      "parameters" : [
       {
        "name" : "date",
        "deco" : "xS3std8datetime4Date"
       }
      ],
      "endline" : 15262
     },
     {
      "name" : "__unittestL15264_771",
      "kind" : "function",
      "line" : 15264,
      "endline" : 15284
     },
     {
      "name" : "timeOfDay",
      "kind" : "function",
      "comment" : "\n        The time portion of $(D DateTime).\n      \n",
      "line" : 15284,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZS3std8datetime9TimeOfDay",
      "originalType" : "const pure nothrow TimeOfDay()",
      "endline" : 15287
     },
     {
      "name" : "__unittestL15289_772",
      "kind" : "function",
      "line" : 15289,
      "endline" : 15318
     },
     {
      "name" : "timeOfDay",
      "kind" : "function",
      "comment" : "\n        The time portion of $(D DateTime).\n\n        Params:\n            tod = The $(D TimeOfDay) to set this $(D DateTime)'s time portion\n                  to.\n      \n",
      "line" : 15318,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdxS3std8datetime9TimeOfDayZv",
      "originalType" : "pure nothrow void(in TimeOfDay tod)",
      "parameters" : [
       {
        "name" : "tod",
        "deco" : "xS3std8datetime9TimeOfDay"
       }
      ],
      "endline" : 15321
     },
     {
      "name" : "__unittestL15323_773",
      "kind" : "function",
      "line" : 15323,
      "endline" : 15344
     },
     {
      "name" : "year",
      "kind" : "function",
      "comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n     \n",
      "line" : 15344,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZs",
      "originalType" : "const pure nothrow short()",
      "endline" : 15347
     },
     {
      "name" : "__unittestL15349_774",
      "kind" : "function",
      "line" : 15349,
      "endline" : 15383
     },
     {
      "name" : "year",
      "kind" : "function",
      "comment" : "\n        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive\n        are B.C.\n\n        Params:\n            year = The year to set this $(D DateTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if the new year is not a leap year and if the\n            resulting date would be on February 29th.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).year == 1999);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).year == 2010);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).year == -7);\n--------------------\n     \n",
      "line" : 15383,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int year)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       }
      ],
      "endline" : 15386
     },
     {
      "name" : "__unittestL15388_775",
      "kind" : "function",
      "line" : 15388,
      "endline" : 15428
     },
     {
      "name" : "yearBC",
      "kind" : "function",
      "comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Throws:\n            $(D DateTimeException) if $(D isAD) is true.\n\n        Examples:\n--------------------\nassert(DateTime(Date(0, 1, 1), TimeOfDay(12, 30, 33)).yearBC == 1);\nassert(DateTime(Date(-1, 1, 1), TimeOfDay(10, 7, 2)).yearBC == 2);\nassert(DateTime(Date(-100, 1, 1), TimeOfDay(4, 59, 0)).yearBC == 101);\n--------------------\n     \n",
      "line" : 15428,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNdZs",
      "originalType" : "const pure short()",
      "endline" : 15431
     },
     {
      "name" : "__unittestL15433_777",
      "kind" : "function",
      "line" : 15433,
      "endline" : 15473
     },
     {
      "name" : "yearBC",
      "kind" : "function",
      "comment" : "\n        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.\n\n        Params:\n            year = The year B.C. to set this $(D DateTime)'s year to.\n\n        Throws:\n            $(D DateTimeException) if a non-positive value is given.\n\n        Examples:\n--------------------\nauto dt = DateTime(Date(2010, 1, 1), TimeOfDay(7, 30, 0));\ndt.yearBC = 1;\nassert(dt == DateTime(Date(0, 1, 1), TimeOfDay(7, 30, 0)));\n\ndt.yearBC = 10;\nassert(dt == DateTime(Date(-9, 1, 1), TimeOfDay(7, 30, 0)));\n--------------------\n     \n",
      "line" : 15473,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int year)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       }
      ],
      "endline" : 15476
     },
     {
      "name" : "__unittestL15478_779",
      "kind" : "function",
      "line" : 15478,
      "endline" : 15516
     },
     {
      "name" : "month",
      "kind" : "function",
      "comment" : "\n        Month of a Gregorian Year.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).month == 7);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).month == 10);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).month == 4);\n--------------------\n     \n",
      "line" : 15516,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZE3std8datetime5Month",
      "originalType" : "const pure nothrow Month()",
      "endline" : 15519
     },
     {
      "name" : "__unittestL15521_780",
      "kind" : "function",
      "line" : 15521,
      "endline" : 15551
     },
     {
      "name" : "month",
      "kind" : "function",
      "comment" : "\n        Month of a Gregorian Year.\n\n        Params:\n            month = The month to set this $(D DateTime)'s month to.\n\n        Throws:\n            $(D DateTimeException) if the given month is not a valid month.\n     \n",
      "line" : 15551,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdE3std8datetime5MonthZv",
      "originalType" : "pure void(Month month)",
      "parameters" : [
       {
        "name" : "month",
        "deco" : "E3std8datetime5Month"
       }
      ],
      "endline" : 15554
     },
     {
      "name" : "__unittestL15556_781",
      "kind" : "function",
      "line" : 15556,
      "endline" : 15591
     },
     {
      "name" : "day",
      "kind" : "function",
      "comment" : "\n        Day of a Gregorian Month.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 7, 6), TimeOfDay(9, 7, 5)).day == 6);\nassert(DateTime(Date(2010, 10, 4), TimeOfDay(0, 0, 30)).day == 4);\nassert(DateTime(Date(-7, 4, 5), TimeOfDay(7, 45, 2)).day == 5);\n--------------------\n     \n",
      "line" : 15591,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 15594
     },
     {
      "name" : "__unittestL15597_782",
      "kind" : "function",
      "line" : 15597,
      "endline" : 15604
     },
     {
      "name" : "__unittestL15604_783",
      "kind" : "function",
      "line" : 15604,
      "endline" : 15638
     },
     {
      "name" : "day",
      "kind" : "function",
      "comment" : "\n        Day of a Gregorian Month.\n\n        Params:\n            day = The day of the month to set this $(D DateTime)'s day to.\n\n        Throws:\n            $(D DateTimeException) if the given day is not a valid day of the\n            current month.\n     \n",
      "line" : 15638,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 15641
     },
     {
      "name" : "__unittestL15643_784",
      "kind" : "function",
      "line" : 15643,
      "endline" : 15733
     },
     {
      "name" : "hour",
      "kind" : "function",
      "comment" : "\n        Hours passed midnight.\n     \n",
      "line" : 15733,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 15736
     },
     {
      "name" : "__unittestL15738_785",
      "kind" : "function",
      "line" : 15738,
      "endline" : 15763
     },
     {
      "name" : "hour",
      "kind" : "function",
      "comment" : "\n        Hours passed midnight.\n\n        Params:\n            hour = The hour of the day to set this $(D DateTime)'s hour to.\n\n        Throws:\n            $(D DateTimeException) if the given hour would result in an invalid\n            $(D DateTime).\n     \n",
      "line" : 15763,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int hour)",
      "parameters" : [
       {
        "name" : "hour",
        "deco" : "i"
       }
      ],
      "endline" : 15766
     },
     {
      "name" : "__unittestL15768_787",
      "kind" : "function",
      "line" : 15768,
      "endline" : 15789
     },
     {
      "name" : "minute",
      "kind" : "function",
      "comment" : "\n        Minutes passed the hour.\n     \n",
      "line" : 15789,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 15792
     },
     {
      "name" : "__unittestL15794_788",
      "kind" : "function",
      "line" : 15794,
      "endline" : 15819
     },
     {
      "name" : "minute",
      "kind" : "function",
      "comment" : "\n        Minutes passed the hour.\n\n        Params:\n            minute = The minute to set this $(D DateTime)'s minute to.\n\n        Throws:\n            $(D DateTimeException) if the given minute would result in an\n            invalid $(D DateTime).\n     \n",
      "line" : 15819,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int minute)",
      "parameters" : [
       {
        "name" : "minute",
        "deco" : "i"
       }
      ],
      "endline" : 15822
     },
     {
      "name" : "__unittestL15824_790",
      "kind" : "function",
      "line" : 15824,
      "endline" : 15845
     },
     {
      "name" : "second",
      "kind" : "function",
      "comment" : "\n        Seconds passed the minute.\n     \n",
      "line" : 15845,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 15848
     },
     {
      "name" : "__unittestL15850_791",
      "kind" : "function",
      "line" : 15850,
      "endline" : 15875
     },
     {
      "name" : "second",
      "kind" : "function",
      "comment" : "\n        Seconds passed the minute.\n\n        Params:\n            second = The second to set this $(D DateTime)'s second to.\n\n        Throws:\n            $(D DateTimeException) if the given seconds would result in an\n            invalid $(D DateTime).\n     \n",
      "line" : 15875,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int second)",
      "parameters" : [
       {
        "name" : "second",
        "deco" : "i"
       }
      ],
      "endline" : 15878
     },
     {
      "name" : "__unittestL15880_793",
      "kind" : "function",
      "line" : 15880,
      "endline" : 15936
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 30, 33);\ndt1.add!\"months\"(11);\nassert(dt1 == DateTime(2010, 12, 1, 12, 30, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 30, 33);\ndt2.add!\"months\"(-11);\nassert(dt2 == DateTime(2009, 2, 1, 12, 30, 33));\n\nauto dt3 = DateTime(2000, 2, 29, 12, 30, 33);\ndt3.add!\"years\"(1);\nassert(dt3 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt4 = DateTime(2000, 2, 29, 12, 30, 33);\ndt4.add!\"years\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
      "line" : 15936,
      "name" : "add",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "add",
        "kind" : "function",
        "comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        Note that if day overflow is allowed, and the date with the adjusted\n        year/month overflows the number of days in the new month, then the month\n        will be incremented by one, and the day set to the number of days\n        overflowed. (e.g. if the day were 31 and the new month were June, then\n        the month would be incremented to July, and the new day would be 1). If\n        day overflow is not allowed, then the day will be set to the last valid\n        day in the month (e.g. June 31st would become June 30th).\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 30, 33);\ndt1.add!\"months\"(11);\nassert(dt1 == DateTime(2010, 12, 1, 12, 30, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 30, 33);\ndt2.add!\"months\"(-11);\nassert(dt2 == DateTime(2009, 2, 1, 12, 30, 33));\n\nauto dt3 = DateTime(2000, 2, 29, 12, 30, 33);\ndt3.add!\"years\"(1);\nassert(dt3 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt4 = DateTime(2000, 2, 29, 12, 30, 33);\ndt4.add!\"years\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
        "line" : 15936,
        "type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 15941
       }
      ]
     },
     {
      "name" : "__unittestL15944_794",
      "kind" : "function",
      "line" : 15944,
      "endline" : 15966
     },
     {
      "name" : "__unittestL15966_795",
      "kind" : "function",
      "line" : 15966,
      "endline" : 16026
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D DateTime) 12 months\n        gets the exact same $(D DateTime). However, the days can still be\n        affected due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 33, 33);\ndt1.roll!\"months\"(1);\nassert(dt1 == DateTime(2010, 2, 1, 12, 33, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 33, 33);\ndt2.roll!\"months\"(-1);\nassert(dt2 == DateTime(2010, 12, 1, 12, 33, 33));\n\nauto dt3 = DateTime(1999, 1, 29, 12, 33, 33);\ndt3.roll!\"months\"(1);\nassert(dt3 == DateTime(1999, 3, 1, 12, 33, 33));\n\nauto dt4 = DateTime(1999, 1, 29, 12, 33, 33);\ndt4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(1999, 2, 28, 12, 33, 33));\n\nauto dt5 = DateTime(2000, 2, 29, 12, 30, 33);\ndt5.roll!\"years\"(1);\nassert(dt5 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt6 = DateTime(2000, 2, 29, 12, 30, 33);\ndt6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(dt6 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
      "line" : 16026,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of years or months to this $(D DateTime). A\n        negative number will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. Rolling a $(D DateTime) 12 months\n        gets the exact same $(D DateTime). However, the days can still be\n        affected due to the differing number of days in each month.\n\n        Because there are no units larger than years, there is no difference\n        between adding and rolling years.\n\n        Params:\n            units         = The type of units to add (\"years\" or \"months\").\n            value         = The number of months or years to add to this\n                            $(D DateTime).\n            allowOverflow = Whether the days should be allowed to overflow,\n                            causing the month to increment.\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 12, 33, 33);\ndt1.roll!\"months\"(1);\nassert(dt1 == DateTime(2010, 2, 1, 12, 33, 33));\n\nauto dt2 = DateTime(2010, 1, 1, 12, 33, 33);\ndt2.roll!\"months\"(-1);\nassert(dt2 == DateTime(2010, 12, 1, 12, 33, 33));\n\nauto dt3 = DateTime(1999, 1, 29, 12, 33, 33);\ndt3.roll!\"months\"(1);\nassert(dt3 == DateTime(1999, 3, 1, 12, 33, 33));\n\nauto dt4 = DateTime(1999, 1, 29, 12, 33, 33);\ndt4.roll!\"months\"(1, AllowDayOverflow.no);\nassert(dt4 == DateTime(1999, 2, 28, 12, 33, 33));\n\nauto dt5 = DateTime(2000, 2, 29, 12, 30, 33);\ndt5.roll!\"years\"(1);\nassert(dt5 == DateTime(2001, 3, 1, 12, 30, 33));\n\nauto dt6 = DateTime(2000, 2, 29, 12, 30, 33);\ndt6.roll!\"years\"(1, AllowDayOverflow.no);\nassert(dt6 == DateTime(2001, 2, 28, 12, 30, 33));\n--------------------\n      \n",
        "line" : 16026,
        "type" : "pure nothrow void(long value, AllowDayOverflow allowOverflow = AllowDayOverflow.yes)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         },
         {
          "name" : "allowOverflow",
          "type" : "AllowDayOverflow",
          "default" : "AllowDayOverflow.yes"
         }
        ],
        "endline" : 16031
       }
      ]
     },
     {
      "name" : "__unittestL16034_796",
      "kind" : "function",
      "line" : 16034,
      "endline" : 16064
     },
     {
      "name" : "__unittestL16064_797",
      "kind" : "function",
      "line" : 16064,
      "endline" : 16114
     },
     {
      "kind" : "template",
      "comment" : "\n        Adds the given number of units to this $(D DateTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D DateTime) one\n        year's worth of days gets the exact same $(D DateTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D DateTime).\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 11, 23, 12);\ndt1.roll!\"days\"(1);\nassert(dt1 == DateTime(2010, 1, 2, 11, 23, 12));\ndt1.roll!\"days\"(365);\nassert(dt1 == DateTime(2010, 1, 26, 11, 23, 12));\ndt1.roll!\"days\"(-32);\nassert(dt1 == DateTime(2010, 1, 25, 11, 23, 12));\n\nauto dt2 = DateTime(2010, 7, 4, 12, 0, 0);\ndt2.roll!\"hours\"(1);\nassert(dt2 == DateTime(2010, 7, 4, 13, 0, 0));\n\nauto dt3 = DateTime(2010, 1, 1, 0, 0, 0);\ndt3.roll!\"seconds\"(-1);\nassert(dt3 == DateTime(2010, 1, 1, 0, 0, 59));\n--------------------\n      \n",
      "line" : 16114,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "comment" : "\n        Adds the given number of units to this $(D DateTime). A negative number\n        will subtract.\n\n        The difference between rolling and adding is that rolling does not\n        affect larger units. For instance, rolling a $(D DateTime) one\n        year's worth of days gets the exact same $(D DateTime).\n\n        Accepted units are $(D \"days\"), $(D \"minutes\"), $(D \"hours\"),\n        $(D \"minutes\"), and $(D \"seconds\").\n\n        Params:\n            units = The units to add.\n            value = The number of $(D_PARAM units) to add to this $(D DateTime).\n\n        Examples:\n--------------------\nauto dt1 = DateTime(2010, 1, 1, 11, 23, 12);\ndt1.roll!\"days\"(1);\nassert(dt1 == DateTime(2010, 1, 2, 11, 23, 12));\ndt1.roll!\"days\"(365);\nassert(dt1 == DateTime(2010, 1, 26, 11, 23, 12));\ndt1.roll!\"days\"(-32);\nassert(dt1 == DateTime(2010, 1, 25, 11, 23, 12));\n\nauto dt2 = DateTime(2010, 7, 4, 12, 0, 0);\ndt2.roll!\"hours\"(1);\nassert(dt2 == DateTime(2010, 7, 4, 13, 0, 0));\n\nauto dt3 = DateTime(2010, 1, 1, 0, 0, 0);\ndt3.roll!\"seconds\"(-1);\nassert(dt3 == DateTime(2010, 1, 1, 0, 0, 59));\n--------------------\n      \n",
        "line" : 16114,
        "type" : "pure nothrow void(long days)",
        "parameters" : [
         {
          "name" : "days",
          "deco" : "l"
         }
        ],
        "endline" : 16118
       }
      ]
     },
     {
      "name" : "__unittestL16121_798",
      "kind" : "function",
      "line" : 16121,
      "endline" : 16143
     },
     {
      "name" : "__unittestL16143_799",
      "kind" : "function",
      "line" : 16143,
      "endline" : 16156
     },
     {
      "kind" : "template",
      "line" : 16156,
      "name" : "roll",
      "parameters" : [
       {
        "name" : "units",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "roll",
        "kind" : "function",
        "line" : 16156,
        "type" : "pure nothrow void(long value)",
        "parameters" : [
         {
          "name" : "value",
          "deco" : "l"
         }
        ],
        "endline" : 16162
       }
      ]
     },
     {
      "name" : "__unittestL16165_800",
      "kind" : "function",
      "line" : 16165,
      "endline" : 16352
     },
     {
      "name" : "__unittestL16352_801",
      "kind" : "function",
      "line" : 16352,
      "endline" : 16523
     },
     {
      "name" : "__unittestL16523_802",
      "kind" : "function",
      "line" : 16523,
      "endline" : 16687
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
      "line" : 16687,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
        "line" : 16687,
        "type" : "const pure nothrow DateTime(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 16711
       }
      ]
     },
     {
      "name" : "__unittestL16713_803",
      "kind" : "function",
      "line" : 16713,
      "endline" : 16797
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime), as well as assigning the result to this $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
      "line" : 16797,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "comment" : "\n        Gives the result of adding or subtracting a duration from this\n        $(D DateTime), as well as assigning the result to this $(D DateTime).\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD +) $(TD duration) $(TD -->) $(TD DateTime))\n        $(TR $(TD DateTime) $(TD -) $(TD duration) $(TD -->) $(TD DateTime))\n        )\n\n        Params:\n            duration = The duration to add to or subtract from this\n                       $(D DateTime).\n      \n",
        "line" : 16797,
        "type" : "pure nothrow DateTime(in D duration)",
        "parameters" : [
         {
          "name" : "duration",
          "type" : "D",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 16821
       }
      ]
     },
     {
      "name" : "__unittestL16823_804",
      "kind" : "function",
      "line" : 16823,
      "endline" : 16883
     },
     {
      "kind" : "template",
      "comment" : "\n        Gives the difference between two $(D DateTime)s.\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD -) $(TD DateTime) $(TD -->) $(TD duration))\n        )\n      \n",
      "line" : 16883,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "comment" : "\n        Gives the difference between two $(D DateTime)s.\n\n        The legal types of arithmetic for $(D DateTime) using this operator are\n\n        $(BOOKTABLE,\n        $(TR $(TD DateTime) $(TD -) $(TD DateTime) $(TD -->) $(TD duration))\n        )\n      \n",
        "line" : 16883,
        "type" : "const pure nothrow Duration(in DateTime rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "DateTime",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 16890
       }
      ]
     },
     {
      "name" : "__unittestL16892_805",
      "kind" : "function",
      "line" : 16892,
      "endline" : 16998
     },
     {
      "name" : "diffMonths",
      "kind" : "function",
      "comment" : "\n        Returns the difference between the two $(D DateTime)s in months.\n\n        To get the difference in years, subtract the year property\n        of two $(D SysTime)s. To get the difference in days or weeks,\n        subtract the $(D SysTime)s themselves and use the $(D Duration)\n        that results. Because converting between months and smaller\n        units requires a specific date (which $(D Duration)s don't have),\n        getting the difference in months requires some math using both\n        the year and month properties, so this is a convenience function for\n        getting the difference in months.\n\n        Note that the number of days in the months or how far into the month\n        either date is is irrelevant. It is the difference in the month property\n        combined with the difference in years * 12. So, for instance,\n        December 31st and January 1st are one month apart just as December 1st\n        and January 31st are one month apart.\n\n        Params:\n            rhs = The $(D DateTime) to subtract from this one.\n\n        Examples:\n--------------------\nassert(DateTime(1999, 2, 1, 12, 2, 3).diffMonths(\n            DateTime(1999, 1, 31, 23, 59, 59)) == 1);\n\nassert(DateTime(1999, 1, 31, 0, 0, 0).diffMonths(\n            DateTime(1999, 2, 1, 12, 3, 42)) == -1);\n\nassert(DateTime(1999, 3, 1, 5, 30, 0).diffMonths(\n            DateTime(1999, 1, 1, 2, 4, 7)) == 2);\n\nassert(DateTime(1999, 1, 1, 7, 2, 4).diffMonths(\n            DateTime(1999, 3, 31, 0, 30, 58)) == -2);\n--------------------\n      \n",
      "line" : 16998,
      "deco" : "xFNaNbxS3std8datetime8DateTimeZi",
      "originalType" : "const pure nothrow int(in DateTime rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime8DateTime"
       }
      ],
      "endline" : 17001
     },
     {
      "name" : "__unittestL17003_806",
      "kind" : "function",
      "line" : 17003,
      "endline" : 17034
     },
     {
      "name" : "isLeapYear",
      "kind" : "function",
      "comment" : "\n        Whether this $(D DateTime) is in a leap year.\n     \n",
      "line" : 17034,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 17037
     },
     {
      "name" : "__unittestL17039_807",
      "kind" : "function",
      "line" : 17039,
      "endline" : 17056
     },
     {
      "name" : "dayOfWeek",
      "kind" : "function",
      "comment" : "\n        Day of the week this $(D DateTime) is on.\n      \n",
      "line" : 17056,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZE3std8datetime9DayOfWeek",
      "originalType" : "const pure nothrow DayOfWeek()",
      "endline" : 17059
     },
     {
      "name" : "__unittestL17061_808",
      "kind" : "function",
      "line" : 17061,
      "endline" : 17085
     },
     {
      "name" : "dayOfYear",
      "kind" : "function",
      "comment" : "\n        Day of the year this $(D DateTime) is on.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 1, 1), TimeOfDay(12, 22, 7)).dayOfYear == 1);\nassert(DateTime(Date(1999, 12, 31), TimeOfDay(7, 2, 59)).dayOfYear == 365);\nassert(DateTime(Date(2000, 12, 31), TimeOfDay(21, 20, 0)).dayOfYear == 366);\n--------------------\n      \n",
      "line" : 17085,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZt",
      "originalType" : "const pure nothrow ushort()",
      "endline" : 17088
     },
     {
      "name" : "__unittestL17090_809",
      "kind" : "function",
      "line" : 17090,
      "endline" : 17116
     },
     {
      "name" : "dayOfYear",
      "kind" : "function",
      "comment" : "\n        Day of the year.\n\n        Params:\n            day = The day of the year to set which day of the year this\n                  $(D DateTime) is on.\n      \n",
      "line" : 17116,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNdiZv",
      "originalType" : "pure void(int day)",
      "parameters" : [
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 17119
     },
     {
      "name" : "__unittestL17121_810",
      "kind" : "function",
      "line" : 17121,
      "endline" : 17160
     },
     {
      "name" : "dayOfGregorianCal",
      "kind" : "function",
      "comment" : "\n        The Xth day of the Gregorian Calendar that this $(D DateTime) is on.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1, 1, 1), TimeOfDay(0, 0, 0)).dayOfGregorianCal ==\n       1);\nassert(DateTime(Date(1, 12, 31), TimeOfDay(23, 59, 59)).dayOfGregorianCal ==\n       365);\nassert(DateTime(Date(2, 1, 1), TimeOfDay(2, 2, 2)).dayOfGregorianCal ==\n       366);\n\nassert(DateTime(Date(0, 12, 31), TimeOfDay(7, 7, 7)).dayOfGregorianCal ==\n       0);\nassert(DateTime(Date(0, 1, 1), TimeOfDay(19, 30, 0)).dayOfGregorianCal ==\n       -365);\nassert(DateTime(Date(-1, 12, 31), TimeOfDay(4, 7, 0)).dayOfGregorianCal ==\n       -366);\n\nassert(DateTime(Date(2000, 1, 1), TimeOfDay(9, 30, 20)).dayOfGregorianCal ==\n       730_120);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(15, 45, 50)).dayOfGregorianCal ==\n       734_137);\n--------------------\n     \n",
      "line" : 17160,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZi",
      "originalType" : "const pure nothrow int()",
      "endline" : 17163
     },
     {
      "name" : "__unittestL17165_811",
      "kind" : "function",
      "line" : 17165,
      "endline" : 17226
     },
     {
      "name" : "dayOfGregorianCal",
      "kind" : "function",
      "comment" : "\n        The Xth day of the Gregorian Calendar that this $(D DateTime) is on.\n        Setting this property does not affect the time portion of\n        $(D DateTime).\n\n        Params:\n            days = The day of the Gregorian Calendar to set this $(D DateTime)\n                   to.\n\n        Examples:\n--------------------\nauto dt = DateTime(Date.init, TimeOfDay(12, 0, 0));\ndt.dayOfGregorianCal = 1;\nassert(dt == DateTime(Date(1, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 365;\nassert(dt == DateTime(Date(1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 366;\nassert(dt == DateTime(Date(2, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 0;\nassert(dt == DateTime(Date(0, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -365;\nassert(dt == DateTime(Date(-0, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = -366;\nassert(dt == DateTime(Date(-1, 12, 31), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 730_120;\nassert(dt == DateTime(Date(2000, 1, 1), TimeOfDay(12, 0, 0)));\n\ndt.dayOfGregorianCal = 734_137;\nassert(dt == DateTime(Date(2010, 12, 31), TimeOfDay(12, 0, 0)));\n--------------------\n     \n",
      "line" : 17226,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdiZv",
      "originalType" : "pure nothrow void(int days)",
      "parameters" : [
       {
        "name" : "days",
        "deco" : "i"
       }
      ],
      "endline" : 17229
     },
     {
      "name" : "__unittestL17231_812",
      "kind" : "function",
      "line" : 17231,
      "endline" : 17275
     },
     {
      "name" : "isoWeek",
      "kind" : "function",
      "comment" : "\n        The ISO 8601 week of the year that this $(D DateTime) is in.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/ISO_week_date, ISO Week Date)\n      \n",
      "line" : 17275,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 17278
     },
     {
      "name" : "__unittestL17280_813",
      "kind" : "function",
      "line" : 17280,
      "endline" : 17313
     },
     {
      "name" : "endOfMonth",
      "kind" : "function",
      "comment" : "\n        $(D DateTime) for the last day in the month that this $(D DateTime) is\n        in. The time portion of endOfMonth is always 23:59:59.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).endOfMonth ==\n       DateTime(Date(1999, 1, 31), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).endOfMonth ==\n       DateTime(Date(1999, 2, 28), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).endOfMonth ==\n       DateTime(Date(2000, 2, 29), TimeOfDay(23, 59, 59)));\n\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).endOfMonth ==\n       DateTime(Date(2000, 6, 30), TimeOfDay(23, 59, 59)));\n--------------------\n      \n",
      "line" : 17313,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZS3std8datetime8DateTime",
      "originalType" : "const pure nothrow DateTime()",
      "endline" : 17319
     },
     {
      "name" : "__unittestL17321_814",
      "kind" : "function",
      "line" : 17321,
      "endline" : 17380
     },
     {
      "name" : "daysInMonth",
      "kind" : "function",
      "comment" : "\n        The last day in the month that this $(D DateTime) is in.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1999, 1, 6), TimeOfDay(0, 0, 0)).daysInMonth == 31);\nassert(DateTime(Date(1999, 2, 7), TimeOfDay(19, 30, 0)).daysInMonth == 28);\nassert(DateTime(Date(2000, 2, 7), TimeOfDay(5, 12, 27)).daysInMonth == 29);\nassert(DateTime(Date(2000, 6, 4), TimeOfDay(12, 22, 9)).daysInMonth == 30);\n--------------------\n      \n",
      "line" : 17380,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZh",
      "originalType" : "const pure nothrow ubyte()",
      "endline" : 17383
     },
     {
      "name" : "__unittestL17385_815",
      "kind" : "function",
      "line" : 17385,
      "endline" : 17414
     },
     {
      "name" : "isAD",
      "kind" : "function",
      "comment" : "\n        Whether the current year is a date in A.D.\n\n        Examples:\n--------------------\nassert(DateTime(Date(1, 1, 1), TimeOfDay(12, 7, 0)).isAD);\nassert(DateTime(Date(2010, 12, 31), TimeOfDay(0, 0, 0)).isAD);\nassert(!DateTime(Date(0, 12, 31), TimeOfDay(23, 59, 59)).isAD);\nassert(!DateTime(Date(-2010, 1, 1), TimeOfDay(2, 2, 2)).isAD);\n--------------------\n      \n",
      "line" : 17414,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 17417
     },
     {
      "name" : "__unittestL17419_816",
      "kind" : "function",
      "line" : 17419,
      "endline" : 17443
     },
     {
      "name" : "julianDay",
      "kind" : "function",
      "comment" : "\n        The julian day for this $(D DateTime) at the given time. For example,\n        prior to noon, 1996-03-31 would be the julian day number 2_450_173, so\n        this function returns 2_450_173, while from noon onward, the julian\n        day number would be 2_450_174, so this function returns 2_450_174.\n      \n",
      "line" : 17443,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZl",
      "originalType" : "const pure nothrow long()",
      "endline" : 17449
     },
     {
      "name" : "__unittestL17451_817",
      "kind" : "function",
      "line" : 17451,
      "endline" : 17491
     },
     {
      "name" : "modJulianDay",
      "kind" : "function",
      "comment" : "\n        The modified julian day for any time on this date (since, the modified\n        julian day changes at midnight).\n      \n",
      "line" : 17491,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZl",
      "originalType" : "const pure nothrow long()",
      "endline" : 17494
     },
     {
      "name" : "__unittestL17496_818",
      "kind" : "function",
      "line" : 17496,
      "endline" : 17532
     },
     {
      "name" : "toISOString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D DateTime) to a string with the format YYYYMMDDTHHMMSS.\n\n        Examples:\n--------------------\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOString() ==\n       \"20100704T070612\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOString() ==\n       \"19981225T021500\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOString() ==\n       \"00000105T230959\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOString() ==\n       \"-00040105T000002\");\n--------------------\n      \n",
      "line" : 17532,
      "deco" : "xFNbZAya",
      "endline" : 17538
     },
     {
      "name" : "__unittestL17540_819",
      "kind" : "function",
      "line" : 17540,
      "endline" : 17592
     },
     {
      "name" : "toISOExtString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D DateTime) to a string with the format\n        YYYY-MM-DDTHH:MM:SS.\n\n        Examples:\n--------------------\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toISOExtString() ==\n       \"2010-07-04T07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toISOExtString() ==\n       \"1998-12-25T02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toISOExtString() ==\n       \"0000-01-05T23:09:59\");\n\nassert(DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)).toISOExtString() ==\n       \"-0004-01-05T00:00:02\");\n--------------------\n      \n",
      "line" : 17592,
      "deco" : "xFNbZAya",
      "endline" : 17598
     },
     {
      "name" : "__unittestL17600_820",
      "kind" : "function",
      "line" : 17600,
      "endline" : 17651
     },
     {
      "name" : "toSimpleString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D DateTime) to a string with the format\n        YYYY-Mon-DD HH:MM:SS.\n\n        Examples:\n--------------------\nassert(DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)).toSimpleString() ==\n       \"2010-Jul-04 07:06:12\");\n\nassert(DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)).toSimpleString() ==\n       \"1998-Dec-25 02:15:00\");\n\nassert(DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)).toSimpleString() ==\n       \"0000-Jan-05 23:09:59\");\n\nassert(DateTime(Dte(-4, 1, 5), TimeOfDay(0, 0, 2)).toSimpleString() ==\n       \"-0004-Jan-05 00:00:02\");\n--------------------\n      \n",
      "line" : 17651,
      "deco" : "xFNbZAya",
      "endline" : 17657
     },
     {
      "name" : "__unittestL17659_821",
      "kind" : "function",
      "line" : 17659,
      "endline" : 17698
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 17698,
      "deco" : "FZAya",
      "endline" : 17701
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n        Converts this $(D DateTime) to a string.\n      \n",
      "line" : 17709,
      "deco" : "xFNbZAya",
      "endline" : 17712
     },
     {
      "name" : "__unittestL17714_822",
      "kind" : "function",
      "line" : 17714,
      "endline" : 17758
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D DateTime) from a string with the format YYYYMMDDTHHMMSS.\n        Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO format for dates and times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO format\n            or if the resulting $(D DateTime) would not be valid.\n\n        Examples:\n--------------------\nassert(DateTime.fromISOString(\"20100704T070612\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOString(\"19981225T021500\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOString(\"00000105T230959\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOString(\"-00040105T000002\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOString(\" 20100704T070612 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n--------------------\n      \n",
      "line" : 17758,
      "name" : "fromISOString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOString",
        "kind" : "function",
        "line" : 17758,
        "type" : "DateTime(in S isoString)",
        "parameters" : [
         {
          "name" : "isoString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 17772
       }
      ]
     },
     {
      "name" : "__unittestL17774_823",
      "kind" : "function",
      "line" : 17774,
      "endline" : 17850
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D DateTime) from a string with the format\n        YYYY-MM-DDTHH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            isoString = A string formatted in the ISO Extended format for dates\n                        and times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the ISO\n            Extended format or if the resulting $(D DateTime) would not be\n            valid.\n\n        Examples:\n--------------------\nassert(DateTime.fromISOExtString(\"2010-07-04T07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n\nassert(DateTime.fromISOExtString(\"1998-12-25T02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\n\nassert(DateTime.fromISOExtString(\"0000-01-05T23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\n\nassert(DateTime.fromISOExtString(\"-0004-01-05T00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\n\nassert(DateTime.fromISOExtString(\" 2010-07-04T07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n--------------------\n      \n",
      "line" : 17850,
      "name" : "fromISOExtString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOExtString",
        "kind" : "function",
        "line" : 17850,
        "type" : "DateTime(in S isoExtString)",
        "parameters" : [
         {
          "name" : "isoExtString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 17864
       }
      ]
     },
     {
      "name" : "__unittestL17866_824",
      "kind" : "function",
      "line" : 17866,
      "endline" : 17936
     },
     {
      "kind" : "template",
      "comment" : "\n        Creates a $(D DateTime) from a string with the format\n        YYYY-Mon-DD HH:MM:SS. Whitespace is stripped from the given string.\n\n        Params:\n            simpleString = A string formatted in the way that toSimpleString\n                           formats dates and times.\n\n        Throws:\n            $(D DateTimeException) if the given string is not in the correct\n            format or if the resulting $(D DateTime) would not be valid.\n\n        Examples:\n--------------------\nassert(DateTime.fromSimpleString(\"2010-Jul-04 07:06:12\") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\nassert(DateTime.fromSimpleString(\"1998-Dec-25 02:15:00\") ==\n       DateTime(Date(1998, 12, 25), TimeOfDay(2, 15, 0)));\nassert(DateTime.fromSimpleString(\"0000-Jan-05 23:09:59\") ==\n       DateTime(Date(0, 1, 5), TimeOfDay(23, 9, 59)));\nassert(DateTime.fromSimpleString(\"-0004-Jan-05 00:00:02\") ==\n       DateTime(Date(-4, 1, 5), TimeOfDay(0, 0, 2)));\nassert(DateTime.fromSimpleString(\" 2010-Jul-04 07:06:12 \") ==\n       DateTime(Date(2010, 7, 4), TimeOfDay(7, 6, 12)));\n--------------------\n      \n",
      "line" : 17936,
      "name" : "fromSimpleString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromSimpleString",
        "kind" : "function",
        "line" : 17936,
        "type" : "DateTime(in S simpleString)",
        "parameters" : [
         {
          "name" : "simpleString",
          "type" : "S",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 17950
       }
      ]
     },
     {
      "name" : "__unittestL17952_825",
      "kind" : "function",
      "line" : 17952,
      "endline" : 18008
     },
     {
      "name" : "min",
      "kind" : "function",
      "comment" : "\n        Returns the $(D DateTime) farthest in the past which is representable by\n        $(D DateTime).\n      \n",
      "line" : 18008,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime8DateTime",
      "originalType" : "pure nothrow DateTime()",
      "endline" : 18022
     },
     {
      "name" : "__unittestL18024_826",
      "kind" : "function",
      "line" : 18024,
      "endline" : 18038
     },
     {
      "name" : "max",
      "kind" : "function",
      "comment" : "\n        Returns the $(D DateTime) farthest in the future which is representable\n        by $(D DateTime).\n      \n",
      "line" : 18038,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNaNbNdZS3std8datetime8DateTime",
      "originalType" : "pure nothrow DateTime()",
      "endline" : 18055
     },
     {
      "name" : "__unittestL18057_827",
      "kind" : "function",
      "line" : 18057,
      "endline" : 18067
     },
     {
      "name" : "addSeconds",
      "kind" : "function",
      "protection" : "private",
      "line" : 18078,
      "deco" : "FNaNbNclZS3std8datetime8DateTime",
      "originalType" : "pure nothrow DateTime(long seconds)",
      "parameters" : [
       {
        "name" : "seconds",
        "deco" : "l"
       }
      ],
      "endline" : 18104
     },
     {
      "name" : "__unittestL18106_828",
      "kind" : "function",
      "protection" : "private",
      "line" : 18106,
      "endline" : 18280
     },
     {
      "name" : "_date",
      "kind" : "variable",
      "protection" : "private",
      "line" : 18280,
      "deco" : "S3std8datetime4Date",
      "offset" : 0
     },
     {
      "name" : "_tod",
      "kind" : "variable",
      "protection" : "private",
      "line" : 18281,
      "deco" : "S3std8datetime9TimeOfDay",
      "offset" : 4
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Represents an interval of time.\n\n    An $(D Interval) has a starting point and an end point. The interval of time\n    is therefore the time starting at the starting point up to, but not\n    including, the end point. e.g.\n\n    $(BOOKTABLE,\n    $(TR $(TD [January 5th, 2010 - March 10th, 2010$(RPAREN)))\n    $(TR $(TD [05:00:30 - 12:00:00$(RPAREN)))\n    $(TR $(TD [1982-01-04T08:59:00 - 2010-07-04T12:00:00$(RPAREN)))\n    )\n\n    A range can be obtained from an $(D Interval), allowing iteration over\n    that interval, with the exact time points which are iterated over depending\n    on the function which generates the range.\n  \n",
    "line" : 18307,
    "name" : "Interval",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Interval",
      "kind" : "struct",
      "line" : 18307,
      "members" : [
       {
        "kind" : "template",
        "comment" : "\n        Params:\n            begin = The time point which begins the interval.\n            end   = The time point which ends (but is not included in) the\n                    interval.\n\n        Throws:\n            $(D DateTimeException) if $(D_PARAM end) is before $(D_PARAM begin).\n\n        Examples:\n--------------------\nInterval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n--------------------\n      \n",
        "line" : 18324,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 18324,
          "type" : "pure (in TP begin, in U end)",
          "parameters" : [
           {
            "name" : "begin",
            "type" : "TP",
            "storageClass" : [
             "in"
            ]
           },
           {
            "name" : "end",
            "type" : "U",
            "storageClass" : [
             "in"
            ]
           }
          ],
          "endline" : 18332
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n        Params:\n            begin    = The time point which begins the interval.\n            duration = The duration from the starting point to the end point.\n\n        Throws:\n            $(D DateTimeException) if the resulting $(D end) is before\n            $(D begin).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), dur!\"years\"(3)) ==\n       Interval!Date(Date(1996, 1, 2), Date(1999, 1, 2)));\n--------------------\n      \n",
        "line" : 18350,
        "name" : "this",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 18350,
          "type" : "pure (in TP begin, in D duration)",
          "parameters" : [
           {
            "name" : "begin",
            "type" : "TP",
            "storageClass" : [
             "in"
            ]
           },
           {
            "name" : "duration",
            "type" : "D",
            "storageClass" : [
             "in"
            ]
           }
          ],
          "endline" : 18358
         }
        ]
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D Interval) to assign to this one.\n      \n",
        "line" : 18365,
        "type" : "pure nothrow Interval(ref const Interval rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "Interval",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 18371
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D Interval) to assign to this one.\n      \n",
        "line" : 18378,
        "type" : "pure nothrow Interval(Interval rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "Interval"
         }
        ],
        "endline" : 18384
       },
       {
        "name" : "begin",
        "kind" : "function",
        "comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).begin ==\n       Date(1996, 1, 2));\n--------------------\n      \n",
        "line" : 18396,
        "type" : "const pure nothrow TP()",
        "endline" : 18399
       },
       {
        "name" : "begin",
        "kind" : "function",
        "comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n\n        Throws:\n            $(D DateTimeException) if the resulting interval would be invalid.\n      \n",
        "line" : 18411,
        "type" : "pure void(TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP"
         }
        ],
        "endline" : 18417
       },
       {
        "name" : "end",
        "kind" : "function",
        "comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).end ==\n       Date(2012, 3, 1));\n--------------------\n      \n",
        "line" : 18429,
        "type" : "const pure nothrow TP()",
        "endline" : 18432
       },
       {
        "name" : "end",
        "kind" : "function",
        "comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n\n        Throws:\n            $(D DateTimeException) if the resulting interval would be invalid.\n      \n",
        "line" : 18444,
        "type" : "pure void(TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP"
         }
        ],
        "endline" : 18450
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\n        Returns the duration between $(D begin) and $(D end).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).length ==\n       dur!\"days\"(5903));\n--------------------\n      \n",
        "line" : 18462,
        "type" : "const pure nothrow typeof(end - begin)()",
        "endline" : 18465
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n        Whether the interval's length is 0, that is, whether $(D begin == end).\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(1996, 1, 2)).empty);\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).empty);\n--------------------\n      \n",
        "line" : 18477,
        "type" : "const pure nothrow bool()",
        "endline" : 18480
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(1994, 12, 24)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2000, 1, 5)));\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 18503,
        "type" : "const pure bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18508
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n      \n",
        "line" : 18532,
        "type" : "const pure bool(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18540
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval going to positive infinity can never be contained in a finite\n        interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
        "line" : 18562,
        "type" : "const pure bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18567
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false (unless this interval is empty), because an\n        interval beginning at negative infinity can never be contained in a\n        finite interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
        "line" : 18589,
        "type" : "const pure bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18594
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2000, 1, 5)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 18619,
        "type" : "const pure bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18624
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 1))));\n--------------------\n      \n",
        "line" : 18649,
        "type" : "const pure bool(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18655
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n      \n",
        "line" : 18677,
        "type" : "const pure bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18682
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect with it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be before an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
        "line" : 18704,
        "type" : "const pure bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18709
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(1994, 12, 24)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2000, 1, 5)));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 18734,
        "type" : "const pure bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18739
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
        "line" : 18764,
        "type" : "const pure bool(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18770
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false (unless this interval is empty) because a finite\n        interval can never be after an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
        "line" : 18792,
        "type" : "const pure bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18797
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n      \n",
        "line" : 18816,
        "type" : "const pure bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18821
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
        "line" : 18845,
        "type" : "const pure bool(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18851
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 18872,
        "type" : "const pure bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18877
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n      \n",
        "line" : 18898,
        "type" : "const pure bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18903
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n      \n",
        "line" : 18927,
        "type" : "const Interval(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18935
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 18959,
        "type" : "const Interval(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18964
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 18988,
        "type" : "const Interval(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 18993
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(1996, 1, 2))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 9, 17))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 19018,
        "type" : "const pure bool(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19024
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 19046,
        "type" : "const pure bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19051
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 1, 2))));\n--------------------\n      \n",
        "line" : 19073,
        "type" : "const pure bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19078
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n      \n",
        "line" : 19102,
        "type" : "const Interval(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19111
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            PosInfInterval!Date(Date(2012, 3, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
        "line" : 19135,
        "type" : "const PosInfInterval!(TP)(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19141
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are not\n            adjacent or if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1996, 1, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
        "line" : 19165,
        "type" : "const NegInfInterval!(TP)(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19171
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(D DateTimeException) if either interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(1991, 1, 8))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            Interval!Date(Date(2012, 3, 1), Date(2013, 5, 7))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 5, 7)));\n--------------------\n      \n",
        "line" : 19196,
        "type" : "const pure Interval(in Interval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19205
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            PosInfInterval!Date(Date(2050, 1, 1))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
        "line" : 19230,
        "type" : "const pure PosInfInterval!(TP)(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19235
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this interval.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Examples:\n--------------------\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1602, 5, 21))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
        "line" : 19260,
        "type" : "const pure NegInfInterval!(TP)(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19265
       },
       {
        "kind" : "template",
        "comment" : "\n        Shifts the interval forward or backwards in time by the given duration\n        (a positive duration shifts the interval forward; a negative duration\n        shifts it backward). Effectively, it does $(D begin += duration) and\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));\n--------------------\n      \n",
        "line" : 19293,
        "name" : "shift",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "shift",
          "kind" : "function",
          "comment" : "\n        Shifts the interval forward or backwards in time by the given duration\n        (a positive duration shifts the interval forward; a negative duration\n        shifts it backward). Effectively, it does $(D begin += duration) and\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == Interval!Date(Date(1996, 2, 21), Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == Interval!Date(Date(1995, 11, 13), Date(2012, 2, 15)));\n--------------------\n      \n",
          "line" : 19293,
          "type" : "pure void(D duration)",
          "parameters" : [
           {
            "name" : "duration",
            "type" : "D"
           }
          ],
          "endline" : 19306
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n        Expands the interval forwards and/or backwards in time. Effectively,\n        it does $(D begin -= duration) and/or $(D end += duration). Whether\n        it expands forwards and/or backwards in time is determined by\n        $(D_PARAM dir).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n\ninterval1.expand(2);\nassert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));\n\ninterval2.expand(-2);\nassert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));\n--------------------\n      \n",
        "line" : 19390,
        "name" : "expand",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "expand",
          "kind" : "function",
          "comment" : "\n        Expands the interval forwards and/or backwards in time. Effectively,\n        it does $(D begin -= duration) and/or $(D end += duration). Whether\n        it expands forwards and/or backwards in time is determined by\n        $(D_PARAM dir).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Throws:\n            $(D DateTimeException) this interval is empty or if the resulting\n            interval would be invalid.\n\n        Examples:\n--------------------\nauto interval1 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\nauto interval2 = Interval!Date(Date(1996, 1, 2), Date(2012, 3, 1));\n\ninterval1.expand(2);\nassert(interval1 == Interval!Date(Date(1994, 1, 2), Date(2014, 3, 1)));\n\ninterval2.expand(-2);\nassert(interval2 == Interval!Date(Date(1998, 1, 2), Date(2010, 3, 1)));\n--------------------\n      \n",
          "line" : 19390,
          "type" : "pure void(D duration, Direction dir = Direction.both)",
          "parameters" : [
           {
            "name" : "duration",
            "type" : "D"
           },
           {
            "name" : "dir",
            "type" : "Direction",
            "default" : "Direction.both"
           }
          ],
          "endline" : 19433
         }
        ]
       },
       {
        "name" : "fwdRange",
        "kind" : "function",
        "comment" : "\n        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(D DateTimeException) will be\n        thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or beyond the $(D end)\n        of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant if when creating a custom delegate.\n\n        Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n      \n",
        "line" : 19601,
        "type" : "const IntervalRange!(TP, Direction.fwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
        "parameters" : [
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         },
         {
          "name" : "popFirst",
          "type" : "PopFirst",
          "default" : "PopFirst.no"
         }
        ],
        "endline" : 19611
       },
       {
        "name" : "bwdRange",
        "kind" : "function",
        "comment" : "\n        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(D DateTimeException) will\n        be thrown. The range will be empty and iteration complete when\n        $(D_PARAM func) generates a time point equal to or less than the\n        $(D begin) of the interval.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" making them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 1), Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\n//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\nassert(range.front == Date(2010, 9, 9));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n      \n",
        "line" : 19694,
        "type" : "const IntervalRange!(TP, Direction.bwd)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
        "parameters" : [
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         },
         {
          "name" : "popFirst",
          "type" : "PopFirst",
          "default" : "PopFirst.no"
         }
        ],
        "endline" : 19704
       },
       {
        "name" : "toString",
        "kind" : "function",
        "line" : 19713,
        "type" : "string()",
        "endline" : 19716
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : "\n        Converts this interval to a string.\n      \n",
        "line" : 19725,
        "type" : "const nothrow string()",
        "endline" : 19728
       },
       {
        "name" : "_toStringImpl",
        "kind" : "function",
        "line" : 19737,
        "type" : "const nothrow string()",
        "endline" : 19743
       },
       {
        "name" : "_enforceNotEmpty",
        "kind" : "function",
        "line" : 19750,
        "type" : "const pure void(size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 19754
       },
       {
        "name" : "_valid",
        "kind" : "function",
        "line" : 19764,
        "type" : "pure nothrow bool(in TP begin, in TP end)",
        "parameters" : [
         {
          "name" : "begin",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "end",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 19767
       },
       {
        "name" : "__invariant8",
        "kind" : "function",
        "line" : 19770
       },
       {
        "name" : "_begin",
        "kind" : "variable",
        "line" : 19776,
        "type" : "TP"
       },
       {
        "name" : "_end",
        "kind" : "variable",
        "line" : 19777,
        "type" : "TP"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL19781_829",
    "kind" : "function",
    "line" : 19781,
    "endline" : 19806
   },
   {
    "name" : "__unittestL19806_830",
    "kind" : "function",
    "line" : 19806,
    "endline" : 19825
   },
   {
    "name" : "__unittestL19825_831",
    "kind" : "function",
    "line" : 19825,
    "endline" : 19844
   },
   {
    "name" : "__unittestL19844_832",
    "kind" : "function",
    "line" : 19844,
    "endline" : 19865
   },
   {
    "name" : "__unittestL19865_833",
    "kind" : "function",
    "line" : 19865,
    "endline" : 19887
   },
   {
    "name" : "__unittestL19887_834",
    "kind" : "function",
    "line" : 19887,
    "endline" : 19920
   },
   {
    "name" : "__unittestL19920_835",
    "kind" : "function",
    "line" : 19920,
    "endline" : 20019
   },
   {
    "name" : "__unittestL20019_836",
    "kind" : "function",
    "line" : 20019,
    "endline" : 20052
   },
   {
    "name" : "__unittestL20052_837",
    "kind" : "function",
    "line" : 20052,
    "endline" : 20152
   },
   {
    "name" : "__unittestL20152_838",
    "kind" : "function",
    "line" : 20152,
    "endline" : 20185
   },
   {
    "name" : "__unittestL20185_839",
    "kind" : "function",
    "line" : 20185,
    "endline" : 20284
   },
   {
    "name" : "__unittestL20284_840",
    "kind" : "function",
    "line" : 20284,
    "endline" : 20385
   },
   {
    "name" : "__unittestL20385_841",
    "kind" : "function",
    "line" : 20385,
    "endline" : 20513
   },
   {
    "name" : "__unittestL20513_842",
    "kind" : "function",
    "line" : 20513,
    "endline" : 20619
   },
   {
    "name" : "__unittestL20619_843",
    "kind" : "function",
    "line" : 20619,
    "endline" : 20758
   },
   {
    "name" : "__unittestL20758_844",
    "kind" : "function",
    "line" : 20758,
    "endline" : 20899
   },
   {
    "name" : "__unittestL20899_845",
    "kind" : "function",
    "line" : 20899,
    "endline" : 20939
   },
   {
    "name" : "__unittestL20939_846",
    "kind" : "function",
    "line" : 20939,
    "endline" : 20993
   },
   {
    "name" : "__unittestL20993_847",
    "kind" : "function",
    "line" : 20993,
    "endline" : 21034
   },
   {
    "name" : "__unittestL21034_848",
    "kind" : "function",
    "line" : 21034,
    "endline" : 21115
   },
   {
    "name" : "__unittestL21115_850",
    "kind" : "function",
    "line" : 21115,
    "endline" : 21184
   },
   {
    "name" : "__unittestL21184_852",
    "kind" : "function",
    "line" : 21184,
    "endline" : 21253
   },
   {
    "name" : "__unittestL21253_853",
    "kind" : "function",
    "line" : 21253,
    "endline" : 21274
   },
   {
    "kind" : "template",
    "comment" : "\n    Represents an interval of time which has positive infinity as its end point.\n\n    Any ranges which iterate over a $(D PosInfInterval) are infinite. So, the\n    main purpose of using $(D PosInfInterval) is to create an infinite range\n    which starts at a fixed point in time and goes to positive infinity.\n  \n",
    "line" : 21275,
    "name" : "PosInfInterval",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "PosInfInterval",
      "kind" : "struct",
      "line" : 21275,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n        Params:\n            begin = The time point which begins the interval.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n      \n",
        "line" : 21287,
        "type" : "pure nothrow (in TP begin)",
        "parameters" : [
         {
          "name" : "begin",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21290
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n      \n",
        "line" : 21297,
        "type" : "pure nothrow PosInfInterval(ref const PosInfInterval rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "PosInfInterval",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 21302
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D PosInfInterval) to assign to this one.\n      \n",
        "line" : 21309,
        "type" : "pure nothrow PosInfInterval(PosInfInterval rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "PosInfInterval"
         }
        ],
        "endline" : 21314
       },
       {
        "name" : "begin",
        "kind" : "function",
        "comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).begin == Date(1996, 1, 2));\n--------------------\n      \n",
        "line" : 21325,
        "type" : "const pure nothrow TP()",
        "endline" : 21328
       },
       {
        "name" : "begin",
        "kind" : "function",
        "comment" : "\n        The starting point of the interval. It is included in the interval.\n\n        Params:\n            timePoint = The time point to set $(D begin) to.\n      \n",
        "line" : 21337,
        "type" : "pure nothrow void(TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP"
         }
        ],
        "endline" : 21340
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n        Whether the interval's length is 0. Always returns false.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n      \n",
        "line" : 21351,
        "type" : "const pure nothrow bool()",
        "endline" : 21354
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(1994, 12, 24)));\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(Date(2000, 1, 5)));\n--------------------\n      \n",
        "line" : 21369,
        "type" : "const pure nothrow bool(TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP"
         }
        ],
        "endline" : 21372
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n      \n",
        "line" : 21396,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21401
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            PosInfInterval!Date(Date(1995, 7, 2))));\n--------------------\n      \n",
        "line" : 21419,
        "type" : "const pure nothrow bool(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21422
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval going to positive infinity\n        can never contain an interval beginning at negative infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
        "line" : 21440,
        "type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21443
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given time point.\n\n        Always returns false because an interval going to positive infinity\n        can never be before any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is before\n                        it.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(Date(2000, 1, 5)));\n--------------------\n      \n",
        "line" : 21462,
        "type" : "const pure nothrow bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21465
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval going to positive infinity can never be before any other\n        interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n      \n",
        "line" : 21491,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21496
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(1992, 5, 4))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            PosInfInterval!Date(Date(2013, 3, 7))));\n--------------------\n      \n",
        "line" : 21518,
        "type" : "const pure nothrow bool(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21521
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval going to positive infinity can\n        never be before any other interval.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n--------------------\n      \n",
        "line" : 21540,
        "type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21543
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(1994, 12, 24)));\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(Date(2000, 1, 5)));\n--------------------\n      \n",
        "line" : 21559,
        "type" : "const pure nothrow bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21562
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
        "line" : 21587,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21592
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval going to positive infinity can\n        never be after another interval going to positive infinity.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
        "line" : 21614,
        "type" : "const pure nothrow bool(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21617
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAfter(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n      \n",
        "line" : 21636,
        "type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21639
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n--------------------\n      \n",
        "line" : 21663,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21668
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals going to positive infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
        "line" : 21690,
        "type" : "const pure nothrow bool(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21693
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersects(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n      \n",
        "line" : 21712,
        "type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21715
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2000, 8, 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2011, 9, 17)));\n--------------------\n      \n",
        "line" : 21739,
        "type" : "const Interval!(TP)(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21746
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1999, 1 , 12)));\n--------------------\n      \n",
        "line" : 21766,
        "type" : "const pure nothrow PosInfInterval(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21769
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(1999, 7, 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       Interval!Date(Date(1996, 1 , 2), Date(2013, 1, 12)));\n--------------------\n      \n",
        "line" : 21792,
        "type" : "const Interval!(TP)(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21797
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            Interval!Date(Date(1989, 3, 1), Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1999, 1, 12)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n--------------------\n      \n",
        "line" : 21819,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21824
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals going to positive infinity\n        can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1990, 1, 7))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            PosInfInterval!Date(Date(1996, 1, 2))));\n--------------------\n      \n",
        "line" : 21846,
        "type" : "const pure nothrow bool(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21849
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 1, 2))));\n\nassert(!PosInfInterval!Date(Date(1996, 1, 2)).isAdjacent(\n            NegInfInterval!Date(Date(2000, 7, 1))));\n--------------------\n      \n",
        "line" : 21868,
        "type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21871
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
        "line" : 21901,
        "type" : "const PosInfInterval(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21907
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).merge(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
        "line" : 21933,
        "type" : "const pure nothrow PosInfInterval(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21936
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(500, 8, 9), Date(1602, 1, 31))) ==\n       PosInfInterval!Date(Date(500, 8, 9)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
        "line" : 21972,
        "type" : "const pure PosInfInterval(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 21977
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D NegInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       PosInfInterval!Date(Date(1990, 7 , 6)));\n\nassert(PosInfInterval!Date(Date(1996, 1, 2)).span(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       PosInfInterval!Date(Date(1996, 1 , 2)));\n--------------------\n      \n",
        "line" : 22006,
        "type" : "const pure nothrow PosInfInterval(in PosInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 22009
       },
       {
        "kind" : "template",
        "comment" : "\n        Shifts the $(D begin) of this interval forward or backwards in time by\n        the given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D begin += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));\n--------------------\n      \n",
        "line" : 22033,
        "name" : "shift",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "shift",
          "kind" : "function",
          "comment" : "\n        Shifts the $(D begin) of this interval forward or backwards in time by\n        the given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D begin += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == PosInfInterval!Date(Date(1996, 2, 21)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == PosInfInterval!Date(Date(1995, 11, 13)));\n--------------------\n      \n",
          "line" : 22033,
          "type" : "pure nothrow void(D duration)",
          "parameters" : [
           {
            "name" : "duration",
            "type" : "D"
           }
          ],
          "endline" : 22037
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n        Expands the interval backwards in time. Effectively, it does\n        $(D begin -= duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));\n--------------------\n      \n",
        "line" : 22107,
        "name" : "expand",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "expand",
          "kind" : "function",
          "comment" : "\n        Expands the interval backwards in time. Effectively, it does\n        $(D begin -= duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = PosInfInterval!Date(Date(1996, 1, 2));\nauto interval2 = PosInfInterval!Date(Date(1996, 1, 2));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == PosInfInterval!Date(Date(1995, 12, 31)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == PosInfInterval!Date(Date(1996, 1, 4)));\n--------------------\n      \n",
          "line" : 22107,
          "type" : "pure nothrow void(D duration)",
          "parameters" : [
           {
            "name" : "duration",
            "type" : "D"
           }
          ],
          "endline" : 22111
         }
        ]
       },
       {
        "name" : "fwdRange",
        "kind" : "function",
        "comment" : "\n        Returns a range which iterates forward over the interval, starting\n        at $(D begin), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D begin). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point less than or equal to the\n        current $(D front) of the range, then a $(D DateTimeException) will be\n        thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D fwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(2010, 9, 1));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date + dur!\"days\"(2);\n\n                return date + dur!\"days\"(1);\n            };\nauto range = interval.fwdRange(func);\n\n//An odd day. Using PopFirst.yes would have made this Date(2010, 9, 2).\nassert(range.front == Date(2010, 9, 1));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n      \n",
        "line" : 22236,
        "type" : "const PosInfIntervalRange!(TP)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
        "parameters" : [
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         },
         {
          "name" : "popFirst",
          "type" : "PopFirst",
          "default" : "PopFirst.no"
         }
        ],
        "endline" : 22244
       },
       {
        "name" : "toString",
        "kind" : "function",
        "line" : 22253,
        "type" : "string()",
        "endline" : 22256
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : "\n        Converts this interval to a string.\n      \n",
        "line" : 22265,
        "type" : "const nothrow string()",
        "endline" : 22268
       },
       {
        "name" : "_toStringImpl",
        "kind" : "function",
        "line" : 22276,
        "type" : "const nothrow string()",
        "endline" : 22282
       },
       {
        "name" : "_begin",
        "kind" : "variable",
        "line" : 22285,
        "type" : "TP"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL22289_854",
    "kind" : "function",
    "line" : 22289,
    "endline" : 22304
   },
   {
    "name" : "__unittestL22304_855",
    "kind" : "function",
    "line" : 22304,
    "endline" : 22323
   },
   {
    "name" : "__unittestL22323_856",
    "kind" : "function",
    "line" : 22323,
    "endline" : 22343
   },
   {
    "name" : "__unittestL22343_857",
    "kind" : "function",
    "line" : 22343,
    "endline" : 22373
   },
   {
    "name" : "__unittestL22373_858",
    "kind" : "function",
    "line" : 22373,
    "endline" : 22470
   },
   {
    "name" : "__unittestL22470_859",
    "kind" : "function",
    "line" : 22470,
    "endline" : 22500
   },
   {
    "name" : "__unittestL22500_860",
    "kind" : "function",
    "line" : 22500,
    "endline" : 22596
   },
   {
    "name" : "__unittestL22596_861",
    "kind" : "function",
    "line" : 22596,
    "endline" : 22626
   },
   {
    "name" : "__unittestL22626_862",
    "kind" : "function",
    "line" : 22626,
    "endline" : 22724
   },
   {
    "name" : "__unittestL22724_863",
    "kind" : "function",
    "line" : 22724,
    "endline" : 22822
   },
   {
    "name" : "__unittestL22822_864",
    "kind" : "function",
    "line" : 22822,
    "endline" : 22948
   },
   {
    "name" : "__unittestL22948_865",
    "kind" : "function",
    "line" : 22948,
    "endline" : 23045
   },
   {
    "name" : "__unittestL23045_866",
    "kind" : "function",
    "line" : 23045,
    "endline" : 23164
   },
   {
    "name" : "__unittestL23164_867",
    "kind" : "function",
    "line" : 23164,
    "endline" : 23284
   },
   {
    "name" : "__unittestL23284_868",
    "kind" : "function",
    "line" : 23284,
    "endline" : 23317
   },
   {
    "name" : "__unittestL23317_869",
    "kind" : "function",
    "line" : 23317,
    "endline" : 23364
   },
   {
    "name" : "__unittestL23364_870",
    "kind" : "function",
    "line" : 23364,
    "endline" : 23397
   },
   {
    "name" : "__unittestL23397_871",
    "kind" : "function",
    "line" : 23397,
    "endline" : 23444
   },
   {
    "name" : "__unittestL23444_873",
    "kind" : "function",
    "line" : 23444,
    "endline" : 23499
   },
   {
    "name" : "__unittestL23499_874",
    "kind" : "function",
    "line" : 23499,
    "endline" : 23522
   },
   {
    "kind" : "template",
    "comment" : "\n    Represents an interval of time which has negative infinity as its starting\n    point.\n\n    Any ranges which iterate over a $(D NegInfInterval) are infinite. So, the\n    main purpose of using $(D NegInfInterval) is to create an infinite range\n    which starts at negative infinity and goes to a fixed end point.\n    Iterate over it in reverse.\n  \n",
    "line" : 23523,
    "name" : "NegInfInterval",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "NegInfInterval",
      "kind" : "struct",
      "line" : 23523,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n        Params:\n            begin = The time point which begins the interval.\n\n        Examples:\n--------------------\nauto interval = PosInfInterval!Date(Date(1996, 1, 2));\n--------------------\n      \n",
        "line" : 23535,
        "type" : "pure nothrow (in TP end)",
        "parameters" : [
         {
          "name" : "end",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23538
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n      \n",
        "line" : 23545,
        "type" : "pure nothrow NegInfInterval(ref const NegInfInterval rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "NegInfInterval",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 23550
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D NegInfInterval) to assign to this one.\n      \n",
        "line" : 23557,
        "type" : "pure nothrow NegInfInterval(NegInfInterval rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "NegInfInterval"
         }
        ],
        "endline" : 23562
       },
       {
        "name" : "end",
        "kind" : "function",
        "comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).end == Date(2012, 3, 1));\n--------------------\n      \n",
        "line" : 23573,
        "type" : "const pure nothrow TP()",
        "endline" : 23576
       },
       {
        "name" : "end",
        "kind" : "function",
        "comment" : "\n        The end point of the interval. It is excluded from the interval.\n\n        Params:\n            timePoint = The time point to set end to.\n      \n",
        "line" : 23585,
        "type" : "pure nothrow void(TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP"
         }
        ],
        "endline" : 23588
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n        Whether the interval's length is 0. Always returns false.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(1996, 1, 2)).empty);\n--------------------\n      \n",
        "line" : 23599,
        "type" : "const pure nothrow bool()",
        "endline" : 23602
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given time point is within this interval.\n\n        Params:\n            timePoint = The time point to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(1994, 12, 24)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 23618,
        "type" : "const pure nothrow bool(TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP"
         }
        ],
        "endline" : 23621
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            Interval!Date(Date(1998, 2, 28), Date(2013, 5, 1))));\n--------------------\n      \n",
        "line" : 23645,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23650
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Always returns false because an interval beginning at negative\n        infinity can never contain an interval going to positive infinity.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n--------------------\n      \n",
        "line" : 23668,
        "type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23671
       },
       {
        "name" : "contains",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is completely within this interval.\n\n        Params:\n            interval = The interval to check for inclusion in this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).contains(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
        "line" : 23689,
        "type" : "const pure nothrow bool(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23692
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is\n                        before it.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2000, 1, 5)));\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 23709,
        "type" : "const pure nothrow bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23712
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
        "line" : 23737,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23742
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 23761,
        "type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23764
       },
       {
        "name" : "isBefore",
        "kind" : "function",
        "comment" : "\n        Whether this interval is before the given interval and does not\n        intersect it.\n\n        Always returns false because an interval beginning at negative\n        infinity can never be before another interval beginning at negative\n        infinity.\n\n        Params:\n            interval = The interval to check for against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isBefore(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
        "line" : 23787,
        "type" : "const pure nothrow bool(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23790
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given time point.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any time point.\n\n        Params:\n            timePoint = The time point to check whether this interval is after\n                        it.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(1994, 12, 24)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2000, 1, 5)));\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 23810,
        "type" : "const pure nothrow bool(in TP timePoint)",
        "parameters" : [
         {
          "name" : "timePoint",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23813
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not\n        intersect it.\n\n        Always returns false (unless the given interval is empty) because an\n        interval beginning at negative infinity can never be after any other\n        interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
        "line" : 23842,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23847
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 23869,
        "type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23872
       },
       {
        "name" : "isAfter",
        "kind" : "function",
        "comment" : "\n        Whether this interval is after the given interval and does not intersect\n        it.\n\n        Always returns false because an interval beginning at negative infinity\n        can never be after any other interval.\n\n        Params:\n            interval = The interval to check against this interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAfter(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
        "line" : 23894,
        "type" : "const pure nothrow bool(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23897
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(1999, 1, 12), Date(2011, 9, 17))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
        "line" : 23921,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23926
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Params:\n            interval = The interval to check for intersection with this\n                       interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 23945,
        "type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23948
       },
       {
        "name" : "intersects",
        "kind" : "function",
        "comment" : "\n        Whether the given interval overlaps this interval.\n\n        Always returns true because two intervals beginning at negative infinity\n        always overlap.\n\n        Params:\n            interval = The interval to check for intersection with this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersects(\n            NegInfInterval!Date(Date(2013, 7, 9))));\n--------------------\n      \n",
        "line" : 23969,
        "type" : "const pure nothrow bool(in NegInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 23972
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect or if\n            the given interval is empty.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2000, 8, 2)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 23996,
        "type" : "const Interval!(TP)(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24003
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1990, 7, 6))) ==\n       Interval!Date(Date(1990, 7 , 6), Date(2012, 3, 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            PosInfInterval!Date(Date(1999, 1, 12))) ==\n       Interval!Date(Date(1999, 1 , 12), Date(2012, 3, 1)));\n--------------------\n      \n",
        "line" : 24026,
        "type" : "const Interval!(TP)(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24031
       },
       {
        "name" : "intersection",
        "kind" : "function",
        "comment" : "\n        Returns the intersection of two intervals\n\n        Params:\n            interval = The interval to intersect with this interval.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(1999, 7 , 6)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).intersection(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n--------------------\n      \n",
        "line" : 24051,
        "type" : "const nothrow NegInfInterval(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24054
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(1999, 1, 12), Date(2012, 3, 1))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2012, 3, 1), Date(2019, 2, 2))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            Interval!Date(Date(2022, 10, 19), Date(2027, 6, 3))));\n--------------------\n      \n",
        "line" : 24082,
        "type" : "const pure bool(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24087
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(1999, 5, 4))));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            PosInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 24106,
        "type" : "const pure nothrow bool(in PosInfInterval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24109
       },
       {
        "name" : "isAdjacent",
        "kind" : "function",
        "comment" : "\n        Whether the given interval is adjacent to this interval.\n\n        Always returns false because two intervals beginning at negative\n        infinity can never be adjacent to one another.\n\n        Params:\n            interval = The interval to check whether its adjecent to this\n                       interval.\n\n        Examples:\n--------------------\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(1996, 5, 4))));\n\nassert(!NegInfInterval!Date(Date(2012, 3, 1)).isAdjacent(\n            NegInfInterval!Date(Date(2012, 3, 1))));\n--------------------\n      \n",
        "line" : 24131,
        "type" : "const pure nothrow bool(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24134
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Throws:\n            $(D DateTimeException) if the two intervals do not intersect and are\n            not adjacent or if the given interval is empty.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n--------------------\n      \n",
        "line" : 24164,
        "type" : "const NegInfInterval(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24170
       },
       {
        "name" : "merge",
        "kind" : "function",
        "comment" : "\n        Returns the union of two intervals\n\n        Params:\n            interval = The interval to merge with this interval.\n\n        Note:\n            There is no overload for $(D merge) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).merge(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
        "line" : 24196,
        "type" : "const pure nothrow NegInfInterval(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24199
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Throws:\n            $(D DateTimeException) if the given interval is empty.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1990, 7, 6), Date(2000, 8, 2))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            Interval!Date(Date(1999, 1, 12), Date(2015, 9, 2))) ==\n       NegInfInterval!Date(Date(2015, 9 , 2)));\n\nassert(NegInfInterval!Date(Date(1600, 1, 7)).span(\n            Interval!Date(Date(2012, 3, 11), Date(2017, 7, 1))) ==\n       NegInfInterval!Date(Date(2017, 7 , 1)));\n--------------------\n      \n",
        "line" : 24235,
        "type" : "const pure NegInfInterval(in Interval!(TP) interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24240
       },
       {
        "name" : "span",
        "kind" : "function",
        "comment" : "\n        Returns an interval that covers from the earliest time point of two\n        intervals up to (but not including) the latest time point of two\n        intervals.\n\n        Params:\n            interval = The interval to create a span together with this\n                       interval.\n\n        Note:\n            There is no overload for $(D span) which takes a\n            $(D PosInfInterval), because an interval\n            going from negative infinity to positive infinity\n            is not possible.\n\n        Examples:\n--------------------\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(1999, 7, 6))) ==\n       NegInfInterval!Date(Date(2012, 3 , 1)));\n\nassert(NegInfInterval!Date(Date(2012, 3, 1)).span(\n            NegInfInterval!Date(Date(2013, 1, 12))) ==\n       NegInfInterval!Date(Date(2013, 1 , 12)));\n--------------------\n      \n",
        "line" : 24269,
        "type" : "const pure nothrow NegInfInterval(in NegInfInterval interval)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 24272
       },
       {
        "kind" : "template",
        "comment" : "\n        Shifts the $(D end) of this interval forward or backwards in time by the\n        given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 4, 5));\nauto interval2 = NegInfInterval!Date(Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));\n--------------------\n      \n",
        "line" : 24296,
        "name" : "shift",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "shift",
          "kind" : "function",
          "comment" : "\n        Shifts the $(D end) of this interval forward or backwards in time by the\n        given duration (a positive duration shifts the interval forward; a\n        negative duration shifts it backward). Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to shift the interval by.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 4, 5));\nauto interval2 = NegInfInterval!Date(Date(2012, 4, 5));\n\ninterval1.shift(dur!\"days\"(50));\nassert(interval1 == NegInfInterval!Date(Date(2012, 5, 25)));\n\ninterval2.shift(dur!\"days\"(-50));\nassert(interval2 == NegInfInterval!Date( Date(2012, 2, 15)));\n--------------------\n      \n",
          "line" : 24296,
          "type" : "pure nothrow void(D duration)",
          "parameters" : [
           {
            "name" : "duration",
            "type" : "D"
           }
          ],
          "endline" : 24300
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n        Expands the interval forwards in time. Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 3, 1));\nauto interval2 = NegInfInterval!Date(Date(2012, 3, 1));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));\n--------------------\n      \n",
        "line" : 24369,
        "name" : "expand",
        "parameters" : [
         {
          "name" : "D",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "expand",
          "kind" : "function",
          "comment" : "\n        Expands the interval forwards in time. Effectively, it does\n        $(D end += duration).\n\n        Params:\n            duration = The duration to expand the interval by.\n            dir      = The direction in time to expand the interval.\n\n        Examples:\n--------------------\nauto interval1 = NegInfInterval!Date(Date(2012, 3, 1));\nauto interval2 = NegInfInterval!Date(Date(2012, 3, 1));\n\ninterval1.expand(dur!\"days\"(2));\nassert(interval1 == NegInfInterval!Date(Date(2012, 3, 3)));\n\ninterval2.expand(dur!\"days\"(-2));\nassert(interval2 == NegInfInterval!Date(Date(2012, 2, 28)));\n--------------------\n      \n",
          "line" : 24369,
          "type" : "pure nothrow void(D duration)",
          "parameters" : [
           {
            "name" : "duration",
            "type" : "D"
           }
          ],
          "endline" : 24373
         }
        ]
       },
       {
        "name" : "bwdRange",
        "kind" : "function",
        "comment" : "\n        Returns a range which iterates backwards over the interval, starting\n        at $(D end), using $(D_PARAM func) to generate each successive time\n        point.\n\n        The range's $(D front) is the interval's $(D end). $(D_PARAM func) is\n        used to generate the next $(D front) when $(D popFront) is called. If\n        $(D_PARAM popFirst) is $(D PopFirst.yes), then $(D popFront) is called\n        before the range is returned (so that $(D front) is a time point which\n        $(D_PARAM func) would generate).\n\n        If $(D_PARAM func) ever generates a time point greater than or equal to\n        the current $(D front) of the range, then a $(D DateTimeException) will\n        be thrown.\n\n        There are helper functions in this module which generate common\n        delegates to pass to $(D bwdRange). Their documentation starts with\n        \"Range-generating function,\" to make them easily searchable.\n\n        Params:\n            func     = The function used to generate the time points of the\n                       range over the interval.\n            popFirst = Whether $(D popFront) should be called on the range\n                       before returning it.\n\n        Throws:\n            $(D DateTimeException) if this interval is empty.\n\n        Warning:\n            $(D_PARAM func) must be logically pure. Ideally, $(D_PARAM func)\n            would be a function pointer to a pure function, but forcing\n            $(D_PARAM func) to be pure is far too restrictive to be useful, and\n            in order to have the ease of use of having functions which generate\n            functions to pass to $(D fwdRange), $(D_PARAM func) must be a\n            delegate.\n\n            If $(D_PARAM func) retains state which changes as it is called, then\n            some algorithms will not work correctly, because the range's\n            $(D save) will have failed to have really saved the range's state.\n            To avoid such bugs, don't pass a delegate which is\n            not logically pure to $(D fwdRange). If $(D_PARAM func) is given the\n            same time point with two different calls, it must return the same\n            result both times.\n\n            Of course, none of the functions in this module have this problem,\n            so it's only relevant for custom delegates.\n\n        Examples:\n--------------------\nauto interval = NegInfInterval!Date(Date(2010, 9, 9));\nauto func = (in Date date) //For iterating over even-numbered days.\n            {\n                if((date.day & 1) == 0)\n                    return date - dur!\"days\"(2);\n\n                return date - dur!\"days\"(1);\n            };\nauto range = interval.bwdRange(func);\n\nassert(range.front == Date(2010, 9, 9)); //An odd day. Using PopFirst.yes would have made this Date(2010, 9, 8).\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 8));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 4));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(!range.empty);\n--------------------\n      \n",
        "line" : 24497,
        "type" : "const NegInfIntervalRange!(TP)(TP delegate(in TP) func, PopFirst popFirst = PopFirst.no)",
        "parameters" : [
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         },
         {
          "name" : "popFirst",
          "type" : "PopFirst",
          "default" : "PopFirst.no"
         }
        ],
        "endline" : 24505
       },
       {
        "name" : "toString",
        "kind" : "function",
        "line" : 24514,
        "type" : "string()",
        "endline" : 24517
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : "\n        Converts this interval to a string.\n      \n",
        "line" : 24526,
        "type" : "const nothrow string()",
        "endline" : 24529
       },
       {
        "name" : "_toStringImpl",
        "kind" : "function",
        "line" : 24537,
        "type" : "const nothrow string()",
        "endline" : 24543
       },
       {
        "name" : "_end",
        "kind" : "variable",
        "line" : 24546,
        "type" : "TP"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL24550_875",
    "kind" : "function",
    "line" : 24550,
    "endline" : 24562
   },
   {
    "name" : "__unittestL24562_876",
    "kind" : "function",
    "line" : 24562,
    "endline" : 24581
   },
   {
    "name" : "__unittestL24581_877",
    "kind" : "function",
    "line" : 24581,
    "endline" : 24601
   },
   {
    "name" : "__unittestL24601_878",
    "kind" : "function",
    "line" : 24601,
    "endline" : 24632
   },
   {
    "name" : "__unittestL24632_879",
    "kind" : "function",
    "line" : 24632,
    "endline" : 24729
   },
   {
    "name" : "__unittestL24729_880",
    "kind" : "function",
    "line" : 24729,
    "endline" : 24760
   },
   {
    "name" : "__unittestL24760_881",
    "kind" : "function",
    "line" : 24760,
    "endline" : 24858
   },
   {
    "name" : "__unittestL24858_882",
    "kind" : "function",
    "line" : 24858,
    "endline" : 24884
   },
   {
    "name" : "__unittestL24884_883",
    "kind" : "function",
    "line" : 24884,
    "endline" : 24986
   },
   {
    "name" : "__unittestL24986_884",
    "kind" : "function",
    "line" : 24986,
    "endline" : 25084
   },
   {
    "name" : "__unittestL25084_885",
    "kind" : "function",
    "line" : 25084,
    "endline" : 25210
   },
   {
    "name" : "__unittestL25210_886",
    "kind" : "function",
    "line" : 25210,
    "endline" : 25309
   },
   {
    "name" : "__unittestL25309_887",
    "kind" : "function",
    "line" : 25309,
    "endline" : 25428
   },
   {
    "name" : "__unittestL25428_888",
    "kind" : "function",
    "line" : 25428,
    "endline" : 25548
   },
   {
    "name" : "__unittestL25548_889",
    "kind" : "function",
    "line" : 25548,
    "endline" : 25581
   },
   {
    "name" : "__unittestL25581_890",
    "kind" : "function",
    "line" : 25581,
    "endline" : 25633
   },
   {
    "name" : "__unittestL25633_891",
    "kind" : "function",
    "line" : 25633,
    "endline" : 25666
   },
   {
    "name" : "__unittestL25666_892",
    "kind" : "function",
    "line" : 25666,
    "endline" : 25713
   },
   {
    "name" : "__unittestL25713_894",
    "kind" : "function",
    "line" : 25713,
    "endline" : 25769
   },
   {
    "name" : "__unittestL25769_895",
    "kind" : "function",
    "line" : 25769,
    "endline" : 25822
   },
   {
    "kind" : "template",
    "comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given\n    $(D DayOfWeek) in a range.\n\n    Using this delegate allows iteration over successive time points which\n    are all the same day of the week. e.g. passing $(D DayOfWeek.mon) to\n    $(D everyDayOfWeek) would result in a delegate which could be used to\n    iterate over all of the Mondays in a range.\n\n    Params:\n        dir       = The direction to iterate in. If passing the return value to\n                    $(D fwdRange), use $(D Direction.fwd). If passing it to\n                    $(D bwdRange), use $(D Direction.bwd).\n        dayOfWeek = The week that each time point in the range will be.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDayOfWeek!Date(DayOfWeek.mon);\nauto range = interval.fwdRange(func);\n\n//A Thursday. Using PopFirst.yes would have made this Date(2010, 9, 6).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 6));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 13));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 20));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
    "line" : 25822,
    "name" : "everyDayOfWeek",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     },
     {
      "name" : "dir",
      "kind" : "value",
      "deco" : "E3std8datetime9Direction",
      "defaultValue" : "Direction.fwd"
     }
    ],
    "members" : [
     {
      "name" : "everyDayOfWeek",
      "kind" : "function",
      "line" : 25822,
      "type" : "nothrow TP delegate(in TP)(DayOfWeek dayOfWeek)",
      "parameters" : [
       {
        "name" : "dayOfWeek",
        "type" : "DayOfWeek"
       }
      ],
      "endline" : 25845
     }
    ]
   },
   {
    "name" : "__unittestL25847_896",
    "kind" : "function",
    "line" : 25847,
    "endline" : 25956
   },
   {
    "kind" : "template",
    "comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point with the given month\n    which would be reached by adding months to the given time point.\n\n    So, using this delegate allows iteration over successive time points\n    which are in the same month but different years. For example,\n    iterate over each successive December 25th in an interval by starting with a\n    date which had the 25th as its day and passed $(D Month.dec) to\n    $(D everyMonth) to create the delegate.\n\n    Since it wouldn't really make sense to be iterating over a specific month\n    and end up with some of the time points in the succeeding month or two years\n    after the previous time point, $(D AllowDayOverflow.no) is always used when\n    calculating the next time point.\n\n    Params:\n        dir   = The direction to iterate in. If passing the return value to\n                $(D fwdRange), use $(D Direction.fwd). If passing it to\n                $(D bwdRange), use $(D Direction.bwd).\n        month = The month that each time point in the range will be in.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2000, 1, 30), Date(2004, 8, 5));\nauto func = everyMonth!(Date)(Month.feb);\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2010, 2, 29).\nassert(range.front == Date(2000, 1, 30));\n\nrange.popFront();\nassert(range.front == Date(2000, 2, 29));\n\nrange.popFront();\nassert(range.front == Date(2001, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2002, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2003, 2, 28));\n\nrange.popFront();\nassert(range.front == Date(2004, 2, 28));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
    "line" : 25956,
    "name" : "everyMonth",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     },
     {
      "name" : "dir",
      "kind" : "value",
      "deco" : "E3std8datetime9Direction",
      "defaultValue" : "Direction.fwd"
     }
    ],
    "members" : [
     {
      "name" : "everyMonth",
      "kind" : "function",
      "line" : 25956,
      "type" : "TP delegate(in TP)(int month)",
      "parameters" : [
       {
        "name" : "month",
        "deco" : "i"
       }
      ],
      "endline" : 25989
     }
    ]
   },
   {
    "name" : "__unittestL25991_897",
    "kind" : "function",
    "line" : 25991,
    "endline" : 26103
   },
   {
    "kind" : "template",
    "comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    duration later.\n\n    Using this delegate allows iteration over successive time points which\n    are apart by the given duration e.g. passing $(D dur!\"days\"(3)) to\n    $(D everyDuration) would result in a delegate which could be used to iterate\n    over a range of days which are each 3 days apart.\n\n    Params:\n        dir      = The direction to iterate in. If passing the return value to\n                   $(D fwdRange), use $(D Direction.fwd). If passing it to\n                   $(D bwdRange), use $(D Direction.bwd).\n        duration = The duration which separates each successive time point in\n                   the range.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2010, 9, 27));\nauto func = everyDuration!Date(dur!\"days\"(8));\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2010, 9, 10).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 10));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 18));\n\nrange.popFront();\nassert(range.front == Date(2010, 9, 26));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
    "line" : 26103,
    "name" : "everyDuration",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     },
     {
      "name" : "dir",
      "kind" : "value",
      "deco" : "E3std8datetime9Direction",
      "defaultValue" : "Direction.fwd"
     },
     {
      "name" : "D",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "everyDuration",
      "kind" : "function",
      "line" : 26103,
      "type" : "nothrow TP delegate(in TP)(D duration)",
      "parameters" : [
       {
        "name" : "duration",
        "type" : "D"
       }
      ],
      "endline" : 26118
     }
    ]
   },
   {
    "name" : "__unittestL26120_898",
    "kind" : "function",
    "line" : 26120,
    "endline" : 26225
   },
   {
    "kind" : "template",
    "comment" : "\n    Range-generating function.\n\n    Returns a delegate which returns the next time point which is the given\n    number of years, month, and duration later.\n\n    The difference between this version of $(D everyDuration) and the version\n    which just takes a $(D Duration) is that this one also takes the number of\n    years and months (along with an $(D AllowDayOverflow) to indicate whether\n    adding years and months should allow the days to overflow).\n\n    Note that if iterating forward, $(D add!\"years\"()) is called on the given\n    time point, then $(D add!\"months\"()), and finally the duration is added\n    to it. However, if iterating backwards, the duration is added first, then\n    $(D add!\"months\"()) is called, and finally $(D add!\"years\"()) is called.\n    That way, going backwards generates close to the same time points that\n    iterating forward does, but since adding years and months is not entirely\n    reversible (due to possible day overflow, regardless of whether\n    $(D AllowDayOverflow.yes) or $(D AllowDayOverflow.no) is used), it can't be\n    guaranteed that iterating backwards will give the same time points as\n    iterating forward would have (even assuming that the end of the range is a\n    time point which would be returned by the delegate when iterating forward\n    from $(D begin)).\n\n    Params:\n        dir           = The direction to iterate in. If passing the return\n                        value to $(D fwdRange), use $(D Direction.fwd). If\n                        passing it to $(D bwdRange), use $(D Direction.bwd).\n        years         = The number of years to add to the time point passed to\n                        the delegate.\n        months        = The number of months to add to the time point passed to\n                        the delegate.\n        allowOverflow = Whether the days should be allowed to overflow on\n                        $(D begin) and $(D end), causing their month to\n                        increment.\n        duration      = The duration to add to the time point passed to the\n                        delegate.\n\n    Examples:\n--------------------\nauto interval = Interval!Date(Date(2010, 9, 2), Date(2025, 9, 27));\nauto func = everyDuration!Date(4, 1, AllowDayOverflow.yes, dur!\"days\"(2));\nauto range = interval.fwdRange(func);\n\n//Using PopFirst.yes would have made this Date(2014, 10, 12).\nassert(range.front == Date(2010, 9, 2));\n\nrange.popFront();\nassert(range.front == Date(2014, 10, 4));\n\nrange.popFront();\nassert(range.front == Date(2018, 11, 6));\n\nrange.popFront();\nassert(range.front == Date(2022, 12, 8));\n\nrange.popFront();\nassert(range.empty);\n--------------------\n  \n",
    "line" : 26225,
    "name" : "everyDuration",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     },
     {
      "name" : "dir",
      "kind" : "value",
      "deco" : "E3std8datetime9Direction",
      "defaultValue" : "Direction.fwd"
     },
     {
      "name" : "D",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "everyDuration",
      "kind" : "function",
      "line" : 26225,
      "type" : "nothrow TP delegate(in TP)(int years, int months = 0, AllowDayOverflow allowOverflow = AllowDayOverflow.yes, D duration = dur!(\"days\")(0))",
      "parameters" : [
       {
        "name" : "years",
        "deco" : "i"
       },
       {
        "name" : "months",
        "deco" : "i",
        "default" : "0"
       },
       {
        "name" : "allowOverflow",
        "type" : "AllowDayOverflow",
        "default" : "AllowDayOverflow.yes"
       },
       {
        "name" : "duration",
        "type" : "D",
        "default" : "dur!(\"days\")(0)"
       }
      ],
      "endline" : 26259
     }
    ]
   },
   {
    "name" : "__unittestL26261_899",
    "kind" : "function",
    "line" : 26261,
    "endline" : 26382
   },
   {
    "kind" : "template",
    "comment" : "\n    A range over an $(D Interval).\n\n    $(D IntervalRange) is only ever constructed by $(D Interval). However, when\n    it is constructed, it is given a function, $(D func), which is used to\n    generate the time points which are iterated over. $(D func) takes a time\n    point and returns a time point of the same type. For instance,\n    to iterate over all of the days in\n    the interval $(D Interval!Date), pass a function to $(D Interval)'s $(D fwdRange)\n    where that function took a $(D Date) and returned a $(D Date) which was one\n    day later. That function would then be used by $(D IntervalRange)'s\n    $(D popFront) to iterate over the $(D Date)s in the interval.\n\n    If $(D dir == Direction.fwd), then a range iterates forward in time, whereas\n    if $(D dir == Direction.bwd), then it iterates backwards in time. So, if\n    $(D dir == Direction.fwd) then $(D front == interval.begin), whereas if\n    $(D dir == Direction.bwd) then $(D front == interval.end). $(D func) must\n    generate a time point going in the proper direction of iteration, or a\n    $(D DateTimeException) will be thrown. So, to iterate forward in\n    time, the time point that $(D func) generates must be later in time than the\n    one passed to it. If it's either identical or earlier in time, then a\n    $(D DateTimeException) will be thrown. To iterate backwards, then\n    the generated time point must be before the time point which was passed in.\n\n    If the generated time point is ever passed the edge of the range in the\n    proper direction, then the edge of that range will be used instead. So, if\n    iterating forward, and the generated time point is past the interval's\n    $(D end), then $(D front) becomes $(D end). If iterating backwards, and the\n    generated time point is before $(D begin), then $(D front) becomes\n    $(D begin). In either case, the range would then be empty.\n\n    Also note that while normally the $(D begin) of an interval is included in\n    it and its $(D end) is excluded from it, if $(D dir == Direction.bwd), then\n    $(D begin) is treated as excluded and $(D end) is treated as included. This\n    allows for the same behavior in both directions. This works because none of\n    $(D Interval)'s functions which care about whether $(D begin) or $(D end) is\n    included or excluded are ever called by $(D IntervalRange). $(D interval)\n    returns a normal interval, regardless of whether $(D dir == Direction.fwd)\n    or if $(D dir == Direction.bwd), so any $(D Interval) functions which are\n    called on it which care about whether $(D begin) or $(D end) are included or\n    excluded will treat $(D begin) as included and $(D end) as excluded.\n  \n",
    "line" : 26384,
    "name" : "IntervalRange",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     },
     {
      "name" : "dir",
      "kind" : "value",
      "deco" : "E3std8datetime9Direction"
     }
    ],
    "members" : [
     {
      "name" : "IntervalRange",
      "kind" : "struct",
      "line" : 26384,
      "members" : [
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D IntervalRange) to assign to this one.\n      \n",
        "line" : 26391,
        "type" : "pure nothrow IntervalRange(ref IntervalRange rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "IntervalRange",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 26397
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n        Whether this $(D IntervalRange) is empty.\n      \n",
        "line" : 26403,
        "type" : "const pure nothrow bool()",
        "endline" : 26406
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n        The first time point in the range.\n\n        Throws:\n            $(D DateTimeException) if the range is empty.\n      \n",
        "line" : 26415,
        "type" : "const pure TP()",
        "endline" : 26423
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range. If the generated time point is beyond the edge\n        of the range, then $(D front) is set to that edge, and the range is then\n        empty. So, if iterating forwards, and the generated time point is\n        greater than the interval's $(D end), then $(D front) is set to\n        $(D end). If iterating backwards, and the generated time point is less\n        than the interval's $(D begin), then $(D front) is set to $(D begin).\n\n        Throws:\n            $(D DateTimeException) if the range is empty or if the generated\n            time point is in the wrong direction (i.e. if iterating\n            forward and the generated time point is before $(D front), or if\n            iterating backwards and the generated time point is after\n            $(D front)).\n      \n",
        "line" : 26442,
        "type" : "void()",
        "endline" : 26468
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n        Returns a copy of $(D this).\n      \n",
        "line" : 26474,
        "type" : "pure nothrow IntervalRange()",
        "endline" : 26477
       },
       {
        "name" : "interval",
        "kind" : "function",
        "comment" : "\n        The interval that this $(D IntervalRange) currently covers.\n      \n",
        "line" : 26483,
        "type" : "const pure nothrow Interval!(TP)()",
        "endline" : 26486
       },
       {
        "name" : "func",
        "kind" : "function",
        "comment" : "\n        The function used to generate the next time point in the range.\n      \n",
        "line" : 26492,
        "type" : "pure nothrow @property TP delegate(in TP)()",
        "endline" : 26495
       },
       {
        "name" : "direction",
        "kind" : "function",
        "comment" : "\n        The $(D Direction) that this range iterates in.\n      \n",
        "line" : 26501,
        "type" : "const pure nothrow Direction()",
        "endline" : 26504
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 26515,
        "type" : "pure nothrow (in Interval!(TP) interval, TP delegate(in TP) func)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "Interval!(TP)",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         }
        ],
        "endline" : 26519
       },
       {
        "name" : "_enforceNotEmpty",
        "kind" : "function",
        "line" : 26526,
        "type" : "const pure void(size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 26530
       },
       {
        "name" : "_enforceCorrectDirection",
        "kind" : "function",
        "line" : 26538,
        "type" : "const void(in TP newTP, size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "newTP",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 26558
       },
       {
        "name" : "_interval",
        "kind" : "variable",
        "line" : 26561,
        "type" : "Interval!(TP)"
       },
       {
        "name" : "_func",
        "kind" : "variable",
        "line" : 26562,
        "type" : "TP delegate(in TP)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL26566_900",
    "kind" : "function",
    "line" : 26566,
    "endline" : 26592
   },
   {
    "name" : "__unittestL26592_901",
    "kind" : "function",
    "line" : 26592,
    "endline" : 26643
   },
   {
    "name" : "__unittestL26643_902",
    "kind" : "function",
    "line" : 26643,
    "endline" : 26680
   },
   {
    "name" : "__unittestL26680_905",
    "kind" : "function",
    "line" : 26680,
    "endline" : 26717
   },
   {
    "name" : "__unittestL26717_908",
    "kind" : "function",
    "line" : 26717,
    "endline" : 26764
   },
   {
    "name" : "__unittestL26764_909",
    "kind" : "function",
    "line" : 26764,
    "endline" : 26789
   },
   {
    "name" : "__unittestL26789_910",
    "kind" : "function",
    "line" : 26789,
    "endline" : 26820
   },
   {
    "name" : "__unittestL26820_911",
    "kind" : "function",
    "line" : 26820,
    "endline" : 26845
   },
   {
    "name" : "__unittestL26845_912",
    "kind" : "function",
    "line" : 26845,
    "endline" : 26899
   },
   {
    "kind" : "template",
    "comment" : "\n    A range over a $(D PosInfInterval). It is an infinite range.\n\n    $(D PosInfIntervalRange) is only ever constructed by $(D PosInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D PosInfInterval!Date), pass a function to\n    $(D PosInfInterval)'s $(D fwdRange) where that function took a $(D Date) and\n    returned a $(D Date) which was one day later. That function would then be\n    used by $(D PosInfIntervalRange)'s $(D popFront) to iterate over the\n    $(D Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to positive infinity, the range is always iterated over\n    forwards, never backwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(D DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be later in time\n    than the one passed to it. If it's either identical or earlier in time, then\n    a $(D DateTimeException) will be thrown.\n  \n",
    "line" : 26901,
    "name" : "PosInfIntervalRange",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "PosInfIntervalRange",
      "kind" : "struct",
      "line" : 26901,
      "members" : [
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D PosInfIntervalRange) to assign to this one.\n      \n",
        "line" : 26908,
        "type" : "pure nothrow PosInfIntervalRange(ref PosInfIntervalRange rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "PosInfIntervalRange",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 26914
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "comment" : "\n        This is an infinite range, so it is never empty.\n      \n",
        "line" : 26920,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n        The first time point in the range.\n      \n",
        "line" : 26926,
        "type" : "const pure nothrow TP()",
        "endline" : 26929
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(D DateTimeException) if the generated time point is less than\n            $(D front).\n      \n",
        "line" : 26940,
        "type" : "void()",
        "endline" : 26947
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n        Returns a copy of $(D this).\n      \n",
        "line" : 26953,
        "type" : "pure nothrow PosInfIntervalRange()",
        "endline" : 26956
       },
       {
        "name" : "interval",
        "kind" : "function",
        "comment" : "\n        The interval that this range currently covers.\n      \n",
        "line" : 26962,
        "type" : "const pure nothrow PosInfInterval!(TP)()",
        "endline" : 26965
       },
       {
        "name" : "func",
        "kind" : "function",
        "comment" : "\n        The function used to generate the next time point in the range.\n      \n",
        "line" : 26971,
        "type" : "pure nothrow @property TP delegate(in TP)()",
        "endline" : 26974
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 26985,
        "type" : "pure nothrow (in PosInfInterval!(TP) interval, TP delegate(in TP) func)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "PosInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         }
        ],
        "endline" : 26989
       },
       {
        "name" : "_enforceCorrectDirection",
        "kind" : "function",
        "line" : 26997,
        "type" : "const void(in TP newTP, size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "newTP",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 27005
       },
       {
        "name" : "_interval",
        "kind" : "variable",
        "line" : 27008,
        "type" : "PosInfInterval!(TP)"
       },
       {
        "name" : "_func",
        "kind" : "variable",
        "line" : 27009,
        "type" : "TP delegate(in TP)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL27013_913",
    "kind" : "function",
    "line" : 27013,
    "endline" : 27038
   },
   {
    "name" : "__unittestL27038_914",
    "kind" : "function",
    "line" : 27038,
    "endline" : 27089
   },
   {
    "name" : "__unittestL27089_915",
    "kind" : "function",
    "line" : 27089,
    "endline" : 27105
   },
   {
    "name" : "__unittestL27105_916",
    "kind" : "function",
    "line" : 27105,
    "endline" : 27124
   },
   {
    "name" : "__unittestL27124_917",
    "kind" : "function",
    "line" : 27124,
    "endline" : 27137
   },
   {
    "name" : "__unittestL27137_918",
    "kind" : "function",
    "line" : 27137,
    "endline" : 27153
   },
   {
    "name" : "__unittestL27153_919",
    "kind" : "function",
    "line" : 27153,
    "endline" : 27198
   },
   {
    "kind" : "template",
    "comment" : "\n    A range over a $(D NegInfInterval). It is an infinite range.\n\n    $(D NegInfIntervalRange) is only ever constructed by $(D NegInfInterval).\n    However, when it is constructed, it is given a function, $(D func), which\n    is used to generate the time points which are iterated over. $(D func)\n    takes a time point and returns a time point of the same type. For\n    instance, to iterate\n    over all of the days in the interval $(D NegInfInterval!Date), pass a function to\n    $(D NegInfInterval)'s $(D bwdRange) where that function took a $(D Date) and\n    returned a $(D Date) which was one day earlier. That function would then be\n    used by $(D NegInfIntervalRange)'s $(D popFront) to iterate over the\n    $(D Date)s in the interval - though obviously, since the range is infinite,\n    use a function such as $(D std.range.take) with it rather than\n    iterating over $(I all) of the dates.\n\n    As the interval goes to negative infinity, the range is always iterated over\n    backwards, never forwards. $(D func) must generate a time point going in\n    the proper direction of iteration, or a $(D DateTimeException) will be\n    thrown. So, the time points that $(D func) generates must be earlier in time\n    than the one passed to it. If it's either identical or later in time, then a\n    $(D DateTimeException) will be thrown.\n\n    Also note that while normally the $(D end) of an interval is excluded from\n    it, $(D NegInfIntervalRange) treats it as if it were included. This allows\n    for the same behavior as with $(D PosInfIntervalRange). This works\n    because none of $(D NegInfInterval)'s functions which care about whether\n    $(D end) is included or excluded are ever called by\n    $(D NegInfIntervalRange). $(D interval) returns a normal interval, so any\n    $(D NegInfInterval) functions which are called on it which care about\n    whether $(D end) is included or excluded will treat $(D end) as excluded.\n  \n",
    "line" : 27200,
    "name" : "NegInfIntervalRange",
    "parameters" : [
     {
      "name" : "TP",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "NegInfIntervalRange",
      "kind" : "struct",
      "line" : 27200,
      "members" : [
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        Params:\n            rhs = The $(D NegInfIntervalRange) to assign to this one.\n      \n",
        "line" : 27207,
        "type" : "pure nothrow NegInfIntervalRange(ref NegInfIntervalRange rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "NegInfIntervalRange",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 27213
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "comment" : "\n        This is an infinite range, so it is never empty.\n      \n",
        "line" : 27219,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n        The first time point in the range.\n      \n",
        "line" : 27225,
        "type" : "const pure nothrow TP()",
        "endline" : 27228
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n        Pops $(D front) from the range, using $(D func) to generate the next\n        time point in the range.\n\n        Throws:\n            $(D DateTimeException) if the generated time point is greater than\n            $(D front).\n      \n",
        "line" : 27239,
        "type" : "void()",
        "endline" : 27246
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n        Returns a copy of $(D this).\n      \n",
        "line" : 27252,
        "type" : "pure nothrow NegInfIntervalRange()",
        "endline" : 27255
       },
       {
        "name" : "interval",
        "kind" : "function",
        "comment" : "\n        The interval that this range currently covers.\n      \n",
        "line" : 27261,
        "type" : "const pure nothrow NegInfInterval!(TP)()",
        "endline" : 27264
       },
       {
        "name" : "func",
        "kind" : "function",
        "comment" : "\n        The function used to generate the next time point in the range.\n      \n",
        "line" : 27270,
        "type" : "pure nothrow @property TP delegate(in TP)()",
        "endline" : 27273
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 27284,
        "type" : "pure nothrow (in NegInfInterval!(TP) interval, TP delegate(in TP) func)",
        "parameters" : [
         {
          "name" : "interval",
          "type" : "NegInfInterval!(TP)",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "func",
          "type" : "TP delegate(in TP)"
         }
        ],
        "endline" : 27288
       },
       {
        "name" : "_enforceCorrectDirection",
        "kind" : "function",
        "line" : 27296,
        "type" : "const void(in TP newTP, size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "newTP",
          "type" : "TP",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 27304
       },
       {
        "name" : "_interval",
        "kind" : "variable",
        "line" : 27307,
        "type" : "NegInfInterval!(TP)"
       },
       {
        "name" : "_func",
        "kind" : "variable",
        "line" : 27308,
        "type" : "TP delegate(in TP)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL27312_920",
    "kind" : "function",
    "line" : 27312,
    "endline" : 27336
   },
   {
    "name" : "__unittestL27336_921",
    "kind" : "function",
    "line" : 27336,
    "endline" : 27387
   },
   {
    "name" : "__unittestL27387_922",
    "kind" : "function",
    "line" : 27387,
    "endline" : 27403
   },
   {
    "name" : "__unittestL27403_923",
    "kind" : "function",
    "line" : 27403,
    "endline" : 27422
   },
   {
    "name" : "__unittestL27422_924",
    "kind" : "function",
    "line" : 27422,
    "endline" : 27435
   },
   {
    "name" : "__unittestL27435_925",
    "kind" : "function",
    "line" : 27435,
    "endline" : 27451
   },
   {
    "name" : "__unittestL27451_926",
    "kind" : "function",
    "line" : 27451,
    "endline" : 27472
   },
   {
    "name" : "TimeZone",
    "kind" : "class",
    "comment" : "\n    Represents a time zone. It is used with $(D SysTime) to indicate the time\n    zone of a $(D SysTime).\n  \n",
    "line" : 27473,
    "members" : [
     {
      "name" : "name",
      "kind" : "function",
      "comment" : "\n        The name of the time zone per the TZ Database. This is the name used to\n        get a $(D TimeZone) by name with $(D TimeZone.getTimeZone).\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)\n      \n",
      "line" : 27486,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZAya",
      "originalType" : "const nothrow string()",
      "endline" : 27489
     },
     {
      "name" : "stdName",
      "kind" : "function",
      "comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n      \n",
      "line" : 27499,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZAya",
      "originalType" : "const nothrow string()",
      "endline" : 27502
     },
     {
      "name" : "dstName",
      "kind" : "function",
      "comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n      \n",
      "line" : 27512,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNbNdZAya",
      "originalType" : "const nothrow string()",
      "endline" : 27515
     },
     {
      "name" : "hasDST",
      "kind" : "function",
      "comment" : "\n        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current dates\n        but will still return true for $(D hasDST) because the time zone did at\n        some point have DST.\n      \n",
      "line" : 27524,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()"
     },
     {
      "name" : "dstInEffect",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n      \n",
      "line" : 27536,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "xFNblZb",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ]
     },
     {
      "name" : "utcToTZ",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n      \n",
      "line" : 27547,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ]
     },
     {
      "name" : "tzToUTC",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
      "line" : 27558,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "adjTime",
        "deco" : "l"
       }
      ]
     },
     {
      "name" : "utcOffsetAt",
      "kind" : "function",
      "comment" : "\n        Returns what the offset from UTC is at the given std time.\n        It includes the DST offset in effect at that time (if any).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n      \n",
      "line" : 27569,
      "deco" : "xFNblZS4core4time8Duration",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 27572
     },
     {
      "name" : "getTimeZone",
      "kind" : "function",
      "comment" : "\n        Returns a $(D TimeZone) with the give name per the TZ Database.\n\n        This returns a $(D PosixTimeZone) on Posix systems and a\n        $(D WindowsTimeZone) on Windows systems. For\n        $(D PosixTimeZone) on Windows, call $(D PosixTimeZone.getTimeZone)\n        directly and give it the location of the TZ Database time zone files on\n        disk.\n\n        On Windows, the given TZ Database name is converted to the corresponding\n        time zone name on Windows prior to calling\n        $(D WindowsTimeZone.getTimeZone). This function allows for\n        the same time zone names on both Windows and Posix systems.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)<br>\n            $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n                  Windows <-> TZ Database Name Conversion Table)\n\n        Params:\n            name = The TZ Database name of the desired time zone\n\n        Throws:\n            $(D DateTimeException) if the given time zone could not be found.\n\n        Examples:\n--------------------\nauto tz = TimeZone.getTimeZone(\"America/Los_Angeles\");\n--------------------\n      \n",
      "line" : 27608,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaZyC3std8datetime8TimeZone",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       }
      ],
      "endline" : 27614
     },
     {
      "name" : "__unittestL27619_927",
      "kind" : "function",
      "line" : 27619,
      "endline" : 27914
     },
     {
      "name" : "getInstalledTZNames",
      "kind" : "function",
      "comment" : "\n        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        On Windows, this function will convert the Windows time zone names to\n        the corresponding TZ Database names with\n        $(D windowsTZNameToTZDatabaseName). To get the actual Windows time\n        zone names, use $(D WindowsTimeZone.getInstalledTZNames) directly.\n\n        Params:\n            subName = The first part of the time zones desired.\n\n        Throws:\n            $(D FileException) on Posix systems if it fails to read from disk.\n            $(D DateTimeException) on Windows systems if it fails to read the\n            registry.\n      \n",
      "line" : 27914,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaZAAya",
      "parameters" : [
       {
        "name" : "subName",
        "deco" : "Aya",
        "default" : "\"\""
       }
      ],
      "endline" : 27935
     },
     {
      "name" : "__unittestL27937_928",
      "kind" : "function",
      "line" : 27937,
      "endline" : 27956
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 27964,
      "deco" : "yFNaAyaAyaAyaZyC3std8datetime8TimeZone",
      "originalType" : "immutable pure (string name, string stdName, string dstName)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "stdName",
        "deco" : "Aya"
       },
       {
        "name" : "dstName",
        "deco" : "Aya"
       }
      ],
      "endline" : 27969
     },
     {
      "name" : "_name",
      "kind" : "variable",
      "protection" : "private",
      "line" : 27972,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAa",
      "originalType" : "string",
      "offset" : 16
     },
     {
      "name" : "_stdName",
      "kind" : "variable",
      "protection" : "private",
      "line" : 27973,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAa",
      "originalType" : "string",
      "offset" : 32
     },
     {
      "name" : "_dstName",
      "kind" : "variable",
      "protection" : "private",
      "line" : 27974,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAa",
      "originalType" : "string",
      "offset" : 48
     }
    ]
   },
   {
    "name" : "LocalTime",
    "kind" : "class",
    "comment" : "\n    A TimeZone which represents the current local time zone on\n    the system running your program.\n\n    This uses the underlying C calls to adjust the time rather than using\n    specific D code based off of system settings to calculate the time such as\n    $(D PosixTimeZone) and $(D WindowsTimeZone) do. That also means that it will\n    use whatever the current time zone is on the system, even if the system's\n    time zone changes while the program is running.\n  \n",
    "line" : 27988,
    "base" : "TimeZone",
    "members" : [
     {
      "name" : "opCall",
      "kind" : "function",
      "comment" : "\n        $(D LocalTime) is a singleton class. $(D LocalTime) returns its only\n        instance.\n      \n",
      "line" : 27996,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNaNbZyC3std8datetime9LocalTime",
      "endline" : 28000
     },
     {
      "name" : "stdName",
      "kind" : "function",
      "comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Standard Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n      \n",
      "line" : 28037,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNbNdZAya",
      "originalType" : "const nothrow string()",
      "endline" : 28076,
      "overrides" : [
       "std.datetime.TimeZone.stdName"
      ]
     },
     {
      "name" : "__unittestL28078_929",
      "kind" : "function",
      "line" : 28078,
      "endline" : 28110
     },
     {
      "name" : "dstName",
      "kind" : "function",
      "comment" : "\n        Typically, the abbreviation (generally 3 or 4 letters) for the time zone\n        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.\n\n        However, on Windows, it may be the unabbreviated name (e.g. Pacific\n        Daylight Time). Regardless, it is not the same as name.\n\n        This property is overridden because the local time of the system could\n        change while the program is running and we need to determine it\n        dynamically rather than it being fixed like it would be with most time\n        zones.\n      \n",
      "line" : 28110,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNbNdZAya",
      "originalType" : "const nothrow string()",
      "endline" : 28149,
      "overrides" : [
       "std.datetime.TimeZone.dstName"
      ]
     },
     {
      "name" : "__unittestL28151_930",
      "kind" : "function",
      "line" : 28151,
      "endline" : 28177
     },
     {
      "name" : "hasDST",
      "kind" : "function",
      "comment" : "\n        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n      \n",
      "line" : 28177,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 28211,
      "overrides" : [
       "std.datetime.TimeZone.hasDST"
      ]
     },
     {
      "name" : "__unittestL28213_931",
      "kind" : "function",
      "line" : 28213,
      "endline" : 28245
     },
     {
      "name" : "dstInEffect",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n      \n",
      "line" : 28245,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZb",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28275,
      "overrides" : [
       "std.datetime.TimeZone.dstInEffect"
      ]
     },
     {
      "name" : "__unittestL28277_932",
      "kind" : "function",
      "line" : 28277,
      "endline" : 28299
     },
     {
      "name" : "utcToTZ",
      "kind" : "function",
      "comment" : "\n        Returns hnsecs in the local time zone using the standard C function\n        calls on Posix systems and the standard Windows system calls on Windows\n        systems to adjust the time to the appropriate time zone from std time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n      \n",
      "line" : 28299,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28319,
      "overrides" : [
       "std.datetime.TimeZone.utcToTZ"
      ]
     },
     {
      "name" : "__unittestL28321_933",
      "kind" : "function",
      "line" : 28321,
      "endline" : 28342
     },
     {
      "name" : "tzToUTC",
      "kind" : "function",
      "comment" : "\n        Returns std time using the standard C function calls on Posix systems\n        and the standard Windows system calls on Windows systems to adjust the\n        time to UTC from the appropriate time zone.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
      "line" : 28342,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "adjTime",
        "deco" : "l"
       }
      ],
      "endline" : 28378,
      "overrides" : [
       "std.datetime.TimeZone.tzToUTC"
      ]
     },
     {
      "name" : "__unittestL28380_934",
      "kind" : "function",
      "line" : 28380,
      "endline" : 28524
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 28526,
      "deco" : "yFZyC3std8datetime9LocalTime",
      "originalType" : "immutable ()",
      "endline" : 28529
     },
     {
      "name" : "_localTime",
      "kind" : "variable",
      "protection" : "private",
      "line" : 28532,
      "storageClass" : [
       "static",
       "immutable"
      ],
      "deco" : "yC3std8datetime9LocalTime",
      "originalType" : "LocalTime",
      "init" : "LocalTime(\"\", \"\", \"\")"
     },
     {
      "name" : "_lowLock",
      "kind" : "variable",
      "protection" : "private",
      "line" : 28534,
      "storageClass" : [
       "static"
      ],
      "deco" : "b"
     },
     {
      "name" : "_tzsetWasCalled",
      "kind" : "variable",
      "protection" : "private",
      "line" : 28535,
      "storageClass" : [
       "static",
       "shared"
      ],
      "deco" : "Ob",
      "originalType" : "bool"
     },
     {
      "name" : "singleton",
      "kind" : "function",
      "protection" : "private",
      "line" : 28540,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZyC3std8datetime9LocalTime",
      "endline" : 28557
     }
    ]
   },
   {
    "name" : "UTC",
    "kind" : "class",
    "comment" : "\n    A $(D TimeZone) which represents UTC.\n  \n",
    "line" : 28564,
    "base" : "TimeZone",
    "members" : [
     {
      "name" : "opCall",
      "kind" : "function",
      "comment" : "\n        $(D UTC) is a singleton class. $(D UTC) returns its only instance.\n      \n",
      "line" : 28571,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNaNbZyC3std8datetime3UTC",
      "endline" : 28574
     },
     {
      "name" : "hasDST",
      "kind" : "function",
      "comment" : "\n        Always returns false.\n      \n",
      "line" : 28580,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 28583,
      "overrides" : [
       "std.datetime.TimeZone.hasDST"
      ]
     },
     {
      "name" : "dstInEffect",
      "kind" : "function",
      "comment" : "\n        Always returns false.\n      \n",
      "line" : 28589,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZb",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28592,
      "overrides" : [
       "std.datetime.TimeZone.dstInEffect"
      ]
     },
     {
      "name" : "utcToTZ",
      "kind" : "function",
      "comment" : "\n        Returns the given hnsecs without changing them at all.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n\n        See_Also:\n            $(D TimeZone.utcToTZ)\n      \n",
      "line" : 28605,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28608,
      "overrides" : [
       "std.datetime.TimeZone.utcToTZ"
      ]
     },
     {
      "name" : "__unittestL28610_935",
      "kind" : "function",
      "line" : 28610,
      "endline" : 28640
     },
     {
      "name" : "tzToUTC",
      "kind" : "function",
      "comment" : "\n        Returns the given hnsecs without changing them at all.\n\n        See_Also:\n            $(D TimeZone.tzToUTC)\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
      "line" : 28640,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "adjTime",
        "deco" : "l"
       }
      ],
      "endline" : 28643,
      "overrides" : [
       "std.datetime.TimeZone.tzToUTC"
      ]
     },
     {
      "name" : "__unittestL28645_936",
      "kind" : "function",
      "line" : 28645,
      "endline" : 28672
     },
     {
      "name" : "utcOffsetAt",
      "kind" : "function",
      "comment" : "\n        Returns a $(CXREF time, Duration) of 0.\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n      \n",
      "line" : 28672,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZS4core4time8Duration",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28675,
      "overrides" : [
       "std.datetime.TimeZone.utcOffsetAt"
      ]
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 28680,
      "deco" : "yFNaZyC3std8datetime3UTC",
      "originalType" : "immutable pure ()",
      "endline" : 28683
     },
     {
      "name" : "_utc",
      "kind" : "variable",
      "protection" : "private",
      "line" : 28686,
      "storageClass" : [
       "static",
       "immutable"
      ],
      "deco" : "yC3std8datetime3UTC",
      "originalType" : "UTC",
      "init" : "UTC(\"UTC\", \"UTC\", \"UTC\")"
     }
    ]
   },
   {
    "name" : "SimpleTimeZone",
    "kind" : "class",
    "comment" : "\n    Represents a time zone with an offset (in minutes, west is negative) from\n    UTC but no DST.\n\n    It's primarily used as the time zone in the result of $(D SysTime)'s\n    $(D fromISOString), $(D fromISOExtString), and $(D fromSimpleString).\n\n    $(D name) and $(D dstName) are always the empty string since this time zone\n    has no DST, and while it may be meant to represent a time zone which is in\n    the TZ Database, obviously it's not likely to be following the exact rules\n    of any of the time zones in the TZ Database, so it makes no sense to set it.\n  \n",
    "line" : 28702,
    "base" : "TimeZone",
    "members" : [
     {
      "name" : "hasDST",
      "kind" : "function",
      "comment" : "\n        Always returns false.\n      \n",
      "line" : 28709,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 28712,
      "overrides" : [
       "std.datetime.TimeZone.hasDST"
      ]
     },
     {
      "name" : "dstInEffect",
      "kind" : "function",
      "comment" : "\n        Always returns false.\n      \n",
      "line" : 28718,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZb",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28721,
      "overrides" : [
       "std.datetime.TimeZone.dstInEffect"
      ]
     },
     {
      "name" : "utcToTZ",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n      \n",
      "line" : 28732,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28735,
      "overrides" : [
       "std.datetime.TimeZone.utcToTZ"
      ]
     },
     {
      "name" : "__unittestL28737_937",
      "kind" : "function",
      "line" : 28737,
      "endline" : 28760
     },
     {
      "name" : "tzToUTC",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
      "line" : 28760,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "adjTime",
        "deco" : "l"
       }
      ],
      "endline" : 28763,
      "overrides" : [
       "std.datetime.TimeZone.tzToUTC"
      ]
     },
     {
      "name" : "__unittestL28765_938",
      "kind" : "function",
      "line" : 28765,
      "endline" : 28787
     },
     {
      "name" : "utcOffsetAt",
      "kind" : "function",
      "comment" : "\n        Returns utcOffset as a $(CXREF time, Duration).\n\n        Params:\n            stdTime = The UTC time for which to get the offset from UTC for this\n                      time zone.\n      \n",
      "line" : 28787,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZS4core4time8Duration",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 28790,
      "overrides" : [
       "std.datetime.TimeZone.utcOffsetAt"
      ]
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            utcOffset = This time zone's offset from UTC in minutes with west of\n                        UTC being negative (it is added to UTC to get the\n                        adjusted time).\n            stdName   = The $(D stdName) for this time zone.\n      \n",
      "line" : 28800,
      "deco" : "yFS4core4time8DurationAyaZyC3std8datetime14SimpleTimeZone",
      "originalType" : "immutable (Duration utcOffset, string stdName = \"\")",
      "parameters" : [
       {
        "name" : "utcOffset",
        "deco" : "S4core4time8Duration"
       },
       {
        "name" : "stdName",
        "deco" : "Aya",
        "default" : "\"\""
       }
      ],
      "endline" : 28808
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Ditto \n",
      "line" : 28811,
      "deco" : "yFiAyaZyC3std8datetime14SimpleTimeZone",
      "originalType" : "immutable (int utcOffset, string stdName = \"\")",
      "parameters" : [
       {
        "name" : "utcOffset",
        "deco" : "i"
       },
       {
        "name" : "stdName",
        "deco" : "Aya",
        "default" : "\"\""
       }
      ],
      "endline" : 28814
     },
     {
      "name" : "__unittestL28816_939",
      "kind" : "function",
      "line" : 28816,
      "endline" : 28834
     },
     {
      "name" : "utcOffset",
      "kind" : "function",
      "comment" : "\n        The number of minutes the offset from UTC is (negative is west of UTC,\n        positive is east).\n      \n",
      "line" : 28834,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdNfZi",
      "originalType" : "const pure nothrow @safe int()",
      "endline" : 28837
     },
     {
      "name" : "toISOString",
      "kind" : "function",
      "protection" : "private",
      "line" : 28851,
      "storageClass" : [
       "static"
      ],
      "deco" : "FS4core4time8DurationZAya",
      "parameters" : [
       {
        "name" : "utcOffset",
        "deco" : "S4core4time8Duration"
       }
      ],
      "endline" : 28861
     },
     {
      "name" : "__unittestL28863_940",
      "kind" : "function",
      "protection" : "private",
      "line" : 28863,
      "endline" : 28904
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 28904,
      "name" : "fromISOString",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fromISOString",
        "kind" : "function",
        "line" : 28904,
        "type" : "immutable(SimpleTimeZone)(S isoString)",
        "parameters" : [
         {
          "name" : "isoString",
          "type" : "S"
         }
        ],
        "endline" : 28937
       }
      ]
     },
     {
      "name" : "__unittestL28939_941",
      "kind" : "function",
      "protection" : "private",
      "line" : 28939,
      "endline" : 29029
     },
     {
      "name" : "__unittestL29029_942",
      "kind" : "function",
      "protection" : "private",
      "line" : 29029,
      "endline" : 29063
     },
     {
      "name" : "_utcOffset",
      "kind" : "variable",
      "protection" : "private",
      "line" : 29063,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yS4core4time8Duration",
      "originalType" : "Duration",
      "offset" : 64
     }
    ]
   },
   {
    "name" : "PosixTimeZone",
    "kind" : "class",
    "comment" : "\n    Represents a time zone from a TZ Database time zone file. Files from the TZ\n    Database are how Posix systems hold their time zone information.\n    Unfortunately, Windows does not use the TZ Database. To use the TZ Database,\n    use $(LREF PosixTimeZone) (which reads its information from the TZ Database\n    files on disk) on Windows by providing the TZ Database files and telling\n    $(D PosixTimeZone.getTimeZone) where the directory holding them is.\n\n    To get a $(D PosixTimeZone), either call $(D PosixTimeZone.getTimeZone)\n    (which allows specifying the location the time zone files) or call\n    $(D TimeZone.getTimeZone) (which will give a $(D PosixTimeZone) on Posix\n    systems and a $(D WindowsTimeZone) on Windows systems).\n\n    Note:\n        Unless your system's local time zone deals with leap seconds (which is\n        highly unlikely), then the only way to get a time zone which\n        takes leap seconds into account is to use $(D PosixTimeZone) with a\n        time zone whose name starts with \"right/\". Those time zone files do\n        include leap seconds, and $(D PosixTimeZone) will take them into account\n        (though posix systems which use a \"right/\" time zone as their local time\n        zone will $(I not) take leap seconds into account even though they're\n        in the file).\n\n    See_Also:\n        $(WEB www.iana.org/time-zones, Home of the TZ Database files)<br>\n        $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ Database)<br>\n        $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of Time\n          Zones)\n  \n",
    "line" : 29096,
    "base" : "TimeZone",
    "members" : [
     {
      "name" : "hasDST",
      "kind" : "function",
      "comment" : "\n        Whether this time zone has Daylight Savings Time at any point in time.\n        Note that for some time zone types it may not have DST for current\n        dates but will still return true for $(D hasDST) because the time zone\n        did at some point have DST.\n      \n",
      "line" : 29106,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNbNdZb",
      "originalType" : "const nothrow bool()",
      "endline" : 29109,
      "overrides" : [
       "std.datetime.TimeZone.hasDST"
      ]
     },
     {
      "name" : "dstInEffect",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and returns whether DST is in effect in this\n        time zone at the given point in time.\n\n        Params:\n            stdTime = The UTC time that needs to be checked for DST in this time\n                      zone.\n      \n",
      "line" : 29121,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZb",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 29139,
      "overrides" : [
       "std.datetime.TimeZone.dstInEffect"
      ]
     },
     {
      "name" : "utcToTZ",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in UTC time (i.e. std time) and converts it to this time zone's time.\n\n        Params:\n            stdTime = The UTC time that needs to be adjusted to this time zone's\n                      time.\n      \n",
      "line" : 29150,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 29169,
      "overrides" : [
       "std.datetime.TimeZone.utcToTZ"
      ]
     },
     {
      "name" : "tzToUTC",
      "kind" : "function",
      "comment" : "\n        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.\n        in this time zone's time and converts it to UTC (i.e. std time).\n\n        Params:\n            adjTime = The time in this time zone that needs to be adjusted to\n                      UTC time.\n      \n",
      "line" : 29180,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFNblZl",
      "parameters" : [
       {
        "name" : "adjTime",
        "deco" : "l"
       }
      ],
      "endline" : 29221,
      "overrides" : [
       "std.datetime.TimeZone.tzToUTC"
      ]
     },
     {
      "name" : "defaultTZDatabaseDir",
      "kind" : "variable",
      "comment" : "\n            The default directory where the TZ Database files are. It's empty\n            for Windows, since Windows doesn't have them.\n          \n",
      "line" : 29230,
      "storageClass" : [
       "enum"
      ],
      "deco" : "Aya",
      "init" : "\"/usr/share/zoneinfo/\""
     },
     {
      "name" : "getTimeZone",
      "kind" : "function",
      "comment" : "\n        Returns a $(D TimeZone) with the give name per the TZ Database. The time\n        zone information is fetched from the TZ Database time zone files in the\n        given directory.\n\n        See_Also:\n            $(WEB en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ\n              Database)<br>\n            $(WEB en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of\n              Time Zones)\n\n        Params:\n            name          = The TZ Database name of the desired time zone\n            tzDatabaseDir = The directory where the TZ Database files are\n                            located. Because these files are not located on\n                            Windows systems, provide them\n                            and give their location here to\n                            use $(D PosixTimeZone)s.\n\n        Throws:\n            $(D DateTimeException) if the given time zone could not be found or\n            $(D FileException) if the TZ Database file could not be opened.\n\n        Examples:\n--------------------\nauto tz = PosixTimeZone.getTimeZone(\"America/Los_Angeles\");\n\nassert(tz.name == \"America/Los_Angeles\");\nassert(tz.stdName == \"PST\");\nassert(tz.dstName == \"PDT\");\n--------------------\n      \n",
      "line" : 29275,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaAyaZyC3std8datetime13PosixTimeZone",
      "originalType" : "immutable(PosixTimeZone)(string name, string tzDatabaseDir = defaultTZDatabaseDir)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "tzDatabaseDir",
        "deco" : "Aya",
        "default" : "\"/usr/share/zoneinfo/\""
       }
      ],
      "endline" : 29573
     },
     {
      "name" : "getInstalledTZNames",
      "kind" : "function",
      "comment" : "\n        Returns a list of the names of the time zones installed on the system.\n\n        Providing a sub-name narrows down the list of time zones (which\n        can number in the thousands). For example,\n        passing in \"America\" as the sub-name returns only the time zones which\n        begin with \"America\".\n\n        Params:\n            subName = The first part of the desired time zones.\n\n        Throws:\n            $(D FileException) if it fails to read from disk.\n      \n",
      "line" : 29589,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaAyaZAAya",
      "originalType" : "string[](string subName = \"\", string tzDatabaseDir = defaultTZDatabaseDir)",
      "parameters" : [
       {
        "name" : "subName",
        "deco" : "Aya",
        "default" : "\"\""
       },
       {
        "name" : "tzDatabaseDir",
        "deco" : "Aya",
        "default" : "\"/usr/share/zoneinfo/\""
       }
      ],
      "endline" : 29624
     },
     {
      "name" : "__unittestL29626_943",
      "kind" : "function",
      "line" : 29626,
      "endline" : 29666
     },
     {
      "name" : "Transition",
      "kind" : "struct",
      "protection" : "private",
      "line" : 29674,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 29675,
        "deco" : "FNclPyS3std8datetime13PosixTimeZone6TTInfoZS3std8datetime13PosixTimeZone10Transition",
        "originalType" : "(long timeT, immutable(TTInfo)* ttInfo)",
        "parameters" : [
         {
          "name" : "timeT",
          "deco" : "l"
         },
         {
          "name" : "ttInfo",
          "deco" : "PyS3std8datetime13PosixTimeZone6TTInfo"
         }
        ],
        "endline" : 29679
       },
       {
        "name" : "timeT",
        "kind" : "variable",
        "line" : 29681,
        "deco" : "l",
        "offset" : 0
       },
       {
        "name" : "ttInfo",
        "kind" : "variable",
        "line" : 29682,
        "deco" : "PyS3std8datetime13PosixTimeZone6TTInfo",
        "offset" : 8
       }
      ]
     },
     {
      "name" : "LeapSecond",
      "kind" : "struct",
      "protection" : "private",
      "line" : 29690,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 29691,
        "deco" : "FNcliZS3std8datetime13PosixTimeZone10LeapSecond",
        "originalType" : "(long timeT, int total)",
        "parameters" : [
         {
          "name" : "timeT",
          "deco" : "l"
         },
         {
          "name" : "total",
          "deco" : "i"
         }
        ],
        "endline" : 29695
       },
       {
        "name" : "timeT",
        "kind" : "variable",
        "line" : 29697,
        "deco" : "l",
        "offset" : 0
       },
       {
        "name" : "total",
        "kind" : "variable",
        "line" : 29698,
        "deco" : "i",
        "offset" : 8
       }
      ]
     },
     {
      "name" : "TTInfo",
      "kind" : "struct",
      "protection" : "private",
      "line" : 29706,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 29707,
        "deco" : "yFNcxS3std8datetime13PosixTimeZone10TempTTInfoAyaZyS3std8datetime13PosixTimeZone6TTInfo",
        "originalType" : "immutable (in TempTTInfo tempTTInfo, string abbrev)",
        "parameters" : [
         {
          "name" : "tempTTInfo",
          "deco" : "xS3std8datetime13PosixTimeZone10TempTTInfo"
         },
         {
          "name" : "abbrev",
          "deco" : "Aya"
         }
        ],
        "endline" : 29712
       },
       {
        "name" : "utcOffset",
        "kind" : "variable",
        "comment" : " Offset from UTC.\n",
        "line" : 29714,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "yi",
        "originalType" : "int",
        "offset" : 0
       },
       {
        "name" : "isDST",
        "kind" : "variable",
        "comment" : " Whether DST is in effect.\n",
        "line" : 29715,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "yb",
        "originalType" : "bool",
        "offset" : 4
       },
       {
        "name" : "abbrev",
        "kind" : "variable",
        "comment" : " The current abbreviation for the time zone.\n",
        "line" : 29716,
        "storageClass" : [
         "immutable"
        ],
        "deco" : "yAa",
        "originalType" : "string",
        "offset" : 8
       },
       {
        "name" : "__xopEquals",
        "kind" : "function",
        "storageClass" : [
         "static"
        ],
        "deco" : "FKxS3std8datetime13PosixTimeZone6TTInfoKxS3std8datetime13PosixTimeZone6TTInfoZb",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "xS3std8datetime13PosixTimeZone6TTInfo",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "q",
          "deco" : "xS3std8datetime13PosixTimeZone6TTInfo",
          "storageClass" : [
           "ref"
          ]
         }
        ]
       }
      ]
     },
     {
      "name" : "TempTTInfo",
      "kind" : "struct",
      "protection" : "private",
      "line" : 29725,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 29726,
        "deco" : "FNcibhZS3std8datetime13PosixTimeZone10TempTTInfo",
        "originalType" : "(int gmtOff, bool isDST, ubyte abbrInd)",
        "parameters" : [
         {
          "name" : "gmtOff",
          "deco" : "i"
         },
         {
          "name" : "isDST",
          "deco" : "b"
         },
         {
          "name" : "abbrInd",
          "deco" : "h"
         }
        ],
        "endline" : 29731
       },
       {
        "name" : "tt_gmtoff",
        "kind" : "variable",
        "line" : 29733,
        "deco" : "i",
        "offset" : 0
       },
       {
        "name" : "tt_isdst",
        "kind" : "variable",
        "line" : 29734,
        "deco" : "b",
        "offset" : 4
       },
       {
        "name" : "tt_abbrind",
        "kind" : "variable",
        "line" : 29735,
        "deco" : "h",
        "offset" : 5
       }
      ]
     },
     {
      "name" : "TempTransition",
      "kind" : "struct",
      "protection" : "private",
      "line" : 29745,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 29746,
        "deco" : "FNclPyS3std8datetime13PosixTimeZone6TTInfoPS3std8datetime13PosixTimeZone14TransitionTypeZS3std8datetime13PosixTimeZone14TempTransition",
        "originalType" : "(long timeT, immutable(TTInfo)* ttInfo, TransitionType* ttype)",
        "parameters" : [
         {
          "name" : "timeT",
          "deco" : "l"
         },
         {
          "name" : "ttInfo",
          "deco" : "PyS3std8datetime13PosixTimeZone6TTInfo"
         },
         {
          "name" : "ttype",
          "deco" : "PS3std8datetime13PosixTimeZone14TransitionType"
         }
        ],
        "endline" : 29751
       },
       {
        "name" : "timeT",
        "kind" : "variable",
        "line" : 29753,
        "deco" : "l",
        "offset" : 0
       },
       {
        "name" : "ttInfo",
        "kind" : "variable",
        "line" : 29754,
        "deco" : "PyS3std8datetime13PosixTimeZone6TTInfo",
        "offset" : 8
       },
       {
        "name" : "ttype",
        "kind" : "variable",
        "line" : 29755,
        "deco" : "PS3std8datetime13PosixTimeZone14TransitionType",
        "offset" : 16
       }
      ]
     },
     {
      "name" : "TransitionType",
      "kind" : "struct",
      "protection" : "private",
      "line" : 29765,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 29766,
        "deco" : "FNcbbZS3std8datetime13PosixTimeZone14TransitionType",
        "originalType" : "(bool isStd, bool inUTC)",
        "parameters" : [
         {
          "name" : "isStd",
          "deco" : "b"
         },
         {
          "name" : "inUTC",
          "deco" : "b"
         }
        ],
        "endline" : 29770
       },
       {
        "name" : "isStd",
        "kind" : "variable",
        "comment" : " Whether the transition is in std time (as opposed to wall clock time).\n",
        "line" : 29773,
        "deco" : "b",
        "offset" : 0
       },
       {
        "name" : "inUTC",
        "kind" : "variable",
        "comment" : " Whether the transition is in UTC (as opposed to local time).\n",
        "line" : 29776,
        "deco" : "b",
        "offset" : 1
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 29783,
      "name" : "readVal",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "readVal",
        "kind" : "function",
        "line" : 29783,
        "type" : "T(ref File tzFile)",
        "parameters" : [
         {
          "name" : "tzFile",
          "type" : "File",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 29793
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 29798,
      "name" : "readVal",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "readVal",
        "kind" : "function",
        "line" : 29798,
        "type" : "T(ref File tzFile, size_t length)",
        "parameters" : [
         {
          "name" : "tzFile",
          "type" : "File",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "length",
          "type" : "size_t"
         }
        ],
        "endline" : 29807
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 29813,
      "name" : "readVal",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "readVal",
        "kind" : "function",
        "line" : 29813,
        "type" : "T(ref File tzFile)",
        "parameters" : [
         {
          "name" : "tzFile",
          "type" : "File",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 29819
       }
      ]
     },
     {
      "name" : "_enforceValidTZFile",
      "kind" : "function",
      "protection" : "private",
      "line" : 29826,
      "storageClass" : [
       "static"
      ],
      "deco" : "FbmZv",
      "originalType" : "void(bool result, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "b"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 29830
     },
     {
      "name" : "calculateLeapSeconds",
      "kind" : "function",
      "protection" : "private",
      "line" : 29833,
      "deco" : "xFNblZi",
      "parameters" : [
       {
        "name" : "stdTime",
        "deco" : "l"
       }
      ],
      "endline" : 29856
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 29859,
      "deco" : "yFyAS3std8datetime13PosixTimeZone10TransitionyAS3std8datetime13PosixTimeZone10LeapSecondAyaAyaAyabZyC3std8datetime13PosixTimeZone",
      "originalType" : "immutable (immutable Transition[] transitions, immutable LeapSecond[] leapSeconds, string name, string stdName, string dstName, bool hasDST)",
      "parameters" : [
       {
        "name" : "transitions",
        "deco" : "yAS3std8datetime13PosixTimeZone10Transition"
       },
       {
        "name" : "leapSeconds",
        "deco" : "yAS3std8datetime13PosixTimeZone10LeapSecond"
       },
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "stdName",
        "deco" : "Aya"
       },
       {
        "name" : "dstName",
        "deco" : "Aya"
       },
       {
        "name" : "hasDST",
        "deco" : "b"
       }
      ],
      "endline" : 29885
     },
     {
      "name" : "_transitions",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " List of times when the utc offset changes.\n",
      "line" : 29888,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAS3std8datetime13PosixTimeZone10Transition",
      "originalType" : "Transition[]",
      "offset" : 64
     },
     {
      "name" : "_leapSeconds",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " List of leap second occurrences.\n",
      "line" : 29891,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAS3std8datetime13PosixTimeZone10LeapSecond",
      "originalType" : "LeapSecond[]",
      "offset" : 80
     },
     {
      "name" : "_hasDST",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " Whether DST is in effect for this time zone at any point in time.\n",
      "line" : 29894,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yb",
      "originalType" : "bool",
      "offset" : 96
     }
    ]
   },
   {
    "name" : "setTZEnvVar",
    "kind" : "function",
    "line" : 30386,
    "deco" : "FNbAyaZv",
    "parameters" : [
     {
      "name" : "tzDatabaseName",
      "deco" : "Aya"
     }
    ],
    "endline" : 30397
   },
   {
    "name" : "clearTZEnvVar",
    "kind" : "function",
    "line" : 30400,
    "deco" : "FNbZv",
    "endline" : 30409
   },
   {
    "name" : "tzDatabaseNameToWindowsTZName",
    "kind" : "function",
    "comment" : "\n    Converts the given TZ Database name to the corresponding Windows time zone\n    name.\n\n    Note that in a few cases, a TZ Dabatase name corresponds to two different\n    Windows time zone names. So, while in most cases converting from one to the\n    other and back again will result in the same time zone name started\n    with, in a few case, it'll get a different name.\n\n    Also, there are far more TZ Database names than Windows time zones, so some\n    of the more exotic TZ Database names don't have corresponding Windows time\n    zone names.\n\n    See_Also:\n        $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n\n    Throws:\n        $(D DateTimeException) if the given $(D_PARAM tzName) cannot be\n        converted.\n  \n",
    "line" : 30437,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "tzName",
      "deco" : "Aya"
     }
    ],
    "endline" : 30547
   },
   {
    "name" : "__unittestL30549_946",
    "kind" : "function",
    "line" : 30549,
    "endline" : 30586
   },
   {
    "name" : "windowsTZNameToTZDatabaseName",
    "kind" : "function",
    "comment" : "\n    Converts the given Windows time zone name to a corresponding TZ Database\n    name.\n\n    See_Also:\n        $(WEB unicode.org/repos/cldr-tmp/trunk/diff/supplemental/zone_tzid.html,\n              Windows <-> TZ Database Name Conversion Table)\n\n    Params:\n        tzName = The TZ Database name to convert.\n\n    Throws:\n        $(D DateTimeException) if the given $(D_PARAM tzName) cannot be\n        converted.\n  \n",
    "line" : 30586,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "tzName",
      "deco" : "Aya"
     }
    ],
    "endline" : 30699
   },
   {
    "name" : "__unittestL30701_947",
    "kind" : "function",
    "line" : 30701,
    "endline" : 30770
   },
   {
    "name" : "StopWatch",
    "kind" : "struct",
    "comment" : "\n   $(D StopWatch) measures time as precisely as possible.\n\n   This class uses a high-performance counter. On Windows systems, it uses\n   $(D QueryPerformanceCounter), and on Posix systems, it uses\n   $(D clock_gettime) if available, and $(D gettimeofday) otherwise.\n\n   But the precision of $(D StopWatch) differs from system to system. It is\n   impossible to for it to be the same from system to system since the precision\n   of the system clock varies from system to system, and other system-dependent\n   and situation-dependent stuff (such as the overhead of a context switch\n   between threads) can also affect $(D StopWatch)'s accuracy.\n\n   Examples:\n--------------------\nvoid foo()\n{\n    StopWatch sw;\n    enum n = 100;\n    TickDuration[n] times;\n    TickDuration last = TickDuration.from!\"seconds\"(0);\n    foreach(i; 0..n)\n    {\n       sw.start(); //start/resume mesuring.\n       foreach(unused; 0..1_000_000)\n           bar();\n       sw.stop();  //stop/pause measuring.\n       //Return value of peek() after having stopped are the always same.\n       writeln((i + 1) * 1_000_000, \" times done, lap time: \",\n               sw.peek().msecs, \"[ms]\");\n       times[i] = sw.peek() - last;\n       last = sw.peek();\n    }\n    real sum = 0;\n    // To know the number of seconds,\n    // use properties of TickDuration.\n    // (seconds, msecs, usecs, hnsecs)\n    foreach(t; times)\n       sum += t.hnsecs;\n    writeln(\"Average time: \", sum/n, \" hnsecs\");\n}\n--------------------\n  \n",
    "line" : 30771,
    "members" : [
     {
      "name" : "__unittestL30774_948",
      "kind" : "function",
      "line" : 30774,
      "endline" : 30807
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n       Auto start with constructor.\n      \n",
      "line" : 30807,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNcNfE3std8datetime9AutoStartZS3std8datetime9StopWatch",
      "originalType" : "(AutoStart autostart)",
      "parameters" : [
       {
        "name" : "autostart",
        "deco" : "E3std8datetime9AutoStart"
       }
      ],
      "endline" : 30811
     },
     {
      "name" : "__unittestL30813_949",
      "kind" : "function",
      "line" : 30813,
      "endline" : 30821
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n",
      "line" : 30821,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "xFNaNbNfxS3std8datetime9StopWatchZb",
      "originalType" : "const pure nothrow bool(const StopWatch rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime9StopWatch"
       }
      ],
      "endline" : 30824
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 30827,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "xFNaNbNfKxS3std8datetime9StopWatchZb",
      "originalType" : "const pure nothrow bool(ref const StopWatch rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "xS3std8datetime9StopWatch",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 30831
     },
     {
      "name" : "reset",
      "kind" : "function",
      "comment" : "\n       Resets the stop watch.\n      \n",
      "line" : 30837,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfZv",
      "originalType" : "void()",
      "endline" : 30851
     },
     {
      "name" : "__unittestL30853_950",
      "kind" : "function",
      "line" : 30853,
      "endline" : 30866
     },
     {
      "name" : "start",
      "kind" : "function",
      "comment" : "\n       Starts the stop watch.\n      \n",
      "line" : 30866,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfZv",
      "originalType" : "void()",
      "endline" : 30871
     },
     {
      "name" : "__unittestL30873_951",
      "kind" : "function",
      "line" : 30873,
      "endline" : 30892
     },
     {
      "name" : "stop",
      "kind" : "function",
      "comment" : "\n       Stops the stop watch.\n      \n",
      "line" : 30892,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfZv",
      "originalType" : "void()",
      "endline" : 30897
     },
     {
      "name" : "__unittestL30899_952",
      "kind" : "function",
      "line" : 30899,
      "endline" : 30919
     },
     {
      "name" : "peek",
      "kind" : "function",
      "comment" : "\n       Peek at the amount of time which has passed since the stop watch was\n       started.\n      \n",
      "line" : 30919,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "xFNfZS4core4time12TickDuration",
      "originalType" : "const TickDuration()",
      "endline" : 30925
     },
     {
      "name" : "__unittestL30927_953",
      "kind" : "function",
      "line" : 30927,
      "endline" : 30944
     },
     {
      "name" : "setMeasured",
      "kind" : "function",
      "comment" : "\n       Set the amount of time which has been measured since the stop watch was\n       started.\n      \n",
      "line" : 30944,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfS4core4time12TickDurationZv",
      "originalType" : "void(TickDuration d)",
      "parameters" : [
       {
        "name" : "d",
        "deco" : "S4core4time12TickDuration"
       }
      ],
      "endline" : 30948
     },
     {
      "name" : "__unittestL30950_954",
      "kind" : "function",
      "line" : 30950,
      "endline" : 30964
     },
     {
      "name" : "running",
      "kind" : "function",
      "comment" : "\n       Confirm whether this stopwatch is measuring time.\n      \n",
      "line" : 30964,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow @property bool()",
      "endline" : 30967
     },
     {
      "name" : "__unittestL30969_955",
      "kind" : "function",
      "line" : 30969,
      "endline" : 30988
     },
     {
      "name" : "_flagStarted",
      "kind" : "variable",
      "protection" : "private",
      "line" : 30991,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "b",
      "init" : "false",
      "offset" : 0
     },
     {
      "name" : "_timeStart",
      "kind" : "variable",
      "protection" : "private",
      "line" : 30994,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "S4core4time12TickDuration",
      "offset" : 8
     },
     {
      "name" : "_timeMeasured",
      "kind" : "variable",
      "protection" : "private",
      "line" : 30997,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "S4core4time12TickDuration",
      "offset" : 16
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std8datetime9StopWatchKxS3std8datetime9StopWatchZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std8datetime9StopWatch",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std8datetime9StopWatch",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 31002,
    "name" : "lengthof",
    "parameters" : [
     {
      "name" : "aliases",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "lengthof",
      "kind" : "function",
      "line" : 31002,
      "type" : "pure nothrow size_t()",
      "endline" : 31005
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Benchmarks code for speed assessment and comparison.\n\n    Params:\n        fun = aliases of callable objects (e.g. function names). Each should\n              take no arguments.\n        n   = The number of times each function is to be executed.\n\n    Returns:\n        The amount of time (as a $(CXREF time, TickDuration)) that it took to\n        call each function $(D n) times. The first value is the length of time\n        that it took to call $(D fun[0]) $(D n) times. The second value is the\n        length of time it took to call $(D fun[1]) $(D n) times. Etc.\n\n   Examples:\n--------------------\nint a;\nvoid f0() {}\nvoid f1() {auto b = a;}\nvoid f2() {auto b = to!(string)(a);}\nauto r = benchmark!(f0, f1, f2)(10_000);\nwritefln(\"Milliseconds to call fun[0] n times: %s\", r[0].msecs);\n--------------------\n  \n",
    "line" : 31032,
    "name" : "benchmark",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "benchmark",
      "kind" : "function",
      "comment" : "\n    Benchmarks code for speed assessment and comparison.\n\n    Params:\n        fun = aliases of callable objects (e.g. function names). Each should\n              take no arguments.\n        n   = The number of times each function is to be executed.\n\n    Returns:\n        The amount of time (as a $(CXREF time, TickDuration)) that it took to\n        call each function $(D n) times. The first value is the length of time\n        that it took to call $(D fun[0]) $(D n) times. The second value is the\n        length of time it took to call $(D fun[1]) $(D n) times. Etc.\n\n   Examples:\n--------------------\nint a;\nvoid f0() {}\nvoid f1() {auto b = a;}\nvoid f2() {auto b = to!(string)(a);}\nauto r = benchmark!(f0, f1, f2)(10_000);\nwritefln(\"Milliseconds to call fun[0] n times: %s\", r[0].msecs);\n--------------------\n  \n",
      "line" : 31032,
      "type" : "TickDuration[lengthof!(fun)()](uint n)",
      "parameters" : [
       {
        "name" : "n",
        "deco" : "k"
       }
      ],
      "endline" : 31047
     }
    ]
   },
   {
    "name" : "__unittestL31050_956",
    "kind" : "function",
    "line" : 31050,
    "endline" : 31062
   },
   {
    "name" : "__unittestL31062_957",
    "kind" : "function",
    "line" : 31062,
    "endline" : 31075
   },
   {
    "name" : "ComparingBenchmarkResult",
    "kind" : "struct",
    "comment" : "\n   Return value of benchmark with two functions comparing.\n  \n",
    "line" : 31076,
    "members" : [
     {
      "name" : "point",
      "kind" : "function",
      "comment" : "\n       Evaluation value\n\n       This returns the evaluation value of performance as the ratio of\n       baseFunc's time over targetFunc's time. If performance is high, this\n       returns a high value.\n      \n",
      "line" : 31084,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZe",
      "originalType" : "const pure nothrow real()",
      "endline" : 31087
     },
     {
      "name" : "baseTime",
      "kind" : "function",
      "comment" : "\n       The time required of the base function\n      \n",
      "line" : 31093,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZS4core4time12TickDuration",
      "originalType" : "const pure nothrow TickDuration()",
      "endline" : 31096
     },
     {
      "name" : "targetTime",
      "kind" : "function",
      "comment" : "\n       The time required of the target function\n      \n",
      "line" : 31102,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZS4core4time12TickDuration",
      "originalType" : "const pure nothrow TickDuration()",
      "endline" : 31105
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 31109,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNaNbNcNfS4core4time12TickDurationS4core4time12TickDurationZS3std8datetime24ComparingBenchmarkResult",
      "originalType" : "pure nothrow (TickDuration baseTime, TickDuration targetTime)",
      "parameters" : [
       {
        "name" : "baseTime",
        "deco" : "S4core4time12TickDuration"
       },
       {
        "name" : "targetTime",
        "deco" : "S4core4time12TickDuration"
       }
      ],
      "endline" : 31113
     },
     {
      "name" : "_baseTime",
      "kind" : "variable",
      "protection" : "private",
      "line" : 31115,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "S4core4time12TickDuration",
      "offset" : 0
     },
     {
      "name" : "_targetTime",
      "kind" : "variable",
      "protection" : "private",
      "line" : 31116,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "S4core4time12TickDuration",
      "offset" : 8
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Benchmark with two functions comparing.\n\n   Params:\n       baseFunc   = The function to become the base of the speed.\n       targetFunc = The function that wants to measure speed.\n       times      = The number of times each function is to be executed.\n\n   Examples:\n--------------------\nvoid f1() {\n   // ...\n}\nvoid f2() {\n   // ...\n}\n\nvoid main() {\n   auto b = comparingBenchmark!(f1, f2, 0x80);\n   writeln(b.point);\n}\n--------------------\n  \n",
    "line" : 31143,
    "name" : "comparingBenchmark",
    "parameters" : [
     {
      "name" : "baseFunc",
      "kind" : "alias"
     },
     {
      "name" : "targetFunc",
      "kind" : "alias"
     },
     {
      "name" : "times",
      "kind" : "value",
      "deco" : "i",
      "defaultValue" : "4095"
     }
    ],
    "members" : [
     {
      "name" : "comparingBenchmark",
      "kind" : "function",
      "comment" : "\n   Benchmark with two functions comparing.\n\n   Params:\n       baseFunc   = The function to become the base of the speed.\n       targetFunc = The function that wants to measure speed.\n       times      = The number of times each function is to be executed.\n\n   Examples:\n--------------------\nvoid f1() {\n   // ...\n}\nvoid f2() {\n   // ...\n}\n\nvoid main() {\n   auto b = comparingBenchmark!(f1, f2, 0x80);\n   writeln(b.point);\n}\n--------------------\n  \n",
      "line" : 31143,
      "type" : "ComparingBenchmarkResult()",
      "endline" : 31149
     }
    ]
   },
   {
    "name" : "__unittestL31151_958",
    "kind" : "function",
    "line" : 31151,
    "endline" : 31161
   },
   {
    "name" : "__unittestL31161_959",
    "kind" : "function",
    "line" : 31161,
    "endline" : 31172
   },
   {
    "name" : "__unittestL31172_972",
    "kind" : "function",
    "line" : 31172,
    "endline" : 31195
   },
   {
    "kind" : "template",
    "comment" : "\n    Whether the given type defines all of the necessary functions for it to\n    function as a time point.\n  \n",
    "line" : 31195,
    "name" : "isTimePoint",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isTimePoint",
      "kind" : "variable",
      "line" : 31201,
      "storageClass" : [
       "enum"
      ],
      "init" : "hasMin!(T) && hasMax!(T) && hasOverloadedOpBinaryWithDuration!(T) && hasOverloadedOpAssignWithDuration!(T) && hasOverloadedOpBinaryWithSelf!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL31204_973",
    "kind" : "function",
    "line" : 31204,
    "endline" : 31229
   },
   {
    "name" : "yearIsLeapYear",
    "kind" : "function",
    "comment" : "\n    Whether the given Gregorian Year is a leap year.\n\n    Params:\n        year = The year to to be tested.\n \n",
    "line" : 31229,
    "storageClass" : [
     "static"
    ],
    "deco" : "FNaNbiZb",
    "parameters" : [
     {
      "name" : "year",
      "deco" : "i"
     }
    ],
    "endline" : 31238
   },
   {
    "name" : "__unittestL31240_974",
    "kind" : "function",
    "line" : 31240,
    "endline" : 31264
   },
   {
    "name" : "unixTimeToStdTime",
    "kind" : "function",
    "comment" : "\n    Converts a $(D time_t) (which uses midnight, January 1st, 1970 UTC as its\n    epoch and seconds as its units) to std time (which uses midnight,\n    January 1st, 1 A.D. UTC and hnsecs as its units).\n\n    Params:\n        unixTime = The $(D time_t) to convert.\n  \n",
    "line" : 31264,
    "deco" : "FNaNblZl",
    "originalType" : "pure nothrow long(time_t unixTime)",
    "parameters" : [
     {
      "name" : "unixTime",
      "deco" : "l"
     }
    ],
    "endline" : 31268
   },
   {
    "name" : "__unittestL31270_975",
    "kind" : "function",
    "line" : 31270,
    "endline" : 31304
   },
   {
    "name" : "stdTimeToUnixTime",
    "kind" : "function",
    "comment" : "\n    Converts std time (which uses midnight, January 1st, 1 A.D. UTC as its epoch\n    and hnsecs as its units) to $(D time_t) (which uses midnight, January 1st,\n    1970 UTC as its epoch and seconds as its units). If $(D time_t) is 32 bits,\n    rather than 64, and the result can't fit in a 32-bit value, then the closest\n    value that can be held in 32 bits will be used (so $(D time_t.max) if it\n    goes over and $(D time_t.min) if it goes under).\n\n    Note:\n        While Windows systems require that $(D time_t) be non-negative (in spite\n        of $(D time_t) being signed), this function still returns negative\n        numbers on Windows, since it's more flexible to allow negative time_t\n        for those who need it. If on Windows and using the\n        standard C functions or Win32 API functions which take a $(D time_t),\n        check whether the return value of\n        $(D stdTimeToUnixTime) is non-negative.\n\n    Params:\n        stdTime = The std time to convert.\n  \n",
    "line" : 31304,
    "deco" : "FNaNblZl",
    "originalType" : "pure nothrow time_t(long stdTime)",
    "parameters" : [
     {
      "name" : "stdTime",
      "deco" : "l"
     }
    ],
    "endline" : 31324
   },
   {
    "name" : "__unittestL31326_976",
    "kind" : "function",
    "line" : 31326,
    "endline" : 31340
   },
   {
    "name" : "DosFileTime",
    "kind" : "alias",
    "comment" : "\n    Type representing the DOS file date/time format.\n  \n",
    "line" : 31647,
    "deco" : "k"
   },
   {
    "name" : "DosFileTimeToSysTime",
    "kind" : "function",
    "comment" : "\n    Converts from DOS file date/time to $(D SysTime).\n\n    Params:\n        dft = The DOS file time to convert.\n        tz  = The time zone which the DOS file time is assumed to be in.\n\n    Throws:\n        $(D DateTimeException) if the $(D DosFileTime) is invalid.\n  \n",
    "line" : 31659,
    "deco" : "FkyC3std8datetime8TimeZoneZS3std8datetime7SysTime",
    "originalType" : "SysTime(DosFileTime dft, immutable TimeZone tz = LocalTime())",
    "parameters" : [
     {
      "name" : "dft",
      "deco" : "k"
     },
     {
      "name" : "tz",
      "deco" : "yC3std8datetime8TimeZone",
      "default" : "cast(immutable(TimeZone))opCall()"
     }
    ],
    "endline" : 31679
   },
   {
    "name" : "__unittestL31681_981",
    "kind" : "function",
    "line" : 31681,
    "endline" : 31707
   },
   {
    "name" : "SysTimeToDosFileTime",
    "kind" : "function",
    "comment" : "\n    Converts from $(D SysTime) to DOS file date/time.\n\n    Params:\n        sysTime = The $(D SysTime) to convert.\n\n    Throws:\n        $(D DateTimeException) if the given $(D SysTime) cannot be converted to\n        a $(D DosFileTime).\n  \n",
    "line" : 31707,
    "deco" : "FS3std8datetime7SysTimeZk",
    "originalType" : "DosFileTime(SysTime sysTime)",
    "parameters" : [
     {
      "name" : "sysTime",
      "deco" : "S3std8datetime7SysTime"
     }
    ],
    "endline" : 31726
   },
   {
    "name" : "__unittestL31728_982",
    "kind" : "function",
    "line" : 31728,
    "endline" : 31752
   },
   {
    "name" : "validTimeUnits",
    "kind" : "function",
    "comment" : "\n    Whether all of the given strings are valid units of time.\n\n    $(D \"nsecs\") is not considered a valid unit of time. Nothing in std.datetime\n    can handle precision greater than hnsecs, and the few functions in core.time\n    which deal with \"nsecs\" deal with it explicitly.\n  \n",
    "line" : 31752,
    "deco" : "FAAyaXb",
    "parameters" : [
     {
      "name" : "units",
      "deco" : "AAya"
     }
    ],
    "endline" : 31761
   },
   {
    "name" : "cmpTimeUnits",
    "kind" : "function",
    "comment" : "\n    Compares two time unit strings. $(D \"years\") are the largest units and\n    $(D \"hnsecs\") are the smallest.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n\n    Throws:\n        $(D DateTimeException) if either of the given strings is not a valid\n        time unit string.\n \n",
    "line" : 31779,
    "deco" : "FAyaAyaZi",
    "parameters" : [
     {
      "name" : "lhs",
      "deco" : "Aya"
     },
     {
      "name" : "rhs",
      "deco" : "Aya"
     }
    ],
    "endline" : 31794
   },
   {
    "name" : "__unittestL31796_983",
    "kind" : "function",
    "line" : 31796,
    "endline" : 31834
   },
   {
    "kind" : "template",
    "comment" : "\n    Compares two time unit strings at compile time. $(D \"years\") are the largest\n    units and $(D \"hnsecs\") are the smallest.\n\n    This template is used instead of $(D cmpTimeUnits) because exceptions\n    can't be thrown at compile time and $(D cmpTimeUnits) must enforce that\n    the strings it's given are valid time unit strings. This template uses a\n    template constraint instead.\n\n    Returns:\n        $(BOOKTABLE,\n        $(TR $(TD this &lt; rhs) $(TD &lt; 0))\n        $(TR $(TD this == rhs) $(TD 0))\n        $(TR $(TD this &gt; rhs) $(TD &gt; 0))\n        )\n \n",
    "line" : 31834,
    "name" : "CmpTimeUnits",
    "parameters" : [
     {
      "name" : "lhs",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "rhs",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "CmpTimeUnits",
      "kind" : "variable",
      "line" : 31837,
      "storageClass" : [
       "enum"
      ],
      "init" : "cmpTimeUnitsCTFE(lhs, rhs)"
     }
    ]
   },
   {
    "name" : "cmpTimeUnitsCTFE",
    "kind" : "function",
    "protection" : "private",
    "line" : 31844,
    "deco" : "FAyaAyaZi",
    "parameters" : [
     {
      "name" : "lhs",
      "deco" : "Aya"
     },
     {
      "name" : "rhs",
      "deco" : "Aya"
     }
    ],
    "endline" : 31856
   },
   {
    "name" : "__unittestL31858_984",
    "kind" : "function",
    "line" : 31858,
    "endline" : 31909
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns whether the given value is valid for the given unit type when in a\n    time point. Naturally, a duration is not held to a particular range, but\n    the values in a time point are (e.g. a month must be in the range of\n    1 - 12 inclusive).\n\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n\n    Examples:\n--------------------\nassert(valid!\"hours\"(12));\nassert(!valid!\"hours\"(32));\nassert(valid!\"months\"(12));\nassert(!valid!\"months\"(13));\n--------------------\n  \n",
    "line" : 31909,
    "name" : "valid",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "valid",
      "kind" : "function",
      "comment" : "\n    Returns whether the given value is valid for the given unit type when in a\n    time point. Naturally, a duration is not held to a particular range, but\n    the values in a time point are (e.g. a month must be in the range of\n    1 - 12 inclusive).\n\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n\n    Examples:\n--------------------\nassert(valid!\"hours\"(12));\nassert(!valid!\"hours\"(32));\nassert(valid!\"months\"(12));\nassert(!valid!\"months\"(13));\n--------------------\n  \n",
      "line" : 31909,
      "type" : "pure nothrow bool(int value)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "i"
       }
      ],
      "endline" : 31923
     }
    ]
   },
   {
    "name" : "__unittestL31925_985",
    "kind" : "function",
    "line" : 31925,
    "endline" : 31947
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns whether the given day is valid for the given year and month.\n\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n  \n",
    "line" : 31947,
    "name" : "valid",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "valid",
      "kind" : "function",
      "comment" : "\n    Returns whether the given day is valid for the given year and month.\n\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n  \n",
      "line" : 31947,
      "type" : "pure nothrow bool(int year, int month, int day)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       },
       {
        "name" : "month",
        "deco" : "i"
       },
       {
        "name" : "day",
        "deco" : "i"
       }
      ],
      "endline" : 31951
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!units(value)) is false.\n  \n",
    "line" : 31965,
    "name" : "enforceValid",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "enforceValid",
      "kind" : "function",
      "comment" : "\n    Params:\n        units = The units of time to validate.\n        value = The number to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!units(value)) is false.\n  \n",
      "line" : 31965,
      "type" : "pure void(int value, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "i"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 31991
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!\"days\"(year, month, day)) is false.\n  \n",
    "line" : 32007,
    "name" : "enforceValid",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "enforceValid",
      "kind" : "function",
      "comment" : "\n    Params:\n        units = The units of time to validate.\n        year  = The year of the day to validate.\n        month = The month of the day to validate.\n        day   = The day to validate.\n        file  = The file that the $(D DateTimeException) will list if thrown.\n        line  = The line number that the $(D DateTimeException) will list if\n                thrown.\n\n    Throws:\n        $(D DateTimeException) if $(D valid!\"days\"(year, month, day)) is false.\n  \n",
      "line" : 32007,
      "type" : "pure void(int year, Month month, int day, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "year",
        "deco" : "i"
       },
       {
        "name" : "month",
        "type" : "Month"
       },
       {
        "name" : "day",
        "deco" : "i"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 32018
     }
    ]
   },
   {
    "name" : "monthsToMonth",
    "kind" : "function",
    "comment" : "\n    Returns the number of months from the current months of the year to the\n    given month of the year. If they are the same, then the result is 0.\n\n    Params:\n        currMonth = The current month of the year.\n        month     = The month of the year to get the number of months to.\n  \n",
    "line" : 32029,
    "storageClass" : [
     "static"
    ],
    "deco" : "FNaiiZi",
    "parameters" : [
     {
      "name" : "currMonth",
      "deco" : "i"
     },
     {
      "name" : "month",
      "deco" : "i"
     }
    ],
    "endline" : 32041
   },
   {
    "name" : "__unittestL32043_986",
    "kind" : "function",
    "line" : 32043,
    "endline" : 32110
   },
   {
    "name" : "daysToDayOfWeek",
    "kind" : "function",
    "comment" : "\n    Returns the number of days from the current day of the week to the given\n    day of the week. If they are the same, then the result is 0.\n\n    Params:\n        currDoW = The current day of the week.\n        dow     = The day of the week to get the number of days to.\n  \n",
    "line" : 32110,
    "storageClass" : [
     "static"
    ],
    "deco" : "FNaNbE3std8datetime9DayOfWeekE3std8datetime9DayOfWeekZi",
    "parameters" : [
     {
      "name" : "currDoW",
      "deco" : "E3std8datetime9DayOfWeek"
     },
     {
      "name" : "dow",
      "deco" : "E3std8datetime9DayOfWeek"
     }
    ],
    "endline" : 32119
   },
   {
    "name" : "__unittestL32121_987",
    "kind" : "function",
    "line" : 32121,
    "endline" : 32184
   },
   {
    "kind" : "template",
    "line" : 32208,
    "name" : "measureTime",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "measureTime",
      "kind" : "function",
      "line" : 32208,
      "storageClass" : [
       "auto"
      ],
      "type" : "@safe ()",
      "endline" : 32224
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 32226,
    "name" : "measureTime",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "measureTime",
      "kind" : "function",
      "line" : 32226,
      "storageClass" : [
       "auto"
      ],
      "type" : "()",
      "endline" : 32242
     }
    ]
   },
   {
    "name" : "__unittestL32245_990",
    "kind" : "function",
    "line" : 32245,
    "endline" : 32263
   },
   {
    "name" : "__unittestL32263_991",
    "kind" : "function",
    "line" : 32263,
    "endline" : 32282
   },
   {
    "name" : "__unittestL32282_998",
    "kind" : "function",
    "line" : 32282,
    "endline" : 32295
   },
   {
    "name" : "daysInYear",
    "kind" : "variable",
    "protection" : "private",
    "comment" : " The number of days in a non-leap year.\n",
    "line" : 32301,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "365"
   },
   {
    "name" : "daysInLeapYear",
    "kind" : "variable",
    "protection" : "private",
    "comment" : " The numbef or days in a leap year.\n",
    "line" : 32302,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "366"
   },
   {
    "name" : "daysIn4Years",
    "kind" : "variable",
    "protection" : "private",
    "comment" : " Number of days in 4 years.\n",
    "line" : 32303,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "1461"
   },
   {
    "name" : "daysIn100Years",
    "kind" : "variable",
    "protection" : "private",
    "comment" : " The number of days in 100 years.\n",
    "line" : 32304,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "36524"
   },
   {
    "name" : "daysIn400Years",
    "kind" : "variable",
    "protection" : "private",
    "comment" : " The number of days in 400 years.\n",
    "line" : 32305,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "146097"
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32315,
    "name" : "hnsecsPer",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32362,
    "name" : "splitUnitsFromHNSecs",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "splitUnitsFromHNSecs",
      "kind" : "function",
      "line" : 32362,
      "type" : "pure nothrow long(ref long hnsecs)",
      "parameters" : [
       {
        "name" : "hnsecs",
        "deco" : "l",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 32370
     }
    ]
   },
   {
    "name" : "__unittestL32372_999",
    "kind" : "function",
    "protection" : "private",
    "line" : 32372,
    "endline" : 32411
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32411,
    "name" : "getUnitsFromHNSecs",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "getUnitsFromHNSecs",
      "kind" : "function",
      "line" : 32411,
      "type" : "pure nothrow long(long hnsecs)",
      "parameters" : [
       {
        "name" : "hnsecs",
        "deco" : "l"
       }
      ],
      "endline" : 32416
     }
    ]
   },
   {
    "name" : "__unittestL32418_1000",
    "kind" : "function",
    "protection" : "private",
    "line" : 32418,
    "endline" : 32453
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32453,
    "name" : "removeUnitsFromHNSecs",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "removeUnitsFromHNSecs",
      "kind" : "function",
      "line" : 32453,
      "type" : "pure nothrow long(long hnsecs)",
      "parameters" : [
       {
        "name" : "hnsecs",
        "deco" : "l"
       }
      ],
      "endline" : 32460
     }
    ]
   },
   {
    "name" : "__unittestL32462_1001",
    "kind" : "function",
    "protection" : "private",
    "line" : 32462,
    "endline" : 32482
   },
   {
    "name" : "maxDay",
    "kind" : "function",
    "protection" : "private",
    "line" : 32482,
    "storageClass" : [
     "static"
    ],
    "deco" : "FNaNbiiZh",
    "parameters" : [
     {
      "name" : "year",
      "deco" : "i"
     },
     {
      "name" : "month",
      "deco" : "i"
     }
    ],
    "endline" : 32500
   },
   {
    "name" : "__unittestL32502_1002",
    "kind" : "function",
    "protection" : "private",
    "line" : 32502,
    "endline" : 32570
   },
   {
    "name" : "getDayOfWeek",
    "kind" : "function",
    "protection" : "private",
    "line" : 32570,
    "deco" : "FNaNbiZE3std8datetime9DayOfWeek",
    "parameters" : [
     {
      "name" : "day",
      "deco" : "i"
     }
    ],
    "endline" : 32584
   },
   {
    "name" : "__unittestL32586_1003",
    "kind" : "function",
    "protection" : "private",
    "line" : 32586,
    "endline" : 32639
   },
   {
    "name" : "monthToString",
    "kind" : "function",
    "protection" : "private",
    "line" : 32639,
    "deco" : "FNaE3std8datetime5MonthbZAya",
    "parameters" : [
     {
      "name" : "month",
      "deco" : "E3std8datetime5Month"
     },
     {
      "name" : "useLongName",
      "deco" : "b",
      "default" : "true"
     }
    ],
    "endline" : 32654
   },
   {
    "name" : "__unittestL32656_1004",
    "kind" : "function",
    "protection" : "private",
    "line" : 32656,
    "endline" : 32708
   },
   {
    "name" : "monthFromString",
    "kind" : "function",
    "protection" : "private",
    "line" : 32708,
    "deco" : "FAyaZE3std8datetime5Month",
    "parameters" : [
     {
      "name" : "monthStr",
      "deco" : "Aya"
     }
    ],
    "endline" : 32750
   },
   {
    "name" : "__unittestL32752_1005",
    "kind" : "function",
    "protection" : "private",
    "line" : 32752,
    "endline" : 32814
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32814,
    "name" : "nextSmallerTimeUnits",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "nextSmallerTimeUnits",
      "kind" : "variable",
      "line" : 32818,
      "storageClass" : [
       "enum"
      ],
      "init" : "timeStrings[countUntil(timeStrings.dup, units) - 1]"
     }
    ]
   },
   {
    "name" : "__unittestL32821_1006",
    "kind" : "function",
    "protection" : "private",
    "line" : 32821,
    "endline" : 32851
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32851,
    "name" : "nextLargerTimeUnits",
    "parameters" : [
     {
      "name" : "units",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "nextLargerTimeUnits",
      "kind" : "variable",
      "line" : 32855,
      "storageClass" : [
       "enum"
      ],
      "init" : "timeStrings[countUntil(timeStrings.dup, units) + 1]"
     }
    ]
   },
   {
    "name" : "__unittestL32858_1007",
    "kind" : "function",
    "protection" : "private",
    "line" : 32858,
    "endline" : 32882
   },
   {
    "name" : "fracSecToISOString",
    "kind" : "function",
    "protection" : "private",
    "line" : 32882,
    "storageClass" : [
     "static"
    ],
    "deco" : "FNbiZAya",
    "parameters" : [
     {
      "name" : "hnsecs",
      "deco" : "i"
     }
    ],
    "endline" : 32903
   },
   {
    "name" : "__unittestL32905_1008",
    "kind" : "function",
    "protection" : "private",
    "line" : 32905,
    "endline" : 32940
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 32940,
    "name" : "fracSecFromISOString",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "fracSecFromISOString",
      "kind" : "function",
      "line" : 32940,
      "type" : "FracSec(in S isoString)",
      "parameters" : [
       {
        "name" : "isoString",
        "type" : "S",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 32965
     }
    ]
   },
   {
    "name" : "__unittestL32967_1009",
    "kind" : "function",
    "protection" : "private",
    "line" : 32967,
    "endline" : 33027
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33027,
    "name" : "hasMin",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasMin",
      "kind" : "variable",
      "line" : 33033,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(hasMember, T, \"min\") && __traits(isStaticFunction, T.min) && is(ReturnType!(T.min) == Unqual!(T)) && functionAttributes!(T.min) & FunctionAttribute.property && functionAttributes!(T.min) & FunctionAttribute.nothrow_"
     }
    ]
   },
   {
    "name" : "__unittestL33037_1010",
    "kind" : "function",
    "protection" : "private",
    "line" : 33037,
    "endline" : 33060
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33060,
    "name" : "hasMax",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasMax",
      "kind" : "variable",
      "line" : 33066,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(hasMember, T, \"max\") && __traits(isStaticFunction, T.max) && is(ReturnType!(T.max) == Unqual!(T)) && functionAttributes!(T.max) & FunctionAttribute.property && functionAttributes!(T.max) & FunctionAttribute.nothrow_"
     }
    ]
   },
   {
    "name" : "__unittestL33070_1011",
    "kind" : "function",
    "protection" : "private",
    "line" : 33070,
    "endline" : 33099
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33099,
    "name" : "hasOverloadedOpBinaryWithDuration",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasOverloadedOpBinaryWithDuration",
      "kind" : "variable",
      "line" : 33108,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(compiles, T.init + dur!(\"days\")(5)) && is(typeof(T.init + dur!(\"days\")(5)) == Unqual!(T)) && __traits(compiles, T.init - dur!(\"days\")(5)) && is(typeof(T.init - dur!(\"days\")(5)) == Unqual!(T)) && __traits(compiles, T.init + TickDuration.from!(\"hnsecs\")(5)) && is(typeof(T.init + TickDuration.from!(\"hnsecs\")(5)) == Unqual!(T)) && __traits(compiles, T.init - TickDuration.from!(\"hnsecs\")(5)) && is(typeof(T.init - TickDuration.from!(\"hnsecs\")(5)) == Unqual!(T))"
     }
    ]
   },
   {
    "name" : "__unittestL33111_1012",
    "kind" : "function",
    "protection" : "private",
    "line" : 33111,
    "endline" : 33140
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33140,
    "name" : "hasOverloadedOpAssignWithDuration",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasOverloadedOpAssignWithDuration",
      "kind" : "variable",
      "line" : 33151,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(typeof(()\n{\nauto d = dur!(\"days\")(5);\nauto td = TickDuration.from!(\"hnsecs\")(5);\nalias Unqual!(T) U;\nstatic assert(is(typeof(U.init += d) == U));\nstatic assert(is(typeof(U.init -= d) == U));\nstatic assert(is(typeof(U.init += td) == U));\nstatic assert(is(typeof(U.init -= td) == U));\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL33154_1014",
    "kind" : "function",
    "protection" : "private",
    "line" : 33154,
    "endline" : 33182
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33182,
    "name" : "hasOverloadedOpBinaryWithSelf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasOverloadedOpBinaryWithSelf",
      "kind" : "variable",
      "line" : 33185,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(compiles, T.init - T.init) && is(Unqual!(typeof(T.init - T.init)) == Duration)"
     }
    ]
   },
   {
    "name" : "__unittestL33188_1015",
    "kind" : "function",
    "protection" : "private",
    "line" : 33188,
    "endline" : 33213
   },
   {
    "name" : "numToString",
    "kind" : "function",
    "protection" : "private",
    "line" : 33213,
    "deco" : "FNaNblZAya",
    "parameters" : [
     {
      "name" : "value",
      "deco" : "l"
     }
    ],
    "endline" : 33243
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33591,
    "name" : "_assertPred",
    "parameters" : [
     {
      "name" : "op",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "L",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "_assertPred",
      "kind" : "function",
      "line" : 33591,
      "type" : "void(L lhs, R rhs, lazy string msg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "L"
       },
       {
        "name" : "rhs",
        "type" : "R"
       },
       {
        "name" : "msg",
        "type" : "string",
        "storageClass" : [
         "lazy"
        ],
        "default" : "null"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 33612
     }
    ]
   },
   {
    "name" : "__unittestL33614_1016",
    "kind" : "function",
    "protection" : "private",
    "line" : 33614,
    "endline" : 33709
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33709,
    "name" : "_assertPred",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "expected",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "L",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "_assertPred",
      "kind" : "function",
      "line" : 33709,
      "type" : "void(L lhs, R rhs, lazy string msg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "L"
       },
       {
        "name" : "rhs",
        "type" : "R"
       },
       {
        "name" : "msg",
        "type" : "string",
        "storageClass" : [
         "lazy"
        ],
        "default" : "null"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 33783
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 33785,
    "name" : "_assertPred",
    "parameters" : [
     {
      "name" : "op",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "L",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "_assertPred",
      "kind" : "function",
      "line" : 33785,
      "type" : "void(L lhs, R rhs, E expected, lazy string msg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "L"
       },
       {
        "name" : "rhs",
        "type" : "R"
       },
       {
        "name" : "expected",
        "type" : "E"
       },
       {
        "name" : "msg",
        "type" : "string",
        "storageClass" : [
         "lazy"
        ],
        "default" : "null"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 33865
     }
    ]
   },
   {
    "name" : "__unittestL33867_1017",
    "kind" : "function",
    "protection" : "private",
    "line" : 33867,
    "endline" : 34012
   },
   {
    "name" : "__unittestL34012_1018",
    "kind" : "function",
    "protection" : "private",
    "line" : 34012,
    "endline" : 34021
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 34021,
    "name" : "_isPrintable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   }
  ]
 },
 {
  "name" : "std.demangle",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/demangle.d",
  "comment" : "\n Demangle D mangled names.\n\n Macros:\n  WIKI = Phobos/StdDemangle\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Thomas Kuehne, Frits van Bommel\n Source:    $(PHOBOSSRC std/_demangle.d)\n \n",
  "members" : [
   {
    "name" : "core.demangle",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "MangleException",
    "kind" : "class",
    "protection" : "private",
    "line" : 26,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 28,
      "deco" : "FZC3std8demangle15MangleException",
      "originalType" : "()",
      "endline" : 31
     }
    ]
   },
   {
    "name" : "demangle",
    "kind" : "function",
    "comment" : "\n Demangle D mangled names.\n\n If it is not a D mangled name, it returns its argument name.\n Example:\n        This program reads standard in and writes it to standard out,\n        pretty-printing any found D mangled names.\n-------------------\nimport core.stdc.stdio : stdin;\nimport std.stdio;\nimport std.ascii;\nimport std.demangle;\n\nvoid test(int x, float y) { }\n\nint main()\n{\n    string buffer;\n    bool inword;\n    int c;\n\n    writefln(\"Try typing in: %s\", test.mangleof);\n    while ((c = fgetc(stdin)) != EOF)\n    {\n        if (inword)\n        {\n            if (c == '_' || isAlphaNum(c))\n                buffer ~= cast(char) c;\n            else\n            {\n                inword = false;\n                write(demangle(buffer), cast(char) c);\n            }\n        }\n        else\n        {   if (c == '_' || isAlpha(c))\n            {\n                inword = true;\n                buffer.length = 0;\n                buffer ~= cast(char) c;\n            }\n            else\n                write(cast(char) c);\n        }\n    }\n    if (inword)\n        write(demangle(buffer));\n    return 0;\n}\n-------------------\n \n",
    "line" : 86,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "Aya"
     }
    ],
    "endline" : 90
   }
  ]
 },
 {
  "name" : "std.encoding",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/encoding.d",
  "comment" : "\nClasses and functions for handling and transcoding between various encodings.\n\nFor cases where the _encoding is known at compile-time, functions are provided\nfor arbitrary _encoding and decoding of characters, arbitrary transcoding\nbetween strings of different type, as well as validation and sanitization.\n\nEncodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1\n(also known as LATIN-1), and WINDOWS-1252.\n\n$(UL\n$(LI The type $(D AsciiChar) represents an ASCII character.)\n$(LI The type $(D AsciiString) represents an ASCII string.)\n$(LI The type $(D Latin1Char) represents an ISO-8859-1 character.)\n$(LI The type $(D Latin1String) represents an ISO-8859-1 string.)\n$(LI The type $(D Windows1252Char) represents a Windows-1252 character.)\n$(LI The type $(D Windows1252String) represents a Windows-1252 string.))\n\nFor cases where the _encoding is not known at compile-time, but is\nknown at run-time, we provide the abstract class $(D EncodingScheme)\nand its subclasses.  To construct a run-time encoder/decoder, one does\ne.g.\n\n----------------------------------------------------\n    auto e = EncodingScheme.create(\"utf-8\");\n----------------------------------------------------\n\nThis library supplies $(D EncodingScheme) subclasses for ASCII,\nISO-8859-1 (also known as LATIN-1), WINDOWS-1252, UTF-8, and (on\nlittle-endian architectures) UTF-16LE and UTF-32LE; or (on big-endian\narchitectures) UTF-16BE and UTF-32BE.\n\nThis library provides a mechanism whereby other modules may add $(D\nEncodingScheme) subclasses for any other _encoding.\n\nMacros:\n    WIKI=Phobos/StdEncoding\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std/_encoding.d)\n",
  "members" : [
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 54,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 55,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 56,
    "protection" : "private"
   },
   {
    "name" : "__unittestL58_1019",
    "kind" : "function",
    "line" : 58,
    "endline" : 364
   },
   {
    "name" : "INVALID_SEQUENCE",
    "kind" : "variable",
    "comment" : " Special value returned by $(D safeDecode) \n",
    "line" : 364,
    "storageClass" : [
     "enum"
    ],
    "deco" : "w",
    "init" : "'\\Uffffffff'"
   },
   {
    "kind" : "template",
    "line" : 366,
    "name" : "EncoderFunctions",
    "parameters" : [],
    "members" : [
     {
      "kind" : "template",
      "line" : 370,
      "name" : "ReadFromString",
      "parameters" : [],
      "members" : [
       {
        "name" : "canRead",
        "kind" : "function",
        "line" : 372,
        "type" : "bool()",
        "endline" : 372
       },
       {
        "name" : "peek",
        "kind" : "function",
        "line" : 373,
        "type" : "E()",
        "endline" : 373
       },
       {
        "name" : "read",
        "kind" : "function",
        "line" : 374,
        "type" : "E()",
        "endline" : 374
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 377,
      "name" : "ReverseReadFromString",
      "parameters" : [],
      "members" : [
       {
        "name" : "canRead",
        "kind" : "function",
        "line" : 379,
        "type" : "bool()",
        "endline" : 379
       },
       {
        "name" : "peek",
        "kind" : "function",
        "line" : 380,
        "type" : "E()",
        "endline" : 380
       },
       {
        "name" : "read",
        "kind" : "function",
        "line" : 381,
        "type" : "E()",
        "endline" : 381
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 386,
      "name" : "WriteToString",
      "parameters" : [],
      "members" : [
       {
        "name" : "s",
        "kind" : "variable",
        "line" : 388,
        "type" : "E[]"
       },
       {
        "name" : "write",
        "kind" : "function",
        "line" : 389,
        "type" : "void(E c)",
        "parameters" : [
         {
          "name" : "c",
          "type" : "E"
         }
        ],
        "endline" : 389
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 392,
      "name" : "WriteToArray",
      "parameters" : [],
      "members" : [
       {
        "name" : "write",
        "kind" : "function",
        "line" : 394,
        "type" : "void(E c)",
        "parameters" : [
         {
          "name" : "c",
          "type" : "E"
         }
        ],
        "endline" : 394
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 397,
      "name" : "WriteToDelegate",
      "parameters" : [],
      "members" : [
       {
        "name" : "write",
        "kind" : "function",
        "line" : 399,
        "type" : "void(E c)",
        "parameters" : [
         {
          "name" : "c",
          "type" : "E"
         }
        ],
        "endline" : 399
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 404,
      "name" : "EncodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite!()",
        "kind" : "mixin",
        "line" : 406
       },
       {
        "name" : "encode",
        "kind" : "function",
        "line" : 407,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 407
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 410,
      "name" : "SkipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead!()",
        "kind" : "mixin",
        "line" : 412
       },
       {
        "name" : "skip",
        "kind" : "function",
        "line" : 413,
        "type" : "void()",
        "endline" : 413
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 416,
      "name" : "DecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead!()",
        "kind" : "mixin",
        "line" : 418
       },
       {
        "name" : "decode",
        "kind" : "function",
        "line" : 419,
        "type" : "dchar()",
        "endline" : 419
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 422,
      "name" : "SafeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead!()",
        "kind" : "mixin",
        "line" : 424
       },
       {
        "name" : "safeDecode",
        "kind" : "function",
        "line" : 425,
        "type" : "dchar()",
        "endline" : 425
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 428,
      "name" : "DecodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead!()",
        "kind" : "mixin",
        "line" : 430
       },
       {
        "name" : "decodeReverse",
        "kind" : "function",
        "line" : 431,
        "type" : "dchar()",
        "endline" : 431
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 436,
      "name" : "EncodeToString",
      "parameters" : [],
      "members" : [
       {
        "name" : "WriteToString!()",
        "kind" : "mixin",
        "line" : 438
       },
       {
        "name" : "EncodeViaWrite!()",
        "kind" : "mixin",
        "line" : 439
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 442,
      "name" : "EncodeToArray",
      "parameters" : [],
      "members" : [
       {
        "name" : "WriteToArray!()",
        "kind" : "mixin",
        "line" : 444
       },
       {
        "name" : "EncodeViaWrite!()",
        "kind" : "mixin",
        "line" : 445
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 448,
      "name" : "EncodeToDelegate",
      "parameters" : [],
      "members" : [
       {
        "name" : "WriteToDelegate!()",
        "kind" : "mixin",
        "line" : 450
       },
       {
        "name" : "EncodeViaWrite!()",
        "kind" : "mixin",
        "line" : 451
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 456,
      "name" : "SkipFromString",
      "parameters" : [],
      "members" : [
       {
        "name" : "ReadFromString!()",
        "kind" : "mixin",
        "line" : 458
       },
       {
        "name" : "SkipViaRead!()",
        "kind" : "mixin",
        "line" : 459
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 462,
      "name" : "DecodeFromString",
      "parameters" : [],
      "members" : [
       {
        "name" : "ReadFromString!()",
        "kind" : "mixin",
        "line" : 464
       },
       {
        "name" : "DecodeViaRead!()",
        "kind" : "mixin",
        "line" : 465
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 468,
      "name" : "SafeDecodeFromString",
      "parameters" : [],
      "members" : [
       {
        "name" : "ReadFromString!()",
        "kind" : "mixin",
        "line" : 470
       },
       {
        "name" : "SafeDecodeViaRead!()",
        "kind" : "mixin",
        "line" : 471
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 474,
      "name" : "DecodeReverseFromString",
      "parameters" : [],
      "members" : [
       {
        "name" : "ReverseReadFromString!()",
        "kind" : "mixin",
        "line" : 476
       },
       {
        "name" : "DecodeReverseViaRead!()",
        "kind" : "mixin",
        "line" : 477
       }
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 484,
      "type" : "E[](dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 489
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 491,
      "type" : "void(dchar c, ref E[] array)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "array",
        "type" : "E[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 495
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 497,
      "type" : "void(dchar c, void delegate(E) dg)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "dg",
        "type" : "void delegate(E)"
       }
      ],
      "endline" : 501
     },
     {
      "name" : "skip",
      "kind" : "function",
      "line" : 503,
      "type" : "void(ref const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 507
     },
     {
      "kind" : "template",
      "line" : 509,
      "name" : "decode",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "decode",
        "kind" : "function",
        "line" : 509,
        "type" : "dchar(ref S s)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "S",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 513
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 515,
      "name" : "safeDecode",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "safeDecode",
        "kind" : "function",
        "line" : 515,
        "type" : "dchar(ref S s)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "S",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 519
       }
      ]
     },
     {
      "name" : "decodeReverse",
      "kind" : "function",
      "line" : 521,
      "type" : "dchar(ref const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 525
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 531,
    "name" : "CodePoints",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "CodePoints",
      "kind" : "struct",
      "line" : 531,
      "members" : [
       {
        "name" : "s",
        "kind" : "variable",
        "line" : 532,
        "type" : "const(E)[]"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 534,
        "type" : "(const(E)[] s)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "const(E)[]"
         }
        ],
        "endline" : 542
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 544,
        "type" : "int(scope int delegate(ref dchar) dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "int delegate(ref dchar)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 554
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 556,
        "type" : "int(scope int delegate(ref size_t, ref dchar) dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "int delegate(ref size_t, ref dchar)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 570
       },
       {
        "name" : "opApplyReverse",
        "kind" : "function",
        "line" : 572,
        "type" : "int(scope int delegate(ref dchar) dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "int delegate(ref dchar)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 582
       },
       {
        "name" : "opApplyReverse",
        "kind" : "function",
        "line" : 584,
        "type" : "int(scope int delegate(ref size_t, ref dchar) dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "int delegate(ref size_t, ref dchar)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 595
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 599,
    "name" : "CodeUnits",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "CodeUnits",
      "kind" : "struct",
      "line" : 599,
      "members" : [
       {
        "name" : "s",
        "kind" : "variable",
        "line" : 600,
        "type" : "E[]"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 602,
        "type" : "(dchar d)",
        "parameters" : [
         {
          "name" : "d",
          "deco" : "w"
         }
        ],
        "endline" : 610
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 612,
        "type" : "int(scope int delegate(ref E) dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "int delegate(ref E)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 621
       },
       {
        "name" : "opApplyReverse",
        "kind" : "function",
        "line" : 623,
        "type" : "int(scope int delegate(ref E) dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "int delegate(ref E)",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 632
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 637,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "AsciiChar",
    "kind" : "enum",
    "comment" : " Defines various character sets. \n",
    "line" : 648,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "init",
      "kind" : "enum member",
      "line" : 648
     }
    ]
   },
   {
    "name" : "AsciiString",
    "kind" : "alias",
    "comment" : " Ditto\n",
    "line" : 650,
    "deco" : "AyE3std8encoding9AsciiChar"
   },
   {
    "kind" : "template",
    "line" : 652,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "CharType",
      "kind" : "type",
      "deco" : "E3std8encoding9AsciiChar"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 654,
      "type" : "AsciiChar"
     },
     {
      "name" : "EString",
      "kind" : "alias",
      "line" : 655,
      "type" : "AsciiString"
     },
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 657,
      "type" : "string()",
      "endline" : 660
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 662,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 665
     },
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "line" : 667,
      "type" : "bool(AsciiChar c)",
      "parameters" : [
       {
        "name" : "c",
        "type" : "AsciiChar"
       }
      ],
      "endline" : 670
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 672,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 680
     },
     {
      "kind" : "template",
      "line" : 682,
      "name" : "encodeX",
      "parameters" : [
       {
        "name" : "Range",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "encodeX",
        "kind" : "function",
        "line" : 682,
        "type" : "void(dchar c, Range r)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         },
         {
          "name" : "r",
          "type" : "Range"
         }
        ],
        "endline" : 686
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 688,
      "name" : "encodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite",
        "kind" : "function",
        "line" : 688,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 692
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 694,
      "name" : "skipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead",
        "kind" : "function",
        "line" : 694,
        "type" : "void()",
        "endline" : 697
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 699,
      "name" : "decodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead",
        "kind" : "function",
        "line" : 699,
        "type" : "dchar()",
        "endline" : 702
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 704,
      "name" : "safeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead",
        "kind" : "function",
        "line" : 704,
        "type" : "dchar()",
        "endline" : 708
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 710,
      "name" : "decodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead",
        "kind" : "function",
        "line" : 710,
        "type" : "dchar()",
        "endline" : 713
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 715,
      "type" : "EString()",
      "endline" : 718
     },
     {
      "name" : "EncoderFunctions!()",
      "kind" : "mixin",
      "line" : 720
     }
    ]
   },
   {
    "name" : "Latin1Char",
    "kind" : "enum",
    "comment" : " Defines an Latin1-encoded character. \n",
    "line" : 728,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "init",
      "kind" : "enum member",
      "line" : 728
     }
    ]
   },
   {
    "name" : "Latin1String",
    "kind" : "alias",
    "comment" : "\nDefines an Latin1-encoded string (as an array of $(D\nimmutable(Latin1Char))).\n \n\n",
    "line" : 733,
    "deco" : "AyE3std8encoding10Latin1Char"
   },
   {
    "kind" : "template",
    "line" : 735,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "CharType",
      "kind" : "type",
      "deco" : "E3std8encoding10Latin1Char"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 737,
      "type" : "Latin1Char"
     },
     {
      "name" : "EString",
      "kind" : "alias",
      "line" : 738,
      "type" : "Latin1String"
     },
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 740,
      "type" : "string()",
      "endline" : 743
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 745,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 748
     },
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "line" : 750,
      "type" : "bool(Latin1Char c)",
      "parameters" : [
       {
        "name" : "c",
        "type" : "Latin1Char"
       }
      ],
      "endline" : 753
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 755,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 763
     },
     {
      "kind" : "template",
      "line" : 765,
      "name" : "encodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite",
        "kind" : "function",
        "line" : 765,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 769
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 771,
      "name" : "skipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead",
        "kind" : "function",
        "line" : 771,
        "type" : "void()",
        "endline" : 774
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 776,
      "name" : "decodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead",
        "kind" : "function",
        "line" : 776,
        "type" : "dchar()",
        "endline" : 779
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 781,
      "name" : "safeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead",
        "kind" : "function",
        "line" : 781,
        "type" : "dchar()",
        "endline" : 784
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 786,
      "name" : "decodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead",
        "kind" : "function",
        "line" : 786,
        "type" : "dchar()",
        "endline" : 789
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 791,
      "type" : "EString()",
      "endline" : 794
     },
     {
      "name" : "EncoderFunctions!()",
      "kind" : "mixin",
      "line" : 796
     }
    ]
   },
   {
    "name" : "Windows1252Char",
    "kind" : "enum",
    "comment" : " Defines a Windows1252-encoded character. \n",
    "line" : 804,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "init",
      "kind" : "enum member",
      "line" : 804
     }
    ]
   },
   {
    "name" : "Windows1252String",
    "kind" : "alias",
    "comment" : "\nDefines an Windows1252-encoded string (as an array of $(D\nimmutable(Windows1252Char))).\n \n\n",
    "line" : 809,
    "deco" : "AyE3std8encoding15Windows1252Char"
   },
   {
    "kind" : "template",
    "line" : 811,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "CharType",
      "kind" : "type",
      "deco" : "E3std8encoding15Windows1252Char"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 813,
      "type" : "Windows1252Char"
     },
     {
      "name" : "EString",
      "kind" : "alias",
      "line" : 814,
      "type" : "Windows1252String"
     },
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 816,
      "type" : "string()",
      "endline" : 819
     },
     {
      "name" : "charMap",
      "kind" : "variable",
      "line" : 821,
      "type" : "wstring",
      "init" : "\"\\xe2\\x82\\xac\\xef\\xbf\\xbd\\xe2\\x80\\x9a\\xc6\\x92\\xe2\\x80\\x9e\\xe2\\x80\\xa6\\xe2\\x80\\xa0\\xe2\\x80\\xa1\\xcb\\x86\\xe2\\x80\\xb0\\xc5\\xa0\\xe2\\x80\\xb9\\xc5\\x92\\xef\\xbf\\xbd\\xc5\\xbd\\xef\\xbf\\xbd\\xef\\xbf\\xbd\\xe2\\x80\\x98\\xe2\\x80\\x99\\xe2\\x80\\x9c\\xe2\\x80\\x9d\\xe2\\x80\\xa2\\xe2\\x84\\x83\\xe2\\x80\\x94\\xcb\\x9c\\xe2\\x84\\xa2\\xc5\\xa1\\xe2\\x80\\xba\\xc5\\x93\\xef\\xbf\\xbd\\xc5\\xbe\\xc5\\xb8\""
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 828,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 834
     },
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "line" : 836,
      "type" : "bool(Windows1252Char c)",
      "parameters" : [
       {
        "name" : "c",
        "type" : "Windows1252Char"
       }
      ],
      "endline" : 840
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 842,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 850
     },
     {
      "kind" : "template",
      "line" : 852,
      "name" : "encodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite",
        "kind" : "function",
        "line" : 852,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 870
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 872,
      "name" : "skipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead",
        "kind" : "function",
        "line" : 872,
        "type" : "void()",
        "endline" : 875
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 877,
      "name" : "decodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead",
        "kind" : "function",
        "line" : 877,
        "type" : "dchar()",
        "endline" : 881
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 883,
      "name" : "safeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead",
        "kind" : "function",
        "line" : 883,
        "type" : "dchar()",
        "endline" : 888
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 890,
      "name" : "decodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead",
        "kind" : "function",
        "line" : 890,
        "type" : "dchar()",
        "endline" : 894
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 896,
      "type" : "EString()",
      "endline" : 899
     },
     {
      "name" : "EncoderFunctions!()",
      "kind" : "mixin",
      "line" : 901
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 908,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "CharType",
      "kind" : "type",
      "deco" : "a"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 910,
      "deco" : "a"
     },
     {
      "name" : "EString",
      "kind" : "alias",
      "line" : 911,
      "type" : "immutable(char)[]"
     },
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 913,
      "type" : "string()",
      "endline" : 916
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 918,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 921
     },
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "line" : 923,
      "type" : "bool(char c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "a"
       }
      ],
      "endline" : 926
     },
     {
      "name" : "tailTable",
      "kind" : "variable",
      "line" : 928,
      "type" : "ubyte[128]",
      "init" : "[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 6, 0]"
     },
     {
      "name" : "tails",
      "kind" : "function",
      "line" : 940,
      "type" : "int(char c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "a"
       }
      ],
      "endline" : 948
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 950,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 961
     },
     {
      "kind" : "template",
      "line" : 963,
      "name" : "encodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite",
        "kind" : "function",
        "line" : 963,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 987
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 989,
      "name" : "skipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead",
        "kind" : "function",
        "line" : 989,
        "type" : "void()",
        "endline" : 998
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1000,
      "name" : "decodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead",
        "kind" : "function",
        "line" : 1000,
        "type" : "dchar()",
        "endline" : 1011
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1013,
      "name" : "safeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead",
        "kind" : "function",
        "line" : 1013,
        "type" : "dchar()",
        "endline" : 1042
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1044,
      "name" : "decodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead",
        "kind" : "function",
        "line" : 1044,
        "type" : "dchar()",
        "endline" : 1060
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 1062,
      "type" : "EString()",
      "endline" : 1065
     },
     {
      "name" : "EncoderFunctions!()",
      "kind" : "mixin",
      "line" : 1067
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1074,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "CharType",
      "kind" : "type",
      "deco" : "u"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 1076,
      "deco" : "u"
     },
     {
      "name" : "EString",
      "kind" : "alias",
      "line" : 1077,
      "type" : "immutable(wchar)[]"
     },
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 1079,
      "type" : "string()",
      "endline" : 1082
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 1084,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1087
     },
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "line" : 1089,
      "type" : "bool(wchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "u"
       }
      ],
      "endline" : 1092
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 1094,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1102
     },
     {
      "kind" : "template",
      "line" : 1104,
      "name" : "encodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite",
        "kind" : "function",
        "line" : 1104,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 1116
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1118,
      "name" : "skipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead",
        "kind" : "function",
        "line" : 1118,
        "type" : "void()",
        "endline" : 1123
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1125,
      "name" : "decodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead",
        "kind" : "function",
        "line" : 1125,
        "type" : "dchar()",
        "endline" : 1133
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1135,
      "name" : "safeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead",
        "kind" : "function",
        "line" : 1135,
        "type" : "dchar()",
        "endline" : 1147
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1149,
      "name" : "decodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead",
        "kind" : "function",
        "line" : 1149,
        "type" : "dchar()",
        "endline" : 1157
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 1159,
      "type" : "EString()",
      "endline" : 1162
     },
     {
      "name" : "EncoderFunctions!()",
      "kind" : "mixin",
      "line" : 1164
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1171,
    "name" : "EncoderInstance",
    "parameters" : [
     {
      "name" : "CharType",
      "kind" : "type",
      "deco" : "w"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 1173,
      "deco" : "w"
     },
     {
      "name" : "EString",
      "kind" : "alias",
      "line" : 1174,
      "type" : "immutable(dchar)[]"
     },
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 1176,
      "type" : "string()",
      "endline" : 1179
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 1181,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1184
     },
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "line" : 1186,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1189
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 1191,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1199
     },
     {
      "kind" : "template",
      "line" : 1201,
      "name" : "encodeViaWrite",
      "parameters" : [],
      "members" : [
       {
        "name" : "encodeViaWrite",
        "kind" : "function",
        "line" : 1201,
        "type" : "void(dchar c)",
        "parameters" : [
         {
          "name" : "c",
          "deco" : "w"
         }
        ],
        "endline" : 1204
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1206,
      "name" : "skipViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "skipViaRead",
        "kind" : "function",
        "line" : 1206,
        "type" : "void()",
        "endline" : 1209
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1211,
      "name" : "decodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeViaRead",
        "kind" : "function",
        "line" : 1211,
        "type" : "dchar()",
        "endline" : 1214
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1216,
      "name" : "safeDecodeViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "safeDecodeViaRead",
        "kind" : "function",
        "line" : 1216,
        "type" : "dchar()",
        "endline" : 1220
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 1222,
      "name" : "decodeReverseViaRead",
      "parameters" : [],
      "members" : [
       {
        "name" : "decodeReverseViaRead",
        "kind" : "function",
        "line" : 1222,
        "type" : "dchar()",
        "endline" : 1225
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 1227,
      "type" : "EString()",
      "endline" : 1230
     },
     {
      "name" : "EncoderFunctions!()",
      "kind" : "mixin",
      "line" : 1232
     }
    ]
   },
   {
    "name" : "isValidCodePoint",
    "kind" : "function",
    "comment" : "\nReturns true if c is a valid code point\n\n Note that this includes the non-character code points U+FFFE and U+FFFF,\n since these are valid code points (even though they are not valid\n characters).\n\n Supercedes:\n This function supercedes $(D std.utf.startsValidDchar()).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be tested\n \n",
    "line" : 1253,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1256
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the name of an encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Examples:\n -----------------------------------\n assert(encodingName!(Latin1Char) == \"ISO-8859-1\");\n -----------------------------------\n \n",
    "line" : 1271,
    "name" : "encodingName",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encodingName",
      "kind" : "function",
      "line" : 1271,
      "type" : "string()",
      "endline" : 1274
     }
    ]
   },
   {
    "name" : "__unittestL1276_1020",
    "kind" : "function",
    "line" : 1276,
    "endline" : 1300
   },
   {
    "kind" : "template",
    "comment" : "\n Returns true iff it is possible to represent the specifed codepoint\n in the encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Examples:\n -----------------------------------\n assert(canEncode!(Latin1Char)('A'));\n -----------------------------------\n \n",
    "line" : 1300,
    "name" : "canEncode",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "canEncode",
      "kind" : "function",
      "comment" : "\n Returns true iff it is possible to represent the specifed codepoint\n in the encoding.\n\n The type of encoding cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Examples:\n -----------------------------------\n assert(canEncode!(Latin1Char)('A'));\n -----------------------------------\n \n",
      "line" : 1300,
      "type" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1303
     }
    ]
   },
   {
    "name" : "__unittestL1305_1021",
    "kind" : "function",
    "line" : 1305,
    "endline" : 1325
   },
   {
    "kind" : "template",
    "comment" : "\n Returns true if the code unit is legal. For example, the byte 0x80 would\n not be legal in ASCII, because ASCII code units must always be in the range\n 0x00 to 0x7F.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code unit to be tested\n \n",
    "line" : 1325,
    "name" : "isValidCodeUnit",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isValidCodeUnit",
      "kind" : "function",
      "comment" : "\n Returns true if the code unit is legal. For example, the byte 0x80 would\n not be legal in ASCII, because ASCII code units must always be in the range\n 0x00 to 0x7F.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code unit to be tested\n \n",
      "line" : 1325,
      "type" : "bool(E c)",
      "parameters" : [
       {
        "name" : "c",
        "type" : "E"
       }
      ],
      "endline" : 1328
     }
    ]
   },
   {
    "name" : "__unittestL1330_1022",
    "kind" : "function",
    "line" : 1330,
    "endline" : 1354
   },
   {
    "kind" : "template",
    "comment" : "\n Returns true if the string is encoded correctly\n\n Supercedes:\n This function supercedes std.utf.validate(), however note that this\n function returns a bool indicating whether the input was valid or not,\n wheras the older funtion would throw an exception.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
    "line" : 1354,
    "name" : "isValid",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isValid",
      "kind" : "function",
      "comment" : "\n Returns true if the string is encoded correctly\n\n Supercedes:\n This function supercedes std.utf.validate(), however note that this\n function returns a bool indicating whether the input was valid or not,\n wheras the older funtion would throw an exception.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
      "line" : 1354,
      "type" : "bool(const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]"
       }
      ],
      "endline" : 1357
     }
    ]
   },
   {
    "name" : "__unittestL1359_1023",
    "kind" : "function",
    "line" : 1359,
    "endline" : 1373
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the length of the longest possible substring, starting from\n the first code unit, which is validly encoded.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
    "line" : 1373,
    "name" : "validLength",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "validLength",
      "kind" : "function",
      "comment" : "\n Returns the length of the longest possible substring, starting from\n the first code unit, which is validly encoded.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be tested\n \n",
      "line" : 1373,
      "type" : "size_t(const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]"
       }
      ],
      "endline" : 1383
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Sanitizes a string by replacing malformed code unit sequences with valid\n code unit sequences. The result is guaranteed to be valid for this encoding.\n\n If the input string is already valid, this function returns the original,\n otherwise it constructs a new string by replacing all illegal code unit\n sequences with the encoding's replacement character, Invalid sequences will\n be replaced with the Unicode replacement character (U+FFFD) if the\n character repertoire contains it, otherwise invalid sequences will be\n replaced with '?'.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sanitized\n \n",
    "line" : 1401,
    "name" : "sanitize",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sanitize",
      "kind" : "function",
      "comment" : "\n Sanitizes a string by replacing malformed code unit sequences with valid\n code unit sequences. The result is guaranteed to be valid for this encoding.\n\n If the input string is already valid, this function returns the original,\n otherwise it constructs a new string by replacing all illegal code unit\n sequences with the encoding's replacement character, Invalid sequences will\n be replaced with the Unicode replacement character (U+FFFD) if the\n character repertoire contains it, otherwise invalid sequences will be\n replaced with '?'.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sanitized\n \n",
      "line" : 1401,
      "type" : "immutable(E)[](immutable(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "immutable(E)[]"
       }
      ],
      "endline" : 1438
     }
    ]
   },
   {
    "name" : "__unittestL1440_1024",
    "kind" : "function",
    "line" : 1440,
    "endline" : 1456
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the length of the first encoded sequence.\n\nThe input to this function MUST be validly encoded.\nThis is enforced by the function's in-contract.\n\nStandards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\nParams:\ns = the string to be sliced\n \n",
    "line" : 1456,
    "name" : "firstSequence",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "firstSequence",
      "kind" : "function",
      "comment" : "\nReturns the length of the first encoded sequence.\n\nThe input to this function MUST be validly encoded.\nThis is enforced by the function's in-contract.\n\nStandards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\nParams:\ns = the string to be sliced\n \n",
      "line" : 1456,
      "type" : "size_t(const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]"
       }
      ],
      "endline" : 1468
     }
    ]
   },
   {
    "name" : "__unittestL1470_1025",
    "kind" : "function",
    "line" : 1470,
    "endline" : 1486
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the length the last encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sliced\n \n",
    "line" : 1486,
    "name" : "lastSequence",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "lastSequence",
      "kind" : "function",
      "comment" : "\n Returns the length the last encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be sliced\n \n",
      "line" : 1486,
      "type" : "size_t(const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]"
       }
      ],
      "endline" : 1497
     }
    ]
   },
   {
    "name" : "__unittestL1499_1026",
    "kind" : "function",
    "line" : 1499,
    "endline" : 1518
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTFindex().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be counted\n \n",
    "line" : 1518,
    "name" : "index",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "index",
      "kind" : "function",
      "comment" : "\n Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTFindex().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be counted\n \n",
      "line" : 1518,
      "type" : "ptrdiff_t(const(E)[] s, int n)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]"
       },
       {
        "name" : "n",
        "deco" : "i"
       }
      ],
      "endline" : 1529
     }
    ]
   },
   {
    "name" : "__unittestL1531_1027",
    "kind" : "function",
    "line" : 1531,
    "endline" : 1554
   },
   {
    "kind" : "template",
    "comment" : "\n Decodes a single code point.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.decode(), however, note that the\n function codePoints() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
    "line" : 1554,
    "name" : "decode",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decode",
      "kind" : "function",
      "comment" : "\n Decodes a single code point.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.decode(), however, note that the\n function codePoints() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
      "line" : 1554,
      "type" : "dchar(ref S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1564
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Decodes a single code point from the end of a string.\n\n This function removes one or more code units from the end of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
    "line" : 1580,
    "name" : "decodeReverse",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeReverse",
      "kind" : "function",
      "comment" : "\n Decodes a single code point from the end of a string.\n\n This function removes one or more code units from the end of a string,\n and returns the decoded code point which those code units represent.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
      "line" : 1580,
      "type" : "dchar(ref const(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(E)[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1589
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n This function will accept an invalidly encoded string as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
    "line" : 1606,
    "name" : "safeDecode",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "safeDecode",
      "kind" : "function",
      "comment" : "\n Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more code units from the start of a string,\n and returns the decoded code point which those code units represent.\n\n This function will accept an invalidly encoded string as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string whose first code point is to be decoded\n \n",
      "line" : 1606,
      "type" : "dchar(ref S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1614
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the number of code units required to encode a single code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
    "line" : 1630,
    "name" : "encodedLength",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encodedLength",
      "kind" : "function",
      "comment" : "\n Returns the number of code units required to encode a single code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
      "line" : 1630,
      "type" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1638
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Encodes a single code point.\n\n This function encodes a single code point into one or more code units.\n It returns a string containing those code units.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
    "line" : 1661,
    "name" : "encode",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encode",
      "kind" : "function",
      "comment" : "\n Encodes a single code point.\n\n This function encodes a single code point into one or more code units.\n It returns a string containing those code units.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
      "line" : 1661,
      "type" : "E[](dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1669
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Encodes a single code point into an array.\n\n This function encodes a single code point into one or more code units\n The code units are stored in a user-supplied fixed-size array,\n which must be passed by reference.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n          the number of code units written to the array\n \n",
    "line" : 1696,
    "name" : "encode",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encode",
      "kind" : "function",
      "comment" : "\n Encodes a single code point into an array.\n\n This function encodes a single code point into one or more code units\n The code units are stored in a user-supplied fixed-size array,\n which must be passed by reference.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n          the number of code units written to the array\n \n",
      "line" : 1696,
      "type" : "size_t(dchar c, E[] array)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "array",
        "type" : "E[]"
       }
      ],
      "endline" : 1706
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1744,
    "name" : "encode",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 1744,
      "type" : "size_t(dchar c, R range)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 1799
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Encodes a single code point to a delegate.\n\n This function encodes a single code point into one or more code units.\n The code units are passed one at a time to the supplied delegate.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
    "line" : 1822,
    "name" : "encode",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encode",
      "kind" : "function",
      "comment" : "\n Encodes a single code point to a delegate.\n\n This function encodes a single code point into one or more code units.\n The code units are passed one at a time to the supplied delegate.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding as a template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode(), however, note that the\n function codeUnits() supercedes it more conveniently.\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    c = the code point to be encoded\n \n",
      "line" : 1822,
      "type" : "void(dchar c, void delegate(E) dg)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "dg",
        "type" : "void delegate(E)"
       }
      ],
      "endline" : 1830
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code points in a string.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n You can foreach either\n with or without an index. If an index is specified, it will be initialized\n at each iteration with the offset into the string at which the code point\n begins.\n\n Supercedes:\n This function supercedes std.utf.decode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be decoded\n\n Examples:\n --------------------------------------------------------\n string s = \"hello world\";\n foreach(c;codePoints(s))\n {\n     // do something with c (which will always be a dchar)\n }\n --------------------------------------------------------\n\n Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)\n in that the latter will fall over on encountering U+FFFF.\n \n",
    "line" : 1864,
    "name" : "codePoints",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "codePoints",
      "kind" : "function",
      "comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code points in a string.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n You can foreach either\n with or without an index. If an index is specified, it will be initialized\n at each iteration with the offset into the string at which the code point\n begins.\n\n Supercedes:\n This function supercedes std.utf.decode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the string to be decoded\n\n Examples:\n --------------------------------------------------------\n string s = \"hello world\";\n foreach(c;codePoints(s))\n {\n     // do something with c (which will always be a dchar)\n }\n --------------------------------------------------------\n\n Note that, currently, foreach(c:codePoints(s)) is superior to foreach(c;s)\n in that the latter will fall over on encountering U+FFFF.\n \n",
      "line" : 1864,
      "type" : "CodePoints!(E)(immutable(E)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "immutable(E)[]"
       }
      ],
      "endline" : 1872
     }
    ]
   },
   {
    "name" : "__unittestL1874_1028",
    "kind" : "function",
    "line" : 1874,
    "endline" : 1916
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code units in a code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type in the template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    d = the code point to be encoded\n\n Examples:\n --------------------------------------------------------\n dchar d = '\\u20AC';\n foreach(c;codeUnits!(char)(d))\n {\n     writefln(\"%X\",c)\n }\n // will print\n // E2\n // 82\n // AC\n --------------------------------------------------------\n \n",
    "line" : 1916,
    "name" : "codeUnits",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "codeUnits",
      "kind" : "function",
      "comment" : "\n Returns a foreachable struct which can bidirectionally iterate over all\n code units in a code point.\n\n The input to this function MUST be a valid code point.\n This is enforced by the function's in-contract.\n\n The type of the output cannot be deduced. Therefore, it is necessary to\n explicitly specify the encoding type in the template parameter.\n\n Supercedes:\n This function supercedes std.utf.encode().\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    d = the code point to be encoded\n\n Examples:\n --------------------------------------------------------\n dchar d = '\\u20AC';\n foreach(c;codeUnits!(char)(d))\n {\n     writefln(\"%X\",c)\n }\n // will print\n // E2\n // 82\n // AC\n --------------------------------------------------------\n \n",
      "line" : 1916,
      "type" : "CodeUnits!(E)(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1924
     }
    ]
   },
   {
    "name" : "__unittestL1926_1029",
    "kind" : "function",
    "line" : 1926,
    "endline" : 1944
   },
   {
    "kind" : "template",
    "comment" : "\nEncodes $(D c) in units of type $(D E) and writes the result to the\noutput range $(D R). Returns the number of $(D E)s written.\n \n",
    "line" : 1944,
    "name" : "encode",
    "parameters" : [
     {
      "name" : "Tgt",
      "kind" : "type"
     },
     {
      "name" : "Src",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encode",
      "kind" : "function",
      "comment" : "\nEncodes $(D c) in units of type $(D E) and writes the result to the\noutput range $(D R). Returns the number of $(D E)s written.\n \n",
      "line" : 1944,
      "type" : "size_t(in Src[] s, R range)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Src[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 1952
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Convert a string from one encoding to another. (See also to!() below).\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and\n std.utf.toUTF32()\n (but note that to!() supercedes it more conveniently).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the source string\n    r = the destination string\n\n Examples:\n --------------------------------------------------------\n wstring ws;\n transcode(\"hello world\",ws);\n     // transcode from UTF-8 to UTF-16\n\n Latin1String ls;\n transcode(ws, ls);\n     // transcode from UTF-16 to ISO-8859-1\n  --------------------------------------------------------\n \n",
    "line" : 1982,
    "name" : "transcode",
    "parameters" : [
     {
      "name" : "Src",
      "kind" : "type"
     },
     {
      "name" : "Dst",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "transcode",
      "kind" : "function",
      "comment" : "\n Convert a string from one encoding to another. (See also to!() below).\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Supercedes:\n This function supercedes std.utf.toUTF8(), std.utf.toUTF16() and\n std.utf.toUTF32()\n (but note that to!() supercedes it more conveniently).\n\n Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n Params:\n    s = the source string\n    r = the destination string\n\n Examples:\n --------------------------------------------------------\n wstring ws;\n transcode(\"hello world\",ws);\n     // transcode from UTF-8 to UTF-16\n\n Latin1String ls;\n transcode(ws, ls);\n     // transcode from UTF-16 to ISO-8859-1\n  --------------------------------------------------------\n \n",
      "line" : 1982,
      "type" : "void(immutable(Src)[] s, out immutable(Dst)[] r)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "immutable(Src)[]"
       },
       {
        "name" : "r",
        "type" : "immutable(Dst)[]",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2005
     }
    ]
   },
   {
    "name" : "EncodingException",
    "kind" : "class",
    "comment" : " The base class for exceptions thrown by this module \n",
    "line" : 2045,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2045,
      "deco" : "FAyaZC3std8encoding17EncodingException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2045
     }
    ]
   },
   {
    "name" : "UnrecognizedEncodingException",
    "kind" : "class",
    "line" : 2047,
    "base" : "EncodingException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2049,
      "deco" : "FAyaZC3std8encoding29UnrecognizedEncodingException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2049
     }
    ]
   },
   {
    "name" : "EncodingScheme",
    "kind" : "class",
    "comment" : " Abstract base class of all encoding schemes \n",
    "line" : 2054,
    "members" : [
     {
      "name" : "register",
      "kind" : "function",
      "comment" : "\n Registers a subclass of EncodingScheme.\n\n This function allows user-defined subclasses of EncodingScheme to\n be declared in other modules.\n\n Examples:\n ----------------------------------------------\n class Amiga1251 : EncodingScheme\n {\n     shared static this()\n     {\n         EncodingScheme.register(\"path.to.Amiga1251\");\n     }\n }\n ----------------------------------------------\n     \n",
      "line" : 2072,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaZv",
      "parameters" : [
       {
        "name" : "className",
        "deco" : "Aya"
       }
      ],
      "endline" : 2081
     },
     {
      "name" : "create",
      "kind" : "function",
      "comment" : "\n Obtains a subclass of EncodingScheme which is capable of encoding\n and decoding the named encoding scheme.\n\n This function is only aware of EncodingSchemes which have been\n registered with the register() function.\n\n Examples:\n ---------------------------------------------------\n auto scheme = EncodingScheme.create(\"Amiga-1251\");\n ---------------------------------------------------\n     \n",
      "line" : 2095,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaZC3std8encoding14EncodingScheme",
      "parameters" : [
       {
        "name" : "encodingName",
        "deco" : "Aya"
       }
      ],
      "endline" : 2104
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns the standard name of the encoding scheme\n         \n",
      "line" : 2111,
      "storageClass" : [
       "const",
       "abstract",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "overrides" : [
       "object.Object.toString"
      ]
     },
     {
      "name" : "names",
      "kind" : "function",
      "comment" : "\n Returns an array of all known names for this encoding scheme\n         \n",
      "line" : 2116,
      "storageClass" : [
       "const",
       "abstract"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()"
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "comment" : "\n Returns true if the character c can be represented\n in this encoding scheme.\n         \n",
      "line" : 2122,
      "storageClass" : [
       "const",
       "abstract"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "comment" : "\n Returns the number of ubytes required to encode this code point.\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n    the number of ubytes required.\n         \n",
      "line" : 2135,
      "storageClass" : [
       "const",
       "abstract"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "comment" : "\n Encodes a single code point into a user-supplied, fixed-size buffer.\n\n This function encodes a single code point into one or more ubytes.\n The supplied buffer must be code unit aligned.\n (For example, UTF-16LE or UTF-16BE must be wchar-aligned,\n UTF-32LE or UTF-32BE must be dchar-aligned, etc.)\n\n The input to this function MUST be a valid code point.\n\n Params:\n    c = the code point to be encoded\n\n Returns:\n    the number of ubytes written.\n         \n",
      "line" : 2153,
      "storageClass" : [
       "const",
       "abstract"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "comment" : "\n Decodes a single code point.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n The input to this function MUST be validly encoded.\n\n Params:\n    s = the array whose first code point is to be decoded\n         \n",
      "line" : 2166,
      "storageClass" : [
       "const",
       "abstract"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "comment" : "\n Decodes a single code point. The input does not have to be valid.\n\n This function removes one or more ubytes from the start of an array,\n and returns the decoded code point which those ubytes represent.\n\n This function will accept an invalidly encoded array as input.\n If an invalid sequence is found at the start of the string, this\n function will remove it, and return the value INVALID_SEQUENCE.\n\n Params:\n    s = the array whose first code point is to be decoded\n         \n",
      "line" : 2181,
      "storageClass" : [
       "const",
       "abstract"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "comment" : "\n Returns the sequence of ubytes to be used to represent\n any character which cannot be represented in the encoding scheme.\n\n Normally this will be a representation of some substitution\n character, such as U+FFFD or '?'.\n         \n",
      "line" : 2190,
      "storageClass" : [
       "const",
       "abstract",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()"
     },
     {
      "name" : "isValid",
      "kind" : "function",
      "comment" : "\n Returns true if the array is encoded correctly\n\n Params:\n    s = the array to be tested\n     \n",
      "line" : 2199,
      "deco" : "FAxhZb",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh"
       }
      ],
      "endline" : 2208
     },
     {
      "name" : "validLength",
      "kind" : "function",
      "comment" : "\n Returns the length of the longest possible substring, starting from\n the first element, which is validly encoded.\n\n Params:\n    s = the array to be tested\n     \n",
      "line" : 2217,
      "deco" : "FAxhZm",
      "originalType" : "size_t(const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh"
       }
      ],
      "endline" : 2227
     },
     {
      "name" : "sanitize",
      "kind" : "function",
      "comment" : "\n Sanitizes an array by replacing malformed ubyte sequences with valid\n ubyte sequences. The result is guaranteed to be valid for this\n encoding scheme.\n\n If the input array is already valid, this function returns the\n original, otherwise it constructs a new array by replacing all illegal\n sequences with the encoding scheme's replacement sequence.\n\n Params:\n    s = the string to be sanitized\n     \n",
      "line" : 2241,
      "deco" : "FAyhZAyh",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Ayh"
       }
      ],
      "endline" : 2278
     },
     {
      "name" : "firstSequence",
      "kind" : "function",
      "comment" : "\n Returns the length of the first encoded sequence.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the array to be sliced\n     \n",
      "line" : 2289,
      "deco" : "FAxhZm",
      "originalType" : "size_t(const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh"
       }
      ],
      "endline" : 2301,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2291,
       "deco" : "FZv",
       "endline" : 2291
      }
     },
     {
      "name" : "count",
      "kind" : "function",
      "comment" : "\n Returns the total number of code points encoded in a ubyte array.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n     \n",
      "line" : 2312,
      "deco" : "FAxhZm",
      "originalType" : "size_t(const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh"
       }
      ],
      "endline" : 2326,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2314,
       "deco" : "FZv",
       "endline" : 2314
      }
     },
     {
      "name" : "index",
      "kind" : "function",
      "comment" : "\n Returns the array index at which the (n+1)th code point begins.\n\n The input to this function MUST be validly encoded.\n This is enforced by the function's in-contract.\n\n Params:\n    s = the string to be counted\n     \n",
      "line" : 2337,
      "deco" : "FAxhmZl",
      "originalType" : "ptrdiff_t(const(ubyte)[] s, size_t n)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh"
       },
       {
        "name" : "n",
        "deco" : "m"
       }
      ],
      "endline" : 2348,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2339,
       "deco" : "FZv",
       "endline" : 2339
      }
     },
     {
      "name" : "supported",
      "kind" : "variable",
      "line" : 2350,
      "storageClass" : [
       "__gshared"
      ],
      "deco" : "HAyaAya"
     }
    ]
   },
   {
    "name" : "EncodingSchemeASCII",
    "kind" : "class",
    "comment" : "\n EncodingScheme to handle ASCII\n\n This scheme recognises the following names:\n                 \"ANSI_X3.4-1968\",\n                 \"ANSI_X3.4-1986\",\n                 \"ASCII\",\n                 \"IBM367\",\n                 \"ISO646-US\",\n                 \"ISO_646.irv:1991\",\n                 \"US-ASCII\",\n                 \"cp367\",\n                 \"csASCII\"\n                 \"iso-ir-6\",\n                 \"us\"\n \n",
    "line" : 2369,
    "base" : "EncodingScheme",
    "members" : [
     {
      "name" : "_sharedStaticCtor9",
      "kind" : "function",
      "line" : 2371,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2374
     },
     {
      "name" : "names",
      "kind" : "function",
      "line" : 2378,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()",
      "endline" : 2395,
      "overrides" : [
       "std.encoding.EncodingScheme.names"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2397,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2400,
      "overrides" : [
       "std.encoding.EncodingScheme.toString"
      ]
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 2402,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2405,
      "overrides" : [
       "std.encoding.EncodingScheme.canEncode"
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 2407,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2410,
      "overrides" : [
       "std.encoding.EncodingScheme.encodedLength"
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 2412,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 2416,
      "overrides" : [
       "std.encoding.EncodingScheme.encode"
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 2418,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2424,
      "overrides" : [
       "std.encoding.EncodingScheme.decode"
      ]
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "line" : 2426,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2432,
      "overrides" : [
       "std.encoding.EncodingScheme.safeDecode"
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 2434,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()",
      "endline" : 2437,
      "overrides" : [
       "std.encoding.EncodingScheme.replacementSequence"
      ]
     }
    ]
   },
   {
    "name" : "EncodingSchemeLatin1",
    "kind" : "class",
    "comment" : "\n EncodingScheme to handle Latin-1\n\n This scheme recognises the following names:\n                 \"CP819\",\n                 \"IBM819\",\n                 \"ISO-8859-1\",\n                 \"ISO_8859-1\",\n                 \"ISO_8859-1:1987\",\n                 \"csISOLatin1\",\n                 \"iso-ir-100\",\n                 \"l1\",\n                 \"latin1\"\n \n",
    "line" : 2455,
    "base" : "EncodingScheme",
    "members" : [
     {
      "name" : "_sharedStaticCtor10",
      "kind" : "function",
      "line" : 2457,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2460
     },
     {
      "name" : "names",
      "kind" : "function",
      "line" : 2464,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()",
      "endline" : 2479,
      "overrides" : [
       "std.encoding.EncodingScheme.names"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2481,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2484,
      "overrides" : [
       "std.encoding.EncodingScheme.toString"
      ]
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 2486,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2489,
      "overrides" : [
       "std.encoding.EncodingScheme.canEncode"
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 2491,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2494,
      "overrides" : [
       "std.encoding.EncodingScheme.encodedLength"
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 2496,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 2500,
      "overrides" : [
       "std.encoding.EncodingScheme.encode"
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 2502,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2508,
      "overrides" : [
       "std.encoding.EncodingScheme.decode"
      ]
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "line" : 2510,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2516,
      "overrides" : [
       "std.encoding.EncodingScheme.safeDecode"
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 2518,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()",
      "endline" : 2521,
      "overrides" : [
       "std.encoding.EncodingScheme.replacementSequence"
      ]
     }
    ]
   },
   {
    "name" : "EncodingSchemeWindows1252",
    "kind" : "class",
    "comment" : "\n EncodingScheme to handle Windows-1252\n\n This scheme recognises the following names:\n                 \"windows-1252\"\n \n",
    "line" : 2531,
    "base" : "EncodingScheme",
    "members" : [
     {
      "name" : "_sharedStaticCtor11",
      "kind" : "function",
      "line" : 2533,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2536
     },
     {
      "name" : "names",
      "kind" : "function",
      "line" : 2540,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()",
      "endline" : 2547,
      "overrides" : [
       "std.encoding.EncodingScheme.names"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2549,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2552,
      "overrides" : [
       "std.encoding.EncodingScheme.toString"
      ]
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 2554,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2557,
      "overrides" : [
       "std.encoding.EncodingScheme.canEncode"
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 2559,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2562,
      "overrides" : [
       "std.encoding.EncodingScheme.encodedLength"
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 2564,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 2568,
      "overrides" : [
       "std.encoding.EncodingScheme.encode"
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 2570,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2576,
      "overrides" : [
       "std.encoding.EncodingScheme.decode"
      ]
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "line" : 2578,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2584,
      "overrides" : [
       "std.encoding.EncodingScheme.safeDecode"
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 2586,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()",
      "endline" : 2589,
      "overrides" : [
       "std.encoding.EncodingScheme.replacementSequence"
      ]
     }
    ]
   },
   {
    "name" : "EncodingSchemeUtf8",
    "kind" : "class",
    "comment" : "\n EncodingScheme to handle UTF-8\n\n This scheme recognises the following names:\n                 \"UTF-8\"\n \n",
    "line" : 2599,
    "base" : "EncodingScheme",
    "members" : [
     {
      "name" : "_sharedStaticCtor12",
      "kind" : "function",
      "line" : 2601,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2604
     },
     {
      "name" : "names",
      "kind" : "function",
      "line" : 2608,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()",
      "endline" : 2615,
      "overrides" : [
       "std.encoding.EncodingScheme.names"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2617,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2620,
      "overrides" : [
       "std.encoding.EncodingScheme.toString"
      ]
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 2622,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2625,
      "overrides" : [
       "std.encoding.EncodingScheme.canEncode"
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 2627,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2630,
      "overrides" : [
       "std.encoding.EncodingScheme.encodedLength"
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 2632,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 2636,
      "overrides" : [
       "std.encoding.EncodingScheme.encode"
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 2638,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2644,
      "overrides" : [
       "std.encoding.EncodingScheme.decode"
      ]
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "line" : 2646,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2652,
      "overrides" : [
       "std.encoding.EncodingScheme.safeDecode"
      ]
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 2654,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()",
      "endline" : 2657,
      "overrides" : [
       "std.encoding.EncodingScheme.replacementSequence"
      ]
     }
    ]
   },
   {
    "name" : "EncodingSchemeUtf16Native",
    "kind" : "class",
    "comment" : "\n EncodingScheme to handle UTF-16 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-16LE\" (little-endian architecture only)\n                 \"UTF-16BE\" (big-endian architecture only)\n \n",
    "line" : 2668,
    "base" : "EncodingScheme",
    "members" : [
     {
      "name" : "_sharedStaticCtor13",
      "kind" : "function",
      "line" : 2670,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2673
     },
     {
      "name" : "NAME",
      "kind" : "variable",
      "line" : 2677,
      "storageClass" : [
       "const",
       "enum"
      ],
      "deco" : "xAya",
      "originalType" : "string",
      "init" : "\"UTF-16LE\""
     },
     {
      "name" : "names",
      "kind" : "function",
      "line" : 2680,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()",
      "endline" : 2683,
      "overrides" : [
       "std.encoding.EncodingScheme.names"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2685,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2688,
      "overrides" : [
       "std.encoding.EncodingScheme.toString"
      ]
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 2690,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2693,
      "overrides" : [
       "std.encoding.EncodingScheme.canEncode"
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 2695,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2698,
      "overrides" : [
       "std.encoding.EncodingScheme.encodedLength"
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 2700,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 2704,
      "overrides" : [
       "std.encoding.EncodingScheme.encode"
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 2706,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2717,
      "overrides" : [
       "std.encoding.EncodingScheme.decode"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2708,
       "type" : "void()",
       "endline" : 2708
      }
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "line" : 2719,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2730,
      "overrides" : [
       "std.encoding.EncodingScheme.safeDecode"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2721,
       "type" : "void()",
       "endline" : 2721
      }
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 2732,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()",
      "endline" : 2735,
      "overrides" : [
       "std.encoding.EncodingScheme.replacementSequence"
      ]
     }
    ]
   },
   {
    "name" : "EncodingSchemeUtf32Native",
    "kind" : "class",
    "comment" : "\n EncodingScheme to handle UTF-32 in native byte order\n\n This scheme recognises the following names:\n                 \"UTF-32LE\" (little-endian architecture only)\n                 \"UTF-32BE\" (big-endian architecture only)\n \n",
    "line" : 2746,
    "base" : "EncodingScheme",
    "members" : [
     {
      "name" : "_sharedStaticCtor14",
      "kind" : "function",
      "line" : 2748,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2751
     },
     {
      "name" : "NAME",
      "kind" : "variable",
      "line" : 2755,
      "storageClass" : [
       "const",
       "enum"
      ],
      "deco" : "xAya",
      "originalType" : "string",
      "init" : "\"UTF-32LE\""
     },
     {
      "name" : "names",
      "kind" : "function",
      "line" : 2758,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAAya",
      "originalType" : "string[]()",
      "endline" : 2761,
      "overrides" : [
       "std.encoding.EncodingScheme.names"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2763,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2766,
      "overrides" : [
       "std.encoding.EncodingScheme.toString"
      ]
     },
     {
      "name" : "canEncode",
      "kind" : "function",
      "line" : 2768,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZb",
      "originalType" : "bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2771,
      "overrides" : [
       "std.encoding.EncodingScheme.canEncode"
      ]
     },
     {
      "name" : "encodedLength",
      "kind" : "function",
      "line" : 2773,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwZm",
      "originalType" : "size_t(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2776,
      "overrides" : [
       "std.encoding.EncodingScheme.encodedLength"
      ]
     },
     {
      "name" : "encode",
      "kind" : "function",
      "line" : 2778,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFwAhZm",
      "originalType" : "size_t(dchar c, ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 2782,
      "overrides" : [
       "std.encoding.EncodingScheme.encode"
      ]
     },
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 2784,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2795,
      "overrides" : [
       "std.encoding.EncodingScheme.decode"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2786,
       "type" : "void()",
       "endline" : 2786
      }
     },
     {
      "name" : "safeDecode",
      "kind" : "function",
      "line" : 2797,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFKAxhZw",
      "originalType" : "dchar(ref const(ubyte)[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axh",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2808,
      "overrides" : [
       "std.encoding.EncodingScheme.safeDecode"
      ],
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 2799,
       "type" : "void()",
       "endline" : 2799
      }
     },
     {
      "name" : "replacementSequence",
      "kind" : "function",
      "line" : 2810,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZAyh",
      "originalType" : "immutable(ubyte)[]()",
      "endline" : 2813,
      "overrides" : [
       "std.encoding.EncodingScheme.replacementSequence"
      ]
     }
    ]
   }
  ]
 },
 {
  "name" : "std.exception",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/exception.d",
  "comment" : "\n    This module defines functions related to exceptions and general error\n    handling. It also defines functions intended to aid in unit testing.\n\n    Synopsis of some of std.exception's functions:\n--------------------\nstring synopsis()\n{\n   FILE* f = enforce(fopen(\"some/file\"));\n   // f is not null from here on\n   FILE* g = enforceEx!WriteException(fopen(\"some/other/file\", \"w\"));\n   // g is not null from here on\n\n   Exception e = collectException(write(g, readln(f)));\n   if (e)\n   {\n       ... an exception occurred...\n       ... We have the exception to play around with...\n   }\n\n   string msg = collectExceptionMsg(write(g, readln(f)));\n   if (msg)\n   {\n       ... an exception occurred...\n       ... We have the message from the exception but not the exception...\n   }\n\n   char[] line;\n   enforce(readln(f, line));\n   return assumeUnique(line);\n}\n--------------------\n\n    Macros:\n        WIKI = Phobos/StdException\n\n    Copyright: Copyright Andrei Alexandrescu 2008-, Jonathan M Davis 2011-.\n    License:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Authors:   $(WEB erdani.org, Andrei Alexandrescu) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_exception.d)\n\n \n",
  "members" : [
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.c.string",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\n    Asserts that the given expression does $(I not) throw the given type\n    of $(D Throwable). If a $(D Throwable) of the given type is thrown,\n    it is caught and does not escape assertNotThrown. Rather, an\n    $(D AssertError) is thrown. However, any other $(D Throwable)s will escape.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n                     If msg is empty, and the thrown exception has a\n                     non-empty msg field, the exception's msg field\n                     will be output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is thrown.\n\n    Examples:\n--------------------\nassertNotThrown!StringException(enforceEx!StringException(true, \"Error!\"));\n\n//Exception is the default.\nassertNotThrown(enforceEx!StringException(true, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertNotThrown!StringException(\n           enforceEx!StringException(false, \"Error!\"))) ==\n       `assertNotThrown failed: StringException was thrown: Error!`);\n--------------------\n  \n",
    "line" : 79,
    "name" : "assertNotThrown",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "deco" : "C6object9Throwable",
      "default" : "Exception"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assertNotThrown",
      "kind" : "function",
      "comment" : "\n    Asserts that the given expression does $(I not) throw the given type\n    of $(D Throwable). If a $(D Throwable) of the given type is thrown,\n    it is caught and does not escape assertNotThrown. Rather, an\n    $(D AssertError) is thrown. However, any other $(D Throwable)s will escape.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n                     If msg is empty, and the thrown exception has a\n                     non-empty msg field, the exception's msg field\n                     will be output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is thrown.\n\n    Examples:\n--------------------\nassertNotThrown!StringException(enforceEx!StringException(true, \"Error!\"));\n\n//Exception is the default.\nassertNotThrown(enforceEx!StringException(true, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertNotThrown!StringException(\n           enforceEx!StringException(false, \"Error!\"))) ==\n       `assertNotThrown failed: StringException was thrown: Error!`);\n--------------------\n  \n",
      "line" : 79,
      "type" : "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "E",
        "storageClass" : [
         "lazy"
        ]
       },
       {
        "name" : "msg",
        "type" : "string",
        "default" : "null"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 98
     }
    ]
   },
   {
    "name" : "__unittestL101_1030",
    "kind" : "function",
    "line" : 101,
    "endline" : 125
   },
   {
    "name" : "__unittestL125_1031",
    "kind" : "function",
    "line" : 125,
    "endline" : 234
   },
   {
    "kind" : "template",
    "comment" : "\n    Asserts that the given expression throws the given type of $(D Throwable).\n    The $(D Throwable) is caught and does not escape assertThrown. However,\n    any other $(D Throwable)s $(I will) escape, and if no $(D Throwable)\n    of the given type is thrown, then an $(D AssertError) is thrown.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is not thrown.\n\n    Examples:\n--------------------\nassertThrown!StringException(enforceEx!StringException(false, \"Error!\"));\n\n//Exception is the default.\nassertThrown(enforceEx!StringException(false, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertThrown!StringException(\n           enforceEx!StringException(true, \"Error!\"))) ==\n       `assertThrown failed: No StringException was thrown.`);\n--------------------\n  \n",
    "line" : 234,
    "name" : "assertThrown",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "deco" : "C6object9Throwable",
      "default" : "Exception"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assertThrown",
      "kind" : "function",
      "comment" : "\n    Asserts that the given expression throws the given type of $(D Throwable).\n    The $(D Throwable) is caught and does not escape assertThrown. However,\n    any other $(D Throwable)s $(I will) escape, and if no $(D Throwable)\n    of the given type is thrown, then an $(D AssertError) is thrown.\n\n    Params:\n        T          = The $(D Throwable) to test for.\n        expression = The expression to test.\n        msg        = Optional message to output on test failure.\n\n    Throws:\n        $(D AssertError) if the given $(D Throwable) is not thrown.\n\n    Examples:\n--------------------\nassertThrown!StringException(enforceEx!StringException(false, \"Error!\"));\n\n//Exception is the default.\nassertThrown(enforceEx!StringException(false, \"Error!\"));\n\nassert(collectExceptionMsg!AssertError(assertThrown!StringException(\n           enforceEx!StringException(true, \"Error!\"))) ==\n       `assertThrown failed: No StringException was thrown.`);\n--------------------\n  \n",
      "line" : 234,
      "type" : "void(lazy E expression, string msg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "E",
        "storageClass" : [
         "lazy"
        ]
       },
       {
        "name" : "msg",
        "type" : "string",
        "default" : "null"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 257
     }
    ]
   },
   {
    "name" : "__unittestL260_1032",
    "kind" : "function",
    "line" : 260,
    "endline" : 272
   },
   {
    "name" : "__unittestL272_1033",
    "kind" : "function",
    "line" : 272,
    "endline" : 371
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new Exception(msg)) is thrown.\n\n    Note:\n        $(D enforce) is used to throw exceptions and is therefore intended to\n        aid in error handling. It is $(I not) intended for verifying the logic\n        of your program. That is what $(D assert) is for. Also, do not use\n        $(D enforce) inside of contracts (i.e. inside of $(D in) and $(D out)\n        blocks and $(D invariant)s), because they will be compiled out when\n        compiling with $(I -release). Use $(D assert) in contracts.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, \"Expected a non-empty line.\");\n--------------------\n \n",
    "line" : 371,
    "name" : "enforce",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "enforce",
      "kind" : "function",
      "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new Exception(msg)) is thrown.\n\n    Note:\n        $(D enforce) is used to throw exceptions and is therefore intended to\n        aid in error handling. It is $(I not) intended for verifying the logic\n        of your program. That is what $(D assert) is for. Also, do not use\n        $(D enforce) inside of contracts (i.e. inside of $(D in) and $(D out)\n        blocks and $(D invariant)s), because they will be compiled out when\n        compiling with $(I -release). Use $(D assert) in contracts.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, \"Expected a non-empty line.\");\n--------------------\n \n",
      "line" : 371,
      "type" : "T(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "msg",
        "type" : "const(char)[]",
        "storageClass" : [
         "lazy"
        ],
        "default" : "null"
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 375
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   $(RED Scheduled for deprecation in January 2013. If passing the file or line\n         number explicitly, please use the version of enforce which takes them as\n         function arguments. Taking them as template arguments causes\n         unnecessary template bloat.)\n \n",
    "line" : 383,
    "name" : "enforce",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "file",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "line",
      "kind" : "value",
      "deco" : "m",
      "defaultValue" : "__LINE__"
     }
    ],
    "members" : [
     {
      "name" : "enforce",
      "kind" : "function",
      "comment" : "\n   $(RED Scheduled for deprecation in January 2013. If passing the file or line\n         number explicitly, please use the version of enforce which takes them as\n         function arguments. Taking them as template arguments causes\n         unnecessary template bloat.)\n \n",
      "line" : 383,
      "type" : "T(T value, lazy const(char)[] msg = null)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "msg",
        "type" : "const(char)[]",
        "storageClass" : [
         "lazy"
        ],
        "default" : "null"
       }
      ],
      "endline" : 388
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, the given\n    delegate is called.\n\n    The whole safety and purity are inferred from $(D Dg)'s safety and purity.\n \n",
    "line" : 396,
    "name" : "enforce",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Dg",
      "kind" : "type"
     },
     {
      "name" : "file",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "__FILE__"
     },
     {
      "name" : "line",
      "kind" : "value",
      "deco" : "m",
      "defaultValue" : "__LINE__"
     }
    ],
    "members" : [
     {
      "name" : "enforce",
      "kind" : "function",
      "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, the given\n    delegate is called.\n\n    The whole safety and purity are inferred from $(D Dg)'s safety and purity.\n \n",
      "line" : 396,
      "type" : "T(T value, scope Dg dg)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "dg",
        "type" : "Dg",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 402
     }
    ]
   },
   {
    "name" : "bailOut",
    "kind" : "function",
    "protection" : "private",
    "line" : 404,
    "deco" : "FNaNfAyamxAaZv",
    "originalType" : "pure @safe void(string file, size_t line, in char[] msg)",
    "parameters" : [
     {
      "name" : "file",
      "deco" : "Aya"
     },
     {
      "name" : "line",
      "deco" : "m"
     },
     {
      "name" : "msg",
      "deco" : "xAa"
     }
    ],
    "endline" : 407
   },
   {
    "name" : "__unittestL409_1034",
    "kind" : "function",
    "line" : 409,
    "endline" : 427
   },
   {
    "name" : "__unittestL427_1035",
    "kind" : "function",
    "line" : 427,
    "endline" : 462
   },
   {
    "name" : "__unittestL462_1037",
    "kind" : "function",
    "line" : 462,
    "endline" : 507
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, $(D ex) is thrown.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, new IOException); // expect a non-empty line\n--------------------\n \n",
    "line" : 507,
    "name" : "enforce",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "enforce",
      "kind" : "function",
      "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise, $(D ex) is thrown.\n\n   Example:\n--------------------\nauto f = enforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length, new IOException); // expect a non-empty line\n--------------------\n \n",
      "line" : 507,
      "type" : "T(T value, lazy Throwable ex)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "ex",
        "type" : "Throwable",
        "storageClass" : [
         "lazy"
        ]
       }
      ],
      "endline" : 511
     }
    ]
   },
   {
    "name" : "__unittestL513_1038",
    "kind" : "function",
    "line" : 513,
    "endline" : 531
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new ErrnoException(msg)) is thrown. $(D ErrnoException) assumes that the\n    last operation set $(D errno) to an error code.\n\n   Example:\n--------------------\nauto f = errnoEnforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length); // expect a non-empty line\n--------------------\n \n",
    "line" : 531,
    "name" : "errnoEnforce",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "file",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "__FILE__"
     },
     {
      "name" : "line",
      "kind" : "value",
      "deco" : "m",
      "defaultValue" : "__LINE__"
     }
    ],
    "members" : [
     {
      "name" : "errnoEnforce",
      "kind" : "function",
      "comment" : "\n    If $(D !!value) is true, $(D value) is returned. Otherwise,\n    $(D new ErrnoException(msg)) is thrown. $(D ErrnoException) assumes that the\n    last operation set $(D errno) to an error code.\n\n   Example:\n--------------------\nauto f = errnoEnforce(fopen(\"data.txt\"));\nauto line = readln(f);\nenforce(line.length); // expect a non-empty line\n--------------------\n \n",
      "line" : 531,
      "type" : "T(T value, lazy string msg = null)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "msg",
        "type" : "string",
        "storageClass" : [
         "lazy"
        ],
        "default" : "null"
       }
      ],
      "endline" : 536
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D !!value) is $(D true), $(D value) is returned. Otherwise,\n    $(D new E(msg, file, line)) is thrown. Or if $(D E) doesn't take a message\n    and can be constructed with $(D new E(file, line)), then\n    $(D new E(file, line)) will be thrown.\n\n   Example:\n--------------------\n auto f = enforceEx!FileMissingException(fopen(\"data.txt\"));\n auto line = readln(f);\n enforceEx!DataCorruptionException(line.length);\n--------------------\n \n",
    "line" : 552,
    "name" : "enforceEx",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 555,
      "name" : "enforceEx",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enforceEx",
        "kind" : "function",
        "line" : 555,
        "type" : "T(T value, lazy string msg = \"\", string file = __FILE__, size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         },
         {
          "name" : "msg",
          "type" : "string",
          "storageClass" : [
           "lazy"
          ],
          "default" : "\"\""
         },
         {
          "name" : "file",
          "type" : "string",
          "default" : "__FILE__"
         },
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 559
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 562,
    "name" : "enforceEx",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 565,
      "name" : "enforceEx",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enforceEx",
        "kind" : "function",
        "line" : 565,
        "type" : "T(T value, string file = __FILE__, size_t line = __LINE__)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         },
         {
          "name" : "file",
          "type" : "string",
          "default" : "__FILE__"
         },
         {
          "name" : "line",
          "type" : "size_t",
          "default" : "__LINE__"
         }
        ],
        "endline" : 569
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 574,
    "name" : "enforceEx",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 577,
      "name" : "enforceEx",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enforceEx",
        "kind" : "function",
        "line" : 577,
        "type" : "T(T value, lazy string msg = \"\")",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         },
         {
          "name" : "msg",
          "type" : "string",
          "storageClass" : [
           "lazy"
          ],
          "default" : "\"\""
         }
        ],
        "endline" : 581
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL584_1039",
    "kind" : "function",
    "line" : 584,
    "endline" : 607
   },
   {
    "name" : "__unittestL607_1040",
    "kind" : "function",
    "line" : 607,
    "endline" : 639
   },
   {
    "kind" : "template",
    "comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned and $(D result) is\n    set to the result of the expression.\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n        result     = The result of the expression if no exception is thrown.\n\n    Example:\n--------------------\nint[] a = new int[3];\nint b;\nassert(collectException(a[4], b));\n--------------------\n",
    "line" : 639,
    "name" : "collectException",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "default" : "Exception"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "collectException",
      "kind" : "function",
      "comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned and $(D result) is\n    set to the result of the expression.\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n        result     = The result of the expression if no exception is thrown.\n\n    Example:\n--------------------\nint[] a = new int[3];\nint b;\nassert(collectException(a[4], b));\n--------------------\n",
      "line" : 639,
      "type" : "T(lazy E expression, ref E result)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "E",
        "storageClass" : [
         "lazy"
        ]
       },
       {
        "name" : "result",
        "type" : "E",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 650
     }
    ]
   },
   {
    "name" : "__unittestL652_1041",
    "kind" : "function",
    "line" : 652,
    "endline" : 676
   },
   {
    "kind" : "template",
    "comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned. $(D E) can be\n    $(D void).\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n",
    "line" : 676,
    "name" : "collectException",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "deco" : "C6object9Throwable",
      "default" : "Exception"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "collectException",
      "kind" : "function",
      "comment" : "\n    Catches and returns the exception thrown from the given expression.\n    If no exception is thrown, then null is returned. $(D E) can be\n    $(D void).\n\n    Note that while $(D collectException) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectException) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n",
      "line" : 676,
      "type" : "T(lazy E expression)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "E",
        "storageClass" : [
         "lazy"
        ]
       }
      ],
      "endline" : 687
     }
    ]
   },
   {
    "name" : "__unittestL689_1042",
    "kind" : "function",
    "line" : 689,
    "endline" : 726
   },
   {
    "kind" : "template",
    "comment" : "\n    Catches the exception thrown from the given expression and returns the\n    msg property of that exception. If no exception is thrown, then null is\n    returned. $(D E) can be $(D void).\n\n    If an exception is thrown but it has an empty message, then\n    $(D emptyExceptionMsg) is returned.\n\n    Note that while $(D collectExceptionMsg) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectExceptionMsg) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n\n    Examples:\n--------------------\nvoid throwFunc() {throw new Exception(\"My Message.\");}\nassert(collectExceptionMsg(throwFunc()) == \"My Message.\");\n\nvoid nothrowFunc() {}\nassert(collectExceptionMsg(nothrowFunc()) is null);\n\nvoid throwEmptyFunc() {throw new Exception(\"\");}\nassert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);\n--------------------\n",
    "line" : 726,
    "name" : "collectExceptionMsg",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "default" : "Exception"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "collectExceptionMsg",
      "kind" : "function",
      "comment" : "\n    Catches the exception thrown from the given expression and returns the\n    msg property of that exception. If no exception is thrown, then null is\n    returned. $(D E) can be $(D void).\n\n    If an exception is thrown but it has an empty message, then\n    $(D emptyExceptionMsg) is returned.\n\n    Note that while $(D collectExceptionMsg) $(I can) be used to collect any\n    $(D Throwable) and not just $(D Exception)s, it is generally ill-advised to\n    catch anything that is neither an $(D Exception) nor a type derived from\n    $(D Exception). So, do not use $(D collectExceptionMsg) to collect\n    non-$(D Exception)s unless you're sure that that's what you really want to\n    do.\n\n    Params:\n        T          = The type of exception to catch.\n        expression = The expression which may throw an exception.\n\n    Examples:\n--------------------\nvoid throwFunc() {throw new Exception(\"My Message.\");}\nassert(collectExceptionMsg(throwFunc()) == \"My Message.\");\n\nvoid nothrowFunc() {}\nassert(collectExceptionMsg(nothrowFunc()) is null);\n\nvoid throwEmptyFunc() {throw new Exception(\"\");}\nassert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);\n--------------------\n",
      "line" : 726,
      "type" : "string(lazy E expression)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "E",
        "storageClass" : [
         "lazy"
        ]
       }
      ],
      "endline" : 736
     }
    ]
   },
   {
    "name" : "__unittestL739_1043",
    "kind" : "function",
    "line" : 739,
    "endline" : 755
   },
   {
    "name" : "emptyExceptionMsg",
    "kind" : "variable",
    "comment" : "\n    Value that collectExceptionMsg returns when it catches an exception\n    with an empty exception message.\n \n",
    "line" : 755,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"<Empty Exception Message>\""
   },
   {
    "kind" : "template",
    "comment" : "\n Casts a mutable array to an immutable array in an idiomatic\n manner. Technically, $(D assumeUnique) just inserts a cast,\n but its name documents assumptions on the part of the\n caller. $(D assumeUnique(arr)) should only be called when\n there are no more active mutable aliases to elements of $(D\n arr). To strenghten this assumption, $(D assumeUnique(arr))\n also clears $(D arr) before returning. Essentially $(D\n assumeUnique(arr)) indicates commitment from the caller that there\n is no more mutable access to any of $(D arr)'s elements\n (transitively), and that all future accesses will be done through\n the immutable array returned by $(D assumeUnique).\n\n Typically, $(D assumeUnique) is used to return arrays from\n functions that have allocated and built them.\n\n Example:\n\n ----\n string letters()\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(result);\n }\n ----\n\n The use in the example above is correct because $(D result)\n was private to $(D letters) and is unaccessible in writing\n after the function returns. The following example shows an\n incorrect use of $(D assumeUnique).\n\n Bad:\n\n ----\n private char[] buffer;\n string letters(char first, char last)\n {\n   if (first >= last) return null; // fine\n   auto sneaky = buffer;\n   sneaky.length = last - first + 1;\n   foreach (i, ref e; sneaky)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(sneaky); // BAD\n }\n ----\n\n The example above wreaks havoc on client code because it is\n modifying arrays that callers considered immutable. To obtain an\n immutable array from the writable array $(D buffer), replace\n the last line with:\n ----\n return to!(string)(sneaky); // not that sneaky anymore\n ----\n\n The call will duplicate the array appropriately.\n\n Checking for uniqueness during compilation is possible in certain\n cases (see the $(D unique) and $(D lent) keywords in\n the $(WEB archjava.fluid.cs.cmu.edu/papers/oopsla02.pdf, ArchJava)\n language), but complicates the language considerably. The downside\n of $(D assumeUnique)'s convention-based usage is that at this\n time there is no formal checking of the correctness of the\n assumption; on the upside, the idiomatic use of $(D\n assumeUnique) is simple and rare enough to be tolerable.\n\n \n",
    "line" : 829,
    "name" : "assumeUnique",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assumeUnique",
      "kind" : "function",
      "comment" : "\n Casts a mutable array to an immutable array in an idiomatic\n manner. Technically, $(D assumeUnique) just inserts a cast,\n but its name documents assumptions on the part of the\n caller. $(D assumeUnique(arr)) should only be called when\n there are no more active mutable aliases to elements of $(D\n arr). To strenghten this assumption, $(D assumeUnique(arr))\n also clears $(D arr) before returning. Essentially $(D\n assumeUnique(arr)) indicates commitment from the caller that there\n is no more mutable access to any of $(D arr)'s elements\n (transitively), and that all future accesses will be done through\n the immutable array returned by $(D assumeUnique).\n\n Typically, $(D assumeUnique) is used to return arrays from\n functions that have allocated and built them.\n\n Example:\n\n ----\n string letters()\n {\n   char[] result = new char['z' - 'a' + 1];\n   foreach (i, ref e; result)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(result);\n }\n ----\n\n The use in the example above is correct because $(D result)\n was private to $(D letters) and is unaccessible in writing\n after the function returns. The following example shows an\n incorrect use of $(D assumeUnique).\n\n Bad:\n\n ----\n private char[] buffer;\n string letters(char first, char last)\n {\n   if (first >= last) return null; // fine\n   auto sneaky = buffer;\n   sneaky.length = last - first + 1;\n   foreach (i, ref e; sneaky)\n   {\n     e = 'a' + i;\n   }\n   return assumeUnique(sneaky); // BAD\n }\n ----\n\n The example above wreaks havoc on client code because it is\n modifying arrays that callers considered immutable. To obtain an\n immutable array from the writable array $(D buffer), replace\n the last line with:\n ----\n return to!(string)(sneaky); // not that sneaky anymore\n ----\n\n The call will duplicate the array appropriately.\n\n Checking for uniqueness during compilation is possible in certain\n cases (see the $(D unique) and $(D lent) keywords in\n the $(WEB archjava.fluid.cs.cmu.edu/papers/oopsla02.pdf, ArchJava)\n language), but complicates the language considerably. The downside\n of $(D assumeUnique)'s convention-based usage is that at this\n time there is no formal checking of the correctness of the\n assumption; on the upside, the idiomatic use of $(D\n assumeUnique) is simple and rare enough to be tolerable.\n\n \n",
      "line" : 829,
      "type" : "pure nothrow immutable(T)[](T[] array)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[]"
       }
      ],
      "endline" : 832
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 834,
    "name" : "assumeUnique",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assumeUnique",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 834,
      "type" : "pure nothrow immutable(T)[](ref T[] array)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 839
     }
    ]
   },
   {
    "name" : "__unittestL841_1044",
    "kind" : "function",
    "line" : 841,
    "endline" : 848
   },
   {
    "kind" : "template",
    "line" : 848,
    "name" : "assumeUnique",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assumeUnique",
      "kind" : "function",
      "line" : 848,
      "type" : "pure nothrow immutable(T[U])(ref T[U] array)",
      "parameters" : [
       {
        "name" : "array",
        "type" : "T[U]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 853
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D source)'s representation embeds a pointer\nthat points to $(D target)'s representation or somewhere inside\nit.\n\nNote that evaluating $(D pointsTo(x, x)) checks whether $(D x) has\ninternal pointers. This should only be done as an assertive test,\nas the language is free to assume objects don't have internal pointers\n(TDPL 7.1.3.5).\n",
    "line" : 873,
    "name" : "pointsTo",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Tdummy",
      "kind" : "type",
      "defaultDeco" : "v"
     }
    ],
    "members" : [
     {
      "name" : "pointsTo",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if $(D source)'s representation embeds a pointer\nthat points to $(D target)'s representation or somewhere inside\nit.\n\nNote that evaluating $(D pointsTo(x, x)) checks whether $(D x) has\ninternal pointers. This should only be done as an assertive test,\nas the language is free to assume objects don't have internal pointers\n(TDPL 7.1.3.5).\n",
      "line" : 873,
      "type" : "pure nothrow @trusted bool(auto ref const S source, auto ref const T target)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "S",
        "storageClass" : [
         "auto",
         "const",
         "ref"
        ]
       },
       {
        "name" : "target",
        "type" : "T",
        "storageClass" : [
         "auto",
         "const",
         "ref"
        ]
       }
      ],
      "endline" : 903
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 905,
    "name" : "pointsTo",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pointsTo",
      "kind" : "function",
      "line" : 905,
      "type" : "pure nothrow @trusted bool(ref const shared S source, ref const shared T target)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "S",
        "storageClass" : [
         "const",
         "shared",
         "ref"
        ]
       },
       {
        "name" : "target",
        "type" : "T",
        "storageClass" : [
         "const",
         "shared",
         "ref"
        ]
       }
      ],
      "endline" : 908
     }
    ]
   },
   {
    "name" : "__unittestL909_1046",
    "kind" : "function",
    "line" : 909,
    "endline" : 960
   },
   {
    "name" : "__unittestL960_1047",
    "kind" : "function",
    "line" : 960,
    "endline" : 1011
   },
   {
    "name" : "ErrnoException",
    "kind" : "class",
    "comment" : "\n Thrown if errors that set $(D errno) occur.\n \n",
    "line" : 1011,
    "base" : "Exception",
    "members" : [
     {
      "name" : "errno",
      "kind" : "variable",
      "line" : 1013,
      "deco" : "k",
      "offset" : 72
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1014,
      "deco" : "FAyaAyamZC3std9exception14ErrnoException",
      "originalType" : "(string msg, string file = null, size_t line = 0)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "null"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "0LU"
       }
      ],
      "endline" : 1027
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1032,
    "name" : "structuralCast",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "structuralCast",
      "kind" : "function",
      "line" : 1032,
      "type" : "Target(Source obj)",
      "parameters" : [
       {
        "name" : "obj",
        "type" : "Source"
       }
      ],
      "endline" : 1039
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1042,
    "name" : "structuralCast",
    "parameters" : [
     {
      "name" : "Target",
      "kind" : "type"
     },
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "structuralCast",
      "kind" : "function",
      "line" : 1042,
      "type" : "Target(Source obj)",
      "parameters" : [
       {
        "name" : "obj",
        "type" : "Source"
       }
      ],
      "endline" : 1045
     }
    ]
   },
   {
    "name" : "__unittestL1047_1048",
    "kind" : "function",
    "line" : 1047,
    "endline" : 1107
   },
   {
    "kind" : "template",
    "line" : 1107,
    "name" : "structurallyCompatible",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "structurallyCompatible",
      "kind" : "variable",
      "line" : 1112,
      "storageClass" : [
       "enum"
      ],
      "init" : "FieldTypeTuple!(S).length >= FieldTypeTuple!(T).length && is(FieldTypeTuple!(S)[0 .. FieldTypeTuple!(T).length] == FieldTypeTuple!(T))"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1115,
    "name" : "structurallyCompatible",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "structurallyCompatible",
      "kind" : "variable",
      "line" : 1119,
      "storageClass" : [
       "enum"
      ],
      "init" : ".structurallyCompatible!(ElementType!(S), ElementType!(T)) && .structurallyCompatible!(ElementType!(T), ElementType!(S))"
     }
    ]
   },
   {
    "name" : "__unittestL1122_1049",
    "kind" : "function",
    "line" : 1122,
    "endline" : 1168
   },
   {
    "name" : "__unittestL1168_1050",
    "kind" : "function",
    "line" : 1168,
    "endline" : 1186
   },
   {
    "name" : "__unittestL1186_1051",
    "kind" : "function",
    "line" : 1186,
    "endline" : 1272
   },
   {
    "kind" : "template",
    "comment" : "\n    ML-style functional exception handling. Runs the supplied expression and\n    returns its result. If the expression throws a $(D Throwable), runs the\n    supplied error handler instead and return its result. The error handler's\n    type must be the same as the expression's type.\n\n    Params:\n        E            = The type of $(D Throwable)s to catch. Defaults to ${D Exception}\n        T            = The return type of the expression and the error handler.\n        expression   = The expression to run and return its result.\n        errorHandler = The handler to run if the expression throwed.\n\n    Examples:\n--------------------\n    //Revert to a default value upon an error:\n    assert(\"x\".to!int().ifThrown(0) == 0);\n--------------------\n\n    You can also chain multiple calls to ifThrown, each capturing errors from the\n    entire preceding expression.\n\n    Example:\n--------------------\n    //Chaining multiple calls to ifThrown to attempt multiple things in a row:\n    string s=\"true\";\n    assert(s.to!int().\n            ifThrown(cast(int)s.to!double()).\n            ifThrown(cast(int)s.to!bool())\n            == 1);\n\n    //Respond differently to different types of errors\n    assert(enforce(\"x\".to!int() < 1).to!string()\n            .ifThrown!ConvException(\"not a number\")\n            .ifThrown!Exception(\"number too small\")\n            == \"not a number\");\n--------------------\n\n    The expression and the errorHandler must have a common type they can both\n    be implicitly casted to, and that type will be the type of the compound\n    expression.\n\n    Examples:\n--------------------\n    //null and new Object have a common type(Object).\n    static assert(is(typeof(null.ifThrown(new Object())) == Object));\n    static assert(is(typeof((new Object()).ifThrown(null)) == Object));\n\n    //1 and new Object do not have a common type.\n    static assert(!__traits(compiles, 1.ifThrown(new Object())));\n    static assert(!__traits(compiles, (new Object()).ifThrown(1)));\n--------------------\n\n    If you need to use the actual thrown expection, you can use a delegate.\n    Example:\n--------------------\n    //Use a lambda to get the thrown object.\n    assert(\"%s\".format().ifThrown!Exception(e => e.classinfo.name) == \"std.format.FormatException\");\n--------------------\n    \n",
    "line" : 1272,
    "name" : "ifThrown",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type",
      "deco" : "C6object9Throwable",
      "default" : "Exception"
     },
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ifThrown",
      "kind" : "function",
      "comment" : "\n    ML-style functional exception handling. Runs the supplied expression and\n    returns its result. If the expression throws a $(D Throwable), runs the\n    supplied error handler instead and return its result. The error handler's\n    type must be the same as the expression's type.\n\n    Params:\n        E            = The type of $(D Throwable)s to catch. Defaults to ${D Exception}\n        T            = The return type of the expression and the error handler.\n        expression   = The expression to run and return its result.\n        errorHandler = The handler to run if the expression throwed.\n\n    Examples:\n--------------------\n    //Revert to a default value upon an error:\n    assert(\"x\".to!int().ifThrown(0) == 0);\n--------------------\n\n    You can also chain multiple calls to ifThrown, each capturing errors from the\n    entire preceding expression.\n\n    Example:\n--------------------\n    //Chaining multiple calls to ifThrown to attempt multiple things in a row:\n    string s=\"true\";\n    assert(s.to!int().\n            ifThrown(cast(int)s.to!double()).\n            ifThrown(cast(int)s.to!bool())\n            == 1);\n\n    //Respond differently to different types of errors\n    assert(enforce(\"x\".to!int() < 1).to!string()\n            .ifThrown!ConvException(\"not a number\")\n            .ifThrown!Exception(\"number too small\")\n            == \"not a number\");\n--------------------\n\n    The expression and the errorHandler must have a common type they can both\n    be implicitly casted to, and that type will be the type of the compound\n    expression.\n\n    Examples:\n--------------------\n    //null and new Object have a common type(Object).\n    static assert(is(typeof(null.ifThrown(new Object())) == Object));\n    static assert(is(typeof((new Object()).ifThrown(null)) == Object));\n\n    //1 and new Object do not have a common type.\n    static assert(!__traits(compiles, 1.ifThrown(new Object())));\n    static assert(!__traits(compiles, (new Object()).ifThrown(1)));\n--------------------\n\n    If you need to use the actual thrown expection, you can use a delegate.\n    Example:\n--------------------\n    //Use a lambda to get the thrown object.\n    assert(\"%s\".format().ifThrown!Exception(e => e.classinfo.name) == \"std.format.FormatException\");\n--------------------\n    \n",
      "line" : 1272,
      "type" : "CommonType!(T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "T1",
        "storageClass" : [
         "scope",
         "lazy"
        ]
       },
       {
        "name" : "errorHandler",
        "type" : "T2",
        "storageClass" : [
         "scope",
         "lazy"
        ]
       }
      ],
      "endline" : 1284
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 1288,
    "name" : "ifThrown",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type",
      "deco" : "C6object9Throwable"
     },
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ifThrown",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 1288,
      "type" : "CommonType!(T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "T1",
        "storageClass" : [
         "scope",
         "lazy"
        ]
       },
       {
        "name" : "errorHandler",
        "type" : "T2 delegate(E)",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 1300
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 1304,
    "name" : "ifThrown",
    "parameters" : [
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ifThrown",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 1304,
      "type" : "CommonType!(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler)",
      "parameters" : [
       {
        "name" : "expression",
        "type" : "T1",
        "storageClass" : [
         "scope",
         "lazy"
        ]
       },
       {
        "name" : "errorHandler",
        "type" : "T2 delegate(Exception)",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 1316
     }
    ]
   },
   {
    "name" : "__unittestL1319_1054",
    "kind" : "function",
    "line" : 1319,
    "endline" : 1349
   },
   {
    "name" : "__unittestL1349_1075",
    "kind" : "function",
    "line" : 1349,
    "endline" : 1382
   }
  ]
 },
 {
  "name" : "std.file",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/file.d",
  "comment" : "\nUtilities for manipulating files and scanning directories. Functions\nin this module handle files as a unit, e.g., read or write one _file\nat a time. For opening files and manipulating them via handles refer\nto module $(LINK2 std_stdio.html,$(D std.stdio)).\n\nMacros:\nWIKI = Phobos/StdFile\n\nCopyright: Copyright Digital Mars 2007 - 2011.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Jonathan M Davis\nSource:    $(PHOBOSSRC std/_file.d)\n \n",
  "members" : [
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdio",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.datetime",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.path",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.process",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.dirent",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.fcntl",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.stat",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.time",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.utime",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "struct_stat64",
    "kind" : "alias",
    "line" : 79,
    "storageClass" : [
     "deprecated"
    ],
    "deco" : "S4core3sys5posix3sys4stat6stat_t"
   },
   {
    "name" : "FileException",
    "kind" : "class",
    "comment" : "\n    Exception thrown for file I/O errors.\n \n",
    "line" : 87,
    "base" : "Exception",
    "members" : [
     {
      "name" : "errno",
      "kind" : "variable",
      "comment" : "\n        OS error code.\n     \n",
      "line" : 92,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yk",
      "originalType" : "uint",
      "offset" : 72
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Constructor which takes an error message.\n\n        Params:\n            name = Name of file for which the error occurred.\n            msg  = Message describing the error.\n            file = The file where the error occurred.\n            line = The line where the error occurred.\n     \n",
      "line" : 103,
      "deco" : "FxAaxAaAyamZC3std4file13FileException",
      "originalType" : "(in char[] name, in char[] msg, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "xAa"
       },
       {
        "name" : "msg",
        "deco" : "xAa"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 111
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Constructor which takes the error number ($(LUCKY GetLastError)\n        in Windows, $(D_PARAM errno) in Posix).\n\n        Params:\n            name = Name of file for which the error occurred.\n            msg  = Message describing the error.\n            file = The file where the error occurred.\n            line = The line where the error occurred.\n     \n",
      "line" : 131,
      "deco" : "FxAakAyamZC3std4file13FileException",
      "originalType" : "(in char[] name, uint errno = .errno, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "xAa"
       },
       {
        "name" : "errno",
        "deco" : "k",
        "default" : "cast(uint)errno()"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 139
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 142,
    "name" : "cenforce",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cenforce",
      "kind" : "function",
      "line" : 142,
      "type" : "T(T condition, lazy const(char)[] name, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "condition",
        "type" : "T"
       },
       {
        "name" : "name",
        "type" : "const(char)[]",
        "storageClass" : [
         "lazy"
        ]
       },
       {
        "name" : "file",
        "type" : "string",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "type" : "size_t",
        "default" : "__LINE__"
       }
      ],
      "endline" : 156
     }
    ]
   },
   {
    "name" : "read",
    "kind" : "function",
    "comment" : "\nRead entire contents of file $(D name) and returns it as an untyped\narray. If the file size is larger than $(D upTo), only $(D upTo)\nbytes are read.\n\nExample:\n\n----\nimport std.file, std.stdio;\nvoid main()\n{\n   auto bytes = cast(ubyte[]) read(\"filename\", 5);\n   if (bytes.length == 5)\n       writefln(\"The fifth byte of the file is 0x%x\", bytes[4]);\n}\n----\n\nReturns: Untyped array of bytes _read.\n\nThrows: $(D FileException) on error.\n \n",
    "line" : 183,
    "deco" : "FxAamZAv",
    "originalType" : "void[](in char[] name, size_t upTo = size_t.max)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "upTo",
      "deco" : "m",
      "default" : "18446744073709551615LU"
     }
    ],
    "endline" : 249
   },
   {
    "name" : "__unittestL251_1076",
    "kind" : "function",
    "line" : 251,
    "endline" : 259
   },
   {
    "name" : "__unittestL259_1077",
    "kind" : "function",
    "line" : 259,
    "endline" : 288
   },
   {
    "kind" : "template",
    "comment" : "\nRead and validates (using $(XREF utf, validate)) a text file. $(D S)\ncan be a type of array of characters of any width and constancy. No\nwidth conversion is performed; if the width of the characters in file\n$(D name) is different from the width of elements of $(D S),\nvalidation will fail.\n\nReturns: Array of characters read.\n\nThrows: $(D FileException) on file error, $(D UTFException) on UTF\ndecoding error.\n\nExample:\n\n----\nenforce(system(\"echo abc>deleteme\") == 0);\nscope(exit) remove(\"deleteme\");\nenforce(chomp(readText(\"deleteme\")) == \"abc\");\n----\n \n",
    "line" : 288,
    "name" : "readText",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type",
      "default" : "string"
     }
    ],
    "members" : [
     {
      "name" : "readText",
      "kind" : "function",
      "comment" : "\nRead and validates (using $(XREF utf, validate)) a text file. $(D S)\ncan be a type of array of characters of any width and constancy. No\nwidth conversion is performed; if the width of the characters in file\n$(D name) is different from the width of elements of $(D S),\nvalidation will fail.\n\nReturns: Array of characters read.\n\nThrows: $(D FileException) on file error, $(D UTFException) on UTF\ndecoding error.\n\nExample:\n\n----\nenforce(system(\"echo abc>deleteme\") == 0);\nscope(exit) remove(\"deleteme\");\nenforce(chomp(readText(\"deleteme\")) == \"abc\");\n----\n \n",
      "line" : 288,
      "type" : "S(in char[] name)",
      "parameters" : [
       {
        "name" : "name",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 293
     }
    ]
   },
   {
    "name" : "__unittestL295_1078",
    "kind" : "function",
    "line" : 295,
    "endline" : 318
   },
   {
    "name" : "write",
    "kind" : "function",
    "comment" : "\nWrite $(D buffer) to file $(D name).\nThrows: $(D FileException) on error.\n\nExample:\n\n----\nimport std.file;\nvoid main()\n{\n   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\n   write(\"filename\", a);\n   assert(cast(int[]) read(\"filename\") == a);\n}\n----\n \n",
    "line" : 318,
    "deco" : "FxAaxAvZv",
    "originalType" : "void(in char[] name, const void[] buffer)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "buffer",
      "deco" : "xAv"
     }
    ],
    "endline" : 337
   },
   {
    "name" : "append",
    "kind" : "function",
    "comment" : "\nAppends $(D buffer) to file $(D name).\nThrows: $(D FileException) on error.\n\nExample:\n\n----\nimport std.file;\nvoid main()\n{\n   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];\n   write(\"filename\", a);\n   int[] b = [ 13, 21 ];\n   append(\"filename\", b);\n   assert(cast(int[]) read(\"filename\") == a ~ b);\n}\n----\n \n",
    "line" : 357,
    "deco" : "FxAaxAvZv",
    "originalType" : "void(in char[] name, in void[] buffer)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "buffer",
      "deco" : "xAv"
     }
    ],
    "endline" : 377
   },
   {
    "name" : "writeImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 381,
    "deco" : "FxAaxAvxkZv",
    "originalType" : "void(in char[] name, in void[] buffer, in uint mode)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "buffer",
      "deco" : "xAv"
     },
     {
      "name" : "mode",
      "deco" : "xk"
     }
    ],
    "endline" : 395
   },
   {
    "name" : "rename",
    "kind" : "function",
    "comment" : "\n Rename file $(D from) to $(D to).\n If the target file exists, it is overwritten.\n Throws: $(D FileException) on error.\n \n",
    "line" : 402,
    "deco" : "FxAaxAaZv",
    "originalType" : "void(in char[] from, in char[] to)",
    "parameters" : [
     {
      "name" : "from",
      "deco" : "xAa"
     },
     {
      "name" : "to",
      "deco" : "xAa"
     }
    ],
    "endline" : 413
   },
   {
    "name" : "__unittestL415_1079",
    "kind" : "function",
    "line" : 415,
    "endline" : 432
   },
   {
    "name" : "remove",
    "kind" : "function",
    "comment" : "\nDelete file $(D name).\nThrows: $(D FileException) on error.\n \n",
    "line" : 432,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 441
   },
   {
    "name" : "getSize",
    "kind" : "function",
    "comment" : "\nGet size of file $(D name) in bytes.\n\nThrows: $(D FileException) on error (e.g., file not found).\n \n",
    "line" : 463,
    "deco" : "FxAaZm",
    "originalType" : "ulong(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 476
   },
   {
    "name" : "__unittestL478_1080",
    "kind" : "function",
    "line" : 478,
    "endline" : 501
   },
   {
    "name" : "getTimes",
    "kind" : "function",
    "comment" : "\n    Get the access and modified times of file or folder $(D name).\n\n    Params:\n        name             = File/Folder name to get times for.\n        accessTime       = Time the file/folder was last accessed.\n        modificationTime = Time the file/folder was last modified.\n\n    Throws:\n        $(D FileException) on error.\n \n",
    "line" : 501,
    "deco" : "FxAaJS3std8datetime7SysTimeJS3std8datetime7SysTimeZv",
    "originalType" : "void(in char[] name, out SysTime accessTime, out SysTime modificationTime)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "accessTime",
      "deco" : "S3std8datetime7SysTime",
      "storageClass" : [
       "out"
      ]
     },
     {
      "name" : "modificationTime",
      "deco" : "S3std8datetime7SysTime",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 522
   },
   {
    "name" : "__unittestL524_1081",
    "kind" : "function",
    "line" : 524,
    "endline" : 593
   },
   {
    "name" : "setTimes",
    "kind" : "function",
    "comment" : "\n    Set access/modified times of file or folder $(D name).\n\n    Params:\n        name             = File/Folder name to get times for.\n        accessTime       = Time the file/folder was last accessed.\n        modificationTime = Time the file/folder was last modified.\n\n    Throws:\n        $(D FileException) on error.\n \n",
    "line" : 685,
    "deco" : "FxAaS3std8datetime7SysTimeS3std8datetime7SysTimeZv",
    "originalType" : "void(in char[] name, SysTime accessTime, SysTime modificationTime)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "accessTime",
      "deco" : "S3std8datetime7SysTime"
     },
     {
      "name" : "modificationTime",
      "deco" : "S3std8datetime7SysTime"
     }
    ],
    "endline" : 720
   },
   {
    "name" : "__unittestL722_1083",
    "kind" : "function",
    "line" : 722,
    "endline" : 752
   },
   {
    "name" : "timeLastModified",
    "kind" : "function",
    "comment" : "\n    Returns the time that the given file was last modified.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n",
    "line" : 752,
    "deco" : "FxAaZS3std8datetime7SysTime",
    "originalType" : "SysTime(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 771
   },
   {
    "name" : "timeLastModified",
    "kind" : "function",
    "comment" : "\n    Returns the time that the given file was last modified. If the\n    file does not exist, returns $(D returnIfMissing).\n\n    A frequent usage pattern occurs in build automation tools such as\n    $(WEB gnu.org/software/make, make) or $(WEB\n    en.wikipedia.org/wiki/Apache_Ant, ant). To check whether file $(D\n    target) must be rebuilt from file $(D source) (i.e., $(D target) is\n    older than $(D source) or does not exist), use the comparison\n    below. The code throws a $(D FileException) if $(D source) does not\n    exist (as it should). On the other hand, the $(D SysTime.min) default\n    makes a non-existing $(D target) seem infinitely old so the test\n    correctly prompts building it.\n\n    Params:\n        name            = The name of the file to get the modification time for.\n        returnIfMissing = The time to return if the given file does not exist.\n\nExamples:\n--------------------\nif(timeLastModified(source) >= timeLastModified(target, SysTime.min))\n{\n    // must (re)build\n}\nelse\n{\n    // target is up-to-date\n}\n--------------------\n",
    "line" : 804,
    "deco" : "FxAaS3std8datetime7SysTimeZS3std8datetime7SysTime",
    "originalType" : "SysTime(in char[] name, SysTime returnIfMissing)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "returnIfMissing",
      "deco" : "S3std8datetime7SysTime"
     }
    ],
    "endline" : 826
   },
   {
    "name" : "__unittestL828_1084",
    "kind" : "function",
    "line" : 828,
    "endline" : 851
   },
   {
    "name" : "exists",
    "kind" : "function",
    "comment" : "\n    Returns whether the given file (or directory) exists.\n \n",
    "line" : 851,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdxAaZb",
    "originalType" : "bool(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 884
   },
   {
    "name" : "__unittestL886_1085",
    "kind" : "function",
    "line" : 886,
    "endline" : 916
   },
   {
    "name" : "getAttributes",
    "kind" : "function",
    "comment" : "\n Returns the attributes of the given file.\n\n Note that the file attributes on Windows and Posix systems are\n completely different. On Windows, they're what is returned by $(WEB\n msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx,\n GetFileAttributes), whereas on Posix systems, they're the $(LUCKY\n st_mode) value which is part of the $(D stat struct) gotten by\n calling the $(WEB en.wikipedia.org/wiki/Stat_%28Unix%29, $(D stat))\n function.\n\n On Posix systems, if the given file is a symbolic link, then\n attributes are the attributes of the file pointed to by the symbolic\n link.\n\n Params:\n name = The file to get the attributes of.\n\n Throws: $(D FileException) on error.\n  \n",
    "line" : 916,
    "deco" : "FxAaZk",
    "originalType" : "uint(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 934
   },
   {
    "name" : "getLinkAttributes",
    "kind" : "function",
    "comment" : "\n    If the given file is a symbolic link, then this returns the attributes of the\n    symbolic link itself rather than file that it points to. If the given file\n    is $(I not) a symbolic link, then this function returns the same result\n    as getAttributes.\n\n    On Windows, getLinkAttributes is identical to getAttributes. It exists on\n    Windows so that you don't have to special-case code for Windows when dealing\n    with symbolic links.\n\n    Params:\n        name = The file to get the symbolic link attributes of.\n\n    Throws:\n        $(D FileException) on error.\n \n",
    "line" : 953,
    "deco" : "FxAaZk",
    "originalType" : "uint(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 965
   },
   {
    "name" : "isDir",
    "kind" : "function",
    "comment" : "\n    Returns whether the given file is a directory.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExamples:\n--------------------\nassert(!\"/etc/fonts/fonts.conf\".isDir);\nassert(\"/usr/share/include\".isDir);\n--------------------\n  \n",
    "line" : 983,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdxAaZb",
    "originalType" : "bool(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 993
   },
   {
    "name" : "__unittestL995_1086",
    "kind" : "function",
    "line" : 995,
    "endline" : 1028
   },
   {
    "name" : "attrIsDir",
    "kind" : "function",
    "comment" : "\n    Returns whether the given file attributes are for a directory.\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\nassert(!attrIsDir(getAttributes(\"/etc/fonts/fonts.conf\")));\nassert(!attrIsDir(getLinkAttributes(\"/etc/fonts/fonts.conf\")));\n--------------------\n  \n",
    "line" : 1028,
    "deco" : "FNbkZb",
    "parameters" : [
     {
      "name" : "attributes",
      "deco" : "k"
     }
    ],
    "endline" : 1038
   },
   {
    "name" : "__unittestL1040_1087",
    "kind" : "function",
    "line" : 1040,
    "endline" : 1100
   },
   {
    "name" : "isFile",
    "kind" : "function",
    "comment" : "\n    Returns whether the given file (or directory) is a file.\n\n    On Windows, if a file is not a directory, then it's a file. So,\n    either $(D isFile) or $(D isDir) will return true for any given file.\n\n    On Posix systems, if $(D isFile) is $(D true), that indicates that the file\n    is a regular file (e.g. not a block not device). So, on Posix systems, it's\n    possible for both $(D isFile) and $(D isDir) to be $(D false) for a\n    particular file (in which case, it's a special file). You can use\n    $(D getAttributes) to get the attributes to figure out what type of special\n    it is, or you can use $(D dirEntry) to get at its $(D statBuf), which is the\n    result from $(D stat). In either case, see the man page for $(D stat) for\n    more information.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n\nExamples:\n--------------------\nassert(\"/etc/fonts/fonts.conf\".isFile);\nassert(!\"/usr/share/include\".isFile);\n--------------------\n  \n",
    "line" : 1100,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdxAaZb",
    "originalType" : "bool(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 1106
   },
   {
    "name" : "__unittestL1108_1088",
    "kind" : "function",
    "line" : 1108,
    "endline" : 1152
   },
   {
    "name" : "attrIsFile",
    "kind" : "function",
    "comment" : "\n    Returns whether the given file attributes are for a file.\n\n    On Windows, if a file is not a directory, it's a file. So, either\n    $(D attrIsFile) or $(D attrIsDir) will return $(D true) for the\n    attributes of any given file.\n\n    On Posix systems, if $(D attrIsFile) is $(D true), that indicates that the\n    file is a regular file (e.g. not a block not device). So, on Posix systems,\n    it's possible for both $(D attrIsFile) and $(D attrIsDir) to be $(D false)\n    for a particular file (in which case, it's a special file). If a file is a\n    special file, you can use the attributes to check what type of special file\n    it is (see the man page for $(D stat) for more information).\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\nassert(attrIsFile(getAttributes(\"/etc/fonts/fonts.conf\")));\nassert(attrIsFile(getLinkAttributes(\"/etc/fonts/fonts.conf\")));\n--------------------\n  \n",
    "line" : 1152,
    "deco" : "FNbkZb",
    "parameters" : [
     {
      "name" : "attributes",
      "deco" : "k"
     }
    ],
    "endline" : 1162
   },
   {
    "name" : "__unittestL1164_1089",
    "kind" : "function",
    "line" : 1164,
    "endline" : 1209
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns whether the given file is a symbolic link.\n\n    On Windows, returns $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        name = The path to the file.\n\n    Throws:\n        $(D FileException) if the given file does not exist.\n  \n",
    "line" : 1209,
    "name" : "isSymlink",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSymlink",
      "kind" : "function",
      "line" : 1209,
      "type" : "bool(const(C)[] name)",
      "parameters" : [
       {
        "name" : "name",
        "type" : "const(C)[]"
       }
      ],
      "endline" : 1215
     }
    ]
   },
   {
    "name" : "__unittestL1217_1090",
    "kind" : "function",
    "line" : 1217,
    "endline" : 1306
   },
   {
    "name" : "attrIsSymlink",
    "kind" : "function",
    "comment" : "\n    Returns whether the given file attributes are for a symbolic link.\n\n    On Windows, return $(D true) when the file is either a symbolic link or a\n    junction point.\n\n    Params:\n        attributes = The file attributes.\n\nExamples:\n--------------------\ncore.sys.posix.unistd.symlink(\"/etc/fonts/fonts.conf\", \"/tmp/alink\");\n\nassert(!getAttributes(\"/tmp/alink\").isSymlink);\nassert(getLinkAttributes(\"/tmp/alink\").isSymlink);\n--------------------\n  \n",
    "line" : 1306,
    "deco" : "FNbkZb",
    "parameters" : [
     {
      "name" : "attributes",
      "deco" : "k"
     }
    ],
    "endline" : 1312
   },
   {
    "name" : "chdir",
    "kind" : "function",
    "comment" : "\n Change directory to $(D pathname).\n Throws: $(D FileException) on error.\n \n",
    "line" : 1319,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] pathname)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAa"
     }
    ],
    "endline" : 1331
   },
   {
    "name" : "mkdir",
    "kind" : "function",
    "comment" : "\nMake directory $(D pathname).\n\nThrows: $(D FileException) on error.\n \n",
    "line" : 1338,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] pathname)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAa"
     }
    ],
    "endline" : 1350
   },
   {
    "name" : "mkdirRecurse",
    "kind" : "function",
    "comment" : "\n Make directory and all parent directories as needed.\n\n Throws: $(D FileException) on error.\n \n",
    "line" : 1358,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] pathname)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAa"
     }
    ],
    "endline" : 1376
   },
   {
    "name" : "__unittestL1378_1091",
    "kind" : "function",
    "line" : 1378,
    "endline" : 1404
   },
   {
    "name" : "rmdir",
    "kind" : "function",
    "comment" : "\nRemove directory $(D pathname).\n\nThrows: $(D FileException) on error.\n \n",
    "line" : 1404,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] pathname)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAa"
     }
    ],
    "endline" : 1416
   },
   {
    "kind" : "template",
    "comment" : "\n    $(BLUE This function is Posix-Only.)\n\n    Creates a symlink.\n\n    Params:\n        original = The file to link from.\n        link     = The symlink to create.\n\n    Note:\n        Relative paths are relative to the current working directory,\n        not the files being linked to or from.\n\n    Throws:\n        $(D FileException) on error (which includes if the symlink already\n        exists).\n  \n",
    "line" : 1436,
    "name" : "symlink",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "symlink",
      "kind" : "function",
      "line" : 1436,
      "type" : "void(const(C1)[] original, const(C2)[] link)",
      "parameters" : [
       {
        "name" : "original",
        "type" : "const(C1)[]"
       },
       {
        "name" : "link",
        "type" : "const(C2)[]"
       }
      ],
      "endline" : 1441
     }
    ]
   },
   {
    "name" : "__unittestL1443_1092",
    "kind" : "function",
    "line" : 1443,
    "endline" : 1498
   },
   {
    "kind" : "template",
    "comment" : "\n    $(BLUE This function is Posix-Only.)\n\n    Returns the path to the file pointed to by a symlink. Note that the\n    path could be either relative or absolute depending on the symlink.\n    If the path is relative, it's relative to the symlink, not the current\n    working directory.\n\n    Throws:\n        $(D FileException) on error.\n  \n",
    "line" : 1499,
    "name" : "readLink",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "readLink",
      "kind" : "function",
      "line" : 1499,
      "type" : "string(const(C)[] link)",
      "parameters" : [
       {
        "name" : "link",
        "type" : "const(C)[]"
       }
      ],
      "endline" : 1532
     }
    ]
   },
   {
    "name" : "__unittestL1534_1093",
    "kind" : "function",
    "line" : 1534,
    "endline" : 1556
   },
   {
    "name" : "getcwd",
    "kind" : "function",
    "comment" : "\n Get current directory.\n Throws: $(D FileException) on error.\n \n",
    "line" : 1582,
    "deco" : "FZAya",
    "endline" : 1588
   },
   {
    "name" : "__unittestL1590_1094",
    "kind" : "function",
    "line" : 1590,
    "endline" : 1597
   },
   {
    "name" : "DirEntry",
    "kind" : "struct",
    "line" : 1867,
    "members" : [
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1871,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZAya",
      "originalType" : "const pure nothrow string()",
      "endline" : 1874
     },
     {
      "name" : "isDir",
      "kind" : "function",
      "line" : 1876,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1881
     },
     {
      "name" : "isFile",
      "kind" : "function",
      "line" : 1883,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1888
     },
     {
      "name" : "isSymlink",
      "kind" : "function",
      "line" : 1890,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1895
     },
     {
      "name" : "size",
      "kind" : "function",
      "line" : 1897,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "ulong()",
      "endline" : 1901
     },
     {
      "name" : "timeStatusChanged",
      "kind" : "function",
      "line" : 1903,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std8datetime7SysTime",
      "originalType" : "SysTime()",
      "endline" : 1908
     },
     {
      "name" : "timeLastAccessed",
      "kind" : "function",
      "line" : 1910,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std8datetime7SysTime",
      "originalType" : "SysTime()",
      "endline" : 1915
     },
     {
      "name" : "timeLastModified",
      "kind" : "function",
      "line" : 1917,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std8datetime7SysTime",
      "originalType" : "SysTime()",
      "endline" : 1922
     },
     {
      "name" : "attributes",
      "kind" : "function",
      "line" : 1924,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZk",
      "originalType" : "uint()",
      "endline" : 1929
     },
     {
      "name" : "linkAttributes",
      "kind" : "function",
      "line" : 1931,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZk",
      "originalType" : "uint()",
      "endline" : 1936
     },
     {
      "name" : "statBuf",
      "kind" : "function",
      "line" : 1938,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS4core3sys5posix3sys4stat6stat_t",
      "originalType" : "stat_t()",
      "endline" : 1943
     },
     {
      "name" : "_init",
      "kind" : "function",
      "protection" : "private",
      "line" : 1947,
      "deco" : "FxAaZv",
      "originalType" : "void(in char[] path)",
      "parameters" : [
       {
        "name" : "path",
        "deco" : "xAa"
       }
      ],
      "endline" : 1954
     },
     {
      "name" : "_init",
      "kind" : "function",
      "protection" : "private",
      "line" : 1956,
      "deco" : "FxAaPS4core3sys5posix6dirent6direntZv",
      "originalType" : "void(in char[] path, core.sys.posix.dirent.dirent* fd)",
      "parameters" : [
       {
        "name" : "path",
        "deco" : "xAa"
       },
       {
        "name" : "fd",
        "deco" : "PS4core3sys5posix6dirent6dirent"
       }
      ],
      "endline" : 1979
     },
     {
      "name" : "_ensureStatDone",
      "kind" : "function",
      "protection" : "private",
      "comment" : "\n            This is to support lazy evaluation, because doing stat's is\n            expensive and not always needed.\n         \n",
      "line" : 1985,
      "deco" : "FZv",
      "endline" : 1994
     },
     {
      "name" : "_ensureLStatDone",
      "kind" : "function",
      "protection" : "private",
      "comment" : "\n            This is to support lazy evaluation, because doing stat's is\n            expensive and not always needed.\n         \n",
      "line" : 2000,
      "deco" : "FZv",
      "endline" : 2014
     },
     {
      "name" : "_name",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " The file or directory represented by this DirEntry.\n",
      "line" : 2017,
      "deco" : "Aya",
      "offset" : 0
     },
     {
      "name" : "_statBuf",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " The result of stat().\n",
      "line" : 2019,
      "deco" : "S4core3sys5posix3sys4stat6stat_t",
      "init" : "void",
      "offset" : 16
     },
     {
      "name" : "_lstatMode",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " The stat mode from lstat().\n",
      "line" : 2020,
      "deco" : "k",
      "offset" : 160
     },
     {
      "name" : "_dType",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " The type of the file.\n",
      "line" : 2021,
      "deco" : "h",
      "offset" : 164
     },
     {
      "name" : "_didLStat",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " Whether lstat() has been called for this DirEntry.\n",
      "line" : 2023,
      "deco" : "b",
      "init" : "false",
      "offset" : 165
     },
     {
      "name" : "_didStat",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " Whether stat() has been called for this DirEntry.\n",
      "line" : 2024,
      "deco" : "b",
      "init" : "false",
      "offset" : 166
     },
     {
      "name" : "_dTypeSet",
      "kind" : "variable",
      "protection" : "private",
      "comment" : " Whether the dType of the file has been set.\n",
      "line" : 2025,
      "deco" : "b",
      "init" : "false",
      "offset" : 167
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std4file8DirEntryKxS3std4file8DirEntryZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std4file8DirEntry",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std4file8DirEntry",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2029_1095",
    "kind" : "function",
    "line" : 2029,
    "endline" : 2095
   },
   {
    "name" : "copy",
    "kind" : "function",
    "comment" : "\nCopy file $(D from) to file $(D to). File timestamps are preserved.\nIf the target file exists, it is overwritten.\n\nThrows: $(D FileException) on error.\n \n",
    "line" : 2095,
    "deco" : "FxAaxAaZv",
    "originalType" : "void(in char[] from, in char[] to)",
    "parameters" : [
     {
      "name" : "from",
      "deco" : "xAa"
     },
     {
      "name" : "to",
      "deco" : "xAa"
     }
    ],
    "endline" : 2150
   },
   {
    "name" : "__unittestL2152_1096",
    "kind" : "function",
    "line" : 2152,
    "endline" : 2173
   },
   {
    "name" : "rmdirRecurse",
    "kind" : "function",
    "comment" : "\n    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n \n",
    "line" : 2173,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] pathname)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAa"
     }
    ],
    "endline" : 2178
   },
   {
    "name" : "rmdirRecurse",
    "kind" : "function",
    "comment" : "\n    Remove directory and all of its content and subdirectories,\n    recursively.\n\n    Throws:\n        $(D FileException) if there is an error (including if the given\n        file is not a directory).\n \n",
    "line" : 2189,
    "deco" : "FKS3std4file8DirEntryZv",
    "parameters" : [
     {
      "name" : "de",
      "deco" : "S3std4file8DirEntry",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2207
   },
   {
    "name" : "__unittestL2217_1098",
    "kind" : "function",
    "line" : 2217,
    "endline" : 2237
   },
   {
    "name" : "__unittestL2237_1099",
    "kind" : "function",
    "line" : 2237,
    "endline" : 2261
   },
   {
    "name" : "SpanMode",
    "kind" : "enum",
    "comment" : "\n Dictates directory spanning policy for $(D_PARAM dirEntries) (see below).\n \n",
    "line" : 2262,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "shallow",
      "kind" : "enum member",
      "comment" : " Only spans one directory. \n",
      "line" : 2264
     },
     {
      "name" : "depth",
      "kind" : "enum member",
      "comment" : " Spans the directory depth-first, i.e. the content of any\n     subdirectory is spanned before that subdirectory itself. Useful\n     e.g. when recursively deleting files.  \n",
      "line" : 2268
     },
     {
      "name" : "breadth",
      "kind" : "enum member",
      "comment" : " Spans the directory breadth-first, i.e. the content of any\n     subdirectory is spanned right after that subdirectory itself. \n",
      "line" : 2271
     }
    ]
   },
   {
    "name" : "DirIteratorImpl",
    "kind" : "struct",
    "protection" : "private",
    "line" : 2275,
    "members" : [
     {
      "name" : "_mode",
      "kind" : "variable",
      "line" : 2276,
      "deco" : "E3std4file8SpanMode",
      "offset" : 0
     },
     {
      "name" : "_followSymlink",
      "kind" : "variable",
      "line" : 2281,
      "deco" : "b",
      "offset" : 4
     },
     {
      "name" : "_cur",
      "kind" : "variable",
      "line" : 2282,
      "deco" : "S3std4file8DirEntry",
      "offset" : 8
     },
     {
      "name" : "_stack",
      "kind" : "variable",
      "line" : 2283,
      "deco" : "S3std5array52__T8AppenderTAS3std4file15DirIteratorImpl9DirHandleZ8Appender",
      "offset" : 176
     },
     {
      "name" : "_stashed",
      "kind" : "variable",
      "line" : 2284,
      "deco" : "S3std5array34__T8AppenderTAS3std4file8DirEntryZ8Appender",
      "offset" : 184
     },
     {
      "name" : "pushExtra",
      "kind" : "function",
      "line" : 2286,
      "deco" : "FS3std4file8DirEntryZv",
      "parameters" : [
       {
        "name" : "de",
        "deco" : "S3std4file8DirEntry"
       }
      ],
      "endline" : 2286
     },
     {
      "name" : "hasExtra",
      "kind" : "function",
      "line" : 2288,
      "deco" : "FZb",
      "endline" : 2288
     },
     {
      "name" : "popExtra",
      "kind" : "function",
      "line" : 2290,
      "deco" : "FZS3std4file8DirEntry",
      "endline" : 2297
     },
     {
      "name" : "DirHandle",
      "kind" : "struct",
      "line" : 2387,
      "members" : [
       {
        "name" : "dirpath",
        "kind" : "variable",
        "line" : 2388,
        "deco" : "Aya",
        "offset" : 0
       },
       {
        "name" : "h",
        "kind" : "variable",
        "line" : 2389,
        "deco" : "PS4core3sys5posix6dirent3DIR",
        "offset" : 16
       },
       {
        "name" : "__xopEquals",
        "kind" : "function",
        "storageClass" : [
         "static"
        ],
        "deco" : "FKxS3std4file15DirIteratorImpl9DirHandleKxS3std4file15DirIteratorImpl9DirHandleZb",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "xS3std4file15DirIteratorImpl9DirHandle",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "q",
          "deco" : "xS3std4file15DirIteratorImpl9DirHandle",
          "storageClass" : [
           "ref"
          ]
         }
        ]
       }
      ]
     },
     {
      "name" : "stepIn",
      "kind" : "function",
      "line" : 2392,
      "deco" : "FAyaZb",
      "parameters" : [
       {
        "name" : "directory",
        "deco" : "Aya"
       }
      ],
      "endline" : 2397
     },
     {
      "name" : "next",
      "kind" : "function",
      "line" : 2399,
      "deco" : "FZb",
      "endline" : 2415
     },
     {
      "name" : "popDirStack",
      "kind" : "function",
      "line" : 2417,
      "deco" : "FZv",
      "endline" : 2422
     },
     {
      "name" : "releaseDirStack",
      "kind" : "function",
      "line" : 2424,
      "deco" : "FZv",
      "endline" : 2428
     },
     {
      "name" : "mayStepIn",
      "kind" : "function",
      "line" : 2430,
      "deco" : "FZb",
      "endline" : 2433
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2436,
      "deco" : "FNcAyaE3std4file8SpanModebZS3std4file15DirIteratorImpl",
      "originalType" : "(string pathname, SpanMode mode, bool followSymlink)",
      "parameters" : [
       {
        "name" : "pathname",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std4file8SpanMode"
       },
       {
        "name" : "followSymlink",
        "deco" : "b"
       }
      ],
      "endline" : 2457
     },
     {
      "name" : "empty",
      "kind" : "function",
      "line" : 2458,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2458
     },
     {
      "name" : "front",
      "kind" : "function",
      "line" : 2459,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std4file8DirEntry",
      "originalType" : "DirEntry()",
      "endline" : 2459
     },
     {
      "name" : "popFront",
      "kind" : "function",
      "line" : 2460,
      "deco" : "FZv",
      "endline" : 2493
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 2495,
      "deco" : "FZv",
      "endline" : 2498
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 2275,
      "deco" : "FNcS3std4file15DirIteratorImplZS3std4file15DirIteratorImpl",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std4file15DirIteratorImpl"
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std4file15DirIteratorImplKxS3std4file15DirIteratorImplZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std4file15DirIteratorImpl",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std4file15DirIteratorImpl",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "DirIterator",
    "kind" : "struct",
    "line" : 2502,
    "members" : [
     {
      "name" : "impl",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2504,
      "deco" : "S3std8typecons86__T10RefCountedTS3std4file15DirIteratorImplVE3std8typecons24RefCountedAutoInitialize0Z10RefCounted",
      "originalType" : "RefCounted!(DirIteratorImpl, RefCountedAutoInitialize.no)",
      "offset" : 0
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2505,
      "deco" : "FNcAyaE3std4file8SpanModebZS3std4file11DirIterator",
      "originalType" : "(string pathname, SpanMode mode, bool followSymlink)",
      "parameters" : [
       {
        "name" : "pathname",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std4file8SpanMode"
       },
       {
        "name" : "followSymlink",
        "deco" : "b"
       }
      ],
      "endline" : 2508
     },
     {
      "name" : "empty",
      "kind" : "function",
      "line" : 2510,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2510
     },
     {
      "name" : "front",
      "kind" : "function",
      "line" : 2511,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std4file8DirEntry",
      "originalType" : "DirEntry()",
      "endline" : 2511
     },
     {
      "name" : "popFront",
      "kind" : "function",
      "line" : 2512,
      "deco" : "FZv",
      "endline" : 2512
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 2502,
      "deco" : "FZv"
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 2502,
      "deco" : "xFKxS3std4file11DirIteratorZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std4file11DirIterator",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 2502,
      "deco" : "FNcS3std4file11DirIteratorZS3std4file11DirIterator",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std4file11DirIterator"
       }
      ]
     }
    ]
   },
   {
    "name" : "dirEntries",
    "kind" : "function",
    "comment" : "\n    Returns an input range of DirEntry that lazily iterates a given directory,\n    also provides two ways of foreach iteration. The iteration variable can be of\n    type $(D_PARAM string) if only the name is needed, or $(D_PARAM DirEntry)\n    if additional details are needed. The span mode dictates the how the\n    directory is traversed. The name of the each directory entry iterated\n    contains the absolute path.\n\n    Params:\n        path = The directory to iterate over.\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\n    Throws:\n        $(D FileException) if the directory does not exist.\n\nExamples:\n--------------------\n// Iterate a directory in depth\nforeach (string name; dirEntries(\"destroy/me\", SpanMode.depth))\n{\n remove(name);\n}\n// Iterate a directory in breadth\nforeach (string name; dirEntries(\".\", SpanMode.breadth))\n{\n writeln(name);\n}\n// Iterate a directory and get detailed info about it\nforeach (DirEntry e; dirEntries(\"dmd-testing\", SpanMode.breadth))\n{\n writeln(e.name, \"\\t\", e.size);\n}\n// Iterate over all *.d files in current directory and all its subdirectories\nauto dFiles = filter!`endsWith(a.name,\".d\")`(dirEntries(\".\",SpanMode.depth));\nforeach(d; dFiles)\n    writeln(d.name);\n// Hook it up with std.parallelism to compile them all in parallel:\nforeach(d; parallel(dFiles, 1)) //passes by 1 file to each thread\n{\n    string cmd = \"dmd -c \"  ~ d.name;\n    writeln(cmd);\n    std.process.system(cmd);\n}\n--------------------\n \n",
    "line" : 2566,
    "storageClass" : [
     "auto"
    ],
    "deco" : "FAyaE3std4file8SpanModebZS3std4file11DirIterator",
    "originalType" : "(string path, SpanMode mode, bool followSymlink = true)",
    "parameters" : [
     {
      "name" : "path",
      "deco" : "Aya"
     },
     {
      "name" : "mode",
      "deco" : "E3std4file8SpanMode"
     },
     {
      "name" : "followSymlink",
      "deco" : "b",
      "default" : "true"
     }
    ],
    "endline" : 2568
   },
   {
    "name" : "__unittestL2570_1100",
    "kind" : "function",
    "line" : 2570,
    "endline" : 2606
   },
   {
    "name" : "__unittestL2606_1101",
    "kind" : "function",
    "line" : 2606,
    "endline" : 2648
   },
   {
    "name" : "dirEntries",
    "kind" : "function",
    "comment" : "\n    Convenience wrapper for filtering file names with a glob pattern.\n\n    Params:\n        path = The directory to iterate over.\n        pattern  = String with wildcards, such as $(RED \"*.d\"). The supported\n                   wildcard strings are described under\n                   $(XREF path, globMatch).\n        mode = Whether the directory's sub-directories should be iterated\n               over depth-first ($(D_PARAM depth)), breadth-first\n               ($(D_PARAM breadth)), or not at all ($(D_PARAM shallow)).\n        followSymlink = Whether symbolic links which point to directories\n                         should be treated as directories and their contents\n                         iterated over.\n\n    Throws:\n        $(D FileException) if the directory does not exist.\n\nExamples:\n--------------------\n// Iterate over all D source files in current directory and all its\n// subdirectories\nauto dFiles = dirEntries(\".\",\"*.{d,di}\",SpanMode.depth);\nforeach(d; dFiles)\n    writeln(d.name);\n--------------------\n \n",
    "line" : 2650,
    "storageClass" : [
     "auto"
    ],
    "deco" : "FAyaAyaE3std4file8SpanModebZS3std4file10dirEntries93__T12FilterResultS48_D3std4file10dirEntries1fMFS3std4file8DirEntryZbTS3std4file11DirIteratorZ12FilterResult",
    "originalType" : "(string path, string pattern, SpanMode mode, bool followSymlink = true)",
    "parameters" : [
     {
      "name" : "path",
      "deco" : "Aya"
     },
     {
      "name" : "pattern",
      "deco" : "Aya"
     },
     {
      "name" : "mode",
      "deco" : "E3std4file8SpanMode"
     },
     {
      "name" : "followSymlink",
      "deco" : "b",
      "default" : "true"
     }
    ],
    "endline" : 2653
   },
   {
    "name" : "dirEntry",
    "kind" : "function",
    "comment" : "\n    Returns a DirEntry for the given file (or directory).\n\n    Params:\n        name = The file (or directory) to get a DirEntry for.\n\n    Throws:\n        $(D FileException) if the file does not exist.\n \n",
    "line" : 2664,
    "deco" : "FxAaZS3std4file8DirEntry",
    "originalType" : "DirEntry(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 2674
   },
   {
    "name" : "__unittestL2677_1102",
    "kind" : "function",
    "line" : 2677,
    "endline" : 2727
   },
   {
    "name" : "__unittestL2727_1103",
    "kind" : "function",
    "line" : 2727,
    "endline" : 2777
   },
   {
    "name" : "__unittestL2777_1104",
    "kind" : "function",
    "line" : 2777,
    "endline" : 2822
   },
   {
    "name" : "__unittestL2822_1105",
    "kind" : "function",
    "line" : 2822,
    "endline" : 2877
   },
   {
    "kind" : "template",
    "comment" : "\nReads an entire file into an array.\n\nExample:\n----\n// Load file; each line is an int followed by comma, whitespace and a\n// double.\nauto a = slurp!(int, double)(\"filename\", \"%s, %s\");\n----\n \n",
    "line" : 2878,
    "name" : "slurp",
    "parameters" : [
     {
      "name" : "Types",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "slurp",
      "kind" : "function",
      "comment" : "\nReads an entire file into an array.\n\nExample:\n----\n// Load file; each line is an int followed by comma, whitespace and a\n// double.\nauto a = slurp!(int, double)(\"filename\", \"%s, %s\");\n----\n \n",
      "line" : 2878,
      "type" : "Select!(Types.length == 1, Types[0][], Tuple!(Types)[])(string filename, in char[] format)",
      "parameters" : [
       {
        "name" : "filename",
        "type" : "string"
       },
       {
        "name" : "format",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2894
     }
    ]
   },
   {
    "name" : "__unittestL2896_1106",
    "kind" : "function",
    "line" : 2896,
    "endline" : 2938
   },
   {
    "name" : "tempDir",
    "kind" : "function",
    "comment" : "\nReturns the path to a directory for temporary files.\n\nOn Windows, this function returns the result of calling the Windows API function\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/aa364992.aspx, $(D GetTempPath)).\n\nOn POSIX platforms, it searches through the following list of directories\nand returns the first one which is found to exist:\n$(OL\n    $(LI The directory given by the $(D TMPDIR) environment variable.)\n    $(LI The directory given by the $(D TEMP) environment variable.)\n    $(LI The directory given by the $(D TMP) environment variable.)\n    $(LI $(D /tmp))\n    $(LI $(D /var/tmp))\n    $(LI $(D /usr/tmp))\n)\n\nOn all platforms, $(D tempDir) returns $(D \".\") on failure, representing\nthe current working directory.\n\nThe return value of the function is cached, so the procedures described\nabove will only be performed the first time the function is called.  All\nsubsequent runs will return the same string, regardless of whether\nenvironment variables and directory structures have changed in the\nmeantime.\n\nThe POSIX $(D tempDir) algorithm is inspired by Python's\n$(LINK2 http://docs.python.org/library/tempfile.html#tempfile.tempdir, $(D tempfile.tempdir)).\n",
    "line" : 2938,
    "deco" : "FZAya",
    "endline" : 2972
   }
  ]
 },
 {
  "name" : "std.format",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/format.d",
  "comment" : "\n   This module implements the formatting functionality for strings and\n   I/O. It's comparable to C99's $(D vsprintf()) and uses a similar\n   format encoding scheme.\n\n   Macros: WIKI = Phobos/StdFormat\n\n   Copyright: Copyright Digital Mars 2000-.\n\n   License: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n   Authors: $(WEB digitalmars.com, Walter Bright), $(WEB erdani.com,\n   Andrei Alexandrescu), and Kenji Hara\n\n   Source: $(PHOBOSSRC std/_format.d)\n \n",
  "members" : [
   {
    "name" : "core.stdc.stdio",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "core.vararg",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.bitmanip",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.system",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "FormatException",
    "kind" : "class",
    "comment" : "\n Signals a mismatch between a format and its corresponding argument.\n \n",
    "line" : 52,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 54,
      "deco" : "FZC3std6format15FormatException",
      "originalType" : "()",
      "endline" : 57
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 59,
      "deco" : "FAyaAyamC6object9ThrowableZC3std6format15FormatException",
      "originalType" : "(string msg, string fn = __FILE__, size_t ln = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "fn",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "ln",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 62
     }
    ]
   },
   {
    "name" : "FormatError",
    "kind" : "alias",
    "line" : 67,
    "storageClass" : [
     "deprecated"
    ],
    "deco" : "C3std6format15FormatException"
   },
   {
    "kind" : "template",
    "comment" : "\n   Interprets variadic argument list $(D args), formats them according\n   to $(D fmt), and sends the resulting characters to $(D w). The\n   encoding of the output is the same as $(D Char). The type $(D Writer)\n   must satisfy $(XREF range,isOutputRange!(Writer, Char)).\n\n   The variadic arguments are normally consumed in order. POSIX-style\n   $(WEB opengroup.org/onlinepubs/009695399/functions/printf.html,\n   positional parameter syntax) is also supported. Each argument is\n   formatted into a sequence of chars according to the format\n   specification, and the characters are passed to $(D w). As many\n   arguments as specified in the format string are consumed and\n   formatted. If there are fewer arguments than format specifiers, a\n   $(D FormatException) is thrown. If there are more remaining arguments\n   than needed by the format specification, they are ignored but only\n   if at least one argument was formatted.\n\n   The format string supports the formatting of array and nested array elements\n   via the grouping format specifiers $(B %&#40;) and $(B %&#41;). Each\n   matching pair of $(B %&#40;) and $(B %&#41;) corresponds with a single array\n   argument. The enclosed sub-format string is applied to individual array\n   elements.  The trailing portion of the sub-format string following the\n   conversion specifier for the array element is interpreted as the array\n   delimiter, and is therefore omitted following the last array element. The\n   $(B %|) specifier may be used to explicitly indicate the start of the\n   delimiter, so that the preceding portion of the string will be included\n   following the last array element.  (See below for explicit examples.)\n\n   Params:\n\n   w = Output is sent to this writer. Typical output writers include\n   $(XREF array,Appender!string) and $(XREF stdio,LockingTextWriter).\n\n   fmt = Format string.\n\n   args = Variadic argument list.\n\n   Returns: Formatted number of arguments.\n\n   Throws: Mismatched arguments and formats result in a $(D\n   FormatException) being thrown.\n\n   Format_String: <a name=\"format-string\">$(I Format strings)</a>\n   consist of characters interspersed with $(I format\n   specifications). Characters are simply copied to the output (such\n   as putc) after any necessary conversion to the corresponding UTF-8\n   sequence.\n\n   The format string has the following grammar:\n\n$(PRE\n$(I FormatString):\n    $(I FormatStringItem)*\n$(I FormatStringItem):\n    $(B '%%')\n    $(B '%') $(I Position) $(I Flags) $(I Width) $(I Precision) $(I FormatChar)\n    $(B '%$(LPAREN)') $(I FormatString) $(B '%$(RPAREN)')\n    $(I OtherCharacterExceptPercent)\n$(I Position):\n    $(I empty)\n    $(I Integer) $(B '$')\n$(I Flags):\n    $(I empty)\n    $(B '-') $(I Flags)\n    $(B '+') $(I Flags)\n    $(B '#') $(I Flags)\n    $(B '0') $(I Flags)\n    $(B ' ') $(I Flags)\n$(I Width):\n    $(I empty)\n    $(I Integer)\n    $(B '*')\n$(I Precision):\n    $(I empty)\n    $(B '.')\n    $(B '.') $(I Integer)\n    $(B '.*')\n$(I Integer):\n    $(I Digit)\n    $(I Digit) $(I Integer)\n$(I Digit):\n    $(B '0')|$(B '1')|$(B '2')|$(B '3')|$(B '4')|$(B '5')|$(B '6')|$(B '7')|$(B '8')|$(B '9')\n$(I FormatChar):\n    $(B 's')|$(B 'b')|$(B 'd')|$(B 'o')|$(B 'x')|$(B 'X')|$(B 'e')|$(B 'E')|$(B 'f')|$(B 'F')|$(B 'g')|$(B 'G')|$(B 'a')|$(B 'A')\n)\n\n    $(BOOKTABLE Flags affect formatting depending on the specifier as\n    follows., $(TR $(TH Flag) $(TH Types&nbsp;affected) $(TH Semantics))\n\n    $(TR $(TD $(B '-')) $(TD numeric) $(TD Left justify the result in\n        the field.  It overrides any $(B 0) flag.))\n\n    $(TR $(TD $(B '+')) $(TD numeric) $(TD Prefix positive numbers in\n    a signed conversion with a $(B +).  It overrides any $(I space)\n    flag.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'o'))) $(TD Add to\n    precision as necessary so that the first digit of the octal\n    formatting is a '0', even if both the argument and the $(I\n    Precision) are zero.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'x'), $(B 'X'))) $(TD If\n       non-zero, prefix result with $(B 0x) ($(B 0X)).))\n\n    $(TR $(TD $(B '#')) $(TD floating) $(TD Always insert the decimal\n       point and print trailing zeros.))\n\n    $(TR $(TD $(B '#')) $(TD numeric ($(B '0'))) $(TD Use leading\n    zeros to pad rather than spaces (except for the floating point\n    values $(D nan) and $(D infinity)).  Ignore if there's a $(I\n    Precision).))\n\n    $(TR $(TD $(B ' ')) $(TD numeric)) $(TD Prefix positive\n    numbers in a signed conversion with a space.))\n\n    <dt>$(I Width)\n    <dd>\n    Specifies the minimum field width.\n    If the width is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the width.\n    If the width is negative, it is as if the $(B -) was given\n    as a $(I Flags) character.\n\n    <dt>$(I Precision)\n    <dd> Gives the precision for numeric conversions.\n    If the precision is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the precision. If it is negative,\n    it is as if there was no $(I Precision).\n\n    <dt>$(I FormatChar)\n    <dd>\n    <dl>\n        <dt>$(B 's')\n        <dd>The corresponding argument is formatted in a manner consistent\n        with its type:\n        <dl>\n            <dt>$(B bool)\n            <dd>The result is <tt>'true'</tt> or <tt>'false'</tt>.\n            <dt>integral types\n            <dd>The $(B %d) format is used.\n            <dt>floating point types\n            <dd>The $(B %g) format is used.\n            <dt>string types\n            <dd>The result is the string converted to UTF-8.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>classes derived from $(B Object)\n            <dd>The result is the string returned from the class instance's\n            $(B .toString()) method.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>non-string static and dynamic arrays\n            <dd>The result is [s<sub>0</sub>, s<sub>1</sub>, ...]\n            where s<sub>k</sub> is the kth element\n            formatted with the default format.\n        </dl>\n\n        <dt>$(B 'c')\n        <dd>The corresponding argument must be a character type.\n\n        <dt>$(B 'b','d','o','x','X')\n        <dd> The corresponding argument must be an integral type\n        and is formatted as an integer. If the argument is a signed type\n        and the $(I FormatChar) is $(B d) it is converted to\n        a signed string of characters, otherwise it is treated as\n        unsigned. An argument of type $(B bool) is formatted as '1'\n        or '0'. The base used is binary for $(B b), octal for $(B o),\n        decimal\n        for $(B d), and hexadecimal for $(B x) or $(B X).\n        $(B x) formats using lower case letters, $(B X) uppercase.\n        If there are fewer resulting digits than the $(I Precision),\n        leading zeros are used as necessary.\n        If the $(I Precision) is 0 and the number is 0, no digits\n        result.\n\n        <dt>$(B 'e','E')\n        <dd> A floating point number is formatted as one digit before\n        the decimal point, $(I Precision) digits after, the $(I FormatChar),\n        &plusmn;, followed by at least a two digit exponent: $(I d.dddddd)e$(I &plusmn;dd).\n        If there is no $(I Precision), six\n        digits are generated after the decimal point.\n        If the $(I Precision) is 0, no decimal point is generated.\n\n        <dt>$(B 'f','F')\n        <dd> A floating point number is formatted in decimal notation.\n        The $(I Precision) specifies the number of digits generated\n        after the decimal point. It defaults to six. At least one digit\n        is generated before the decimal point. If the $(I Precision)\n        is zero, no decimal point is generated.\n\n        <dt>$(B 'g','G')\n        <dd> A floating point number is formatted in either $(B e) or\n        $(B f) format for $(B g); $(B E) or $(B F) format for\n        $(B G).\n        The $(B f) format is used if the exponent for an $(B e) format\n        is greater than -5 and less than the $(I Precision).\n        The $(I Precision) specifies the number of significant\n        digits, and defaults to six.\n        Trailing zeros are elided after the decimal point, if the fractional\n        part is zero then no decimal point is generated.\n\n        <dt>$(B 'a','A')\n        <dd> A floating point number is formatted in hexadecimal\n        exponential notation 0x$(I h.hhhhhh)p$(I &plusmn;d).\n        There is one hexadecimal digit before the decimal point, and as\n        many after as specified by the $(I Precision).\n        If the $(I Precision) is zero, no decimal point is generated.\n        If there is no $(I Precision), as many hexadecimal digits as\n        necessary to exactly represent the mantissa are generated.\n        The exponent is written in as few digits as possible,\n        but at least one, is in decimal, and represents a power of 2 as in\n        $(I h.hhhhhh)*2<sup>$(I &plusmn;d)</sup>.\n        The exponent for zero is zero.\n        The hexadecimal digits, x and p are in upper case if the\n        $(I FormatChar) is upper case.\n    </dl>\n\n    Floating point NaN's are formatted as $(B nan) if the\n    $(I FormatChar) is lower case, or $(B NAN) if upper.\n    Floating point infinities are formatted as $(B inf) or\n    $(B infinity) if the\n    $(I FormatChar) is lower case, or $(B INF) or $(B INFINITY) if upper.\n    </dl>\n\nExamples:\n\n-------------------------\nimport std.c.stdio;\nimport std.format;\n\nvoid main()\n{\n    auto writer = appender!string();\n    formattedWrite(writer, \"%s is the ultimate %s.\", 42, \"answer\");\n    assert(writer.data == \"42 is the ultimate answer.\");\n    // Clear the writer\n    writer = appender!string();\n    formattedWrite(writer, \"Date: %2$s %1$s\", \"October\", 5);\n    assert(writer.data == \"Date: 5 October\");\n}\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the next parameter after\nthe largest positional parameter already used.\n\nExample using array and nested array formatting:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(%s %).\", [1,2,3]);\n    writefln(\"My items are %(%s, %).\", [1,2,3]);\n}\n-------------------------\n   The output is:\n<pre class=console>\nMy items are 1 2 3.\nMy items are 1, 2, 3.\n</pre>\n\n   The trailing end of the sub-format string following the specifier for each\n   item is interpreted as the array delimiter, and is therefore omitted\n   following the last array item. The $(B %|) delimiter specifier may be used\n   to indicate where the delimiter begins, so that the portion of the format\n   string prior to it will be retained in the last array element:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(-%s-%|, %).\", [1,2,3]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy items are -1-, -2-, -3-.\n</pre>\n\n   These compound format specifiers may be nested in the case of a nested\n   array argument:\n-------------------------\nimport std.stdio;\nvoid main() {\n     auto mat = [[1, 2, 3],\n                 [4, 5, 6],\n                 [7, 8, 9]];\n\n     writefln(\"%(%(%d %)\\n%)\", mat);\n     writeln();\n\n     writefln(\"[%(%(%d %)\\n %)]\", mat);\n     writeln();\n\n     writefln(\"[%([%(%d %)]%|\\n %)]\", mat);\n     writeln();\n}\n-------------------------\n   The output is:\n<pre class=console>\n1 2 3\n4 5 6\n7 8 9\n\n[1 2 3\n 4 5 6\n 7 8 9]\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n</pre>\n\n   Inside a compound format specifier, strings and characters are escaped\n   automatically. To avoid this behavior, add $(B '-') flag to\n   $(D \"%$(LPAREN)\").\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My friends are %s.\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %(%s, %).\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %-(%s, %).\", [\"John\", \"Nancy\"]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy friends are [\"John\", \"Nancy\"].\nMy friends are \"John\", \"Nancy\".\nMy friends are John, Nancy.\n</pre>\n \n",
    "line" : 404,
    "name" : "formattedWrite",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     },
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "formattedWrite",
      "kind" : "function",
      "comment" : "\n   Interprets variadic argument list $(D args), formats them according\n   to $(D fmt), and sends the resulting characters to $(D w). The\n   encoding of the output is the same as $(D Char). The type $(D Writer)\n   must satisfy $(XREF range,isOutputRange!(Writer, Char)).\n\n   The variadic arguments are normally consumed in order. POSIX-style\n   $(WEB opengroup.org/onlinepubs/009695399/functions/printf.html,\n   positional parameter syntax) is also supported. Each argument is\n   formatted into a sequence of chars according to the format\n   specification, and the characters are passed to $(D w). As many\n   arguments as specified in the format string are consumed and\n   formatted. If there are fewer arguments than format specifiers, a\n   $(D FormatException) is thrown. If there are more remaining arguments\n   than needed by the format specification, they are ignored but only\n   if at least one argument was formatted.\n\n   The format string supports the formatting of array and nested array elements\n   via the grouping format specifiers $(B %&#40;) and $(B %&#41;). Each\n   matching pair of $(B %&#40;) and $(B %&#41;) corresponds with a single array\n   argument. The enclosed sub-format string is applied to individual array\n   elements.  The trailing portion of the sub-format string following the\n   conversion specifier for the array element is interpreted as the array\n   delimiter, and is therefore omitted following the last array element. The\n   $(B %|) specifier may be used to explicitly indicate the start of the\n   delimiter, so that the preceding portion of the string will be included\n   following the last array element.  (See below for explicit examples.)\n\n   Params:\n\n   w = Output is sent to this writer. Typical output writers include\n   $(XREF array,Appender!string) and $(XREF stdio,LockingTextWriter).\n\n   fmt = Format string.\n\n   args = Variadic argument list.\n\n   Returns: Formatted number of arguments.\n\n   Throws: Mismatched arguments and formats result in a $(D\n   FormatException) being thrown.\n\n   Format_String: <a name=\"format-string\">$(I Format strings)</a>\n   consist of characters interspersed with $(I format\n   specifications). Characters are simply copied to the output (such\n   as putc) after any necessary conversion to the corresponding UTF-8\n   sequence.\n\n   The format string has the following grammar:\n\n$(PRE\n$(I FormatString):\n    $(I FormatStringItem)*\n$(I FormatStringItem):\n    $(B '%%')\n    $(B '%') $(I Position) $(I Flags) $(I Width) $(I Precision) $(I FormatChar)\n    $(B '%$(LPAREN)') $(I FormatString) $(B '%$(RPAREN)')\n    $(I OtherCharacterExceptPercent)\n$(I Position):\n    $(I empty)\n    $(I Integer) $(B '$')\n$(I Flags):\n    $(I empty)\n    $(B '-') $(I Flags)\n    $(B '+') $(I Flags)\n    $(B '#') $(I Flags)\n    $(B '0') $(I Flags)\n    $(B ' ') $(I Flags)\n$(I Width):\n    $(I empty)\n    $(I Integer)\n    $(B '*')\n$(I Precision):\n    $(I empty)\n    $(B '.')\n    $(B '.') $(I Integer)\n    $(B '.*')\n$(I Integer):\n    $(I Digit)\n    $(I Digit) $(I Integer)\n$(I Digit):\n    $(B '0')|$(B '1')|$(B '2')|$(B '3')|$(B '4')|$(B '5')|$(B '6')|$(B '7')|$(B '8')|$(B '9')\n$(I FormatChar):\n    $(B 's')|$(B 'b')|$(B 'd')|$(B 'o')|$(B 'x')|$(B 'X')|$(B 'e')|$(B 'E')|$(B 'f')|$(B 'F')|$(B 'g')|$(B 'G')|$(B 'a')|$(B 'A')\n)\n\n    $(BOOKTABLE Flags affect formatting depending on the specifier as\n    follows., $(TR $(TH Flag) $(TH Types&nbsp;affected) $(TH Semantics))\n\n    $(TR $(TD $(B '-')) $(TD numeric) $(TD Left justify the result in\n        the field.  It overrides any $(B 0) flag.))\n\n    $(TR $(TD $(B '+')) $(TD numeric) $(TD Prefix positive numbers in\n    a signed conversion with a $(B +).  It overrides any $(I space)\n    flag.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'o'))) $(TD Add to\n    precision as necessary so that the first digit of the octal\n    formatting is a '0', even if both the argument and the $(I\n    Precision) are zero.))\n\n    $(TR $(TD $(B '#')) $(TD integral ($(B 'x'), $(B 'X'))) $(TD If\n       non-zero, prefix result with $(B 0x) ($(B 0X)).))\n\n    $(TR $(TD $(B '#')) $(TD floating) $(TD Always insert the decimal\n       point and print trailing zeros.))\n\n    $(TR $(TD $(B '#')) $(TD numeric ($(B '0'))) $(TD Use leading\n    zeros to pad rather than spaces (except for the floating point\n    values $(D nan) and $(D infinity)).  Ignore if there's a $(I\n    Precision).))\n\n    $(TR $(TD $(B ' ')) $(TD numeric)) $(TD Prefix positive\n    numbers in a signed conversion with a space.))\n\n    <dt>$(I Width)\n    <dd>\n    Specifies the minimum field width.\n    If the width is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the width.\n    If the width is negative, it is as if the $(B -) was given\n    as a $(I Flags) character.\n\n    <dt>$(I Precision)\n    <dd> Gives the precision for numeric conversions.\n    If the precision is a $(B *), the next argument, which must be\n    of type $(B int), is taken as the precision. If it is negative,\n    it is as if there was no $(I Precision).\n\n    <dt>$(I FormatChar)\n    <dd>\n    <dl>\n        <dt>$(B 's')\n        <dd>The corresponding argument is formatted in a manner consistent\n        with its type:\n        <dl>\n            <dt>$(B bool)\n            <dd>The result is <tt>'true'</tt> or <tt>'false'</tt>.\n            <dt>integral types\n            <dd>The $(B %d) format is used.\n            <dt>floating point types\n            <dd>The $(B %g) format is used.\n            <dt>string types\n            <dd>The result is the string converted to UTF-8.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>classes derived from $(B Object)\n            <dd>The result is the string returned from the class instance's\n            $(B .toString()) method.\n            A $(I Precision) specifies the maximum number of characters\n            to use in the result.\n            <dt>non-string static and dynamic arrays\n            <dd>The result is [s<sub>0</sub>, s<sub>1</sub>, ...]\n            where s<sub>k</sub> is the kth element\n            formatted with the default format.\n        </dl>\n\n        <dt>$(B 'c')\n        <dd>The corresponding argument must be a character type.\n\n        <dt>$(B 'b','d','o','x','X')\n        <dd> The corresponding argument must be an integral type\n        and is formatted as an integer. If the argument is a signed type\n        and the $(I FormatChar) is $(B d) it is converted to\n        a signed string of characters, otherwise it is treated as\n        unsigned. An argument of type $(B bool) is formatted as '1'\n        or '0'. The base used is binary for $(B b), octal for $(B o),\n        decimal\n        for $(B d), and hexadecimal for $(B x) or $(B X).\n        $(B x) formats using lower case letters, $(B X) uppercase.\n        If there are fewer resulting digits than the $(I Precision),\n        leading zeros are used as necessary.\n        If the $(I Precision) is 0 and the number is 0, no digits\n        result.\n\n        <dt>$(B 'e','E')\n        <dd> A floating point number is formatted as one digit before\n        the decimal point, $(I Precision) digits after, the $(I FormatChar),\n        &plusmn;, followed by at least a two digit exponent: $(I d.dddddd)e$(I &plusmn;dd).\n        If there is no $(I Precision), six\n        digits are generated after the decimal point.\n        If the $(I Precision) is 0, no decimal point is generated.\n\n        <dt>$(B 'f','F')\n        <dd> A floating point number is formatted in decimal notation.\n        The $(I Precision) specifies the number of digits generated\n        after the decimal point. It defaults to six. At least one digit\n        is generated before the decimal point. If the $(I Precision)\n        is zero, no decimal point is generated.\n\n        <dt>$(B 'g','G')\n        <dd> A floating point number is formatted in either $(B e) or\n        $(B f) format for $(B g); $(B E) or $(B F) format for\n        $(B G).\n        The $(B f) format is used if the exponent for an $(B e) format\n        is greater than -5 and less than the $(I Precision).\n        The $(I Precision) specifies the number of significant\n        digits, and defaults to six.\n        Trailing zeros are elided after the decimal point, if the fractional\n        part is zero then no decimal point is generated.\n\n        <dt>$(B 'a','A')\n        <dd> A floating point number is formatted in hexadecimal\n        exponential notation 0x$(I h.hhhhhh)p$(I &plusmn;d).\n        There is one hexadecimal digit before the decimal point, and as\n        many after as specified by the $(I Precision).\n        If the $(I Precision) is zero, no decimal point is generated.\n        If there is no $(I Precision), as many hexadecimal digits as\n        necessary to exactly represent the mantissa are generated.\n        The exponent is written in as few digits as possible,\n        but at least one, is in decimal, and represents a power of 2 as in\n        $(I h.hhhhhh)*2<sup>$(I &plusmn;d)</sup>.\n        The exponent for zero is zero.\n        The hexadecimal digits, x and p are in upper case if the\n        $(I FormatChar) is upper case.\n    </dl>\n\n    Floating point NaN's are formatted as $(B nan) if the\n    $(I FormatChar) is lower case, or $(B NAN) if upper.\n    Floating point infinities are formatted as $(B inf) or\n    $(B infinity) if the\n    $(I FormatChar) is lower case, or $(B INF) or $(B INFINITY) if upper.\n    </dl>\n\nExamples:\n\n-------------------------\nimport std.c.stdio;\nimport std.format;\n\nvoid main()\n{\n    auto writer = appender!string();\n    formattedWrite(writer, \"%s is the ultimate %s.\", 42, \"answer\");\n    assert(writer.data == \"42 is the ultimate answer.\");\n    // Clear the writer\n    writer = appender!string();\n    formattedWrite(writer, \"Date: %2$s %1$s\", \"October\", 5);\n    assert(writer.data == \"Date: 5 October\");\n}\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the next parameter after\nthe largest positional parameter already used.\n\nExample using array and nested array formatting:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(%s %).\", [1,2,3]);\n    writefln(\"My items are %(%s, %).\", [1,2,3]);\n}\n-------------------------\n   The output is:\n<pre class=console>\nMy items are 1 2 3.\nMy items are 1, 2, 3.\n</pre>\n\n   The trailing end of the sub-format string following the specifier for each\n   item is interpreted as the array delimiter, and is therefore omitted\n   following the last array item. The $(B %|) delimiter specifier may be used\n   to indicate where the delimiter begins, so that the portion of the format\n   string prior to it will be retained in the last array element:\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My items are %(-%s-%|, %).\", [1,2,3]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy items are -1-, -2-, -3-.\n</pre>\n\n   These compound format specifiers may be nested in the case of a nested\n   array argument:\n-------------------------\nimport std.stdio;\nvoid main() {\n     auto mat = [[1, 2, 3],\n                 [4, 5, 6],\n                 [7, 8, 9]];\n\n     writefln(\"%(%(%d %)\\n%)\", mat);\n     writeln();\n\n     writefln(\"[%(%(%d %)\\n %)]\", mat);\n     writeln();\n\n     writefln(\"[%([%(%d %)]%|\\n %)]\", mat);\n     writeln();\n}\n-------------------------\n   The output is:\n<pre class=console>\n1 2 3\n4 5 6\n7 8 9\n\n[1 2 3\n 4 5 6\n 7 8 9]\n\n[[1 2 3]\n [4 5 6]\n [7 8 9]]\n</pre>\n\n   Inside a compound format specifier, strings and characters are escaped\n   automatically. To avoid this behavior, add $(B '-') flag to\n   $(D \"%$(LPAREN)\").\n-------------------------\nimport std.stdio;\n\nvoid main()\n{\n    writefln(\"My friends are %s.\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %(%s, %).\", [\"John\", \"Nancy\"]);\n    writefln(\"My friends are %-(%s, %).\", [\"John\", \"Nancy\"]);\n}\n-------------------------\n   which gives the output:\n<pre class=console>\nMy friends are [\"John\", \"Nancy\"].\nMy friends are \"John\", \"Nancy\".\nMy friends are John, Nancy.\n</pre>\n \n",
      "line" : 404,
      "type" : "uint(Writer w, in Char[] fmt, A args)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "fmt",
        "type" : "Char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "args",
        "type" : "A"
       }
      ],
      "endline" : 502
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Reads characters from input range $(D r), converts them according\n   to $(D fmt), and writes them to $(D args).\n\n   Returns:\n\n   On success, the function returns the number of variables filled. This count\n   can match the expected number of readings or fewer, even zero, if a\n   matching failure happens.\n\n   Example:\n----\nstring s = \"hello!124:34.5\";\nstring a;\nint b;\ndouble c;\nformattedRead(s, \"%s!%s:%s\", &a, &b, &c);\nassert(a == \"hello\" && b == 124 && c == 34.5);\n----\n \n",
    "line" : 524,
    "name" : "formattedRead",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "formattedRead",
      "kind" : "function",
      "comment" : "\n   Reads characters from input range $(D r), converts them according\n   to $(D fmt), and writes them to $(D args).\n\n   Returns:\n\n   On success, the function returns the number of variables filled. This count\n   can match the expected number of readings or fewer, even zero, if a\n   matching failure happens.\n\n   Example:\n----\nstring s = \"hello!124:34.5\";\nstring a;\nint b;\ndouble c;\nformattedRead(s, \"%s!%s:%s\", &a, &b, &c);\nassert(a == \"hello\" && b == 124 && c == 34.5);\n----\n \n",
      "line" : 524,
      "type" : "uint(ref R r, const(Char)[] fmt, S args)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "fmt",
        "type" : "const(Char)[]"
       },
       {
        "name" : "args",
        "type" : "S"
       }
      ],
      "endline" : 569
     }
    ]
   },
   {
    "name" : "__unittestL571_1107",
    "kind" : "function",
    "line" : 571,
    "endline" : 582
   },
   {
    "kind" : "template",
    "line" : 582,
    "name" : "FormatSpec",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "FormatSpec",
      "kind" : "alias",
      "line" : 585,
      "type" : "FormatSpec!(Unqual!(Char))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   A General handler for $(D printf) style format specifiers. Used for building more\n   specific formatting functions.\n\n   Example:\n----\nauto a = appender!(string)();\nauto fmt = \"Number: %2.4e\\nString: %s\";\nauto f = FormatSpec!char(fmt);\n\nf.writeUpToNextSpec(a);\n\nassert(a.data == \"Number: \");\nassert(f.trailing == \"\\nString: %s\");\nassert(f.spec == 'e');\nassert(f.width == 2);\nassert(f.precision == 4);\n\nf.writeUpToNextSpec(a);\n\nassert(a.data == \"Number: \\nString: \");\nassert(f.trailing == \"\");\nassert(f.spec == 's');\n----\n \n",
    "line" : 615,
    "name" : "FormatSpec",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "FormatSpec",
      "kind" : "struct",
      "line" : 615,
      "members" : [
       {
        "name" : "width",
        "kind" : "variable",
        "comment" : "\n       Minimum _width, default $(D 0).\n     \n",
        "line" : 619,
        "deco" : "i",
        "init" : "0"
       },
       {
        "name" : "precision",
        "kind" : "variable",
        "comment" : "\n       Precision. Its semantics depends on the argument type. For\n       floating point numbers, _precision dictates the number of\n       decimals printed.\n     \n",
        "line" : 625,
        "deco" : "i",
        "init" : "UNSPECIFIED"
       },
       {
        "name" : "DYNAMIC",
        "kind" : "variable",
        "comment" : "\n       Special value for width and precision. $(D DYNAMIC) width or\n       precision means that they were specified with $(D '*') in the\n       format string and are passed at runtime through the varargs.\n     \n",
        "line" : 631,
        "storageClass" : [
         "enum"
        ],
        "deco" : "i",
        "init" : "(int).max"
       },
       {
        "name" : "UNSPECIFIED",
        "kind" : "variable",
        "comment" : "\n       Special value for precision, meaning the format specifier\n       contained no explicit precision.\n     \n",
        "line" : 636,
        "storageClass" : [
         "enum"
        ],
        "deco" : "i",
        "init" : "DYNAMIC - 1"
       },
       {
        "name" : "spec",
        "kind" : "variable",
        "comment" : "\n       The actual format specifier, $(D 's') by default.\n    \n",
        "line" : 640,
        "deco" : "a",
        "init" : "'s'"
       },
       {
        "name" : "indexStart",
        "kind" : "variable",
        "comment" : "\n       Index of the argument for positional parameters, from $(D 1) to\n       $(D ubyte.max). ($(D 0) means not used).\n    \n",
        "line" : 645,
        "deco" : "h"
       },
       {
        "name" : "indexEnd",
        "kind" : "variable",
        "comment" : "\n       Index of the last argument for positional parameter range, from\n       $(D 1) to $(D ubyte.max). ($(D 0) means not used).\n    \n",
        "line" : 650,
        "deco" : "h"
       },
       {
        "name" : "allFlags",
        "kind" : "variable",
        "line" : 691,
        "deco" : "h"
       },
       {
        "name" : "nested",
        "kind" : "variable",
        "comment" : "\n       In case of a compound format specifier starting with $(D\n       \"%$(LPAREN)\") and ending with $(D \"%$(RPAREN)\"), $(D _nested)\n       contains the string contained within the two separators.\n     \n",
        "line" : 700,
        "type" : "const(Char)[]"
       },
       {
        "name" : "sep",
        "kind" : "variable",
        "comment" : "\n       In case of a compound format specifier, $(D _sep) contains the\n       string positioning after $(D \"%|\").\n     \n",
        "line" : 706,
        "type" : "const(Char)[]"
       },
       {
        "name" : "trailing",
        "kind" : "variable",
        "comment" : "\n       $(D _trailing) contains the rest of the format string.\n     \n",
        "line" : 711,
        "type" : "const(Char)[]"
       },
       {
        "name" : "seqBefore",
        "kind" : "variable",
        "line" : 717,
        "storageClass" : [
         "enum"
        ],
        "type" : "immutable(Char)[]",
        "init" : "\"[\""
       },
       {
        "name" : "seqAfter",
        "kind" : "variable",
        "line" : 723,
        "storageClass" : [
         "enum"
        ],
        "type" : "immutable(Char)[]",
        "init" : "\"]\""
       },
       {
        "name" : "keySeparator",
        "kind" : "variable",
        "line" : 729,
        "storageClass" : [
         "enum"
        ],
        "type" : "immutable(Char)[]",
        "init" : "\":\""
       },
       {
        "name" : "seqSeparator",
        "kind" : "variable",
        "line" : 735,
        "storageClass" : [
         "enum"
        ],
        "type" : "immutable(Char)[]",
        "init" : "\", \""
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n       Construct a new $(D FormatSpec) using the format string $(D fmt), no\n       processing is done until needed.\n     \n",
        "line" : 741,
        "type" : "(in Char[] fmt)",
        "parameters" : [
         {
          "name" : "fmt",
          "type" : "Char[]",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 744
       },
       {
        "kind" : "template",
        "line" : 746,
        "name" : "writeUpToNextSpec",
        "parameters" : [
         {
          "name" : "OutputRange",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "writeUpToNextSpec",
          "kind" : "function",
          "line" : 746,
          "type" : "bool(OutputRange writer)",
          "parameters" : [
           {
            "name" : "writer",
            "type" : "OutputRange"
           }
          ],
          "endline" : 770
         }
        ]
       },
       {
        "name" : "__unittestL772_1108",
        "kind" : "function",
        "line" : 772,
        "endline" : 800
       },
       {
        "name" : "fillUp",
        "kind" : "function",
        "line" : 800,
        "type" : "void()",
        "endline" : 995
       },
       {
        "kind" : "template",
        "line" : 998,
        "name" : "readUpToNextSpec",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "readUpToNextSpec",
          "kind" : "function",
          "line" : 998,
          "type" : "bool(ref R r)",
          "parameters" : [
           {
            "name" : "r",
            "type" : "R",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 1059
         }
        ]
       },
       {
        "name" : "getCurFmtStr",
        "kind" : "function",
        "line" : 1061,
        "type" : "string()",
        "endline" : 1080
       },
       {
        "name" : "__unittestL1082_1109",
        "kind" : "function",
        "line" : 1082,
        "endline" : 1093
       },
       {
        "name" : "headUpToNextSpec",
        "kind" : "function",
        "line" : 1093,
        "type" : "const(Char)[]()",
        "endline" : 1117
       },
       {
        "name" : "toString",
        "kind" : "function",
        "line" : 1119,
        "type" : "string()",
        "endline" : 1134
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1136_1110",
    "kind" : "function",
    "line" : 1136,
    "endline" : 1166
   },
   {
    "kind" : "template",
    "comment" : "\n   Helper function that returns a $(D FormatSpec) for a single specifier given\n   in $(D fmt)\n\n   Returns a $(D FormatSpec) with the specifier parsed.\n\n   Enforces giving only one specifier to the function.\n  \n",
    "line" : 1166,
    "name" : "singleSpec",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "singleSpec",
      "kind" : "function",
      "comment" : "\n   Helper function that returns a $(D FormatSpec) for a single specifier given\n   in $(D fmt)\n\n   Returns a $(D FormatSpec) with the specifier parsed.\n\n   Enforces giving only one specifier to the function.\n  \n",
      "line" : 1166,
      "type" : "FormatSpec!(Char)(Char[] fmt)",
      "parameters" : [
       {
        "name" : "fmt",
        "type" : "Char[]"
       }
      ],
      "endline" : 1183
     }
    ]
   },
   {
    "name" : "__unittestL1184_1111",
    "kind" : "function",
    "line" : 1184,
    "endline" : 1202
   },
   {
    "kind" : "template",
    "comment" : "\n   $(D bool)s are formatted as \"true\" or \"false\" with %s and as \"1\" or\n   \"0\" with integral-specific format specs.\n \n",
    "line" : 1202,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   $(D bool)s are formatted as \"true\" or \"false\" with %s and as \"1\" or\n   \"0\" with integral-specific format specs.\n \n",
      "line" : 1202,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1227
     }
    ]
   },
   {
    "name" : "__unittestL1229_1112",
    "kind" : "function",
    "line" : 1229,
    "endline" : 1251
   },
   {
    "name" : "__unittestL1251_1113",
    "kind" : "function",
    "line" : 1251,
    "endline" : 1263
   },
   {
    "kind" : "template",
    "comment" : "\n   $(D null) literal is formatted as $(D \"null\").\n \n",
    "line" : 1263,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   $(D null) literal is formatted as $(D \"null\").\n \n",
      "line" : 1263,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1269
     }
    ]
   },
   {
    "name" : "__unittestL1271_1114",
    "kind" : "function",
    "line" : 1271,
    "endline" : 1279
   },
   {
    "kind" : "template",
    "comment" : "\n   Integrals are formatted like $(D printf) does.\n \n",
    "line" : 1279,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Integrals are formatted like $(D printf) does.\n \n",
      "line" : 1279,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1310
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1312,
    "name" : "formatIntegral",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatIntegral",
      "kind" : "function",
      "line" : 1312,
      "type" : "void(Writer w, const(T) val, ref FormatSpec!(Char) f, ulong mask)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "const(T)"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "mask",
        "deco" : "m"
       }
      ],
      "endline" : 1336
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1338,
    "name" : "formatUnsigned",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatUnsigned",
      "kind" : "function",
      "line" : 1338,
      "type" : "void(Writer w, ulong arg, ref FormatSpec!(Char) fs, uint base, bool negative)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "arg",
        "deco" : "m"
       },
       {
        "name" : "fs",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "base",
        "deco" : "k"
       },
       {
        "name" : "negative",
        "deco" : "b"
       }
      ],
      "endline" : 1437
     }
    ]
   },
   {
    "name" : "__unittestL1439_1115",
    "kind" : "function",
    "line" : 1439,
    "endline" : 1457
   },
   {
    "name" : "__unittestL1457_1116",
    "kind" : "function",
    "line" : 1457,
    "endline" : 1502
   },
   {
    "kind" : "template",
    "comment" : "\n Floating-point values are formatted like $(D printf) does.\n \n",
    "line" : 1502,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n Floating-point values are formatted like $(D printf) does.\n \n",
      "line" : 1502,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1585
     }
    ]
   },
   {
    "name" : "__unittestL1587_1117",
    "kind" : "function",
    "line" : 1587,
    "endline" : 1597
   },
   {
    "name" : "__unittestL1597_1118",
    "kind" : "function",
    "line" : 1597,
    "endline" : 1614
   },
   {
    "name" : "__unittestL1614_1119",
    "kind" : "function",
    "line" : 1614,
    "endline" : 1625
   },
   {
    "kind" : "template",
    "line" : 1625,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "line" : 1625,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1634
     }
    ]
   },
   {
    "name" : "__unittestL1636_1120",
    "kind" : "function",
    "line" : 1636,
    "endline" : 1646
   },
   {
    "name" : "__unittestL1646_1121",
    "kind" : "function",
    "line" : 1646,
    "endline" : 1666
   },
   {
    "kind" : "template",
    "line" : 1666,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "line" : 1666,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1673
     }
    ]
   },
   {
    "name" : "__unittestL1675_1122",
    "kind" : "function",
    "line" : 1675,
    "endline" : 1685
   },
   {
    "name" : "__unittestL1685_1123",
    "kind" : "function",
    "line" : 1685,
    "endline" : 1707
   },
   {
    "kind" : "template",
    "comment" : "\n   Individual characters ($(D char), $(D wchar), or $(D dchar)) are\n   formatted as Unicode characters with %s and as integers with\n   integral-specific format specs.\n \n",
    "line" : 1707,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Individual characters ($(D char), $(D wchar), or $(D dchar)) are\n   formatted as Unicode characters with %s and as integers with\n   integral-specific format specs.\n \n",
      "line" : 1707,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1720
     }
    ]
   },
   {
    "name" : "__unittestL1722_1124",
    "kind" : "function",
    "line" : 1722,
    "endline" : 1742
   },
   {
    "kind" : "template",
    "comment" : "\n   Strings are formatted like $(D printf) does.\n \n",
    "line" : 1742,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Strings are formatted like $(D printf) does.\n \n",
      "line" : 1742,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1747
     }
    ]
   },
   {
    "name" : "__unittestL1749_1125",
    "kind" : "function",
    "line" : 1749,
    "endline" : 1754
   },
   {
    "name" : "__unittestL1754_1126",
    "kind" : "function",
    "line" : 1754,
    "endline" : 1769
   },
   {
    "name" : "__unittestL1769_1127",
    "kind" : "function",
    "line" : 1769,
    "endline" : 1783
   },
   {
    "kind" : "template",
    "comment" : "\n   Static-size arrays are formatted as dynamic arrays.\n \n",
    "line" : 1783,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Static-size arrays are formatted as dynamic arrays.\n \n",
      "line" : 1783,
      "type" : "void(Writer w, auto ref T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1787
     }
    ]
   },
   {
    "name" : "__unittestL1789_1128",
    "kind" : "function",
    "line" : 1789,
    "endline" : 1808
   },
   {
    "kind" : "template",
    "comment" : "\n   Dynamic arrays are formatted as input ranges.\n\n   Specializations:\n     $(UL $(LI $(D void[]) is formatted like $(D ubyte[]).)\n          $(LI Const array is converted to input range by removing its qualifier.))\n \n",
    "line" : 1808,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Dynamic arrays are formatted as input ranges.\n\n   Specializations:\n     $(UL $(LI $(D void[]) is formatted like $(D ubyte[]).)\n          $(LI Const array is converted to input range by removing its qualifier.))\n \n",
      "line" : 1808,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1826
     }
    ]
   },
   {
    "name" : "__unittestL1829_1129",
    "kind" : "function",
    "line" : 1829,
    "endline" : 1884
   },
   {
    "name" : "__unittestL1884_1130",
    "kind" : "function",
    "line" : 1884,
    "endline" : 1900
   },
   {
    "name" : "__unittestL1900_1131",
    "kind" : "function",
    "line" : 1900,
    "endline" : 1911
   },
   {
    "name" : "__unittestL1911_1132",
    "kind" : "function",
    "line" : 1911,
    "endline" : 1938
   },
   {
    "name" : "__unittestL1938_1133",
    "kind" : "function",
    "line" : 1938,
    "endline" : 1980
   },
   {
    "name" : "__unittestL1980_1134",
    "kind" : "function",
    "line" : 1980,
    "endline" : 1987
   },
   {
    "name" : "__unittestL1987_1135",
    "kind" : "function",
    "line" : 1987,
    "endline" : 2005
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2005,
    "name" : "formatRange",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatRange",
      "kind" : "function",
      "line" : 2005,
      "type" : "void(ref Writer w, ref T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "val",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2152
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2155,
    "name" : "formatChar",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatChar",
      "kind" : "function",
      "line" : 2155,
      "type" : "void(Writer w, in dchar c, in char quote)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "c",
        "deco" : "w",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "quote",
        "deco" : "a",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2184
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2188,
    "name" : "formatElement",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatElement",
      "kind" : "function",
      "line" : 2188,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2238
     }
    ]
   },
   {
    "name" : "__unittestL2240_1136",
    "kind" : "function",
    "line" : 2240,
    "endline" : 2258
   },
   {
    "kind" : "template",
    "line" : 2258,
    "name" : "formatElement",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatElement",
      "kind" : "function",
      "line" : 2258,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2269
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2273,
    "name" : "formatElement",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatElement",
      "kind" : "function",
      "line" : 2273,
      "type" : "void(Writer w, auto ref T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2277
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Associative arrays are formatted by using $(D ':') and $(D \", \") as\n   separators, and enclosed by $(D '[') and $(D ']').\n \n",
    "line" : 2283,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Associative arrays are formatted by using $(D ':') and $(D \", \") as\n   separators, and enclosed by $(D '[') and $(D ']').\n \n",
      "line" : 2283,
      "type" : "void(Writer w, T obj, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "obj",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2329
     }
    ]
   },
   {
    "name" : "__unittestL2331_1137",
    "kind" : "function",
    "line" : 2331,
    "endline" : 2354
   },
   {
    "name" : "__unittestL2354_1138",
    "kind" : "function",
    "line" : 2354,
    "endline" : 2370
   },
   {
    "kind" : "template",
    "line" : 2370,
    "name" : "hasToString",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2400,
    "name" : "formatObject",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatObject",
      "kind" : "function",
      "line" : 2400,
      "type" : "void(ref Writer w, ref T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "val",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2421
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2423,
    "name" : "enforceValidFormatSpec",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "enforceValidFormatSpec",
      "kind" : "function",
      "line" : 2423,
      "type" : "void(ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2430
     }
    ]
   },
   {
    "name" : "__unittestL2432_1152",
    "kind" : "function",
    "line" : 2432,
    "endline" : 2501
   },
   {
    "kind" : "template",
    "comment" : "\n   Aggregates ($(D struct), $(D union), $(D class), and $(D interface)) are\n   basically formatted by calling $(D toString).\n   $(D toString) should have one of the following signatures:\n\n---\nconst void toString(scope void delegate(const(char)[]) sink, FormatSpec fmt);\nconst void toString(scope void delegate(const(char)[]) sink, string fmt);\nconst void toString(scope void delegate(const(char)[]) sink);\nconst string toString();\n---\n\n   For the class objects which have input range interface,\n   $(UL $(LI If the instance $(D toString) has overridden\n             $(D Object.toString), it is used.)\n        $(LI Otherwise, the objects are formatted as input range.))\n\n   For the struct and union objects which does not have $(D toString),\n   $(UL $(LI If they have range interface, formatted as input range.)\n        $(LI Otherwise, they are formatted like $(D Type(field1, filed2, ...)).))\n\n   Otherwise, are formatted just as their type name.\n \n",
    "line" : 2501,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Aggregates ($(D struct), $(D union), $(D class), and $(D interface)) are\n   basically formatted by calling $(D toString).\n   $(D toString) should have one of the following signatures:\n\n---\nconst void toString(scope void delegate(const(char)[]) sink, FormatSpec fmt);\nconst void toString(scope void delegate(const(char)[]) sink, string fmt);\nconst void toString(scope void delegate(const(char)[]) sink);\nconst string toString();\n---\n\n   For the class objects which have input range interface,\n   $(UL $(LI If the instance $(D toString) has overridden\n             $(D Object.toString), it is used.)\n        $(LI Otherwise, the objects are formatted as input range.))\n\n   For the struct and union objects which does not have $(D toString),\n   $(UL $(LI If they have range interface, formatted as input range.)\n        $(LI Otherwise, they are formatted like $(D Type(field1, filed2, ...)).))\n\n   Otherwise, are formatted just as their type name.\n \n",
      "line" : 2501,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2540
     }
    ]
   },
   {
    "name" : "__unittestL2542_1153",
    "kind" : "function",
    "line" : 2542,
    "endline" : 2552
   },
   {
    "name" : "__unittestL2552_1154",
    "kind" : "function",
    "line" : 2552,
    "endline" : 2603
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2603,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2603,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2624
     }
    ]
   },
   {
    "name" : "__unittestL2626_1155",
    "kind" : "function",
    "line" : 2626,
    "endline" : 2647
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2647,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2647,
      "type" : "void(Writer w, auto ref T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2693
     }
    ]
   },
   {
    "name" : "__unittestL2695_1156",
    "kind" : "function",
    "line" : 2695,
    "endline" : 2706
   },
   {
    "name" : "__unittestL2706_1157",
    "kind" : "function",
    "line" : 2706,
    "endline" : 2715
   },
   {
    "name" : "__unittestL2715_1158",
    "kind" : "function",
    "line" : 2715,
    "endline" : 2738
   },
   {
    "name" : "__unittestL2738_1159",
    "kind" : "function",
    "line" : 2738,
    "endline" : 2761
   },
   {
    "name" : "__unittestL2761_1160",
    "kind" : "function",
    "line" : 2761,
    "endline" : 2775
   },
   {
    "kind" : "template",
    "comment" : "\n   $(D enum) is formatted like its base value.\n \n",
    "line" : 2775,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   $(D enum) is formatted like its base value.\n \n",
      "line" : 2775,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2794
     }
    ]
   },
   {
    "name" : "__unittestL2795_1161",
    "kind" : "function",
    "line" : 2795,
    "endline" : 2801
   },
   {
    "name" : "__unittestL2801_1162",
    "kind" : "function",
    "line" : 2801,
    "endline" : 2807
   },
   {
    "name" : "__unittestL2807_1163",
    "kind" : "function",
    "line" : 2807,
    "endline" : 2813
   },
   {
    "name" : "__unittestL2813_1164",
    "kind" : "function",
    "line" : 2813,
    "endline" : 2829
   },
   {
    "kind" : "template",
    "comment" : "\n   Pointers are formatted as hex integers.\n \n",
    "line" : 2829,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Pointers are formatted as hex integers.\n \n",
      "line" : 2829,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2857
     }
    ]
   },
   {
    "name" : "__unittestL2859_1165",
    "kind" : "function",
    "line" : 2859,
    "endline" : 2873
   },
   {
    "name" : "__unittestL2873_1166",
    "kind" : "function",
    "line" : 2873,
    "endline" : 2887
   },
   {
    "name" : "__unittestL2887_1167",
    "kind" : "function",
    "line" : 2887,
    "endline" : 2899
   },
   {
    "name" : "__unittestL2899_1168",
    "kind" : "function",
    "line" : 2899,
    "endline" : 2909
   },
   {
    "kind" : "template",
    "comment" : "\n   Delegates are formatted by 'Attributes ReturnType delegate(Parameters)'\n \n",
    "line" : 2909,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "comment" : "\n   Delegates are formatted by 'Attributes ReturnType delegate(Parameters)'\n \n",
      "line" : 2909,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2922
     }
    ]
   },
   {
    "name" : "__unittestL2924_1169",
    "kind" : "function",
    "line" : 2924,
    "endline" : 2933
   },
   {
    "kind" : "template",
    "line" : 2933,
    "name" : "formatValue",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatValue",
      "kind" : "function",
      "line" : 2933,
      "type" : "void(Writer w, T val, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "val",
        "type" : "T"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2940
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2948,
    "name" : "formatGeneric",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "D",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "formatGeneric",
      "kind" : "function",
      "line" : 2948,
      "type" : "void(Writer w, const(void)* arg, ref FormatSpec!(Char) f)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "arg",
        "type" : "const(void)*"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2951
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2953,
    "name" : "formatNth",
    "parameters" : [
     {
      "name" : "Writer",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     },
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "formatNth",
      "kind" : "function",
      "line" : 2953,
      "type" : "void(Writer w, ref FormatSpec!(Char) f, size_t index, A args)",
      "parameters" : [
       {
        "name" : "w",
        "type" : "Writer"
       },
       {
        "name" : "f",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t"
       },
       {
        "name" : "args",
        "type" : "A"
       }
      ],
      "endline" : 2976
     }
    ]
   },
   {
    "name" : "__unittestL2978_1170",
    "kind" : "function",
    "line" : 2978,
    "endline" : 2993
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2993,
    "name" : "getNthInt",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "getNthInt",
      "kind" : "function",
      "line" : 2993,
      "type" : "int(uint index, A args)",
      "parameters" : [
       {
        "name" : "index",
        "deco" : "k"
       },
       {
        "name" : "args",
        "type" : "A"
       }
      ],
      "endline" : 3014
     }
    ]
   },
   {
    "name" : "__unittestL3039_1171",
    "kind" : "function",
    "line" : 3039,
    "endline" : 3056
   },
   {
    "name" : "__unittestL3056_1172",
    "kind" : "function",
    "line" : 3056,
    "endline" : 3063
   },
   {
    "name" : "__unittestL3063_1173",
    "kind" : "function",
    "line" : 3063,
    "endline" : 3077
   },
   {
    "name" : "__unittestL3077_1174",
    "kind" : "function",
    "line" : 3077,
    "endline" : 3094
   },
   {
    "name" : "__unittestL3094_1175",
    "kind" : "function",
    "line" : 3094,
    "endline" : 3541
   },
   {
    "name" : "__unittestL3541_1176",
    "kind" : "function",
    "line" : 3541,
    "endline" : 3580
   },
   {
    "name" : "__unittestL3580_1177",
    "kind" : "function",
    "line" : 3580,
    "endline" : 3590
   },
   {
    "name" : "__unittestL3637_1180",
    "kind" : "function",
    "line" : 3637,
    "endline" : 3729
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3729,
    "name" : "skipData",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "skipData",
      "kind" : "function",
      "line" : 3729,
      "type" : "void(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3744
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3746,
    "name" : "acceptedSpecs",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n Reads a boolean value and returns it.\n \n",
    "line" : 3757,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n Reads a boolean value and returns it.\n \n",
      "line" : 3757,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3768
     }
    ]
   },
   {
    "name" : "__unittestL3770_1181",
    "kind" : "function",
    "line" : 3770,
    "endline" : 3812
   },
   {
    "kind" : "template",
    "comment" : "\n Reads null literal and returns it.\n \n",
    "line" : 3812,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n Reads null literal and returns it.\n \n",
      "line" : 3812,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3819
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Reads an integral value and returns it.\n \n",
    "line" : 3824,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n   Reads an integral value and returns it.\n \n",
      "line" : 3824,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3839
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Reads a floating-point value and returns it.\n \n",
    "line" : 3844,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n   Reads a floating-point value and returns it.\n \n",
      "line" : 3844,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3878
     }
    ]
   },
   {
    "name" : "__unittestL3895_1183",
    "kind" : "function",
    "line" : 3895,
    "endline" : 3920
   },
   {
    "kind" : "template",
    "comment" : "\n Reads one character and returns it.\n \n",
    "line" : 3920,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n Reads one character and returns it.\n \n",
      "line" : 3920,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3940
     }
    ]
   },
   {
    "name" : "__unittestL3942_1184",
    "kind" : "function",
    "line" : 3942,
    "endline" : 3957
   },
   {
    "kind" : "template",
    "comment" : "\n   Reads a string and returns it.\n \n",
    "line" : 3957,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n   Reads a string and returns it.\n \n",
      "line" : 3957,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4002
     }
    ]
   },
   {
    "name" : "__unittestL4004_1185",
    "kind" : "function",
    "line" : 4004,
    "endline" : 4033
   },
   {
    "kind" : "template",
    "comment" : "\n   Reads an array (except for string types) and returns it.\n \n",
    "line" : 4033,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n   Reads an array (except for string types) and returns it.\n \n",
      "line" : 4033,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4044
     }
    ]
   },
   {
    "name" : "__unittestL4046_1186",
    "kind" : "function",
    "line" : 4046,
    "endline" : 4056
   },
   {
    "name" : "__unittestL4056_1187",
    "kind" : "function",
    "line" : 4056,
    "endline" : 4081
   },
   {
    "name" : "__unittestL4081_1188",
    "kind" : "function",
    "line" : 4081,
    "endline" : 4099
   },
   {
    "name" : "__unittestL4099_1189",
    "kind" : "function",
    "line" : 4099,
    "endline" : 4113
   },
   {
    "name" : "__unittestL4113_1190",
    "kind" : "function",
    "line" : 4113,
    "endline" : 4126
   },
   {
    "kind" : "template",
    "comment" : "\n Reads an associative array and returns it.\n \n",
    "line" : 4126,
    "name" : "unformatValue",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatValue",
      "kind" : "function",
      "comment" : "\n Reads an associative array and returns it.\n \n",
      "line" : 4126,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4137
     }
    ]
   },
   {
    "name" : "__unittestL4139_1191",
    "kind" : "function",
    "line" : 4139,
    "endline" : 4161
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4161,
    "name" : "unformatRange",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatRange",
      "kind" : "function",
      "line" : 4161,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4258
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 4261,
    "name" : "unformatElement",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unformatElement",
      "kind" : "function",
      "line" : 4261,
      "type" : "T(ref Range input, ref FormatSpec!(Char) spec)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "spec",
        "type" : "FormatSpec!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 4280
     }
    ]
   },
   {
    "name" : "Mangle",
    "kind" : "enum",
    "line" : 4285,
    "baseDeco" : "a",
    "members" : [
     {
      "name" : "Tvoid",
      "kind" : "enum member",
      "line" : 4287
     },
     {
      "name" : "Tbool",
      "kind" : "enum member",
      "line" : 4288
     },
     {
      "name" : "Tbyte",
      "kind" : "enum member",
      "line" : 4289
     },
     {
      "name" : "Tubyte",
      "kind" : "enum member",
      "line" : 4290
     },
     {
      "name" : "Tshort",
      "kind" : "enum member",
      "line" : 4291
     },
     {
      "name" : "Tushort",
      "kind" : "enum member",
      "line" : 4292
     },
     {
      "name" : "Tint",
      "kind" : "enum member",
      "line" : 4293
     },
     {
      "name" : "Tuint",
      "kind" : "enum member",
      "line" : 4294
     },
     {
      "name" : "Tlong",
      "kind" : "enum member",
      "line" : 4295
     },
     {
      "name" : "Tulong",
      "kind" : "enum member",
      "line" : 4296
     },
     {
      "name" : "Tfloat",
      "kind" : "enum member",
      "line" : 4297
     },
     {
      "name" : "Tdouble",
      "kind" : "enum member",
      "line" : 4298
     },
     {
      "name" : "Treal",
      "kind" : "enum member",
      "line" : 4299
     },
     {
      "name" : "Tifloat",
      "kind" : "enum member",
      "line" : 4301
     },
     {
      "name" : "Tidouble",
      "kind" : "enum member",
      "line" : 4302
     },
     {
      "name" : "Tireal",
      "kind" : "enum member",
      "line" : 4303
     },
     {
      "name" : "Tcfloat",
      "kind" : "enum member",
      "line" : 4304
     },
     {
      "name" : "Tcdouble",
      "kind" : "enum member",
      "line" : 4305
     },
     {
      "name" : "Tcreal",
      "kind" : "enum member",
      "line" : 4306
     },
     {
      "name" : "Tchar",
      "kind" : "enum member",
      "line" : 4308
     },
     {
      "name" : "Twchar",
      "kind" : "enum member",
      "line" : 4309
     },
     {
      "name" : "Tdchar",
      "kind" : "enum member",
      "line" : 4310
     },
     {
      "name" : "Tarray",
      "kind" : "enum member",
      "line" : 4312
     },
     {
      "name" : "Tsarray",
      "kind" : "enum member",
      "line" : 4313
     },
     {
      "name" : "Taarray",
      "kind" : "enum member",
      "line" : 4314
     },
     {
      "name" : "Tpointer",
      "kind" : "enum member",
      "line" : 4315
     },
     {
      "name" : "Tfunction",
      "kind" : "enum member",
      "line" : 4316
     },
     {
      "name" : "Tident",
      "kind" : "enum member",
      "line" : 4317
     },
     {
      "name" : "Tclass",
      "kind" : "enum member",
      "line" : 4318
     },
     {
      "name" : "Tstruct",
      "kind" : "enum member",
      "line" : 4319
     },
     {
      "name" : "Tenum",
      "kind" : "enum member",
      "line" : 4320
     },
     {
      "name" : "Ttypedef",
      "kind" : "enum member",
      "line" : 4321
     },
     {
      "name" : "Tdelegate",
      "kind" : "enum member",
      "line" : 4322
     },
     {
      "name" : "Tconst",
      "kind" : "enum member",
      "line" : 4324
     },
     {
      "name" : "Timmutable",
      "kind" : "enum member",
      "line" : 4325
     }
    ]
   },
   {
    "name" : "primitiveTypeInfo",
    "kind" : "function",
    "protection" : "private",
    "line" : 4332,
    "deco" : "FE3std6format6MangleZC8TypeInfo",
    "parameters" : [
     {
      "name" : "m",
      "deco" : "E3std6format6Mangle"
     }
    ],
    "endline" : 4364
   },
   {
    "name" : "doFormat",
    "kind" : "function",
    "line" : 4625,
    "deco" : "FDFwZvAC8TypeInfoPvZv",
    "originalType" : "void(void delegate(dchar) putc, TypeInfo[] arguments, va_list argptr)",
    "parameters" : [
     {
      "name" : "putc",
      "deco" : "DFwZv"
     },
     {
      "name" : "arguments",
      "deco" : "AC8TypeInfo"
     },
     {
      "name" : "argptr",
      "deco" : "Pv"
     }
    ],
    "endline" : 5570
   },
   {
    "name" : "__unittestL5574_1192",
    "kind" : "function",
    "line" : 5574,
    "endline" : 5870
   },
   {
    "name" : "__unittestL5870_1193",
    "kind" : "function",
    "line" : 5870,
    "endline" : 5877
   }
  ]
 },
 {
  "name" : "std.functional",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/functional.d",
  "comment" : "\nFunctions that manipulate other functions.\n\nMacros:\n\nWIKI = Phobos/StdFunctional\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nSource:    $(PHOBOSSRC std/_functional.d)\n",
  "members" : [
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\nTransforms a string representing an expression into a unary\nfunction. The string must use symbol name $(D a) as the parameter.\n\nExample:\n\n----\nalias unaryFun!(\"(a & 1) == 0\") isEven;\nassert(isEven(2) && !isEven(1));\n----\n",
    "line" : 39,
    "name" : "unaryFun",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "byRef",
      "kind" : "value",
      "deco" : "b",
      "defaultValue" : "false"
     },
     {
      "name" : "parmName",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "\"a\""
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL66_1194",
    "kind" : "function",
    "line" : 66,
    "endline" : 96
   },
   {
    "kind" : "template",
    "comment" : "\nTransforms a string representing an expression into a Boolean binary\npredicate. The string must use symbol names $(D a) and $(D b) as the\ncompared elements.\n\n   Example:\n\n----\nalias binaryFun!(\"a < b\") less;\nassert(less(1, 2) && !less(2, 1));\nalias binaryFun!(\"a > b\") greater;\nassert(!greater(\"1\", \"2\") && greater(\"2\", \"1\"));\n----\n",
    "line" : 96,
    "name" : "binaryFun",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "parm1Name",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "\"a\""
     },
     {
      "name" : "parm2Name",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "\"b\""
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL115_1195",
    "kind" : "function",
    "line" : 115,
    "endline" : 152
   },
   {
    "kind" : "template",
    "comment" : "\n   Binary predicate that reverses the order of arguments, e.g., given\n   $(D pred(a, b)), returns $(D pred(b, a)).\n",
    "line" : 152,
    "name" : "binaryReverseArgs",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 155,
      "name" : "binaryReverseArgs",
      "parameters" : [
       {
        "name" : "ElementType1",
        "kind" : "type"
       },
       {
        "name" : "ElementType2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "binaryReverseArgs",
        "kind" : "function",
        "line" : 155,
        "storageClass" : [
         "auto"
        ],
        "type" : "(ElementType1 a, ElementType2 b)",
        "parameters" : [
         {
          "name" : "a",
          "type" : "ElementType1"
         },
         {
          "name" : "b",
          "type" : "ElementType2"
         }
        ],
        "endline" : 158
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL161_1196",
    "kind" : "function",
    "line" : 161,
    "endline" : 182
   },
   {
    "kind" : "template",
    "comment" : "\nNegates predicate $(D pred).\n\nExample:\n----\nstring a = \"   Hello, world!\";\nassert(find!(not!isWhite)(a) == \"Hello, world!\");\n----\n \n",
    "line" : 182,
    "name" : "not",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 184,
      "name" : "not",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "not",
        "kind" : "function",
        "line" : 184,
        "storageClass" : [
         "auto"
        ],
        "type" : "(T args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "T"
         }
        ],
        "endline" : 193
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nCurries $(D fun) by tying its first argument to a particular value.\n\nExample:\n\n----\nint fun(int a, int b) { return a + b; }\nalias curry!(fun, 5) fun5;\nassert(fun5(6) == 11);\n----\n\nNote that in most cases you'd use an alias instead of a value\nassignment. Using an alias allows you to curry template functions\nwithout committing to a particular type of the function.\n \n",
    "line" : 211,
    "name" : "curry",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "arg",
      "kind" : "alias"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL246_1197",
    "kind" : "function",
    "line" : 246,
    "endline" : 276
   },
   {
    "name" : "__unittestL276_1198",
    "kind" : "function",
    "line" : 276,
    "endline" : 353
   },
   {
    "kind" : "template",
    "comment" : "\nTakes multiple functions and adjoins them together. The result is a\n$(XREF typecons, Tuple) with one element per passed-in function. Upon\ninvocation, the returned tuple is the adjoined results of all\nfunctions.\n\nExample:\n\n----\nstatic bool f1(int a) { return a != 0; }\nstatic int f2(int a) { return a / 2; }\nauto x = adjoin!(f1, f2)(5);\nassert(is(typeof(x) == Tuple!(bool, int)));\nassert(x[0] == true && x[1] == 2);\n----\n",
    "line" : 353,
    "name" : "adjoin",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 355,
      "name" : "adjoin",
      "parameters" : [
       {
        "name" : "V",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "adjoin",
        "kind" : "function",
        "line" : 355,
        "storageClass" : [
         "auto"
        ],
        "type" : "(V a)",
        "parameters" : [
         {
          "name" : "a",
          "type" : "V"
         }
        ],
        "endline" : 375
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL378_1200",
    "kind" : "function",
    "line" : 378,
    "endline" : 457
   },
   {
    "kind" : "template",
    "comment" : "\n   Composes passed-in functions $(D fun[0], fun[1], ...) returning a\n   function $(D f(x)) that in turn returns $(D\n   fun[0](fun[1](...(x)))...). Each function can be a regular\n   functions, a delegate, or a string.\n\n   Example:\n\n----\n// First split a string in whitespace-separated tokens and then\n// convert each token into an integer\nassert(compose!(map!(to!(int)), split)(\"1 2 3\") == [1, 2, 3]);\n----\n",
    "line" : 457,
    "name" : "compose",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n   Pipes functions in sequence. Offers the same functionality as $(D\n   compose), but with functions specified in reverse order. This may\n   lead to more readable code in some situation because the order of\n   execution is the same as lexical order.\n\n   Example:\n\n----\n// Read an entire text file, split the resulting string in\n// whitespace-separated tokens, and then convert each token into an\n// integer\nint[] a = pipe!(readText, split, map!(to!(int)))(\"file.txt\");\n----\n \n",
    "line" : 497,
    "name" : "pipe",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "pipe",
      "kind" : "alias",
      "line" : 499,
      "type" : "compose!(Reverse!(fun))"
     }
    ]
   },
   {
    "name" : "__unittestL502_1202",
    "kind" : "function",
    "line" : 502,
    "endline" : 596
   },
   {
    "kind" : "template",
    "comment" : "\n $(LUCKY Memoizes) a function so as to avoid repeated\n computation. The memoization structure is a hash table keyed by a\n tuple of the function's arguments. There is a speed gain if the\n function is repeatedly called with the same arguments and is more\n expensive than a hash table lookup. For more information on memoization, refer to $(WEB docs.google.com/viewer?url=http%3A%2F%2Fhop.perl.plover.com%2Fbook%2Fpdf%2F03CachingAndMemoization.pdf, this book chapter).\n\nExample:\n----\ndouble transmogrify(int a, string b)\n{\n   ... expensive computation ...\n}\nalias memoize!transmogrify fastTransmogrify;\nunittest\n{\n    auto slow = transmogrify(2, \"hello\");\n    auto fast = fastTransmogrify(2, \"hello\");\n    assert(slow == fast);\n}\n----\n\nTechnically the memoized function should be pure because $(D memoize) assumes it will\nalways return the same result for a given tuple of arguments. However, $(D memoize) does not\nenforce that because sometimes it\nis useful to memoize an impure function, too.\n\nTo _memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call.\nFor example, to transform the exponential-time Fibonacci implementation into a linear-time computation:\n\nExample:\n----\nulong fib(ulong n)\n{\n    alias memoize!fib mfib;\n    return n < 2 ? 1 : mfib(n - 2) + mfib(n - 1);\n}\n...\nassert(fib(10) == 89);\n----\n\nTo improve the speed of the factorial function,\n\nExample:\n----\nulong fact(ulong n)\n{\n    alias memoize!fact mfact;\n    return n < 2 ? 1 : n * mfact(n - 1);\n}\n...\nassert(fact(10) == 3628800);\n----\n\nThis memoizes all values of $(D fact) up to the largest argument. To only cache the final\nresult, move $(D memoize) outside the function as shown below.\n\nExample:\n----\nulong factImpl(ulong n)\n{\n    return n < 2 ? 1 : n * mfact(n - 1);\n}\nalias memoize!factImpl fact;\n...\nassert(fact(10) == 3628800);\n----\n\nThe $(D maxSize) parameter is a cutoff for the cache size. If upon a miss the length of the hash\ntable is found to be $(D maxSize), the table is simply cleared.\n\nExample:\n----\n// Memoize no more than 128 values of transmogrify\nalias memoize!(transmogrify, 128) fastTransmogrify;\n----\n",
    "line" : 596,
    "name" : "memoize",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "maxSize",
      "kind" : "value",
      "deco" : "k",
      "defaultValue" : "(uint).max"
     }
    ],
    "members" : [
     {
      "name" : "memoize",
      "kind" : "function",
      "line" : 598,
      "type" : "ReturnType!(fun)(ParameterTypeTuple!(fun) args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "ParameterTypeTuple!(fun)"
       }
      ],
      "endline" : 612
     }
    ]
   },
   {
    "name" : "__unittestL615_1204",
    "kind" : "function",
    "line" : 615,
    "endline" : 646
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 646,
    "name" : "DelegateFaker",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "DelegateFaker",
      "kind" : "struct",
      "line" : 646,
      "members" : [
       {
        "kind" : "template",
        "line" : 648,
        "name" : "castToF",
        "parameters" : [
         {
          "name" : "THIS",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "castToF",
          "kind" : "function",
          "line" : 648,
          "type" : "@trusted F(THIS x)",
          "parameters" : [
           {
            "name" : "x",
            "type" : "THIS"
           }
          ],
          "endline" : 651
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 669,
        "name" : "GeneratingPolicy",
        "parameters" : [],
        "members" : [
         {
          "name" : "WITHOUT_SYMBOL",
          "kind" : "variable",
          "line" : 672,
          "storageClass" : [
           "enum"
          ],
          "init" : "true"
         },
         {
          "kind" : "template",
          "line" : 675,
          "name" : "generateFunctionBody",
          "parameters" : [
           {
            "name" : "unused",
            "kind" : "tuple"
           }
          ],
          "members" : [
           {
            "name" : "generateFunctionBody",
            "kind" : "variable",
            "line" : 687,
            "storageClass" : [
             "enum"
            ],
            "init" : "\"\\x0a                // When this function gets called, the this pointer isn't\\x0a                // really a this pointer (no instance even really exists), but\\x0a                // a function pointer that points to the function to be called.\\x0a                // Cast it to the correct type and call it.\\x0a\\x0a                auto fp = castToF(&this);\\x0a                return fp(args);\\x0a            \""
           }
          ]
         }
        ]
       },
       {
        "name" : "FuncInfo_doIt",
        "kind" : "alias",
        "line" : 691,
        "type" : "FuncInfo!(F)"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Convert a callable to a delegate with the same parameter list and\n return type, avoiding heap allocations and use of auxiliary storage.\n\n Examples:\n ----\n void doStuff() {\n     writeln(\"Hello, world.\");\n }\n\n void runDelegate(void delegate() myDelegate) {\n     myDelegate();\n }\n\n auto delegateToPass = toDelegate(&doStuff);\n runDelegate(delegateToPass);  // Calls doStuff, prints \"Hello, world.\"\n ----\n\n BUGS:\n $(UL\n   $(LI Does not work with $(D @safe) functions.)\n   $(LI Ignores C-style / D-style variadic arguments.)\n )\n \n",
    "line" : 722,
    "name" : "toDelegate",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toDelegate",
      "kind" : "function",
      "comment" : "\n Convert a callable to a delegate with the same parameter list and\n return type, avoiding heap allocations and use of auxiliary storage.\n\n Examples:\n ----\n void doStuff() {\n     writeln(\"Hello, world.\");\n }\n\n void runDelegate(void delegate() myDelegate) {\n     myDelegate();\n }\n\n auto delegateToPass = toDelegate(&doStuff);\n runDelegate(delegateToPass);  // Calls doStuff, prints \"Hello, world.\"\n ----\n\n BUGS:\n $(UL\n   $(LI Does not work with $(D @safe) functions.)\n   $(LI Ignores C-style / D-style variadic arguments.)\n )\n \n",
      "line" : 722,
      "storageClass" : [
       "auto"
      ],
      "type" : "(auto ref F fp)",
      "parameters" : [
       {
        "name" : "fp",
        "type" : "F",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 762
     }
    ]
   },
   {
    "name" : "__unittestL764_1205",
    "kind" : "function",
    "line" : 764,
    "endline" : 856
   }
  ]
 },
 {
  "name" : "std.getopt",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/getopt.d",
  "comment" : "\nProcessing of command line options.\n\nThe getopt module implements a $(D getopt) function, which adheres to\nthe POSIX syntax for command line options. GNU extensions are\nsupported in the form of long options introduced by a double dash\n(\"--\"). Support for bundling of command line options, as was the case\nwith the more traditional single-letter approach, is provided but not\nenabled by default.\n\nMacros:\n\nWIKI = Phobos/StdGetopt\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\nCredits:   This module and its documentation are inspired by Perl's $(WEB\n                   perldoc.perl.org/Getopt/Long.html, Getopt::Long) module. The syntax of\n                   D's $(D getopt) is simpler than its Perl counterpart because $(D\n                   getopt) infers the expected parameter types from the static types of\n                   the passed-in pointers.\nSource:    $(PHOBOSSRC std/_getopt.d)\n",
  "members" : [
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.bitmanip",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\n Synopsis:\n\n---------\nimport std.getopt;\n\nstring data = \"file.dat\";\nint length = 24;\nbool verbose;\nenum Color { no, yes };\nColor color;\n\nvoid main(string[] args)\n{\n  getopt(\n    args,\n    \"length\",  &length,    // numeric\n    \"file\",    &data,      // string\n    \"verbose\", &verbose,   // flag\n    \"color\",   &color);    // enum\n  ...\n}\n---------\n\n The $(D getopt) function takes a reference to the command line\n (as received by $(D main)) as its first argument, and an\n unbounded number of pairs of strings and pointers. Each string is an\n option meant to \"fill\" the value pointed-to by the pointer to its\n right (the \"bound\" pointer). The option string in the call to\n $(D getopt) should not start with a dash.\n\n In all cases, the command-line options that were parsed and used by\n $(D getopt) are removed from $(D args). Whatever in the\n arguments did not look like an option is left in $(D args) for\n further processing by the program. Values that were unaffected by the\n options are not touched, so a common idiom is to initialize options\n to their defaults and then invoke $(D getopt). If a\n command-line argument is recognized as an option with a parameter and\n the parameter cannot be parsed properly (e.g. a number is expected\n but not present), a $(D ConvException) exception is thrown.\n\n Depending on the type of the pointer being bound, $(D getopt)\n recognizes the following kinds of options:\n\n $(OL $(LI $(I Boolean options). A lone argument sets the option to $(D true).\n Additionally $(B true) or $(B false) can be set within the option separated with\n an \"=\" sign:\n\n---------\n  bool verbose = false, debugging = true;\n  getopt(args, \"verbose\", &verbose, \"debug\", &debugging);\n---------\n\n To set $(D verbose) to $(D true), invoke the program with either $(D\n --verbose) or $(D --verbose=true).\n\n To set $(D debugging) to $(D false), invoke the program with $(D --debugging=false).\n\n )$(LI $(I Numeric options.) If an option is bound to a numeric type, a\n number is expected as the next option, or right within the option\n separated with an \"=\" sign:\n\n---------\n  uint timeout;\n  getopt(args, \"timeout\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), invoke the program with either $(D\n--timeout=5) or $(D --timeout 5).\n\n $(UL $(LI $(I Incremental options.) If an option name has a \"+\" suffix and\n is bound to a numeric type, then the option's value tracks the number\n of times the option occurred on the command line:\n\n---------\n  uint paranoid;\n  getopt(args, \"paranoid+\", &paranoid);\n---------\n\n Invoking the program with \"--paranoid --paranoid --paranoid\" will set\n $(D paranoid) to 3. Note that an incremental option never\n expects a parameter, e.g. in the command line \"--paranoid 42\n --paranoid\", the \"42\" does not set $(D paranoid) to 42;\n instead, $(D paranoid) is set to 2 and \"42\" is not considered\n as part of the normal program arguments.)))\n\n $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as a\n string is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\n  enum Color { no, yes };\n  Color color; // default initialized to Color.no\n  getopt(args, \"color\", &color);\n---------\n\nTo set $(D color) to $(D Color.yes), invoke the program with either $(D\n--color=yes) or $(D --color yes).)\n\n $(LI $(I String options.) If an option is bound to a string, a string\n is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\nstring outputFile;\ngetopt(args, \"output\", &outputFile);\n---------\n\n Invoking the program with \"--output=myfile.txt\" or \"--output\n myfile.txt\" will set $(D outputFile) to \"myfile.txt\". If you want to\n pass a string containing spaces, you need to use the quoting that is\n appropriate to your shell, e.g. --output='my file.txt'.)\n\n $(LI $(I Array options.) If an option is bound to an array, a new\n element is appended to the array each time the option occurs:\n\n---------\nstring[] outputFiles;\ngetopt(args, \"output\", &outputFiles);\n---------\n\n Invoking the program with \"--output=myfile.txt --output=yourfile.txt\"\n or \"--output myfile.txt --output yourfile.txt\" will set $(D\n outputFiles) to [ \"myfile.txt\", \"yourfile.txt\" ] .)\n\n $(LI $(I Hash options.) If an option is bound to an associative\n array, a string of the form \"name=value\" is expected as the next\n option, or right within the option separated with an \"=\" sign:\n\n---------\ndouble[string] tuningParms;\ngetopt(args, \"tune\", &tuningParms);\n---------\n\nInvoking the program with e.g. \"--tune=alpha=0.5 --tune beta=0.6\" will\nset $(D tuningParms) to [ \"alpha\" : 0.5, \"beta\" : 0.6 ]. In general,\nkeys and values can be of any parsable types.)\n\n$(LI $(I Delegate options.) An option can be bound to a delegate with\nthe signature $(D void delegate()), $(D void delegate(string option))\nor $(D void delegate(string option, string value)).\n\n$(UL $(LI In the $(D void delegate()) case, the delegate is invoked\nwhenever the option is seen.) $(LI In the $(D void delegate(string\noption)) case, the option string (without the leading dash(es)) is\npassed to the delegate. After that, the option string is considered\nhandled and removed from the options array.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option)\n  {\n    if (option == \"quiet\")\n    {\n      verbosityLevel = 0;\n    }\n    else\n    {\n      assert(option == \"verbose\");\n      verbosityLevel = 2;\n    }\n  }\n  getopt(args, \"verbose\", &myHandler, \"quiet\", &myHandler);\n}\n---------\n\n)$(LI In the $(D void delegate(string option, string value)) case, the\noption string is handled as an option with one argument, and parsed\naccordingly. The option and its value are passed to the\ndelegate. After that, whatever was passed to the delegate is\nconsidered handled and removed from the list.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option, string value)\n  {\n    switch (value)\n    {\n      case \"quiet\": verbosityLevel = 0; break;\n      case \"verbose\": verbosityLevel = 2; break;\n      case \"shouting\": verbosityLevel = verbosityLevel.max; break;\n      default :\n        stderr.writeln(\"Dunno how verbose you want me to be by saying \",\n          value);\n        exit(1);\n    }\n  }\n  getopt(args, \"verbosity\", &myHandler);\n}\n---------\n))))\n\n$(B Options with multiple names)\n\nSometimes option synonyms are desirable, e.g. \"--verbose\",\n\"--loquacious\", and \"--garrulous\" should have the same effect. Such\nalternate option names can be included in the option specification,\nusing \"|\" as a separator:\n\n---------\nbool verbose;\ngetopt(args, \"verbose|loquacious|garrulous\", &verbose);\n---------\n\n$(B Case)\n\nBy default options are case-insensitive. You can change that behavior\nby passing $(D getopt) the $(D caseSensitive) directive like this:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nIn the example above, \"--foo\", \"--bar\", \"--FOo\", \"--bAr\" etc. are recognized.\nThe directive is active til the end of $(D getopt), or until the\nconverse directive $(D caseInsensitive) is encountered:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    std.getopt.config.caseInsensitive,\n    \"bar\", &bar);\n---------\n\nThe option \"--Foo\" is rejected due to $(D\nstd.getopt.config.caseSensitive), but not \"--Bar\", \"--bAr\"\netc. because the directive $(D\nstd.getopt.config.caseInsensitive) turned sensitivity off before\noption \"bar\" was parsed.\n\n$(B \"Short\" versus \"long\" options)\n\nTraditionally, programs accepted single-letter options preceded by\nonly one dash (e.g. $(D -t)). $(D getopt) accepts such parameters\nseamlessly. When used with a double-dash (e.g. $(D --t)), a\nsingle-letter option behaves the same as a multi-letter option. When\nused with a single dash, a single-letter option is accepted. If the\noption has a parameter, that must be \"stuck\" to the option without\nany intervening space or \"=\":\n\n---------\nuint timeout;\ngetopt(args, \"timeout|t\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), use either of the following: $(D --timeout=5),\n$(D --timeout 5), $(D --t=5), $(D --t 5), or $(D -t5). Forms such as $(D -t 5)\nand $(D -timeout=5) will be not accepted.\n\nFor more details about short options, refer also to the next section.\n\n$(B Bundling)\n\nSingle-letter options can be bundled together, i.e. \"-abc\" is the same as\n$(D \"-a -b -c\"). By default, this confusing option is turned off. You can\nturn it on with the $(D std.getopt.config.bundling) directive:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.bundling,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nIn case you want to only enable bundling for some of the parameters,\nbundling can be turned off with $(D std.getopt.config.noBundling).\n\n$(B Passing unrecognized options through)\n\nIf an application needs to do its own processing of whichever arguments\n$(D getopt) did not understand, it can pass the\n$(D std.getopt.config.passThrough) directive to $(D getopt):\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.passThrough,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nAn unrecognized option such as \"--baz\" will be found untouched in\n$(D args) after $(D getopt) returns.\n\n$(B Options Terminator)\n\nA lonesome double-dash terminates $(D getopt) gathering. It is used to\nseparate program options from other parameters (e.g. options to be passed\nto another program). Invoking the example above with $(D \"--foo -- --bar\")\nparses foo but leaves \"--bar\" in $(D args). The double-dash itself is\nremoved from the argument array.\n",
    "line" : 347,
    "name" : "getopt",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "getopt",
      "kind" : "function",
      "comment" : "\n Synopsis:\n\n---------\nimport std.getopt;\n\nstring data = \"file.dat\";\nint length = 24;\nbool verbose;\nenum Color { no, yes };\nColor color;\n\nvoid main(string[] args)\n{\n  getopt(\n    args,\n    \"length\",  &length,    // numeric\n    \"file\",    &data,      // string\n    \"verbose\", &verbose,   // flag\n    \"color\",   &color);    // enum\n  ...\n}\n---------\n\n The $(D getopt) function takes a reference to the command line\n (as received by $(D main)) as its first argument, and an\n unbounded number of pairs of strings and pointers. Each string is an\n option meant to \"fill\" the value pointed-to by the pointer to its\n right (the \"bound\" pointer). The option string in the call to\n $(D getopt) should not start with a dash.\n\n In all cases, the command-line options that were parsed and used by\n $(D getopt) are removed from $(D args). Whatever in the\n arguments did not look like an option is left in $(D args) for\n further processing by the program. Values that were unaffected by the\n options are not touched, so a common idiom is to initialize options\n to their defaults and then invoke $(D getopt). If a\n command-line argument is recognized as an option with a parameter and\n the parameter cannot be parsed properly (e.g. a number is expected\n but not present), a $(D ConvException) exception is thrown.\n\n Depending on the type of the pointer being bound, $(D getopt)\n recognizes the following kinds of options:\n\n $(OL $(LI $(I Boolean options). A lone argument sets the option to $(D true).\n Additionally $(B true) or $(B false) can be set within the option separated with\n an \"=\" sign:\n\n---------\n  bool verbose = false, debugging = true;\n  getopt(args, \"verbose\", &verbose, \"debug\", &debugging);\n---------\n\n To set $(D verbose) to $(D true), invoke the program with either $(D\n --verbose) or $(D --verbose=true).\n\n To set $(D debugging) to $(D false), invoke the program with $(D --debugging=false).\n\n )$(LI $(I Numeric options.) If an option is bound to a numeric type, a\n number is expected as the next option, or right within the option\n separated with an \"=\" sign:\n\n---------\n  uint timeout;\n  getopt(args, \"timeout\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), invoke the program with either $(D\n--timeout=5) or $(D --timeout 5).\n\n $(UL $(LI $(I Incremental options.) If an option name has a \"+\" suffix and\n is bound to a numeric type, then the option's value tracks the number\n of times the option occurred on the command line:\n\n---------\n  uint paranoid;\n  getopt(args, \"paranoid+\", &paranoid);\n---------\n\n Invoking the program with \"--paranoid --paranoid --paranoid\" will set\n $(D paranoid) to 3. Note that an incremental option never\n expects a parameter, e.g. in the command line \"--paranoid 42\n --paranoid\", the \"42\" does not set $(D paranoid) to 42;\n instead, $(D paranoid) is set to 2 and \"42\" is not considered\n as part of the normal program arguments.)))\n\n $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as a\n string is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\n  enum Color { no, yes };\n  Color color; // default initialized to Color.no\n  getopt(args, \"color\", &color);\n---------\n\nTo set $(D color) to $(D Color.yes), invoke the program with either $(D\n--color=yes) or $(D --color yes).)\n\n $(LI $(I String options.) If an option is bound to a string, a string\n is expected as the next option, or right within the option separated\n with an \"=\" sign:\n\n---------\nstring outputFile;\ngetopt(args, \"output\", &outputFile);\n---------\n\n Invoking the program with \"--output=myfile.txt\" or \"--output\n myfile.txt\" will set $(D outputFile) to \"myfile.txt\". If you want to\n pass a string containing spaces, you need to use the quoting that is\n appropriate to your shell, e.g. --output='my file.txt'.)\n\n $(LI $(I Array options.) If an option is bound to an array, a new\n element is appended to the array each time the option occurs:\n\n---------\nstring[] outputFiles;\ngetopt(args, \"output\", &outputFiles);\n---------\n\n Invoking the program with \"--output=myfile.txt --output=yourfile.txt\"\n or \"--output myfile.txt --output yourfile.txt\" will set $(D\n outputFiles) to [ \"myfile.txt\", \"yourfile.txt\" ] .)\n\n $(LI $(I Hash options.) If an option is bound to an associative\n array, a string of the form \"name=value\" is expected as the next\n option, or right within the option separated with an \"=\" sign:\n\n---------\ndouble[string] tuningParms;\ngetopt(args, \"tune\", &tuningParms);\n---------\n\nInvoking the program with e.g. \"--tune=alpha=0.5 --tune beta=0.6\" will\nset $(D tuningParms) to [ \"alpha\" : 0.5, \"beta\" : 0.6 ]. In general,\nkeys and values can be of any parsable types.)\n\n$(LI $(I Delegate options.) An option can be bound to a delegate with\nthe signature $(D void delegate()), $(D void delegate(string option))\nor $(D void delegate(string option, string value)).\n\n$(UL $(LI In the $(D void delegate()) case, the delegate is invoked\nwhenever the option is seen.) $(LI In the $(D void delegate(string\noption)) case, the option string (without the leading dash(es)) is\npassed to the delegate. After that, the option string is considered\nhandled and removed from the options array.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option)\n  {\n    if (option == \"quiet\")\n    {\n      verbosityLevel = 0;\n    }\n    else\n    {\n      assert(option == \"verbose\");\n      verbosityLevel = 2;\n    }\n  }\n  getopt(args, \"verbose\", &myHandler, \"quiet\", &myHandler);\n}\n---------\n\n)$(LI In the $(D void delegate(string option, string value)) case, the\noption string is handled as an option with one argument, and parsed\naccordingly. The option and its value are passed to the\ndelegate. After that, whatever was passed to the delegate is\nconsidered handled and removed from the list.\n\n---------\nvoid main(string[] args)\n{\n  uint verbosityLevel = 1;\n  void myHandler(string option, string value)\n  {\n    switch (value)\n    {\n      case \"quiet\": verbosityLevel = 0; break;\n      case \"verbose\": verbosityLevel = 2; break;\n      case \"shouting\": verbosityLevel = verbosityLevel.max; break;\n      default :\n        stderr.writeln(\"Dunno how verbose you want me to be by saying \",\n          value);\n        exit(1);\n    }\n  }\n  getopt(args, \"verbosity\", &myHandler);\n}\n---------\n))))\n\n$(B Options with multiple names)\n\nSometimes option synonyms are desirable, e.g. \"--verbose\",\n\"--loquacious\", and \"--garrulous\" should have the same effect. Such\nalternate option names can be included in the option specification,\nusing \"|\" as a separator:\n\n---------\nbool verbose;\ngetopt(args, \"verbose|loquacious|garrulous\", &verbose);\n---------\n\n$(B Case)\n\nBy default options are case-insensitive. You can change that behavior\nby passing $(D getopt) the $(D caseSensitive) directive like this:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nIn the example above, \"--foo\", \"--bar\", \"--FOo\", \"--bAr\" etc. are recognized.\nThe directive is active til the end of $(D getopt), or until the\nconverse directive $(D caseInsensitive) is encountered:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.caseSensitive,\n    \"foo\", &foo,\n    std.getopt.config.caseInsensitive,\n    \"bar\", &bar);\n---------\n\nThe option \"--Foo\" is rejected due to $(D\nstd.getopt.config.caseSensitive), but not \"--Bar\", \"--bAr\"\netc. because the directive $(D\nstd.getopt.config.caseInsensitive) turned sensitivity off before\noption \"bar\" was parsed.\n\n$(B \"Short\" versus \"long\" options)\n\nTraditionally, programs accepted single-letter options preceded by\nonly one dash (e.g. $(D -t)). $(D getopt) accepts such parameters\nseamlessly. When used with a double-dash (e.g. $(D --t)), a\nsingle-letter option behaves the same as a multi-letter option. When\nused with a single dash, a single-letter option is accepted. If the\noption has a parameter, that must be \"stuck\" to the option without\nany intervening space or \"=\":\n\n---------\nuint timeout;\ngetopt(args, \"timeout|t\", &timeout);\n---------\n\nTo set $(D timeout) to $(D 5), use either of the following: $(D --timeout=5),\n$(D --timeout 5), $(D --t=5), $(D --t 5), or $(D -t5). Forms such as $(D -t 5)\nand $(D -timeout=5) will be not accepted.\n\nFor more details about short options, refer also to the next section.\n\n$(B Bundling)\n\nSingle-letter options can be bundled together, i.e. \"-abc\" is the same as\n$(D \"-a -b -c\"). By default, this confusing option is turned off. You can\nturn it on with the $(D std.getopt.config.bundling) directive:\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.bundling,\n    \"foo|f\", &foo,\n    \"bar|b\", &bar);\n---------\n\nIn case you want to only enable bundling for some of the parameters,\nbundling can be turned off with $(D std.getopt.config.noBundling).\n\n$(B Passing unrecognized options through)\n\nIf an application needs to do its own processing of whichever arguments\n$(D getopt) did not understand, it can pass the\n$(D std.getopt.config.passThrough) directive to $(D getopt):\n\n---------\nbool foo, bar;\ngetopt(args,\n    std.getopt.config.passThrough,\n    \"foo\", &foo,\n    \"bar\", &bar);\n---------\n\nAn unrecognized option such as \"--baz\" will be found untouched in\n$(D args) after $(D getopt) returns.\n\n$(B Options Terminator)\n\nA lonesome double-dash terminates $(D getopt) gathering. It is used to\nseparate program options from other parameters (e.g. options to be passed\nto another program). Invoking the example above with $(D \"--foo -- --bar\")\nparses foo but leaves \"--bar\" in $(D args). The double-dash itself is\nremoved from the argument array.\n",
      "line" : 347,
      "type" : "void(ref string[] args, T opts)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "string[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "opts",
        "type" : "T"
       }
      ],
      "endline" : 352
     }
    ]
   },
   {
    "name" : "config",
    "kind" : "enum",
    "comment" : "\n Configuration options for $(D getopt). You can pass them to $(D\n getopt) in any position, except in between an option string and its\n bound pointer.\n \n",
    "line" : 360,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "caseSensitive",
      "kind" : "enum member",
      "comment" : " Turns case sensitivity on\n",
      "line" : 362
     },
     {
      "name" : "caseInsensitive",
      "kind" : "enum member",
      "comment" : " Turns case sensitivity off\n",
      "line" : 364
     },
     {
      "name" : "bundling",
      "kind" : "enum member",
      "comment" : " Turns bundling on\n",
      "line" : 366
     },
     {
      "name" : "noBundling",
      "kind" : "enum member",
      "comment" : " Turns bundling off\n",
      "line" : 368
     },
     {
      "name" : "passThrough",
      "kind" : "enum member",
      "comment" : " Pass unrecognized arguments through\n",
      "line" : 370
     },
     {
      "name" : "noPassThrough",
      "kind" : "enum member",
      "comment" : " Signal unrecognized arguments as errors\n",
      "line" : 372
     },
     {
      "name" : "stopOnFirstNonOption",
      "kind" : "enum member",
      "comment" : " Stop at first argument that does not look like an option\n",
      "line" : 374
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 377,
    "name" : "getoptImpl",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "getoptImpl",
      "kind" : "function",
      "line" : 377,
      "type" : "void(ref string[] args, ref configuration cfg, T opts)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "string[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "cfg",
        "type" : "configuration",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "opts",
        "type" : "T"
       }
      ],
      "endline" : 426
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 428,
    "name" : "handleOption",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "handleOption",
      "kind" : "function",
      "line" : 428,
      "type" : "void(string option, R receiver, ref string[] args, ref configuration cfg, bool incremental)",
      "parameters" : [
       {
        "name" : "option",
        "type" : "string"
       },
       {
        "name" : "receiver",
        "type" : "R"
       },
       {
        "name" : "args",
        "type" : "string[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "cfg",
        "type" : "configuration",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "incremental",
        "deco" : "b"
       }
      ],
      "endline" : 548
     }
    ]
   },
   {
    "name" : "optionChar",
    "kind" : "variable",
    "comment" : "\n   The option character. Defaults to '-' but it can be assigned to\n   prior to calling $(D getopt).\n \n",
    "line" : 554,
    "deco" : "w",
    "init" : "'-'"
   },
   {
    "name" : "endOfOptions",
    "kind" : "variable",
    "comment" : "\n   The string that conventionally marks the end of all\n   options. Defaults to \"--\" but can be assigned to prior to calling\n   $(D getopt). Assigning an empty string to $(D endOfOptions)\n   effectively disables it.\n \n",
    "line" : 562,
    "deco" : "Aya",
    "init" : "\"--\""
   },
   {
    "name" : "assignChar",
    "kind" : "variable",
    "comment" : "\n   The assignment character used in options with parameters. Defaults\n   to '=' but can be assigned to prior to calling $(D getopt).\n \n",
    "line" : 568,
    "deco" : "w",
    "init" : "'='"
   },
   {
    "name" : "autoIncrementChar",
    "kind" : "variable",
    "line" : 570,
    "storageClass" : [
     "enum"
    ],
    "deco" : "a",
    "init" : "'+'"
   },
   {
    "name" : "configuration",
    "kind" : "struct",
    "protection" : "private",
    "line" : 573,
    "members" : [
     {
      "name" : "caseSensitive",
      "kind" : "function",
      "line" : 574,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 574
     },
     {
      "name" : "caseSensitive",
      "kind" : "function",
      "line" : 575,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfbZv",
      "originalType" : "pure nothrow void(bool v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "b"
       }
      ],
      "endline" : 575
     },
     {
      "name" : "bundling",
      "kind" : "function",
      "line" : 576,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 576
     },
     {
      "name" : "bundling",
      "kind" : "function",
      "line" : 577,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfbZv",
      "originalType" : "pure nothrow void(bool v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "b"
       }
      ],
      "endline" : 577
     },
     {
      "name" : "passThrough",
      "kind" : "function",
      "line" : 578,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 578
     },
     {
      "name" : "passThrough",
      "kind" : "function",
      "line" : 579,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfbZv",
      "originalType" : "pure nothrow void(bool v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "b"
       }
      ],
      "endline" : 579
     },
     {
      "name" : "stopOnFirstNonOption",
      "kind" : "function",
      "line" : 580,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 580
     },
     {
      "name" : "stopOnFirstNonOption",
      "kind" : "function",
      "line" : 581,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "FNaNbNdNfbZv",
      "originalType" : "pure nothrow void(bool v)",
      "parameters" : [
       {
        "name" : "v",
        "deco" : "b"
       }
      ],
      "endline" : 581
     },
     {
      "name" : "_caseSensitive_bundling_passThrough_stopOnFirstNonOption_",
      "kind" : "variable",
      "protection" : "private",
      "line" : 582,
      "deco" : "h",
      "offset" : 0
     }
    ]
   },
   {
    "name" : "optMatch",
    "kind" : "function",
    "protection" : "private",
    "line" : 582,
    "deco" : "FAyaAyaKAyaS3std6getopt13configurationZb",
    "parameters" : [
     {
      "name" : "arg",
      "deco" : "Aya"
     },
     {
      "name" : "optPattern",
      "deco" : "Aya"
     },
     {
      "name" : "value",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "cfg",
      "deco" : "S3std6getopt13configuration"
     }
    ],
    "endline" : 631
   },
   {
    "name" : "setConfig",
    "kind" : "function",
    "protection" : "private",
    "line" : 633,
    "deco" : "FKS3std6getopt13configurationE3std6getopt6configZv",
    "parameters" : [
     {
      "name" : "cfg",
      "deco" : "S3std6getopt13configuration",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "option",
      "deco" : "E3std6getopt6config"
     }
    ],
    "endline" : 647
   },
   {
    "name" : "__unittestL649_1206",
    "kind" : "function",
    "line" : 649,
    "endline" : 773
   },
   {
    "name" : "__unittestL773_1207",
    "kind" : "function",
    "line" : 773,
    "endline" : 790
   },
   {
    "name" : "__unittestL790_1208",
    "kind" : "function",
    "line" : 790,
    "endline" : 800
   },
   {
    "name" : "__unittestL800_1209",
    "kind" : "function",
    "line" : 800,
    "endline" : 809
   },
   {
    "name" : "__unittestL809_1210",
    "kind" : "function",
    "line" : 809,
    "endline" : 817
   }
  ]
 },
 {
  "name" : "std.json",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/json.d",
  "comment" : "\nJavaScript Object Notation\n\nCopyright: Copyright Jeremie Pelletier 2008 - 2009.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   Jeremie Pelletier\nReferences: $(LINK http://json.org/)\nSource:    $(PHOBOSSRC std/_json.d)\n",
  "members" : [
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 20,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.uni",
    "kind" : "import",
    "line" : 23,
    "protection" : "private",
    "selective" : [
     "isControl"
    ]
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "UTFStride",
    "kind" : "alias",
    "protection" : "private",
    "line" : 29
   },
   {
    "name" : "toUnicode",
    "kind" : "alias",
    "protection" : "private",
    "line" : 30
   },
   {
    "name" : "JSON_TYPE",
    "kind" : "enum",
    "comment" : "\nJSON type enumeration\n",
    "line" : 36,
    "baseDeco" : "g",
    "members" : [
     {
      "name" : "STRING",
      "kind" : "enum member",
      "comment" : " Indicates the type of a $(D JSONValue).\n",
      "line" : 39
     },
     {
      "name" : "INTEGER",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 40
     },
     {
      "name" : "UINTEGER",
      "kind" : "enum member",
      "comment" : " integers > 2^63-1\n",
      "line" : 41
     },
     {
      "name" : "FLOAT",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 42
     },
     {
      "name" : "OBJECT",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 43
     },
     {
      "name" : "ARRAY",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 44
     },
     {
      "name" : "TRUE",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 45
     },
     {
      "name" : "FALSE",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 46
     },
     {
      "name" : "NULL",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 47
     }
    ]
   },
   {
    "name" : "JSONValue",
    "kind" : "struct",
    "comment" : "\nJSON value node\n",
    "line" : 54,
    "members" : [
     {
      "name" : "str",
      "kind" : "variable",
      "comment" : " Value when $(D type) is $(D JSON_TYPE.STRING)\n",
      "line" : 58,
      "deco" : "Aya",
      "offset" : 0
     },
     {
      "name" : "integer",
      "kind" : "variable",
      "comment" : " Value when $(D type) is $(D JSON_TYPE.INTEGER)\n",
      "line" : 60,
      "deco" : "l",
      "offset" : 0
     },
     {
      "name" : "uinteger",
      "kind" : "variable",
      "comment" : " Value when $(D type) is $(D JSON_TYPE.UINTEGER)\n",
      "line" : 62,
      "deco" : "m",
      "offset" : 0
     },
     {
      "name" : "floating",
      "kind" : "variable",
      "comment" : " Value when $(D type) is $(D JSON_TYPE.FLOAT)\n",
      "line" : 64,
      "deco" : "e",
      "offset" : 0
     },
     {
      "name" : "object",
      "kind" : "variable",
      "comment" : " Value when $(D type) is $(D JSON_TYPE.OBJECT)\n",
      "line" : 66,
      "deco" : "HAyaS3std4json9JSONValue",
      "offset" : 0
     },
     {
      "name" : "array",
      "kind" : "variable",
      "comment" : " Value when $(D type) is $(D JSON_TYPE.ARRAY)\n",
      "line" : 68,
      "deco" : "AS3std4json9JSONValue",
      "offset" : 0
     },
     {
      "name" : "type",
      "kind" : "variable",
      "comment" : " Specifies the _type of the value stored in this structure.\n",
      "line" : 71,
      "deco" : "E3std4json9JSON_TYPE",
      "offset" : 16
     },
     {
      "name" : "opIndex",
      "kind" : "function",
      "comment" : " array syntax for json arrays\n",
      "line" : 74,
      "deco" : "FNcmZS3std4json9JSONValue",
      "originalType" : "JSONValue(size_t i)",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 79
     },
     {
      "name" : "opIndex",
      "kind" : "function",
      "comment" : " hash syntax for json objects\n",
      "line" : 82,
      "deco" : "FNcAyaZS3std4json9JSONValue",
      "originalType" : "JSONValue(string k)",
      "parameters" : [
       {
        "name" : "k",
        "deco" : "Aya"
       }
      ],
      "endline" : 87
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std4json9JSONValueKxS3std4json9JSONValueZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std4json9JSONValue",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std4json9JSONValue",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nParses a serialized string and returns a tree of JSON values.\n",
    "line" : 93,
    "name" : "parseJSON",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseJSON",
      "kind" : "function",
      "comment" : "\nParses a serialized string and returns a tree of JSON values.\n",
      "line" : 93,
      "type" : "JSONValue(T json, int maxDepth = -1)",
      "parameters" : [
       {
        "name" : "json",
        "type" : "T"
       },
       {
        "name" : "maxDepth",
        "deco" : "i",
        "default" : "-1"
       }
      ],
      "endline" : 377
     }
    ]
   },
   {
    "name" : "toJSON",
    "kind" : "function",
    "comment" : "\nTakes a tree of JSON values and returns the serialized string.\n",
    "line" : 382,
    "deco" : "FxPS3std4json9JSONValueZAya",
    "originalType" : "string(in JSONValue* root)",
    "parameters" : [
     {
      "name" : "root",
      "deco" : "xPS3std4json9JSONValue"
     }
    ],
    "endline" : 473
   },
   {
    "name" : "appendJSONChar",
    "kind" : "function",
    "protection" : "private",
    "line" : 475,
    "deco" : "FPS3std5array17__T8AppenderTAyaZ8AppenderwMDFAyaZvZv",
    "parameters" : [
     {
      "name" : "dst",
      "deco" : "PS3std5array17__T8AppenderTAyaZ8Appender"
     },
     {
      "name" : "c",
      "deco" : "w"
     },
     {
      "name" : "error",
      "deco" : "DFAyaZv",
      "storageClass" : [
       "scope"
      ]
     }
    ],
    "endline" : 481
   },
   {
    "name" : "JSONException",
    "kind" : "class",
    "comment" : "\nException thrown on JSON errors\n",
    "line" : 486,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 488,
      "deco" : "FAyaiiZC3std4json13JSONException",
      "originalType" : "(string msg, int line = 0, int pos = 0)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "line",
        "deco" : "i",
        "default" : "0"
       },
       {
        "name" : "pos",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 494
     }
    ]
   },
   {
    "name" : "__unittestL499_1213",
    "kind" : "function",
    "line" : 499,
    "endline" : 558
   }
  ]
 },
 {
  "name" : "std.math",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/math.d",
  "comment" : "\n Elementary mathematical functions\n\n Contains the elementary mathematical functions (powers, roots,\n and trignometric functions), and low-level floating-point operations.\n Mathematical special functions are available in std.mathspecial.\n\n The functionality closely follows the IEEE754-2008 standard for\n floating-point arithmetic, including the use of camelCase names rather\n than C99-style lower case names. All of these functions behave correctly\n when presented with an infinity or NaN.\n\n Unlike C, there is no global 'errno' variable. Consequently, almost all of\n these functions are pure nothrow.\n\n Status:\n The semantics and names of feqrel and approxEqual will be revised.\n\n Macros:\n      WIKI = Phobos/StdMath\n\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values</caption>\n              $0</table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)\n      POWER = $1<sup>$2</sup>\n      SUB = $1<sub>$2</sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n                        Don Clugston\n Source: $(PHOBOSSRC std/_math.d)\n \n",
  "members" : [
   {
    "name" : "core.stdc.math",
    "kind" : "import",
    "line" : 57,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 58,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 58,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 171,
    "name" : "floatTraits",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RECIP_EPSILON",
      "kind" : "variable",
      "line" : 177,
      "storageClass" : [
       "enum"
      ],
      "type" : "T",
      "init" : "1 / T.epsilon"
     }
    ]
   },
   {
    "name" : "MANTISSA_LSB",
    "kind" : "variable",
    "protection" : "private",
    "line" : 259,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "0"
   },
   {
    "name" : "MANTISSA_MSB",
    "kind" : "variable",
    "protection" : "private",
    "line" : 260,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "1"
   },
   {
    "name" : "E",
    "kind" : "variable",
    "comment" : " e = 2.718281... \n",
    "line" : 272,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xa.df85458a2bb4a9bp-2L"
   },
   {
    "name" : "LOG2T",
    "kind" : "variable",
    "comment" : " $(SUB log, 2)10 = 3.321928... \n",
    "line" : 273,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xd.49a784bcd1b8afep-2L"
   },
   {
    "name" : "LOG2E",
    "kind" : "variable",
    "comment" : " $(SUB log, 2)e = 1.442695... \n",
    "line" : 274,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xb.8aa3b295c17f0bcp-3L"
   },
   {
    "name" : "LOG2",
    "kind" : "variable",
    "comment" : " $(SUB log, 10)2 = 0.301029... \n",
    "line" : 275,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0x9.a209a84fbcff799p-5L"
   },
   {
    "name" : "LOG10E",
    "kind" : "variable",
    "comment" : " $(SUB log, 10)e = 0.434294... \n",
    "line" : 276,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xd.e5bd8a937287195p-5L"
   },
   {
    "name" : "LN2",
    "kind" : "variable",
    "comment" : " ln 2  = 0.693147... \n",
    "line" : 277,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xb.17217f7d1cf79acp-4L"
   },
   {
    "name" : "LN10",
    "kind" : "variable",
    "comment" : " ln 10 = 2.302585... \n",
    "line" : 278,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0x9.35d8dddaaa8ac17p-2L"
   },
   {
    "name" : "PI",
    "kind" : "variable",
    "comment" : " $(_PI) = 3.141592... \n",
    "line" : 279,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xc.90fdaa22168c235p-2L"
   },
   {
    "name" : "PI_2",
    "kind" : "variable",
    "comment" : " $(PI) / 2 = 1.570796... \n",
    "line" : 280,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xc.90fdaa22168c235p-3L"
   },
   {
    "name" : "PI_4",
    "kind" : "variable",
    "comment" : " $(PI) / 4 = 0.785398... \n",
    "line" : 281,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xc.90fdaa22168c235p-4L"
   },
   {
    "name" : "M_1_PI",
    "kind" : "variable",
    "comment" : " 1 / $(PI) = 0.318309... \n",
    "line" : 282,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xa.2f9836e4e44152ap-5L"
   },
   {
    "name" : "M_2_PI",
    "kind" : "variable",
    "comment" : " 2 / $(PI) = 0.636619... \n",
    "line" : 283,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xa.2f9836e4e44152ap-4L"
   },
   {
    "name" : "M_2_SQRTPI",
    "kind" : "variable",
    "comment" : " 2 / $(SQRT)$(PI) = 1.128379... \n",
    "line" : 284,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0x9.06eba8214db688dp-3L"
   },
   {
    "name" : "SQRT2",
    "kind" : "variable",
    "comment" : " $(SQRT)2 = 1.414213... \n",
    "line" : 285,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xb.504f333f9de6484p-3L"
   },
   {
    "name" : "SQRT1_2",
    "kind" : "variable",
    "comment" : " $(SQRT)$(HALF) = 0.707106... \n",
    "line" : 286,
    "storageClass" : [
     "enum"
    ],
    "deco" : "e",
    "init" : "0xb.504f333f9de6484p-4L"
   },
   {
    "kind" : "template",
    "comment" : "\n Calculates the absolute value\n\n For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )\n = hypot(z.re, z.im).\n \n",
    "line" : 296,
    "name" : "abs",
    "parameters" : [
     {
      "name" : "Num",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "abs",
      "kind" : "function",
      "comment" : "\n Calculates the absolute value\n\n For complex numbers, abs(z) = sqrt( $(POWER z.re, 2) + $(POWER z.im, 2) )\n = hypot(z.re, z.im).\n \n",
      "line" : 296,
      "type" : "pure nothrow @safe Num(Num x)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "Num"
       }
      ],
      "endline" : 305
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 307,
    "name" : "abs",
    "parameters" : [
     {
      "name" : "Num",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "abs",
      "kind" : "function",
      "line" : 307,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (Num z)",
      "parameters" : [
       {
        "name" : "z",
        "type" : "Num"
       }
      ],
      "endline" : 312
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto \n",
    "line" : 315,
    "name" : "abs",
    "parameters" : [
     {
      "name" : "Num",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "abs",
      "kind" : "function",
      "comment" : " ditto \n",
      "line" : 315,
      "type" : "pure nothrow @safe real(Num y)",
      "parameters" : [
       {
        "name" : "y",
        "type" : "Num"
       }
      ],
      "endline" : 320
     }
    ]
   },
   {
    "name" : "__unittestL323_1214",
    "kind" : "function",
    "line" : 323,
    "endline" : 343
   },
   {
    "name" : "conj",
    "kind" : "function",
    "comment" : "\n Complex conjugate\n\n  conj(x + iy) = x - iy\n\n Note that z * conj(z) = $(POWER z.re, 2) - $(POWER z.im, 2)\n is always a real number\n \n",
    "line" : 343,
    "deco" : "FNaNbNfcZc",
    "parameters" : [
     {
      "name" : "z",
      "deco" : "c"
     }
    ],
    "endline" : 346
   },
   {
    "name" : "conj",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 349,
    "deco" : "FNaNbNfjZj",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "j"
     }
    ],
    "endline" : 352
   },
   {
    "name" : "__unittestL355_1215",
    "kind" : "function",
    "line" : 355,
    "endline" : 374
   },
   {
    "name" : "cos",
    "kind" : "function",
    "comment" : "\n Returns cosine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cos(x)) $(TH invalid?))\n      $(TR $(TD $(NAN))            $(TD $(NAN)) $(TD yes)     )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN)) $(TD yes)     )\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n \n",
    "line" : 374,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "sin",
    "kind" : "function",
    "comment" : "\n Returns sine of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)               $(TH sin(x))      $(TH invalid?))\n      $(TR $(TD $(NAN))          $(TD $(NAN))      $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))    $(TD $(NAN))      $(TD yes))\n      )\n Bugs:\n      Results are undefined if |x| >= $(POWER 2,64).\n \n",
    "line" : 389,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "sin",
    "kind" : "function",
    "comment" : "\n  sine, complex and imaginary\n\n  sin(z) = sin(z.re)*cosh(z.im) + cos(z.re)*sinh(z.im)i\n\n If both sin($(THETA)) and cos($(THETA)) are required,\n it is most efficient to use expi($(THETA)).\n \n",
    "line" : 400,
    "deco" : "FNaNbNfcZc",
    "parameters" : [
     {
      "name" : "z",
      "deco" : "c"
     }
    ],
    "endline" : 405
   },
   {
    "name" : "sin",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 408,
    "deco" : "FNaNbNfjZj",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "j"
     }
    ],
    "endline" : 411
   },
   {
    "name" : "__unittestL413_1216",
    "kind" : "function",
    "line" : 413,
    "endline" : 424
   },
   {
    "name" : "cos",
    "kind" : "function",
    "comment" : "\n  cosine, complex and imaginary\n\n  cos(z) = cos(z.re)*cosh(z.im) - sin(z.re)*sinh(z.im)i\n \n",
    "line" : 424,
    "deco" : "FNaNbNfcZc",
    "parameters" : [
     {
      "name" : "z",
      "deco" : "c"
     }
    ],
    "endline" : 429
   },
   {
    "name" : "cos",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 432,
    "deco" : "FNaNbNfjZe",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "j"
     }
    ],
    "endline" : 435
   },
   {
    "name" : "__unittestL437_1217",
    "kind" : "function",
    "line" : 437,
    "endline" : 455
   },
   {
    "name" : "tan",
    "kind" : "function",
    "comment" : "\n Returns tangent of x. x is in radians.\n\n      $(TABLE_SV\n      $(TR $(TH x)             $(TH tan(x))       $(TH invalid?))\n      $(TR $(TD $(NAN))        $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMNINF))  $(TD $(NAN))       $(TD yes))\n      )\n \n",
    "line" : 455,
    "deco" : "FNaNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 545
   },
   {
    "name" : "__unittestL547_1218",
    "kind" : "function",
    "line" : 547,
    "endline" : 601
   },
   {
    "name" : "__unittestL601_1219",
    "kind" : "function",
    "line" : 601,
    "endline" : 617
   },
   {
    "name" : "acos",
    "kind" : "function",
    "comment" : "\n Calculates the arc cosine of x,\n returning a value ranging from 0 to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH acos(x)) $(TH invalid?))\n      $(TR $(TD $(GT)1.0)  $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(LT)-1.0) $(TD $(NAN))  $(TD yes))\n      $(TR $(TD $(NAN))    $(TD $(NAN))  $(TD yes))\n  )\n \n",
    "line" : 617,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 620
   },
   {
    "name" : "acos",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 623,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 623
   },
   {
    "name" : "acos",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 626,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 626
   },
   {
    "name" : "__unittestL628_1220",
    "kind" : "function",
    "line" : 628,
    "endline" : 644
   },
   {
    "name" : "asin",
    "kind" : "function",
    "comment" : "\n Calculates the arc sine of x,\n returning a value ranging from -$(PI)/2 to $(PI)/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH asin(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(GT)1.0)     $(TD $(NAN))       $(TD yes))\n      $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD yes))\n  )\n \n",
    "line" : 644,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 647
   },
   {
    "name" : "asin",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 650,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 650
   },
   {
    "name" : "asin",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 653,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 653
   },
   {
    "name" : "__unittestL655_1221",
    "kind" : "function",
    "line" : 655,
    "endline" : 670
   },
   {
    "name" : "atan",
    "kind" : "function",
    "comment" : "\n Calculates the arc tangent of x,\n returning a value ranging from -$(PI)/2 to $(PI)/2.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH atan(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(NAN))       $(TD yes))\n  )\n \n",
    "line" : 670,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 670
   },
   {
    "name" : "atan",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 673,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 673
   },
   {
    "name" : "atan",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 676,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 676
   },
   {
    "name" : "__unittestL678_1222",
    "kind" : "function",
    "line" : 678,
    "endline" : 704
   },
   {
    "name" : "atan2",
    "kind" : "function",
    "comment" : "\n Calculates the arc tangent of y / x,\n returning a value ranging from -$(PI) to $(PI).\n\n      $(TABLE_SV\n      $(TR $(TH y)                 $(TH x)            $(TH atan(y, x)))\n      $(TR $(TD $(NAN))            $(TD anything)     $(TD $(NAN)) )\n      $(TR $(TD anything)          $(TD $(NAN))       $(TD $(NAN)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(GT)0.0)     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0)         $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(LT)0.0)     $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -0.0)         $(TD $(PLUSMN)$(PI)))\n      $(TR $(TD $(GT)0.0)          $(TD $(PLUSMN)0.0) $(TD $(PI)/2) )\n      $(TR $(TD $(LT)0.0)          $(TD $(PLUSMN)0.0) $(TD -$(PI)/2) )\n      $(TR $(TD $(GT)0.0)          $(TD $(INFIN))     $(TD $(PLUSMN)0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD anything)     $(TD $(PLUSMN)$(PI)/2))\n      $(TR $(TD $(GT)0.0)          $(TD -$(INFIN))    $(TD $(PLUSMN)$(PI)) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(INFIN))     $(TD $(PLUSMN)$(PI)/4))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD -$(INFIN))    $(TD $(PLUSMN)3$(PI)/4))\n      )\n \n",
    "line" : 704,
    "deco" : "FNaNbNeeeZe",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "e"
     },
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 731
   },
   {
    "name" : "atan2",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 734,
    "deco" : "FNaNbNfddZd",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "d"
     },
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 737
   },
   {
    "name" : "atan2",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 740,
    "deco" : "FNaNbNfffZf",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "f"
     },
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 743
   },
   {
    "name" : "__unittestL745_1223",
    "kind" : "function",
    "line" : 745,
    "endline" : 758
   },
   {
    "name" : "cosh",
    "kind" : "function",
    "comment" : "\n Calculates the hyperbolic cosine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH cosh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)0.0) $(TD no) )\n      )\n \n",
    "line" : 758,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 764
   },
   {
    "name" : "cosh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 767,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 767
   },
   {
    "name" : "cosh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 770,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 770
   },
   {
    "name" : "__unittestL772_1224",
    "kind" : "function",
    "line" : 772,
    "endline" : 786
   },
   {
    "name" : "sinh",
    "kind" : "function",
    "comment" : "\n Calculates the hyperbolic sine of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH sinh(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no))\n      )\n \n",
    "line" : 786,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 799
   },
   {
    "name" : "sinh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 802,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 802
   },
   {
    "name" : "sinh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 805,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 805
   },
   {
    "name" : "__unittestL807_1225",
    "kind" : "function",
    "line" : 807,
    "endline" : 821
   },
   {
    "name" : "tanh",
    "kind" : "function",
    "comment" : "\n Calculates the hyperbolic tangent of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH tanh(x))      $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) $(TD no) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)1.0) $(TD no))\n      )\n \n",
    "line" : 821,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 831
   },
   {
    "name" : "tanh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 834,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 834
   },
   {
    "name" : "tanh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 837,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 837
   },
   {
    "name" : "__unittestL839_1226",
    "kind" : "function",
    "line" : 839,
    "endline" : 844
   },
   {
    "name" : "coshisinh",
    "kind" : "function",
    "protection" : "package",
    "line" : 849,
    "deco" : "FNaNbNfeZc",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 862
   },
   {
    "name" : "__unittestL864_1227",
    "kind" : "function",
    "protection" : "package",
    "line" : 864,
    "endline" : 871
   },
   {
    "name" : "acosh",
    "kind" : "function",
    "comment" : "\n Calculates the inverse hyperbolic cosine of x.\n\n  Mathematically, acosh(x) = log(x + sqrt( x*x - 1))\n\n $(TABLE_DOMRG\n  $(DOMAIN 1..$(INFIN))\n  $(RANGE  1..log(real.max), $(INFIN)) )\n      $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(LT)1,     $(NAN) )\n    $(SV  1,      0       )\n    $(SV  +$(INFIN),+$(INFIN))\n  )\n \n",
    "line" : 889,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 895
   },
   {
    "name" : "acosh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 898,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 898
   },
   {
    "name" : "acosh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 901,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 901
   },
   {
    "name" : "__unittestL904_1228",
    "kind" : "function",
    "line" : 904,
    "endline" : 930
   },
   {
    "name" : "asinh",
    "kind" : "function",
    "comment" : "\n Calculates the inverse hyperbolic sine of x.\n\n  Mathematically,\n  ---------------\n  asinh(x) =  log( x + sqrt( x*x + 1 )) // if x >= +0\n  asinh(x) = -log(-x + sqrt( x*x + 1 )) // if x <= -0\n  -------------\n\n    $(TABLE_SV\n    $(SVH x,                asinh(x)       )\n    $(SV  $(NAN),           $(NAN)         )\n    $(SV  $(PLUSMN)0,       $(PLUSMN)0      )\n    $(SV  $(PLUSMN)$(INFIN),$(PLUSMN)$(INFIN))\n    )\n \n",
    "line" : 930,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 937
   },
   {
    "name" : "asinh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 940,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 940
   },
   {
    "name" : "asinh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 943,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 943
   },
   {
    "name" : "__unittestL945_1229",
    "kind" : "function",
    "line" : 945,
    "endline" : 972
   },
   {
    "name" : "atanh",
    "kind" : "function",
    "comment" : "\n Calculates the inverse hyperbolic tangent of x,\n returning a value from ranging from -1 to 1.\n\n Mathematically, atanh(x) = log( (1+x)/(1-x) ) / 2\n\n\n $(TABLE_DOMRG\n  $(DOMAIN -$(INFIN)..$(INFIN))\n  $(RANGE  -1..1) )\n $(TABLE_SV\n    $(SVH  x,     acosh(x) )\n    $(SV  $(NAN), $(NAN) )\n    $(SV  $(PLUSMN)0, $(PLUSMN)0)\n    $(SV  -$(INFIN), -0)\n )\n \n",
    "line" : 972,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 976
   },
   {
    "name" : "atanh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 979,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 979
   },
   {
    "name" : "atanh",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 982,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 982
   },
   {
    "name" : "__unittestL985_1230",
    "kind" : "function",
    "line" : 985,
    "endline" : 1001
   },
   {
    "name" : "rndtol",
    "kind" : "function",
    "comment" : "\n Returns x rounded to a long value using the current rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n \n",
    "line" : 1001,
    "deco" : "FNaNbNfeZl",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "rndtonl",
    "kind" : "function",
    "comment" : "\n Returns x rounded to a long value using the FE_TONEAREST rounding mode.\n If the integer value of x is\n greater than long.max, the result is\n indeterminate.\n \n",
    "line" : 1010,
    "deco" : "UeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "sqrt",
    "kind" : "function",
    "comment" : "\n Compute square root of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)         $(TH sqrt(x))   $(TH invalid?))\n      $(TR $(TD -0.0)      $(TD -0.0)      $(TD no))\n      $(TR $(TD $(LT)0.0)  $(TD $(NAN))    $(TD yes))\n      $(TR $(TD +$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      )\n \n",
    "line" : 1022,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ]
   },
   {
    "name" : "sqrt",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1025,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ]
   },
   {
    "name" : "sqrt",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1028,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "__unittestL1030_1231",
    "kind" : "function",
    "line" : 1030,
    "endline" : 1038
   },
   {
    "name" : "sqrt",
    "kind" : "function",
    "line" : 1038,
    "deco" : "FNaNbNfcZc",
    "parameters" : [
     {
      "name" : "z",
      "deco" : "c"
     }
    ],
    "endline" : 1077
   },
   {
    "name" : "exp",
    "kind" : "function",
    "comment" : "\n Calculates e$(SUP x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUP x)) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\n \n",
    "line" : 1089,
    "deco" : "FNaNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 1109
   },
   {
    "name" : "exp",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1112,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 1112
   },
   {
    "name" : "exp",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1115,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 1115
   },
   {
    "name" : "__unittestL1117_1232",
    "kind" : "function",
    "line" : 1117,
    "endline" : 1137
   },
   {
    "name" : "expm1",
    "kind" : "function",
    "comment" : "\n Calculates the value of the natural logarithm base (e)\n raised to the power of x, minus 1.\n\n For very small x, expm1(x) is more accurate\n than exp(x)-1.\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH e$(SUP x)-1)  )\n    $(TR $(TD $(PLUSMN)0.0)  $(TD $(PLUSMN)0.0) )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN))    )\n    $(TR $(TD -$(INFIN))     $(TD -1.0)         )\n    $(TR $(TD $(NAN))        $(TD $(NAN))       )\n  )\n \n",
    "line" : 1137,
    "deco" : "FNaNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 1304
   },
   {
    "name" : "exp2",
    "kind" : "function",
    "comment" : "\n Calculates 2$(SUP x).\n\n  $(TABLE_SV\n    $(TR $(TH x)             $(TH exp2(x))   )\n    $(TR $(TD +$(INFIN))     $(TD +$(INFIN)) )\n    $(TR $(TD -$(INFIN))     $(TD +0.0)      )\n    $(TR $(TD $(NAN))        $(TD $(NAN))    )\n  )\n \n",
    "line" : 1318,
    "deco" : "FNaNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 1511
   },
   {
    "name" : "__unittestL1513_1233",
    "kind" : "function",
    "line" : 1513,
    "endline" : 1524
   },
   {
    "name" : "__unittestL1524_1234",
    "kind" : "function",
    "line" : 1524,
    "endline" : 1597
   },
   {
    "name" : "expi",
    "kind" : "function",
    "comment" : "\n Calculate cos(y) + i sin(y).\n\n On many CPUs (such as x86), this is a very efficient operation;\n almost twice as fast as calculating sin(y) and cos(y) separately,\n and is the preferred method when both are required.\n \n",
    "line" : 1597,
    "deco" : "FNaNbNeeZc",
    "parameters" : [
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 1626
   },
   {
    "name" : "__unittestL1628_1235",
    "kind" : "function",
    "line" : 1628,
    "endline" : 1652
   },
   {
    "name" : "frexp",
    "kind" : "function",
    "comment" : "\n Separate floating point value into significand and exponent.\n\n Returns:\n      Calculate and return $(I x) and $(I exp) such that\n      value =$(I x)*2$(SUP exp) and\n      .5 $(LT)= |$(I x)| $(LT) 1.0\n\n      $(I x) has same sign as value.\n\n      $(TABLE_SV\n      $(TR $(TH value)           $(TH returns)         $(TH exp))\n      $(TR $(TD $(PLUSMN)0.0)    $(TD $(PLUSMN)0.0)    $(TD 0))\n      $(TR $(TD +$(INFIN))       $(TD +$(INFIN))       $(TD int.max))\n      $(TR $(TD -$(INFIN))       $(TD -$(INFIN))       $(TD int.min))\n      $(TR $(TD $(PLUSMN)$(NAN)) $(TD $(PLUSMN)$(NAN)) $(TD int.min))\n      )\n \n",
    "line" : 1652,
    "deco" : "FNaNbNeeJiZe",
    "parameters" : [
     {
      "name" : "value",
      "deco" : "e"
     },
     {
      "name" : "exp",
      "deco" : "i",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 1786
   },
   {
    "name" : "__unittestL1789_1236",
    "kind" : "function",
    "line" : 1789,
    "endline" : 1842
   },
   {
    "name" : "__unittestL1842_1237",
    "kind" : "function",
    "line" : 1842,
    "endline" : 1869
   },
   {
    "name" : "ilogb",
    "kind" : "function",
    "comment" : "\n Extracts the exponent of x as a signed integral value.\n\n If x is not a special value, the result is the same as\n $(D cast(int)logb(x)).\n\n      $(TABLE_SV\n      $(TR $(TH x)                $(TH ilogb(x))     $(TH Range error?))\n      $(TR $(TD 0)                 $(TD FP_ILOGB0)   $(TD yes))\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD int.max)     $(TD no))\n      $(TR $(TD $(NAN))            $(TD FP_ILOGBNAN) $(TD no))\n      )\n \n",
    "line" : 1869,
    "deco" : "FNbNeeZi",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 1905
   },
   {
    "name" : "FP_ILOGB0",
    "kind" : "alias",
    "line" : 1907
   },
   {
    "name" : "FP_ILOGBNAN",
    "kind" : "alias",
    "line" : 1908
   },
   {
    "name" : "ldexp",
    "kind" : "function",
    "comment" : "\n Compute n * 2$(SUP exp)\n References: frexp\n \n",
    "line" : 1916,
    "deco" : "FNaNbNfeiZe",
    "parameters" : [
     {
      "name" : "n",
      "deco" : "e"
     },
     {
      "name" : "exp",
      "deco" : "i"
     }
    ]
   },
   {
    "name" : "__unittestL1918_1238",
    "kind" : "function",
    "line" : 1918,
    "endline" : 1930
   },
   {
    "name" : "__unittestL1930_1239",
    "kind" : "function",
    "line" : 1930,
    "endline" : 1956
   },
   {
    "name" : "__unittestL1956_1240",
    "kind" : "function",
    "line" : 1956,
    "endline" : 1983
   },
   {
    "name" : "log",
    "kind" : "function",
    "comment" : "\n Calculate the natural logarithm of x.\n\n    $(TABLE_SV\n    $(TR $(TH x)            $(TH log(x))    $(TH divide by 0?) $(TH invalid?))\n    $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n    $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n    $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n    )\n \n",
    "line" : 1983,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 1989
   },
   {
    "name" : "__unittestL1991_1241",
    "kind" : "function",
    "line" : 1991,
    "endline" : 2007
   },
   {
    "name" : "log10",
    "kind" : "function",
    "comment" : "\n Calculate the base-10 logarithm of x.\n\n      $(TABLE_SV\n      $(TR $(TH x)            $(TH log10(x))  $(TH divide by 0?) $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no))\n      $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes))\n      $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no))\n      )\n \n",
    "line" : 2007,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2013
   },
   {
    "name" : "__unittestL2015_1242",
    "kind" : "function",
    "line" : 2015,
    "endline" : 2036
   },
   {
    "name" : "log1p",
    "kind" : "function",
    "comment" : "\n      Calculates the natural logarithm of 1 + x.\n\n      For very small x, log1p(x) will be more accurate than\n      log(1 + x).\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log1p(x))     $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD $(PLUSMN)0.0) $(TD no)           $(TD no))\n  $(TR $(TD -1.0)         $(TD -$(INFIN))    $(TD yes)          $(TD no))\n  $(TR $(TD $(LT)-1.0)    $(TD $(NAN))       $(TD no)           $(TD yes))\n  $(TR $(TD +$(INFIN))    $(TD -$(INFIN))    $(TD no)           $(TD no))\n  )\n \n",
    "line" : 2036,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2048
   },
   {
    "name" : "log2",
    "kind" : "function",
    "comment" : "\n Calculates the base-2 logarithm of x:\n $(SUB log, 2)x\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH log2(x))   $(TH divide by 0?) $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0) $(TD -$(INFIN)) $(TD yes)          $(TD no) )\n  $(TR $(TD $(LT)0.0)     $(TD $(NAN))    $(TD no)           $(TD yes) )\n  $(TR $(TD +$(INFIN))    $(TD +$(INFIN)) $(TD no)           $(TD no) )\n  )\n \n",
    "line" : 2061,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2067
   },
   {
    "name" : "__unittestL2069_1243",
    "kind" : "function",
    "line" : 2069,
    "endline" : 2088
   },
   {
    "name" : "logb",
    "kind" : "function",
    "comment" : "\n Extracts the exponent of x as a signed integral value.\n\n If x is subnormal, it is treated as if it were normalized.\n For a positive, finite x:\n\n 1 $(LT)= $(I x) * FLT_RADIX$(SUP -logb(x)) $(LT) FLT_RADIX\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH logb(x))   $(TH divide by 0?) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) $(TD no))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD -$(INFIN)) $(TD yes) )\n      )\n \n",
    "line" : 2088,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2103
   },
   {
    "name" : "fmod",
    "kind" : "function",
    "comment" : "\n Calculates the remainder from the calculation x/y.\n Returns:\n The value of x - i * y, where i is the number of times that y can\n be completely subtracted from x. The result has the same sign as x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH y)             $(TH fmod(x, y))   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)   $(TD not 0.0)       $(TD $(PLUSMN)0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(NAN))       $(TD yes))\n  $(TR $(TD anything)       $(TD $(PLUSMN)0.0)  $(TD $(NAN))       $(TD yes))\n  $(TR $(TD !=$(PLUSMNINF)) $(TD $(PLUSMNINF))  $(TD x)            $(TD no))\n )\n \n",
    "line" : 2119,
    "deco" : "FNbNeeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 2127
   },
   {
    "name" : "modf",
    "kind" : "function",
    "comment" : "\n Breaks x into an integral part and a fractional part, each of which has\n the same sign as x. The integral part is stored in i.\n Returns:\n The fractional part of x.\n\n $(TABLE_SV\n  $(TR $(TH x)              $(TH i (on input))  $(TH modf(x, i))   $(TH i (on return)))\n  $(TR $(TD $(PLUSMNINF))   $(TD anything)      $(TD $(PLUSMN)0.0) $(TD $(PLUSMNINF)))\n )\n \n",
    "line" : 2140,
    "deco" : "FNbNeeKeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "i",
      "deco" : "e",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2149
   },
   {
    "name" : "scalbn",
    "kind" : "function",
    "comment" : "\n Efficiently calculates x * 2$(SUP n).\n\n scalbn handles underflow and overflow in\n the same fashion as the basic arithmetic operators.\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH scalb(x)))\n      $(TR $(TD $(PLUSMNINF))      $(TD $(PLUSMNINF)) )\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0) )\n      )\n \n",
    "line" : 2163,
    "deco" : "FNbNeeiZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "n",
      "deco" : "i"
     }
    ],
    "endline" : 2193
   },
   {
    "name" : "__unittestL2195_1244",
    "kind" : "function",
    "line" : 2195,
    "endline" : 2210
   },
   {
    "name" : "cbrt",
    "kind" : "function",
    "comment" : "\n Calculates the cube root of x.\n\n      $(TABLE_SV\n      $(TR $(TH $(I x))            $(TH cbrt(x))           $(TH invalid?))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD $(PLUSMN)0.0)      $(TD no) )\n      $(TR $(TD $(NAN))            $(TD $(NAN))            $(TD yes) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD $(PLUSMN)$(INFIN)) $(TD no) )\n      )\n \n",
    "line" : 2210,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2218
   },
   {
    "name" : "fabs",
    "kind" : "function",
    "comment" : "\n Returns |x|\n\n      $(TABLE_SV\n      $(TR $(TH x)                 $(TH fabs(x)))\n      $(TR $(TD $(PLUSMN)0.0)      $(TD +0.0) )\n      $(TR $(TD $(PLUSMN)$(INFIN)) $(TD +$(INFIN)) )\n      )\n \n",
    "line" : 2230,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "hypot",
    "kind" : "function",
    "comment" : "\n Calculates the length of the\n hypotenuse of a right-angled triangle with sides of length x and y.\n The hypotenuse is the value of the square root of\n the sums of the squares of x and y:\n\n      sqrt($(POWER x, 2) + $(POWER y, 2))\n\n Note that hypot(x, y), hypot(y, x) and\n hypot(x, -y) are equivalent.\n\n  $(TABLE_SV\n  $(TR $(TH x)            $(TH y)            $(TH hypot(x, y)) $(TH invalid?))\n  $(TR $(TD x)            $(TD $(PLUSMN)0.0) $(TD |x|)         $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD y)            $(TD +$(INFIN))   $(TD no))\n  $(TR $(TD $(PLUSMNINF)) $(TD $(NAN))       $(TD +$(INFIN))   $(TD no))\n  )\n \n",
    "line" : 2252,
    "deco" : "FNaNbNfeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 2304
   },
   {
    "name" : "__unittestL2306_1245",
    "kind" : "function",
    "line" : 2306,
    "endline" : 2342
   },
   {
    "name" : "ceil",
    "kind" : "function",
    "comment" : "\n Returns the value of x rounded upward to the next integer\n (toward positive infinity).\n \n",
    "line" : 2342,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2365
   },
   {
    "name" : "__unittestL2367_1246",
    "kind" : "function",
    "line" : 2367,
    "endline" : 2377
   },
   {
    "name" : "floor",
    "kind" : "function",
    "comment" : "\n Returns the value of x rounded downward to the next integer\n (toward negative infinity).\n \n",
    "line" : 2377,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2400
   },
   {
    "name" : "__unittestL2402_1247",
    "kind" : "function",
    "line" : 2402,
    "endline" : 2415
   },
   {
    "name" : "nearbyint",
    "kind" : "function",
    "comment" : "\n Rounds x to the nearest integer value, using the current rounding\n mode.\n\n Unlike the rint functions, nearbyint does not raise the\n FE_INEXACT exception.\n \n",
    "line" : 2415,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2423
   },
   {
    "name" : "rint",
    "kind" : "function",
    "comment" : "\n Rounds x to the nearest integer value, using the current rounding\n mode.\n If the return value is not equal to x, the FE_INEXACT\n exception is raised.\n $(B nearbyint) performs\n the same operation, but does not set the FE_INEXACT exception.\n \n",
    "line" : 2433,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "lrint",
    "kind" : "function",
    "comment" : "\n Rounds x to the nearest integer value, using the current rounding\n mode.\n\n This is generally the fastest method to convert a floating-point number\n to an integer. Note that the results from this function\n depend on the rounding mode, if the fractional part of x is exactly 0.5.\n If using the default rounding mode (ties round to even integers)\n lrint(4.5) == 4, lrint(5.5)==6.\n \n",
    "line" : 2445,
    "deco" : "FNaNbNeeZl",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2475
   },
   {
    "name" : "round",
    "kind" : "function",
    "comment" : "\n Return the value of x rounded to the nearest integer.\n If the fractional part of x is exactly 0.5, the return value is rounded to\n the even integer.\n \n",
    "line" : 2482,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2494
   },
   {
    "name" : "lround",
    "kind" : "function",
    "comment" : "\n Return the value of x rounded to the nearest integer.\n\n If the fractional part of x is exactly 0.5, the return value is rounded\n away from zero.\n \n",
    "line" : 2502,
    "deco" : "FNbNeeZl",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2508
   },
   {
    "name" : "__unittestL2512_1248",
    "kind" : "function",
    "line" : 2512,
    "endline" : 2518
   },
   {
    "name" : "trunc",
    "kind" : "function",
    "comment" : "\n Returns the integer portion of x, dropping the fractional portion.\n\n This is also known as \"chop\" rounding.\n \n",
    "line" : 2525,
    "deco" : "FNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 2548
   },
   {
    "name" : "remainder",
    "kind" : "function",
    "comment" : "\n Calculate the remainder x REM y, following IEC 60559.\n\n REM is the value of x - y * n, where n is the integer nearest the exact\n value of x / y.\n If |n - x / y| == 0.5, n is even.\n If the result is zero, it has the same sign as x.\n Otherwise, the sign of the result is the sign of x / y.\n Precision mode has no effect on the remainder functions.\n\n remquo returns n in the parameter n.\n\n $(TABLE_SV\n  $(TR $(TH x)               $(TH y)            $(TH remainder(x, y)) $(TH n)   $(TH invalid?))\n  $(TR $(TD $(PLUSMN)0.0)    $(TD not 0.0)      $(TD $(PLUSMN)0.0)    $(TD 0.0) $(TD no))\n  $(TR $(TD $(PLUSMNINF))    $(TD anything)     $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD anything)        $(TD $(PLUSMN)0.0) $(TD $(NAN))          $(TD ?)   $(TD yes))\n  $(TR $(TD != $(PLUSMNINF)) $(TD $(PLUSMNINF)) $(TD x)               $(TD ?)   $(TD no))\n )\n\n Note: remquo not supported on windows\n \n",
    "line" : 2572,
    "deco" : "FNbNeeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 2581
   },
   {
    "name" : "remquo",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2583,
    "deco" : "FNbNeeeJiZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     },
     {
      "name" : "n",
      "deco" : "i",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 2589
   },
   {
    "name" : "IeeeFlags",
    "kind" : "struct",
    "comment" : " IEEE exception status flags ('sticky bits')\n\n These flags indicate that an exceptional floating-point condition has occurred.\n They indicate that a NaN or an infinity has been generated, that a result\n is inexact, or that a signalling NaN has been encountered. If floating-point\n exceptions are enabled (unmasked), a hardware exception will be generated\n instead of setting these flags.\n\n Example:\n ----\n    real a=3.5;\n    // Set all the flags to zero\n    resetIeeeFlags();\n    assert(!ieeeFlags.divByZero);\n    // Perform a division by zero.\n    a/=0.0L;\n    assert(a==real.infinity);\n    assert(ieeeFlags.divByZero);\n    // Create a NaN\n    a*=0.0L;\n    assert(ieeeFlags.invalid);\n    assert(isNaN(a));\n\n    // Check that calling func() has no effect on the\n    // status flags.\n    IeeeFlags f = ieeeFlags;\n    func();\n    assert(ieeeFlags == f);\n\n ----\n \n",
    "line" : 2623,
    "members" : [
     {
      "name" : "flags",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2627,
      "deco" : "k",
      "offset" : 0
     },
     {
      "name" : "INEXACT_MASK",
      "kind" : "enum member",
      "line" : 2633
     },
     {
      "name" : "UNDERFLOW_MASK",
      "kind" : "enum member",
      "line" : 2634
     },
     {
      "name" : "OVERFLOW_MASK",
      "kind" : "enum member",
      "line" : 2635
     },
     {
      "name" : "DIVBYZERO_MASK",
      "kind" : "enum member",
      "line" : 2636
     },
     {
      "name" : "INVALID_MASK",
      "kind" : "enum member",
      "line" : 2637
     },
     {
      "name" : "getIeeeFlags",
      "kind" : "function",
      "protection" : "private",
      "line" : 2686,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZk",
      "endline" : 2725
     },
     {
      "name" : "resetIeeeFlags",
      "kind" : "function",
      "protection" : "private",
      "line" : 2726,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2745
     },
     {
      "name" : "inexact",
      "kind" : "function",
      "comment" : " The result cannot be represented exactly, so rounding occured.\n (example: x = sin(0.1); )\n",
      "line" : 2751,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2751
     },
     {
      "name" : "underflow",
      "kind" : "function",
      "comment" : " A zero was generated by underflow (example: x = real.min*real.epsilon/2;)\n",
      "line" : 2754,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2754
     },
     {
      "name" : "overflow",
      "kind" : "function",
      "comment" : " An infinity was generated by overflow (example: x = real.max*2;)\n",
      "line" : 2757,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2757
     },
     {
      "name" : "divByZero",
      "kind" : "function",
      "comment" : " An infinity was generated by division by zero (example: x = 3/0.0; )\n",
      "line" : 2760,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2760
     },
     {
      "name" : "invalid",
      "kind" : "function",
      "comment" : " A machine NaN was generated. (example: x = real.infinity * 0.0; )\n",
      "line" : 2763,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2763
     }
    ]
   },
   {
    "name" : "resetIeeeFlags",
    "kind" : "function",
    "comment" : " Set all of the floating-point status flags to false.\n",
    "line" : 2770,
    "deco" : "FZv",
    "endline" : 2770
   },
   {
    "name" : "ieeeFlags",
    "kind" : "function",
    "comment" : " Return a snapshot of the current state of the floating-point status flags.\n",
    "line" : 2773,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdZS3std4math9IeeeFlags",
    "originalType" : "IeeeFlags()",
    "endline" : 2776
   },
   {
    "name" : "FloatingPointControl",
    "kind" : "struct",
    "comment" : " Control the Floating point hardware\n\n  Change the IEEE754 floating-point rounding mode and the floating-point\n  hardware exceptions.\n\n  By default, the rounding mode is roundToNearest and all hardware exceptions\n  are disabled. For most applications, debugging is easier if the $(I division\n  by zero), $(I overflow), and $(I invalid operation) exceptions are enabled.\n  These three are combined into a $(I severeExceptions) value for convenience.\n  Note in particular that if $(I invalidException) is enabled, a hardware trap\n  will be generated whenever an uninitialized floating-point variable is used.\n\n  All changes are temporary. The previous state is restored at the\n  end of the scope.\n\n\nExample:\n----\n{\n    FloatingPointControl fpctrl;\n\n    // Enable hardware exceptions for division by zero, overflow to infinity,\n    // invalid operations, and uninitialized floating-point variables.\n    fpctrl.enableExceptions(FloatingPointControl.severeExceptions);\n\n    // This will generate a hardware exception, if x is a\n    // default-initialized floating point variable:\n    real x; // Add `= 0` or even `= real.nan` to not throw the exception.\n    real y = x * 3.0;\n\n    // The exception is only thrown for default-uninitialized NaN-s.\n    // NaN-s with other payload are valid:\n    real z = y * real.nan; // ok\n\n    // Changing the rounding mode:\n    fpctrl.rounding = FloatingPointControl.roundUp;\n    assert(rint(1.1) == 2);\n\n    // The set hardware exceptions will be disabled when leaving this scope.\n    // The original rounding mode will also be restored.\n}\n\n// Ensure previous values are returned:\nassert(!FloatingPointControl.enabledExceptions);\nassert(FloatingPointControl.rounding == FloatingPointControl.roundToNearest);\nassert(rint(1.1) == 1);\n----\n\n \n",
    "line" : 2828,
    "members" : [
     {
      "name" : "RoundingMode",
      "kind" : "alias",
      "line" : 2829,
      "deco" : "k"
     },
     {
      "name" : "roundToNearest",
      "kind" : "enum member",
      "line" : 2836
     },
     {
      "name" : "roundDown",
      "kind" : "enum member",
      "line" : 2837
     },
     {
      "name" : "roundUp",
      "kind" : "enum member",
      "line" : 2838
     },
     {
      "name" : "roundToZero",
      "kind" : "enum member",
      "line" : 2839
     },
     {
      "name" : "inexactException",
      "kind" : "enum member",
      "line" : 2847
     },
     {
      "name" : "underflowException",
      "kind" : "enum member",
      "line" : 2848
     },
     {
      "name" : "overflowException",
      "kind" : "enum member",
      "line" : 2849
     },
     {
      "name" : "divByZeroException",
      "kind" : "enum member",
      "line" : 2850
     },
     {
      "name" : "subnormalException",
      "kind" : "enum member",
      "line" : 2851
     },
     {
      "name" : "invalidException",
      "kind" : "enum member",
      "line" : 2852
     },
     {
      "name" : "severeExceptions",
      "kind" : "enum member",
      "comment" : " Severe = The overflow, division by zero, and invalid exceptions.\n",
      "line" : 2854
     },
     {
      "name" : "allExceptions",
      "kind" : "enum member",
      "line" : 2856
     },
     {
      "name" : "EXCEPTION_MASK",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2861,
      "storageClass" : [
       "enum"
      ],
      "deco" : "t",
      "init" : "cast(ushort)63u"
     },
     {
      "name" : "ROUNDING_MASK",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2862,
      "storageClass" : [
       "enum"
      ],
      "deco" : "t",
      "init" : "cast(ushort)3072u"
     },
     {
      "name" : "enableExceptions",
      "kind" : "function",
      "comment" : " Enable (unmask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
      "line" : 2866,
      "deco" : "FkZv",
      "parameters" : [
       {
        "name" : "exceptions",
        "deco" : "k"
       }
      ],
      "endline" : 2870
     },
     {
      "name" : "disableExceptions",
      "kind" : "function",
      "comment" : " Disable (mask) specific hardware exceptions. Multiple exceptions may be ORed together.\n",
      "line" : 2873,
      "deco" : "FkZv",
      "parameters" : [
       {
        "name" : "exceptions",
        "deco" : "k"
       }
      ],
      "endline" : 2877
     },
     {
      "name" : "rounding",
      "kind" : "function",
      "comment" : " Change the floating-point hardware rounding mode\n",
      "line" : 2880,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdkZv",
      "originalType" : "void(RoundingMode newMode)",
      "parameters" : [
       {
        "name" : "newMode",
        "deco" : "k"
       }
      ],
      "endline" : 2884
     },
     {
      "name" : "enabledExceptions",
      "kind" : "function",
      "comment" : " Return the exceptions which are currently enabled (unmasked)\n",
      "line" : 2887,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNdZk",
      "originalType" : "uint()",
      "endline" : 2890
     },
     {
      "name" : "rounding",
      "kind" : "function",
      "comment" : " Return the currently active rounding mode\n",
      "line" : 2893,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNdZk",
      "originalType" : "RoundingMode()",
      "endline" : 2896
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "comment" : "  Clear all pending exceptions, then restore the original exception state and rounding mode.\n",
      "line" : 2899,
      "deco" : "FZv",
      "endline" : 2904
     },
     {
      "name" : "savedState",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2907,
      "deco" : "t",
      "offset" : 0
     },
     {
      "name" : "initialized",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2909,
      "deco" : "b",
      "init" : "false",
      "offset" : 2
     },
     {
      "name" : "initialize",
      "kind" : "function",
      "protection" : "private",
      "line" : 2911,
      "deco" : "FZv",
      "endline" : 2918
     },
     {
      "name" : "clearExceptions",
      "kind" : "function",
      "protection" : "private",
      "line" : 2921,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2932
     },
     {
      "name" : "getControlState",
      "kind" : "function",
      "protection" : "private",
      "line" : 2935,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNbNeZt",
      "endline" : 2960
     },
     {
      "name" : "setControlState",
      "kind" : "function",
      "protection" : "private",
      "line" : 2963,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNbNetZv",
      "parameters" : [
       {
        "name" : "newState",
        "deco" : "t"
       }
      ],
      "endline" : 2989
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 2828,
      "deco" : "FNcS3std4math20FloatingPointControlZS3std4math20FloatingPointControl",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std4math20FloatingPointControl"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2992_1249",
    "kind" : "function",
    "line" : 2992,
    "endline" : 3032
   },
   {
    "name" : "isNaN",
    "kind" : "function",
    "comment" : "\n Returns !=0 if e is a NaN.\n \n",
    "line" : 3032,
    "deco" : "FNaNbNeeZb",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3059
   },
   {
    "name" : "__unittestL3062_1250",
    "kind" : "function",
    "line" : 3062,
    "endline" : 3076
   },
   {
    "name" : "isFinite",
    "kind" : "function",
    "comment" : "\n Returns !=0 if e is finite (not infinite or $(NAN)).\n \n",
    "line" : 3076,
    "deco" : "FNaNbNeeZi",
    "parameters" : [
     {
      "name" : "e",
      "deco" : "e"
     }
    ],
    "endline" : 3081
   },
   {
    "name" : "__unittestL3083_1251",
    "kind" : "function",
    "line" : 3083,
    "endline" : 3099
   },
   {
    "kind" : "template",
    "comment" : "\n Returns !=0 if x is normalized (not zero, subnormal, infinite, or $(NAN)).\n \n",
    "line" : 3099,
    "name" : "isNormal",
    "parameters" : [
     {
      "name" : "X",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isNormal",
      "kind" : "function",
      "comment" : "\n Returns !=0 if x is normalized (not zero, subnormal, infinite, or $(NAN)).\n \n",
      "line" : 3099,
      "type" : "pure nothrow @trusted int(X x)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "X"
       }
      ],
      "endline" : 3113
     }
    ]
   },
   {
    "name" : "__unittestL3116_1252",
    "kind" : "function",
    "line" : 3116,
    "endline" : 3144
   },
   {
    "name" : "isSubnormal",
    "kind" : "function",
    "comment" : "\n Is number subnormal? (Also called \"denormal\".)\n Subnormals have a 0 exponent and a 0 most significant mantissa bit.\n \n",
    "line" : 3144,
    "deco" : "FNaNbNefZi",
    "parameters" : [
     {
      "name" : "f",
      "deco" : "f"
     }
    ],
    "endline" : 3148
   },
   {
    "name" : "__unittestL3150_1253",
    "kind" : "function",
    "line" : 3150,
    "endline" : 3160
   },
   {
    "name" : "isSubnormal",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 3160,
    "deco" : "FNaNbNedZi",
    "parameters" : [
     {
      "name" : "d",
      "deco" : "d"
     }
    ],
    "endline" : 3165
   },
   {
    "name" : "__unittestL3167_1254",
    "kind" : "function",
    "line" : 3167,
    "endline" : 3177
   },
   {
    "name" : "isSubnormal",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 3177,
    "deco" : "FNaNbNeeZi",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3206
   },
   {
    "name" : "__unittestL3208_1255",
    "kind" : "function",
    "line" : 3208,
    "endline" : 3220
   },
   {
    "name" : "isInfinity",
    "kind" : "function",
    "comment" : "\n Return !=0 if e is $(PLUSMN)$(INFIN).\n \n",
    "line" : 3220,
    "deco" : "FNaNbNeeZb",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3251
   },
   {
    "name" : "__unittestL3253_1256",
    "kind" : "function",
    "line" : 3253,
    "endline" : 3270
   },
   {
    "name" : "isIdentical",
    "kind" : "function",
    "comment" : "\n Is the binary representation of x identical to y?\n\n Same as ==, except that positive and negative zero are not identical,\n and two $(NAN)s are identical if they have the same 'payload'.\n \n",
    "line" : 3270,
    "deco" : "FNaNbNeeeZb",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 3292
   },
   {
    "name" : "signbit",
    "kind" : "function",
    "comment" : "\n Return 1 if sign bit of e is set, 0 if not.\n \n",
    "line" : 3298,
    "deco" : "FNaNbNeeZi",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3301
   },
   {
    "name" : "__unittestL3303_1257",
    "kind" : "function",
    "line" : 3303,
    "endline" : 3320
   },
   {
    "name" : "copysign",
    "kind" : "function",
    "comment" : "\n Return a value composed of to with from's sign bit.\n \n",
    "line" : 3320,
    "deco" : "FNaNbNeeeZe",
    "parameters" : [
     {
      "name" : "to",
      "deco" : "e"
     },
     {
      "name" : "from",
      "deco" : "e"
     }
    ],
    "endline" : 3329
   },
   {
    "name" : "__unittestL3331_1258",
    "kind" : "function",
    "line" : 3331,
    "endline" : 3355
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if\n$(D x > 0), and $(NAN) if x==$(NAN).\n \n",
    "line" : 3355,
    "name" : "sgn",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "sgn",
      "kind" : "function",
      "comment" : "\nReturns $(D -1) if $(D x < 0), $(D x) if $(D x == 0), $(D 1) if\n$(D x > 0), and $(NAN) if x==$(NAN).\n \n",
      "line" : 3355,
      "type" : "pure nothrow @safe F(F x)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "F"
       }
      ],
      "endline" : 3359
     }
    ]
   },
   {
    "name" : "__unittestL3361_1259",
    "kind" : "function",
    "line" : 3361,
    "endline" : 3384
   },
   {
    "name" : "NaN",
    "kind" : "function",
    "comment" : "\n Create a quiet $(NAN), storing an integer inside the payload.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n \n",
    "line" : 3384,
    "deco" : "FNaNbNemZe",
    "parameters" : [
     {
      "name" : "payload",
      "deco" : "m"
     }
    ],
    "endline" : 3454
   },
   {
    "name" : "getNaNPayload",
    "kind" : "function",
    "comment" : "\n Extract an integral payload from a $(NAN).\n\n Returns:\n the integer payload as a ulong.\n\n For floats, the largest possible payload is 0x3F_FFFF.\n For doubles, it is 0x3_FFFF_FFFF_FFFF.\n For 80-bit or 128-bit reals, it is 0x3FFF_FFFF_FFFF_FFFF.\n \n",
    "line" : 3466,
    "deco" : "FNaNbNeeZm",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3504
   },
   {
    "name" : "nextUp",
    "kind" : "function",
    "comment" : "\n Calculate the next largest floating point value after x.\n\n Return the least number greater than x that is representable as a real;\n thus, it gives the next point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextUp(x)   )\n    $(SV  -$(INFIN),    -real.max   )\n    $(SV  $(PLUSMN)0.0, real.min_normal*real.epsilon )\n    $(SV  real.max,     $(INFIN) )\n    $(SV  $(INFIN),     $(INFIN) )\n    $(SV  $(NAN),       $(NAN)   )\n )\n \n",
    "line" : 3547,
    "deco" : "FNaNbNeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3648
   },
   {
    "name" : "nextUp",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3651,
    "deco" : "FNaNbNedZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 3675
   },
   {
    "name" : "nextUp",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3678,
    "deco" : "FNaNbNefZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 3705
   },
   {
    "name" : "nextDown",
    "kind" : "function",
    "comment" : "\n Calculate the next smallest floating point value before x.\n\n Return the greatest number less than x that is representable as a real;\n thus, it gives the previous point on the IEEE number line.\n\n  $(TABLE_SV\n    $(SVH x,            nextDown(x)   )\n    $(SV  $(INFIN),     real.max  )\n    $(SV  $(PLUSMN)0.0, -real.min_normal*real.epsilon )\n    $(SV  -real.max,    -$(INFIN) )\n    $(SV  -$(INFIN),    -$(INFIN) )\n    $(SV  $(NAN),       $(NAN)    )\n )\n \n",
    "line" : 3722,
    "deco" : "FNaNbNfeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 3725
   },
   {
    "name" : "nextDown",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3728,
    "deco" : "FNaNbNfdZd",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "d"
     }
    ],
    "endline" : 3731
   },
   {
    "name" : "nextDown",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3734,
    "deco" : "FNaNbNffZf",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "f"
     }
    ],
    "endline" : 3737
   },
   {
    "name" : "__unittestL3739_1261",
    "kind" : "function",
    "line" : 3739,
    "endline" : 3744
   },
   {
    "name" : "__unittestL3744_1262",
    "kind" : "function",
    "line" : 3744,
    "endline" : 3827
   },
   {
    "kind" : "template",
    "comment" : "\n Calculates the next representable value after x in the direction of y.\n\n If y > x, the result will be the next largest floating-point value;\n if y < x, the result will be the next smallest value.\n If x == y, the result is y.\n\n Remarks:\n This function is not generally very useful; it's almost always better to use\n the faster functions nextUp() or nextDown() instead.\n\n The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and\n the function result is infinite. The FE_INEXACT and FE_UNDERFLOW\n exceptions will be raised if the function value is subnormal, and x is\n not equal to y.\n \n",
    "line" : 3827,
    "name" : "nextafter",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "nextafter",
      "kind" : "function",
      "comment" : "\n Calculates the next representable value after x in the direction of y.\n\n If y > x, the result will be the next largest floating-point value;\n if y < x, the result will be the next smallest value.\n If x == y, the result is y.\n\n Remarks:\n This function is not generally very useful; it's almost always better to use\n the faster functions nextUp() or nextDown() instead.\n\n The FE_INEXACT and FE_OVERFLOW exceptions will be raised if x is finite and\n the function result is infinite. The FE_INEXACT and FE_UNDERFLOW\n exceptions will be raised if the function value is subnormal, and x is\n not equal to y.\n \n",
      "line" : 3827,
      "type" : "pure nothrow @safe T(T x, T y)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "T"
       },
       {
        "name" : "y",
        "type" : "T"
       }
      ],
      "endline" : 3831
     }
    ]
   },
   {
    "name" : "__unittestL3833_1263",
    "kind" : "function",
    "line" : 3833,
    "endline" : 3859
   },
   {
    "name" : "fdim",
    "kind" : "function",
    "comment" : "\n Returns the positive difference between x and y.\n Returns:\n      $(TABLE_SV\n      $(TR $(TH x, y)       $(TH fdim(x, y)))\n      $(TR $(TD x $(GT) y)  $(TD x - y))\n      $(TR $(TD x $(LT)= y) $(TD +0.0))\n      )\n \n",
    "line" : 3859,
    "deco" : "FNaNbNfeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 3859
   },
   {
    "name" : "fmax",
    "kind" : "function",
    "comment" : "\n Returns the larger of x and y.\n \n",
    "line" : 3864,
    "deco" : "FNaNbNfeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 3864
   },
   {
    "name" : "fmin",
    "kind" : "function",
    "comment" : "\n Returns the smaller of x and y.\n \n",
    "line" : 3869,
    "deco" : "FNaNbNfeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 3869
   },
   {
    "name" : "fma",
    "kind" : "function",
    "comment" : "\n Returns (x * y) + z, rounding only once according to the\n current rounding mode.\n\n BUGS: Not currently implemented - rounds twice.\n \n",
    "line" : 3877,
    "deco" : "FNaNbNfeeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     },
     {
      "name" : "z",
      "deco" : "e"
     }
    ],
    "endline" : 3877
   },
   {
    "kind" : "template",
    "comment" : "\n Compute the value of x $(SUP n), where n is an integer\n \n",
    "line" : 3882,
    "name" : "pow",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "G",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pow",
      "kind" : "function",
      "comment" : "\n Compute the value of x $(SUP n), where n is an integer\n \n",
      "line" : 3882,
      "type" : "pure nothrow @trusted Unqual!(F)(F x, G n)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "F"
       },
       {
        "name" : "n",
        "type" : "G"
       }
      ],
      "endline" : 3927
     }
    ]
   },
   {
    "name" : "__unittestL3929_1264",
    "kind" : "function",
    "line" : 3929,
    "endline" : 3968
   },
   {
    "name" : "__unittestL3968_1265",
    "kind" : "function",
    "line" : 3968,
    "endline" : 3981
   },
   {
    "kind" : "template",
    "comment" : " Compute the value of an integer x, raised to the power of a positive\n integer n.\n\n  If both x and n are 0, the result is 1.\n  If n is negative, an integer divide error will occur at runtime,\n regardless of the value of x.\n \n",
    "line" : 3981,
    "name" : "pow",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "G",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pow",
      "kind" : "function",
      "comment" : " Compute the value of an integer x, raised to the power of a positive\n integer n.\n\n  If both x and n are 0, the result is 1.\n  If n is negative, an integer divide error will occur at runtime,\n regardless of the value of x.\n \n",
      "line" : 3981,
      "type" : "pure nothrow @trusted typeof(Unqual!(F).init * Unqual!(G).init)(F x, G n)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "F"
       },
       {
        "name" : "n",
        "type" : "G"
       }
      ],
      "endline" : 4016
     }
    ]
   },
   {
    "name" : "__unittestL4018_1266",
    "kind" : "function",
    "line" : 4018,
    "endline" : 4036
   },
   {
    "kind" : "template",
    "comment" : "Computes integer to floating point powers.\n",
    "line" : 4036,
    "name" : "pow",
    "parameters" : [
     {
      "name" : "I",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pow",
      "kind" : "function",
      "comment" : "Computes integer to floating point powers.\n",
      "line" : 4036,
      "type" : "pure nothrow @trusted real(I x, F y)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "I"
       },
       {
        "name" : "y",
        "type" : "F"
       }
      ],
      "endline" : 4040
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Calculates x$(SUP y).\n\n $(TABLE_SV\n $(TR $(TH x) $(TH y) $(TH pow(x, y))\n      $(TH div 0) $(TH invalid?))\n $(TR $(TD anything)      $(TD $(PLUSMN)0.0)                $(TD 1.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD +$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD +$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD -$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD -$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(GT) 0.0)                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(LT) 0.0)                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD odd integer $(GT) 0.0)      $(TD -$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(GT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD no)        $(TD no))\n $(TR $(TD -$(INFIN))      $(TD odd integer $(LT) 0.0)      $(TD -0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(LT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)1.0)   $(TD $(PLUSMN)$(INFIN))          $(TD $(NAN))\n      $(TD no)        $(TD yes) )\n $(TR $(TD $(LT) 0.0)      $(TD finite, nonintegral)        $(TD $(NAN))\n      $(TD no)        $(TD yes))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(LT) 0.0)      $(TD $(PLUSMNINF))\n      $(TD yes)       $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(LT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD yes)       $(TD no))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(GT) 0.0)      $(TD $(PLUSMN)0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(GT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n )\n \n",
    "line" : 4085,
    "name" : "pow",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "G",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pow",
      "kind" : "function",
      "comment" : "\n Calculates x$(SUP y).\n\n $(TABLE_SV\n $(TR $(TH x) $(TH y) $(TH pow(x, y))\n      $(TH div 0) $(TH invalid?))\n $(TR $(TD anything)      $(TD $(PLUSMN)0.0)                $(TD 1.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD +$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD +$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(GT) 1)    $(TD -$(INFIN))                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD |x| $(LT) 1)    $(TD -$(INFIN))                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(GT) 0.0)                  $(TD +$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD +$(INFIN))      $(TD $(LT) 0.0)                  $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD odd integer $(GT) 0.0)      $(TD -$(INFIN))\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(GT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD no)        $(TD no))\n $(TR $(TD -$(INFIN))      $(TD odd integer $(LT) 0.0)      $(TD -0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD -$(INFIN))      $(TD $(LT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)1.0)   $(TD $(PLUSMN)$(INFIN))          $(TD $(NAN))\n      $(TD no)        $(TD yes) )\n $(TR $(TD $(LT) 0.0)      $(TD finite, nonintegral)        $(TD $(NAN))\n      $(TD no)        $(TD yes))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(LT) 0.0)      $(TD $(PLUSMNINF))\n      $(TD yes)       $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(LT) 0.0, not odd integer) $(TD +$(INFIN))\n      $(TD yes)       $(TD no))\n $(TR $(TD $(PLUSMN)0.0)   $(TD odd integer $(GT) 0.0)      $(TD $(PLUSMN)0.0)\n      $(TD no)        $(TD no) )\n $(TR $(TD $(PLUSMN)0.0)   $(TD $(GT) 0.0, not odd integer) $(TD +0.0)\n      $(TD no)        $(TD no) )\n )\n \n",
      "line" : 4085,
      "type" : "pure nothrow @trusted Unqual!(Largest!(F, G))(F x, G y)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "F"
       },
       {
        "name" : "y",
        "type" : "G"
       }
      ],
      "endline" : 4208
     }
    ]
   },
   {
    "name" : "__unittestL4210_1267",
    "kind" : "function",
    "line" : 4210,
    "endline" : 4283
   },
   {
    "kind" : "template",
    "comment" : "\n To what precision is x equal to y?\n\n Returns: the number of mantissa bits which are equal in x and y.\n eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.\n\n      $(TABLE_SV\n      $(TR $(TH x)      $(TH y)          $(TH feqrel(x, y)))\n      $(TR $(TD x)      $(TD x)          $(TD real.mant_dig))\n      $(TR $(TD x)      $(TD $(GT)= 2*x) $(TD 0))\n      $(TR $(TD x)      $(TD $(LT)= x/2) $(TD 0))\n      $(TR $(TD $(NAN)) $(TD any)        $(TD 0))\n      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))\n      )\n \n",
    "line" : 4283,
    "name" : "feqrel",
    "parameters" : [
     {
      "name" : "X",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "feqrel",
      "kind" : "function",
      "comment" : "\n To what precision is x equal to y?\n\n Returns: the number of mantissa bits which are equal in x and y.\n eg, 0x1.F8p+60 and 0x1.F1p+60 are equal to 5 bits of precision.\n\n      $(TABLE_SV\n      $(TR $(TH x)      $(TH y)          $(TH feqrel(x, y)))\n      $(TR $(TD x)      $(TD x)          $(TD real.mant_dig))\n      $(TR $(TD x)      $(TD $(GT)= 2*x) $(TD 0))\n      $(TR $(TD x)      $(TD $(LT)= x/2) $(TD 0))\n      $(TR $(TD $(NAN)) $(TD any)        $(TD 0))\n      $(TR $(TD any)    $(TD $(NAN))     $(TD 0))\n      )\n \n",
      "line" : 4283,
      "type" : "pure nothrow @trusted int(X x, X y)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "X"
       },
       {
        "name" : "y",
        "type" : "X"
       }
      ],
      "endline" : 4372
     }
    ]
   },
   {
    "name" : "__unittestL4374_1268",
    "kind" : "function",
    "line" : 4374,
    "endline" : 4427
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 4443,
    "name" : "ieeeMean",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ieeeMean",
      "kind" : "function",
      "line" : 4443,
      "type" : "pure nothrow @trusted T(T x, T y)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "T"
       },
       {
        "name" : "y",
        "type" : "T"
       }
      ],
      "endline" : 4546
     }
    ]
   },
   {
    "name" : "__unittestL4548_1269",
    "kind" : "function",
    "protection" : "package",
    "line" : 4548,
    "endline" : 4572
   },
   {
    "name" : "poly",
    "kind" : "function",
    "comment" : "\n Evaluate polynomial A(x) = $(SUB a, 0) + $(SUB a, 1)x + $(SUB a, 2)$(POWER x,2)\n                          + $(SUB a,3)$(POWER x,3); ...\n\n Uses Horner's rule A(x) = $(SUB a, 0) + x($(SUB a, 1) + x($(SUB a, 2)\n                         + x($(SUB a, 3) + ...)))\n Params:\n      A =     array of coefficients $(SUB a, 0), $(SUB a, 1), etc.\n \n",
    "line" : 4584,
    "deco" : "FNaNbNeexAeZe",
    "originalType" : "pure nothrow @trusted real(real x, const real[] A)",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "A",
      "deco" : "xAe"
     }
    ],
    "endline" : 4722
   },
   {
    "name" : "__unittestL4724_1270",
    "kind" : "function",
    "line" : 4724,
    "endline" : 4742
   },
   {
    "kind" : "template",
    "comment" : "\n   Computes whether $(D lhs) is approximately equal to $(D rhs)\n   admitting a maximum relative difference $(D maxRelDiff) and a\n   maximum absolute difference $(D maxAbsDiff).\n\n   If the two inputs are ranges, $(D approxEqual) returns true if and\n   only if the ranges have the same number of elements and if $(D\n   approxEqual) evaluates to $(D true) for each pair of elements.\n \n",
    "line" : 4742,
    "name" : "approxEqual",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "type"
     },
     {
      "name" : "V",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "approxEqual",
      "kind" : "function",
      "comment" : "\n   Computes whether $(D lhs) is approximately equal to $(D rhs)\n   admitting a maximum relative difference $(D maxRelDiff) and a\n   maximum absolute difference $(D maxAbsDiff).\n\n   If the two inputs are ranges, $(D approxEqual) returns true if and\n   only if the ranges have the same number of elements and if $(D\n   approxEqual) evaluates to $(D true) for each pair of elements.\n \n",
      "line" : 4742,
      "type" : "bool(T lhs, U rhs, V maxRelDiff, V maxAbsDiff = 1e-05)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "T"
       },
       {
        "name" : "rhs",
        "type" : "U"
       },
       {
        "name" : "maxRelDiff",
        "type" : "V"
       },
       {
        "name" : "maxAbsDiff",
        "type" : "V",
        "default" : "1e-05"
       }
      ],
      "endline" : 4792
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Returns $(D approxEqual(lhs, rhs, 1e-2, 1e-5)).\n \n",
    "line" : 4797,
    "name" : "approxEqual",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "approxEqual",
      "kind" : "function",
      "comment" : "\n   Returns $(D approxEqual(lhs, rhs, 1e-2, 1e-5)).\n \n",
      "line" : 4797,
      "type" : "bool(T lhs, U rhs)",
      "parameters" : [
       {
        "name" : "lhs",
        "type" : "T"
       },
       {
        "name" : "rhs",
        "type" : "U"
       }
      ],
      "endline" : 4800
     }
    ]
   },
   {
    "name" : "__unittestL4802_1271",
    "kind" : "function",
    "line" : 4802,
    "endline" : 4819
   },
   {
    "name" : "isnan",
    "kind" : "alias",
    "line" : 4819
   },
   {
    "name" : "isfinite",
    "kind" : "alias",
    "line" : 4820
   },
   {
    "name" : "isnormal",
    "kind" : "alias",
    "line" : 4821
   },
   {
    "name" : "issubnormal",
    "kind" : "alias",
    "line" : 4822
   },
   {
    "name" : "isinf",
    "kind" : "alias",
    "line" : 4823
   },
   {
    "name" : "yl2x",
    "kind" : "function",
    "line" : 4830,
    "deco" : "FNaNbNfeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "yl2xp1",
    "kind" : "function",
    "line" : 4831,
    "deco" : "FNaNbNfeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ]
   },
   {
    "name" : "__unittestL4833_1272",
    "kind" : "function",
    "line" : 4833,
    "endline" : 4842
   },
   {
    "name" : "__unittestL4842_1273",
    "kind" : "function",
    "line" : 4842,
    "endline" : 4850
   },
   {
    "name" : "__unittestL4850_1274",
    "kind" : "function",
    "line" : 4850,
    "endline" : 4862
   },
   {
    "name" : "__unittestL4862_1275",
    "kind" : "function",
    "line" : 4862,
    "endline" : 4875
   },
   {
    "name" : "__unittestL4875_1276",
    "kind" : "function",
    "line" : 4875,
    "endline" : 4888
   },
   {
    "name" : "__unittestL4888_1277",
    "kind" : "function",
    "line" : 4888,
    "endline" : 4901
   },
   {
    "name" : "__unittestL4901_1278",
    "kind" : "function",
    "line" : 4901,
    "endline" : 4912
   }
  ]
 },
 {
  "name" : "std.mathspecial",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/mathspecial.d",
  "comment" : "\n Mathematical Special Functions\n\n The technical term 'Special Functions' includes several families of\n transcendental functions, which have important applications in particular\n branches of mathematics and physics.\n\n The gamma and related functions, and the error function are crucial for\n mathematical statistics.\n The Bessel and related functions arise in problems involving wave propagation\n (especially in optics).\n Other major categories of special functions include the elliptic integrals\n (related to the arc length of an ellipse), and the hypergeometric functions.\n\n Status:\n  Many more functions will be added to this module.\n  The naming convention for the distribution functions (gammaIncomplete, etc)\n  is not yet finalized and will probably change.\n\n Macros:\n      WIKI = Phobos/StdMathSpecial\n\n      TABLE_SV = <table border=1 cellpadding=4 cellspacing=0>\n              <caption>Special Values</caption>\n              $0</table>\n      SVH = $(TR $(TH $1) $(TH $2))\n      SV  = $(TR $(TD $1) $(TD $2))\n\n      NAN = $(RED NAN)\n      SUP = <span style=\"vertical-align:super;font-size:smaller\">$0</span>\n      GAMMA = &#915;\n      THETA = &theta;\n      INTEGRAL = &#8747;\n      INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)\n      POWER = $1<sup>$2</sup>\n      SUB = $1<sub>$2</sub>\n      BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)\n      CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)\n      PLUSMN = &plusmn;\n      INFIN = &infin;\n      PLUSMNINF = &plusmn;&infin;\n      PI = &pi;\n      LT = &lt;\n      GT = &gt;\n      SQRT = &radic;\n      HALF = &frac12;\n\n\n Copyright: Based on the CEPHES math library, which is\n            Copyright (C) 1994 Stephen L. Moshier (moshier@world.std.com).\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   Stephen L. Moshier (original C code). Conversion to D by Don Clugston\n Source:    $(PHOBOSSRC std/_mathspecial.d)\n \n",
  "members" : [
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 58
   },
   {
    "name" : "std.internal.math.gammafunction",
    "kind" : "import",
    "line" : 59,
    "protection" : "private"
   },
   {
    "name" : "std.internal.math.errorfunction",
    "kind" : "import",
    "line" : 60,
    "protection" : "private"
   },
   {
    "name" : "gamma",
    "kind" : "function",
    "comment" : " The Gamma function, $(GAMMA)(x)\n\n  $(GAMMA)(x) is a generalisation of the factorial function\n  to real and complex numbers.\n  Like x!, $(GAMMA)(x+1) = x * $(GAMMA)(x).\n\n  Mathematically, if z.re > 0 then\n   $(GAMMA)(z) = $(INTEGRATE 0, $(INFIN)) $(POWER t, z-1)$(POWER e, -t) dt\n\n  $(TABLE_SV\n    $(SVH  x,           $(GAMMA)(x) )\n    $(SV  $(NAN),       $(NAN)      )\n    $(SV  $(PLUSMN)0.0, $(PLUSMNINF))\n    $(SV integer > 0,   (x-1)!      )\n    $(SV integer < 0,   $(NAN)      )\n    $(SV +$(INFIN),      +$(INFIN)   )\n    $(SV -$(INFIN),      $(NAN)      )\n  )\n \n",
    "line" : 85,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 88
   },
   {
    "name" : "logGamma",
    "kind" : "function",
    "comment" : " Natural logarithm of the gamma function, $(GAMMA)(x)\n\n Returns the base e (2.718...) logarithm of the absolute\n value of the gamma function of the argument.\n\n For reals, logGamma is equivalent to log(fabs(gamma(x))).\n\n  $(TABLE_SV\n    $(SVH  x,             logGamma(x)   )\n    $(SV  $(NAN),         $(NAN)      )\n    $(SV integer <= 0,    +$(INFIN)    )\n    $(SV $(PLUSMNINF),    +$(INFIN)    )\n  )\n \n",
    "line" : 104,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 107
   },
   {
    "name" : "sgnGamma",
    "kind" : "function",
    "comment" : " The sign of $(GAMMA)(x).\n\n Returns -1 if $(GAMMA)(x) < 0,  +1 if $(GAMMA)(x) > 0,\n $(NAN) if sign is indeterminate.\n\n Note that this function can be used in conjunction with logGamma(x) to\n evaluate gamma for very large values of x.\n \n",
    "line" : 117,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 132
   },
   {
    "name" : "__unittestL134_1279",
    "kind" : "function",
    "line" : 134,
    "endline" : 149
   },
   {
    "name" : "beta",
    "kind" : "function",
    "comment" : " Beta function\n\n The beta function is defined as\n\n beta(x, y) = ($(GAMMA)(x) * $(GAMMA)(y)) / $(GAMMA)(x + y)\n \n",
    "line" : 149,
    "deco" : "FeeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 154
   },
   {
    "name" : "__unittestL156_1280",
    "kind" : "function",
    "line" : 156,
    "endline" : 167
   },
   {
    "name" : "digamma",
    "kind" : "function",
    "comment" : " Digamma function\n\n  The digamma function is the logarithmic derivative of the gamma function.\n\n  digamma(x) = d/dx logGamma(x)\n \n",
    "line" : 167,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 170
   },
   {
    "name" : "betaIncomplete",
    "kind" : "function",
    "comment" : " Incomplete beta integral\n\n Returns incomplete beta integral of the arguments, evaluated\n from zero to x. The regularized incomplete beta function is defined as\n\n betaIncomplete(a, b, x) = $(GAMMA)(a + b) / ( $(GAMMA)(a) $(GAMMA)(b) ) *\n $(INTEGRATE 0, x) $(POWER t, a-1)$(POWER (1-t), b-1) dt\n\n and is the same as the the cumulative distribution function.\n\n The domain of definition is 0 <= x <= 1.  In this\n implementation a and b are restricted to positive values.\n The integral from x to 1 may be obtained by the symmetry\n relation\n\n    betaIncompleteCompl(a, b, x )  =  betaIncomplete( b, a, 1-x )\n\n The integral is evaluated by a continued fraction expansion\n or, when b * x is small, by a power series.\n \n",
    "line" : 192,
    "deco" : "FeeeZe",
    "parameters" : [
     {
      "name" : "a",
      "deco" : "e"
     },
     {
      "name" : "b",
      "deco" : "e"
     },
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 195
   },
   {
    "name" : "betaIncompleteInverse",
    "kind" : "function",
    "comment" : " Inverse of incomplete beta integral\n\n Given y, the function finds x such that\n\n  betaIncomplete(a, b, x) == y\n\n  Newton iterations or interval halving is used.\n \n",
    "line" : 205,
    "deco" : "FeeeZe",
    "parameters" : [
     {
      "name" : "a",
      "deco" : "e"
     },
     {
      "name" : "b",
      "deco" : "e"
     },
     {
      "name" : "y",
      "deco" : "e"
     }
    ],
    "endline" : 208
   },
   {
    "name" : "gammaIncomplete",
    "kind" : "function",
    "comment" : " Incomplete gamma integral and its complement\n\n These functions are defined by\n\n   gammaIncomplete = ( $(INTEGRATE 0, x) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)\n\n  gammaIncompleteCompl(a,x)   =   1 - gammaIncomplete(a,x)\n = ($(INTEGRATE x, $(INFIN)) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)\n\n In this implementation both arguments must be positive.\n The integral is evaluated by either a power series or\n continued fraction expansion, depending on the relative\n values of a and x.\n \n",
    "line" : 224,
    "deco" : "FeeZe",
    "parameters" : [
     {
      "name" : "a",
      "deco" : "e"
     },
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 231
   },
   {
    "name" : "gammaIncompleteCompl",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 234,
    "deco" : "FeeZe",
    "parameters" : [
     {
      "name" : "a",
      "deco" : "e"
     },
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 241
   },
   {
    "name" : "gammaIncompleteComplInverse",
    "kind" : "function",
    "comment" : " Inverse of complemented incomplete gamma integral\n\n Given a and p, the function finds x such that\n\n  gammaIncompleteCompl( a, x ) = p.\n \n",
    "line" : 249,
    "deco" : "FeeZe",
    "parameters" : [
     {
      "name" : "a",
      "deco" : "e"
     },
     {
      "name" : "p",
      "deco" : "e"
     }
    ],
    "endline" : 256
   },
   {
    "name" : "erf",
    "kind" : "function",
    "comment" : " Error function\n\n The integral is\n\n  erf(x) =  2/ $(SQRT)($(PI))\n     $(INTEGRATE 0, x) exp( - $(POWER t, 2)) dt\n\n The magnitude of x is limited to about 106.56 for IEEE 80-bit\n arithmetic; 1 or -1 is returned outside this range.\n \n",
    "line" : 273,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 276
   },
   {
    "name" : "erfc",
    "kind" : "function",
    "comment" : " Complementary error function\n\n erfc(x) = 1 - erf(x)\n         = 2/ $(SQRT)($(PI))\n     $(INTEGRATE x, $(INFIN)) exp( - $(POWER t, 2)) dt\n\n This function has high relative accuracy for\n values of x far from zero. (For values near zero, use erf(x)).\n \n",
    "line" : 287,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 290
   },
   {
    "name" : "normalDistribution",
    "kind" : "function",
    "comment" : " Normal distribution function.\n\n The normal (or Gaussian, or bell-shaped) distribution is\n defined as:\n\n normalDist(x) = 1/$(SQRT) $(PI) $(INTEGRATE -$(INFIN), x) exp( - $(POWER t, 2)/2) dt\n   = 0.5 + 0.5 * erf(x/sqrt(2))\n   = 0.5 * erfc(- x/sqrt(2))\n\n To maintain accuracy at values of x near 1.0, use\n      normalDistribution(x) = 1.0 - normalDistribution(-x).\n\n References:\n $(LINK http://www.netlib.org/cephes/ldoubdoc.html),\n G. Marsaglia, \"Evaluating the Normal Distribution\",\n Journal of Statistical Software <b>11</b>, (July 2004).\n \n",
    "line" : 310,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "x",
      "deco" : "e"
     }
    ],
    "endline" : 313
   },
   {
    "name" : "normalDistributionInverse",
    "kind" : "function",
    "comment" : " Inverse of Normal distribution function\n\n Returns the argument, x, for which the area under the\n Normal probability density function (integrated from\n minus infinity to x) is equal to p.\n \n",
    "line" : 321,
    "deco" : "FeZe",
    "parameters" : [
     {
      "name" : "p",
      "deco" : "e"
     }
    ],
    "endline" : 328
   }
  ]
 },
 {
  "name" : "std.md5",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/md5.d",
  "comment" : "\n $(RED Scheduled for deprecation. Please use std.digest.md instead.)\n\n Computes MD5 digests of arbitrary data. MD5 digests are 16 byte quantities that are like a checksum or crc, but are more robust.\n\n There are two ways to do this. The first does it all in one function call to\n sum(). The second is for when the data is buffered.\n\n Bugs:\n MD5 digests have been demonstrated to not be unique.\n\n Author:\n The routines and algorithms are derived from the\n $(I RSA Data Security, Inc. MD5 Message-Digest Algorithm).\n\n References:\n      $(LINK2 http://en.wikipedia.org/wiki/Md5, Wikipedia on MD5)\n\n Source: $(PHOBOSSRC std/_md5.d)\n\n Macros:\n      WIKI = Phobos/StdMd5\n \n\n Example:\n\n--------------------\n// This code is derived from the\n// RSA Data Security, Inc. MD5 Message-Digest Algorithm.\n\nimport std.md5;\nimport std.stdio;\n\nvoid main(string[] args)\n{\n    foreach (arg; args)\n        mdFile(arg);\n}\n\n/// Digests a file and prints the result.\nvoid mdFile(string filename)\n{\n    ubyte[16] digest;\n\n    MD5_CTX context;\n    context.start();\n    foreach (buffer; File(filename).byChunk(64 * 1024))\n        context.update(buffer);\n    context.finish(digest);\n    writefln(\"MD5 (%s) = %s\", filename, digestToString(digest));\n}\n--------------------\n \n",
  "members" : [
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 90,
    "protection" : "private"
   },
   {
    "name" : "std.bitmanip",
    "kind" : "import",
    "line" : 91,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 92,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 93,
    "protection" : "private"
   },
   {
    "name" : "sum",
    "kind" : "function",
    "comment" : "\n Computes MD5 digest of several arrays of data.\n \n",
    "line" : 100,
    "deco" : "FKG16hxAAvXv",
    "originalType" : "void(ref ubyte[16] digest, in void[][] data...)",
    "parameters" : [
     {
      "name" : "digest",
      "deco" : "G16h",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "data",
      "deco" : "xAAv"
     }
    ],
    "endline" : 109
   },
   {
    "name" : "digestToString",
    "kind" : "function",
    "comment" : "\n Converts MD5 digest to a string.\n \n",
    "line" : 124,
    "deco" : "FxG16hZAya",
    "originalType" : "string(in ubyte[16] digest)",
    "parameters" : [
     {
      "name" : "digest",
      "deco" : "xG16h"
     }
    ],
    "endline" : 136
   },
   {
    "name" : "getDigestString",
    "kind" : "function",
    "comment" : "\n   Gets the digest of all $(D data) items passed in.\n\nExample:\n\n----\nstring a = \"Mary has \", b = \"a little lamb\";\nint[] c = [ 1, 2, 3, 4, 5 ];\nstring d = getDigestString(a, b, c);\n----\n",
    "line" : 149,
    "deco" : "FxAAvXAya",
    "originalType" : "string(in void[][] data...)",
    "parameters" : [
     {
      "name" : "data",
      "deco" : "xAAv"
     }
    ],
    "endline" : 159
   },
   {
    "name" : "__unittestL162_1281",
    "kind" : "function",
    "line" : 162,
    "endline" : 178
   },
   {
    "name" : "MD5_CTX",
    "kind" : "struct",
    "comment" : "\n Holds context of MD5 computation.\n\n Used when data to be digested is buffered.\n \n",
    "line" : 179,
    "members" : [
     {
      "name" : "state",
      "kind" : "variable",
      "line" : 180,
      "deco" : "G4k",
      "originalType" : "uint[4]",
      "init" : "[1732584193u, 4023233417u, 2562383102u, 271733878u]",
      "offset" : 0
     },
     {
      "name" : "count",
      "kind" : "variable",
      "line" : 184,
      "deco" : "m",
      "offset" : 16
     },
     {
      "name" : "buffer",
      "kind" : "variable",
      "line" : 185,
      "deco" : "G64h",
      "originalType" : "ubyte[64]",
      "offset" : 24
     },
     {
      "name" : "PADDING",
      "kind" : "variable",
      "line" : 187,
      "storageClass" : [
       "static"
      ],
      "deco" : "G64h",
      "originalType" : "ubyte[64]",
      "init" : "[cast(ubyte)128u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u]"
     },
     {
      "name" : "F",
      "kind" : "function",
      "protection" : "private",
      "line" : 198,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkkkZk",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "y",
        "deco" : "k"
       },
       {
        "name" : "z",
        "deco" : "k"
       }
      ],
      "endline" : 198
     },
     {
      "name" : "G",
      "kind" : "function",
      "protection" : "private",
      "line" : 199,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkkkZk",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "y",
        "deco" : "k"
       },
       {
        "name" : "z",
        "deco" : "k"
       }
      ],
      "endline" : 199
     },
     {
      "name" : "H",
      "kind" : "function",
      "protection" : "private",
      "line" : 200,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkkkZk",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "y",
        "deco" : "k"
       },
       {
        "name" : "z",
        "deco" : "k"
       }
      ],
      "endline" : 200
     },
     {
      "name" : "I",
      "kind" : "function",
      "protection" : "private",
      "line" : 201,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkkkZk",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "y",
        "deco" : "k"
       },
       {
        "name" : "z",
        "deco" : "k"
       }
      ],
      "endline" : 201
     },
     {
      "name" : "ROTATE_LEFT",
      "kind" : "function",
      "line" : 206,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkkZk",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "n",
        "deco" : "k"
       }
      ],
      "endline" : 211
     },
     {
      "name" : "FF",
      "kind" : "function",
      "line" : 216,
      "storageClass" : [
       "static"
      ],
      "deco" : "FKkkkkkkkZv",
      "parameters" : [
       {
        "name" : "a",
        "deco" : "k",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "b",
        "deco" : "k"
       },
       {
        "name" : "c",
        "deco" : "k"
       },
       {
        "name" : "d",
        "deco" : "k"
       },
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "s",
        "deco" : "k"
       },
       {
        "name" : "ac",
        "deco" : "k"
       }
      ],
      "endline" : 221
     },
     {
      "name" : "GG",
      "kind" : "function",
      "line" : 223,
      "storageClass" : [
       "static"
      ],
      "deco" : "FKkkkkkkkZv",
      "parameters" : [
       {
        "name" : "a",
        "deco" : "k",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "b",
        "deco" : "k"
       },
       {
        "name" : "c",
        "deco" : "k"
       },
       {
        "name" : "d",
        "deco" : "k"
       },
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "s",
        "deco" : "k"
       },
       {
        "name" : "ac",
        "deco" : "k"
       }
      ],
      "endline" : 228
     },
     {
      "name" : "HH",
      "kind" : "function",
      "line" : 230,
      "storageClass" : [
       "static"
      ],
      "deco" : "FKkkkkkkkZv",
      "parameters" : [
       {
        "name" : "a",
        "deco" : "k",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "b",
        "deco" : "k"
       },
       {
        "name" : "c",
        "deco" : "k"
       },
       {
        "name" : "d",
        "deco" : "k"
       },
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "s",
        "deco" : "k"
       },
       {
        "name" : "ac",
        "deco" : "k"
       }
      ],
      "endline" : 235
     },
     {
      "name" : "II",
      "kind" : "function",
      "line" : 237,
      "storageClass" : [
       "static"
      ],
      "deco" : "FKkkkkkkkZv",
      "parameters" : [
       {
        "name" : "a",
        "deco" : "k",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "b",
        "deco" : "k"
       },
       {
        "name" : "c",
        "deco" : "k"
       },
       {
        "name" : "d",
        "deco" : "k"
       },
       {
        "name" : "x",
        "deco" : "k"
       },
       {
        "name" : "s",
        "deco" : "k"
       },
       {
        "name" : "ac",
        "deco" : "k"
       }
      ],
      "endline" : 242
     },
     {
      "name" : "start",
      "kind" : "function",
      "comment" : "\n MD5 initialization. Begins an MD5 operation, writing a new context.\n     \n",
      "line" : 247,
      "deco" : "FZv",
      "endline" : 250
     },
     {
      "name" : "update",
      "kind" : "function",
      "comment" : " MD5 block update operation. Continues an MD5 message-digest\n      operation, processing another message block, and updating the\n      context.\n     \n",
      "line" : 256,
      "deco" : "FxAvZv",
      "originalType" : "void(const void[] input)",
      "parameters" : [
       {
        "name" : "input",
        "deco" : "xAv"
       }
      ],
      "endline" : 286
     },
     {
      "name" : "finish",
      "kind" : "function",
      "comment" : " MD5 finalization. Ends an MD5 message-digest operation, writing the\n the message to digest and zeroing the context.\n     \n",
      "line" : 291,
      "deco" : "FKG16hZv",
      "originalType" : "void(ref ubyte[16] digest)",
      "parameters" : [
       {
        "name" : "digest",
        "deco" : "G16h",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 315
     },
     {
      "name" : "S11",
      "kind" : "enum member",
      "line" : 323
     },
     {
      "name" : "S12",
      "kind" : "enum member",
      "line" : 324
     },
     {
      "name" : "S13",
      "kind" : "enum member",
      "line" : 325
     },
     {
      "name" : "S14",
      "kind" : "enum member",
      "line" : 326
     },
     {
      "name" : "S21",
      "kind" : "enum member",
      "line" : 327
     },
     {
      "name" : "S22",
      "kind" : "enum member",
      "line" : 328
     },
     {
      "name" : "S23",
      "kind" : "enum member",
      "line" : 329
     },
     {
      "name" : "S24",
      "kind" : "enum member",
      "line" : 330
     },
     {
      "name" : "S31",
      "kind" : "enum member",
      "line" : 331
     },
     {
      "name" : "S32",
      "kind" : "enum member",
      "line" : 332
     },
     {
      "name" : "S33",
      "kind" : "enum member",
      "line" : 333
     },
     {
      "name" : "S34",
      "kind" : "enum member",
      "line" : 334
     },
     {
      "name" : "S41",
      "kind" : "enum member",
      "line" : 335
     },
     {
      "name" : "S42",
      "kind" : "enum member",
      "line" : 336
     },
     {
      "name" : "S43",
      "kind" : "enum member",
      "line" : 337
     },
     {
      "name" : "S44",
      "kind" : "enum member",
      "line" : 338
     },
     {
      "name" : "transform",
      "kind" : "function",
      "protection" : "private",
      "line" : 341,
      "deco" : "FxPhZv",
      "originalType" : "void(const ubyte* block)",
      "parameters" : [
       {
        "name" : "block",
        "deco" : "xPh"
       }
      ],
      "endline" : 440
     }
    ]
   },
   {
    "name" : "__unittestL443_1282",
    "kind" : "function",
    "line" : 443,
    "endline" : 475
   }
  ]
 },
 {
  "name" : "std.metastrings",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/metastrings.d",
  "comment" : "\n$(RED Deprecated. It will be removed in March 2014.\n      Please use $(XREF string, format), $(XREF conv, to), or\n      $(XREF conv, parse) instead of these templates (which one would depend on\n      which template is being replaced.) They now work in CTFE, and these\n      templates are very inefficient.)\n\nTemplates with which to do compile-time manipulation of strings.\n\nMacros:\n WIKI = Phobos/StdMetastrings\n\nCopyright: Copyright Digital Mars 2007 - 2013.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           Don Clugston\nSource:    $(PHOBOSSRC std/_metastrings.d)\n",
  "members" : [
   {
    "kind" : "template",
    "comment" : "\n$(RED Deprecated.\n     Please use $(XREF string, format) instead. It now works in CTFE,\n     and this template is very inefficient.)\n\nFormats constants into a string at compile time.  Analogous to $(XREF\nstring,format).\n\nParameters:\n\nA = tuple of constants, which can be strings, characters, or integral\n    values.\n\nFormats:\n    The formats supported are %s for strings, and %%\n    for the % character.\nExample:\n---\nimport std.metastrings;\nimport std.stdio;\n\nvoid main()\n{\n  string s = Format!(\"Arg %s = %s\", \"foo\", 27);\n  writefln(s); // \"Arg foo = 27\"\n}\n ---\n \n",
    "line" : 53,
    "name" : "Format",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "line" : 64,
    "name" : "FormatString",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "value",
      "deco" : "Axa"
     },
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL82_1283",
    "kind" : "function",
    "line" : 82,
    "endline" : 96
   },
   {
    "kind" : "template",
    "comment" : "\n $(RED Deprecated.\n       Please use $(XREF conv, format) instead. It now works in CTFE,\n       and this template is very inefficient.)\n\n Convert constant argument to a string.\n \n",
    "line" : 97,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "v",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL105_1284",
    "kind" : "function",
    "line" : 105,
    "endline" : 111
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 112,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "v",
      "kind" : "value",
      "deco" : "l"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL120_1285",
    "kind" : "function",
    "line" : 120,
    "endline" : 127
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 128,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "U",
      "kind" : "value",
      "deco" : "k"
     }
    ],
    "members" : [
     {
      "name" : "toStringNow",
      "kind" : "variable",
      "line" : 130,
      "storageClass" : [
       "enum"
      ],
      "init" : "toStringNow!(cast(ulong)U)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 135,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "I",
      "kind" : "value",
      "deco" : "i"
     }
    ],
    "members" : [
     {
      "name" : "toStringNow",
      "kind" : "variable",
      "line" : 137,
      "storageClass" : [
       "enum"
      ],
      "init" : "toStringNow!(cast(long)I)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 142,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "B",
      "kind" : "value",
      "deco" : "b"
     }
    ],
    "members" : [
     {
      "name" : "toStringNow",
      "kind" : "variable",
      "line" : 144,
      "storageClass" : [
       "enum"
      ],
      "init" : "B ? \"true\" : \"false\""
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 149,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "toStringNow",
      "kind" : "variable",
      "line" : 151,
      "storageClass" : [
       "enum"
      ],
      "init" : "S"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 156,
    "name" : "toStringNow",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "value",
      "deco" : "a"
     }
    ],
    "members" : [
     {
      "name" : "toStringNow",
      "kind" : "variable",
      "line" : 158,
      "storageClass" : [
       "enum"
      ],
      "init" : "\"\" ~ C"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n $(RED Deprecated.\n       Please use $(XREF conv, parse) instead. It now works in CTFE,\n       and this template is very inefficient.)\n\n Parse unsigned integer literal from the start of string s.\n returns:\n    .value = the integer literal as a string,\n    .rest = the string following the integer literal\n Otherwise:\n    .value = null,\n    .rest = s\n \n",
    "line" : 177,
    "name" : "parseUinteger",
    "parameters" : [
     {
      "name" : "s",
      "kind" : "value",
      "deco" : "Axa"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n$(RED Deprecated.\n      Please use $(XREF conv, parse) instead. It now works in CTFE,\n      and this template is very inefficient.)\n\nParse integer literal optionally preceded by $(D '-') from the start\nof string $(D s).\n\nReturns:\n   .value = the integer literal as a string,\n   .rest = the string following the integer literal\n\nOtherwise:\n   .value = null,\n   .rest = s\n",
    "line" : 214,
    "name" : "parseInteger",
    "parameters" : [
     {
      "name" : "s",
      "kind" : "value",
      "deco" : "Axa"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL239_1286",
    "kind" : "function",
    "line" : 239,
    "endline" : 246
   }
  ]
 },
 {
  "name" : "std.mmfile",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/mmfile.d",
  "comment" : "\n Read and write memory mapped files.\n Macros:\n  WIKI=Phobos/StdMmfile\n\n Copyright: Copyright Digital Mars 2004 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Matthew Wilson\n Source:    $(PHOBOSSRC std/_mmfile.d)\n \n",
  "members" : [
   {
    "name" : "std.file",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdio",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.path",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.fcntl",
    "kind" : "import",
    "line" : 38,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 39,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.mman",
    "kind" : "import",
    "line" : 40,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.stat",
    "kind" : "import",
    "line" : 41,
    "protection" : "private"
   },
   {
    "name" : "MmFile",
    "kind" : "class",
    "comment" : "\n MmFile objects control the memory mapped file resource.\n \n",
    "line" : 52,
    "members" : [
     {
      "name" : "Mode",
      "kind" : "enum",
      "comment" : "\n The mode the memory mapped file is opened with.\n     \n",
      "line" : 57,
      "baseDeco" : "i",
      "members" : [
       {
        "name" : "read",
        "kind" : "enum member",
        "comment" : " Read existing file\n",
        "line" : 58
       },
       {
        "name" : "readWriteNew",
        "kind" : "enum member",
        "comment" : " Delete existing file, write new file\n",
        "line" : 59
       },
       {
        "name" : "readWrite",
        "kind" : "enum member",
        "comment" : " Read/Write existing file, create if not existing\n",
        "line" : 60
       },
       {
        "name" : "readCopyOnWrite",
        "kind" : "enum member",
        "comment" : " Read/Write existing file, copy on write\n",
        "line" : 61
       }
      ]
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Open memory mapped file filename for reading.\n File is closed when the object instance is deleted.\n Throws:\n  std.file.FileException\n     \n",
      "line" : 70,
      "deco" : "FAyaZC3std6mmfile6MmFile",
      "originalType" : "(string filename)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       }
      ],
      "endline" : 73
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 75,
      "deco" : "FS3std5stdio4FileE3std6mmfile6MmFile4ModemPvmZC3std6mmfile6MmFile",
      "originalType" : "(File file, Mode mode = Mode.read, ulong size = 0, void* address = null, size_t window = 0)",
      "parameters" : [
       {
        "name" : "file",
        "deco" : "S3std5stdio4File"
       },
       {
        "name" : "mode",
        "deco" : "E3std6mmfile6MmFile4Mode",
        "default" : "cast(Mode)0"
       },
       {
        "name" : "size",
        "deco" : "m",
        "default" : "0LU"
       },
       {
        "name" : "address",
        "deco" : "Pv",
        "default" : "null"
       },
       {
        "name" : "window",
        "deco" : "m",
        "default" : "0LU"
       }
      ],
      "endline" : 79
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 81,
      "deco" : "FiE3std6mmfile6MmFile4ModemPvmZC3std6mmfile6MmFile",
      "originalType" : "(int fildes, Mode mode, ulong size, void* address, size_t window)",
      "parameters" : [
       {
        "name" : "fildes",
        "deco" : "i"
       },
       {
        "name" : "mode",
        "deco" : "E3std6mmfile6MmFile4Mode"
       },
       {
        "name" : "size",
        "deco" : "m"
       },
       {
        "name" : "address",
        "deco" : "Pv"
       },
       {
        "name" : "window",
        "deco" : "m"
       }
      ],
      "endline" : 146
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Open memory mapped file filename in mode.\n File is closed when the object instance is deleted.\n Params:\n  filename = name of the file.\n      If null, an anonymous file mapping is created.\n  mode = access mode defined above.\n  size =  the size of the file. If 0, it is taken to be the\n      size of the existing file.\n  address = the preferred address to map the file to,\n      although the system is not required to honor it.\n      If null, the system selects the most convenient address.\n  window = preferred block size of the amount of data to map at one time\n      with 0 meaning map the entire file. The window size must be a\n      multiple of the memory allocation page size.\n Throws:\n  std.file.FileException\n     \n",
      "line" : 166,
      "deco" : "FAyaE3std6mmfile6MmFile4ModemPvmZC3std6mmfile6MmFile",
      "originalType" : "(string filename, Mode mode, ulong size, void* address, size_t window = 0)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6mmfile6MmFile4Mode"
       },
       {
        "name" : "size",
        "deco" : "m"
       },
       {
        "name" : "address",
        "deco" : "Pv"
       },
       {
        "name" : "window",
        "deco" : "m",
        "default" : "0LU"
       }
      ],
      "endline" : 358
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "comment" : "\n Flushes pending output and closes the memory mapped file.\n     \n",
      "line" : 363,
      "deco" : "FZv",
      "endline" : 390
     },
     {
      "name" : "flush",
      "kind" : "function",
      "line" : 394,
      "deco" : "FZv",
      "endline" : 411
     },
     {
      "name" : "length",
      "kind" : "function",
      "comment" : "\n Gives size in bytes of the memory mapped file.\n     \n",
      "line" : 416,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZm",
      "originalType" : "const ulong()",
      "endline" : 420
     },
     {
      "name" : "mode",
      "kind" : "function",
      "comment" : "\n Read-only property returning the file mode.\n     \n",
      "line" : 425,
      "deco" : "FZE3std6mmfile6MmFile4Mode",
      "endline" : 429
     },
     {
      "name" : "opSlice",
      "kind" : "function",
      "comment" : "\n Returns entire file contents as an array.\n     \n",
      "line" : 434,
      "deco" : "FZAv",
      "endline" : 438
     },
     {
      "name" : "opSlice",
      "kind" : "function",
      "comment" : "\n Returns slice of file contents as an array.\n     \n",
      "line" : 443,
      "deco" : "FmmZAv",
      "parameters" : [
       {
        "name" : "i1",
        "deco" : "m"
       },
       {
        "name" : "i2",
        "deco" : "m"
       }
      ],
      "endline" : 450
     },
     {
      "name" : "opIndex",
      "kind" : "function",
      "comment" : "\n Returns byte at index i in file.\n     \n",
      "line" : 455,
      "deco" : "FmZh",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 461
     },
     {
      "name" : "opIndexAssign",
      "kind" : "function",
      "comment" : "\n Sets and returns byte at index i in file to value.\n     \n",
      "line" : 466,
      "deco" : "FhmZh",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "h"
       },
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 472
     },
     {
      "name" : "mapped",
      "kind" : "function",
      "protection" : "private",
      "line" : 476,
      "deco" : "FmZi",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 481
     },
     {
      "name" : "unmap",
      "kind" : "function",
      "protection" : "private",
      "line" : 484,
      "deco" : "FZv",
      "endline" : 494
     },
     {
      "name" : "map",
      "kind" : "function",
      "protection" : "private",
      "line" : 497,
      "deco" : "FmmZv",
      "originalType" : "void(ulong start, size_t len)",
      "parameters" : [
       {
        "name" : "start",
        "deco" : "m"
       },
       {
        "name" : "len",
        "deco" : "m"
       }
      ],
      "endline" : 513
     },
     {
      "name" : "ensureMapped",
      "kind" : "function",
      "protection" : "private",
      "line" : 516,
      "deco" : "FmZv",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 531
     },
     {
      "name" : "ensureMapped",
      "kind" : "function",
      "protection" : "private",
      "line" : 534,
      "deco" : "FmmZv",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       },
       {
        "name" : "j",
        "deco" : "m"
       }
      ],
      "endline" : 551
     },
     {
      "name" : "filename",
      "kind" : "variable",
      "protection" : "private",
      "line" : 554,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "data",
      "kind" : "variable",
      "protection" : "private",
      "line" : 555,
      "deco" : "Av",
      "offset" : 32
     },
     {
      "name" : "start",
      "kind" : "variable",
      "protection" : "private",
      "line" : 556,
      "deco" : "m",
      "offset" : 48
     },
     {
      "name" : "window",
      "kind" : "variable",
      "protection" : "private",
      "line" : 557,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 56
     },
     {
      "name" : "size",
      "kind" : "variable",
      "protection" : "private",
      "line" : 558,
      "deco" : "m",
      "offset" : 64
     },
     {
      "name" : "mMode",
      "kind" : "variable",
      "protection" : "private",
      "line" : 559,
      "deco" : "E3std6mmfile6MmFile4Mode",
      "offset" : 72
     },
     {
      "name" : "address",
      "kind" : "variable",
      "protection" : "private",
      "line" : 560,
      "deco" : "Pv",
      "offset" : 80
     },
     {
      "name" : "fd",
      "kind" : "variable",
      "protection" : "private",
      "line" : 570,
      "deco" : "i",
      "offset" : 88
     },
     {
      "name" : "prot",
      "kind" : "variable",
      "protection" : "private",
      "line" : 571,
      "deco" : "i",
      "offset" : 92
     },
     {
      "name" : "flags",
      "kind" : "variable",
      "protection" : "private",
      "line" : 572,
      "deco" : "i",
      "offset" : 96
     },
     {
      "name" : "fmode",
      "kind" : "variable",
      "protection" : "private",
      "line" : 573,
      "deco" : "i",
      "offset" : 100
     }
    ]
   },
   {
    "name" : "__unittestL598_1287",
    "kind" : "function",
    "line" : 598,
    "endline" : 632
   }
  ]
 },
 {
  "name" : "std.numeric",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/numeric.d",
  "comment" : "\nThis module is a port of a growing fragment of the $(D_PARAM numeric)\nheader in Alexander Stepanov's $(LINK2 http://sgi.com/tech/stl,\nStandard Template Library), with a few additions.\n\nMacros:\n\nWIKI = Phobos/StdNumeric\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n                   Don Clugston, Robert Jacques\nSource:    $(PHOBOSSRC std/_numeric.d)\n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "std.bitmanip",
    "kind" : "import",
    "line" : 28,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 29,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 31,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 32,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 33,
    "protection" : "private"
   },
   {
    "name" : "std.random",
    "kind" : "import",
    "line" : 34,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdlib",
    "kind" : "import",
    "line" : 37,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 38,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 39,
    "protection" : "private"
   },
   {
    "name" : "std.complex",
    "kind" : "import",
    "line" : 40,
    "protection" : "private"
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 42,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 43,
    "protection" : "private"
   },
   {
    "name" : "CustomFloatFlags",
    "kind" : "enum",
    "comment" : " Format flags for CustomFloat.\n",
    "line" : 50,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "signed",
      "kind" : "enum member",
      "comment" : " Adds a sign bit to allow for signed numbers.\n",
      "line" : 53
     },
     {
      "name" : "storeNormalized",
      "kind" : "enum member",
      "comment" : "\n Store values in normalized form by default. The actual precision of the\n significand is extended by 1 bit by assuming an implicit leading bit of 1\n instead of 0. i.e. $(D 1.nnnn) instead of $(D 0.nnnn).\n True for all $(LUCKY IEE754) types\n     \n",
      "line" : 61
     },
     {
      "name" : "allowDenorm",
      "kind" : "enum member",
      "comment" : "\n Stores the significand in $(LUCKY IEEE754 denormalized) form when the\n exponent is 0. Required to express the value 0.\n     \n",
      "line" : 67
     },
     {
      "name" : "infinity",
      "kind" : "enum member",
      "comment" : " Allows the storage of $(LUCKY IEEE754 _infinity) values.\n",
      "line" : 70
     },
     {
      "name" : "nan",
      "kind" : "enum member",
      "comment" : " Allows the storage of $(LUCKY IEEE754 Not a Number) values.\n",
      "line" : 73
     },
     {
      "name" : "probability",
      "kind" : "enum member",
      "comment" : "\n If set, select an exponent bias such that max_exp = 1.\n i.e. so that the maximum value is >= 1.0 and < 2.0.\n Ignored if the exponent bias is manually specified.\n     \n",
      "line" : 80
     },
     {
      "name" : "negativeUnsigned",
      "kind" : "enum member",
      "comment" : " If set, unsigned custom floats are assumed to be negative.\n",
      "line" : 83
     },
     {
      "name" : "allowDenormZeroOnly",
      "kind" : "enum member",
      "comment" : "If set, 0 is the only allowed $(LUCKY IEEE754 denormalized) number.\n Requires allowDenorm and storeNormalized.\n     \n",
      "line" : 88
     },
     {
      "name" : "ieee",
      "kind" : "enum member",
      "comment" : " Include _all of the $(LUCKY IEEE754) options.\n",
      "line" : 91
     },
     {
      "name" : "none",
      "kind" : "enum member",
      "comment" : " Include none of the above options.\n",
      "line" : 94
     }
    ]
   },
   {
    "name" : "bsr64",
    "kind" : "function",
    "protection" : "private",
    "line" : 98,
    "deco" : "FmZi",
    "parameters" : [
     {
      "name" : "value",
      "deco" : "m"
     }
    ],
    "endline" : 109
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 111,
    "name" : "CustomFloatParams",
    "parameters" : [
     {
      "name" : "bits",
      "kind" : "value",
      "deco" : "k"
     }
    ],
    "members" : [
     {
      "name" : "flags",
      "kind" : "variable",
      "line" : 113,
      "storageClass" : [
       "enum"
      ],
      "type" : "CustomFloatFlags",
      "init" : "CustomFloatFlags.ieee ^ (bits == 80 ? CustomFloatFlags.storeNormalized : CustomFloatFlags.none)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 122,
    "name" : "CustomFloatParams",
    "parameters" : [
     {
      "name" : "precision",
      "kind" : "value",
      "deco" : "k"
     },
     {
      "name" : "exponentWidth",
      "kind" : "value",
      "deco" : "k"
     },
     {
      "name" : "flags",
      "kind" : "value",
      "deco" : "E3std7numeric16CustomFloatFlags"
     }
    ],
    "members" : [
     {
      "name" : "CustomFloatParams",
      "kind" : "alias",
      "line" : 130,
      "type" : "TypeTuple!(precision, exponentWidth, flags, (1 << exponentWidth - ((flags & flags.probability) == 0)) - ((flags & (flags.nan | flags.infinity)) != 0) - ((flags & flags.probability) != 0))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Allows user code to define custom floating-point formats. These formats are\n for storage only; all operations on them are performed by first implicitly\n extracting them to $(D real) first. After the operation is completed the\n result can be stored in a custom floating-point value via assignment.\n\n Example:\n ----\n // Define a 16-bit floating point values\n CustomFloat!16                                x;     // Using the number of bits\n CustomFloat!(10, 5)                           y;     // Using the precision and exponent width\n CustomFloat!(10, 5,CustomFloatFlags.ieee)     z;     // Using the precision, exponent width and format flags\n CustomFloat!(10, 5,CustomFloatFlags.ieee, 15) w;     // Using the precision, exponent width, format flags and exponent offset bias\n\n // Use the 16-bit floats mostly like normal numbers\n w = x*y - 1;\n writeln(w);\n\n // Functions calls require conversion\n z = sin(+x)           + cos(+y);                     // Use uniary plus to concisely convert to a real\n z = sin(x.re)         + cos(y.re);                   // Or use the .re property to convert to a real\n z = sin(x.get!float)  + cos(y.get!float);            // Or use get!T\n z = sin(cast(float)x) + cos(cast(float)y);           // Or use cast(T) to explicitly convert\n\n // Define a 8-bit custom float for storing probabilities\n alias CustomFloat!(4, 4, CustomFloatFlags.ieee^CustomFloatFlags.probability^CustomFloatFlags.signed ) Probability;\n auto p = Probability(0.5);\n ----\n \n",
    "line" : 162,
    "name" : "CustomFloat",
    "parameters" : [
     {
      "name" : "bits",
      "kind" : "value",
      "deco" : "k"
     }
    ],
    "members" : [
     {
      "name" : "CustomFloat",
      "kind" : "alias",
      "line" : 165,
      "type" : "CustomFloat!(CustomFloatParams!(bits))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 168,
    "name" : "CustomFloat",
    "parameters" : [
     {
      "name" : "precision",
      "kind" : "value",
      "deco" : "k"
     },
     {
      "name" : "exponentWidth",
      "kind" : "value",
      "deco" : "k"
     },
     {
      "name" : "flags",
      "kind" : "value",
      "deco" : "E3std7numeric16CustomFloatFlags",
      "defaultValue" : "CustomFloatFlags.ieee"
     }
    ],
    "members" : [
     {
      "name" : "CustomFloat",
      "kind" : "alias",
      "line" : 171,
      "type" : "CustomFloat!(CustomFloatParams!(precision, exponentWidth, flags))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 181,
    "name" : "CustomFloat",
    "parameters" : [
     {
      "name" : "precision",
      "kind" : "value",
      "deco" : "k"
     },
     {
      "name" : "exponentWidth",
      "kind" : "value",
      "deco" : "k"
     },
     {
      "name" : "flags",
      "kind" : "value",
      "deco" : "E3std7numeric16CustomFloatFlags"
     },
     {
      "name" : "bias",
      "kind" : "value",
      "deco" : "k"
     }
    ],
    "members" : [
     {
      "name" : "CustomFloat",
      "kind" : "struct",
      "line" : 181,
      "members" : [
       {
        "kind" : "template",
        "line" : 184,
        "name" : "uType",
        "parameters" : [
         {
          "name" : "bits",
          "kind" : "value",
          "deco" : "k"
         }
        ],
        "members" : []
       },
       {
        "kind" : "template",
        "line" : 190,
        "name" : "sType",
        "parameters" : [
         {
          "name" : "bits",
          "kind" : "value",
          "deco" : "k"
         }
        ],
        "members" : []
       },
       {
        "name" : "T_sig",
        "kind" : "alias",
        "line" : 195,
        "type" : "uType!(precision)"
       },
       {
        "name" : "T_exp",
        "kind" : "alias",
        "line" : 196,
        "type" : "uType!(exponentWidth)"
       },
       {
        "name" : "T_signed_exp",
        "kind" : "alias",
        "line" : 197,
        "type" : "sType!(exponentWidth)"
       },
       {
        "name" : "Flags",
        "kind" : "alias",
        "line" : 199,
        "type" : "CustomFloatFlags"
       },
       {
        "kind" : "template",
        "line" : 204,
        "name" : "ToBinary",
        "parameters" : [
         {
          "name" : "F",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "ToBinary",
          "kind" : "union",
          "line" : 204,
          "members" : [
           {
            "name" : "set",
            "kind" : "variable",
            "line" : 205,
            "type" : "F"
           },
           {
            "name" : "get",
            "kind" : "variable",
            "line" : 209,
            "type" : "CustomFloat!(CustomFloatParams!(min(F.sizeof * 8, 80)))"
           },
           {
            "name" : "opCall",
            "kind" : "function",
            "line" : 212,
            "type" : "typeof(get)(F value)",
            "parameters" : [
             {
              "name" : "value",
              "type" : "F"
             }
            ],
            "endline" : 216
           }
          ]
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 221,
        "name" : "roundedShift",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "roundedShift",
          "kind" : "function",
          "line" : 221,
          "type" : "void(ref T sig, U shift)",
          "parameters" : [
           {
            "name" : "sig",
            "type" : "T",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "shift",
            "type" : "U"
           }
          ],
          "endline" : 232
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 235,
        "name" : "toNormalized",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "toNormalized",
          "kind" : "function",
          "line" : 235,
          "type" : "void(ref T sig, ref U exp)",
          "parameters" : [
           {
            "name" : "sig",
            "type" : "T",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "exp",
            "type" : "U",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 266
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 269,
        "name" : "fromNormalized",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "fromNormalized",
          "kind" : "function",
          "line" : 269,
          "type" : "void(ref T sig, ref U exp)",
          "parameters" : [
           {
            "name" : "sig",
            "type" : "T",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "exp",
            "type" : "U",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 346
         }
        ]
       },
       {
        "name" : "dig",
        "kind" : "function",
        "comment" : " Returns: number of decimal digits of precision\n",
        "line" : 386,
        "type" : "size_t()",
        "endline" : 390
       },
       {
        "name" : "epsilon",
        "kind" : "function",
        "comment" : " Returns: smallest increment to the value 1\n",
        "line" : 393,
        "type" : "CustomFloat()",
        "endline" : 409
       },
       {
        "name" : "mant_dig",
        "kind" : "variable",
        "comment" : " the number of bits in mantissa\n",
        "line" : 412,
        "storageClass" : [
         "enum"
        ],
        "init" : "precision + ((flags & Flags.storeNormalized) != 0)"
       },
       {
        "name" : "max_10_exp",
        "kind" : "function",
        "comment" : " Returns: maximum int value such that 10<sup>max_10_exp</sup> is representable\n",
        "line" : 415,
        "type" : "int()",
        "endline" : 415
       },
       {
        "name" : "max_exp",
        "kind" : "variable",
        "comment" : " maximum int value such that 2<sup>max_exp-1</sup> is representable\n",
        "line" : 418,
        "storageClass" : [
         "enum"
        ],
        "init" : "exponent_max - bias + ((~flags & (Flags.infinity | flags.nan)) != 0)"
       },
       {
        "name" : "min_10_exp",
        "kind" : "function",
        "comment" : " Returns: minimum int value such that 10<sup>min_10_exp</sup> is representable\n",
        "line" : 421,
        "type" : "int()",
        "endline" : 421
       },
       {
        "name" : "min_exp",
        "kind" : "variable",
        "comment" : " minimum int value such that 2<sup>min_exp-1</sup> is representable as a normalized value\n",
        "line" : 424,
        "storageClass" : [
         "enum"
        ],
        "init" : "cast(T_signed_exp)-bias + 1 + ((flags & Flags.allowDenorm) != 0)"
       },
       {
        "name" : "max",
        "kind" : "function",
        "comment" : " Returns: largest representable value that's not infinity\n",
        "line" : 427,
        "type" : "CustomFloat()",
        "endline" : 434
       },
       {
        "name" : "min_normal",
        "kind" : "function",
        "comment" : " Returns: smallest representable normalized value that's not 0\n",
        "line" : 437,
        "type" : "CustomFloat()",
        "endline" : 447
       },
       {
        "name" : "re",
        "kind" : "function",
        "comment" : " Returns: real part\n",
        "line" : 450,
        "type" : "CustomFloat()",
        "endline" : 450
       },
       {
        "name" : "im",
        "kind" : "function",
        "comment" : " Returns: imaginary part\n",
        "line" : 453,
        "type" : "CustomFloat()",
        "endline" : 453
       },
       {
        "kind" : "template",
        "comment" : " Initialize from any $(D real) compatible type.\n",
        "line" : 456,
        "name" : "this",
        "parameters" : [
         {
          "name" : "F",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 456,
          "type" : "(F input)",
          "parameters" : [
           {
            "name" : "input",
            "type" : "F"
           }
          ],
          "endline" : 456
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Self assignment\n",
        "line" : 459,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "F",
          "kind" : "type",
          "type" : "CustomFloat"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : " Self assignment\n",
          "line" : 459,
          "type" : "void(F input)",
          "parameters" : [
           {
            "name" : "input",
            "type" : "F"
           }
          ],
          "endline" : 464
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Assigns from any $(D real) compatible type.\n",
        "line" : 467,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "F",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : " Assigns from any $(D real) compatible type.\n",
          "line" : 467,
          "type" : "void(F input)",
          "parameters" : [
           {
            "name" : "input",
            "type" : "F"
           }
          ],
          "endline" : 496
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Fetches the stored value either as a $(D float), $(D double) or $(D real).\n",
        "line" : 499,
        "name" : "get",
        "parameters" : [
         {
          "name" : "F",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "get",
          "kind" : "function",
          "line" : 499,
          "type" : "F()",
          "endline" : 516
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 518,
        "name" : "opCast",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCast",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 518,
          "type" : "T()",
          "endline" : 518
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Convert the CustomFloat to a real and perform the relavent operator on the result\n",
        "line" : 521,
        "name" : "opUnary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opUnary",
          "kind" : "function",
          "comment" : " Convert the CustomFloat to a real and perform the relavent operator on the result\n",
          "line" : 521,
          "type" : "real()",
          "endline" : 528
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 531,
        "name" : "opBinary",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinary",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 531,
          "type" : "real(T b)",
          "parameters" : [
           {
            "name" : "b",
            "type" : "T"
           }
          ],
          "endline" : 533
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 536,
        "name" : "opBinaryRight",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opBinaryRight",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 536,
          "type" : "real(T a)",
          "parameters" : [
           {
            "name" : "a",
            "type" : "T"
           }
          ],
          "endline" : 539
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 542,
        "name" : "opCmp",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCmp",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 542,
          "type" : "int(auto ref T b)",
          "parameters" : [
           {
            "name" : "b",
            "type" : "T",
            "storageClass" : [
             "auto",
             "ref"
            ]
           }
          ],
          "endline" : 546
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 549,
        "name" : "opOpAssign",
        "parameters" : [
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOpAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 549,
          "type" : "void(auto ref T b)",
          "parameters" : [
           {
            "name" : "b",
            "type" : "T",
            "storageClass" : [
             "auto",
             "ref"
            ]
           }
          ],
          "endline" : 551
         }
        ]
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : " ditto\n",
        "line" : 554,
        "type" : "string()",
        "endline" : 554
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL557_1288",
    "kind" : "function",
    "line" : 557,
    "endline" : 628
   },
   {
    "kind" : "template",
    "comment" : "\nDefines the fastest type to use when storing temporaries of a\ncalculation intended to ultimately yield a result of type $(D F)\n(where $(D F) must be one of $(D float), $(D double), or $(D\nreal)). When doing a multi-step computation, you may want to store\nintermediate results as $(D FPTemporary!F).\n\nExample:\n----\n// Average numbers in an array\ndouble avg(in double[] a)\n{\n    if (a.length == 0) return 0;\n    FPTemporary!double result = 0;\n    foreach (e; a) result += e;\n    return result / a.length;\n}\n----\n\nThe necessity of $(D FPTemporary) stems from the optimized\nfloating-point operations and registers present in virtually all\nprocessors. When adding numbers in the example above, the addition may\nin fact be done in $(D real) precision internally. In that case,\nstoring the intermediate $(D result) in $(D double format) is not only\nless precise, it is also (surprisingly) slower, because a conversion\nfrom $(D real) to $(D double) is performed every pass through the\nloop. This being a lose-lose situation, $(D FPTemporary!F) has been\ndefined as the $(I fastest) type to use for calculations at precision\n$(D F). There is no need to define a type for the $(I most accurate)\ncalculations, as that is always $(D real).\n\nFinally, there is no guarantee that using $(D FPTemporary!F) will\nalways be fastest, as the speed of floating-point calculations depends\non very many factors.\n \n",
    "line" : 628,
    "name" : "FPTemporary",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "FPTemporary",
      "kind" : "alias",
      "line" : 630,
      "deco" : "e"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nImplements the $(WEB tinyurl.com/2zb9yr, secant method) for finding a\nroot of the function $(D fun) starting from points $(D [xn_1, x_n])\n(ideally close to the root). $(D Num) may be $(D float), $(D double),\nor $(D real).\n\nExample:\n\n----\nfloat f(float x) {\n    return cos(x) - x*x*x;\n}\nauto x = secantMethod!(f)(0f, 1f);\nassert(approxEqual(x, 0.865474));\n----\n",
    "line" : 649,
    "name" : "secantMethod",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 651,
      "name" : "secantMethod",
      "parameters" : [
       {
        "name" : "Num",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "secantMethod",
        "kind" : "function",
        "line" : 651,
        "type" : "Num(Num xn_1, Num xn)",
        "parameters" : [
         {
          "name" : "xn_1",
          "type" : "Num"
         },
         {
          "name" : "xn",
          "type" : "Num"
         }
        ],
        "endline" : 663
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL666_1289",
    "kind" : "function",
    "line" : 666,
    "endline" : 680
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 682,
    "name" : "oppositeSigns",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "oppositeSigns",
      "kind" : "function",
      "line" : 682,
      "type" : "bool(T a, T b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T"
       },
       {
        "name" : "b",
        "type" : "T"
       }
      ],
      "endline" : 685
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "  Find a real root of a real function f(x) via bracketing.\n\n Given a function $(D f) and a range $(D [a..b]) such that $(D f(a))\n and $(D f(b)) have opposite signs, returns the value of $(D x) in\n the range which is closest to a root of $(D f(x)).  If $(D f(x))\n has more than one root in the range, one will be chosen\n arbitrarily.  If $(D f(x)) returns NaN, NaN will be returned;\n otherwise, this algorithm is guaranteed to succeed.\n\n Uses an algorithm based on TOMS748, which uses inverse cubic\n interpolation whenever possible, otherwise reverting to parabolic\n or secant interpolation. Compared to TOMS748, this implementation\n improves worst-case performance by a factor of more than 100, and\n typical performance by a factor of 2. For 80-bit reals, most\n problems require 8 to 15 calls to $(D f(x)) to achieve full machine\n precision. The worst-case performance (pathological cases) is\n approximately twice the number of bits.\n\n References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n pp733-744 (1993).  Fortran code available from $(WEB\n www.netlib.org,www.netlib.org) as algorithm TOMS478.\n\n \n",
    "line" : 713,
    "name" : "findRoot",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findRoot",
      "kind" : "function",
      "comment" : "  Find a real root of a real function f(x) via bracketing.\n\n Given a function $(D f) and a range $(D [a..b]) such that $(D f(a))\n and $(D f(b)) have opposite signs, returns the value of $(D x) in\n the range which is closest to a root of $(D f(x)).  If $(D f(x))\n has more than one root in the range, one will be chosen\n arbitrarily.  If $(D f(x)) returns NaN, NaN will be returned;\n otherwise, this algorithm is guaranteed to succeed.\n\n Uses an algorithm based on TOMS748, which uses inverse cubic\n interpolation whenever possible, otherwise reverting to parabolic\n or secant interpolation. Compared to TOMS748, this implementation\n improves worst-case performance by a factor of more than 100, and\n typical performance by a factor of 2. For 80-bit reals, most\n problems require 8 to 15 calls to $(D f(x)) to achieve full machine\n precision. The worst-case performance (pathological cases) is\n approximately twice the number of bits.\n\n References: \"On Enclosing Simple Roots of Nonlinear Equations\",\n G. Alefeld, F.A. Potra, Yixun Shi, Mathematics of Computation 61,\n pp733-744 (1993).  Fortran code available from $(WEB\n www.netlib.org,www.netlib.org) as algorithm TOMS478.\n\n \n",
      "line" : 713,
      "type" : "T(scope R delegate(T) f, T a, T b)",
      "parameters" : [
       {
        "name" : "f",
        "type" : "R delegate(T)",
        "storageClass" : [
         "scope"
        ]
       },
       {
        "name" : "a",
        "type" : "T"
       },
       {
        "name" : "b",
        "type" : "T"
       }
      ],
      "endline" : 718
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Find root of a real function f(x) by bracketing, allowing the\n termination condition to be specified.\n\n Params:\n\n f = Function to be analyzed\n\n ax = Left bound of initial range of $(D f) known to contain the\n root.\n\n bx = Right bound of initial range of $(D f) known to contain the\n root.\n\n fax = Value of $(D f(ax)).\n\n fbx = Value of $(D f(bx)). ($(D f(ax)) and $(D f(bx)) are commonly\n known in advance.)\n\n\n tolerance = Defines an early termination condition. Receives the\n             current upper and lower bounds on the root. The\n             delegate must return $(D true) when these bounds are\n             acceptable. If this function always returns $(D false),\n             full machine precision will be achieved.\n\n Returns:\n\n A tuple consisting of two ranges. The first two elements are the\n range (in $(D x)) of the root, while the second pair of elements\n are the corresponding function values at those points. If an exact\n root was found, both of the first two elements will contain the\n root, and the second pair of elements will be 0.\n \n",
    "line" : 753,
    "name" : "findRoot",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "findRoot",
      "kind" : "function",
      "comment" : " Find root of a real function f(x) by bracketing, allowing the\n termination condition to be specified.\n\n Params:\n\n f = Function to be analyzed\n\n ax = Left bound of initial range of $(D f) known to contain the\n root.\n\n bx = Right bound of initial range of $(D f) known to contain the\n root.\n\n fax = Value of $(D f(ax)).\n\n fbx = Value of $(D f(bx)). ($(D f(ax)) and $(D f(bx)) are commonly\n known in advance.)\n\n\n tolerance = Defines an early termination condition. Receives the\n             current upper and lower bounds on the root. The\n             delegate must return $(D true) when these bounds are\n             acceptable. If this function always returns $(D false),\n             full machine precision will be achieved.\n\n Returns:\n\n A tuple consisting of two ranges. The first two elements are the\n range (in $(D x)) of the root, while the second pair of elements\n are the corresponding function values at those points. If an exact\n root was found, both of the first two elements will contain the\n root, and the second pair of elements will be 0.\n \n",
      "line" : 753,
      "type" : "Tuple!(T, T, R, R)(scope R delegate(T) f, T ax, T bx, R fax, R fbx, scope bool delegate(T lo, T hi) tolerance)",
      "parameters" : [
       {
        "name" : "f",
        "type" : "R delegate(T)",
        "storageClass" : [
         "scope"
        ]
       },
       {
        "name" : "ax",
        "type" : "T"
       },
       {
        "name" : "bx",
        "type" : "T"
       },
       {
        "name" : "fax",
        "type" : "R"
       },
       {
        "name" : "fbx",
        "type" : "R"
       },
       {
        "name" : "tolerance",
        "type" : "bool delegate(T lo, T hi)",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 992
     }
    ]
   },
   {
    "name" : "__unittestL994_1292",
    "kind" : "function",
    "line" : 994,
    "endline" : 1185
   },
   {
    "kind" : "template",
    "comment" : "\nComputes $(LUCKY Euclidean distance) between input ranges $(D a) and\n$(D b). The two ranges must have the same length. The three-parameter\nversion stops computation as soon as the distance is greater than or\nequal to $(D limit) (this is useful to save computation if a small\ndistance is sought).\n \n",
    "line" : 1186,
    "name" : "euclideanDistance",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "euclideanDistance",
      "kind" : "function",
      "comment" : "\nComputes $(LUCKY Euclidean distance) between input ranges $(D a) and\n$(D b). The two ranges must have the same length. The three-parameter\nversion stops computation as soon as the distance is greater than or\nequal to $(D limit) (this is useful to save computation if a small\ndistance is sought).\n \n",
      "line" : 1186,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       }
      ],
      "endline" : 1199
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1203,
    "name" : "euclideanDistance",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "euclideanDistance",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1203,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b, F limit)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       },
       {
        "name" : "limit",
        "type" : "F"
       }
      ],
      "endline" : 1222
     }
    ]
   },
   {
    "name" : "__unittestL1224_1293",
    "kind" : "function",
    "line" : 1224,
    "endline" : 1240
   },
   {
    "kind" : "template",
    "comment" : "\nComputes the $(LUCKY dot product) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration.\n \n",
    "line" : 1241,
    "name" : "dotProduct",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dotProduct",
      "kind" : "function",
      "comment" : "\nComputes the $(LUCKY dot product) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration.\n \n",
      "line" : 1241,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       }
      ],
      "endline" : 1254
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1258,
    "name" : "dotProduct",
    "parameters" : [
     {
      "name" : "F1",
      "kind" : "type"
     },
     {
      "name" : "F2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dotProduct",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1258,
      "type" : "Unqual!(CommonType!(F1, F2))(in F1[] avector, in F2[] bvector)",
      "parameters" : [
       {
        "name" : "avector",
        "type" : "F1[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "bvector",
        "type" : "F2[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 1307
     }
    ]
   },
   {
    "name" : "__unittestL1309_1294",
    "kind" : "function",
    "line" : 1309,
    "endline" : 1334
   },
   {
    "kind" : "template",
    "comment" : "\nComputes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration. If either range has all-zero elements, return 0.\n \n",
    "line" : 1335,
    "name" : "cosineSimilarity",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cosineSimilarity",
      "kind" : "function",
      "comment" : "\nComputes the $(LUCKY cosine similarity) of input ranges $(D a) and $(D\nb). The two ranges must have the same length. If both ranges define\nlength, the check is done once; otherwise, it is done at each\niteration. If either range has all-zero elements, return 0.\n \n",
      "line" : 1335,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       }
      ],
      "endline" : 1351
     }
    ]
   },
   {
    "name" : "__unittestL1353_1295",
    "kind" : "function",
    "line" : 1353,
    "endline" : 1374
   },
   {
    "kind" : "template",
    "comment" : "\nNormalizes values in $(D range) by multiplying each element with a\nnumber chosen such that values sum up to $(D sum). If elements in $(D\nrange) sum to zero, assigns $(D sum / range.length) to\nall. Normalization makes sense only if all elements in $(D range) are\npositive. $(D normalize) assumes that is the case without checking it.\n\nReturns: $(D true) if normalization completed normally, $(D false) if\nall elements in $(D range) were zero or if $(D range) is empty.\n \n",
    "line" : 1374,
    "name" : "normalize",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "normalize",
      "kind" : "function",
      "comment" : "\nNormalizes values in $(D range) by multiplying each element with a\nnumber chosen such that values sum up to $(D sum). If elements in $(D\nrange) sum to zero, assigns $(D sum / range.length) to\nall. Normalization makes sense only if all elements in $(D range) are\npositive. $(D normalize) assumes that is the case without checking it.\n\nReturns: $(D true) if normalization completed normally, $(D false) if\nall elements in $(D range) were zero or if $(D range) is empty.\n \n",
      "line" : 1374,
      "type" : "bool(R range, ElementType!(R) sum = 1)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "sum",
        "type" : "ElementType!(R)",
        "default" : "1"
       }
      ],
      "endline" : 1410
     }
    ]
   },
   {
    "name" : "__unittestL1412_1296",
    "kind" : "function",
    "line" : 1412,
    "endline" : 1432
   },
   {
    "kind" : "template",
    "comment" : "\nComputes $(LUCKY _entropy) of input range $(D r) in bits. This\nfunction assumes (without checking) that the values in $(D r) are all\nin $(D [0, 1]). For the entropy to be meaningful, often $(D r) should\nbe normalized too (i.e., its values should sum to 1). The\ntwo-parameter version stops evaluating as soon as the intermediate\nresult is greater than or equal to $(D max).\n \n",
    "line" : 1432,
    "name" : "entropy",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "entropy",
      "kind" : "function",
      "comment" : "\nComputes $(LUCKY _entropy) of input range $(D r) in bits. This\nfunction assumes (without checking) that the values in $(D r) are all\nin $(D [0, 1]). For the entropy to be meaningful, often $(D r) should\nbe normalized too (i.e., its values should sum to 1). The\ntwo-parameter version stops evaluating as soon as the intermediate\nresult is greater than or equal to $(D max).\n \n",
      "line" : 1432,
      "type" : "ElementType!(Range)(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 1441
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1444,
    "name" : "entropy",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "entropy",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1444,
      "type" : "ElementType!(Range)(Range r, F max)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "max",
        "type" : "F"
       }
      ],
      "endline" : 1456
     }
    ]
   },
   {
    "name" : "__unittestL1458_1297",
    "kind" : "function",
    "line" : 1458,
    "endline" : 1479
   },
   {
    "kind" : "template",
    "comment" : "\nComputes the $(LUCKY Kullback-Leibler divergence) between input ranges\n$(D a) and $(D b), which is the sum $(D ai * log(ai / bi)). The base\nof logarithm is 2. The ranges are assumed to contain elements in $(D\n[0, 1]). Usually the ranges are normalized probability distributions,\nbut this is not required or checked by $(D\nkullbackLeiblerDivergence). If any element $(D bi) is zero and the\ncorresponding element $(D ai) nonzero, returns infinity. (Otherwise,\nif $(D ai == 0 && bi == 0), the term $(D ai * log(ai / bi)) is\nconsidered zero.) If the inputs are normalized, the result is\npositive.\n \n",
    "line" : 1480,
    "name" : "kullbackLeiblerDivergence",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "kullbackLeiblerDivergence",
      "kind" : "function",
      "comment" : "\nComputes the $(LUCKY Kullback-Leibler divergence) between input ranges\n$(D a) and $(D b), which is the sum $(D ai * log(ai / bi)). The base\nof logarithm is 2. The ranges are assumed to contain elements in $(D\n[0, 1]). Usually the ranges are normalized probability distributions,\nbut this is not required or checked by $(D\nkullbackLeiblerDivergence). If any element $(D bi) is zero and the\ncorresponding element $(D ai) nonzero, returns infinity. (Otherwise,\nif $(D ai == 0 && bi == 0), the term $(D ai * log(ai / bi)) is\nconsidered zero.) If the inputs are normalized, the result is\npositive.\n \n",
      "line" : 1480,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       }
      ],
      "endline" : 1497
     }
    ]
   },
   {
    "name" : "__unittestL1499_1298",
    "kind" : "function",
    "line" : 1499,
    "endline" : 1523
   },
   {
    "kind" : "template",
    "comment" : "\nComputes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D\nb), which is the sum $(D (ai * log(2 * ai / (ai + bi)) + bi * log(2 *\nbi / (ai + bi))) / 2). The base of logarithm is 2. The ranges are\nassumed to contain elements in $(D [0, 1]). Usually the ranges are\nnormalized probability distributions, but this is not required or\nchecked by $(D jensenShannonDivergence). If the inputs are normalized,\nthe result is bounded within $(D [0, 1]). The three-parameter version\nstops evaluations as soon as the intermediate result is greater than\nor equal to $(D limit).\n \n",
    "line" : 1524,
    "name" : "jensenShannonDivergence",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "jensenShannonDivergence",
      "kind" : "function",
      "comment" : "\nComputes the $(LUCKY Jensen-Shannon divergence) between $(D a) and $(D\nb), which is the sum $(D (ai * log(2 * ai / (ai + bi)) + bi * log(2 *\nbi / (ai + bi))) / 2). The base of logarithm is 2. The ranges are\nassumed to contain elements in $(D [0, 1]). Usually the ranges are\nnormalized probability distributions, but this is not required or\nchecked by $(D jensenShannonDivergence). If the inputs are normalized,\nthe result is bounded within $(D [0, 1]). The three-parameter version\nstops evaluations as soon as the intermediate result is greater than\nor equal to $(D limit).\n \n",
      "line" : 1524,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       }
      ],
      "endline" : 1547
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1551,
    "name" : "jensenShannonDivergence",
    "parameters" : [
     {
      "name" : "Range1",
      "kind" : "type"
     },
     {
      "name" : "Range2",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "jensenShannonDivergence",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1551,
      "type" : "CommonType!(ElementType!(Range1), ElementType!(Range2))(Range1 a, Range2 b, F limit)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "Range1"
       },
       {
        "name" : "b",
        "type" : "Range2"
       },
       {
        "name" : "limit",
        "type" : "F"
       }
      ],
      "endline" : 1577
     }
    ]
   },
   {
    "name" : "__unittestL1579_1299",
    "kind" : "function",
    "line" : 1579,
    "endline" : 1709
   },
   {
    "kind" : "template",
    "comment" : "\nThe so-called \"all-lengths gap-weighted string kernel\" computes a\nsimilarity measure between $(D s) and $(D t) based on all of their\ncommon subsequences of all lengths. Gapped subsequences are also\nincluded.\n\nTo understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,\nconsider first the case $(D lambda = 1) and the strings $(D s =\n[\"Hello\", \"brave\", \"new\", \"world\"]) and $(D t = [\"Hello\", \"new\",\n\"world\"]). In that case, $(D gapWeightedSimilarity) counts the\nfollowing matches:\n\n$(OL $(LI three matches of length 1, namely $(D \"Hello\"), $(D \"new\"),\nand $(D \"world\");) $(LI three matches of length 2, namely ($(D\n\"Hello\", \"new\")), ($(D \"Hello\", \"world\")), and ($(D \"new\", \"world\"));)\n$(LI one match of length 3, namely ($(D \"Hello\", \"new\", \"world\")).))\n\nThe call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of\nthese matches and adds them up, returning 7.\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 1) == 7);\n----\n\nNote how the gaps in matching are simply ignored, for example ($(D\n\"Hello\", \"new\")) is deemed as good a match as ($(D \"new\",\n\"world\")). This may be too permissive for some applications. To\neliminate gapped matches entirely, use $(D lambda = 0):\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0) == 4);\n----\n\nThe call above eliminated the gapped matches ($(D \"Hello\", \"new\")),\n($(D \"Hello\", \"world\")), and ($(D \"Hello\", \"new\", \"world\")) from the\ntally. That leaves only 4 matches.\n\nThe most interesting case is when gapped matches still participate in\nthe result, but not as strongly as ungapped matches. The result will\nbe a smooth, fine-grained similarity measure between the input\nstrings. This is where values of $(D lambda) between 0 and 1 enter\ninto play: gapped matches are $(I exponentially penalized with the\nnumber of gaps) with base $(D lambda). This means that an ungapped\nmatch adds 1 to the return value; a match with one gap in either\nstring adds $(D lambda) to the return value; ...; a match with a total\nof $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return\nvalue. In the example above, we have 4 matches without gaps, 2 matches\nwith one gap, and 1 match with three gaps. The latter match is ($(D\n\"Hello\", \"world\")), which has two gaps in the first string and one gap\nin the second string, totaling to three gaps. Summing these up we get\n$(D 4 + 2 * lambda + pow(lambda, 3)).\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);\n----\n\n$(D gapWeightedSimilarity) is useful wherever a smooth similarity\nmeasure between sequences allowing for approximate matches is\nneeded. The examples above are given with words, but any sequences\nwith elements comparable for equality are allowed, e.g. characters or\nnumbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic\nprogramming implementation that needs $(D 16 * min(s.length,\nt.length)) extra bytes of memory and $(BIGOH s.length * t.length) time\nto complete.\n \n",
    "line" : 1709,
    "name" : "gapWeightedSimilarity",
    "parameters" : [
     {
      "name" : "comp",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "gapWeightedSimilarity",
      "kind" : "function",
      "comment" : "\nThe so-called \"all-lengths gap-weighted string kernel\" computes a\nsimilarity measure between $(D s) and $(D t) based on all of their\ncommon subsequences of all lengths. Gapped subsequences are also\nincluded.\n\nTo understand what $(D gapWeightedSimilarity(s, t, lambda)) computes,\nconsider first the case $(D lambda = 1) and the strings $(D s =\n[\"Hello\", \"brave\", \"new\", \"world\"]) and $(D t = [\"Hello\", \"new\",\n\"world\"]). In that case, $(D gapWeightedSimilarity) counts the\nfollowing matches:\n\n$(OL $(LI three matches of length 1, namely $(D \"Hello\"), $(D \"new\"),\nand $(D \"world\");) $(LI three matches of length 2, namely ($(D\n\"Hello\", \"new\")), ($(D \"Hello\", \"world\")), and ($(D \"new\", \"world\"));)\n$(LI one match of length 3, namely ($(D \"Hello\", \"new\", \"world\")).))\n\nThe call $(D gapWeightedSimilarity(s, t, 1)) simply counts all of\nthese matches and adds them up, returning 7.\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 1) == 7);\n----\n\nNote how the gaps in matching are simply ignored, for example ($(D\n\"Hello\", \"new\")) is deemed as good a match as ($(D \"new\",\n\"world\")). This may be too permissive for some applications. To\neliminate gapped matches entirely, use $(D lambda = 0):\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0) == 4);\n----\n\nThe call above eliminated the gapped matches ($(D \"Hello\", \"new\")),\n($(D \"Hello\", \"world\")), and ($(D \"Hello\", \"new\", \"world\")) from the\ntally. That leaves only 4 matches.\n\nThe most interesting case is when gapped matches still participate in\nthe result, but not as strongly as ungapped matches. The result will\nbe a smooth, fine-grained similarity measure between the input\nstrings. This is where values of $(D lambda) between 0 and 1 enter\ninto play: gapped matches are $(I exponentially penalized with the\nnumber of gaps) with base $(D lambda). This means that an ungapped\nmatch adds 1 to the return value; a match with one gap in either\nstring adds $(D lambda) to the return value; ...; a match with a total\nof $(D n) gaps in both strings adds $(D pow(lambda, n)) to the return\nvalue. In the example above, we have 4 matches without gaps, 2 matches\nwith one gap, and 1 match with three gaps. The latter match is ($(D\n\"Hello\", \"world\")), which has two gaps in the first string and one gap\nin the second string, totaling to three gaps. Summing these up we get\n$(D 4 + 2 * lambda + pow(lambda, 3)).\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, t, 0.5) == 4 + 0.5 * 2 + 0.125);\n----\n\n$(D gapWeightedSimilarity) is useful wherever a smooth similarity\nmeasure between sequences allowing for approximate matches is\nneeded. The examples above are given with words, but any sequences\nwith elements comparable for equality are allowed, e.g. characters or\nnumbers. $(D gapWeightedSimilarity) uses a highly optimized dynamic\nprogramming implementation that needs $(D 16 * min(s.length,\nt.length)) extra bytes of memory and $(BIGOH s.length * t.length) time\nto complete.\n \n",
      "line" : 1709,
      "type" : "F(R1 s, R2 t, F lambda)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "R1"
       },
       {
        "name" : "t",
        "type" : "R2"
       },
       {
        "name" : "lambda",
        "type" : "F"
       }
      ],
      "endline" : 1748
     }
    ]
   },
   {
    "name" : "__unittestL1750_1300",
    "kind" : "function",
    "line" : 1750,
    "endline" : 1790
   },
   {
    "kind" : "template",
    "comment" : "\nThe similarity per $(D gapWeightedSimilarity) has an issue in that it\ngrows with the lengths of the two strings, even though the strings are\nnot actually very similar. For example, the range $(D [\"Hello\",\n\"world\"]) is increasingly similar with the range $(D [\"Hello\",\n\"world\", \"world\", \"world\",...]) as more instances of $(D \"world\") are\nappended. To prevent that, $(D gapWeightedSimilarityNormalized)\ncomputes a normalized version of the similarity that is computed as\n$(D gapWeightedSimilarity(s, t, lambda) /\nsqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,\nlambda))). The function $(D gapWeightedSimilarityNormalized) (a\nso-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)\nonly for ranges that don't match in any position, and $(D 1) only for\nidentical ranges.\n\nExample:\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, s, 1) == 15);\nassert(gapWeightedSimilarity(t, t, 1) == 7);\nassert(gapWeightedSimilarity(s, t, 1) == 7);\nassert(gapWeightedSimilarityNormalized(s, t, 1) == 7. / sqrt(15. * 7));\n----\n\nThe optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for\navoiding duplicate computation. Many applications may have already\ncomputed $(D gapWeightedSimilarity(s, s, lambda)) and/or $(D\ngapWeightedSimilarity(t, t, lambda)). In that case, they can be passed\nas $(D sSelfSim) and $(D tSelfSim), respectively.\n \n",
    "line" : 1791,
    "name" : "gapWeightedSimilarityNormalized",
    "parameters" : [
     {
      "name" : "comp",
      "kind" : "alias",
      "defaultAlias" : "\"a == b\""
     },
     {
      "name" : "R1",
      "kind" : "type"
     },
     {
      "name" : "R2",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "gapWeightedSimilarityNormalized",
      "kind" : "function",
      "comment" : "\nThe similarity per $(D gapWeightedSimilarity) has an issue in that it\ngrows with the lengths of the two strings, even though the strings are\nnot actually very similar. For example, the range $(D [\"Hello\",\n\"world\"]) is increasingly similar with the range $(D [\"Hello\",\n\"world\", \"world\", \"world\",...]) as more instances of $(D \"world\") are\nappended. To prevent that, $(D gapWeightedSimilarityNormalized)\ncomputes a normalized version of the similarity that is computed as\n$(D gapWeightedSimilarity(s, t, lambda) /\nsqrt(gapWeightedSimilarity(s, t, lambda) * gapWeightedSimilarity(s, t,\nlambda))). The function $(D gapWeightedSimilarityNormalized) (a\nso-called normalized kernel) is bounded in $(D [0, 1]), reaches $(D 0)\nonly for ranges that don't match in any position, and $(D 1) only for\nidentical ranges.\n\nExample:\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nassert(gapWeightedSimilarity(s, s, 1) == 15);\nassert(gapWeightedSimilarity(t, t, 1) == 7);\nassert(gapWeightedSimilarity(s, t, 1) == 7);\nassert(gapWeightedSimilarityNormalized(s, t, 1) == 7. / sqrt(15. * 7));\n----\n\nThe optional parameters $(D sSelfSim) and $(D tSelfSim) are meant for\navoiding duplicate computation. Many applications may have already\ncomputed $(D gapWeightedSimilarity(s, s, lambda)) and/or $(D\ngapWeightedSimilarity(t, t, lambda)). In that case, they can be passed\nas $(D sSelfSim) and $(D tSelfSim), respectively.\n \n",
      "line" : 1791,
      "type" : "Select!(isFloatingPoint!(F), F, double)(R1 s, R2 t, F lambda, F sSelfSim = F.init, F tSelfSim = F.init)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "R1"
       },
       {
        "name" : "t",
        "type" : "R2"
       },
       {
        "name" : "lambda",
        "type" : "F"
       },
       {
        "name" : "sSelfSim",
        "type" : "F",
        "default" : "F.init"
       },
       {
        "name" : "tSelfSim",
        "type" : "F",
        "default" : "F.init"
       }
      ],
      "endline" : 1810
     }
    ]
   },
   {
    "name" : "__unittestL1812_1301",
    "kind" : "function",
    "line" : 1812,
    "endline" : 1849
   },
   {
    "kind" : "template",
    "comment" : "\nSimilar to $(D gapWeightedSimilarity), just works in an incremental\nmanner by first revealing the matches of length 1, then gapped matches\nof length 2, and so on. The memory requirement is $(BIGOH s.length *\nt.length). The time complexity is $(BIGOH s.length * t.length) time\nfor computing each step. Continuing on the previous example:\n\n----\nstring[] s = [\"Hello\", \"brave\", \"new\", \"world\"];\nstring[] t = [\"Hello\", \"new\", \"world\"];\nauto simIter = gapWeightedSimilarityIncremental(s, t, 1);\nassert(simIter.front == 3); // three 1-length matches\nsimIter.popFront();\nassert(simIter.front == 3); // three 2-length matches\nsimIter.popFront();\nassert(simIter.front == 1); // one 3-length match\nsimIter.popFront();\nassert(simIter.empty);     // no more match\n----\n\nThe implementation is based on the pseudocode in Fig. 4 of the paper\n$(WEB jmlr.csail.mit.edu/papers/volume6/rousu05a/rousu05a.pdf,\n\"Efﬁcient Computation of Gapped Substring Kernels on Large Alphabets\")\nby Rousu et al., with additional algorithmic and systems-level\noptimizations.\n \n",
    "line" : 1851,
    "name" : "GapWeightedSimilarityIncremental",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type",
      "defaultDeco" : "d"
     }
    ],
    "members" : [
     {
      "name" : "GapWeightedSimilarityIncremental",
      "kind" : "struct",
      "line" : 1851,
      "members" : [
       {
        "name" : "s",
        "kind" : "variable",
        "line" : 1853,
        "type" : "Range"
       },
       {
        "name" : "t",
        "kind" : "variable",
        "line" : 1853,
        "type" : "Range"
       },
       {
        "name" : "currentValue",
        "kind" : "variable",
        "line" : 1854,
        "type" : "F",
        "init" : "0"
       },
       {
        "name" : "kl",
        "kind" : "variable",
        "line" : 1855,
        "type" : "F*"
       },
       {
        "name" : "gram",
        "kind" : "variable",
        "line" : 1856,
        "type" : "size_t",
        "init" : "void"
       },
       {
        "name" : "lambda",
        "kind" : "variable",
        "line" : 1857,
        "type" : "F",
        "init" : "void"
       },
       {
        "name" : "lambda2",
        "kind" : "variable",
        "line" : 1857,
        "type" : "F",
        "init" : "void"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\nConstructs an object given two ranges $(D s) and $(D t) and a penalty\n$(D lambda). Constructor completes in $(BIGOH s.length * t.length)\ntime and computes all matches of length 1.\n \n",
        "line" : 1865,
        "type" : "(Range s, Range t, F lambda)",
        "parameters" : [
         {
          "name" : "s",
          "type" : "Range"
         },
         {
          "name" : "t",
          "type" : "Range"
         },
         {
          "name" : "lambda",
          "type" : "F"
         }
        ],
        "endline" : 1913
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : "\nReturns $(D this).\n \n",
        "line" : 1918,
        "type" : "GapWeightedSimilarityIncremental()",
        "endline" : 1921
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\nComputes the match of the popFront length. Completes in $(BIGOH s.length *\nt.length) time.\n \n",
        "line" : 1927,
        "type" : "void()",
        "endline" : 1997
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\nReturns the gapped similarity at the current match length (initially\n1, grows with each call to $(D popFront)).\n \n",
        "line" : 2003,
        "type" : "F()",
        "endline" : 2003
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\nReturns whether there are more matches.\n \n",
        "line" : 2008,
        "type" : "bool()",
        "endline" : 2015
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nDitto\n \n",
    "line" : 2021,
    "name" : "gapWeightedSimilarityIncremental",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "gapWeightedSimilarityIncremental",
      "kind" : "function",
      "comment" : "\nDitto\n \n",
      "line" : 2021,
      "type" : "GapWeightedSimilarityIncremental!(R, F)(R r1, R r2, F penalty)",
      "parameters" : [
       {
        "name" : "r1",
        "type" : "R"
       },
       {
        "name" : "r2",
        "type" : "R"
       },
       {
        "name" : "penalty",
        "type" : "F"
       }
      ],
      "endline" : 2025
     }
    ]
   },
   {
    "name" : "__unittestL2027_1302",
    "kind" : "function",
    "line" : 2027,
    "endline" : 2068
   },
   {
    "name" : "__unittestL2068_1303",
    "kind" : "function",
    "line" : 2068,
    "endline" : 2100
   },
   {
    "kind" : "template",
    "comment" : "\nComputes the greatest common divisor of $(D a) and $(D b) by using\nEuler's algorithm.\n \n",
    "line" : 2100,
    "name" : "gcd",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "gcd",
      "kind" : "function",
      "comment" : "\nComputes the greatest common divisor of $(D a) and $(D b) by using\nEuler's algorithm.\n \n",
      "line" : 2100,
      "type" : "T(T a, T b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T"
       },
       {
        "name" : "b",
        "type" : "T"
       }
      ],
      "endline" : 2114
     }
    ]
   },
   {
    "name" : "__unittestL2116_1304",
    "kind" : "function",
    "line" : 2116,
    "endline" : 2183
   },
   {
    "name" : "lookup_t",
    "kind" : "alias",
    "protection" : "private",
    "line" : 2183,
    "deco" : "f"
   },
   {
    "name" : "Fft",
    "kind" : "class",
    "comment" : "A class for performing fast Fourier transforms of power of two sizes.\n This class encapsulates a large amount of state that is reusable when\n performing multiple FFTs of sizes smaller than or equal to that specified\n in the constructor.  This results in substantial speedups when performing\n multiple FFTs with a known maximum size.  However,\n a free function API is provided for convenience if you need to perform a\n one-off FFT.\n\n References:\n $(WEB en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm)\n \n",
    "line" : 2196,
    "members" : [
     {
      "name" : "negSinLookup",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2198,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yAAf",
      "originalType" : "lookup_t[][]",
      "offset" : 16
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 2200,
      "name" : "enforceSize",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "enforceSize",
        "kind" : "function",
        "line" : 2200,
        "type" : "const void(R range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         }
        ],
        "endline" : 2203
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 2205,
      "name" : "fftImpl",
      "parameters" : [
       {
        "name" : "Ret",
        "kind" : "type"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fftImpl",
        "kind" : "function",
        "line" : 2205,
        "type" : "const void(Stride!(R) range, Ret buf)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "Stride!(R)"
         },
         {
          "name" : "buf",
          "type" : "Ret"
         }
        ],
        "endline" : 2226
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 2233,
      "name" : "fftImplPureReal",
      "parameters" : [
       {
        "name" : "Ret",
        "kind" : "type"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fftImplPureReal",
        "kind" : "function",
        "line" : 2233,
        "type" : "const void(R range, Ret buf)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         },
         {
          "name" : "buf",
          "type" : "Ret"
         }
        ],
        "endline" : 2322
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 2324,
      "name" : "butterfly",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "butterfly",
        "kind" : "function",
        "line" : 2324,
        "type" : "const void(R buf)",
        "parameters" : [
         {
          "name" : "buf",
          "type" : "R"
         }
        ],
        "endline" : 2386
       }
      ]
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2394,
      "deco" : "FAfZC3std7numeric3Fft",
      "originalType" : "(lookup_t[] memSpace)",
      "parameters" : [
       {
        "name" : "memSpace",
        "deco" : "Af"
       }
      ],
      "endline" : 2444
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "Create an $(D Fft) object for computing fast Fourier transforms of\n power of two sizes of $(D size) or smaller.  $(D size) must be a\n power of two.\n     \n",
      "line" : 2451,
      "deco" : "FmZC3std7numeric3Fft",
      "originalType" : "(size_t size)",
      "parameters" : [
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2456
     },
     {
      "name" : "size",
      "kind" : "function",
      "line" : 2458,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZm",
      "originalType" : "const size_t()",
      "endline" : 2460
     },
     {
      "kind" : "template",
      "comment" : "Compute the Fourier transform of range using the $(BIGOH N log N)\n Cooley-Tukey Algorithm.  $(D range) must be a random-access range with\n slicing and a length equal to $(D size) as provided at the construction of\n this object.  The contents of range can be either  numeric types,\n which will be interpreted as pure real values, or complex types with\n properties or members $(D .re) and $(D .im) that can be read.\n\n Note:  Pure real FFTs are automatically detected and the relevant\n        optimizations are performed.\n\n Returns:  An array of complex numbers representing the transformed data in\n           the frequency domain.\n     \n",
      "line" : 2475,
      "name" : "fft",
      "parameters" : [
       {
        "name" : "F",
        "kind" : "type",
        "defaultDeco" : "d"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fft",
        "kind" : "function",
        "comment" : "Compute the Fourier transform of range using the $(BIGOH N log N)\n Cooley-Tukey Algorithm.  $(D range) must be a random-access range with\n slicing and a length equal to $(D size) as provided at the construction of\n this object.  The contents of range can be either  numeric types,\n which will be interpreted as pure real values, or complex types with\n properties or members $(D .re) and $(D .im) that can be read.\n\n Note:  Pure real FFTs are automatically detected and the relevant\n        optimizations are performed.\n\n Returns:  An array of complex numbers representing the transformed data in\n           the frequency domain.\n     \n",
        "line" : 2475,
        "type" : "const Complex!(F)[](R range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         }
        ],
        "endline" : 2488
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "Same as the overload, but allows for the results to be stored in a user-\n provided buffer.  The buffer must be of the same length as range, must be\n a random-access range, must have slicing, and must contain elements that are\n complex-like.  This means that they must have a .re and a .im member or\n property that can be both read and written and are floating point numbers.\n     \n",
      "line" : 2496,
      "name" : "fft",
      "parameters" : [
       {
        "name" : "Ret",
        "kind" : "type"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "fft",
        "kind" : "function",
        "comment" : "Same as the overload, but allows for the results to be stored in a user-\n provided buffer.  The buffer must be of the same length as range, must be\n a random-access range, must have slicing, and must contain elements that are\n complex-like.  This means that they must have a .re and a .im member or\n property that can be both read and written and are floating point numbers.\n     \n",
        "line" : 2496,
        "type" : "const void(R range, Ret buf)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         },
         {
          "name" : "buf",
          "type" : "Ret"
         }
        ],
        "endline" : 2521
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "Computes the inverse Fourier transform of a range.  The range must be a\n random access range with slicing, have a length equal to the size\n provided at construction of this object, and contain elements that are\n either of type std.complex.Complex or have essentially\n the same compile-time interface.\n\n Returns:  The time-domain signal.\n     \n",
      "line" : 2531,
      "name" : "inverseFft",
      "parameters" : [
       {
        "name" : "F",
        "kind" : "type",
        "defaultDeco" : "d"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "inverseFft",
        "kind" : "function",
        "comment" : "Computes the inverse Fourier transform of a range.  The range must be a\n random access range with slicing, have a length equal to the size\n provided at construction of this object, and contain elements that are\n either of type std.complex.Complex or have essentially\n the same compile-time interface.\n\n Returns:  The time-domain signal.\n     \n",
        "line" : 2531,
        "type" : "const Complex!(F)[](R range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         }
        ],
        "endline" : 2544
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "Inverse FFT that allows a user-supplied buffer to be provided.  The buffer\n must be a random access range with slicing, and its elements\n must be some complex-like type.\n     \n",
      "line" : 2550,
      "name" : "inverseFft",
      "parameters" : [
       {
        "name" : "Ret",
        "kind" : "type"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "inverseFft",
        "kind" : "function",
        "comment" : "Inverse FFT that allows a user-supplied buffer to be provided.  The buffer\n must be a random access range with slicing, and its elements\n must be some complex-like type.\n     \n",
        "line" : 2550,
        "type" : "const void(R range, Ret buf)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         },
         {
          "name" : "buf",
          "type" : "Ret"
         }
        ],
        "endline" : 2563
       }
      ]
     }
    ]
   },
   {
    "name" : "MakeLocalFft",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2569,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"\\x0a    auto lookupBuf = (cast(lookup_t*) malloc(range.length * 2 * lookup_t.sizeof))\\x0a                     [0..2 * range.length];\\x0a    if(!lookupBuf.ptr) {\\x0a        throw new OutOfMemoryError(__FILE__, __LINE__);\\x0a    }\\x0a    scope(exit) free(cast(void*) lookupBuf.ptr);\\x0a    auto fftObj = scoped!Fft(lookupBuf);\\x0a\""
   },
   {
    "kind" : "template",
    "comment" : "Convenience functions that create an $(D Fft) object, run the FFT or inverse\n FFT and return the result.  Useful for one-off FFTs.\n\n Note:  In addition to convenience, these functions are slightly more\n        efficient than manually creating an Fft object for a single use,\n        as the Fft object is deterministically destroyed before these\n        functions return.\n \n",
    "line" : 2587,
    "name" : "fft",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type",
      "defaultDeco" : "d"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "fft",
      "kind" : "function",
      "comment" : "Convenience functions that create an $(D Fft) object, run the FFT or inverse\n FFT and return the result.  Useful for one-off FFTs.\n\n Note:  In addition to convenience, these functions are slightly more\n        efficient than manually creating an Fft object for a single use,\n        as the Fft object is deterministically destroyed before these\n        functions return.\n \n",
      "line" : 2587,
      "type" : "Complex!(F)[](R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 2590
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2593,
    "name" : "fft",
    "parameters" : [
     {
      "name" : "Ret",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "fft",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2593,
      "type" : "void(R range, Ret buf)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "buf",
        "type" : "Ret"
       }
      ],
      "endline" : 2596
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2599,
    "name" : "inverseFft",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type",
      "defaultDeco" : "d"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "inverseFft",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2599,
      "type" : "Complex!(F)[](R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 2602
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2605,
    "name" : "inverseFft",
    "parameters" : [
     {
      "name" : "Ret",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "inverseFft",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2605,
      "type" : "void(R range, Ret buf)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "buf",
        "type" : "Ret"
       }
      ],
      "endline" : 2608
     }
    ]
   },
   {
    "name" : "__unittestL2610_1305",
    "kind" : "function",
    "line" : 2610,
    "endline" : 2678
   },
   {
    "kind" : "template",
    "line" : 2678,
    "name" : "swapRealImag",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "swapRealImag",
      "kind" : "function",
      "line" : 2678,
      "type" : "C(C input)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "C"
       }
      ],
      "endline" : 2680
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2686,
    "name" : "Stride",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Stride",
      "kind" : "struct",
      "line" : 2686,
      "members" : [
       {
        "name" : "range",
        "kind" : "variable",
        "line" : 2687,
        "type" : "Unqual!(R)"
       },
       {
        "name" : "_nSteps",
        "kind" : "variable",
        "line" : 2688,
        "type" : "size_t"
       },
       {
        "name" : "_length",
        "kind" : "variable",
        "line" : 2689,
        "type" : "size_t"
       },
       {
        "name" : "E",
        "kind" : "alias",
        "line" : 2690,
        "type" : "ElementType!(R)"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 2692,
        "type" : "(R range, size_t nStepsIn)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         },
         {
          "name" : "nStepsIn",
          "type" : "size_t"
         }
        ],
        "endline" : 2696
       },
       {
        "name" : "length",
        "kind" : "function",
        "line" : 2698,
        "type" : "const @property size_t()",
        "endline" : 2700
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 2702,
        "type" : "@property typeof(this)()",
        "endline" : 2706
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "line" : 2708,
        "type" : "E(size_t index)",
        "parameters" : [
         {
          "name" : "index",
          "type" : "size_t"
         }
        ],
        "endline" : 2710
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 2712,
        "type" : "@property E()",
        "endline" : 2714
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 2716,
        "type" : "void()",
        "endline" : 2724
       },
       {
        "name" : "popHalf",
        "kind" : "function",
        "line" : 2727,
        "type" : "void()",
        "endline" : 2729
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 2731,
        "type" : "const @property bool()",
        "endline" : 2733
       },
       {
        "name" : "nSteps",
        "kind" : "function",
        "line" : 2735,
        "type" : "const @property size_t()",
        "endline" : 2737
       },
       {
        "name" : "doubleSteps",
        "kind" : "function",
        "line" : 2739,
        "type" : "void()",
        "endline" : 2742
       },
       {
        "name" : "nSteps",
        "kind" : "function",
        "line" : 2744,
        "type" : "@property size_t(size_t newVal)",
        "parameters" : [
         {
          "name" : "newVal",
          "type" : "size_t"
         }
        ],
        "endline" : 2750
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2756,
    "name" : "slowFourier2",
    "parameters" : [
     {
      "name" : "Ret",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "slowFourier2",
      "kind" : "function",
      "line" : 2756,
      "type" : "void(R range, Ret buf)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "buf",
        "type" : "Ret"
       }
      ],
      "endline" : 2761
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2765,
    "name" : "slowFourier4",
    "parameters" : [
     {
      "name" : "Ret",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "slowFourier4",
      "kind" : "function",
      "line" : 2765,
      "type" : "void(R range, Ret buf)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "buf",
        "type" : "Ret"
       }
      ],
      "endline" : 2774
     }
    ]
   },
   {
    "name" : "isPowerOfTwo",
    "kind" : "function",
    "protection" : "private",
    "line" : 2776,
    "deco" : "FmZb",
    "originalType" : "bool(size_t num)",
    "parameters" : [
     {
      "name" : "num",
      "deco" : "m"
     }
    ],
    "endline" : 2778
   },
   {
    "name" : "roundDownToPowerOf2",
    "kind" : "function",
    "protection" : "private",
    "line" : 2780,
    "deco" : "FmZm",
    "originalType" : "size_t(size_t num)",
    "parameters" : [
     {
      "name" : "num",
      "deco" : "m"
     }
    ],
    "endline" : 2782
   },
   {
    "name" : "__unittestL2784_1306",
    "kind" : "function",
    "protection" : "private",
    "line" : 2784,
    "endline" : 2789
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2789,
    "name" : "isComplexLike",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isComplexLike",
      "kind" : "variable",
      "line" : 2790,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof(T.init.re)) && is(typeof(T.init.im))"
     }
    ]
   },
   {
    "name" : "__unittestL2794_1307",
    "kind" : "function",
    "protection" : "private",
    "line" : 2794,
    "endline" : 2799
   }
  ]
 },
 {
  "name" : "std.outbuffer",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/outbuffer.d",
  "comment" : "\n Macros:\n      WIKI = Phobos/StdOutbuffer\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_outbuffer.d)\n \n",
  "members" : [
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdio",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdlib",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdarg",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "OutBuffer",
    "kind" : "class",
    "comment" : "\n OutBuffer provides a way to build up an array of bytes out\n of raw data. It is useful for things like preparing an\n array of bytes to write out to a file.\n OutBuffer's byte order is the format native to the computer.\n To control the byte order (endianness), use a class derived\n from OutBuffer.\n \n",
    "line" : 39,
    "members" : [
     {
      "name" : "data",
      "kind" : "variable",
      "line" : 40,
      "deco" : "Ah",
      "offset" : 16
     },
     {
      "name" : "offset",
      "kind" : "variable",
      "line" : 41,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 32
     },
     {
      "name" : "__invariant15",
      "kind" : "function",
      "line" : 43,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 49,
      "deco" : "FZC3std9outbuffer9OutBuffer",
      "originalType" : "()",
      "endline" : 52
     },
     {
      "name" : "toBytes",
      "kind" : "function",
      "comment" : "\n Convert to array of bytes.\n     \n",
      "line" : 58,
      "deco" : "FZAh",
      "endline" : 58
     },
     {
      "name" : "reserve",
      "kind" : "function",
      "comment" : "\n Preallocate nbytes more to the size of the internal buffer.\n\n This is a\n speed optimization, a good guess at the maximum size of the resulting\n buffer will improve performance by eliminating reallocations and copying.\n     \n",
      "line" : 69,
      "deco" : "FmZv",
      "originalType" : "void(size_t nbytes)",
      "parameters" : [
       {
        "name" : "nbytes",
        "deco" : "m"
       }
      ],
      "endline" : 86,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 71,
       "deco" : "FZv",
       "endline" : 71
      },
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 75,
       "deco" : "FZv",
       "endline" : 75
      }
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : "\n Append data to the internal buffer.\n     \n",
      "line" : 92,
      "deco" : "FAxhZv",
      "parameters" : [
       {
        "name" : "bytes",
        "deco" : "Axh"
       }
      ],
      "endline" : 97
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 99,
      "deco" : "FxAuZv",
      "originalType" : "void(in wchar[] chars)",
      "parameters" : [
       {
        "name" : "chars",
        "deco" : "xAu"
       }
      ],
      "endline" : 102
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 104,
      "deco" : "FAxwZv",
      "parameters" : [
       {
        "name" : "chars",
        "deco" : "Axw"
       }
      ],
      "endline" : 107
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 109,
      "deco" : "FhZv",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "h"
       }
      ],
      "endline" : 114
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 116,
      "deco" : "FgZv",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "g"
       }
      ],
      "endline" : 116
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 117,
      "deco" : "FaZv",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "a"
       }
      ],
      "endline" : 117
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 118,
      "deco" : "FwZv",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 118
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 120,
      "deco" : "FtZv",
      "parameters" : [
       {
        "name" : "w",
        "deco" : "t"
       }
      ],
      "endline" : 125
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 127,
      "deco" : "FsZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "s"
       }
      ],
      "endline" : 127
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 129,
      "deco" : "FuZv",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "u"
       }
      ],
      "endline" : 134
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 136,
      "deco" : "FkZv",
      "parameters" : [
       {
        "name" : "w",
        "deco" : "k"
       }
      ],
      "endline" : 141
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 143,
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "i"
       }
      ],
      "endline" : 143
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 145,
      "deco" : "FmZv",
      "parameters" : [
       {
        "name" : "l",
        "deco" : "m"
       }
      ],
      "endline" : 150
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 152,
      "deco" : "FlZv",
      "parameters" : [
       {
        "name" : "l",
        "deco" : "l"
       }
      ],
      "endline" : 152
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 154,
      "deco" : "FfZv",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "f"
       }
      ],
      "endline" : 159
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 161,
      "deco" : "FdZv",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "d"
       }
      ],
      "endline" : 166
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 168,
      "deco" : "FeZv",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "e"
       }
      ],
      "endline" : 173
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 175,
      "deco" : "FxAaZv",
      "originalType" : "void(in char[] s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "xAa"
       }
      ],
      "endline" : 178
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 184,
      "deco" : "FC3std9outbuffer9OutBufferZv",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "C3std9outbuffer9OutBuffer"
       }
      ],
      "endline" : 187
     },
     {
      "name" : "fill0",
      "kind" : "function",
      "comment" : "\n Append nbytes of 0 to the internal buffer.\n     \n",
      "line" : 193,
      "deco" : "FmZv",
      "originalType" : "void(size_t nbytes)",
      "parameters" : [
       {
        "name" : "nbytes",
        "deco" : "m"
       }
      ],
      "endline" : 198
     },
     {
      "name" : "alignSize",
      "kind" : "function",
      "comment" : "\n 0-fill to align on power of 2 boundary.\n     \n",
      "line" : 204,
      "deco" : "FmZv",
      "originalType" : "void(size_t alignsize)",
      "parameters" : [
       {
        "name" : "alignsize",
        "deco" : "m"
       }
      ],
      "endline" : 218,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 206,
       "deco" : "FZv",
       "endline" : 206
      },
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 210,
       "deco" : "FZv",
       "endline" : 210
      }
     },
     {
      "name" : "align2",
      "kind" : "function",
      "comment" : "\n Optimize common special case alignSize(2)\n     \n",
      "line" : 224,
      "deco" : "FZv",
      "endline" : 228
     },
     {
      "name" : "align4",
      "kind" : "function",
      "comment" : "\n Optimize common special case alignSize(4)\n     \n",
      "line" : 234,
      "deco" : "FZv",
      "endline" : 240
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Convert internal buffer to array of chars.\n     \n",
      "line" : 246,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZAya",
      "endline" : 250,
      "overrides" : [
       "object.Object.toString"
      ]
     },
     {
      "name" : "vprintf",
      "kind" : "function",
      "comment" : "\n Append output of C's vprintf() to internal buffer.\n     \n",
      "line" : 256,
      "deco" : "FAyaPvZv",
      "originalType" : "void(string format, va_list args)",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "Aya"
       },
       {
        "name" : "args",
        "deco" : "Pv"
       }
      ],
      "endline" : 303
     },
     {
      "name" : "printf",
      "kind" : "function",
      "comment" : "\n Append output of C's printf() to internal buffer.\n     \n",
      "line" : 309,
      "deco" : "FAyaYv",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "Aya"
       }
      ],
      "endline" : 332
     },
     {
      "name" : "spread",
      "kind" : "function",
      "comment" : "\n At offset index into buffer, create nbytes of space by shifting upwards\n all data past index.\n     \n",
      "line" : 339,
      "deco" : "FmmZv",
      "originalType" : "void(size_t index, size_t nbytes)",
      "parameters" : [
       {
        "name" : "index",
        "deco" : "m"
       },
       {
        "name" : "nbytes",
        "deco" : "m"
       }
      ],
      "endline" : 355,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 341,
       "deco" : "FZv",
       "endline" : 341
      }
     },
     {
      "name" : "__invariant",
      "kind" : "function",
      "line" : 39,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     }
    ]
   },
   {
    "name" : "__unittestL358_1308",
    "kind" : "function",
    "line" : 358,
    "endline" : 375
   }
  ]
 },
 {
  "name" : "std.parallelism",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/parallelism.d",
  "comment" : "\n$(D std._parallelism) implements high-level primitives for SMP _parallelism.\nThese include parallel foreach, parallel reduce, parallel eager map, pipelining\nand future/promise _parallelism.  $(D std._parallelism) is recommended when the\nsame operation is to be executed in parallel on different data, or when a\nfunction is to be executed in a background thread and its result returned to a\nwell-defined main thread.  For communication between arbitrary threads, see\n$(D std.concurrency).\n\n$(D std._parallelism) is based on the concept of a $(D Task).  A $(D Task) is an\nobject that represents the fundamental unit of work in this library and may be\nexecuted in parallel with any other $(D Task).  Using $(D Task)\ndirectly allows programming with a future/promise paradigm.  All other\nsupported _parallelism paradigms (parallel foreach, map, reduce, pipelining)\nrepresent an additional level of abstraction over $(D Task).  They\nautomatically create one or more $(D Task) objects, or closely related types\nthat are conceptually identical but not part of the public API.\n\nAfter creation, a $(D Task) may be executed in a new thread, or submitted\nto a $(D TaskPool) for execution.  A $(D TaskPool) encapsulates a task queue\nand its worker threads.  Its purpose is to efficiently map a large\nnumber of $(D Task)s onto a smaller number of threads.  A task queue is a\nFIFO queue of $(D Task) objects that have been submitted to the\n$(D TaskPool) and are awaiting execution.  A worker thread is a thread that\nis associated with exactly one task queue.  It executes the $(D Task) at the\nfront of its queue when the queue has work available, or sleeps when\nno work is available.  Each task queue is associated with zero or\nmore worker threads.  If the result of a $(D Task) is needed before execution\nby a worker thread has begun, the $(D Task) can be removed from the task queue\nand executed immediately in the thread where the result is needed.\n\nWarning:  Unless marked as $(D @trusted) or $(D @safe), artifacts in\n          this module allow implicit data sharing between threads and cannot\n          guarantee that client code is free from low level data races.\n\nSynopsis:\n\n---\nimport std.algorithm, std.parallelism, std.range;\n\nvoid main() {\n    // Parallel reduce can be combined with\n    // std.algorithm.map to interesting effect.\n    // The following example (thanks to Russel Winder)\n    // calculates pi by quadrature  using\n    // std.algorithm.map and TaskPool.reduce.\n    // getTerm is evaluated in parallel as needed by\n    // TaskPool.reduce.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // TaskPool.reduce:       12.170 s\n    // std.algorithm.reduce:  24.065 s\n\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0 / n;\n\n    real getTerm(int i)\n    {\n        immutable x = ( i - 0.5 ) * delta;\n        return delta / ( 1.0 + x * x ) ;\n    }\n\n    immutable pi = 4.0 * taskPool.reduce!\"a + b\"(\n        std.algorithm.map!getTerm(iota(n))\n    );\n}\n---\n\nSource:    $(PHOBOSSRC std/_parallelism.d)\nAuthor:  David Simcha\nCopyright:  Copyright (c) 2009-2011, David Simcha.\nLicense:    $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n",
  "members" : [
   {
    "name" : "core.atomic",
    "kind" : "import",
    "line" : 77,
    "protection" : "private"
   },
   {
    "name" : "core.cpuid",
    "kind" : "import",
    "line" : 78,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 79,
    "protection" : "private"
   },
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 80,
    "protection" : "private"
   },
   {
    "name" : "core.sync.condition",
    "kind" : "import",
    "line" : 81,
    "protection" : "private"
   },
   {
    "name" : "core.thread",
    "kind" : "import",
    "line" : 82,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 84,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 85,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 86,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 87,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 88,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 89,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 90,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 91,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 92,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 143,
    "protection" : "private"
   },
   {
    "name" : "_sharedStaticCtor17",
    "kind" : "function",
    "line" : 145,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 148
   },
   {
    "name" : "atomicSetUbyte",
    "kind" : "function",
    "protection" : "private",
    "line" : 189,
    "deco" : "FKhhZv",
    "parameters" : [
     {
      "name" : "stuff",
      "deco" : "h",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "newVal",
      "deco" : "h"
     }
    ],
    "endline" : 193
   },
   {
    "name" : "atomicReadUbyte",
    "kind" : "function",
    "protection" : "private",
    "line" : 195,
    "deco" : "FKhZh",
    "parameters" : [
     {
      "name" : "val",
      "deco" : "h",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 198
   },
   {
    "name" : "atomicCasUbyte",
    "kind" : "function",
    "protection" : "private",
    "line" : 202,
    "deco" : "FKhhhZb",
    "parameters" : [
     {
      "name" : "stuff",
      "deco" : "h",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "testVal",
      "deco" : "h"
     },
     {
      "name" : "newVal",
      "deco" : "h"
     }
    ],
    "endline" : 205
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 208,
    "name" : "MapType",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "functions",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 221,
    "name" : "ReduceType",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ReduceType",
      "kind" : "alias",
      "line" : 223,
      "type" : "typeof(binaryFun!(fun)(E.init, ElementType!(R).init))"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 226,
    "name" : "noUnsharedAliasing",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "noUnsharedAliasing",
      "kind" : "variable",
      "line" : 228,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "!hasUnsharedAliasing!(T)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 234,
    "name" : "isSafeTask",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSafeTask",
      "kind" : "variable",
      "line" : 236,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "(functionAttributes!(F) & (FunctionAttribute.safe | FunctionAttribute.trusted)) != 0 && (functionAttributes!(F) & FunctionAttribute.ref_) == 0 && (isFunctionPointer!(F) || !hasUnsharedAliasing!(F)) && allSatisfy!(noUnsharedAliasing, ParameterTypeTuple!(F))"
     }
    ]
   },
   {
    "name" : "__unittestL243_1309",
    "kind" : "function",
    "line" : 243,
    "endline" : 267
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 267,
    "name" : "isSafeReturn",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 283,
    "name" : "randAssignable",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randAssignable",
      "kind" : "variable",
      "line" : 285,
      "storageClass" : [
       "enum"
      ],
      "init" : "isRandomAccessRange!(R) && hasAssignableElements!(R)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 289,
    "name" : "addressOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "addressOf",
      "kind" : "function",
      "line" : 289,
      "type" : "pure nothrow T*(ref T val)",
      "parameters" : [
       {
        "name" : "val",
        "type" : "T",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 292
     }
    ]
   },
   {
    "name" : "TaskStatus",
    "kind" : "enum",
    "line" : 294,
    "baseDeco" : "h",
    "members" : [
     {
      "name" : "notStarted",
      "kind" : "enum member",
      "line" : 296
     },
     {
      "name" : "inProgress",
      "kind" : "enum member",
      "line" : 297
     },
     {
      "name" : "done",
      "kind" : "enum member",
      "line" : 298
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 301,
    "name" : "AliasReturn",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "AliasReturn",
      "kind" : "alias",
      "line" : 303,
      "type" : "typeof(()\n{\nT args;\nreturn fun(args);\n}\n)"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 308,
    "name" : "reduceAdjoin",
    "parameters" : [
     {
      "name" : "functions",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 330,
    "name" : "reduceFinish",
    "parameters" : [
     {
      "name" : "functions",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 352,
    "name" : "isAssignable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isAssignable",
      "kind" : "variable",
      "line" : 358,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(typeof(()\n{\nT a;\nT b;\na = b;\n}\n))"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 361,
    "name" : "isRoundRobin",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type",
      "type" : "RoundRobinBuffer!(C1, C2)"
     },
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isRoundRobin",
      "kind" : "variable",
      "line" : 363,
      "storageClass" : [
       "enum"
      ],
      "init" : "true"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 366,
    "name" : "isRoundRobin",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isRoundRobin",
      "kind" : "variable",
      "line" : 368,
      "storageClass" : [
       "enum"
      ],
      "init" : "false"
     }
    ]
   },
   {
    "name" : "__unittestL371_1312",
    "kind" : "function",
    "line" : 371,
    "endline" : 379
   },
   {
    "name" : "AbstractTask",
    "kind" : "struct",
    "protection" : "private",
    "line" : 380,
    "members" : [
     {
      "name" : "prev",
      "kind" : "variable",
      "line" : 381,
      "deco" : "PS3std11parallelism12AbstractTask",
      "offset" : 0
     },
     {
      "name" : "next",
      "kind" : "variable",
      "line" : 382,
      "deco" : "PS3std11parallelism12AbstractTask",
      "offset" : 8
     },
     {
      "name" : "runTask",
      "kind" : "variable",
      "line" : 385,
      "deco" : "PFPvZv",
      "offset" : 16
     },
     {
      "name" : "exception",
      "kind" : "variable",
      "line" : 387,
      "deco" : "C6object9Throwable",
      "originalType" : "Throwable",
      "offset" : 24
     },
     {
      "name" : "taskStatus",
      "kind" : "variable",
      "line" : 388,
      "deco" : "h",
      "init" : "cast(ubyte)0u",
      "offset" : 32
     },
     {
      "name" : "done",
      "kind" : "function",
      "line" : 390,
      "deco" : "FNdZb",
      "endline" : 403
     },
     {
      "name" : "job",
      "kind" : "function",
      "line" : 405,
      "deco" : "FZv",
      "endline" : 408
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std11parallelism12AbstractTaskKxS3std11parallelism12AbstractTaskZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std11parallelism12AbstractTask",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std11parallelism12AbstractTask",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n$(D Task) represents the fundamental unit of work.  A $(D Task) may be\nexecuted in parallel with any other $(D Task).  Using this struct directly\nallows future/promise _parallelism.  In this paradigm, a function (or delegate\nor other callable) is executed in a thread other than the one it was called\nfrom.  The calling thread does not block while the function is being executed.\nA call to $(D workForce), $(D yieldForce), or $(D spinForce) is used to\nensure that the $(D Task) has finished executing and to obtain the return\nvalue, if any.  These functions and $(D done) also act as full memory barriers,\nmeaning that any memory writes made in the thread that executed the $(D Task)\nare guaranteed to be visible in the calling thread after one of these functions\nreturns.\n\nThe $(XREF parallelism, task) and $(XREF parallelism, scopedTask) functions can\nbe used to create an instance of this struct.  See $(D task) for usage examples.\n\nFunction results are returned from $(D yieldForce), $(D spinForce) and\n$(D workForce) by ref.  If $(D fun) returns by ref, the reference will point\nto the returned reference of $(D fun).  Otherwise it will point to a\nfield in this struct.\n\nCopying of this struct is disabled, since it would provide no useful semantics.\nIf you want to pass this struct around, you should do so by reference or\npointer.\n\nBugs:  Changes to $(D ref) and $(D out) arguments are not propagated to the\n       call site, only to $(D args) in this struct.\n",
    "line" : 440,
    "name" : "Task",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Task",
      "kind" : "struct",
      "line" : 440,
      "members" : [
       {
        "name" : "base",
        "kind" : "variable",
        "line" : 441,
        "type" : "AbstractTask",
        "init" : "{runTask:&impl}"
       },
       {
        "name" : "basePtr",
        "kind" : "function",
        "line" : 444,
        "type" : "AbstractTask*()",
        "endline" : 447
       },
       {
        "name" : "impl",
        "kind" : "function",
        "line" : 449,
        "type" : "void(void* myTask)",
        "parameters" : [
         {
          "name" : "myTask",
          "type" : "void*"
         }
        ],
        "endline" : 464
       },
       {
        "name" : "pool",
        "kind" : "variable",
        "line" : 466,
        "type" : "TaskPool"
       },
       {
        "name" : "isScoped",
        "kind" : "variable",
        "line" : 467,
        "deco" : "b"
       },
       {
        "name" : "_args",
        "kind" : "variable",
        "line" : 469,
        "type" : "Args"
       },
       {
        "name" : "ReturnType",
        "kind" : "alias",
        "comment" : "\n    The return type of the function called by this $(D Task).  This can be\n    $(D void).\n    \n",
        "line" : 517,
        "type" : "typeof(fun(_args))"
       },
       {
        "name" : "enforcePool",
        "kind" : "function",
        "line" : 543,
        "type" : "void()",
        "endline" : 546
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 548,
        "type" : "(Args args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "Args"
         }
        ],
        "endline" : 554
       },
       {
        "name" : "spinForce",
        "kind" : "function",
        "comment" : "\n    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    busy spin until it's done, then return the return value.  If it threw\n    an exception, rethrow that exception.\n\n    This function should be used when you expect the result of the\n    $(D Task) to be available on a timescale shorter than that of an OS\n    context switch.\n     \n",
        "line" : 586,
        "type" : "@trusted ReturnType()",
        "endline" : 603
       },
       {
        "name" : "yieldForce",
        "kind" : "function",
        "comment" : "\n    If the $(D Task) isn't started yet, execute it in the current thread.\n    If it's done, return its return value, if any.  If it's in progress,\n    wait on a condition variable.  If it threw an exception, rethrow that\n    exception.\n\n    This function should be used for expensive functions, as waiting on a\n    condition variable introduces latency, but avoids wasted CPU cycles.\n     \n",
        "line" : 614,
        "type" : "@trusted ReturnType()",
        "endline" : 648
       },
       {
        "name" : "workForce",
        "kind" : "function",
        "comment" : "\n    If this $(D Task) was not started yet, execute it in the current\n    thread.  If it is finished, return its result.  If it is in progress,\n    execute any other $(D Task) from the $(D TaskPool) instance that\n    this $(D Task) was submitted to until this one\n    is finished.  If it threw an exception, rethrow that exception.\n    If no other tasks are available or this $(D Task) was executed using\n    $(D executeInNewThread), wait on a condition variable.\n     \n",
        "line" : 659,
        "type" : "@trusted ReturnType()",
        "endline" : 722
       },
       {
        "name" : "done",
        "kind" : "function",
        "comment" : "\n    Returns $(D true) if the $(D Task) is finished executing.\n\n    Throws:  Rethrows any exception thrown during the execution of the\n             $(D Task).\n    \n",
        "line" : 730,
        "type" : "@trusted bool()",
        "endline" : 734
       },
       {
        "name" : "executeInNewThread",
        "kind" : "function",
        "comment" : "\n    Create a new thread for executing this $(D Task), execute it in the\n    newly created thread, then terminate the thread.  This can be used for\n    future/promise parallelism.  An explicit priority may be given\n    to the $(D Task).  If one is provided, its value is forwarded to\n    $(D core.thread.Thread.priority). See $(XREF parallelism, task) for\n    usage example.\n    \n",
        "line" : 744,
        "type" : "@trusted void()",
        "endline" : 747
       },
       {
        "name" : "executeInNewThread",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 750,
        "type" : "@trusted void(int priority)",
        "parameters" : [
         {
          "name" : "priority",
          "deco" : "i"
         }
        ],
        "endline" : 753
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "line" : 755,
        "endline" : 761
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 771,
    "name" : "run",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "run",
      "kind" : "function",
      "line" : 771,
      "type" : "ReturnType!(F)(F fpOrDelegate, ref Args args)",
      "parameters" : [
       {
        "name" : "fpOrDelegate",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "Args",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 774
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nCreates a $(D Task) on the GC heap that calls an alias.  This may be executed\nvia $(D Task.executeInNewThread) or by submitting to a\n$(XREF parallelism, TaskPool).  A globally accessible instance of\n$(D TaskPool) is provided by $(XREF parallelism, taskPool).\n\nReturns:  A pointer to the $(D Task).\n\nExamples:\n---\n// Read two files into memory at the same time.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task!read(\"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\n---\n// Sorts an array using a parallel quick sort algorithm.\n// The first partition is done serially.  Both recursion\n// branches are then executed in parallel.\n//\n// Timings for sorting an array of 1,000,000 doubles on\n// an Athlon 64 X2 dual core machine:\n//\n// This implementation:               176 milliseconds.\n// Equivalent serial implementation:  280 milliseconds\nvoid parallelSort(T)(T[] data)\n{\n    // Sort small subarrays serially.\n    if(data.length < 100)\n    {\n         std.algorithm.sort(data);\n         return;\n    }\n\n    // Partition the array.\n    swap(data[$ / 2], data[$ - 1]);\n    auto pivot = data[$ - 1];\n    bool lessThanPivot(T elem) { return elem < pivot; }\n\n    auto greaterEqual = partition!lessThanPivot(data[0..$ - 1]);\n    swap(data[$ - greaterEqual.length - 1], data[$ - 1]);\n\n    auto less = data[0..$ - greaterEqual.length - 1];\n    greaterEqual = data[$ - greaterEqual.length..$];\n\n    // Execute both recursion branches in parallel.\n    auto recurseTask = task!parallelSort(greaterEqual);\n    taskPool.put(recurseTask);\n    parallelSort(less);\n    recurseTask.yieldForce;\n}\n---\n",
    "line" : 842,
    "name" : "task",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "task",
      "kind" : "function",
      "comment" : "\nCreates a $(D Task) on the GC heap that calls an alias.  This may be executed\nvia $(D Task.executeInNewThread) or by submitting to a\n$(XREF parallelism, TaskPool).  A globally accessible instance of\n$(D TaskPool) is provided by $(XREF parallelism, taskPool).\n\nReturns:  A pointer to the $(D Task).\n\nExamples:\n---\n// Read two files into memory at the same time.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task!read(\"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\n---\n// Sorts an array using a parallel quick sort algorithm.\n// The first partition is done serially.  Both recursion\n// branches are then executed in parallel.\n//\n// Timings for sorting an array of 1,000,000 doubles on\n// an Athlon 64 X2 dual core machine:\n//\n// This implementation:               176 milliseconds.\n// Equivalent serial implementation:  280 milliseconds\nvoid parallelSort(T)(T[] data)\n{\n    // Sort small subarrays serially.\n    if(data.length < 100)\n    {\n         std.algorithm.sort(data);\n         return;\n    }\n\n    // Partition the array.\n    swap(data[$ / 2], data[$ - 1]);\n    auto pivot = data[$ - 1];\n    bool lessThanPivot(T elem) { return elem < pivot; }\n\n    auto greaterEqual = partition!lessThanPivot(data[0..$ - 1]);\n    swap(data[$ - greaterEqual.length - 1], data[$ - 1]);\n\n    auto less = data[0..$ - greaterEqual.length - 1];\n    greaterEqual = data[$ - greaterEqual.length..$];\n\n    // Execute both recursion branches in parallel.\n    auto recurseTask = task!parallelSort(greaterEqual);\n    taskPool.put(recurseTask);\n    parallelSort(less);\n    recurseTask.yieldForce;\n}\n---\n",
      "line" : 842,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Args args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 845
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nCreates a $(D Task) on the GC heap that calls a function pointer, delegate, or\nclass/struct with overloaded opCall.\n\nExamples:\n---\n// Read two files in at the same time again,\n// but this time use a function pointer instead\n// of an alias to represent std.file.read.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task(&read, \"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\nNotes: This function takes a non-scope delegate, meaning it can be\n       used with closures.  If you can't allocate a closure due to objects\n       on the stack that have scoped destruction, see $(D scopedTask), which\n       takes a scope delegate.\n \n",
    "line" : 878,
    "name" : "task",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "task",
      "kind" : "function",
      "comment" : "\nCreates a $(D Task) on the GC heap that calls a function pointer, delegate, or\nclass/struct with overloaded opCall.\n\nExamples:\n---\n// Read two files in at the same time again,\n// but this time use a function pointer instead\n// of an alias to represent std.file.read.\nimport std.file;\n\nvoid main()\n{\n    // Create and execute a Task for reading\n    // foo.txt.\n    auto file1Task = task(&read, \"foo.txt\");\n    file1Task.executeInNewThread();\n\n    // Read bar.txt in parallel.\n    auto file2Data = read(\"bar.txt\");\n\n    // Get the results of reading foo.txt.\n    auto file1Data = file1Task.yieldForce;\n}\n---\n\nNotes: This function takes a non-scope delegate, meaning it can be\n       used with closures.  If you can't allocate a closure due to objects\n       on the stack that have scoped destruction, see $(D scopedTask), which\n       takes a scope delegate.\n \n",
      "line" : 878,
      "storageClass" : [
       "auto"
      ],
      "type" : "(F delegateOrFp, Args args)",
      "parameters" : [
       {
        "name" : "delegateOrFp",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 882
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nVersion of $(D task) usable from $(D @safe) code.  Usage mechanics are\nidentical to the non-@safe case, but safety introduces some restrictions:\n\n1.  $(D fun) must be @safe or @trusted.\n\n2.  $(D F) must not have any unshared aliasing as defined by\n    $(XREF traits, hasUnsharedAliasing).  This means it\n    may not be an unshared delegate or a non-shared class or struct\n    with overloaded $(D opCall).  This also precludes accepting template\n    alias parameters.\n\n3.  $(D Args) must not have unshared aliasing.\n\n4.  $(D fun) must not return by reference.\n\n5.  The return type must not have unshared aliasing unless $(D fun) is\n    $(D pure) or the $(D Task) is executed via $(D executeInNewThread) instead\n    of using a $(D TaskPool).\n\n",
    "line" : 905,
    "name" : "task",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "task",
      "kind" : "function",
      "comment" : "\nVersion of $(D task) usable from $(D @safe) code.  Usage mechanics are\nidentical to the non-@safe case, but safety introduces some restrictions:\n\n1.  $(D fun) must be @safe or @trusted.\n\n2.  $(D F) must not have any unshared aliasing as defined by\n    $(XREF traits, hasUnsharedAliasing).  This means it\n    may not be an unshared delegate or a non-shared class or struct\n    with overloaded $(D opCall).  This also precludes accepting template\n    alias parameters.\n\n3.  $(D Args) must not have unshared aliasing.\n\n4.  $(D fun) must not return by reference.\n\n5.  The return type must not have unshared aliasing unless $(D fun) is\n    $(D pure) or the $(D Task) is executed via $(D executeInNewThread) instead\n    of using a $(D TaskPool).\n\n",
      "line" : 905,
      "storageClass" : [
       "auto"
      ],
      "type" : "@trusted (F fun, Args args)",
      "parameters" : [
       {
        "name" : "fun",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 909
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nThese functions allow the creation of $(D Task) objects on the stack rather\nthan the GC heap.  The lifetime of a $(D Task) created by $(D scopedTask)\ncannot exceed the lifetime of the scope it was created in.\n\n$(D scopedTask) might be preferred over $(D task):\n\n1.  When a $(D Task) that calls a delegate is being created and a closure\n    cannot be allocated due to objects on the stack that have scoped\n    destruction.  The delegate overload of $(D scopedTask) takes a $(D scope)\n    delegate.\n\n2.  As a micro-optimization, to avoid the heap allocation associated with\n    $(D task) or with the creation of a closure.\n\nUsage is otherwise identical to $(D task).\n\nNotes:  $(D Task) objects created using $(D scopedTask) will automatically\ncall $(D Task.yieldForce) in their destructor if necessary to ensure\nthe $(D Task) is complete before the stack frame they reside on is destroyed.\n",
    "line" : 932,
    "name" : "scopedTask",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "scopedTask",
      "kind" : "function",
      "comment" : "\nThese functions allow the creation of $(D Task) objects on the stack rather\nthan the GC heap.  The lifetime of a $(D Task) created by $(D scopedTask)\ncannot exceed the lifetime of the scope it was created in.\n\n$(D scopedTask) might be preferred over $(D task):\n\n1.  When a $(D Task) that calls a delegate is being created and a closure\n    cannot be allocated due to objects on the stack that have scoped\n    destruction.  The delegate overload of $(D scopedTask) takes a $(D scope)\n    delegate.\n\n2.  As a micro-optimization, to avoid the heap allocation associated with\n    $(D task) or with the creation of a closure.\n\nUsage is otherwise identical to $(D task).\n\nNotes:  $(D Task) objects created using $(D scopedTask) will automatically\ncall $(D Task.yieldForce) in their destructor if necessary to ensure\nthe $(D Task) is complete before the stack frame they reside on is destroyed.\n",
      "line" : 932,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Args args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 937
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 940,
    "name" : "scopedTask",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "scopedTask",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 940,
      "storageClass" : [
       "auto"
      ],
      "type" : "(scope F delegateOrFp, Args args)",
      "parameters" : [
       {
        "name" : "delegateOrFp",
        "type" : "F",
        "storageClass" : [
         "scope"
        ]
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 946
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 949,
    "name" : "scopedTask",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "scopedTask",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 949,
      "storageClass" : [
       "auto"
      ],
      "type" : "@trusted (F fun, Args args)",
      "parameters" : [
       {
        "name" : "fun",
        "type" : "F"
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 955
     }
    ]
   },
   {
    "name" : "totalCPUs",
    "kind" : "variable",
    "comment" : "\nThe total number of CPU cores available on the current machine, as reported by\nthe operating system.\n",
    "line" : 961,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yk",
    "originalType" : "uint"
   },
   {
    "name" : "ParallelismThread",
    "kind" : "class",
    "protection" : "private",
    "line" : 973,
    "base" : "Thread",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 975,
      "deco" : "FDFZvZC3std11parallelism17ParallelismThread",
      "originalType" : "(void delegate() dg)",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFZv"
       }
      ],
      "endline" : 978
     },
     {
      "name" : "pool",
      "kind" : "variable",
      "line" : 980,
      "deco" : "C3std11parallelism8TaskPool",
      "originalType" : "TaskPool",
      "offset" : 168
     }
    ]
   },
   {
    "name" : "_sharedStaticDtor19",
    "kind" : "function",
    "line" : 984,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 997
   },
   {
    "name" : "TaskPool",
    "kind" : "class",
    "comment" : "\nThis class encapsulates a task queue and a set of worker threads.  Its purpose\nis to efficiently map a large number of $(D Task)s onto a smaller number of\nthreads.  A task queue is a FIFO queue of $(D Task) objects that have been\nsubmitted to the $(D TaskPool) and are awaiting execution.  A worker thread is a\nthread that executes the $(D Task) at the front of the queue when one is\navailable and sleeps when the queue is empty.\n\nThis class should usually be used via the global instantiation\navailable via the $(XREF parallelism, taskPool) property.\nOccasionally it is useful to explicitly instantiate a $(D TaskPool):\n\n1.  When you want $(D TaskPool) instances with multiple priorities, for example\n    a low priority pool and a high priority pool.\n\n2.  When the threads in the global task pool are waiting on a synchronization\n    primitive (for example a mutex), and you want to parallelize the code that\n    needs to run before these threads can be resumed.\n \n",
    "line" : 1019,
    "members" : [
     {
      "name" : "isSingleTask",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1025,
      "deco" : "b",
      "offset" : 16
     },
     {
      "name" : "pool",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1027,
      "deco" : "AC3std11parallelism17ParallelismThread",
      "offset" : 24
     },
     {
      "name" : "singleTaskThread",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1028,
      "deco" : "C4core6thread6Thread",
      "originalType" : "Thread",
      "offset" : 40
     },
     {
      "name" : "head",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1030,
      "deco" : "PS3std11parallelism12AbstractTask",
      "offset" : 48
     },
     {
      "name" : "tail",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1031,
      "deco" : "PS3std11parallelism12AbstractTask",
      "offset" : 56
     },
     {
      "name" : "status",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1032,
      "deco" : "E3std11parallelism8TaskPool9PoolState",
      "init" : "cast(PoolState)cast(ubyte)0u",
      "offset" : 64
     },
     {
      "name" : "workerCondition",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1033,
      "deco" : "C4core4sync9condition9Condition",
      "originalType" : "Condition",
      "offset" : 72
     },
     {
      "name" : "waiterCondition",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1034,
      "deco" : "C4core4sync9condition9Condition",
      "originalType" : "Condition",
      "offset" : 80
     },
     {
      "name" : "queueMutex",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1035,
      "deco" : "C4core4sync5mutex5Mutex",
      "originalType" : "Mutex",
      "offset" : 88
     },
     {
      "name" : "waiterMutex",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1036,
      "deco" : "C4core4sync5mutex5Mutex",
      "originalType" : "Mutex",
      "offset" : 96
     },
     {
      "name" : "nextInstanceIndex",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1039,
      "storageClass" : [
       "static"
      ],
      "deco" : "m",
      "originalType" : "size_t",
      "init" : "1LU"
     },
     {
      "name" : "threadIndex",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1042,
      "storageClass" : [
       "static"
      ],
      "deco" : "m",
      "originalType" : "size_t"
     },
     {
      "name" : "instanceStartIndex",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1045,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "ym",
      "originalType" : "size_t",
      "offset" : 104
     },
     {
      "name" : "nextThreadIndex",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1048,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 112
     },
     {
      "name" : "PoolState",
      "kind" : "enum",
      "line" : 1050,
      "baseDeco" : "h",
      "members" : [
       {
        "name" : "running",
        "kind" : "enum member",
        "line" : 1052
       },
       {
        "name" : "finishing",
        "kind" : "enum member",
        "line" : 1053
       },
       {
        "name" : "stopNow",
        "kind" : "enum member",
        "line" : 1054
       }
      ]
     },
     {
      "name" : "doJob",
      "kind" : "function",
      "protection" : "private",
      "line" : 1057,
      "deco" : "FPS3std11parallelism12AbstractTaskZv",
      "parameters" : [
       {
        "name" : "job",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1083
     },
     {
      "name" : "doSingleTask",
      "kind" : "function",
      "protection" : "private",
      "line" : 1086,
      "deco" : "FZv",
      "endline" : 1094
     },
     {
      "name" : "startWorkLoop",
      "kind" : "function",
      "protection" : "private",
      "line" : 1099,
      "deco" : "FZv",
      "endline" : 1110
     },
     {
      "name" : "executeWorkLoop",
      "kind" : "function",
      "protection" : "private",
      "line" : 1115,
      "deco" : "FZv",
      "endline" : 1133
     },
     {
      "name" : "pop",
      "kind" : "function",
      "protection" : "private",
      "line" : 1136,
      "deco" : "FZPS3std11parallelism12AbstractTask",
      "endline" : 1147
     },
     {
      "name" : "popNoSync",
      "kind" : "function",
      "protection" : "private",
      "line" : 1149,
      "deco" : "FZPS3std11parallelism12AbstractTask",
      "endline" : 1180
     },
     {
      "name" : "abstractPut",
      "kind" : "function",
      "protection" : "private",
      "line" : 1183,
      "deco" : "FPS3std11parallelism12AbstractTaskZv",
      "parameters" : [
       {
        "name" : "task",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1188
     },
     {
      "name" : "abstractPutNoSync",
      "kind" : "function",
      "protection" : "private",
      "line" : 1190,
      "deco" : "FPS3std11parallelism12AbstractTaskZv",
      "parameters" : [
       {
        "name" : "task",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1230
     },
     {
      "name" : "abstractPutGroupNoSync",
      "kind" : "function",
      "protection" : "private",
      "line" : 1232,
      "deco" : "FPS3std11parallelism12AbstractTaskPS3std11parallelism12AbstractTaskZv",
      "parameters" : [
       {
        "name" : "h",
        "deco" : "PS3std11parallelism12AbstractTask"
       },
       {
        "name" : "t",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1255
     },
     {
      "name" : "tryDeleteExecute",
      "kind" : "function",
      "protection" : "private",
      "line" : 1257,
      "deco" : "FPS3std11parallelism12AbstractTaskZv",
      "parameters" : [
       {
        "name" : "toExecute",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1276
     },
     {
      "name" : "deleteItem",
      "kind" : "function",
      "protection" : "private",
      "line" : 1278,
      "deco" : "FPS3std11parallelism12AbstractTaskZb",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1283
     },
     {
      "name" : "deleteItemNoSync",
      "kind" : "function",
      "protection" : "private",
      "line" : 1285,
      "deco" : "FPS3std11parallelism12AbstractTaskZb",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "PS3std11parallelism12AbstractTask"
       }
      ],
      "endline" : 1323
     },
     {
      "name" : "queueLock",
      "kind" : "function",
      "protection" : "private",
      "line" : 1325,
      "deco" : "FZv",
      "endline" : 1329
     },
     {
      "name" : "queueUnlock",
      "kind" : "function",
      "protection" : "private",
      "line" : 1331,
      "deco" : "FZv",
      "endline" : 1335
     },
     {
      "name" : "waiterLock",
      "kind" : "function",
      "protection" : "private",
      "line" : 1337,
      "deco" : "FZv",
      "endline" : 1340
     },
     {
      "name" : "waiterUnlock",
      "kind" : "function",
      "protection" : "private",
      "line" : 1342,
      "deco" : "FZv",
      "endline" : 1345
     },
     {
      "name" : "wait",
      "kind" : "function",
      "protection" : "private",
      "line" : 1347,
      "deco" : "FZv",
      "endline" : 1350
     },
     {
      "name" : "notify",
      "kind" : "function",
      "protection" : "private",
      "line" : 1352,
      "deco" : "FZv",
      "endline" : 1355
     },
     {
      "name" : "notifyAll",
      "kind" : "function",
      "protection" : "private",
      "line" : 1357,
      "deco" : "FZv",
      "endline" : 1360
     },
     {
      "name" : "waitUntilCompletion",
      "kind" : "function",
      "protection" : "private",
      "line" : 1362,
      "deco" : "FZv",
      "endline" : 1372
     },
     {
      "name" : "notifyWaiters",
      "kind" : "function",
      "protection" : "private",
      "line" : 1374,
      "deco" : "FZv",
      "endline" : 1377
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 1382,
      "deco" : "FPS3std11parallelism12AbstractTaskiZC3std11parallelism8TaskPool",
      "originalType" : "(AbstractTask* task, int priority = (int).max)",
      "parameters" : [
       {
        "name" : "task",
        "deco" : "PS3std11parallelism12AbstractTask"
       },
       {
        "name" : "priority",
        "deco" : "i",
        "default" : "2147483647"
       }
      ],
      "endline" : 1399
     },
     {
      "name" : "defaultWorkUnitSize",
      "kind" : "function",
      "line" : 1404,
      "deco" : "xFNaNbNfmZm",
      "originalType" : "const pure nothrow @safe size_t(size_t rangeLen)",
      "parameters" : [
       {
        "name" : "rangeLen",
        "deco" : "m"
       }
      ],
      "endline" : 1414
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n    Default constructor that initializes a $(D TaskPool) with\n    $(D totalCPUs) - 1 worker threads.  The minus 1 is included because the\n    main thread will also be available to do work.\n\n    Note:  On single-core machines, the primitives provided by $(D TaskPool)\n           operate transparently in single-threaded mode.\n     \n",
      "line" : 1424,
      "deco" : "FNeZC3std11parallelism8TaskPool",
      "originalType" : "@trusted ()",
      "endline" : 1427
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n    Allows for custom number of worker threads.\n    \n",
      "line" : 1432,
      "deco" : "FNemZC3std11parallelism8TaskPool",
      "originalType" : "@trusted (size_t nWorkers)",
      "parameters" : [
       {
        "name" : "nWorkers",
        "deco" : "m"
       }
      ],
      "endline" : 1457
     },
     {
      "kind" : "template",
      "comment" : "\n    Implements a parallel foreach loop over a range.  This works by implicitly\n    creating and submitting one $(D Task) to the $(D TaskPool) for each worker\n    thread.  A work unit is a set of consecutive elements of $(D range) to\n    be processed by a worker thread between communication with any other\n    thread.  The number of elements processed per work unit is controlled by the\n    $(D workUnitSize) parameter.  Smaller work units provide better load\n    balancing, but larger work units avoid the overhead of communicating\n    with other threads frequently to fetch the next work unit.  Large work\n    units also avoid false sharing in cases where the range is being modified.\n    The less time a single iteration of the loop takes, the larger\n    $(D workUnitSize) should be.  For very expensive loop bodies,\n    $(D workUnitSize) should  be 1.  An overload that chooses a default work\n    unit size is also available.\n\n    Examples:\n    ---\n    // Find the logarithm of every number from 1 to\n    // 10_000_000 in parallel.\n    auto logs = new double[10_000_000];\n\n    // Parallel foreach works with or without an index\n    // variable.  It can be iterate by ref if range.front\n    // returns by ref.\n\n    // Iterate over logs using work units of size 100.\n    foreach(i, ref elem; taskPool.parallel(logs, 100))\n    {\n        elem = log(i + 1.0);\n    }\n\n    // Same thing, but use the default work unit size.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // Parallel foreach:  388 milliseconds\n    // Regular foreach:   619 milliseconds\n    foreach(i, ref elem; taskPool.parallel(logs))\n    {\n        elem = log(i + 1.0);\n    }\n    ---\n\n    Notes:\n\n    The memory usage of this implementation is guaranteed to be constant\n    in $(D range.length).\n\n    Breaking from a parallel foreach loop via a break, labeled break,\n    labeled continue, return or goto statement throws a\n    $(D ParallelForeachError).\n\n    In the case of non-random access ranges, parallel foreach buffers lazily\n    to an array of size $(D workUnitSize) before executing the parallel portion\n    of the loop.  The exception is that, if a parallel foreach is executed\n    over a range returned by $(D asyncBuf) or $(D map), the copying is elided\n    and the buffers are simply swapped.  In this case $(D workUnitSize) is\n    ignored and the work unit size is set to the  buffer size of $(D range).\n\n    A memory barrier is guaranteed to be executed on exit from the loop,\n    so that results produced by all threads are visible in the calling thread.\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside a parallel foreach loop,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown by any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n    \n",
      "line" : 1530,
      "name" : "parallel",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "parallel",
        "kind" : "function",
        "comment" : "\n    Implements a parallel foreach loop over a range.  This works by implicitly\n    creating and submitting one $(D Task) to the $(D TaskPool) for each worker\n    thread.  A work unit is a set of consecutive elements of $(D range) to\n    be processed by a worker thread between communication with any other\n    thread.  The number of elements processed per work unit is controlled by the\n    $(D workUnitSize) parameter.  Smaller work units provide better load\n    balancing, but larger work units avoid the overhead of communicating\n    with other threads frequently to fetch the next work unit.  Large work\n    units also avoid false sharing in cases where the range is being modified.\n    The less time a single iteration of the loop takes, the larger\n    $(D workUnitSize) should be.  For very expensive loop bodies,\n    $(D workUnitSize) should  be 1.  An overload that chooses a default work\n    unit size is also available.\n\n    Examples:\n    ---\n    // Find the logarithm of every number from 1 to\n    // 10_000_000 in parallel.\n    auto logs = new double[10_000_000];\n\n    // Parallel foreach works with or without an index\n    // variable.  It can be iterate by ref if range.front\n    // returns by ref.\n\n    // Iterate over logs using work units of size 100.\n    foreach(i, ref elem; taskPool.parallel(logs, 100))\n    {\n        elem = log(i + 1.0);\n    }\n\n    // Same thing, but use the default work unit size.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // Parallel foreach:  388 milliseconds\n    // Regular foreach:   619 milliseconds\n    foreach(i, ref elem; taskPool.parallel(logs))\n    {\n        elem = log(i + 1.0);\n    }\n    ---\n\n    Notes:\n\n    The memory usage of this implementation is guaranteed to be constant\n    in $(D range.length).\n\n    Breaking from a parallel foreach loop via a break, labeled break,\n    labeled continue, return or goto statement throws a\n    $(D ParallelForeachError).\n\n    In the case of non-random access ranges, parallel foreach buffers lazily\n    to an array of size $(D workUnitSize) before executing the parallel portion\n    of the loop.  The exception is that, if a parallel foreach is executed\n    over a range returned by $(D asyncBuf) or $(D map), the copying is elided\n    and the buffers are simply swapped.  In this case $(D workUnitSize) is\n    ignored and the work unit size is set to the  buffer size of $(D range).\n\n    A memory barrier is guaranteed to be executed on exit from the loop,\n    so that results produced by all threads are visible in the calling thread.\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside a parallel foreach loop,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown by any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n    \n",
        "line" : 1530,
        "type" : "ParallelForeach!(R)(R range, size_t workUnitSize)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         },
         {
          "name" : "workUnitSize",
          "type" : "size_t"
         }
        ],
        "endline" : 1535
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : " Ditto\n",
      "line" : 1539,
      "name" : "parallel",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "parallel",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 1539,
        "type" : "ParallelForeach!(R)(R range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         }
        ],
        "endline" : 1554
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    Eager parallel map.  The eagerness of this function means it has less\n    overhead than the lazily evaluated $(D TaskPool.map) and should be\n    preferred where the memory requirements of eagerness are acceptable.\n    $(D functions) are the functions to be evaluated, passed as template alias\n    parameters in a style similar to $(XREF algorithm, map).  The first\n    argument must be a random access range.\n\n    ---\n    auto numbers = iota(100_000_000.0);\n\n    // Find the square roots of numbers.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // Parallel eager map:                   0.802 s\n    // Equivalent serial implementation:     1.768 s\n    auto squareRoots = taskPool.amap!sqrt(numbers);\n    ---\n\n    Immediately after the range argument, an optional work unit size argument\n    may be provided.  Work units as used by $(D amap) are identical to those\n    defined for parallel foreach.  If no work unit size is provided, the\n    default work unit size is used.\n\n    ---\n    // Same thing, but make work unit size 100.\n    auto squareRoots = taskPool.amap!sqrt(numbers, 100);\n    ---\n\n    An output range for returning the results may be provided as the last\n    argument.  If one is not provided, an array of the proper type will be\n    allocated on the garbage collected heap.  If one is provided, it must be a\n    random access range with assignable elements, must have reference\n    semantics with respect to assignment to its elements, and must have the\n    same length as the input range.  Writing to adjacent elements from\n    different threads must be safe.\n\n    ---\n    // Same thing, but explicitly allocate an array\n    // to return the results in.  The element type\n    // of the array may be either the exact type\n    // returned by functions or an implicit conversion\n    // target.\n    auto squareRoots = new float[numbers.length];\n    taskPool.amap!sqrt(numbers, squareRoots);\n\n    // Multiple functions, explicit output range, and\n    // explicit work unit size.\n    auto results = new Tuple!(float, real)[numbers.length];\n    taskPool.amap!(sqrt, log)(numbers, 100, results);\n    ---\n\n    Note:\n\n    A memory barrier is guaranteed to be executed after all results are written\n    but before returning so that results produced by all threads are visible\n    in the calling thread.\n\n    Tips:\n\n    To perform the mapping operation in place, provide the same range for the\n    input and output range.\n\n    To parallelize the copying of a range with expensive to evaluate elements\n    to an array, pass an identity function (a function that just returns\n    whatever argument is provided to it) to $(D amap).\n\n    $(B Exception Handling):\n\n    When at least one exception is thrown from inside the map functions,\n    the submission of additional $(D Task) objects is terminated as soon as\n    possible, in a non-deterministic manner.  All currently executing or\n    enqueued work units are allowed to complete.  Then, all exceptions that\n    were thrown from any work unit are chained using $(D Throwable.next) and\n    rethrown.  The order of the exception chaining is non-deterministic.\n     \n",
      "line" : 1633,
      "name" : "amap",
      "parameters" : [
       {
        "name" : "functions",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "kind" : "template",
        "comment" : "\n",
        "line" : 1636,
        "name" : "amap",
        "parameters" : [
         {
          "name" : "Args",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "amap",
          "kind" : "function",
          "comment" : "\n",
          "line" : 1636,
          "storageClass" : [
           "auto"
          ],
          "type" : "(Args args)",
          "parameters" : [
           {
            "name" : "args",
            "type" : "Args"
           }
          ],
          "endline" : 1739
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    A semi-lazy parallel map that can be used for pipelining.  The map\n    functions are evaluated for the first $(D bufSize) elements and stored in a\n    buffer and made available to $(D popFront).  Meanwhile, in the\n    background a second buffer of the same size is filled.  When the first\n    buffer is exhausted, it is swapped with the second buffer and filled while\n    the values from what was originally the second buffer are read.  This\n    implementation allows for elements to be written to the buffer without\n    the need for atomic operations or synchronization for each write, and\n    enables the mapping function to be evaluated efficiently in parallel.\n\n    $(D map) has more overhead than the simpler procedure used by $(D amap)\n    but avoids the need to keep all results in memory simultaneously and works\n    with non-random access ranges.\n\n    Params:\n\n    source = The input range to be mapped.  If $(D source) is not random\n    access it will be lazily buffered to an array of size $(D bufSize) before\n    the map function is evaluated.  (For an exception to this rule, see Notes.)\n\n    bufSize = The size of the buffer to store the evaluated elements.\n\n    workUnitSize = The number of elements to evaluate in a single\n    $(D Task).  Must be less than or equal to $(D bufSize), and\n    should be a fraction of $(D bufSize) such that all worker threads can be\n    used.  If the default of size_t.max is used, workUnitSize will be set to\n    the pool-wide default.\n\n    Returns:  An input range representing the results of the map.  This range\n              has a length iff $(D source) has a length.\n\n    Notes:\n\n    If a range returned by $(D map) or $(D asyncBuf) is used as an input to\n    $(D map), then as an optimization the copying from the output buffer\n    of the first range to the input buffer of the second range is elided, even\n    though the ranges returned by $(D map) and $(D asyncBuf) are non-random\n    access ranges.  This means that the $(D bufSize) parameter passed to the\n    current call to $(D map) will be ignored and the size of the buffer\n    will be the buffer size of $(D source).\n\n    Examples:\n    ---\n    // Pipeline reading a file, converting each line\n    // to a number, taking the logarithms of the numbers,\n    // and performing the additions necessary to find\n    // the sum of the logarithms.\n\n    auto lineRange = File(\"numberList.txt\").byLine();\n    auto dupedLines = std.algorithm.map!\"a.idup\"(lineRange);\n    auto nums = taskPool.map!(to!double)(dupedLines);\n    auto logs = taskPool.map!log10(nums);\n\n    double sum = 0;\n    foreach(elem; logs)\n    {\n        sum += elem;\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source)\n    or computing the map function are re-thrown on a call to $(D popFront) or,\n    if thrown during construction, are simply allowed to propagate to the\n    caller.  In the case of exceptions thrown while computing the map function,\n    the exceptions are chained as in $(D TaskPool.amap).\n    \n",
      "line" : 1811,
      "name" : "map",
      "parameters" : [
       {
        "name" : "functions",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "kind" : "template",
        "comment" : "\n",
        "line" : 1815,
        "name" : "map",
        "parameters" : [
         {
          "name" : "S",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "map",
          "kind" : "function",
          "comment" : "\n",
          "line" : 1815,
          "storageClass" : [
           "auto"
          ],
          "type" : "(S source, size_t bufSize = 100, size_t workUnitSize = size_t.max)",
          "parameters" : [
           {
            "name" : "source",
            "type" : "S"
           },
           {
            "name" : "bufSize",
            "type" : "size_t",
            "default" : "100"
           },
           {
            "name" : "workUnitSize",
            "type" : "size_t",
            "default" : "size_t.max"
           }
          ],
          "endline" : 2083
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    Given a $(D source) range that is expensive to iterate over, returns an\n    input range that asynchronously buffers the contents of\n    $(D source) into a buffer of $(D bufSize) elements in a worker thread,\n    while making prevously buffered elements from a second buffer, also of size\n    $(D bufSize), available via the range interface of the returned\n    object.  The returned range has a length iff $(D hasLength!S).\n    $(D asyncBuf) is useful, for example, when performing expensive operations\n    on the elements of ranges that represent data on a disk or network.\n\n    Examples:\n    ---\n    import std.conv, std.stdio;\n\n    void main()\n    {\n        // Fetch lines of a file in a background thread\n        // while processing prevously fetched lines,\n        // dealing with byLine's buffer recycling by\n        // eagerly duplicating every line.\n        auto lines = File(\"foo.txt\").byLine();\n        auto duped = std.algorithm.map!\"a.idup\"(lines);\n\n        // Fetch more lines in the background while we\n        // process the lines already read into memory\n        // into a matrix of doubles.\n        double[][] matrix;\n        auto asyncReader = taskPool.asyncBuf(duped);\n\n        foreach(line; asyncReader)\n        {\n            auto ls = line.split(\"\\t\");\n            matrix ~= to!(double[])(ls);\n        }\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source) are re-thrown on a\n    call to $(D popFront) or, if thrown during construction, simply\n    allowed to propagate to the caller.\n    \n",
      "line" : 2129,
      "name" : "asyncBuf",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "asyncBuf",
        "kind" : "function",
        "comment" : "\n    Given a $(D source) range that is expensive to iterate over, returns an\n    input range that asynchronously buffers the contents of\n    $(D source) into a buffer of $(D bufSize) elements in a worker thread,\n    while making prevously buffered elements from a second buffer, also of size\n    $(D bufSize), available via the range interface of the returned\n    object.  The returned range has a length iff $(D hasLength!S).\n    $(D asyncBuf) is useful, for example, when performing expensive operations\n    on the elements of ranges that represent data on a disk or network.\n\n    Examples:\n    ---\n    import std.conv, std.stdio;\n\n    void main()\n    {\n        // Fetch lines of a file in a background thread\n        // while processing prevously fetched lines,\n        // dealing with byLine's buffer recycling by\n        // eagerly duplicating every line.\n        auto lines = File(\"foo.txt\").byLine();\n        auto duped = std.algorithm.map!\"a.idup\"(lines);\n\n        // Fetch more lines in the background while we\n        // process the lines already read into memory\n        // into a matrix of doubles.\n        double[][] matrix;\n        auto asyncReader = taskPool.asyncBuf(duped);\n\n        foreach(line; asyncReader)\n        {\n            auto ls = line.split(\"\\t\");\n            matrix ~= to!(double[])(ls);\n        }\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D source) are re-thrown on a\n    call to $(D popFront) or, if thrown during construction, simply\n    allowed to propagate to the caller.\n    \n",
        "line" : 2129,
        "storageClass" : [
         "auto"
        ],
        "type" : "(S source, size_t bufSize = 100)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "S"
         },
         {
          "name" : "bufSize",
          "type" : "size_t",
          "default" : "100"
         }
        ],
        "endline" : 2264
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    Given a callable object $(D next) that writes to a user-provided buffer and\n    a second callable object $(D empty) that determines whether more data is\n    available to write via $(D next), returns an input range that\n    asynchronously calls $(D next) with a set of size $(D nBuffers) of buffers\n    and makes the results available in the order they were obtained via the\n    input range interface of the returned object.  Similarly to the\n    input range overload of $(D asyncBuf), the first half of the buffers\n    are made available via the range interface while the second half are\n    filled and vice-versa.\n\n    Params:\n\n    next = A callable object that takes a single argument that must be an array\n           with mutable elements.  When called, $(D next) writes data to\n           the array provided by the caller.\n\n    empty = A callable object that takes no arguments and returns a type\n            implicitly convertible to $(D bool).  This is used to signify\n            that no more data is available to be obtained by calling $(D next).\n\n    initialBufSize = The initial size of each buffer.  If $(D next) takes its\n                     array by reference, it may resize the buffers.\n\n    nBuffers = The number of buffers to cycle through when calling $(D next).\n\n    Examples:\n    ---\n    // Fetch lines of a file in a background\n    // thread while processing prevously fetched\n    // lines, without duplicating any lines.\n    auto file = File(\"foo.txt\");\n\n    void next(ref char[] buf)\n    {\n        file.readln(buf);\n    }\n\n    // Fetch more lines in the background while we\n    // process the lines already read into memory\n    // into a matrix of doubles.\n    double[][] matrix;\n    auto asyncReader = taskPool.asyncBuf(&next, &file.eof);\n\n    foreach(line; asyncReader)\n    {\n        auto ls = line.split(\"\\t\");\n        matrix ~= to!(double[])(ls);\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D range) are re-thrown on a\n    call to $(D popFront).\n\n    Warning:\n\n    Using the range returned by this function in a parallel foreach loop\n    will not work because buffers may be overwritten while the task that\n    processes them is in queue.  This is checked for at compile time\n    and will result in a static assertion failure.\n    \n",
      "line" : 2329,
      "name" : "asyncBuf",
      "parameters" : [
       {
        "name" : "C1",
        "kind" : "type"
       },
       {
        "name" : "C2",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "asyncBuf",
        "kind" : "function",
        "comment" : "\n    Given a callable object $(D next) that writes to a user-provided buffer and\n    a second callable object $(D empty) that determines whether more data is\n    available to write via $(D next), returns an input range that\n    asynchronously calls $(D next) with a set of size $(D nBuffers) of buffers\n    and makes the results available in the order they were obtained via the\n    input range interface of the returned object.  Similarly to the\n    input range overload of $(D asyncBuf), the first half of the buffers\n    are made available via the range interface while the second half are\n    filled and vice-versa.\n\n    Params:\n\n    next = A callable object that takes a single argument that must be an array\n           with mutable elements.  When called, $(D next) writes data to\n           the array provided by the caller.\n\n    empty = A callable object that takes no arguments and returns a type\n            implicitly convertible to $(D bool).  This is used to signify\n            that no more data is available to be obtained by calling $(D next).\n\n    initialBufSize = The initial size of each buffer.  If $(D next) takes its\n                     array by reference, it may resize the buffers.\n\n    nBuffers = The number of buffers to cycle through when calling $(D next).\n\n    Examples:\n    ---\n    // Fetch lines of a file in a background\n    // thread while processing prevously fetched\n    // lines, without duplicating any lines.\n    auto file = File(\"foo.txt\");\n\n    void next(ref char[] buf)\n    {\n        file.readln(buf);\n    }\n\n    // Fetch more lines in the background while we\n    // process the lines already read into memory\n    // into a matrix of doubles.\n    double[][] matrix;\n    auto asyncReader = taskPool.asyncBuf(&next, &file.eof);\n\n    foreach(line; asyncReader)\n    {\n        auto ls = line.split(\"\\t\");\n        matrix ~= to!(double[])(ls);\n    }\n    ---\n\n    $(B Exception Handling):\n\n    Any exceptions thrown while iterating over $(D range) are re-thrown on a\n    call to $(D popFront).\n\n    Warning:\n\n    Using the range returned by this function in a parallel foreach loop\n    will not work because buffers may be overwritten while the task that\n    processes them is in queue.  This is checked for at compile time\n    and will result in a static assertion failure.\n    \n",
        "line" : 2329,
        "storageClass" : [
         "auto"
        ],
        "type" : "(C1 next, C2 empty, size_t initialBufSize = 0, size_t nBuffers = 100)",
        "parameters" : [
         {
          "name" : "next",
          "type" : "C1"
         },
         {
          "name" : "empty",
          "type" : "C2"
         },
         {
          "name" : "initialBufSize",
          "type" : "size_t",
          "default" : "0"
         },
         {
          "name" : "nBuffers",
          "type" : "size_t",
          "default" : "100"
         }
        ],
        "endline" : 2337
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    Parallel reduce on a random access range.  Except as otherwise noted, usage\n    is similar to $(XREF algorithm, _reduce).  This function works by splitting\n    the range to be reduced into work units, which are slices to be reduced in\n    parallel.  Once the results from all work units are computed, a final serial\n    reduction is performed on these results to compute the final answer.\n    Therefore, care must be taken to choose the seed value appropriately.\n\n    Because the reduction is being performed in parallel,\n    $(D functions) must be associative.  For notational simplicity, let # be an\n    infix operator representing $(D functions).  Then, (a # b) # c must equal\n    a # (b # c).  Floating point addition is not associative\n    even though addition in exact arithmetic is.  Summing floating\n    point numbers using this function may give different results than summing\n    serially.  However, for many practical purposes floating point addition\n    can be treated as associative.\n\n    Note that, since $(D functions) are assumed to be associative, additional\n    optimizations are made to the serial portion of the reduction algorithm.\n    These take advantage of the instruction level parallelism of modern CPUs,\n    in addition to the thread-level parallelism that the rest of this\n    module exploits.  This can lead to better than linear speedups relative\n    to $(XREF algorithm, _reduce), especially for fine-grained benchmarks\n    like dot products.\n\n    An explicit seed may be provided as the first argument.  If\n    provided, it is used as the seed for all work units and for the final\n    reduction of results from all work units.  Therefore, if it is not the\n    identity value for the operation being performed, results may differ from\n    those generated by $(XREF algorithm, _reduce) or depending on how many work\n    units are used.  The next argument must be the range to be reduced.\n    ---\n    // Find the sum of squares of a range in parallel, using\n    // an explicit seed.\n    //\n    // Timings on an Athlon 64 X2 dual core machine:\n    //\n    // Parallel reduce:                     72 milliseconds\n    // Using std.algorithm.reduce instead:  181 milliseconds\n    auto nums = iota(10_000_000.0f);\n    auto sumSquares = taskPool.reduce!\"a + b\"(\n        0.0, std.algorithm.map!\"a * a\"(nums)\n    );\n    ---\n\n    If no explicit seed is provided, the first element of each work unit\n    is used as a seed.  For the final reduction, the result from the first\n    work unit is used as the seed.\n    ---\n    // Find the sum of a range in parallel, using the first\n    // element of each work unit as the seed.\n    auto sum = taskPool.reduce!\"a + b\"(nums);\n    ---\n\n    An explicit work unit size may be specified as the last argument.\n    Specifying too small a work unit size will effectively serialize the\n    reduction, as the final reduction of the result of each work unit will\n    dominate computation time.  If $(D TaskPool.size) for this instance\n    is zero, this parameter is ignored and one work unit is used.\n    ---\n    // Use a work unit size of 100.\n    auto sum2 = taskPool.reduce!\"a + b\"(nums, 100);\n\n    // Work unit size of 100 and explicit seed.\n    auto sum3 = taskPool.reduce!\"a + b\"(0.0, nums, 100);\n    ---\n\n    Parallel reduce supports multiple functions, like\n    $(D std.algorithm.reduce).\n    ---\n    // Find both the min and max of nums.\n    auto minMax = taskPool.reduce!(min, max)(nums);\n    assert(minMax[0] == reduce!min(nums));\n    assert(minMax[1] == reduce!max(nums));\n    ---\n\n    $(B Exception Handling):\n\n    After this function is finished executing, any exceptions thrown\n    are chained together via $(D Throwable.next) and rethrown.  The chaining\n    order is non-deterministic.\n     \n",
      "line" : 2421,
      "name" : "reduce",
      "parameters" : [
       {
        "name" : "functions",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "kind" : "template",
        "comment" : "\n",
        "line" : 2425,
        "name" : "reduce",
        "parameters" : [
         {
          "name" : "Args",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "reduce",
          "kind" : "function",
          "comment" : "\n",
          "line" : 2425,
          "storageClass" : [
           "auto"
          ],
          "type" : "(Args args)",
          "parameters" : [
           {
            "name" : "args",
            "type" : "Args"
           }
          ],
          "endline" : 2716
         }
        ]
       }
      ]
     },
     {
      "name" : "workerIndex",
      "kind" : "function",
      "comment" : "\n    Gets the index of the current thread relative to this $(D TaskPool).  Any\n    thread not in this pool will receive an index of 0.  The worker threads in\n    this pool receive unique indices of 1 through $(D this.size).\n\n    This function is useful for maintaining worker-local resources.\n\n    Examples:\n    ---\n    // Execute a loop that computes the greatest common\n    // divisor of every number from 0 through 999 with\n    // 42 in parallel.  Write the results out to\n    // a set of files, one for each thread.  This allows\n    // results to be written out without any synchronization.\n\n    import std.conv, std.range, std.numeric, std.stdio;\n\n    void main()\n    {\n        auto filesHandles = new File[taskPool.size + 1];\n        scope(exit) {\n            foreach(ref handle; fileHandles) {\n                handle.close();\n            }\n        }\n\n        foreach(i, ref handle; fileHandles)\n        {\n            handle = File(\"workerResults\" ~ to!string(i) ~ \".txt\");\n        }\n\n        foreach(num; parallel(iota(1_000)))\n        {\n            auto outHandle = fileHandles[taskPool.workerIndex];\n            outHandle.writeln(num, '\\t', gcd(num, 42));\n        }\n    }\n    ---\n    \n",
      "line" : 2758,
      "deco" : "xFNbNdNfZm",
      "originalType" : "const nothrow @property @safe size_t()",
      "endline" : 2763
     },
     {
      "kind" : "template",
      "comment" : "\n    Struct for creating worker-local storage.  Worker-local storage is\n    thread-local storage that exists only for worker threads in a given\n    $(D TaskPool) plus a single thread outside the pool.  It is allocated on the\n    garbage collected heap in a way that avoids _false sharing, and doesn't\n    necessarily have global scope within any thread.  It can be accessed from\n    any worker thread in the $(D TaskPool) that created it, and one thread\n    outside this $(D TaskPool).  All threads outside the pool that created a\n    given instance of worker-local storage share a single slot.\n\n    Since the underlying data for this struct is heap-allocated, this struct\n    has reference semantics when passed between functions.\n\n    The main uses cases for $(D WorkerLocalStorageStorage) are:\n\n    1.  Performing parallel reductions with an imperative, as opposed to\n    functional, programming style.  In this case, it's useful to treat\n    $(D WorkerLocalStorageStorage) as local to each thread for only the parallel\n    portion of an algorithm.\n\n    2.  Recycling temporary buffers across iterations of a parallel foreach loop.\n\n    Examples:\n    ---\n    // Calculate pi as in our synopsis example, but\n    // use an imperative instead of a functional style.\n    immutable n = 1_000_000_000;\n    immutable delta = 1.0L / n;\n\n    auto sums = taskPool.workerLocalStorage(0.0L);\n    foreach(i; parallel(iota(n)))\n    {\n        immutable x = ( i - 0.5L ) * delta;\n        immutable toAdd = delta / ( 1.0 + x * x );\n        sums.get += toAdd;\n    }\n\n    // Add up the results from each worker thread.\n    real pi = 0;\n    foreach(threadResult; sums.toRange)\n    {\n        pi += 4.0L * threadResult;\n    }\n    ---\n     \n",
      "line" : 2811,
      "name" : "WorkerLocalStorage",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "WorkerLocalStorage",
        "kind" : "struct",
        "line" : 2811,
        "members" : [
         {
          "name" : "pool",
          "kind" : "variable",
          "line" : 2813,
          "type" : "TaskPool"
         },
         {
          "name" : "size",
          "kind" : "variable",
          "line" : 2814,
          "type" : "size_t"
         },
         {
          "name" : "cacheLineSize",
          "kind" : "variable",
          "line" : 2816,
          "type" : "size_t"
         },
         {
          "name" : "elemSize",
          "kind" : "variable",
          "line" : 2817,
          "type" : "size_t"
         },
         {
          "name" : "stillThreadLocal",
          "kind" : "variable",
          "line" : 2818,
          "type" : "bool*"
         },
         {
          "name" : "_sharedStaticCtor20",
          "kind" : "function",
          "line" : 2820,
          "storageClass" : [
           "static"
          ],
          "endline" : 2832
         },
         {
          "name" : "roundToLine",
          "kind" : "function",
          "line" : 2834,
          "type" : "pure nothrow size_t(size_t num)",
          "parameters" : [
           {
            "name" : "num",
            "type" : "size_t"
           }
          ],
          "endline" : 2843
         },
         {
          "name" : "data",
          "kind" : "variable",
          "line" : 2845,
          "type" : "void*"
         },
         {
          "name" : "initialize",
          "kind" : "function",
          "line" : 2847,
          "type" : "void(TaskPool pool)",
          "parameters" : [
           {
            "name" : "pool",
            "type" : "TaskPool"
           }
          ],
          "endline" : 2875
         },
         {
          "name" : "opIndex",
          "kind" : "function",
          "line" : 2877,
          "type" : "T(size_t index)",
          "parameters" : [
           {
            "name" : "index",
            "type" : "size_t"
           }
          ],
          "endline" : 2881
         },
         {
          "name" : "opIndexAssign",
          "kind" : "function",
          "line" : 2883,
          "type" : "void(T val, size_t index)",
          "parameters" : [
           {
            "name" : "val",
            "type" : "T"
           },
           {
            "name" : "index",
            "type" : "size_t"
           }
          ],
          "endline" : 2887
         },
         {
          "name" : "get",
          "kind" : "function",
          "comment" : "\n        Get the current thread's instance.  Returns by ref.\n        Note that calling $(D get) from any thread\n        outside the $(D TaskPool) that created this instance will return the\n        same reference, so an instance of worker-local storage should only be\n        accessed from one thread outside the pool that created it.  If this\n        rule is violated, undefined behavior will result.\n\n        If assertions are enabled and $(D toRange) has been called, then this\n        WorkerLocalStorage instance is no longer worker-local and an assertion\n        failure will result when calling this method.  This is not checked\n        when assertions are disabled for performance reasons.\n         \n",
          "line" : 2903,
          "type" : "@property T()",
          "endline" : 2910
         },
         {
          "name" : "get",
          "kind" : "function",
          "comment" : "\n        Assign a value to the current thread's instance.  This function has\n        the same caveats as its overload.\n        \n",
          "line" : 2916,
          "type" : "@property void(T val)",
          "parameters" : [
           {
            "name" : "val",
            "type" : "T"
           }
          ],
          "endline" : 2924
         },
         {
          "name" : "toRange",
          "kind" : "function",
          "comment" : "\n        Returns a range view of the values for all threads, which can be used\n        to further process the results of each thread after running the parallel\n        part of your algorithm.  Do not use this method in the parallel portion\n        of your algorithm.\n\n        Calling this function sets a flag indicating that this struct is no\n        longer worker-local, and attempting to use the $(D get) method again\n        will result in an assertion failure if assertions are enabled.\n         \n",
          "line" : 2936,
          "type" : "@property WorkerLocalStorageRange!(T)()",
          "endline" : 2953
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    Range primitives for worker-local storage.  The purpose of this is to\n    access results produced by each worker thread from a single thread once you\n    are no longer using the worker-local storage from multiple threads.\n    Do not use this struct in the parallel portion of your algorithm.\n\n    The proper way to instantiate this object is to call\n    $(D WorkerLocalStorage.toRange).  Once instantiated, this object behaves\n    as a finite random-access range with assignable, lvalue elemends and\n    a length equal to the number of worker threads in the $(D TaskPool) that\n    created it plus 1.\n     \n",
      "line" : 2969,
      "name" : "WorkerLocalStorageRange",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "WorkerLocalStorageRange",
        "kind" : "struct",
        "line" : 2969,
        "members" : [
         {
          "name" : "workerLocalStorage",
          "kind" : "variable",
          "line" : 2971,
          "type" : "WorkerLocalStorage!(T)"
         },
         {
          "name" : "_length",
          "kind" : "variable",
          "line" : 2973,
          "type" : "size_t"
         },
         {
          "name" : "beginOffset",
          "kind" : "variable",
          "line" : 2974,
          "type" : "size_t"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2976,
          "type" : "(WorkerLocalStorage!(T) wl)",
          "parameters" : [
           {
            "name" : "wl",
            "type" : "WorkerLocalStorage!(T)"
           }
          ],
          "endline" : 2980
         },
         {
          "name" : "front",
          "kind" : "function",
          "line" : 2983,
          "type" : "@property T()",
          "endline" : 2986
         },
         {
          "name" : "back",
          "kind" : "function",
          "line" : 2988,
          "type" : "@property T()",
          "endline" : 2991
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "line" : 2993,
          "type" : "void()",
          "endline" : 3000
         },
         {
          "name" : "popBack",
          "kind" : "function",
          "line" : 3002,
          "type" : "void()",
          "endline" : 3008
         },
         {
          "name" : "save",
          "kind" : "function",
          "line" : 3010,
          "type" : "@property typeof(this)()",
          "endline" : 3013
         },
         {
          "name" : "opIndex",
          "kind" : "function",
          "line" : 3015,
          "type" : "T(size_t index)",
          "parameters" : [
           {
            "name" : "index",
            "type" : "size_t"
           }
          ],
          "endline" : 3019
         },
         {
          "name" : "opIndexAssign",
          "kind" : "function",
          "line" : 3021,
          "type" : "void(T val, size_t index)",
          "parameters" : [
           {
            "name" : "val",
            "type" : "T"
           },
           {
            "name" : "index",
            "type" : "size_t"
           }
          ],
          "endline" : 3025
         },
         {
          "name" : "opSlice",
          "kind" : "function",
          "line" : 3027,
          "type" : "typeof(this)(size_t lower, size_t upper)",
          "parameters" : [
           {
            "name" : "lower",
            "type" : "size_t"
           },
           {
            "name" : "upper",
            "type" : "size_t"
           }
          ],
          "endline" : 3034
         },
         {
          "name" : "empty",
          "kind" : "function",
          "line" : 3036,
          "type" : "@property bool()",
          "endline" : 3039
         },
         {
          "name" : "length",
          "kind" : "function",
          "line" : 3041,
          "type" : "@property size_t()",
          "endline" : 3044
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\n    Creates an instance of worker-local storage, initialized with a given\n    value.  The value is $(D lazy) so that you can, for example, easily\n    create one instance of a class for each worker.  For usage example,\n    see the $(D WorkerLocalStorage) struct.\n     \n",
      "line" : 3053,
      "name" : "workerLocalStorage",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "workerLocalStorage",
        "kind" : "function",
        "comment" : "\n    Creates an instance of worker-local storage, initialized with a given\n    value.  The value is $(D lazy) so that you can, for example, easily\n    create one instance of a class for each worker.  For usage example,\n    see the $(D WorkerLocalStorage) struct.\n     \n",
        "line" : 3053,
        "type" : "WorkerLocalStorage!(T)(lazy T initialVal = T.init)",
        "parameters" : [
         {
          "name" : "initialVal",
          "type" : "T",
          "storageClass" : [
           "lazy"
          ],
          "default" : "T.init"
         }
        ],
        "endline" : 3068
       }
      ]
     },
     {
      "name" : "stop",
      "kind" : "function",
      "comment" : "\n    Signals to all worker threads to terminate as soon as they are finished\n    with their current $(D Task), or immediately if they are not executing a\n    $(D Task).  $(D Task)s that were in queue will not be executed unless\n    a call to $(D Task.workForce), $(D Task.yieldForce) or $(D Task.spinForce)\n    causes them to be executed.\n\n    Use only if you have waitied on every $(D Task) and therefore know the\n    queue is empty, or if you speculatively executed some tasks and no longer\n    need the results.\n     \n",
      "line" : 3081,
      "deco" : "FNeZv",
      "endline" : 3087
     },
     {
      "name" : "finish",
      "kind" : "function",
      "comment" : "\n    Signals worker threads to terminate when the queue becomes empty.\n\n    If blocking argument is true, wait for all worker threads to terminate\n    before returning.  This option might be used in applications where\n    task results are never consumed-- e.g. when $(D TaskPool) is employed as a\n    rudimentary scheduler for tasks which communicate by means other than\n    return values.\n\n    Warning:  Calling this function with $(D blocking = true) from a worker\n              thread that is a member of the same $(D TaskPool) that\n              $(D finish) is being called on will result in a deadlock.\n     \n",
      "line" : 3102,
      "deco" : "FNebZv",
      "parameters" : [
       {
        "name" : "blocking",
        "deco" : "b",
        "default" : "false"
       }
      ],
      "endline" : 3130
     },
     {
      "name" : "size",
      "kind" : "function",
      "comment" : " Returns the number of worker threads in the pool.\n",
      "line" : 3133,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdNfZm",
      "originalType" : "const pure nothrow @safe size_t()",
      "endline" : 3136
     },
     {
      "kind" : "template",
      "comment" : "\n    Put a $(D Task) object on the back of the task queue.  The $(D Task)\n    object may be passed by pointer or reference.\n\n    Example:\n    ---\n    import std.file;\n\n    // Create a task.\n    auto t = task!read(\"foo.txt\");\n\n    // Add it to the queue to be executed.\n    taskPool.put(t);\n    ---\n\n    Notes:\n\n    @trusted overloads of this function are called for $(D Task)s if\n    $(XREF traits, hasUnsharedAliasing) is false for the $(D Task)'s\n    return type or the function the $(D Task) executes is $(D pure).\n    $(D Task) objects that meet all other requirements specified in the\n    $(D @trusted) overloads of $(D task) and $(D scopedTask) may be created\n    and executed from $(D @safe) code via $(D Task.executeInNewThread) but\n    not via $(D TaskPool).\n\n    While this function takes the address of variables that may\n    be on the stack, some overloads are marked as @trusted.\n    $(D Task) includes a destructor that waits for the task to complete\n    before destroying the stack frame it is allocated on.  Therefore,\n    it is impossible for the stack frame to be destroyed before the task is\n    complete and no longer referenced by a $(D TaskPool).\n    \n",
      "line" : 3170,
      "name" : "put",
      "parameters" : [
       {
        "name" : "fun",
        "kind" : "alias"
       },
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "put",
        "kind" : "function",
        "comment" : "\n    Put a $(D Task) object on the back of the task queue.  The $(D Task)\n    object may be passed by pointer or reference.\n\n    Example:\n    ---\n    import std.file;\n\n    // Create a task.\n    auto t = task!read(\"foo.txt\");\n\n    // Add it to the queue to be executed.\n    taskPool.put(t);\n    ---\n\n    Notes:\n\n    @trusted overloads of this function are called for $(D Task)s if\n    $(XREF traits, hasUnsharedAliasing) is false for the $(D Task)'s\n    return type or the function the $(D Task) executes is $(D pure).\n    $(D Task) objects that meet all other requirements specified in the\n    $(D @trusted) overloads of $(D task) and $(D scopedTask) may be created\n    and executed from $(D @safe) code via $(D Task.executeInNewThread) but\n    not via $(D TaskPool).\n\n    While this function takes the address of variables that may\n    be on the stack, some overloads are marked as @trusted.\n    $(D Task) includes a destructor that waits for the task to complete\n    before destroying the stack frame it is allocated on.  Therefore,\n    it is impossible for the stack frame to be destroyed before the task is\n    complete and no longer referenced by a $(D TaskPool).\n    \n",
        "line" : 3170,
        "type" : "void(ref Task!(fun, Args) task)",
        "parameters" : [
         {
          "name" : "task",
          "type" : "Task!(fun, Args)",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 3175
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : " Ditto\n",
      "line" : 3178,
      "name" : "put",
      "parameters" : [
       {
        "name" : "fun",
        "kind" : "alias"
       },
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "put",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 3178,
        "type" : "void(Task!(fun, Args)* task)",
        "parameters" : [
         {
          "name" : "task",
          "type" : "Task!(fun, Args)*"
         }
        ],
        "endline" : 3183
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3185,
      "name" : "put",
      "parameters" : [
       {
        "name" : "fun",
        "kind" : "alias"
       },
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "put",
        "kind" : "function",
        "line" : 3185,
        "type" : "void(ref Task!(fun, Args) task)",
        "parameters" : [
         {
          "name" : "task",
          "type" : "Task!(fun, Args)",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 3190
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3192,
      "name" : "put",
      "parameters" : [
       {
        "name" : "fun",
        "kind" : "alias"
       },
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "put",
        "kind" : "function",
        "line" : 3192,
        "type" : "void(Task!(fun, Args)* task)",
        "parameters" : [
         {
          "name" : "task",
          "type" : "Task!(fun, Args)*"
         }
        ],
        "endline" : 3197
       }
      ]
     },
     {
      "name" : "isDaemon",
      "kind" : "function",
      "comment" : "\n    These properties control whether the worker threads are daemon threads.\n    A daemon thread is automatically terminated when all non-daemon threads\n    have terminated.  A non-daemon thread will prevent a program from\n    terminating as long as it has not terminated.\n\n    If any $(D TaskPool) with non-daemon threads is active, either $(D stop)\n    or $(D finish) must be called on it before the program can terminate.\n\n    The worker treads in the $(D TaskPool) instance returned by the\n    $(D taskPool) property are daemon by default.  The worker threads of\n    manually instantiated task pools are non-daemon by default.\n\n    Note:  For a size zero pool, the getter arbitrarily returns true and the\n           setter has no effect.\n    \n",
      "line" : 3215,
      "deco" : "FNdNeZb",
      "endline" : 3220
     },
     {
      "name" : "isDaemon",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3223,
      "deco" : "FNdNebZv",
      "parameters" : [
       {
        "name" : "newVal",
        "deco" : "b"
       }
      ],
      "endline" : 3231
     },
     {
      "name" : "priority",
      "kind" : "function",
      "comment" : "\n    These functions allow getting and setting the OS scheduling priority of\n    the worker threads in this $(D TaskPool).  They forward to\n    $(D core.thread.Thread.priority), so a given priority value here means the\n    same thing as an identical priority value in $(D core.thread).\n\n    Note:  For a size zero pool, the getter arbitrarily returns\n           $(D core.thread.Thread.PRIORITY_MIN) and the setter has no effect.\n    \n",
      "line" : 3242,
      "deco" : "FNdNeZi",
      "endline" : 3246
     },
     {
      "name" : "priority",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3249,
      "deco" : "FNdNeiZv",
      "parameters" : [
       {
        "name" : "newPriority",
        "deco" : "i"
       }
      ],
      "endline" : 3258
     }
    ]
   },
   {
    "name" : "taskPool",
    "kind" : "function",
    "comment" : "\nReturns a lazily initialized global instantiation of $(D TaskPool).\nThis function can safely be called concurrently from multiple non-worker\nthreads.  The worker threads in this pool are daemon threads, meaning that it\nis not necessary to call $(D TaskPool.stop) or $(D TaskPool.finish) before\nterminating the main thread.\n",
    "line" : 3268,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdNeZC3std11parallelism8TaskPool",
    "originalType" : "@trusted TaskPool()",
    "endline" : 3288
   },
   {
    "name" : "_defaultPoolThreads",
    "kind" : "variable",
    "protection" : "private",
    "line" : 3290,
    "storageClass" : [
     "shared"
    ],
    "deco" : "Ok",
    "originalType" : "uint"
   },
   {
    "name" : "_sharedStaticCtor21",
    "kind" : "function",
    "line" : 3291,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 3294
   },
   {
    "name" : "defaultPoolThreads",
    "kind" : "function",
    "comment" : "\nThese properties get and set the number of worker threads in the $(D TaskPool)\ninstance returned by $(D taskPool).  The default value is $(D totalCPUs) - 1.\nCalling the setter after the first call to $(D taskPool) does not changes\nnumber of worker threads in the instance returned by $(D taskPool).\n",
    "line" : 3302,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdNeZk",
    "originalType" : "@trusted uint()",
    "endline" : 3305
   },
   {
    "name" : "defaultPoolThreads",
    "kind" : "function",
    "comment" : " Ditto\n",
    "line" : 3308,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdNekZv",
    "originalType" : "@trusted void(uint newVal)",
    "parameters" : [
     {
      "name" : "newVal",
      "deco" : "k"
     }
    ],
    "endline" : 3311
   },
   {
    "kind" : "template",
    "comment" : "\nConvenience functions that forwards to $(D taskPool.parallel).  The\npurpose of these is to make parallel foreach less verbose and more\nreadable.\n\nExample:\n---\n// Find the logarithm of every number from\n// 1 to 1_000_000 in parallel, using the\n// default TaskPool instance.\nauto logs = new double[1_000_000];\n\nforeach(i, ref elem; parallel(logs)) {\n    elem = log(i + 1.0);\n}\n---\n\n",
    "line" : 3331,
    "name" : "parallel",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parallel",
      "kind" : "function",
      "comment" : "\nConvenience functions that forwards to $(D taskPool.parallel).  The\npurpose of these is to make parallel foreach less verbose and more\nreadable.\n\nExample:\n---\n// Find the logarithm of every number from\n// 1 to 1_000_000 in parallel, using the\n// default TaskPool instance.\nauto logs = new double[1_000_000];\n\nforeach(i, ref elem; parallel(logs)) {\n    elem = log(i + 1.0);\n}\n---\n\n",
      "line" : 3331,
      "type" : "ParallelForeach!(R)(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 3334
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3337,
    "name" : "parallel",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parallel",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3337,
      "type" : "ParallelForeach!(R)(R range, size_t workUnitSize)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "workUnitSize",
        "type" : "size_t"
       }
      ],
      "endline" : 3340
     }
    ]
   },
   {
    "name" : "ParallelForeachError",
    "kind" : "class",
    "line" : 3343,
    "base" : "Error",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 3345,
      "deco" : "FZC3std11parallelism20ParallelForeachError",
      "originalType" : "()",
      "endline" : 3349
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3353,
    "name" : "randLen",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randLen",
      "kind" : "variable",
      "line" : 3355,
      "storageClass" : [
       "enum"
      ],
      "init" : "isRandomAccessRange!(R) && hasLength!(R)"
     }
    ]
   },
   {
    "name" : "submitAndExecute",
    "kind" : "function",
    "protection" : "private",
    "line" : 3358,
    "deco" : "FC3std11parallelism8TaskPoolMDFZvZv",
    "parameters" : [
     {
      "name" : "pool",
      "deco" : "C3std11parallelism8TaskPool"
     },
     {
      "name" : "doIt",
      "deco" : "DFZv",
      "storageClass" : [
       "scope"
      ]
     }
    ],
    "endline" : 3463
   },
   {
    "name" : "foreachErr",
    "kind" : "function",
    "line" : 3465,
    "deco" : "FZv",
    "endline" : 3468
   },
   {
    "kind" : "template",
    "line" : 3470,
    "name" : "doSizeZeroCase",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Delegate",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "doSizeZeroCase",
      "kind" : "function",
      "line" : 3470,
      "type" : "int(ref ParallelForeach!(R) p, Delegate dg)",
      "parameters" : [
       {
        "name" : "p",
        "type" : "ParallelForeach!(R)",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "dg",
        "type" : "Delegate"
       }
      ],
      "endline" : 3513
     }
    ]
   },
   {
    "name" : "parallelApplyMixinRandomAccess",
    "kind" : "variable",
    "protection" : "private",
    "line" : 3515,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"\\x0a    // Handle empty thread pool as special case.\\x0a    if(pool.size == 0)\\x0a    {\\x0a        return doSizeZeroCase(this, dg);\\x0a    }\\x0a\\x0a    // Whether iteration is with or without an index variable.\\x0a    enum withIndex = ParameterTypeTuple!(typeof(dg)).length == 2;\\x0a\\x0a    shared size_t workUnitIndex = size_t.max;  // Effectively -1:  chunkIndex + 1 == 0\\x0a    immutable len = range.length;\\x0a    if(!len) return 0;\\x0a\\x0a    shared bool shouldContinue = true;\\x0a\\x0a    void doIt()\\x0a    {\\x0a        scope(failure)\\x0a        {\\x0a            // If an exception is thrown, all threads should bail.\\x0a            atomicStore(shouldContinue, false);\\x0a        }\\x0a\\x0a        while(atomicLoad(shouldContinue))\\x0a        {\\x0a            immutable myUnitIndex = atomicOp!\\\"+=\\\"(workUnitIndex, 1);\\x0a            immutable start = workUnitSize * myUnitIndex;\\x0a            if(start >= len)\\x0a            {\\x0a                atomicStore(shouldContinue, false);\\x0a                break;\\x0a            }\\x0a\\x0a            immutable end = min(len, start + workUnitSize);\\x0a\\x0a            foreach(i; start..end)\\x0a            {\\x0a                static if(withIndex)\\x0a                {\\x0a                    if(dg(i, range[i])) foreachErr();\\x0a                }\\x0a                else\\x0a                {\\x0a                    if(dg(range[i])) foreachErr();\\x0a                }\\x0a            }\\x0a        }\\x0a    }\\x0a\\x0a    submitAndExecute(pool, &doIt);\\x0a\\x0a    return 0;\\x0a\""
   },
   {
    "name" : "parallelApplyMixinInputRange",
    "kind" : "variable",
    "line" : 3570,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"\\x0a    // Handle empty thread pool as special case.\\x0a    if(pool.size == 0)\\x0a    {\\x0a        return doSizeZeroCase(this, dg);\\x0a    }\\x0a\\x0a    // Whether iteration is with or without an index variable.\\x0a    enum withIndex = ParameterTypeTuple!(typeof(dg)).length == 2;\\x0a\\x0a    // This protects the range while copying it.\\x0a    auto rangeMutex = new Mutex();\\x0a\\x0a    shared bool shouldContinue = true;\\x0a\\x0a    // The total number of elements that have been popped off range.\\x0a    // This is updated only while protected by rangeMutex;\\x0a    size_t nPopped = 0;\\x0a\\x0a    static if(\\x0a        is(typeof(range.buf1)) &&\\x0a        is(typeof(range.bufPos)) &&\\x0a        is(typeof(range.doBufSwap()))\\x0a    )\\x0a    {\\x0a        // Make sure we don't have the buffer recycling overload of\\x0a        // asyncBuf.\\x0a        static if(\\x0a            is(typeof(range.source)) &&\\x0a            isRoundRobin!(typeof(range.source))\\x0a        )\\x0a        {\\x0a            static assert(0, \\\"Cannot execute a parallel foreach loop on \\\" ~\\x0a            \\\"the buffer recycling overload of asyncBuf.\\\");\\x0a        }\\x0a\\x0a        enum bool bufferTrick = true;\\x0a    }\\x0a    else\\x0a    {\\x0a        enum bool bufferTrick = false;\\x0a    }\\x0a\\x0a    void doIt()\\x0a    {\\x0a        scope(failure)\\x0a        {\\x0a            // If an exception is thrown, all threads should bail.\\x0a            atomicStore(shouldContinue, false);\\x0a        }\\x0a\\x0a        static if(hasLvalueElements!R)\\x0a        {\\x0a            alias ElementType!R*[] Temp;\\x0a            Temp temp;\\x0a\\x0a            // Returns:  The previous value of nPopped.\\x0a            size_t makeTemp()\\x0a            {\\x0a                if(temp is null)\\x0a                {\\x0a                    temp = uninitializedArray!Temp(workUnitSize);\\x0a                }\\x0a\\x0a                rangeMutex.lock();\\x0a                scope(exit) rangeMutex.unlock();\\x0a\\x0a                size_t i = 0;\\x0a                for(; i < workUnitSize && !range.empty; range.popFront(), i++)\\x0a                {\\x0a                    temp[i] = addressOf(range.front);\\x0a                }\\x0a\\x0a                temp = temp[0..i];\\x0a                auto ret = nPopped;\\x0a                nPopped += temp.length;\\x0a                return ret;\\x0a            }\\x0a\\x0a        }\\x0a        else\\x0a        {\\x0a\\x0a            alias ElementType!R[] Temp;\\x0a            Temp temp;\\x0a\\x0a            // Returns:  The previous value of nPopped.\\x0a            static if(!bufferTrick) size_t makeTemp()\\x0a            {\\x0a                if(temp is null)\\x0a                {\\x0a                    temp = uninitializedArray!Temp(workUnitSize);\\x0a                }\\x0a\\x0a                rangeMutex.lock();\\x0a                scope(exit) rangeMutex.unlock();\\x0a\\x0a                size_t i = 0;\\x0a                for(; i < workUnitSize && !range.empty; range.popFront(), i++)\\x0a                {\\x0a                    temp[i] = range.front;\\x0a                }\\x0a\\x0a                temp = temp[0..i];\\x0a                auto ret = nPopped;\\x0a                nPopped += temp.length;\\x0a                return ret;\\x0a            }\\x0a\\x0a            static if(bufferTrick) size_t makeTemp()\\x0a            {\\x0a                rangeMutex.lock();\\x0a                scope(exit) rangeMutex.unlock();\\x0a\\x0a                // Elide copying by just swapping buffers.\\x0a                temp.length = range.buf1.length;\\x0a                swap(range.buf1, temp);\\x0a\\x0a                // This is necessary in case popFront() has been called on\\x0a                // range before entering the parallel foreach loop.\\x0a                temp = temp[range.bufPos..$];\\x0a\\x0a                static if(is(typeof(range._length)))\\x0a                {\\x0a                    range._length -= (temp.length - range.bufPos);\\x0a                }\\x0a\\x0a                range.doBufSwap();\\x0a                auto ret = nPopped;\\x0a                nPopped += temp.length;\\x0a                return ret;\\x0a            }\\x0a        }\\x0a\\x0a        while(atomicLoad(shouldContinue))\\x0a        {\\x0a            auto overallIndex = makeTemp();\\x0a            if(temp.empty)\\x0a            {\\x0a                atomicStore(shouldContinue, false);\\x0a                break;\\x0a            }\\x0a\\x0a            foreach(i; 0..temp.length)\\x0a            {\\x0a                scope(success) overallIndex++;\\x0a\\x0a                static if(hasLvalueElements!R)\\x0a                {\\x0a                    static if(withIndex)\\x0a                    {\\x0a                        if(dg(overallIndex, *temp[i])) foreachErr();\\x0a                    }\\x0a                    else\\x0a                    {\\x0a                        if(dg(*temp[i])) foreachErr();\\x0a                    }\\x0a                }\\x0a                else\\x0a                {\\x0a                    static if(withIndex)\\x0a                    {\\x0a                        if(dg(overallIndex, temp[i])) foreachErr();\\x0a                    }\\x0a                    else\\x0a                    {\\x0a                        if(dg(temp[i])) foreachErr();\\x0a                    }\\x0a                }\\x0a            }\\x0a        }\\x0a    }\\x0a\\x0a    submitAndExecute(pool, &doIt);\\x0a\\x0a    return 0;\\x0a\""
   },
   {
    "name" : "findLastException",
    "kind" : "function",
    "protection" : "private",
    "line" : 3749,
    "deco" : "FNaNbC6object9ThrowableZC6object9Throwable",
    "parameters" : [
     {
      "name" : "e",
      "deco" : "C6object9Throwable"
     }
    ],
    "endline" : 3759
   },
   {
    "name" : "addToChain",
    "kind" : "function",
    "protection" : "private",
    "line" : 3762,
    "deco" : "FNaNbC6object9ThrowableKC6object9ThrowableKC6object9ThrowableZv",
    "parameters" : [
     {
      "name" : "e",
      "deco" : "C6object9Throwable"
     },
     {
      "name" : "firstException",
      "deco" : "C6object9Throwable",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "lastException",
      "deco" : "C6object9Throwable",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 3779
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3782,
    "name" : "ParallelForeach",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ParallelForeach",
      "kind" : "struct",
      "line" : 3782,
      "members" : [
       {
        "name" : "pool",
        "kind" : "variable",
        "line" : 3783,
        "type" : "TaskPool"
       },
       {
        "name" : "range",
        "kind" : "variable",
        "line" : 3784,
        "type" : "R"
       },
       {
        "name" : "workUnitSize",
        "kind" : "variable",
        "line" : 3785,
        "type" : "size_t"
       },
       {
        "name" : "E",
        "kind" : "alias",
        "line" : 3786,
        "type" : "ElementType!(R)"
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 3799,
        "type" : "int(scope NoIndexDg dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "NoIndexDg",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 3809
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 3811,
        "type" : "int(scope IndexDg dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "IndexDg",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 3821
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3832,
    "name" : "RoundRobinBuffer",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RoundRobinBuffer",
      "kind" : "struct",
      "line" : 3832,
      "members" : [
       {
        "name" : "Array",
        "kind" : "alias",
        "line" : 3835,
        "type" : "ParameterTypeTuple!(C1.init)[0]"
       },
       {
        "name" : "T",
        "kind" : "alias",
        "line" : 3836,
        "type" : "typeof(Array.init[0])"
       },
       {
        "name" : "bufs",
        "kind" : "variable",
        "line" : 3838,
        "type" : "T[][]"
       },
       {
        "name" : "index",
        "kind" : "variable",
        "line" : 3839,
        "type" : "size_t"
       },
       {
        "name" : "nextDel",
        "kind" : "variable",
        "line" : 3840,
        "type" : "C1"
       },
       {
        "name" : "emptyDel",
        "kind" : "variable",
        "line" : 3841,
        "type" : "C2"
       },
       {
        "name" : "_empty",
        "kind" : "variable",
        "line" : 3842,
        "deco" : "b"
       },
       {
        "name" : "primed",
        "kind" : "variable",
        "line" : 3843,
        "deco" : "b"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3845,
        "type" : "(C1 nextDel, C2 emptyDel, size_t initialBufSize, size_t nBuffers)",
        "parameters" : [
         {
          "name" : "nextDel",
          "type" : "C1"
         },
         {
          "name" : "emptyDel",
          "type" : "C2"
         },
         {
          "name" : "initialBufSize",
          "type" : "size_t"
         },
         {
          "name" : "nBuffers",
          "type" : "size_t"
         }
        ],
        "endline" : 3859
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 3861,
        "type" : "void()",
        "endline" : 3870
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 3873,
        "type" : "@property T[]()",
        "endline" : 3882
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 3884,
        "type" : "void()",
        "endline" : 3894
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 3896,
        "type" : "const pure nothrow @property @safe bool()",
        "endline" : 3899
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL3912_1313",
    "kind" : "function",
    "line" : 3912,
    "endline" : 4309
   }
  ]
 },
 {
  "name" : "std.path",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/path.d",
  "comment" : " This module is used to manipulate _path strings.\n\n    All functions, with the exception of $(LREF expandTilde) (and in some\n    cases $(LREF absolutePath) and $(LREF relativePath)), are pure\n    string manipulation functions; they don't depend on any state outside\n    the program, nor do they perform any actual file system actions.\n    This has the consequence that the module does not make any distinction\n    between a _path that points to a directory and a _path that points to a\n    file, and it does not know whether or not the object pointed to by the\n    _path actually exists in the file system.\n    To differentiate between these cases, use $(XREF file,isDir) and\n    $(XREF file,exists).\n\n    Note that on Windows, both the backslash ($(D `\\`)) and the slash ($(D `/`))\n    are in principle valid directory separators.  This module treats them\n    both on equal footing, but in cases where a $(I new) separator is\n    added, a backslash will be used.  Furthermore, the $(LREF buildNormalizedPath)\n    function will replace all slashes with backslashes on that platform.\n\n    In general, the functions in this module assume that the input paths\n    are well-formed.  (That is, they should not contain invalid characters,\n    they should follow the file system's _path format, etc.)  The result\n    of calling a function on an ill-formed _path is undefined.  When there\n    is a chance that a _path or a file name is invalid (for instance, when it\n    has been input by the user), it may sometimes be desirable to use the\n    $(LREF isValidFilename) and $(LREF isValidPath) functions to check\n    this.\n\n    Most functions do not perform any memory allocations, and if a string is\n    returned, it is usually a slice of an input string.  If a function\n    allocates, this is explicitly mentioned in the documentation.\n\n    Authors:\n        Lars Tandle Kyllingstad,\n        $(WEB digitalmars.com, Walter Bright),\n        Grzegorz Adam Hankiewicz,\n        Thomas Kühne,\n        $(WEB erdani.org, Andrei Alexandrescu)\n    Copyright:\n        Copyright (c) 2000–2011, the authors. All rights reserved.\n    License:\n        $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0)\n    Source:\n        $(PHOBOSSRC std/_path.d)\n    Macros:\n        WIKI = Phobos/StdPath\n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 53,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 54,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 55,
    "protection" : "private"
   },
   {
    "name" : "std.file",
    "kind" : "import",
    "line" : 56,
    "protection" : "private",
    "selective" : [
     "getcwd"
    ]
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 57,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 58,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 62,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 63,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.pwd",
    "kind" : "import",
    "line" : 64,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.stdlib",
    "kind" : "import",
    "line" : 65,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 66,
    "protection" : "private",
    "selective" : [
     "onOutOfMemoryError"
    ]
   },
   {
    "name" : "dirSeparator",
    "kind" : "variable",
    "comment" : " String used to separate directory names in a path.  Under\n    POSIX this is a slash, under Windows a backslash.\n",
    "line" : 75,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"/\""
   },
   {
    "name" : "pathSeparator",
    "kind" : "variable",
    "comment" : " Path separator string.  A colon under POSIX, a semicolon\n    under Windows.\n",
    "line" : 85,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\":\""
   },
   {
    "name" : "isDirSeparator",
    "kind" : "function",
    "comment" : " Determines whether the given character is a directory separator.\n\n    On Windows, this includes both $(D `\\`) and $(D `/`).\n    On POSIX, it's just $(D `/`).\n",
    "line" : 97,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 102
   },
   {
    "name" : "isDriveSeparator",
    "kind" : "function",
    "protection" : "private",
    "line" : 111,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 115
   },
   {
    "name" : "isSeparator",
    "kind" : "alias",
    "protection" : "private",
    "line" : 123
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 130,
    "name" : "lastSeparator",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "lastSeparator",
      "kind" : "function",
      "line" : 130,
      "type" : "pure nothrow @safe ptrdiff_t(in C[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 136
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 182,
    "name" : "ltrimDirSeparators",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ltrimDirSeparators",
      "kind" : "function",
      "line" : 182,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 188
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 190,
    "name" : "rtrimDirSeparators",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "rtrimDirSeparators",
      "kind" : "function",
      "line" : 190,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 196
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 198,
    "name" : "trimDirSeparators",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "trimDirSeparators",
      "kind" : "function",
      "line" : 198,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 202
     }
    ]
   },
   {
    "name" : "CaseSensitive",
    "kind" : "enum",
    "comment" : " This $(D enum) is used as a template argument to functions which\n    compare file names, and determines whether the comparison is\n    case sensitive or not.\n",
    "line" : 211,
    "baseDeco" : "b",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " File names are case insensitive\n",
      "line" : 214
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " File names are case sensitive\n",
      "line" : 217
     },
     {
      "name" : "osDefault",
      "kind" : "enum member",
      "comment" : " The default (or most common) setting for the current platform.\n        That is, $(D no) on Windows and Mac OS X, and $(D yes) on all\n        POSIX systems except OS X (Linux, *BSD, etc.).\n    \n",
      "line" : 223
     }
    ]
   },
   {
    "name" : "osDefaultCaseSensitivity",
    "kind" : "variable",
    "protection" : "private",
    "line" : 227,
    "storageClass" : [
     "enum"
    ],
    "deco" : "b",
    "init" : "true"
   },
   {
    "kind" : "template",
    "comment" : " Returns the name of a file, without any leading directory\n    and with an optional suffix chopped off.\n\n    If $(D suffix) is specified, it will be compared to $(D path)\n    using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (baseName(\"dir/file.ext\")         == \"file.ext\");\n    assert (baseName(\"dir/file.ext\", \".ext\") == \"file\");\n    assert (baseName(\"dir/file.ext\", \".xyz\") == \"file.ext\");\n    assert (baseName(\"dir/filename\", \"name\") == \"file\");\n    assert (baseName(\"dir/subdir/\")          == \"subdir\");\n\n    version (Windows)\n    {\n        assert (baseName(`d:file.ext`)      == \"file.ext\");\n        assert (baseName(`d:\\dir\\file.ext`) == \"file.ext\");\n    }\n    ---\n\n    Note:\n    This function $(I only) strips away the specified suffix, which\n    doesn't necessarily have to represent an extension.  If you want\n    to remove the extension from a path, regardless of what the extension\n    is, use $(LREF stripExtension).\n    If you want the filename without leading directories and without\n    an extension, combine the functions like this:\n    ---\n    assert (baseName(stripExtension(\"dir/file.ext\")) == \"file\");\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html,\n    the POSIX requirements for the 'basename' shell utility)\n    (with suitable adaptations for Windows paths).\n",
    "line" : 274,
    "name" : "baseName",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "baseName",
      "kind" : "function",
      "comment" : " Returns the name of a file, without any leading directory\n    and with an optional suffix chopped off.\n\n    If $(D suffix) is specified, it will be compared to $(D path)\n    using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (baseName(\"dir/file.ext\")         == \"file.ext\");\n    assert (baseName(\"dir/file.ext\", \".ext\") == \"file\");\n    assert (baseName(\"dir/file.ext\", \".xyz\") == \"file.ext\");\n    assert (baseName(\"dir/filename\", \"name\") == \"file\");\n    assert (baseName(\"dir/subdir/\")          == \"subdir\");\n\n    version (Windows)\n    {\n        assert (baseName(`d:file.ext`)      == \"file.ext\");\n        assert (baseName(`d:\\dir\\file.ext`) == \"file.ext\");\n    }\n    ---\n\n    Note:\n    This function $(I only) strips away the specified suffix, which\n    doesn't necessarily have to represent an extension.  If you want\n    to remove the extension from a path, regardless of what the extension\n    is, use $(LREF stripExtension).\n    If you want the filename without leading directories and without\n    an extension, combine the functions like this:\n    ---\n    assert (baseName(stripExtension(\"dir/file.ext\")) == \"file\");\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html,\n    the POSIX requirements for the 'basename' shell utility)\n    (with suitable adaptations for Windows paths).\n",
      "line" : 274,
      "type" : "pure @trusted inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 292
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 295,
    "name" : "baseName",
    "parameters" : [
     {
      "name" : "cs",
      "kind" : "value",
      "deco" : "E3std4path13CaseSensitive",
      "defaultValue" : "CaseSensitive.osDefault"
     },
     {
      "name" : "C",
      "kind" : "type"
     },
     {
      "name" : "C1",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "baseName",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 295,
      "type" : "pure @safe inout(C)[](inout(C)[] path, in C1[] suffix)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       },
       {
        "name" : "suffix",
        "type" : "C1[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 307
     }
    ]
   },
   {
    "name" : "__unittestL310_1318",
    "kind" : "function",
    "line" : 310,
    "endline" : 389
   },
   {
    "kind" : "template",
    "comment" : " Returns the directory part of a path.  On Windows, this\n    includes the drive letter if present.\n\n    This function performs a memory allocation if and only if $(D path)\n    is mutable and does not have a directory (in which case a new mutable\n    string is needed to hold the returned current-directory symbol,\n    $(D \".\")).\n\n    Examples:\n    ---\n    assert (dirName(\"file\")        == \".\");\n    assert (dirName(\"dir/file\")    == \"dir\");\n    assert (dirName(\"/file\")       == \"/\");\n    assert (dirName(\"dir/subdir/\") == \"dir\");\n\n    version (Windows)\n    {\n        assert (dirName(\"d:file\")      == \"d:\");\n        assert (dirName(`d:\\dir\\file`) == `d:\\dir`);\n        assert (dirName(`d:\\file`)     == `d:\\`);\n        assert (dirName(`dir\\subdir\\`) == `dir`);\n    }\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html,\n    the POSIX requirements for the 'dirname' shell utility)\n    (with suitable adaptations for Windows paths).\n",
    "line" : 389,
    "name" : "dirName",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dirName",
      "kind" : "function",
      "comment" : " Returns the directory part of a path.  On Windows, this\n    includes the drive letter if present.\n\n    This function performs a memory allocation if and only if $(D path)\n    is mutable and does not have a directory (in which case a new mutable\n    string is needed to hold the returned current-directory symbol,\n    $(D \".\")).\n\n    Examples:\n    ---\n    assert (dirName(\"file\")        == \".\");\n    assert (dirName(\"dir/file\")    == \"dir\");\n    assert (dirName(\"/file\")       == \"/\");\n    assert (dirName(\"dir/subdir/\") == \"dir\");\n\n    version (Windows)\n    {\n        assert (dirName(\"d:file\")      == \"d:\");\n        assert (dirName(`d:\\dir\\file`) == `d:\\dir`);\n        assert (dirName(`d:\\file`)     == `d:\\`);\n        assert (dirName(`dir\\subdir\\`) == `dir`);\n    }\n    ---\n\n    Standards:\n    This function complies with\n    $(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/dirname.html,\n    the POSIX requirements for the 'dirname' shell utility)\n    (with suitable adaptations for Windows paths).\n",
      "line" : 389,
      "type" : "C[](C[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C[]"
       }
      ],
      "endline" : 420
     }
    ]
   },
   {
    "name" : "__unittestL423_1319",
    "kind" : "function",
    "line" : 423,
    "endline" : 481
   },
   {
    "kind" : "template",
    "comment" : " Returns the root directory of the specified path, or $(D null) if the\n    path is not rooted.\n\n    Examples:\n    ---\n    assert (rootName(\"foo\") is null);\n    assert (rootName(\"/foo\") == \"/\");\n\n    version (Windows)\n    {\n        assert (rootName(`\\foo`) == `\\`);\n        assert (rootName(`c:\\foo`) == `c:\\`);\n        assert (rootName(`\\\\server\\share\\foo`) == `\\\\server\\share`);\n    }\n    ---\n",
    "line" : 481,
    "name" : "rootName",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "rootName",
      "kind" : "function",
      "comment" : " Returns the root directory of the specified path, or $(D null) if the\n    path is not rooted.\n\n    Examples:\n    ---\n    assert (rootName(\"foo\") is null);\n    assert (rootName(\"/foo\") == \"/\");\n\n    version (Windows)\n    {\n        assert (rootName(`\\foo`) == `\\`);\n        assert (rootName(`c:\\foo`) == `c:\\`);\n        assert (rootName(`\\\\server\\share\\foo`) == `\\\\server\\share`);\n    }\n    ---\n",
      "line" : 481,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 506
     }
    ]
   },
   {
    "name" : "__unittestL509_1320",
    "kind" : "function",
    "line" : 509,
    "endline" : 544
   },
   {
    "kind" : "template",
    "comment" : " Returns the drive of a path, or $(D null) if the drive\n    is not specified.  In the case of UNC paths, the network share\n    is returned.\n\n    Always returns $(D null) on POSIX.\n\n    Examples:\n    ---\n    version (Windows)\n    {\n        assert (driveName(`d:\\file`) == \"d:\");\n        assert (driveName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n        assert (driveName(`dir\\file`).empty);\n    }\n    ---\n",
    "line" : 544,
    "name" : "driveName",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "driveName",
      "kind" : "function",
      "comment" : " Returns the drive of a path, or $(D null) if the drive\n    is not specified.  In the case of UNC paths, the network share\n    is returned.\n\n    Always returns $(D null) on POSIX.\n\n    Examples:\n    ---\n    version (Windows)\n    {\n        assert (driveName(`d:\\file`) == \"d:\");\n        assert (driveName(`\\\\server\\share\\file`) == `\\\\server\\share`);\n        assert (driveName(`dir\\file`).empty);\n    }\n    ---\n",
      "line" : 544,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 555
     }
    ]
   },
   {
    "name" : "__unittestL558_1321",
    "kind" : "function",
    "line" : 558,
    "endline" : 590
   },
   {
    "kind" : "template",
    "comment" : " Strips the drive from a Windows path.  On POSIX, the path is returned\n    unaltered.\n\n    Example:\n    ---\n    version (Windows)\n    {\n        assert (stripDrive(`d:\\dir\\file`) == `\\dir\\file`);\n        assert (stripDrive(`\\\\server\\share\\dir\\file`) == `\\dir\\file`);\n    }\n    ---\n",
    "line" : 590,
    "name" : "stripDrive",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stripDrive",
      "kind" : "function",
      "comment" : " Strips the drive from a Windows path.  On POSIX, the path is returned\n    unaltered.\n\n    Example:\n    ---\n    version (Windows)\n    {\n        assert (stripDrive(`d:\\dir\\file`) == `\\dir\\file`);\n        assert (stripDrive(`\\\\server\\share\\dir\\file`) == `\\dir\\file`);\n    }\n    ---\n",
      "line" : 590,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 598
     }
    ]
   },
   {
    "name" : "__unittestL601_1322",
    "kind" : "function",
    "line" : 601,
    "endline" : 621
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 621,
    "name" : "extSeparatorPos",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "extSeparatorPos",
      "kind" : "function",
      "line" : 621,
      "type" : "pure nothrow @safe ptrdiff_t(in C[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 631
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Returns the _extension part of a file name, including the dot.\n\n    If there is no _extension, $(D null) is returned.\n\n    Examples:\n    ---\n    assert (extension(\"file\").empty);\n    assert (extension(\"file.ext\")       == \".ext\");\n    assert (extension(\"file.ext1.ext2\") == \".ext2\");\n    assert (extension(\"file.\")          == \".\");\n    assert (extension(\".file\").empty);\n    assert (extension(\".file.ext\")      == \".ext\");\n    ---\n",
    "line" : 650,
    "name" : "extension",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "extension",
      "kind" : "function",
      "comment" : " Returns the _extension part of a file name, including the dot.\n\n    If there is no _extension, $(D null) is returned.\n\n    Examples:\n    ---\n    assert (extension(\"file\").empty);\n    assert (extension(\"file.ext\")       == \".ext\");\n    assert (extension(\"file.ext1.ext2\") == \".ext2\");\n    assert (extension(\"file.\")          == \".\");\n    assert (extension(\".file\").empty);\n    assert (extension(\".file.ext\")      == \".ext\");\n    ---\n",
      "line" : 650,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 655
     }
    ]
   },
   {
    "name" : "__unittestL658_1323",
    "kind" : "function",
    "line" : 658,
    "endline" : 711
   },
   {
    "kind" : "template",
    "comment" : " Returns the path with the extension stripped off.\n\n    Examples:\n    ---\n    assert (stripExtension(\"file\")           == \"file\");\n    assert (stripExtension(\"file.ext\")       == \"file\");\n    assert (stripExtension(\"file.ext1.ext2\") == \"file.ext1\");\n    assert (stripExtension(\"file.\")          == \"file\");\n    assert (stripExtension(\".file\")          == \".file\");\n    assert (stripExtension(\".file.ext\")      == \".file\");\n    assert (stripExtension(\"dir/file.ext\")   == \"dir/file\");\n    ---\n",
    "line" : 711,
    "name" : "stripExtension",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stripExtension",
      "kind" : "function",
      "comment" : " Returns the path with the extension stripped off.\n\n    Examples:\n    ---\n    assert (stripExtension(\"file\")           == \"file\");\n    assert (stripExtension(\"file.ext\")       == \"file\");\n    assert (stripExtension(\"file.ext1.ext2\") == \"file.ext1\");\n    assert (stripExtension(\"file.\")          == \"file\");\n    assert (stripExtension(\".file\")          == \".file\");\n    assert (stripExtension(\".file.ext\")      == \".file\");\n    assert (stripExtension(\"dir/file.ext\")   == \"dir/file\");\n    ---\n",
      "line" : 711,
      "type" : "pure nothrow @safe inout(C)[](inout(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "inout(C)[]"
       }
      ],
      "endline" : 717
     }
    ]
   },
   {
    "name" : "__unittestL720_1324",
    "kind" : "function",
    "line" : 720,
    "endline" : 775
   },
   {
    "kind" : "template",
    "comment" : " Returns a string containing the _path given by $(D path), but where\n    the extension has been set to $(D ext).\n\n    If the filename already has an extension, it is replaced.   If not, the\n    extension is simply appended to the filename.  Including a leading dot\n    in $(D ext) is optional.\n\n    This function normally allocates a new string (the possible exception\n    being the case when path is immutable and doesn't already have an\n    extension).\n\n    Examples:\n    ---\n    assert (setExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (setExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (setExtension(\"file.old\", \"new\")  == \"file.new\");\n    assert (setExtension(\"file.old\", \".new\") == \"file.new\");\n    ---\n",
    "line" : 775,
    "name" : "setExtension",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "setExtension",
      "kind" : "function",
      "comment" : " Returns a string containing the _path given by $(D path), but where\n    the extension has been set to $(D ext).\n\n    If the filename already has an extension, it is replaced.   If not, the\n    extension is simply appended to the filename.  Including a leading dot\n    in $(D ext) is optional.\n\n    This function normally allocates a new string (the possible exception\n    being the case when path is immutable and doesn't already have an\n    extension).\n\n    Examples:\n    ---\n    assert (setExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (setExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (setExtension(\"file.old\", \"new\")  == \"file.new\");\n    assert (setExtension(\"file.old\", \".new\") == \"file.new\");\n    ---\n",
      "line" : 775,
      "type" : "pure nothrow @trusted immutable(Unqual!(C1))[](in C1[] path, in C2[] ext)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C1[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "ext",
        "type" : "C2[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 783
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 786,
    "name" : "setExtension",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "setExtension",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 786,
      "type" : "pure nothrow @trusted immutable(C1)[](immutable(C1)[] path, const(C2)[] ext)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "immutable(C1)[]"
       },
       {
        "name" : "ext",
        "type" : "const(C2)[]"
       }
      ],
      "endline" : 808
     }
    ]
   },
   {
    "name" : "__unittestL811_1325",
    "kind" : "function",
    "line" : 811,
    "endline" : 854
   },
   {
    "kind" : "template",
    "comment" : " Returns the _path given by $(D path), with the extension given by\n    $(D ext) appended if the path doesn't already have one.\n\n    Including the dot in the extension is optional.\n\n    This function always allocates a new string, except in the case when\n    path is immutable and already has an extension.\n\n    Examples:\n    ---\n    assert (defaultExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (defaultExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (defaultExtension(\"file.\", \"ext\")     == \"file.\");\n    assert (defaultExtension(\"file.old\", \"new\")  == \"file.old\");\n    assert (defaultExtension(\"file.old\", \".new\") == \"file.old\");\n    ---\n",
    "line" : 854,
    "name" : "defaultExtension",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "defaultExtension",
      "kind" : "function",
      "comment" : " Returns the _path given by $(D path), with the extension given by\n    $(D ext) appended if the path doesn't already have one.\n\n    Including the dot in the extension is optional.\n\n    This function always allocates a new string, except in the case when\n    path is immutable and already has an extension.\n\n    Examples:\n    ---\n    assert (defaultExtension(\"file\", \"ext\")      == \"file.ext\");\n    assert (defaultExtension(\"file\", \".ext\")     == \"file.ext\");\n    assert (defaultExtension(\"file.\", \"ext\")     == \"file.\");\n    assert (defaultExtension(\"file.old\", \"new\")  == \"file.old\");\n    assert (defaultExtension(\"file.old\", \".new\") == \"file.old\");\n    ---\n",
      "line" : 854,
      "type" : "pure @trusted immutable(Unqual!(C1))[](in C1[] path, in C2[] ext)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C1[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "ext",
        "type" : "C2[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 867
     }
    ]
   },
   {
    "name" : "__unittestL870_1326",
    "kind" : "function",
    "line" : 870,
    "endline" : 918
   },
   {
    "kind" : "template",
    "comment" : " Combines one or more path components.\n\n    The given path components are concatenated with each other,\n    and if necessary, directory separators are inserted between\n    them. If any of the path components are rooted (as defined by\n    $(LREF isRooted)) the preceding path components will be dropped.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == \"foo/bar/baz\");\n        assert (buildPath(\"/foo/\", \"bar\")      == \"/foo/bar\");\n        assert (buildPath(\"/foo\", \"/bar\")      == \"/bar\");\n    }\n\n    version (Windows)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == `foo\\bar\\baz`);\n        assert (buildPath(`c:\\foo`, \"bar\")    == `c:\\foo\\bar`);\n        assert (buildPath(\"foo\", `d:\\bar`)    == `d:\\bar`);\n        assert (buildPath(\"foo\", `\\bar`)      == `\\bar`);\n    }\n    ---\n",
    "line" : 918,
    "name" : "buildPath",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "buildPath",
      "kind" : "function",
      "comment" : " Combines one or more path components.\n\n    The given path components are concatenated with each other,\n    and if necessary, directory separators are inserted between\n    them. If any of the path components are rooted (as defined by\n    $(LREF isRooted)) the preceding path components will be dropped.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == \"foo/bar/baz\");\n        assert (buildPath(\"/foo/\", \"bar\")      == \"/foo/bar\");\n        assert (buildPath(\"/foo\", \"/bar\")      == \"/bar\");\n    }\n\n    version (Windows)\n    {\n        assert (buildPath(\"foo\", \"bar\", \"baz\") == `foo\\bar\\baz`);\n        assert (buildPath(`c:\\foo`, \"bar\")    == `c:\\foo\\bar`);\n        assert (buildPath(\"foo\", `d:\\bar`)    == `d:\\bar`);\n        assert (buildPath(\"foo\", `\\bar`)      == `\\bar`);\n    }\n    ---\n",
      "line" : 918,
      "type" : "pure @safe immutable(C)[](const(C[])[] paths...)",
      "parameters" : [
       {
        "name" : "paths",
        "type" : "const(C[])[]"
       }
      ],
      "endline" : 934
     }
    ]
   },
   {
    "name" : "__unittestL937_1327",
    "kind" : "function",
    "line" : 937,
    "endline" : 973
   },
   {
    "name" : "__unittestL973_1328",
    "kind" : "function",
    "line" : 973,
    "endline" : 1021
   },
   {
    "kind" : "template",
    "comment" : " Performs the same task as $(LREF buildPath),\n    while at the same time resolving current/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    On Windows, slashes are replaced with backslashes.\n\n    Note that this function does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildNormalizedPath(\"/foo/./bar/..//baz/\") == \"/foo/baz\");\n        assert (buildNormalizedPath(\"../foo/.\") == \"../foo\");\n        assert (buildNormalizedPath(\"/foo\", \"bar/baz/\") == \"/foo/bar/baz\");\n        assert (buildNormalizedPath(\"/foo\", \"/bar/..\", \"baz\") == \"/baz\");\n        assert (buildNormalizedPath(\"foo/./bar\", \"../../\", \"../baz\") == \"../baz\");\n        assert (buildNormalizedPath(\"/foo/./bar\", \"../../baz\") == \"/baz\");\n    }\n\n    version (Windows)\n    {\n        assert (buildNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`) == `c:\\foo\\baz`);\n        assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar/..`) == `c:\\foo`);\n        assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) == `\\\\server\\share\\bar`);\n    }\n    ---\n",
    "line" : 1021,
    "name" : "buildNormalizedPath",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "buildNormalizedPath",
      "kind" : "function",
      "comment" : " Performs the same task as $(LREF buildPath),\n    while at the same time resolving current/parent directory\n    symbols ($(D \".\") and $(D \"..\")) and removing superfluous\n    directory separators.\n    On Windows, slashes are replaced with backslashes.\n\n    Note that this function does not resolve symbolic links.\n\n    This function always allocates memory to hold the resulting path.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (buildNormalizedPath(\"/foo/./bar/..//baz/\") == \"/foo/baz\");\n        assert (buildNormalizedPath(\"../foo/.\") == \"../foo\");\n        assert (buildNormalizedPath(\"/foo\", \"bar/baz/\") == \"/foo/bar/baz\");\n        assert (buildNormalizedPath(\"/foo\", \"/bar/..\", \"baz\") == \"/baz\");\n        assert (buildNormalizedPath(\"foo/./bar\", \"../../\", \"../baz\") == \"../baz\");\n        assert (buildNormalizedPath(\"/foo/./bar\", \"../../baz\") == \"/baz\");\n    }\n\n    version (Windows)\n    {\n        assert (buildNormalizedPath(`c:\\foo\\.\\bar/..\\\\baz\\`) == `c:\\foo\\baz`);\n        assert (buildNormalizedPath(`..\\foo\\.`) == `..\\foo`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar\\baz\\`) == `c:\\foo\\bar\\baz`);\n        assert (buildNormalizedPath(`c:\\foo`, `bar/..`) == `c:\\foo`);\n        assert (buildNormalizedPath(`\\\\server\\share\\foo`, `..\\bar`) == `\\\\server\\share\\bar`);\n    }\n    ---\n",
      "line" : 1021,
      "type" : "pure nothrow @trusted immutable(C)[](const(C[])[] paths...)",
      "parameters" : [
       {
        "name" : "paths",
        "type" : "const(C[])[]"
       }
      ],
      "endline" : 1217
     }
    ]
   },
   {
    "name" : "__unittestL1219_1329",
    "kind" : "function",
    "line" : 1219,
    "endline" : 1295
   },
   {
    "name" : "__unittestL1295_1330",
    "kind" : "function",
    "line" : 1295,
    "endline" : 1400
   },
   {
    "name" : "__unittestL1400_1331",
    "kind" : "function",
    "line" : 1400,
    "endline" : 1435
   },
   {
    "kind" : "template",
    "comment" : " Returns a bidirectional range that iterates over the elements of a path.\n\n    Examples:\n    ---\n    assert (equal(pathSplitter(\"/\"), [\"/\"]));\n    assert (equal(pathSplitter(\"/foo/bar\"), [\"/\", \"foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"//foo/bar\"), [\"//foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"foo/../bar//./\"), [\"foo\", \"..\", \"bar\", \".\"]));\n\n    version (Windows)\n    {\n        assert (equal(pathSplitter(`foo\\..\\bar\\/.\\`), [\"foo\", \"..\", \"bar\", \".\"]));\n        assert (equal(pathSplitter(\"c:\"), [\"c:\"]));\n        assert (equal(pathSplitter(`c:\\foo\\bar`), [`c:\\`, \"foo\", \"bar\"]));\n        assert (equal(pathSplitter(`c:foo\\bar`), [\"c:foo\", \"bar\"]));\n    }\n    ---\n",
    "line" : 1435,
    "name" : "pathSplitter",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pathSplitter",
      "kind" : "function",
      "comment" : " Returns a bidirectional range that iterates over the elements of a path.\n\n    Examples:\n    ---\n    assert (equal(pathSplitter(\"/\"), [\"/\"]));\n    assert (equal(pathSplitter(\"/foo/bar\"), [\"/\", \"foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"//foo/bar\"), [\"//foo\", \"bar\"]));\n    assert (equal(pathSplitter(\"foo/../bar//./\"), [\"foo\", \"..\", \"bar\", \".\"]));\n\n    version (Windows)\n    {\n        assert (equal(pathSplitter(`foo\\..\\bar\\/.\\`), [\"foo\", \"..\", \"bar\", \".\"]));\n        assert (equal(pathSplitter(\"c:\"), [\"c:\"]));\n        assert (equal(pathSplitter(`c:\\foo\\bar`), [`c:\\`, \"foo\", \"bar\"]));\n        assert (equal(pathSplitter(`c:foo\\bar`), [\"c:foo\", \"bar\"]));\n    }\n    ---\n",
      "line" : 1435,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow @safe (const(C)[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "const(C)[]"
       }
      ],
      "endline" : 1569
     }
    ]
   },
   {
    "name" : "__unittestL1571_1332",
    "kind" : "function",
    "line" : 1571,
    "endline" : 1658
   },
   {
    "kind" : "template",
    "comment" : " Determines whether a path starts at a root directory.\n\n    On POSIX, this function returns true if and only if the path starts\n    with a slash (/).\n    ---\n    version (Posix)\n    {\n        assert (isRooted(\"/\"));\n        assert (isRooted(\"/foo\"));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"../foo\"));\n    }\n    ---\n\n    On Windows, this function returns true if the path starts at\n    the root directory of the current drive, of some other drive,\n    or of a network drive.\n    ---\n    version (Windows)\n    {\n        assert (isRooted(`\\`));\n        assert (isRooted(`\\foo`));\n        assert (isRooted(`d:\\foo`));\n        assert (isRooted(`\\\\foo\\bar`));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"d:foo\"));\n    }\n    ---\n",
    "line" : 1658,
    "name" : "isRooted",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isRooted",
      "kind" : "function",
      "comment" : " Determines whether a path starts at a root directory.\n\n    On POSIX, this function returns true if and only if the path starts\n    with a slash (/).\n    ---\n    version (Posix)\n    {\n        assert (isRooted(\"/\"));\n        assert (isRooted(\"/foo\"));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"../foo\"));\n    }\n    ---\n\n    On Windows, this function returns true if the path starts at\n    the root directory of the current drive, of some other drive,\n    or of a network drive.\n    ---\n    version (Windows)\n    {\n        assert (isRooted(`\\`));\n        assert (isRooted(`\\foo`));\n        assert (isRooted(`d:\\foo`));\n        assert (isRooted(`\\\\foo\\bar`));\n        assert (!isRooted(\"foo\"));\n        assert (!isRooted(\"d:foo\"));\n    }\n    ---\n",
      "line" : 1658,
      "type" : "pure nothrow @safe bool(in C[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 1663
     }
    ]
   },
   {
    "name" : "__unittestL1666_1333",
    "kind" : "function",
    "line" : 1666,
    "endline" : 1721
   },
   {
    "name" : "isAbsolute",
    "kind" : "alias",
    "comment" : " Determines whether a path is absolute or not.\n\n    Examples:\n    On POSIX, an absolute path starts at the root directory.\n    (In fact, $(D _isAbsolute) is just an alias for $(LREF isRooted).)\n    ---\n    version (Posix)\n    {\n        assert (isAbsolute(\"/\"));\n        assert (isAbsolute(\"/foo\"));\n        assert (!isAbsolute(\"foo\"));\n        assert (!isAbsolute(\"../foo\"));\n    }\n    ---\n\n    On Windows, an absolute path starts at the root directory of\n    a specific drive.  Hence, it must start with $(D `d:\\`) or $(D `d:/`),\n    where $(D d) is the drive letter.  Alternatively, it may be a\n    network path, i.e. a path starting with a double (back)slash.\n    ---\n    version (Windows)\n    {\n        assert (isAbsolute(`d:\\`));\n        assert (isAbsolute(`d:\\foo`));\n        assert (isAbsolute(`\\\\foo\\bar`));\n        assert (!isAbsolute(`\\`));\n        assert (!isAbsolute(`\\foo`));\n        assert (!isAbsolute(\"d:foo\"));\n    }\n    ---\n",
    "line" : 1730
   },
   {
    "name" : "__unittestL1733_1334",
    "kind" : "function",
    "line" : 1733,
    "endline" : 1795
   },
   {
    "name" : "absolutePath",
    "kind" : "function",
    "comment" : " Translates $(D path) into an absolute _path.\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is empty, return $(D null).)\n        $(LI If $(D path) is already absolute, return it.)\n        $(LI Otherwise, append $(D path) to $(D base) and return\n            the result. If $(D base) is not specified, the current\n            working directory is used.)\n    )\n    The function allocates memory if and only if it gets to the third stage\n    of this algorithm.\n\n    Examples:\n    ---\n    version (Posix)\n    {\n        assert (absolutePath(\"some/file\", \"/foo/bar\")  == \"/foo/bar/some/file\");\n        assert (absolutePath(\"../file\", \"/foo/bar\")    == \"/foo/bar/../file\");\n        assert (absolutePath(\"/some/file\", \"/foo/bar\") == \"/some/file\");\n    }\n\n    version (Windows)\n    {\n        assert (absolutePath(`some\\file`, `c:\\foo\\bar`)    == `c:\\foo\\bar\\some\\file`);\n        assert (absolutePath(`..\\file`, `c:\\foo\\bar`)      == `c:\\foo\\bar\\..\\file`);\n        assert (absolutePath(`c:\\some\\file`, `c:\\foo\\bar`) == `c:\\some\\file`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
    "line" : 1795,
    "deco" : "FNaNfAyaLAyaZAya",
    "parameters" : [
     {
      "name" : "path",
      "deco" : "Aya"
     },
     {
      "name" : "base",
      "deco" : "Aya",
      "storageClass" : [
       "lazy"
      ],
      "default" : "getcwd()"
     }
    ],
    "endline" : 1803
   },
   {
    "name" : "__unittestL1806_1335",
    "kind" : "function",
    "line" : 1806,
    "endline" : 1884
   },
   {
    "kind" : "template",
    "comment" : " Translates $(D path) into a relative _path.\n\n    The returned _path is relative to $(D base), which is by default\n    taken to be the current working directory.  If specified,\n    $(D base) must be an absolute _path, and it is always assumed\n    to refer to a directory.  If $(D path) and $(D base) refer to\n    the same directory, the function returns $(D `.`).\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is a relative directory, return it unaltered.)\n        $(LI Find a common root between $(D path) and $(D base).\n            If there is no common root, return $(D path) unaltered.)\n        $(LI Prepare a string with as many $(D `../`) or $(D `..\\`) as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of $(D path) to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    The function allocates memory if and only if it reaches the third stage\n    of the above algorithm.\n\n    Examples:\n    ---\n    assert (relativePath(\"foo\") == \"foo\");\n\n    version (Posix)\n    {\n        assert (relativePath(\"foo\", \"/bar\") == \"foo\");\n        assert (relativePath(\"/foo/bar\", \"/foo/bar\") == \".\");\n        assert (relativePath(\"/foo/bar\", \"/foo/baz\") == \"../bar\");\n        assert (relativePath(\"/foo/bar/baz\", \"/foo/woo/wee\") == \"../../bar/baz\");\n        assert (relativePath(\"/foo/bar/baz\", \"/foo/bar\") == \"baz\");\n    }\n    version (Windows)\n    {\n        assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n        assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
    "line" : 1884,
    "name" : "relativePath",
    "parameters" : [
     {
      "name" : "cs",
      "kind" : "value",
      "deco" : "E3std4path13CaseSensitive",
      "defaultValue" : "CaseSensitive.osDefault"
     }
    ],
    "members" : [
     {
      "name" : "relativePath",
      "kind" : "function",
      "comment" : " Translates $(D path) into a relative _path.\n\n    The returned _path is relative to $(D base), which is by default\n    taken to be the current working directory.  If specified,\n    $(D base) must be an absolute _path, and it is always assumed\n    to refer to a directory.  If $(D path) and $(D base) refer to\n    the same directory, the function returns $(D `.`).\n\n    The following algorithm is used:\n    $(OL\n        $(LI If $(D path) is a relative directory, return it unaltered.)\n        $(LI Find a common root between $(D path) and $(D base).\n            If there is no common root, return $(D path) unaltered.)\n        $(LI Prepare a string with as many $(D `../`) or $(D `..\\`) as\n            necessary to reach the common root from base path.)\n        $(LI Append the remaining segments of $(D path) to the string\n            and return.)\n    )\n\n    In the second step, path components are compared using $(D filenameCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCmp) documentation for details.\n\n    The function allocates memory if and only if it reaches the third stage\n    of the above algorithm.\n\n    Examples:\n    ---\n    assert (relativePath(\"foo\") == \"foo\");\n\n    version (Posix)\n    {\n        assert (relativePath(\"foo\", \"/bar\") == \"foo\");\n        assert (relativePath(\"/foo/bar\", \"/foo/bar\") == \".\");\n        assert (relativePath(\"/foo/bar\", \"/foo/baz\") == \"../bar\");\n        assert (relativePath(\"/foo/bar/baz\", \"/foo/woo/wee\") == \"../../bar/baz\");\n        assert (relativePath(\"/foo/bar/baz\", \"/foo/bar\") == \"baz\");\n    }\n    version (Windows)\n    {\n        assert (relativePath(\"foo\", `c:\\bar`) == \"foo\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\bar`) == \".\");\n        assert (relativePath(`c:\\foo\\bar`, `c:\\foo\\baz`) == `..\\bar`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\woo\\wee`) == `..\\..\\bar\\baz`);\n        assert (relativePath(`c:\\foo\\bar\\baz`, `c:\\foo\\bar`) == \"baz\");\n        assert (relativePath(`c:\\foo\\bar`, `d:\\foo`) == `c:\\foo\\bar`);\n    }\n    ---\n\n    Throws:\n    $(D Exception) if the specified _base directory is not absolute.\n",
      "line" : 1884,
      "type" : "string(string path, lazy string base = getcwd())",
      "parameters" : [
       {
        "name" : "path",
        "type" : "string"
       },
       {
        "name" : "base",
        "type" : "string",
        "storageClass" : [
         "lazy"
        ],
        "default" : "getcwd()"
       }
      ],
      "endline" : 1931
     }
    ]
   },
   {
    "name" : "__unittestL1933_1336",
    "kind" : "function",
    "line" : 1933,
    "endline" : 2002
   },
   {
    "kind" : "template",
    "comment" : " Compares filename characters and return $(D < 0) if $(D a < b), $(D 0) if\n    $(D a == b) and $(D > 0) if $(D a > b).\n\n    This function can perform a case-sensitive or a case-insensitive\n    comparison.  This is controlled through the $(D cs) template parameter\n    which, if not specified, is given by\n    $(LREF CaseSensitive)$(D .osDefault).\n\n    On Windows, the backslash and slash characters ($(D `\\`) and $(D `/`))\n    are considered equal.\n\n    Examples:\n    ---\n    assert (filenameCharCmp('a', 'a') == 0);\n    assert (filenameCharCmp('a', 'b') < 0);\n    assert (filenameCharCmp('b', 'a') > 0);\n\n    version (linux)\n    {\n        // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n        assert (filenameCharCmp('A', 'a') < 0);\n        assert (filenameCharCmp('a', 'A') > 0);\n    }\n    version (Windows)\n    {\n        // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n        assert (filenameCharCmp('a', 'A') == 0);\n        assert (filenameCharCmp('a', 'B') < 0);\n        assert (filenameCharCmp('A', 'b') < 0);\n    }\n    ---\n",
    "line" : 2002,
    "name" : "filenameCharCmp",
    "parameters" : [
     {
      "name" : "cs",
      "kind" : "value",
      "deco" : "E3std4path13CaseSensitive",
      "defaultValue" : "CaseSensitive.osDefault"
     }
    ],
    "members" : [
     {
      "name" : "filenameCharCmp",
      "kind" : "function",
      "comment" : " Compares filename characters and return $(D < 0) if $(D a < b), $(D 0) if\n    $(D a == b) and $(D > 0) if $(D a > b).\n\n    This function can perform a case-sensitive or a case-insensitive\n    comparison.  This is controlled through the $(D cs) template parameter\n    which, if not specified, is given by\n    $(LREF CaseSensitive)$(D .osDefault).\n\n    On Windows, the backslash and slash characters ($(D `\\`) and $(D `/`))\n    are considered equal.\n\n    Examples:\n    ---\n    assert (filenameCharCmp('a', 'a') == 0);\n    assert (filenameCharCmp('a', 'b') < 0);\n    assert (filenameCharCmp('b', 'a') > 0);\n\n    version (linux)\n    {\n        // Same as calling filenameCharCmp!(CaseSensitive.yes)(a, b)\n        assert (filenameCharCmp('A', 'a') < 0);\n        assert (filenameCharCmp('a', 'A') > 0);\n    }\n    version (Windows)\n    {\n        // Same as calling filenameCharCmp!(CaseSensitive.no)(a, b)\n        assert (filenameCharCmp('a', 'A') == 0);\n        assert (filenameCharCmp('a', 'B') < 0);\n        assert (filenameCharCmp('A', 'b') < 0);\n    }\n    ---\n",
      "line" : 2002,
      "type" : "pure nothrow @safe int(dchar a, dchar b)",
      "parameters" : [
       {
        "name" : "a",
        "deco" : "w"
       },
       {
        "name" : "b",
        "deco" : "w"
       }
      ],
      "endline" : 2013
     }
    ]
   },
   {
    "name" : "__unittestL2016_1337",
    "kind" : "function",
    "line" : 2016,
    "endline" : 2075
   },
   {
    "kind" : "template",
    "comment" : " Compares file names and returns\n    $(D < 0) if $(D filename1 < filename2),\n    $(D 0) if $(D filename1 == filename2) and\n    $(D > 0) if $(D filename1 > filename2).\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (filenameCmp(\"abc\", \"abc\") == 0);\n    assert (filenameCmp(\"abc\", \"abd\") < 0);\n    assert (filenameCmp(\"abc\", \"abb\") > 0);\n    assert (filenameCmp(\"abc\", \"abcd\") < 0);\n    assert (filenameCmp(\"abcd\", \"abc\") > 0);\n\n    version (linux)\n    {\n        // Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") < 0);\n        assert (filenameCmp(\"abc\", \"Abc\") > 0);\n    }\n    version (Windows)\n    {\n        // Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") == 0);\n        assert (filenameCmp(\"abc\", \"Abc\") == 0);\n        assert (filenameCmp(\"Abc\", \"abD\") < 0);\n        assert (filenameCmp(\"abc\", \"AbB\") > 0);\n    }\n    ---\n",
    "line" : 2075,
    "name" : "filenameCmp",
    "parameters" : [
     {
      "name" : "cs",
      "kind" : "value",
      "deco" : "E3std4path13CaseSensitive",
      "defaultValue" : "CaseSensitive.osDefault"
     },
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "filenameCmp",
      "kind" : "function",
      "comment" : " Compares file names and returns\n    $(D < 0) if $(D filename1 < filename2),\n    $(D 0) if $(D filename1 == filename2) and\n    $(D > 0) if $(D filename1 > filename2).\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Examples:\n    ---\n    assert (filenameCmp(\"abc\", \"abc\") == 0);\n    assert (filenameCmp(\"abc\", \"abd\") < 0);\n    assert (filenameCmp(\"abc\", \"abb\") > 0);\n    assert (filenameCmp(\"abc\", \"abcd\") < 0);\n    assert (filenameCmp(\"abcd\", \"abc\") > 0);\n\n    version (linux)\n    {\n        // Same as calling filenameCmp!(CaseSensitive.yes)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") < 0);\n        assert (filenameCmp(\"abc\", \"Abc\") > 0);\n    }\n    version (Windows)\n    {\n        // Same as calling filenameCmp!(CaseSensitive.no)(filename1, filename2)\n        assert (filenameCmp(\"Abc\", \"abc\") == 0);\n        assert (filenameCmp(\"abc\", \"Abc\") == 0);\n        assert (filenameCmp(\"Abc\", \"abD\") < 0);\n        assert (filenameCmp(\"abc\", \"AbB\") > 0);\n    }\n    ---\n",
      "line" : 2075,
      "type" : "pure @safe int(const(C1)[] filename1, const(C2)[] filename2)",
      "parameters" : [
       {
        "name" : "filename1",
        "type" : "const(C1)[]"
       },
       {
        "name" : "filename2",
        "type" : "const(C2)[]"
       }
      ],
      "endline" : 2090
     }
    ]
   },
   {
    "name" : "__unittestL2093_1338",
    "kind" : "function",
    "line" : 2093,
    "endline" : 2180
   },
   {
    "kind" : "template",
    "comment" : " Matches a pattern against a path.\n\n    Some characters of pattern have a special meaning (they are\n    $(I meta-characters)) and can't be escaped. These are:\n\n    $(BOOKTABLE,\n    $(TR $(TD $(D *))\n         $(TD Matches 0 or more instances of any character.))\n    $(TR $(TD $(D ?))\n         $(TD Matches exactly one instance of any character.))\n    $(TR $(TD $(D [)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that appears\n              between the brackets.))\n    $(TR $(TD $(D [!)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that does not\n              appear between the brackets after the exclamation mark.))\n    $(TR $(TD $(D {)$(I string1)$(D ,)$(I string2)$(D ,)&hellip;$(D }))\n         $(TD Matches either of the specified strings.))\n    )\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Note that directory\n    separators and dots don't stop a meta-character from matching\n    further portions of the path.\n\n    Returns:\n    $(D true) if pattern matches path, $(D false) otherwise.\n\n    See_also:\n    $(LINK2 http://en.wikipedia.org/wiki/Glob_%28programming%29,Wikipedia: _glob (programming))\n\n    Examples:\n    -----\n    assert (globMatch(\"foo.bar\", \"*\"));\n    assert (globMatch(\"foo.bar\", \"*.*\"));\n    assert (globMatch(`foo/foo\\bar`, \"f*b*r\"));\n    assert (globMatch(\"foo.bar\", \"f???bar\"));\n    assert (globMatch(\"foo.bar\", \"[fg]???bar\"));\n    assert (globMatch(\"foo.bar\", \"[!gh]*bar\"));\n    assert (globMatch(\"bar.fooz\", \"bar.{foo,bif}z\"));\n    assert (globMatch(\"bar.bifz\", \"bar.{foo,bif}z\"));\n\n    version (Windows)\n    {\n        // Same as calling globMatch!(CaseSensitive.no)(path, pattern)\n        assert (globMatch(\"foo\", \"Foo\"));\n        assert (globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    version (linux)\n    {\n        // Same as calling globMatch!(CaseSensitive.yes)(path, pattern)\n        assert (!globMatch(\"foo\", \"Foo\"));\n        assert (!globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    -----\n \n",
    "line" : 2180,
    "name" : "globMatch",
    "parameters" : [
     {
      "name" : "cs",
      "kind" : "value",
      "deco" : "E3std4path13CaseSensitive",
      "defaultValue" : "CaseSensitive.osDefault"
     },
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "globMatch",
      "kind" : "function",
      "comment" : " Matches a pattern against a path.\n\n    Some characters of pattern have a special meaning (they are\n    $(I meta-characters)) and can't be escaped. These are:\n\n    $(BOOKTABLE,\n    $(TR $(TD $(D *))\n         $(TD Matches 0 or more instances of any character.))\n    $(TR $(TD $(D ?))\n         $(TD Matches exactly one instance of any character.))\n    $(TR $(TD $(D [)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that appears\n              between the brackets.))\n    $(TR $(TD $(D [!)$(I chars)$(D ]))\n         $(TD Matches one instance of any character that does not\n              appear between the brackets after the exclamation mark.))\n    $(TR $(TD $(D {)$(I string1)$(D ,)$(I string2)$(D ,)&hellip;$(D }))\n         $(TD Matches either of the specified strings.))\n    )\n\n    Individual characters are compared using $(D filenameCharCmp!cs),\n    where $(D cs) is an optional template parameter determining whether\n    the comparison is case sensitive or not.  See the\n    $(LREF filenameCharCmp) documentation for details.\n\n    Note that directory\n    separators and dots don't stop a meta-character from matching\n    further portions of the path.\n\n    Returns:\n    $(D true) if pattern matches path, $(D false) otherwise.\n\n    See_also:\n    $(LINK2 http://en.wikipedia.org/wiki/Glob_%28programming%29,Wikipedia: _glob (programming))\n\n    Examples:\n    -----\n    assert (globMatch(\"foo.bar\", \"*\"));\n    assert (globMatch(\"foo.bar\", \"*.*\"));\n    assert (globMatch(`foo/foo\\bar`, \"f*b*r\"));\n    assert (globMatch(\"foo.bar\", \"f???bar\"));\n    assert (globMatch(\"foo.bar\", \"[fg]???bar\"));\n    assert (globMatch(\"foo.bar\", \"[!gh]*bar\"));\n    assert (globMatch(\"bar.fooz\", \"bar.{foo,bif}z\"));\n    assert (globMatch(\"bar.bifz\", \"bar.{foo,bif}z\"));\n\n    version (Windows)\n    {\n        // Same as calling globMatch!(CaseSensitive.no)(path, pattern)\n        assert (globMatch(\"foo\", \"Foo\"));\n        assert (globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    version (linux)\n    {\n        // Same as calling globMatch!(CaseSensitive.yes)(path, pattern)\n        assert (!globMatch(\"foo\", \"Foo\"));\n        assert (!globMatch(\"Goo.bar\", \"[fg]???bar\"));\n    }\n    -----\n \n",
      "line" : 2180,
      "type" : "pure nothrow @safe bool(const(C)[] path, const(C)[] pattern)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "const(C)[]"
       },
       {
        "name" : "pattern",
        "type" : "const(C)[]"
       }
      ],
      "endline" : 2297
     }
    ]
   },
   {
    "name" : "__unittestL2299_1339",
    "kind" : "function",
    "line" : 2299,
    "endline" : 2372
   },
   {
    "kind" : "template",
    "comment" : " Checks that the given file or directory name is valid.\n\n    This function returns $(D true) if and only if $(D filename) is not\n    empty, not too long, and does not contain invalid characters.\n\n    The maximum length of $(D filename) is given by the constant\n    $(D core.stdc.stdio.FILENAME_MAX).  (On Windows, this number is\n    defined as the maximum number of UTF-16 code points, and the\n    test will therefore only yield strictly correct results when\n    $(D filename) is a string of $(D wchar)s.)\n\n    On Windows, the following criteria must be satisfied\n    ($(LINK2 http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx,source)):\n    $(UL\n        $(LI $(D filename) must not contain any characters whose integer\n            representation is in the range 0-31.)\n        $(LI $(D filename) must not contain any of the following $(I reserved\n            characters): <>:\"/\\|?*)\n        $(LI $(D filename) may not end with a space ($(D ' ')) or a period\n            ($(D '.')).)\n    )\n\n    On POSIX, $(D filename) may not contain a forward slash ($(D '/')) or\n    the null character ($(D '\\0')).\n",
    "line" : 2372,
    "name" : "isValidFilename",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isValidFilename",
      "kind" : "function",
      "comment" : " Checks that the given file or directory name is valid.\n\n    This function returns $(D true) if and only if $(D filename) is not\n    empty, not too long, and does not contain invalid characters.\n\n    The maximum length of $(D filename) is given by the constant\n    $(D core.stdc.stdio.FILENAME_MAX).  (On Windows, this number is\n    defined as the maximum number of UTF-16 code points, and the\n    test will therefore only yield strictly correct results when\n    $(D filename) is a string of $(D wchar)s.)\n\n    On Windows, the following criteria must be satisfied\n    ($(LINK2 http://msdn.microsoft.com/en-us/library/aa365247(v=vs.85).aspx,source)):\n    $(UL\n        $(LI $(D filename) must not contain any characters whose integer\n            representation is in the range 0-31.)\n        $(LI $(D filename) must not contain any of the following $(I reserved\n            characters): <>:\"/\\|?*)\n        $(LI $(D filename) may not end with a space ($(D ' ')) or a period\n            ($(D '.')).)\n    )\n\n    On POSIX, $(D filename) may not contain a forward slash ($(D '/')) or\n    the null character ($(D '\\0')).\n",
      "line" : 2372,
      "type" : "pure nothrow @safe bool(in C[] filename)",
      "parameters" : [
       {
        "name" : "filename",
        "type" : "C[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2411
     }
    ]
   },
   {
    "name" : "__unittestL2414_1340",
    "kind" : "function",
    "line" : 2414,
    "endline" : 2461
   },
   {
    "kind" : "template",
    "comment" : " Checks whether $(D path) is a valid _path.\n\n    Generally, this function checks that $(D path) is not empty, and that\n    each component of the path either satisfies $(LREF isValidFilename)\n    or is equal to $(D \".\") or $(D \"..\").\n    It does $(I not) check whether the _path points to an existing file\n    or directory; use $(XREF file,exists) for this purpose.\n\n    On Windows, some special rules apply:\n    $(UL\n        $(LI If the second character of $(D path) is a colon ($(D ':')),\n            the first character is interpreted as a drive letter, and\n            must be in the range A-Z (case insensitive).)\n        $(LI If $(D path) is on the form $(D `\\\\$(I server)\\$(I share)\\...`)\n            (UNC path), $(LREF isValidFilename) is applied to $(I server)\n            and $(I share) as well.)\n        $(LI If $(D path) starts with $(D `\\\\?\\`) (long UNC path), the\n            only requirement for the rest of the string is that it does\n            not contain the null character.)\n        $(LI If $(D path) starts with $(D `\\\\.\\`) (Win32 device namespace)\n            this function returns $(D false); such paths are beyond the scope\n            of this module.)\n    )\n",
    "line" : 2461,
    "name" : "isValidPath",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isValidPath",
      "kind" : "function",
      "comment" : " Checks whether $(D path) is a valid _path.\n\n    Generally, this function checks that $(D path) is not empty, and that\n    each component of the path either satisfies $(LREF isValidFilename)\n    or is equal to $(D \".\") or $(D \"..\").\n    It does $(I not) check whether the _path points to an existing file\n    or directory; use $(XREF file,exists) for this purpose.\n\n    On Windows, some special rules apply:\n    $(UL\n        $(LI If the second character of $(D path) is a colon ($(D ':')),\n            the first character is interpreted as a drive letter, and\n            must be in the range A-Z (case insensitive).)\n        $(LI If $(D path) is on the form $(D `\\\\$(I server)\\$(I share)\\...`)\n            (UNC path), $(LREF isValidFilename) is applied to $(I server)\n            and $(I share) as well.)\n        $(LI If $(D path) starts with $(D `\\\\?\\`) (long UNC path), the\n            only requirement for the rest of the string is that it does\n            not contain the null character.)\n        $(LI If $(D path) starts with $(D `\\\\.\\`) (Win32 device namespace)\n            this function returns $(D false); such paths are beyond the scope\n            of this module.)\n    )\n",
      "line" : 2461,
      "type" : "pure nothrow @safe bool(in C[] path)",
      "parameters" : [
       {
        "name" : "path",
        "type" : "C[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2552
     }
    ]
   },
   {
    "name" : "__unittestL2555_1341",
    "kind" : "function",
    "line" : 2555,
    "endline" : 2630
   },
   {
    "name" : "expandTilde",
    "kind" : "function",
    "comment" : " Performs tilde expansion in paths on POSIX systems.\n    On Windows, this function does nothing.\n\n    There are two ways of using tilde expansion in a path. One\n    involves using the tilde alone or followed by a path separator. In\n    this case, the tilde will be expanded with the value of the\n    environment variable $(D HOME).  The second way is putting\n    a username after the tilde (i.e. $(D ~john/Mail)). Here,\n    the username will be searched for in the user database\n    (i.e. $(D /etc/passwd) on Unix systems) and will expand to\n    whatever path is stored there.  The username is considered the\n    string after the tilde ending at the first instance of a path\n    separator.\n\n    Note that using the $(D ~user) syntax may give different\n    values from just $(D ~) if the environment variable doesn't\n    match the value stored in the user database.\n\n    When the environment variable version is used, the path won't\n    be modified if the environment variable doesn't exist or it\n    is empty. When the database version is used, the path won't be\n    modified if the user doesn't exist in the database or there is\n    not enough memory to perform the query.\n\n    This function performs several memory allocations.\n\n    Returns:\n    $(D inputPath) with the tilde expanded, or just $(D inputPath)\n    if it could not be expanded.\n    For Windows, $(D expandTilde) merely returns its argument $(D inputPath).\n\n    Examples:\n    -----\n    void processFile(string path)\n    {\n        // Allow calling this function with paths such as ~/foo\n        auto fullPath = expandTilde(path);\n        ...\n    }\n    -----\n",
    "line" : 2630,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "inputPath",
      "deco" : "Aya"
     }
    ],
    "endline" : 2762
   },
   {
    "name" : "__unittestL2766_1342",
    "kind" : "function",
    "line" : 2766,
    "endline" : 2804
   }
  ]
 },
 {
  "name" : "std.process",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/process.d",
  "comment" : "\nFunctions for starting and interacting with other processes, and for\nworking with the current _process' execution environment.\n\nProcess_handling:\n$(UL $(LI\n    $(LREF spawnProcess) spawns a new _process, optionally assigning it an\n    arbitrary set of standard input, output, and error streams.\n    The function returns immediately, leaving the child _process to execute\n    in parallel with its parent.  All other functions in this module that\n    spawn processes are built around $(D spawnProcess).)\n$(LI\n    $(LREF wait) makes the parent _process wait for a child _process to\n    terminate.  In general one should always do this, to avoid\n    child processes becoming \"zombies\" when the parent _process exits.\n    Scope guards are perfect for this – see the $(LREF spawnProcess)\n    documentation for examples.  $(LREF tryWait) is similar to $(D wait),\n    but does not block if the _process has not yet terminated.)\n$(LI\n    $(LREF pipeProcess) also spawns a child _process which runs\n    in parallel with its parent.  However, instead of taking\n    arbitrary streams, it automatically creates a set of\n    pipes that allow the parent to communicate with the child\n    through the child's standard input, output, and/or error streams.\n    This function corresponds roughly to C's $(D popen) function.)\n$(LI\n    $(LREF execute) starts a new _process and waits for it\n    to complete before returning.  Additionally, it captures\n    the _process' standard output and error streams and returns\n    the output of these as a string.)\n$(LI\n    $(LREF spawnShell), $(LREF pipeShell) and $(LREF executeShell) work like\n    $(D spawnProcess), $(D pipeProcess) and $(D execute), respectively,\n    except that they take a single command string and run it through\n    the current user's default command interpreter.\n    $(D executeShell) corresponds roughly to C's $(D system) function.)\n$(LI\n    $(LREF kill) attempts to terminate a running _process.)\n)\n\nThe following table compactly summarises the different _process creation\nfunctions and how they relate to each other:\n$(BOOKTABLE,\n    $(TR $(TH )\n         $(TH Runs program directly)\n         $(TH Runs shell command))\n    $(TR $(TD Low-level _process creation)\n         $(TD $(LREF spawnProcess))\n         $(TD $(LREF spawnShell)))\n    $(TR $(TD Automatic input/output redirection using pipes)\n         $(TD $(LREF pipeProcess))\n         $(TD $(LREF pipeShell)))\n    $(TR $(TD Execute and wait for completion, collect output)\n         $(TD $(LREF execute))\n         $(TD $(LREF executeShell)))\n)\n\nOther_functionality:\n$(UL\n$(LI\n    $(LREF pipe) is used to create unidirectional pipes.)\n$(LI\n    $(LREF environment) is an interface through which the current _process'\n    environment variables can be read and manipulated.)\n$(LI\n    $(LREF escapeShellCommand) and $(LREF escapeShellFileName) are useful\n    for constructing shell command lines in a portable way.)\n)\n\nAuthors:\n    $(LINK2 https://github.com/kyllingstad, Lars Tandle Kyllingstad),\n    $(LINK2 https://github.com/schveiguy, Steven Schveighoffer),\n    $(WEB thecybershadow.net, Vladimir Panteleev)\nCopyright:\n    Copyright (c) 2013, the authors. All rights reserved.\nSource:\n    $(PHOBOSSRC std/_process.d)\nMacros:\n    WIKI=Phobos/StdProcess\n    OBJECTREF=$(D $(LINK2 object.html#$0,$0))\n    LREF=$(D $(LINK2 #.$0,$0))\n",
  "members" : [
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 89,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 90,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.stdio",
    "kind" : "import",
    "line" : 91,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 92,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.wait",
    "kind" : "import",
    "line" : 93,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 102,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 104,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 105,
    "protection" : "private"
   },
   {
    "name" : "std.path",
    "kind" : "import",
    "line" : 106,
    "protection" : "private"
   },
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 107,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 108,
    "protection" : "private"
   },
   {
    "name" : "std.internal.processinit",
    "kind" : "import",
    "line" : 109,
    "protection" : "private"
   },
   {
    "name" : "environ",
    "kind" : "variable",
    "protection" : "private",
    "line" : 183,
    "storageClass" : [
     "extern",
     "const",
     "__gshared"
    ],
    "deco" : "xPPa",
    "originalType" : "char**"
   },
   {
    "name" : "spawnProcess",
    "kind" : "function",
    "comment" : "\nSpawns a new _process, optionally assigning it an arbitrary set of standard\ninput, output, and error streams.\n\nThe function returns immediately, leaving the child _process to execute\nin parallel with its parent.  It is recommended to always call $(LREF wait)\non the returned $(LREF Pid), as detailed in the documentation for $(D wait).\n\nCommand_line:\nThere are four overloads of this function.  The first two take an array\nof strings, $(D args), which should contain the program name as the\nzeroth element and any command-line arguments in subsequent elements.\nThe third and fourth versions are included for convenience, and may be\nused when there are no command-line arguments.  They take a single string,\n$(D program), which specifies the program name.\n\nUnless a directory is specified in $(D args[0]) or $(D program),\n$(D spawnProcess) will search for the program in a platform-dependent\nmanner.  On POSIX systems, it will look for the executable in the\ndirectories listed in the PATH environment variable, in the order\nthey are listed.  On Windows, it will search for the executable in\nthe following sequence:\n$(OL\n    $(LI The directory from which the application loaded.)\n    $(LI The current directory for the parent process.)\n    $(LI The 32-bit Windows system directory.)\n    $(LI The 16-bit Windows system directory.)\n    $(LI The Windows directory.)\n    $(LI The directories listed in the PATH environment variable.)\n)\n---\n// Run an executable called \"prog\" located in the current working\n// directory:\nauto pid = spawnProcess(\"./prog\");\nscope(exit) wait(pid);\n// We can do something else while the program runs.  The scope guard\n// ensures that the process is waited for at the end of the scope.\n...\n\n// Run DMD on the file \"myprog.d\", specifying a few compiler switches:\nauto dmdPid = spawnProcess([\"dmd\", \"-O\", \"-release\", \"-inline\", \"myprog.d\" ]);\nif (wait(dmdPid) != 0)\n    writeln(\"Compilation failed!\");\n---\n\nEnvironment_variables:\nBy default, the child process inherits the environment of the parent\nprocess, along with any additional variables specified in the $(D env)\nparameter.  If the same variable exists in both the parent's environment\nand in $(D env), the latter takes precedence.\n\nIf the $(LREF Config.newEnv) flag is set in $(D config), the child\nprocess will $(I not) inherit the parent's environment.  Its entire\nenvironment will then be determined by $(D env).\n---\nwait(spawnProcess(\"myapp\", [\"foo\" : \"bar\"], Config.newEnv));\n---\n\nStandard_streams:\nThe optional arguments $(D stdin), $(D stdout) and $(D stderr) may\nbe used to assign arbitrary $(XREF stdio,File) objects as the standard\ninput, output and error streams, respectively, of the child process.  The\nformer must be opened for reading, while the latter two must be opened for\nwriting.  The default is for the child process to inherit the standard\nstreams of its parent.\n---\n// Run DMD on the file myprog.d, logging any error messages to a\n// file named errors.log.\nauto logFile = File(\"errors.log\", \"w\");\nauto pid = spawnProcess([\"dmd\", \"myprog.d\"],\n                        std.stdio.stdin,\n                        std.stdio.stdout,\n                        logFile);\nif (wait(pid) != 0)\n    writeln(\"Compilation failed. See errors.log for details.\");\n---\n\nNote that if you pass a $(D File) object that is $(I not)\none of the standard input/output/error streams of the parent process,\nthat stream will by default be $(I closed) in the parent process when\nthis function returns.  See the $(LREF Config) documentation below for\ninformation about how to disable this behaviour.\n\nBeware of buffering issues when passing $(D File) objects to\n$(D spawnProcess).  The child process will inherit the low-level raw\nread/write offset associated with the underlying file descriptor, but\nit will not be aware of any buffered data.  In cases where this matters\n(e.g. when a file should be aligned before being passed on to the\nchild process), it may be a good idea to use unbuffered streams, or at\nleast ensure all relevant buffers are flushed.\n\nParams:\nargs    = An array which contains the program name as the zeroth element\n          and any command-line arguments in the following elements.\nprogram = The program name, $(I without) command-line arguments.\nstdin   = The standard input stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for reading.\n          By default the child process inherits the parent's input\n          stream.\nstdout  = The standard output stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for writing.\n          By default the child process inherits the parent's output stream.\nstderr  = The standard error stream of the child process.\n          This can be any $(XREF stdio,File) that is opened for writing.\n          By default the child process inherits the parent's error stream.\nenv     = Additional environment variables for the child process.\nconfig  = Flags that control process creation. See $(LREF Config)\n          for an overview of available flags.\n\nReturns:\nA $(LREF Pid) object that corresponds to the spawned process.\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to pass one of the streams\n    to the child process (Windows only).$(BR)\n$(CXREF exception,RangeError) if $(D args) is empty.\n",
    "line" : 314,
    "deco" : "FNexAAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[][] args, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "xAAa"
     },
     {
      "name" : "stdin",
      "deco" : "S3std5stdio4File",
      "default" : "stdin"
     },
     {
      "name" : "stdout",
      "deco" : "S3std5stdio4File",
      "default" : "stdout"
     },
     {
      "name" : "stderr",
      "deco" : "S3std5stdio4File",
      "default" : "stderr"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 325
   },
   {
    "name" : "spawnProcess",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 328,
    "deco" : "FNexAAaxHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[][] args, const string[string] env, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "xAAa"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 339
   },
   {
    "name" : "spawnProcess",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 342,
    "deco" : "FNexAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[] program, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "program",
      "deco" : "xAa"
     },
     {
      "name" : "stdin",
      "deco" : "S3std5stdio4File",
      "default" : "stdin"
     },
     {
      "name" : "stdout",
      "deco" : "S3std5stdio4File",
      "default" : "stdout"
     },
     {
      "name" : "stderr",
      "deco" : "S3std5stdio4File",
      "default" : "stderr"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 352
   },
   {
    "name" : "spawnProcess",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 355,
    "deco" : "FNexAaxHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[] program, const string[string] env, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "program",
      "deco" : "xAa"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 361
   },
   {
    "name" : "spawnProcessImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 370,
    "deco" : "FNexAAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[][] args, File stdin, File stdout, File stderr, const string[string] env, Config config)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "xAAa"
     },
     {
      "name" : "stdin",
      "deco" : "S3std5stdio4File"
     },
     {
      "name" : "stdout",
      "deco" : "S3std5stdio4File"
     },
     {
      "name" : "stderr",
      "deco" : "S3std5stdio4File"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config"
     }
    ],
    "endline" : 462
   },
   {
    "name" : "createEnv",
    "kind" : "function",
    "protection" : "private",
    "line" : 554,
    "deco" : "FxHAyaAyabZPxPa",
    "originalType" : "const(char*)*(const string[string] childEnv, bool mergeWithParentEnv)",
    "parameters" : [
     {
      "name" : "childEnv",
      "deco" : "xHAyaAya"
     },
     {
      "name" : "mergeWithParentEnv",
      "deco" : "b"
     }
    ],
    "endline" : 583
   },
   {
    "name" : "__unittestL585_1343",
    "kind" : "function",
    "line" : 585,
    "endline" : 614
   },
   {
    "name" : "searchPathFor",
    "kind" : "function",
    "protection" : "private",
    "line" : 659,
    "deco" : "FNexAaZAya",
    "originalType" : "@trusted string(in char[] executable)",
    "parameters" : [
     {
      "name" : "executable",
      "deco" : "xAa"
     }
    ],
    "endline" : 672
   },
   {
    "name" : "isExecutable",
    "kind" : "function",
    "protection" : "private",
    "line" : 677,
    "deco" : "FNexAaZb",
    "originalType" : "@trusted bool(in char[] path)",
    "parameters" : [
     {
      "name" : "path",
      "deco" : "xAa"
     }
    ],
    "endline" : 680
   },
   {
    "name" : "__unittestL682_1345",
    "kind" : "function",
    "line" : 682,
    "endline" : 693
   },
   {
    "name" : "setCLOEXEC",
    "kind" : "function",
    "protection" : "private",
    "line" : 694,
    "deco" : "FibZv",
    "parameters" : [
     {
      "name" : "fd",
      "deco" : "i"
     },
     {
      "name" : "on",
      "deco" : "b"
     }
    ],
    "endline" : 709
   },
   {
    "name" : "__unittestL711_1346",
    "kind" : "function",
    "line" : 711,
    "endline" : 728
   },
   {
    "name" : "__unittestL728_1347",
    "kind" : "function",
    "line" : 728,
    "endline" : 773
   },
   {
    "name" : "__unittestL773_1348",
    "kind" : "function",
    "line" : 773,
    "endline" : 814
   },
   {
    "name" : "__unittestL814_1349",
    "kind" : "function",
    "line" : 814,
    "endline" : 846
   },
   {
    "name" : "spawnShell",
    "kind" : "function",
    "comment" : "\nA variation on $(LREF spawnProcess) that runs the given _command through\nthe current user's preferred _command interpreter (aka. shell).\n\nThe string $(D command) is passed verbatim to the shell, and is therefore\nsubject to its rules about _command structure, argument/filename quoting\nand escaping of special characters.\nThe path to the shell executable is determined by the $(LREF userShell)\nfunction.\n\nIn all other respects this function works just like $(D spawnProcess).\nPlease refer to the $(LREF spawnProcess) documentation for descriptions\nof the other function parameters, the return value and any exceptions\nthat may be thrown.\n---\n// Run the command/program \"foo\" on the file named \"my file.txt\", and\n// redirect its output into foo.log.\nauto pid = spawnShell(`foo \"my file.txt\" > foo.log`);\nwait(pid);\n---\n\nSee_also:\n$(LREF escapeShellCommand), which may be helpful in constructing a\nproperly quoted and escaped shell _command line for the current platform.\n",
    "line" : 846,
    "deco" : "FNexAaS3std5stdio4FileS3std5stdio4FileS3std5stdio4FilexHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[] command, File stdin = std.stdio.stdin, File stdout = std.stdio.stdout, File stderr = std.stdio.stderr, const string[string] env = null, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "xAa"
     },
     {
      "name" : "stdin",
      "deco" : "S3std5stdio4File",
      "default" : "stdin"
     },
     {
      "name" : "stdout",
      "deco" : "S3std5stdio4File",
      "default" : "stdout"
     },
     {
      "name" : "stderr",
      "deco" : "S3std5stdio4File",
      "default" : "stderr"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 867
   },
   {
    "name" : "spawnShell",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 870,
    "deco" : "FNexAaxHAyaAyaE3std7process6ConfigZC3std7process3Pid",
    "originalType" : "@trusted Pid(in char[] command, const string[string] env, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "xAa"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 881
   },
   {
    "name" : "__unittestL883_1350",
    "kind" : "function",
    "line" : 883,
    "endline" : 926
   },
   {
    "name" : "Config",
    "kind" : "enum",
    "comment" : "\nFlags that control the behaviour of $(LREF spawnProcess) and\n$(LREF spawnShell).\n\nUse bitwise OR to combine flags.\n\nExample:\n---\nauto logFile = File(\"myapp_error.log\", \"w\");\n\n// Start program, suppressing the console window (Windows only),\n// redirect its error stream to logFile, and leave logFile open\n// in the parent process as well.\nauto pid = spawnProcess(\"myapp\", stdin, stdout, logFile,\n                        Config.retainStderr | Config.suppressConsole);\nscope(exit)\n{\n    auto exitCode = wait(pid);\n    logFile.writeln(\"myapp exited with code \", exitCode);\n    logFile.close();\n}\n---\n",
    "line" : 927,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "none",
      "kind" : "enum member",
      "line" : 928
     },
     {
      "name" : "newEnv",
      "kind" : "enum member",
      "comment" : "\n    By default, the child process inherits the parent's environment,\n    and any environment variables passed to $(LREF spawnProcess) will\n    be added to it.  If this flag is set, the only variables in the\n    child process' environment will be those given to spawnProcess.\n    \n",
      "line" : 936
     },
     {
      "name" : "retainStdin",
      "kind" : "enum member",
      "comment" : "\n    Unless the child process inherits the standard input/output/error\n    streams of its parent, one almost always wants the streams closed\n    in the parent when $(LREF spawnProcess) returns.  Therefore, by\n    default, this is done.  If this is not desirable, pass any of these\n    options to spawnProcess.\n    \n",
      "line" : 945
     },
     {
      "name" : "retainStdout",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 946
     },
     {
      "name" : "retainStderr",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 947
     },
     {
      "name" : "suppressConsole",
      "kind" : "enum member",
      "comment" : "\n    On Windows, if the child process is a console application, this\n    flag will prevent the creation of a console window.  Otherwise,\n    it will be ignored. On POSIX, $(D suppressConsole) has no effect.\n    \n",
      "line" : 954
     },
     {
      "name" : "inheritFDs",
      "kind" : "enum member",
      "comment" : "\n    On POSIX, open $(LINK2 http://en.wikipedia.org/wiki/File_descriptor,file descriptors)\n    are by default inherited by the child process.  As this may lead\n    to subtle bugs when pipes or multiple threads are involved,\n    $(LREF spawnProcess) ensures that all file descriptors except the\n    ones that correspond to standard input/output/error are closed\n    in the child process when it starts.  Use $(D inheritFDs) to prevent\n    this.\n\n    On Windows, this option has no effect, and any handles which have been\n    explicitly marked as inheritable will always be inherited by the child\n    process.\n    \n",
      "line" : 969
     }
    ]
   },
   {
    "name" : "Pid",
    "kind" : "class",
    "comment" : " A handle that corresponds to a spawned process.\n",
    "line" : 975,
    "members" : [
     {
      "name" : "processID",
      "kind" : "function",
      "comment" : "\n    The process ID number.\n\n    This is a number that uniquely identifies the process on the operating\n    system, for at least as long as the process is running.  Once $(LREF wait)\n    has been called on the $(LREF Pid), this method will return an\n    invalid process ID.\n    \n",
      "line" : 984,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdNfZi",
      "originalType" : "const pure nothrow @safe int()",
      "endline" : 987
     },
     {
      "name" : "osHandle",
      "kind" : "function",
      "comment" : "\n    An operating system handle to the process.\n\n    This handle is used to specify the process in OS-specific APIs.\n    On POSIX, this function returns a $(D core.sys.posix.sys.types.pid_t)\n    with the same value as $(LREF Pid.processID), while on Windows it returns\n    a $(D core.sys.windows.windows.HANDLE).\n\n    Once $(LREF wait) has been called on the $(LREF Pid), this method\n    will return an invalid handle.\n    \n",
      "line" : 1007,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNaNbNdNfZi",
      "originalType" : "pure nothrow @safe pid_t()",
      "endline" : 1010
     },
     {
      "name" : "performWait",
      "kind" : "function",
      "protection" : "private",
      "line" : 1026,
      "deco" : "FNebZi",
      "parameters" : [
       {
        "name" : "block",
        "deco" : "b"
       }
      ],
      "endline" : 1071
     },
     {
      "name" : "invalid",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1104,
      "storageClass" : [
       "enum"
      ],
      "deco" : "i",
      "init" : "-1"
     },
     {
      "name" : "terminated",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1104,
      "storageClass" : [
       "enum"
      ],
      "deco" : "i",
      "init" : "-2"
     },
     {
      "name" : "_processID",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1108,
      "deco" : "i",
      "init" : "-1",
      "offset" : 16
     },
     {
      "name" : "_exitCode",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1112,
      "deco" : "i",
      "offset" : 20
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 1127,
      "deco" : "FNaNbNfiZC3std7process3Pid",
      "originalType" : "pure nothrow @safe (int id)",
      "parameters" : [
       {
        "name" : "id",
        "deco" : "i"
       }
      ],
      "endline" : 1130
     }
    ]
   },
   {
    "name" : "wait",
    "kind" : "function",
    "comment" : "\nWaits for the process associated with $(D pid) to terminate, and returns\nits exit status.\n\nIn general one should always _wait for child processes to terminate\nbefore exiting the parent process.  Otherwise, they may become\n\"$(WEB en.wikipedia.org/wiki/Zombie_process,zombies)\" – processes\nthat are defunct, yet still occupy a slot in the OS process table.\n\nIf the process has already terminated, this function returns directly.\nThe exit code is cached, so that if wait() is called multiple times on\nthe same $(LREF Pid) it will always return the same value.\n\nPOSIX_specific:\nIf the process is terminated by a signal, this function returns a\nnegative number whose absolute value is the signal number.\nSince POSIX restricts normal exit codes to the range 0-255, a\nnegative return value will always indicate termination by signal.\nSignal codes are defined in the $(D core.sys.posix.signal) module\n(which corresponds to the $(D signal.h) POSIX header).\n\nThrows:\n$(LREF ProcessException) on failure.\n\nExamples:\nSee the $(LREF spawnProcess) documentation.\n\nSee_also:\n$(LREF tryWait), for a non-blocking function.\n",
    "line" : 1165,
    "deco" : "FNfC3std7process3PidZi",
    "parameters" : [
     {
      "name" : "pid",
      "deco" : "C3std7process3Pid"
     }
    ],
    "endline" : 1169
   },
   {
    "name" : "__unittestL1172_1351",
    "kind" : "function",
    "line" : 1172,
    "endline" : 1237
   },
   {
    "name" : "tryWait",
    "kind" : "function",
    "comment" : "\nA non-blocking version of $(LREF wait).\n\nIf the process associated with $(D pid) has already terminated,\n$(D tryWait) has the exact same effect as $(D wait).\nIn this case, it returns a struct where the $(D terminated) field\nis set to $(D true) and the $(D status) field has the same\ninterpretation as the return value of $(D wait).\n\nIf the process has $(I not) yet terminated, this function differs\nfrom $(D wait) in that does not wait for this to happen, but instead\nreturns immediately.  The $(D terminated) field of the returned\ntuple will then be set to $(D false), while the $(D status) field\nwill always be 0 (zero).  $(D wait) or $(D tryWait) should then be\ncalled again on the same $(D Pid) at some later time; not only to\nget the exit code, but also to avoid the process becoming a \"zombie\"\nwhen it finally terminates.  (See $(LREF wait) for details).\n\nReturns:\nA $(D struct) which contains the fields $(D bool terminated)\nand $(D int status).  (This will most likely change to become a\n$(D std.typecons.Tuple!(bool,\"terminated\",int,\"status\")) in the future,\nbut a compiler bug currently prevents this.)\n\nThrows:\n$(LREF ProcessException) on failure.\n\nExample:\n---\nauto pid = spawnProcess(\"dmd myapp.d\");\nscope(exit) wait(pid);\n...\nauto dmd = tryWait(pid);\nif (dmd.terminated)\n{\n    if (dmd.status == 0) writeln(\"Compilation succeeded!\");\n    else writeln(\"Compilation failed\");\n}\nelse writeln(\"Still compiling...\");\n...\n---\nNote that in this example, the first $(D wait) call will have no\neffect if the process has already terminated by the time $(D tryWait)\nis called.  In the opposite case, however, the $(D scope) statement\nensures that we always wait for the process if it hasn't terminated\nby the time we reach the end of the scope.\n",
    "line" : 1238,
    "storageClass" : [
     "auto"
    ],
    "deco" : "FNfC3std7process3PidZS3std7process7tryWaitFNfC3std7process3PidZ13TryWaitResult",
    "originalType" : "@safe (Pid pid)",
    "parameters" : [
     {
      "name" : "pid",
      "deco" : "C3std7process3Pid"
     }
    ],
    "endline" : 1247
   },
   {
    "name" : "kill",
    "kind" : "function",
    "comment" : "\nAttempts to terminate the process associated with $(D pid).\n\nThe effect of this function, as well as the meaning of $(D codeOrSignal),\nis highly platform dependent.  Details are given below.  Common to all\nplatforms is that this function only $(I initiates) termination of the process,\nand returns immediately.  It does not wait for the process to end,\nnor does it guarantee that the process does in fact get terminated.\n\nAlways call $(LREF wait) to wait for a process to complete, even if $(D kill)\nhas been called on it.\n\nWindows_specific:\nThe process will be\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/ms686714%28v=vs.100%29.aspx,\nforcefully and abruptly terminated).  If $(D codeOrSignal) is specified, it\nmust be a nonnegative number which will be used as the exit code of the process.\nIf not, the process wil exit with code 1.  Do not use $(D codeOrSignal = 259),\nas this is a special value (aka. $(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/ms683189.aspx,STILL_ACTIVE))\nused by Windows to signal that a process has in fact $(I not) terminated yet.\n---\nauto pid = spawnProcess(\"some_app\");\nkill(pid, 10);\nassert (wait(pid) == 10);\n---\n$(RED Warning:) The mechanisms for process termination are\n$(LINK2 http://blogs.msdn.com/b/oldnewthing/archive/2007/05/03/2383346.aspx,\nincredibly badly specified) in the Windows API.  This function may therefore\nproduce unexpected results, and should be used with the utmost care.\n\nPOSIX_specific:\nA $(LINK2 http://en.wikipedia.org/wiki/Unix_signal,signal) will be sent to\nthe process, whose value is given by $(D codeOrSignal).  Depending on the\nsignal sent, this may or may not terminate the process.  Symbolic constants\nfor various $(LINK2 http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals,\nPOSIX signals) are defined in $(D core.sys.posix.signal), which corresponds to the\n$(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html,\n$(D signal.h) POSIX header).  If $(D codeOrSignal) is omitted, the\n$(D SIGTERM) signal will be sent.  (This matches the behaviour of the\n$(LINK2 http://pubs.opengroup.org/onlinepubs/9699919799/utilities/kill.html,\n$(D _kill)) shell command.)\n---\nimport core.sys.posix.signal: SIGKILL;\nauto pid = spawnProcess(\"some_app\");\nkill(pid, SIGKILL);\nassert (wait(pid) == -SIGKILL); // Negative return value on POSIX!\n---\n\nThrows:\n$(LREF ProcessException) on error (e.g. if codeOrSignal is invalid).\n    Note that failure to terminate the process is considered a \"normal\"\n    outcome, not an error.$(BR)\n",
    "line" : 1304,
    "deco" : "FC3std7process3PidZv",
    "parameters" : [
     {
      "name" : "pid",
      "deco" : "C3std7process3Pid"
     }
    ],
    "endline" : 1312
   },
   {
    "name" : "kill",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1315,
    "deco" : "FC3std7process3PidiZv",
    "parameters" : [
     {
      "name" : "pid",
      "deco" : "C3std7process3Pid"
     },
     {
      "name" : "codeOrSignal",
      "deco" : "i"
     }
    ],
    "endline" : 1336
   },
   {
    "name" : "__unittestL1338_1352",
    "kind" : "function",
    "line" : 1338,
    "endline" : 1406
   },
   {
    "name" : "pipe",
    "kind" : "function",
    "comment" : "\nCreates a unidirectional _pipe.\n\nData is written to one end of the _pipe and read from the other.\n---\nauto p = pipe();\np.writeEnd.writeln(\"Hello World\");\nassert (p.readEnd.readln().chomp() == \"Hello World\");\n---\nPipes can, for example, be used for interprocess communication\nby spawning a new process and passing one end of the _pipe to\nthe child, while the parent uses the other end.\n(See also $(LREF pipeProcess) and $(LREF pipeShell) for an easier\nway of doing this.)\n---\n// Use cURL to download the dlang.org front page, pipe its\n// output to grep to extract a list of links to ZIP files,\n// and write the list to the file \"D downloads.txt\":\nauto p = pipe();\nauto outFile = File(\"D downloads.txt\", \"w\");\nauto cpid = spawnProcess([\"curl\", \"http://dlang.org/download.html\"],\n                         std.stdio.stdin, p.writeEnd);\nscope(exit) wait(cpid);\nauto gpid = spawnProcess([\"grep\", \"-o\", `http://\\S*\\.zip`],\n                         p.readEnd, outFile);\nscope(exit) wait(gpid);\n---\n\nReturns:\nA $(LREF Pipe) object that corresponds to the created _pipe.\n\nThrows:\n$(XREF stdio,StdioException) on failure.\n",
    "line" : 1407,
    "deco" : "FNeZS3std7process4Pipe",
    "endline" : 1422
   },
   {
    "name" : "Pipe",
    "kind" : "struct",
    "comment" : " An interface to a pipe created by the $(LREF pipe) function.\n",
    "line" : 1504,
    "members" : [
     {
      "name" : "readEnd",
      "kind" : "function",
      "comment" : " The read end of the pipe.\n",
      "line" : 1506,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdNeZS3std5stdio4File",
      "originalType" : "@trusted File()",
      "endline" : 1506
     },
     {
      "name" : "writeEnd",
      "kind" : "function",
      "comment" : " The write end of the pipe.\n",
      "line" : 1510,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdNeZS3std5stdio4File",
      "originalType" : "@trusted File()",
      "endline" : 1510
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : "\n    Closes both ends of the pipe.\n\n    Normally it is not necessary to do this manually, as $(XREF stdio,File)\n    objects are automatically closed when there are no more references\n    to them.\n\n    Note that if either end of the pipe has been passed to a child process,\n    it will only be closed in the parent process.  (What happens in the\n    child process is platform dependent.)\n    \n",
      "line" : 1524,
      "deco" : "FNeZv",
      "endline" : 1528
     },
     {
      "name" : "_read",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1531,
      "deco" : "S3std5stdio4File",
      "offset" : 0
     },
     {
      "name" : "_write",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1531,
      "deco" : "S3std5stdio4File",
      "offset" : 24
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 1504,
      "deco" : "FZv"
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 1504,
      "deco" : "xFKxS3std7process4PipeZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std7process4Pipe",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 1504,
      "deco" : "FNcS3std7process4PipeZS3std7process4Pipe",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std7process4Pipe"
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std7process4PipeKxS3std7process4PipeZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std7process4Pipe",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std7process4Pipe",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1534_1353",
    "kind" : "function",
    "line" : 1534,
    "endline" : 1604
   },
   {
    "name" : "pipeProcess",
    "kind" : "function",
    "comment" : "\nStarts a new process, creating pipes to redirect its standard\ninput, output and/or error streams.\n\n$(D pipeProcess) and $(D pipeShell) are convenient wrappers around\n$(LREF spawnProcess) and $(LREF spawnShell), respectively, and\nautomate the task of redirecting one or more of the child process'\nstandard streams through pipes.  Like the functions they wrap,\nthese functions return immediately, leaving the child process to\nexecute in parallel with the invoking process.  It is recommended\nto always call $(LREF wait) on the returned $(LREF ProcessPipes.pid),\nas detailed in the documentation for $(D wait).\n\nThe $(D args)/$(D program)/$(D command), $(D env) and $(D config)\nparameters are forwarded straight to the underlying spawn functions,\nand we refer to their documentation for details.\n\nParams:\nargs     = An array which contains the program name as the zeroth element\n           and any command-line arguments in the following elements.\n           (See $(LREF spawnProcess) for details.)\nprogram  = The program name, $(I without) command-line arguments.\n           (See $(LREF spawnProcess) for details.)\ncommand  = A shell command which is passed verbatim to the command\n           interpreter.  (See $(LREF spawnShell) for details.)\nredirect = Flags that determine which streams are redirected, and\n           how.  See $(LREF Redirect) for an overview of available\n           flags.\nenv      = Additional environment variables for the child process.\n           (See $(LREF spawnProcess) for details.)\nconfig   = Flags that control process creation. See $(LREF Config)\n           for an overview of available flags, and note that the\n           $(D retainStd...) flags have no effect in this function.\n\nReturns:\nA $(LREF ProcessPipes) object which contains $(XREF stdio,File)\nhandles that communicate with the redirected streams of the child\nprocess, along with a $(LREF Pid) object that corresponds to the\nspawned process.\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to redirect any of the streams.$(BR)\n\nExample:\n---\nauto pipes = pipeProcess(\"my_application\", Redirect.stdout | Redirect.stderr);\nscope(exit) wait(pipes.pid);\n\n// Store lines of output.\nstring[] output;\nforeach (line; pipes.stdout.byLine) output ~= line.idup;\n\n// Store lines of errors.\nstring[] errors;\nforeach (line; pipes.stderr.byLine) errors ~= line.idup;\n---\n",
    "line" : 1604,
    "deco" : "FNeAAyaE3std7process8RedirectxHAyaAyaE3std7process6ConfigZS3std7process12ProcessPipes",
    "originalType" : "@trusted ProcessPipes(string[] args, Redirect redirectFlags = Redirect.all, const string[string] env = null, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "AAya"
     },
     {
      "name" : "redirectFlags",
      "deco" : "E3std7process8Redirect",
      "default" : "cast(Redirect)7"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 1611
   },
   {
    "name" : "pipeProcess",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1614,
    "deco" : "FNeAyaE3std7process8RedirectxHAyaAyaE3std7process6ConfigZS3std7process12ProcessPipes",
    "originalType" : "@trusted ProcessPipes(string program, Redirect redirectFlags = Redirect.all, const string[string] env = null, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "program",
      "deco" : "Aya"
     },
     {
      "name" : "redirectFlags",
      "deco" : "E3std7process8Redirect",
      "default" : "cast(Redirect)7"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 1621
   },
   {
    "name" : "pipeShell",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1624,
    "deco" : "FNfAyaE3std7process8RedirectxHAyaAyaE3std7process6ConfigZS3std7process12ProcessPipes",
    "originalType" : "@safe ProcessPipes(string command, Redirect redirectFlags = Redirect.all, const string[string] env = null, Config config = Config.none)",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "Aya"
     },
     {
      "name" : "redirectFlags",
      "deco" : "E3std7process8Redirect",
      "default" : "cast(Redirect)7"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     }
    ],
    "endline" : 1631
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1634,
    "name" : "pipeProcessImpl",
    "parameters" : [
     {
      "name" : "spawnFunc",
      "kind" : "alias"
     },
     {
      "name" : "Cmd",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "pipeProcessImpl",
      "kind" : "function",
      "line" : 1634,
      "type" : "@trusted ProcessPipes(Cmd command, Redirect redirectFlags, const string[string] env = null, Config config = Config.none)",
      "parameters" : [
       {
        "name" : "command",
        "type" : "Cmd"
       },
       {
        "name" : "redirectFlags",
        "type" : "Redirect"
       },
       {
        "name" : "env",
        "type" : "string[string]",
        "storageClass" : [
         "const"
        ],
        "default" : "null"
       },
       {
        "name" : "config",
        "type" : "Config",
        "default" : "Config.none"
       }
      ],
      "endline" : 1707
     }
    ]
   },
   {
    "name" : "Redirect",
    "kind" : "enum",
    "comment" : "\nFlags that can be passed to $(LREF pipeProcess) and $(LREF pipeShell)\nto specify which of the child process' standard streams are redirected.\nUse bitwise OR to combine flags.\n",
    "line" : 1716,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "stdin",
      "kind" : "enum member",
      "comment" : " Redirect the standard input, output or error streams, respectively.\n",
      "line" : 1718
     },
     {
      "name" : "stdout",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1719
     },
     {
      "name" : "stderr",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1720
     },
     {
      "name" : "all",
      "kind" : "enum member",
      "comment" : "\n    Redirect _all three streams.  This is equivalent to\n    $(D Redirect.stdin | Redirect.stdout | Redirect.stderr).\n    \n",
      "line" : 1726
     },
     {
      "name" : "stderrToStdout",
      "kind" : "enum member",
      "comment" : "\n    Redirect the standard error stream into the standard output stream.\n    This can not be combined with $(D Redirect.stderr).\n    \n",
      "line" : 1732
     },
     {
      "name" : "stdoutToStderr",
      "kind" : "enum member",
      "comment" : "\n    Redirect the standard output stream into the standard error stream.\n    This can not be combined with $(D Redirect.stdout).\n    \n",
      "line" : 1738
     }
    ]
   },
   {
    "name" : "__unittestL1741_1354",
    "kind" : "function",
    "line" : 1741,
    "endline" : 1797
   },
   {
    "name" : "__unittestL1797_1355",
    "kind" : "function",
    "line" : 1797,
    "endline" : 1820
   },
   {
    "name" : "ProcessPipes",
    "kind" : "struct",
    "comment" : "\nObject which contains $(XREF stdio,File) handles that allow communication\nwith a child process through its standard streams.\n",
    "line" : 1821,
    "members" : [
     {
      "name" : "pid",
      "kind" : "function",
      "comment" : " The $(LREF Pid) of the child process.\n",
      "line" : 1823,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNbNdNfZC3std7process3Pid",
      "originalType" : "nothrow @safe Pid()",
      "endline" : 1827
     },
     {
      "name" : "stdin",
      "kind" : "function",
      "comment" : "\n    An $(XREF stdio,File) that allows writing to the child process'\n    standard input stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard input stream hasn't\n    been redirected.\n    \n",
      "line" : 1837,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdNeZS3std5stdio4File",
      "originalType" : "@trusted File()",
      "endline" : 1843
     },
     {
      "name" : "stdout",
      "kind" : "function",
      "comment" : "\n    An $(XREF stdio,File) that allows reading from the child process'\n    standard output stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard output stream hasn't\n    been redirected.\n    \n",
      "line" : 1853,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdNeZS3std5stdio4File",
      "originalType" : "@trusted File()",
      "endline" : 1859
     },
     {
      "name" : "stderr",
      "kind" : "function",
      "comment" : "\n    An $(XREF stdio,File) that allows reading from the child process'\n    standard error stream.\n\n    Throws:\n    $(OBJECTREF Error) if the child process' standard error stream hasn't\n    been redirected.\n    \n",
      "line" : 1869,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdNeZS3std5stdio4File",
      "originalType" : "@trusted File()",
      "endline" : 1875
     },
     {
      "name" : "_redirectFlags",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1878,
      "deco" : "E3std7process8Redirect",
      "offset" : 0
     },
     {
      "name" : "_pid",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1879,
      "deco" : "C3std7process3Pid",
      "originalType" : "Pid",
      "offset" : 8
     },
     {
      "name" : "_stdin",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1880,
      "deco" : "S3std5stdio4File",
      "offset" : 16
     },
     {
      "name" : "_stdout",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1880,
      "deco" : "S3std5stdio4File",
      "offset" : 40
     },
     {
      "name" : "_stderr",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1880,
      "deco" : "S3std5stdio4File",
      "offset" : 64
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 1821,
      "deco" : "FZv"
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 1821,
      "deco" : "xFKxS3std7process12ProcessPipesZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std7process12ProcessPipes",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 1821,
      "deco" : "FNcS3std7process12ProcessPipesZS3std7process12ProcessPipes",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std7process12ProcessPipes"
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std7process12ProcessPipesKxS3std7process12ProcessPipesZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std7process12ProcessPipes",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std7process12ProcessPipes",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "execute",
    "kind" : "function",
    "comment" : "\nExecutes the given program or shell command and returns its exit\ncode and output.\n\n$(D execute) and $(D executeShell) start a new process using\n$(LREF spawnProcess) and $(LREF spawnShell), respectively, and wait\nfor the process to complete before returning.  The functions capture\nwhat the child process prints to both its standard output and\nstandard error streams, and return this together with its exit code.\n---\nauto dmd = execute(\"dmd\", \"myapp.d\");\nif (dmd.status != 0) writeln(\"Compilation failed:\\n\", dmd.output);\n\nauto ls = executeShell(\"ls -l\");\nif (ls.status == 0) writeln(\"Failed to retrieve file listing\");\nelse writeln(ls.output);\n---\n\nThe $(D args)/$(D program)/$(D command), $(D env) and $(D config)\nparameters are forwarded straight to the underlying spawn functions,\nand we refer to their documentation for details.\n\nParams:\nargs      = An array which contains the program name as the zeroth element\n            and any command-line arguments in the following elements.\n            (See $(LREF spawnProcess) for details.)\nprogram   = The program name, $(I without) command-line arguments.\n            (See $(LREF spawnProcess) for details.)\ncommand   = A shell command which is passed verbatim to the command\n            interpreter.  (See $(LREF spawnShell) for details.)\nenv       = Additional environment variables for the child process.\n            (See $(LREF spawnProcess) for details.)\nconfig    = Flags that control process creation. See $(LREF Config)\n            for an overview of available flags, and note that the\n            $(D retainStd...) flags have no effect in this function.\nmaxOutput = The maximum number of bytes of output that should be\n            captured.\n\nReturns:\nA $(D struct) which contains the fields $(D int status) and\n$(D string output).  (This will most likely change to become a\n$(D std.typecons.Tuple!(int,\"status\",string,\"output\")) in the future,\nbut a compiler bug currently prevents this.)\n\nPOSIX_specific:\nIf the process is terminated by a signal, the $(D status) field of\nthe return value will contain a negative number whose absolute\nvalue is the signal number.  (See $(LREF wait) for details.)\n\nThrows:\n$(LREF ProcessException) on failure to start the process.$(BR)\n$(XREF stdio,StdioException) on failure to capture output.\n",
    "line" : 1943,
    "storageClass" : [
     "auto"
    ],
    "deco" : "FNeAAyaxHAyaAyaE3std7process6ConfigmZS3std7process138__T11executeImplS112_D3std7process11pipeProcessFNeAAyaE3std7process8RedirectxHAyaAyaE3std7process6ConfigZS3std7process12ProcessPipesTAAyaZ11executeImplFAAyaxHAyaAyaE3std7process6ConfigmZ13ProcessOutput",
    "originalType" : "@trusted (string[] args, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "AAya"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     },
     {
      "name" : "maxOutput",
      "deco" : "m",
      "default" : "18446744073709551615LU"
     }
    ],
    "endline" : 1945
   },
   {
    "name" : "execute",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1953,
    "storageClass" : [
     "auto"
    ],
    "deco" : "FNeAyaxHAyaAyaE3std7process6ConfigmZS3std7process137__T11executeImplS112_D3std7process11pipeProcessFNeAAyaE3std7process8RedirectxHAyaAyaE3std7process6ConfigZS3std7process12ProcessPipesTAyaZ11executeImplFAyaxHAyaAyaE3std7process6ConfigmZ13ProcessOutput",
    "originalType" : "@trusted (string program, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max)",
    "parameters" : [
     {
      "name" : "program",
      "deco" : "Aya"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     },
     {
      "name" : "maxOutput",
      "deco" : "m",
      "default" : "18446744073709551615LU"
     }
    ],
    "endline" : 1955
   },
   {
    "name" : "executeShell",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1963,
    "storageClass" : [
     "auto"
    ],
    "deco" : "FNeAyaxHAyaAyaE3std7process6ConfigmZS3std7process133__T11executeImplS108_D3std7process9pipeShellFNfAyaE3std7process8RedirectxHAyaAyaE3std7process6ConfigZS3std7process12ProcessPipesTAyaZ11executeImplFAyaxHAyaAyaE3std7process6ConfigmZ13ProcessOutput",
    "originalType" : "@trusted (string command, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max)",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "Aya"
     },
     {
      "name" : "env",
      "deco" : "xHAyaAya",
      "default" : "null"
     },
     {
      "name" : "config",
      "deco" : "E3std7process6Config",
      "default" : "cast(Config)0"
     },
     {
      "name" : "maxOutput",
      "deco" : "m",
      "default" : "18446744073709551615LU"
     }
    ],
    "endline" : 1965
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1968,
    "name" : "executeImpl",
    "parameters" : [
     {
      "name" : "pipeFunc",
      "kind" : "alias"
     },
     {
      "name" : "Cmd",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "executeImpl",
      "kind" : "function",
      "line" : 1968,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Cmd commandLine, const string[string] env = null, Config config = Config.none, size_t maxOutput = size_t.max)",
      "parameters" : [
       {
        "name" : "commandLine",
        "type" : "Cmd"
       },
       {
        "name" : "env",
        "type" : "string[string]",
        "storageClass" : [
         "const"
        ],
        "default" : "null"
       },
       {
        "name" : "config",
        "type" : "Config",
        "default" : "Config.none"
       },
       {
        "name" : "maxOutput",
        "type" : "size_t",
        "default" : "size_t.max"
       }
      ],
      "endline" : 1998
     }
    ]
   },
   {
    "name" : "__unittestL2000_1356",
    "kind" : "function",
    "line" : 2000,
    "endline" : 2020
   },
   {
    "name" : "__unittestL2020_1357",
    "kind" : "function",
    "line" : 2020,
    "endline" : 2035
   },
   {
    "name" : "ProcessException",
    "kind" : "class",
    "comment" : " An exception that signals a problem with starting or waiting for a process.\n",
    "line" : 2035,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2038,
      "deco" : "FAyaAyamZC3std7process16ProcessException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 2041
     },
     {
      "name" : "newFromErrno",
      "kind" : "function",
      "line" : 2044,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaAyamZC3std7process16ProcessException",
      "originalType" : "ProcessException(string customMsg = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "customMsg",
        "deco" : "Aya",
        "default" : "null"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 2063
     }
    ]
   },
   {
    "name" : "userShell",
    "kind" : "function",
    "comment" : "\nDetermines the path to the current user's default command interpreter.\n\nOn Windows, this function returns the contents of the COMSPEC environment\nvariable, if it exists.  Otherwise, it returns the string $(D \"cmd.exe\").\n\nOn POSIX, $(D userShell) returns the contents of the SHELL environment\nvariable, if it exists and is non-empty.  Otherwise, it returns\n$(D \"/bin/sh\").\n",
    "line" : 2089,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdNfZAya",
    "originalType" : "@safe string()",
    "endline" : 2093
   },
   {
    "name" : "shellSwitch",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2098,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAa",
    "originalType" : "string",
    "init" : "\"-c\""
   },
   {
    "name" : "thisProcessID",
    "kind" : "function",
    "comment" : " Returns the process ID number of the current process.\n",
    "line" : 2103,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdNeZi",
    "originalType" : "@trusted int()",
    "endline" : 2107
   },
   {
    "name" : "escapeShellCommand",
    "kind" : "function",
    "comment" : "\nEscapes an argv-style argument array to be used with $(LREF spawnShell),\n$(LREF pipeShell) or $(LREF executeShell).\n---\nstring url = \"http://dlang.org/\";\nexecuteShell(escapeShellCommand(\"wget\", url, \"-O\", \"dlang-index.html\"));\n---\n\nConcatenate multiple $(D escapeShellCommand) and\n$(LREF escapeShellFileName) results to use shell redirection or\npiping operators.\n---\nexecuteShell(\n    escapeShellCommand(\"curl\", \"http://dlang.org/download.html\") ~\n    \"|\" ~\n    escapeShellCommand(\"grep\", \"-o\", `http://\\S*\\.zip`) ~\n    \">\" ~\n    escapeShellFileName(\"D download links.txt\"));\n---\n\nThrows:\n$(OBJECTREF Exception) if any part of the command line contains unescapable\ncharacters (NUL on all platforms, as well as CR and LF on Windows).\n",
    "line" : 2211,
    "deco" : "FxAAaXAya",
    "originalType" : "string(in char[][] args...)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "xAAa"
     }
    ],
    "endline" : 2215
   },
   {
    "name" : "escapeShellCommandString",
    "kind" : "function",
    "protection" : "private",
    "line" : 2218,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "Aya"
     }
    ],
    "endline" : 2225
   },
   {
    "name" : "escapeWindowsShellCommand",
    "kind" : "function",
    "protection" : "private",
    "line" : 2227,
    "deco" : "FxAaZAya",
    "originalType" : "string(in char[] command)",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "xAa"
     }
    ],
    "endline" : 2256
   },
   {
    "name" : "escapeShellArguments",
    "kind" : "function",
    "protection" : "private",
    "line" : 2258,
    "deco" : "FNaNbNexAAaXAya",
    "originalType" : "pure nothrow @trusted string(in char[][] args...)",
    "parameters" : [
     {
      "name" : "args",
      "deco" : "xAAa"
     }
    ],
    "endline" : 2280
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2282,
    "name" : "escapeShellArgument",
    "parameters" : [
     {
      "name" : "allocator",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "escapeShellArgument",
      "kind" : "function",
      "line" : 2282,
      "storageClass" : [
       "auto"
      ],
      "type" : "nothrow @safe (in char[] arg)",
      "parameters" : [
       {
        "name" : "arg",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2291
     }
    ]
   },
   {
    "name" : "escapeWindowsArgument",
    "kind" : "function",
    "comment" : "\nQuotes a command-line argument in a manner conforming to the behavior of\n$(LINK2 http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391(v=vs.85).aspx,\nCommandLineToArgvW).\n",
    "line" : 2298,
    "deco" : "FNaNbNexAaZAya",
    "originalType" : "pure nothrow @trusted string(in char[] arg)",
    "parameters" : [
     {
      "name" : "arg",
      "deco" : "xAa"
     }
    ],
    "endline" : 2306
   },
   {
    "name" : "charAllocator",
    "kind" : "function",
    "protection" : "private",
    "line" : 2309,
    "deco" : "FNaNbNfmZAa",
    "originalType" : "pure nothrow @safe char[](size_t size)",
    "parameters" : [
     {
      "name" : "size",
      "deco" : "m"
     }
    ],
    "endline" : 2312
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2315,
    "name" : "escapeWindowsArgumentImpl",
    "parameters" : [
     {
      "name" : "allocator",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "escapeWindowsArgumentImpl",
      "kind" : "function",
      "line" : 2315,
      "type" : "nothrow @safe char[](in char[] arg)",
      "parameters" : [
       {
        "name" : "arg",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2370
     }
    ]
   },
   {
    "name" : "escapePosixArgument",
    "kind" : "function",
    "protection" : "private",
    "line" : 2412,
    "deco" : "FNaNbNexAaZAya",
    "originalType" : "pure nothrow @trusted string(in char[] arg)",
    "parameters" : [
     {
      "name" : "arg",
      "deco" : "xAa"
     }
    ],
    "endline" : 2416
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2418,
    "name" : "escapePosixArgumentImpl",
    "parameters" : [
     {
      "name" : "allocator",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "escapePosixArgumentImpl",
      "kind" : "function",
      "line" : 2418,
      "type" : "nothrow @safe char[](in char[] arg)",
      "parameters" : [
       {
        "name" : "arg",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2448
     }
    ]
   },
   {
    "name" : "escapeShellFileName",
    "kind" : "function",
    "comment" : "\nEscapes a filename to be used for shell redirection with $(LREF spawnShell),\n$(LREF pipeShell) or $(LREF executeShell).\n",
    "line" : 2454,
    "deco" : "FNaNbNexAaZAya",
    "originalType" : "pure nothrow @trusted string(in char[] fileName)",
    "parameters" : [
     {
      "name" : "fileName",
      "deco" : "xAa"
     }
    ],
    "endline" : 2463
   },
   {
    "name" : "environment",
    "kind" : "class",
    "comment" : "\nManipulates _environment variables using an associative-array-like\ninterface.\n\nThis class contains only static methods, and cannot be instantiated.\nSee below for examples of use.\n",
    "line" : 2583,
    "members" : [
     {
      "name" : "opIndex",
      "kind" : "function",
      "comment" : "\n    Retrieves the value of the environment variable with the given $(D name).\n    ---\n    auto path = environment[\"PATH\"];\n    ---\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variable does not exist.\n\n    See_also:\n    $(LREF environment.get), which doesn't throw on failure.\n    \n",
      "line" : 2597,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNfAyaZAya",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       }
      ],
      "endline" : 2602
     },
     {
      "name" : "get",
      "kind" : "function",
      "comment" : "\n    Retrieves the value of the environment variable with the given $(D name),\n    or a default value if the variable doesn't exist.\n\n    Unlike $(LREF environment.opIndex), this function never throws.\n    ---\n    auto sh = environment.get(\"SHELL\", \"/bin/sh\");\n    ---\n    This function is also useful in checking for the existence of an\n    environment variable.\n    ---\n    auto myVar = environment.get(\"MYVAR\");\n    if (myVar is null)\n    {\n        // Environment variable doesn't exist.\n        // Note that we have to use 'is' for the comparison, since\n        // myVar == null is also true if the variable exists but is\n        // empty.\n    }\n    ---\n    \n",
      "line" : 2625,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNfAyaAyaZAya",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "defaultValue",
        "deco" : "Aya",
        "default" : "null"
       }
      ],
      "endline" : 2630
     },
     {
      "name" : "opIndexAssign",
      "kind" : "function",
      "comment" : "\n    Assigns the given $(D value) to the environment variable with the given\n    $(D name).\n\n    If the variable does not exist, it will be created. If it already exists,\n    it will be overwritten.\n    ---\n    environment[\"foo\"] = \"bar\";\n    ---\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variable could not be added\n        (e.g. if the name is invalid).\n    \n",
      "line" : 2646,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNeAyaAyaZAya",
      "parameters" : [
       {
        "name" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "name",
        "deco" : "Aya"
       }
      ],
      "endline" : 2671
     },
     {
      "name" : "remove",
      "kind" : "function",
      "comment" : "\n    Removes the environment variable with the given $(D name).\n\n    If the variable isn't in the environment, this function returns\n    successfully without doing anything.\n    \n",
      "line" : 2679,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNeAyaZv",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       }
      ],
      "endline" : 2684
     },
     {
      "name" : "toAA",
      "kind" : "function",
      "comment" : "\n    Copies all environment variables into an associative array.\n\n    Windows_specific:\n    While Windows environment variable names are case insensitive, D's\n    built-in associative arrays are not.  This function will store all\n    variable names in uppercase (e.g. $(D PATH)).\n\n    Throws:\n    $(OBJECTREF Exception) if the environment variables could not\n        be retrieved (Windows only).\n    \n",
      "line" : 2698,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNeZHAyaAya",
      "endline" : 2744
     },
     {
      "name" : "getImpl",
      "kind" : "function",
      "protection" : "private",
      "line" : 2756,
      "storageClass" : [
       "static"
      ],
      "deco" : "FNeAyaJAyaZb",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "value",
        "deco" : "Aya",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2787
     }
    ]
   },
   {
    "name" : "__unittestL2790_1360",
    "kind" : "function",
    "line" : 2790,
    "endline" : 2861
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 2861,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdlib",
    "kind" : "import",
    "line" : 2862,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 2863,
    "protection" : "private"
   },
   {
    "name" : "core.thread",
    "kind" : "import",
    "line" : 2864,
    "protection" : "private"
   },
   {
    "name" : "std.c.process",
    "kind" : "import",
    "line" : 2865,
    "protection" : "private"
   },
   {
    "name" : "std.c.string",
    "kind" : "import",
    "line" : 2866,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.stdlib",
    "kind" : "import",
    "line" : 2874,
    "protection" : "private"
   },
   {
    "name" : "system",
    "kind" : "function",
    "comment" : "\n   Execute $(D command) in a _command shell.\n\n   $(RED This function is scheduled for deprecation.  Please use\n   $(LREF spawnShell) or $(LREF executeShell) instead.)\n\n   Returns: If $(D command) is null, returns nonzero if the _command\n   interpreter is found, and zero otherwise. If $(D command) is not\n   null, returns -1 on error, or the exit status of command (which may\n   in turn signal an error in command's execution).\n\n   Note: On Unix systems, the homonym C function (which is accessible\n   to D programs as $(LINK2 std_c_process.html, std.c._system))\n   returns a code in the same format as $(LUCKY waitpid, waitpid),\n   meaning that C programs must use the $(D WEXITSTATUS) macro to\n   extract the actual exit code from the $(D system) call. D's $(D\n   system) automatically extracts the exit status.\n\n",
    "line" : 2903,
    "deco" : "FAyaZi",
    "parameters" : [
     {
      "name" : "command",
      "deco" : "Aya"
     }
    ],
    "endline" : 2921
   },
   {
    "name" : "toAStringz",
    "kind" : "function",
    "protection" : "private",
    "line" : 2923,
    "deco" : "FxAAyaPPxaZv",
    "originalType" : "void(in string[] a, const(char)** az)",
    "parameters" : [
     {
      "name" : "a",
      "deco" : "xAAya"
     },
     {
      "name" : "az",
      "deco" : "PPxa"
     }
    ],
    "endline" : 2930
   },
   {
    "name" : "P_WAIT",
    "kind" : "alias",
    "line" : 2949
   },
   {
    "name" : "P_NOWAIT",
    "kind" : "alias",
    "line" : 2950
   },
   {
    "name" : "spawnvp",
    "kind" : "function",
    "line" : 2952,
    "deco" : "FiAyaAAyaZi",
    "parameters" : [
     {
      "name" : "mode",
      "deco" : "i"
     },
     {
      "name" : "pathname",
      "deco" : "Aya"
     },
     {
      "name" : "argv",
      "deco" : "AAya"
     }
    ],
    "endline" : 2968
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 2972,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.wait",
    "kind" : "import",
    "line" : 2973,
    "protection" : "private"
   },
   {
    "name" : "_spawnvp",
    "kind" : "function",
    "line" : 2974,
    "deco" : "FixPaxPPaZi",
    "originalType" : "int(int mode, in char* pathname, in char** argv)",
    "parameters" : [
     {
      "name" : "mode",
      "deco" : "i"
     },
     {
      "name" : "pathname",
      "deco" : "xPa"
     },
     {
      "name" : "argv",
      "deco" : "xPPa"
     }
    ],
    "endline" : 3023
   },
   {
    "name" : "stopped",
    "kind" : "alias",
    "protection" : "private",
    "line" : 3026
   },
   {
    "name" : "signaled",
    "kind" : "alias",
    "protection" : "private",
    "line" : 3027
   },
   {
    "name" : "termsig",
    "kind" : "alias",
    "protection" : "private",
    "line" : 3028
   },
   {
    "name" : "exited",
    "kind" : "alias",
    "protection" : "private",
    "line" : 3029
   },
   {
    "name" : "exitstatus",
    "kind" : "alias",
    "protection" : "private",
    "line" : 3030
   },
   {
    "name" : "execv",
    "kind" : "function",
    "comment" : "\n Replace the current process by executing a command, $(D pathname), with\n the arguments in $(D argv).\n\n $(RED These functions are scheduled for deprecation.  Please use\n $(LREF spawnShell) instead (or, alternatively, the homonymous C\n functions declared in $(D std.c.process).))\n\n Typically, the first element of $(D argv) is\n the command being executed, i.e. $(D argv[0] == pathname). The 'p'\n versions of $(D exec) search the PATH environment variable for $(D\n pathname). The 'e' versions additionally take the new process'\n environment variables as an array of strings of the form key=value.\n\n Does not return on success (the current process will have been\n replaced). Returns -1 on failure with no indication of the\n underlying error.\n \n",
    "line" : 3055,
    "deco" : "FxAyaxAAyaZi",
    "originalType" : "int(in string pathname, in string[] argv)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAya"
     },
     {
      "name" : "argv",
      "deco" : "xAAya"
     }
    ],
    "endline" : 3062
   },
   {
    "name" : "execve",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3065,
    "deco" : "FxAyaxAAyaxAAyaZi",
    "originalType" : "int(in string pathname, in string[] argv, in string[] envp)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAya"
     },
     {
      "name" : "argv",
      "deco" : "xAAya"
     },
     {
      "name" : "envp",
      "deco" : "xAAya"
     }
    ],
    "endline" : 3074
   },
   {
    "name" : "execvp",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3077,
    "deco" : "FxAyaxAAyaZi",
    "originalType" : "int(in string pathname, in string[] argv)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAya"
     },
     {
      "name" : "argv",
      "deco" : "xAAya"
     }
    ],
    "endline" : 3084
   },
   {
    "name" : "execvpe",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 3087,
    "deco" : "FxAyaxAAyaxAAyaZi",
    "originalType" : "int(in string pathname, in string[] argv, in string[] envp)",
    "parameters" : [
     {
      "name" : "pathname",
      "deco" : "xAya"
     },
     {
      "name" : "argv",
      "deco" : "xAAya"
     },
     {
      "name" : "envp",
      "deco" : "xAAya"
     }
    ],
    "endline" : 3136
   },
   {
    "name" : "getpid",
    "kind" : "alias",
    "comment" : "\n Returns the process ID of the calling process, which is guaranteed to be\n unique on the system. This call is always successful.\n\n $(RED This function is scheduled for deprecation.  Please use\n $(LREF thisProcessID) instead.)\n\n Example:\n ---\n writefln(\"Current process id: %s\", getpid());\n ---\n \n",
    "line" : 3150
   },
   {
    "name" : "shell",
    "kind" : "function",
    "comment" : "\n   Runs $(D_PARAM cmd) in a shell and returns its standard output. If\n   the process could not be started or exits with an error code,\n   throws ErrnoException.\n\n   $(RED This function is scheduled for deprecation.  Please use\n   $(LREF executeShell) instead.)\n\n   Example:\n\n   ----\n   auto tempFilename = chomp(shell(\"mcookie\"));\n   auto f = enforce(fopen(tempFilename), \"w\");\n   scope(exit)\n   {\n       fclose(f) == 0 || assert(false);\n       system(escapeShellCommand(\"rm\", tempFilename));\n   }\n   ... use f ...\n   ----\n",
    "line" : 3173,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "cmd",
      "deco" : "Aya"
     }
    ],
    "endline" : 3208
   },
   {
    "name" : "__unittestL3210_1361",
    "kind" : "function",
    "line" : 3210,
    "endline" : 3229
   },
   {
    "name" : "getenv",
    "kind" : "function",
    "comment" : "\nGets the value of environment variable $(D name) as a string. Calls\n$(LINK2 std_c_stdlib.html#_getenv, std.c.stdlib._getenv)\ninternally.\n\n   $(RED This function is scheduled for deprecation.  Please use\n   $(LREF environment.get) instead.)\n",
    "line" : 3229,
    "deco" : "FxAaZAya",
    "originalType" : "string(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 3238
   },
   {
    "name" : "setenv",
    "kind" : "function",
    "comment" : "\nSets the value of environment variable $(D name) to $(D value). If the\nvalue was written, or the variable was already present and $(D\noverwrite) is false, returns normally. Otherwise, it throws an\nexception. Calls $(LINK2 std_c_stdlib.html#_setenv,\nstd.c.stdlib._setenv) internally.\n\n   $(RED This function is scheduled for deprecation.  Please use\n   $(LREF environment.opIndexAssign) instead.)\n",
    "line" : 3251,
    "deco" : "FxAaxAabZv",
    "originalType" : "void(in char[] name, in char[] value, bool overwrite)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "value",
      "deco" : "xAa"
     },
     {
      "name" : "overwrite",
      "deco" : "b"
     }
    ],
    "endline" : 3255
   },
   {
    "name" : "unsetenv",
    "kind" : "function",
    "comment" : "\nRemoves variable $(D name) from the environment. Calls $(LINK2\nstd_c_stdlib.html#_unsetenv, std.c.stdlib._unsetenv) internally.\n\n   $(RED This function is scheduled for deprecation.  Please use\n   $(LREF environment.remove) instead.)\n",
    "line" : 3265,
    "deco" : "FxAaZv",
    "originalType" : "void(in char[] name)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     }
    ],
    "endline" : 3268
   },
   {
    "name" : "__unittestL3270_1362",
    "kind" : "function",
    "line" : 3270,
    "endline" : 3282
   },
   {
    "name" : "core.stdc.stdio",
    "kind" : "import",
    "line" : 3380,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 3381,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 3382,
    "protection" : "private"
   },
   {
    "name" : "browse",
    "kind" : "function",
    "line" : 3384,
    "deco" : "FAyaZv",
    "parameters" : [
     {
      "name" : "url",
      "deco" : "Aya"
     }
    ],
    "endline" : 3409
   }
  ]
 },
 {
  "name" : "std.random",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/random.d",
  "comment" : "\nFacilities for random number generation.\n\nThe new-style generator objects hold their own state so they are\nimmune of threading issues. The generators feature a number of\nwell-known and well-documented methods of generating random\nnumbers. An overall fast and reliable means to generate random numbers\nis the $(D_PARAM Mt19937) generator, which derives its name from\n\"$(LUCKY Mersenne Twister) with a period of 2 to the power of\n19937\". In memory-constrained situations, $(LUCKY linear congruential)\ngenerators such as $(D MinstdRand0) and $(D MinstdRand) might be\nuseful. The standard library provides an alias $(D_PARAM Random) for\nwhichever generator it considers the most fit for the target\nenvironment.\n\nExample:\n\n----\n// Generate a uniformly-distributed integer in the range [0, 14]\nauto i = uniform(0, 15);\n// Generate a uniformly-distributed real in the range [0, 100$(RPAREN)\n// using a specific random generator\nRandom gen;\nauto r = uniform(0.0L, 100.0L, gen);\n----\n\nIn addition to random number generators, this module features\ndistributions, which skew a generator's output statistical\ndistribution in various ways. So far the uniform distribution for\nintegers and real numbers have been implemented.\n\nSource:    $(PHOBOSSRC std/_random.d)\n\nMacros:\n\nWIKI = Phobos/StdRandom\n\n\nCopyright: Copyright Andrei Alexandrescu 2008 - 2009, Joseph Rushton Wakeling 2012.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu)\n           Masahiro Nakagawa (Xorshift randome generator)\n           $(WEB braingam.es, Joseph Rushton Wakeling) (Algorithm D for random sampling)\nCredits:   The entire random number library architecture is derived from the\n           excellent $(WEB open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2461.pdf, C++0X)\n           random number facility proposed by Jens Maurer and contributed to by\n           researchers at the Fermi laboratory(excluding Xorshift).\n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 59,
    "protection" : "private"
   },
   {
    "name" : "std.c.time",
    "kind" : "import",
    "line" : 59,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 59,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 59,
    "protection" : "private"
   },
   {
    "name" : "std.math",
    "kind" : "import",
    "line" : 60,
    "protection" : "private"
   },
   {
    "name" : "std.numeric",
    "kind" : "import",
    "line" : 60,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 60,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 60,
    "protection" : "private"
   },
   {
    "name" : "core.thread",
    "kind" : "import",
    "line" : 61,
    "protection" : "private"
   },
   {
    "name" : "core.time",
    "kind" : "import",
    "line" : 61,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 62,
    "protection" : "private",
    "selective" : [
     "format"
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Test if Rng is a random-number generator. The overload\n taking a ElementType also makes sure that the Rng generates\n values of that type.\n\n A random-number generator has at least the following features:\n $(UL\n   $(LI it's an InputRange)\n   $(LI it has a 'bool isUniformRandom' field readable in CTFE)\n )\n \n",
    "line" : 127,
    "name" : "isUniformRNG",
    "parameters" : [
     {
      "name" : "Rng",
      "kind" : "type"
     },
     {
      "name" : "ElementType",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isUniformRNG",
      "kind" : "variable",
      "line" : 129,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isInputRange!(Rng) && is(typeof(Rng.front) == ElementType) && is(typeof(()\n{\nstatic assert(Rng.isUniformRandom);\n}\n))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n ditto\n \n",
    "line" : 140,
    "name" : "isUniformRNG",
    "parameters" : [
     {
      "name" : "Rng",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isUniformRNG",
      "kind" : "variable",
      "line" : 142,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isInputRange!(Rng) && is(typeof(()\n{\nstatic assert(Rng.isUniformRandom);\n}\n))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Test if Rng is seedable. The overload\n taking a SeedType also makes sure that the Rng can be seeded with SeedType.\n\n A seedable random-number generator has the following additional features:\n $(UL\n   $(LI it has a 'seed(ElementType)' function)\n )\n \n",
    "line" : 158,
    "name" : "isSeedable",
    "parameters" : [
     {
      "name" : "Rng",
      "kind" : "type"
     },
     {
      "name" : "SeedType",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSeedable",
      "kind" : "variable",
      "line" : 160,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isUniformRNG!(Rng) && is(typeof(()\n{\nRng r = void;\nr.seed(SeedType.init);\n}\n))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 169,
    "name" : "isSeedable",
    "parameters" : [
     {
      "name" : "Rng",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSeedable",
      "kind" : "variable",
      "line" : 171,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isUniformRNG!(Rng) && is(typeof(()\n{\nRng r = void;\nr.seed((typeof(r.front)).init);\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL179_1367",
    "kind" : "function",
    "line" : 179,
    "endline" : 247
   },
   {
    "kind" : "template",
    "comment" : "\nLinear Congruential generator.\n \n",
    "line" : 249,
    "name" : "LinearCongruentialEngine",
    "parameters" : [
     {
      "name" : "UIntType",
      "kind" : "type"
     },
     {
      "name" : "a",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "c",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "m",
      "kind" : "value",
      "type" : "UIntType"
     }
    ],
    "members" : [
     {
      "name" : "LinearCongruentialEngine",
      "kind" : "struct",
      "line" : 249,
      "members" : [
       {
        "name" : "isUniformRandom",
        "kind" : "variable",
        "comment" : "Mark this as a Rng\n",
        "line" : 251,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "true"
       },
       {
        "name" : "hasFixedRange",
        "kind" : "variable",
        "comment" : " Does this generator have a fixed range? ($(D_PARAM true)).\n",
        "line" : 253,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "true"
       },
       {
        "name" : "min",
        "kind" : "variable",
        "comment" : " Lowest generated value ($(D 1) if $(D c == 0), $(D 0) otherwise).\n",
        "line" : 255,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "c == 0 ? 1 : 0"
       },
       {
        "name" : "max",
        "kind" : "variable",
        "comment" : " Highest generated value ($(D modulus - 1)).\n",
        "line" : 257,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "m - 1"
       },
       {
        "name" : "multiplier",
        "kind" : "variable",
        "comment" : "\nThe parameters of this distribution. The random number is $(D_PARAM x\n= (x * multipler + increment) % modulus).\n \n",
        "line" : 262,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "a"
       },
       {
        "name" : "increment",
        "kind" : "variable",
        "comment" : "ditto\n",
        "line" : 264,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "c"
       },
       {
        "name" : "modulus",
        "kind" : "variable",
        "comment" : "ditto\n",
        "line" : 266,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "m"
       },
       {
        "name" : "gcd",
        "kind" : "function",
        "line" : 275,
        "type" : "ulong(ulong a, ulong b)",
        "parameters" : [
         {
          "name" : "a",
          "deco" : "m"
         },
         {
          "name" : "b",
          "deco" : "m"
         }
        ],
        "endline" : 284
       },
       {
        "name" : "primeFactorsOnly",
        "kind" : "function",
        "line" : 286,
        "type" : "ulong(ulong n)",
        "parameters" : [
         {
          "name" : "n",
          "deco" : "m"
         }
        ],
        "endline" : 300
       },
       {
        "name" : "__unittestL302_1368",
        "kind" : "function",
        "line" : 302,
        "endline" : 313
       },
       {
        "name" : "properLinearCongruentialParameters",
        "kind" : "function",
        "line" : 313,
        "type" : "bool(ulong m, ulong a, ulong c)",
        "parameters" : [
         {
          "name" : "m",
          "deco" : "m"
         },
         {
          "name" : "a",
          "deco" : "m"
         },
         {
          "name" : "c",
          "deco" : "m"
         }
        ],
        "endline" : 338
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\nConstructs a $(D_PARAM LinearCongruentialEngine) generator seeded with\n$(D x0).\n \n",
        "line" : 348,
        "type" : "(UIntType x0)",
        "parameters" : [
         {
          "name" : "x0",
          "type" : "UIntType"
         }
        ],
        "endline" : 351
       },
       {
        "name" : "seed",
        "kind" : "function",
        "comment" : "\n   (Re)seeds the generator.\n",
        "line" : 356,
        "type" : "void(UIntType x0 = 1)",
        "parameters" : [
         {
          "name" : "x0",
          "type" : "UIntType",
          "default" : "1"
         }
        ],
        "endline" : 365
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n   Advances the random sequence.\n",
        "line" : 370,
        "type" : "void()",
        "endline" : 401
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n   Returns the current number in the random sequence.\n",
        "line" : 406,
        "type" : "UIntType()",
        "endline" : 409
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 412,
        "type" : "typeof(this)()",
        "endline" : 415
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "comment" : "\nAlways $(D false) (random generators are infinite ranges).\n \n",
        "line" : 420,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\n   Compares against $(D_PARAM rhs) for equality.\n \n",
        "line" : 425,
        "type" : "const bool(ref const LinearCongruentialEngine rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "LinearCongruentialEngine",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 428
       },
       {
        "name" : "_x",
        "kind" : "variable",
        "line" : 430,
        "type" : "UIntType",
        "init" : "m ? (a + c) % m : a + c"
       }
      ]
     }
    ]
   },
   {
    "name" : "MinstdRand0",
    "kind" : "alias",
    "comment" : "\nDefine $(D_PARAM LinearCongruentialEngine) generators with well-chosen\nparameters. $(D MinstdRand0) implements Park and Miller's \"minimal\nstandard\" $(WEB\nwikipedia.org/wiki/Park%E2%80%93Miller_random_number_generator,\ngenerator) that uses 16807 for the multiplier. $(D MinstdRand)\nimplements a variant that has slightly better spectral behavior by\nusing the multiplier 48271. Both generators are rather simplistic.\n\nExample:\n\n----\n// seed with a constant\nauto rnd0 = MinstdRand0(1);\nauto n = rnd0.front; // same for each run\n// Seed with an unpredictable value\nrnd0.seed(unpredictableSeed);\nn = rnd0.front; // different across runs\n----\n \n",
    "line" : 453,
    "deco" : "S3std6random54__T24LinearCongruentialEngineTkVi16807Vi0Vi2147483647Z24LinearCongruentialEngine"
   },
   {
    "name" : "MinstdRand",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 455,
    "deco" : "S3std6random54__T24LinearCongruentialEngineTkVi48271Vi0Vi2147483647Z24LinearCongruentialEngine"
   },
   {
    "name" : "__unittestL457_1369",
    "kind" : "function",
    "line" : 457,
    "endline" : 513
   },
   {
    "kind" : "template",
    "comment" : "\nThe $(LUCKY Mersenne Twister) generator.\n \n",
    "line" : 518,
    "name" : "MersenneTwisterEngine",
    "parameters" : [
     {
      "name" : "UIntType",
      "kind" : "type"
     },
     {
      "name" : "w",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "n",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "m",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "r",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "a",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "u",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "s",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "b",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "t",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "c",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "l",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "MersenneTwisterEngine",
      "kind" : "struct",
      "line" : 518,
      "members" : [
       {
        "name" : "isUniformRandom",
        "kind" : "variable",
        "comment" : "Mark this as a Rng\n",
        "line" : 520,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "true"
       },
       {
        "name" : "wordSize",
        "kind" : "variable",
        "comment" : "\nParameter for the generator.\n",
        "line" : 524,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "w"
       },
       {
        "name" : "stateSize",
        "kind" : "variable",
        "line" : 525,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "n"
       },
       {
        "name" : "shiftSize",
        "kind" : "variable",
        "line" : 526,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "m"
       },
       {
        "name" : "maskBits",
        "kind" : "variable",
        "line" : 527,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "r"
       },
       {
        "name" : "xorMask",
        "kind" : "variable",
        "line" : 528,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "a"
       },
       {
        "name" : "temperingU",
        "kind" : "variable",
        "line" : 529,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "u"
       },
       {
        "name" : "temperingS",
        "kind" : "variable",
        "line" : 530,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "s"
       },
       {
        "name" : "temperingB",
        "kind" : "variable",
        "line" : 531,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "b"
       },
       {
        "name" : "temperingT",
        "kind" : "variable",
        "line" : 532,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "t"
       },
       {
        "name" : "temperingC",
        "kind" : "variable",
        "line" : 533,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "c"
       },
       {
        "name" : "temperingL",
        "kind" : "variable",
        "line" : 534,
        "storageClass" : [
         "enum"
        ],
        "type" : "size_t",
        "init" : "l"
       },
       {
        "name" : "min",
        "kind" : "variable",
        "comment" : " Smallest generated value (0).\n",
        "line" : 537,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "0"
       },
       {
        "name" : "max",
        "kind" : "variable",
        "comment" : " Largest generated value.\n",
        "line" : 539,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "w == UIntType.sizeof * 8 ? UIntType.max : (1u << w) - 1"
       },
       {
        "name" : "defaultSeed",
        "kind" : "variable",
        "comment" : " The default seed value.\n",
        "line" : 542,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "5489u"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n   Constructs a MersenneTwisterEngine object.\n",
        "line" : 553,
        "type" : "(UIntType value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "UIntType"
         }
        ],
        "endline" : 556
       },
       {
        "kind" : "template",
        "comment" : "\n   Seeds a MersenneTwisterEngine object.\n   Note:\n   This seed function gives 2^32 starting points. To allow the RNG to be started in any one of its\n   internal states use the seed overload taking an InputRange.\n",
        "line" : 564,
        "name" : "seed",
        "parameters" : [],
        "members" : [
         {
          "name" : "seed",
          "kind" : "function",
          "comment" : "\n   Seeds a MersenneTwisterEngine object.\n   Note:\n   This seed function gives 2^32 starting points. To allow the RNG to be started in any one of its\n   internal states use the seed overload taking an InputRange.\n",
          "line" : 564,
          "type" : "void(UIntType value = defaultSeed)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "UIntType",
            "default" : "defaultSeed"
           }
          ],
          "endline" : 588
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Seeds a MersenneTwisterEngine object using an InputRange.\n\n   Throws:\n   $(D Exception) if the InputRange didn't provide enough elements to seed the generator.\n   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.\n\n   Examples:\n   ----------------\n   Mt19937 gen;\n   gen.seed(map!((a) => unpredictableSeed)(repeat(0)));\n   ----------------\n \n",
        "line" : 603,
        "name" : "seed",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "seed",
          "kind" : "function",
          "comment" : "\n   Seeds a MersenneTwisterEngine object using an InputRange.\n\n   Throws:\n   $(D Exception) if the InputRange didn't provide enough elements to seed the generator.\n   The number of elements required is the 'n' template parameter of the MersenneTwisterEngine struct.\n\n   Examples:\n   ----------------\n   Mt19937 gen;\n   gen.seed(map!((a) => unpredictableSeed)(repeat(0)));\n   ----------------\n \n",
          "line" : 603,
          "type" : "void(T range)",
          "parameters" : [
           {
            "name" : "range",
            "type" : "T"
           }
          ],
          "endline" : 619
         }
        ]
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n   Advances the generator.\n",
        "line" : 624,
        "type" : "void()",
        "endline" : 670
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n   Returns the current random value.\n \n",
        "line" : 675,
        "type" : "UIntType()",
        "endline" : 679
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 682,
        "type" : "typeof(this)()",
        "endline" : 685
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "comment" : "\nAlways $(D false).\n \n",
        "line" : 690,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "mt",
        "kind" : "variable",
        "line" : 692,
        "type" : "UIntType[n]"
       },
       {
        "name" : "mti",
        "kind" : "variable",
        "line" : 693,
        "type" : "size_t",
        "init" : "size_t.max"
       },
       {
        "name" : "_y",
        "kind" : "variable",
        "line" : 694,
        "type" : "UIntType",
        "init" : "UIntType.max"
       }
      ]
     }
    ]
   },
   {
    "name" : "Mt19937",
    "kind" : "alias",
    "comment" : "\nA $(D MersenneTwisterEngine) instantiated with the parameters of the\noriginal engine $(WEB math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html,\nMT19937), generating uniformly-distributed 32-bit numbers with a\nperiod of 2 to the power of 19937. Recommended for random number\ngeneration unless memory is severely restricted, in which case a $(D\nLinearCongruentialEngine) would be the generator of choice.\n\nExample:\n\n----\n// seed with a constant\nMt19937 gen;\nauto n = gen.front; // same for each run\n// Seed with an unpredictable value\ngen.seed(unpredictableSeed);\nn = gen.front; // different across runs\n----\n \n",
    "line" : 718,
    "deco" : "S3std6random98__T21MersenneTwisterEngineTkVi32Vi624Vi397Vi31Vk2567483615Vi11Vi7Vk2636928640Vi15Vk4022730752Vi18Z21MersenneTwisterEngine"
   },
   {
    "name" : "__unittestL720_1372",
    "kind" : "function",
    "line" : 720,
    "endline" : 732
   },
   {
    "name" : "__unittestL732_1379",
    "kind" : "function",
    "line" : 732,
    "endline" : 743
   },
   {
    "name" : "__unittestL743_1380",
    "kind" : "function",
    "line" : 743,
    "endline" : 775
   },
   {
    "kind" : "template",
    "comment" : "\n Xorshift generator using 32bit algorithm.\n\n Implemented according to $(WEB www.jstatsoft.org/v08/i14/paper, Xorshift RNGs).\n\n $(BOOKTABLE $(TEXTWITHCOMMAS Supporting bits are below, $(D bits) means second parameter of XorshiftEngine.),\n  $(TR $(TH bits) $(TH period))\n  $(TR $(TD 32)   $(TD 2^32 - 1))\n  $(TR $(TD 64)   $(TD 2^64 - 1))\n  $(TR $(TD 96)   $(TD 2^96 - 1))\n  $(TR $(TD 128)  $(TD 2^128 - 1))\n  $(TR $(TD 160)  $(TD 2^160 - 1))\n  $(TR $(TD 192)  $(TD 2^192 - 2^32))\n )\n \n",
    "line" : 777,
    "name" : "XorshiftEngine",
    "parameters" : [
     {
      "name" : "UIntType",
      "kind" : "type"
     },
     {
      "name" : "bits",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "a",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "b",
      "kind" : "value",
      "type" : "UIntType"
     },
     {
      "name" : "c",
      "kind" : "value",
      "type" : "UIntType"
     }
    ],
    "members" : [
     {
      "name" : "XorshiftEngine",
      "kind" : "struct",
      "line" : 777,
      "members" : [
       {
        "name" : "isUniformRandom",
        "kind" : "variable",
        "comment" : "Mark this as a Rng\n",
        "line" : 784,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "true"
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "comment" : " Always $(D false) (random generators are infinite ranges).\n",
        "line" : 786,
        "storageClass" : [
         "enum"
        ],
        "init" : "false"
       },
       {
        "name" : "min",
        "kind" : "variable",
        "comment" : " Smallest generated value.\n",
        "line" : 788,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "0"
       },
       {
        "name" : "max",
        "kind" : "variable",
        "comment" : " Largest generated value.\n",
        "line" : 790,
        "storageClass" : [
         "enum"
        ],
        "type" : "UIntType",
        "init" : "UIntType.max"
       },
       {
        "name" : "size",
        "kind" : "variable",
        "line" : 794,
        "storageClass" : [
         "enum"
        ],
        "init" : "bits / 32"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n Constructs a $(D XorshiftEngine) generator seeded with $(D_PARAM x0).\n     \n",
        "line" : 818,
        "type" : "(UIntType x0)",
        "parameters" : [
         {
          "name" : "x0",
          "type" : "UIntType"
         }
        ],
        "endline" : 821
       },
       {
        "name" : "seed",
        "kind" : "function",
        "comment" : "\n (Re)seeds the generator.\n     \n",
        "line" : 828,
        "type" : "void(UIntType x0)",
        "parameters" : [
         {
          "name" : "x0",
          "type" : "UIntType"
         }
        ],
        "endline" : 838
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n Returns the current number in the random sequence.\n     \n",
        "line" : 845,
        "type" : "UIntType()",
        "endline" : 851
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n Advances the random sequence.\n     \n",
        "line" : 858,
        "type" : "void()",
        "endline" : 908
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n Captures a range state.\n     \n",
        "line" : 915,
        "type" : "typeof(this)()",
        "endline" : 918
       },
       {
        "name" : "opEquals",
        "kind" : "function",
        "comment" : "\n Compares against $(D_PARAM rhs) for equality.\n     \n",
        "line" : 925,
        "type" : "const bool(ref const XorshiftEngine rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "XorshiftEngine",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 928
       },
       {
        "name" : "sanitizeSeeds",
        "kind" : "function",
        "line" : 933,
        "type" : "void(ref UIntType[size] seeds)",
        "parameters" : [
         {
          "name" : "seeds",
          "type" : "UIntType[size]",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 940
       },
       {
        "name" : "__unittestL943_1381",
        "kind" : "function",
        "line" : 943,
        "endline" : 954
       }
      ]
     }
    ]
   },
   {
    "name" : "Xorshift32",
    "kind" : "alias",
    "comment" : "\n Define $(D XorshiftEngine) generators with well-chosen parameters. See each bits examples of \"Xorshift RNGs\".\n $(D Xorshift) is a Xorshift128's alias because 128bits implementation is mostly used.\n\n Example:\n -----\n // Seed with a constant\n auto rnd = Xorshift(1);\n auto num = rnd.front;  // same for each run\n\n // Seed with an unpredictable value\n rnd.seed(unpredictableSeed());\n num = rnd.front; // different across runs\n -----\n \n",
    "line" : 972,
    "deco" : "S3std6random37__T14XorshiftEngineTkVi32Vi13Vi17Vi5Z14XorshiftEngine"
   },
   {
    "name" : "Xorshift64",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 973,
    "deco" : "S3std6random38__T14XorshiftEngineTkVi64Vi10Vi13Vi10Z14XorshiftEngine"
   },
   {
    "name" : "Xorshift96",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 974,
    "deco" : "S3std6random37__T14XorshiftEngineTkVi96Vi10Vi5Vi26Z14XorshiftEngine"
   },
   {
    "name" : "Xorshift128",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 975,
    "deco" : "S3std6random38__T14XorshiftEngineTkVi128Vi11Vi8Vi19Z14XorshiftEngine"
   },
   {
    "name" : "Xorshift160",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 976,
    "deco" : "S3std6random36__T14XorshiftEngineTkVi160Vi2Vi1Vi4Z14XorshiftEngine"
   },
   {
    "name" : "Xorshift192",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 977,
    "deco" : "S3std6random36__T14XorshiftEngineTkVi192Vi2Vi1Vi4Z14XorshiftEngine"
   },
   {
    "name" : "Xorshift",
    "kind" : "alias",
    "comment" : " ditto\n",
    "line" : 978,
    "deco" : "S3std6random38__T14XorshiftEngineTkVi128Vi11Vi8Vi19Z14XorshiftEngine"
   },
   {
    "name" : "__unittestL981_1382",
    "kind" : "function",
    "line" : 981,
    "endline" : 1026
   },
   {
    "name" : "unpredictableSeed",
    "kind" : "function",
    "comment" : "\nA \"good\" seed for initializing random number engines. Initializing\nwith $(D_PARAM unpredictableSeed) makes engines generate different\nrandom number sequences every run.\n\nExample:\n\n----\nauto rnd = Random(unpredictableSeed);\nauto n = rnd.front;\n...\n----\n",
    "line" : 1026,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdZk",
    "originalType" : "uint()",
    "endline" : 1038
   },
   {
    "name" : "__unittestL1040_1383",
    "kind" : "function",
    "line" : 1040,
    "endline" : 1055
   },
   {
    "name" : "Random",
    "kind" : "alias",
    "comment" : "\nThe \"default\", \"favorite\", \"suggested\" random number generator type on\nthe current platform. It is an alias for one of the previously-defined\ngenerators. You may want to use it if (1) you need to generate some\nnice random numbers, and (2) you don't care for the minutiae of the\nmethod being used.\n \n",
    "line" : 1055,
    "deco" : "S3std6random98__T21MersenneTwisterEngineTkVi32Vi624Vi397Vi31Vk2567483615Vi11Vi7Vk2636928640Vi15Vk4022730752Vi18Z21MersenneTwisterEngine"
   },
   {
    "name" : "__unittestL1057_1384",
    "kind" : "function",
    "line" : 1057,
    "endline" : 1070
   },
   {
    "name" : "rndGen",
    "kind" : "function",
    "comment" : "\nGlobal random number generator used by various functions in this\nmodule whenever no generator is specified. It is allocated per-thread\nand initialized to an unpredictable value for each thread.\n \n",
    "line" : 1070,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNcNdZS3std6random98__T21MersenneTwisterEngineTkVi32Vi624Vi397Vi31Vk2567483615Vi11Vi7Vk2636928640Vi15Vk4022730752Vi18Z21MersenneTwisterEngine",
    "originalType" : "Random()",
    "endline" : 1083
   },
   {
    "kind" : "template",
    "comment" : "\nGenerates a number between $(D a) and $(D b). The $(D boundaries)\nparameter controls the shape of the interval (open vs. closed on\neither side). Valid values for $(D boundaries) are $(D \"[]\"), $(D\n\"$(LPAREN)]\"), $(D \"[$(RPAREN)\"), and $(D \"()\"). The default interval\nis closed to the left and open to the right. The version that does not\ntake $(D urng) uses the default generator $(D rndGen).\n\nExample:\n\n----\nRandom gen(unpredictableSeed);\n// Generate an integer in [0, 1023]\nauto a = uniform(0, 1024, gen);\n// Generate a float in [0, 1$(RPAREN)\nauto a = uniform(0.0f, 1.0f, gen);\n----\n \n",
    "line" : 1104,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "boundaries",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "\"[)\""
     },
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "comment" : "\nGenerates a number between $(D a) and $(D b). The $(D boundaries)\nparameter controls the shape of the interval (open vs. closed on\neither side). Valid values for $(D boundaries) are $(D \"[]\"), $(D\n\"$(LPAREN)]\"), $(D \"[$(RPAREN)\"), and $(D \"()\"). The default interval\nis closed to the left and open to the right. The version that does not\ntake $(D urng) uses the default generator $(D rndGen).\n\nExample:\n\n----\nRandom gen(unpredictableSeed);\n// Generate an integer in [0, 1023]\nauto a = uniform(0, 1024, gen);\n// Generate a float in [0, 1$(RPAREN)\nauto a = uniform(0.0f, 1.0f, gen);\n----\n \n",
      "line" : 1104,
      "storageClass" : [
       "auto"
      ],
      "type" : "(T1 a, T2 b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T1"
       },
       {
        "name" : "b",
        "type" : "T2"
       }
      ],
      "endline" : 1107
     }
    ]
   },
   {
    "name" : "__unittestL1109_1389",
    "kind" : "function",
    "line" : 1109,
    "endline" : 1140
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1142,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "boundaries",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "\"[)\""
     },
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     },
     {
      "name" : "UniformRandomNumberGenerator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1142,
      "storageClass" : [
       "auto"
      ],
      "type" : "(T1 a, T2 b, ref UniformRandomNumberGenerator urng)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T1"
       },
       {
        "name" : "b",
        "type" : "T2"
       },
       {
        "name" : "urng",
        "type" : "UniformRandomNumberGenerator",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1170
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1175,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "boundaries",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "\"[)\""
     },
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     },
     {
      "name" : "UniformRandomNumberGenerator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "line" : 1175,
      "storageClass" : [
       "auto"
      ],
      "type" : "(T1 a, T2 b, ref UniformRandomNumberGenerator urng)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "T1"
       },
       {
        "name" : "b",
        "type" : "T2"
       },
       {
        "name" : "urng",
        "type" : "UniformRandomNumberGenerator",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1224
     }
    ]
   },
   {
    "name" : "__unittestL1226_1390",
    "kind" : "function",
    "line" : 1226,
    "endline" : 1254
   },
   {
    "kind" : "template",
    "comment" : "\nGenerates a uniformly-distributed number in the range $(D [T.min,\nT.max]) for any integral type $(D T). If no random number generator is\npassed, uses the default $(D rndGen).\n \n",
    "line" : 1255,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "UniformRandomNumberGenerator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "comment" : "\nGenerates a uniformly-distributed number in the range $(D [T.min,\nT.max]) for any integral type $(D T). If no random number generator is\npassed, uses the default $(D rndGen).\n \n",
      "line" : 1255,
      "storageClass" : [
       "auto"
      ],
      "type" : "(ref UniformRandomNumberGenerator urng)",
      "parameters" : [
       {
        "name" : "urng",
        "type" : "UniformRandomNumberGenerator",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1271
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1274,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1274,
      "storageClass" : [
       "auto"
      ],
      "type" : "()",
      "endline" : 1278
     }
    ]
   },
   {
    "name" : "__unittestL1280_1391",
    "kind" : "function",
    "line" : 1280,
    "endline" : 1296
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a uniformly selected member of enum $(D E). If no random number\ngenerator is passed, uses the default $(D rndGen).\n \n",
    "line" : 1297,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "UniformRandomNumberGenerator",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "comment" : "\nReturns a uniformly selected member of enum $(D E). If no random number\ngenerator is passed, uses the default $(D rndGen).\n \n",
      "line" : 1297,
      "storageClass" : [
       "auto"
      ],
      "type" : "(ref UniformRandomNumberGenerator urng)",
      "parameters" : [
       {
        "name" : "urng",
        "type" : "UniformRandomNumberGenerator",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1302
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1305,
    "name" : "uniform",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "uniform",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1305,
      "storageClass" : [
       "auto"
      ],
      "type" : "()",
      "endline" : 1309
     }
    ]
   },
   {
    "name" : "__unittestL1311_1392",
    "kind" : "function",
    "line" : 1311,
    "endline" : 1328
   },
   {
    "kind" : "template",
    "comment" : "\nGenerates a uniform probability distribution of size $(D n), i.e., an\narray of size $(D n) of positive numbers of type $(D F) that sum to\n$(D 1). If $(D useThis) is provided, it is used as storage.\n \n",
    "line" : 1328,
    "name" : "uniformDistribution",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type",
      "defaultDeco" : "d"
     }
    ],
    "members" : [
     {
      "name" : "uniformDistribution",
      "kind" : "function",
      "comment" : "\nGenerates a uniform probability distribution of size $(D n), i.e., an\narray of size $(D n) of positive numbers of type $(D F) that sum to\n$(D 1). If $(D useThis) is provided, it is used as storage.\n \n",
      "line" : 1328,
      "type" : "F[](size_t n, F[] useThis = null)",
      "parameters" : [
       {
        "name" : "n",
        "type" : "size_t"
       },
       {
        "name" : "useThis",
        "type" : "F[]",
        "default" : "null"
       }
      ],
      "endline" : 1338
     }
    ]
   },
   {
    "name" : "__unittestL1340_1393",
    "kind" : "function",
    "line" : 1340,
    "endline" : 1356
   },
   {
    "kind" : "template",
    "comment" : "\nShuffles elements of $(D r) using $(D gen) as a shuffler. $(D r) must be\na random-access range with length.\n \n",
    "line" : 1356,
    "name" : "randomShuffle",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RandomGen",
      "kind" : "type",
      "default" : "Random"
     }
    ],
    "members" : [
     {
      "name" : "randomShuffle",
      "kind" : "function",
      "comment" : "\nShuffles elements of $(D r) using $(D gen) as a shuffler. $(D r) must be\na random-access range with length.\n \n",
      "line" : 1356,
      "type" : "void(Range r, ref RandomGen gen = rndGen)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "gen",
        "type" : "RandomGen",
        "storageClass" : [
         "ref"
        ],
        "default" : "rndGen"
       }
      ],
      "endline" : 1361
     }
    ]
   },
   {
    "name" : "__unittestL1363_1394",
    "kind" : "function",
    "line" : 1363,
    "endline" : 1386
   },
   {
    "kind" : "template",
    "comment" : "\nPartially shuffles the elements of $(D r) such that upon returning $(D r[0..n])\nis a random subset of $(D r) and is randomly ordered.  $(D r[n..r.length])\nwill contain the elements not in $(D r[0..n]).  These will be in an undefined\norder, but will not be random in the sense that their order after\n$(D partialShuffle) returns will not be independent of their order before\n$(D partialShuffle) was called.\n\n$(D r) must be a random-access range with length.  $(D n) must be less than\nor equal to $(D r.length).\n",
    "line" : 1386,
    "name" : "partialShuffle",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RandomGen",
      "kind" : "type",
      "default" : "Random"
     }
    ],
    "members" : [
     {
      "name" : "partialShuffle",
      "kind" : "function",
      "comment" : "\nPartially shuffles the elements of $(D r) such that upon returning $(D r[0..n])\nis a random subset of $(D r) and is randomly ordered.  $(D r[n..r.length])\nwill contain the elements not in $(D r[0..n]).  These will be in an undefined\norder, but will not be random in the sense that their order after\n$(D partialShuffle) returns will not be independent of their order before\n$(D partialShuffle) was called.\n\n$(D r) must be a random-access range with length.  $(D n) must be less than\nor equal to $(D r.length).\n",
      "line" : 1386,
      "type" : "void(Range r, size_t n, ref RandomGen gen = rndGen)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "n",
        "type" : "size_t"
       },
       {
        "name" : "gen",
        "type" : "RandomGen",
        "storageClass" : [
         "ref"
        ],
        "default" : "rndGen"
       }
      ],
      "endline" : 1395
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nRolls a dice with relative probabilities stored in $(D\nproportions). Returns the index in $(D proportions) that was chosen.\n\nExample:\n\n----\nauto x = dice(0.5, 0.5);   // x is 0 or 1 in equal proportions\nauto y = dice(50, 50);     // y is 0 or 1 in equal proportions\nauto z = dice(70, 20, 10); // z is 0 70% of the time, 1 20% of the time,\n                           // and 2 10% of the time\n----\n",
    "line" : 1410,
    "name" : "dice",
    "parameters" : [
     {
      "name" : "Rng",
      "kind" : "type"
     },
     {
      "name" : "Num",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dice",
      "kind" : "function",
      "comment" : "\nRolls a dice with relative probabilities stored in $(D\nproportions). Returns the index in $(D proportions) that was chosen.\n\nExample:\n\n----\nauto x = dice(0.5, 0.5);   // x is 0 or 1 in equal proportions\nauto y = dice(50, 50);     // y is 0 or 1 in equal proportions\nauto z = dice(70, 20, 10); // z is 0 70% of the time, 1 20% of the time,\n                           // and 2 10% of the time\n----\n",
      "line" : 1410,
      "type" : "size_t(ref Rng rnd, Num[] proportions...)",
      "parameters" : [
       {
        "name" : "rnd",
        "type" : "Rng",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "proportions",
        "type" : "Num[]"
       }
      ],
      "endline" : 1414
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1417,
    "name" : "dice",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dice",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1417,
      "type" : "size_t(ref R rnd, Range proportions)",
      "parameters" : [
       {
        "name" : "rnd",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "proportions",
        "type" : "Range"
       }
      ],
      "endline" : 1421
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1424,
    "name" : "dice",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dice",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1424,
      "type" : "size_t(Range proportions)",
      "parameters" : [
       {
        "name" : "proportions",
        "type" : "Range"
       }
      ],
      "endline" : 1428
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1431,
    "name" : "dice",
    "parameters" : [
     {
      "name" : "Num",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dice",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1431,
      "type" : "size_t(Num[] proportions...)",
      "parameters" : [
       {
        "name" : "proportions",
        "type" : "Num[]"
       }
      ],
      "endline" : 1435
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1437,
    "name" : "diceImpl",
    "parameters" : [
     {
      "name" : "Rng",
      "kind" : "type"
     },
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "diceImpl",
      "kind" : "function",
      "line" : 1437,
      "type" : "size_t(ref Rng rng, Range proportions)",
      "parameters" : [
       {
        "name" : "rng",
        "type" : "Rng",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "proportions",
        "type" : "Range"
       }
      ],
      "endline" : 1455
     }
    ]
   },
   {
    "name" : "__unittestL1457_1395",
    "kind" : "function",
    "line" : 1457,
    "endline" : 1484
   },
   {
    "kind" : "template",
    "comment" : "\nCovers a given range $(D r) in a random manner, i.e. goes through each\nelement of $(D r) once and only once, just in a random order. $(D r)\nmust be a random-access range with length.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ];\nauto rnd = Random(unpredictableSeed);\nforeach (e; randomCover(a, rnd))\n{\n    writeln(e);\n}\n----\n \n",
    "line" : 1486,
    "name" : "RandomCover",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Random",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RandomCover",
      "kind" : "struct",
      "line" : 1486,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 1487,
        "type" : "Range"
       },
       {
        "name" : "_rnd",
        "kind" : "variable",
        "line" : 1488,
        "type" : "Random"
       },
       {
        "name" : "_chosen",
        "kind" : "variable",
        "line" : 1489,
        "type" : "bool[]"
       },
       {
        "name" : "_current",
        "kind" : "variable",
        "line" : 1490,
        "deco" : "k"
       },
       {
        "name" : "_alreadyChosen",
        "kind" : "variable",
        "line" : 1491,
        "deco" : "k"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1493,
        "type" : "(Range input, Random rnd)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         },
         {
          "name" : "rnd",
          "type" : "Random"
         }
        ],
        "endline" : 1499
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 1508,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 1510
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 1512,
        "type" : "void()",
        "endline" : 1539
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 1541,
        "type" : "typeof(this)()",
        "endline" : 1547
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 1549,
        "type" : "bool()",
        "endline" : 1549
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1553,
    "name" : "randomCover",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "Random",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randomCover",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1553,
      "type" : "RandomCover!(Range, Random)(Range r, Random rnd)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "rnd",
        "type" : "Random"
       }
      ],
      "endline" : 1557
     }
    ]
   },
   {
    "name" : "__unittestL1559_1396",
    "kind" : "function",
    "line" : 1559,
    "endline" : 1606
   },
   {
    "kind" : "template",
    "comment" : "\nSelects a random subsample out of $(D r), containing exactly $(D n)\nelements. The order of elements is the same as in the original\nrange. The total length of $(D r) must be known. If $(D total) is\npassed in, the total number of sample is considered to be $(D\ntotal). Otherwise, $(D RandomSample) uses $(D r.length).\n\nIf the number of elements is not exactly $(D total), $(D\nRandomSample) throws an exception. This is because $(D total) is\nessential to computing the probability of selecting elements in the\nrange.\n\nExample:\n----\nint[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ];\n// Print 5 random elements picked off from a\nforeach (e; randomSample(a, 5))\n{\n    writeln(e);\n}\n----\n\n$(D RandomSample) implements Jeffrey Scott Vitter's Algorithm D\n(see Vitter $(WEB dx.doi.org/10.1145/358105.893, 1984), $(WEB\ndx.doi.org/10.1145/23002.23003, 1987)), which selects a sample\nof size $(D n) in O(n) steps and requiring O(n) random variates,\nregardless of the size of the data being sampled.\n",
    "line" : 1608,
    "name" : "RandomSample",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Random",
      "kind" : "type",
      "defaultDeco" : "v"
     }
    ],
    "members" : [
     {
      "name" : "RandomSample",
      "kind" : "struct",
      "line" : 1608,
      "members" : [
       {
        "name" : "_available",
        "kind" : "variable",
        "line" : 1609,
        "type" : "size_t"
       },
       {
        "name" : "_toSelect",
        "kind" : "variable",
        "line" : 1609,
        "type" : "size_t"
       },
       {
        "name" : "_alphaInverse",
        "kind" : "variable",
        "line" : 1610,
        "storageClass" : [
         "enum"
        ],
        "deco" : "t",
        "init" : "13"
       },
       {
        "name" : "_first",
        "kind" : "variable",
        "line" : 1611,
        "deco" : "b"
       },
       {
        "name" : "_algorithmA",
        "kind" : "variable",
        "line" : 1611,
        "deco" : "b"
       },
       {
        "name" : "_Vprime",
        "kind" : "variable",
        "line" : 1612,
        "deco" : "d"
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 1613,
        "type" : "R"
       },
       {
        "name" : "_index",
        "kind" : "variable",
        "line" : 1614,
        "type" : "size_t"
       },
       {
        "name" : "initialize",
        "kind" : "function",
        "line" : 1655,
        "type" : "void(R input, size_t howMany, size_t total)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "R"
         },
         {
          "name" : "howMany",
          "type" : "size_t"
         },
         {
          "name" : "total",
          "type" : "size_t"
         }
        ],
        "endline" : 1662
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n   Range primitives.\n",
        "line" : 1667,
        "type" : "const bool()",
        "endline" : 1670
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 1673,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 1696
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 1699,
        "type" : "void()",
        "endline" : 1706
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 1709,
        "type" : "typeof(this)()",
        "endline" : 1714
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 1717,
        "type" : "size_t()",
        "endline" : 1720
       },
       {
        "name" : "index",
        "kind" : "function",
        "comment" : "\nReturns the index of the visited record.\n \n",
        "line" : 1725,
        "type" : "size_t()",
        "endline" : 1728
       },
       {
        "name" : "skipA",
        "kind" : "function",
        "line" : 1734,
        "type" : "size_t()",
        "endline" : 1773
       },
       {
        "name" : "newVprime",
        "kind" : "function",
        "line" : 1778,
        "type" : "double(size_t remaining)",
        "parameters" : [
         {
          "name" : "remaining",
          "type" : "size_t"
         }
        ],
        "endline" : 1790
       },
       {
        "name" : "skip",
        "kind" : "function",
        "line" : 1804,
        "type" : "size_t()",
        "endline" : 1902
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 1904,
        "type" : "void()",
        "endline" : 1914
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1918,
    "name" : "randomSample",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randomSample",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1918,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R r, size_t n, size_t total)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       },
       {
        "name" : "total",
        "type" : "size_t"
       }
      ],
      "endline" : 1922
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1925,
    "name" : "randomSample",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randomSample",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1925,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 1929
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1932,
    "name" : "randomSample",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Random",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randomSample",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1932,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R r, size_t n, size_t total, Random gen)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       },
       {
        "name" : "total",
        "type" : "size_t"
       },
       {
        "name" : "gen",
        "type" : "Random"
       }
      ],
      "endline" : 1936
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1939,
    "name" : "randomSample",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Random",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randomSample",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1939,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R r, size_t n, Random gen)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       },
       {
        "name" : "gen",
        "type" : "Random"
       }
      ],
      "endline" : 1943
     }
    ]
   },
   {
    "name" : "__unittestL1945_1397",
    "kind" : "function",
    "line" : 1945,
    "endline" : 1974
   }
  ]
 },
 {
  "name" : "std.range",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/range.d",
  "comment" : "\nThis module defines the notion of a range. Ranges generalize the concept of\narrays, lists, or anything that involves sequential access. This abstraction\nenables the same set of algorithms (see $(LINK2 std_algorithm.html,\nstd.algorithm)) to be used with a vast variety of different concrete types. For\nexample, a linear search algorithm such as $(LINK2 std_algorithm.html#find,\nstd.algorithm.find) works not just for arrays, but for linked-lists, input\nfiles, incoming network data, etc.\n\nFor more detailed information about the conceptual aspect of ranges and the\nmotivation behind them, see Andrei Alexandrescu's article\n$(LINK2 http://www.informit.com/articles/printerfriendly.aspx?p=1407357&rll=1,\n$(I On Iteration)).\n\nThis module defines several templates for testing whether a given object is a\n_range, and what kind of _range it is:\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF isInputRange)))\n        $(TD Tests if something is an $(I input _range), defined to be\n        something from which one can sequentially read data using the\n        primitives $(D front), $(D popFront), and $(D empty).\n    ))\n    $(TR $(TD $(D $(LREF isOutputRange)))\n        $(TD Tests if something is an $(I output _range), defined to be\n        something to which one can sequentially write data using the $(D $(LREF\n        put)) primitive.\n    ))\n    $(TR $(TD $(D $(LREF isForwardRange)))\n        $(TD Tests if something is a $(I forward _range), defined to be an\n        input _range with the additional capability that one can save one's\n        current position with the $(D save) primitive, thus allowing one to\n        iterate over the same _range multiple times.\n    ))\n    $(TR $(TD $(D $(LREF isBidirectionalRange)))\n        $(TD Tests if something is a $(I bidirectional _range), that is, a\n        forward _range that allows reverse traversal using the primitives $(D\n        back) and $(D popBack).\n    ))\n    $(TR $(TD $(D $(LREF isRandomAccessRange)))\n        $(TD Tests if something is a $(I random access _range), which is a\n        bidirectional _range that also supports the array subscripting\n        operation via the primitive $(D opIndex).\n    ))\n)\n\nA number of templates are provided that test for various _range capabilities:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF hasMobileElements)))\n        $(TD Tests if a given _range's elements can be moved around using the\n        primitives $(D moveFront), $(D moveBack), or $(D moveAt).\n    ))\n    $(TR $(TD $(D $(LREF ElementType)))\n        $(TD Returns the element type of a given _range.\n    ))\n    $(TR $(TD $(D $(LREF ElementEncodingType)))\n        $(TD Returns the encoding element type of a given _range.\n    ))\n    $(TR $(TD $(D $(LREF hasSwappableElements)))\n        $(TD Tests if a _range is a forward _range with swappable elements.\n    ))\n    $(TR $(TD $(D $(LREF hasAssignableElements)))\n        $(TD Tests if a _range is a forward _range with mutable elements.\n    ))\n    $(TR $(TD $(D $(LREF hasLvalueElements)))\n        $(TD Tests if a _range is a forward _range with elements that can be\n        passed by reference and have their address taken.\n    ))\n    $(TR $(TD $(D $(LREF hasLength)))\n        $(TD Tests if a given _range has the $(D length) attribute.\n    ))\n    $(TR $(TD $(D $(LREF isInfinite)))\n        $(TD Tests if a given _range is an $(I infinite _range).\n    ))\n    $(TR $(TD $(D $(LREF hasSlicing)))\n        $(TD Tests if a given _range supports the array slicing operation $(D\n        R[x..y]).\n    ))\n    $(TR $(TD $(D $(LREF walkLength)))\n        $(TD Computes the length of any _range in O(n) time.\n    ))\n)\n\nA rich set of _range creation and composition templates are provided that let\nyou construct new ranges out of existing ranges:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF retro)))\n        $(TD Iterates a bidirectional _range backwards.\n    ))\n    $(TR $(TD $(D $(LREF stride)))\n        $(TD Iterates a _range with stride $(I n).\n    ))\n    $(TR $(TD $(D $(LREF chain)))\n        $(TD Concatenates several ranges into a single _range.\n    ))\n    $(TR $(TD $(D $(LREF roundRobin)))\n        $(TD Given $(I n) ranges, creates a new _range that return the $(I n)\n        first elements of each _range, in turn, then the second element of each\n        _range, and so on, in a round-robin fashion.\n    ))\n    $(TR $(TD $(D $(LREF radial)))\n        $(TD Given a random-access _range and a starting point, creates a\n        _range that alternately returns the next left and next right element to\n        the starting point.\n    ))\n    $(TR $(TD $(D $(LREF take)))\n        $(TD Creates a sub-_range consisting of only up to the first $(I n)\n        elements of the given _range.\n    ))\n    $(TR $(TD $(D $(LREF takeExactly)))\n        $(TD Like $(D take), but assumes the given _range actually has $(I n)\n        elements, and therefore also defines the $(D length) property.\n    ))\n    $(TR $(TD $(D $(LREF takeOne)))\n        $(TD Creates a random-access _range consisting of exactly the first\n        element of the given _range.\n    ))\n    $(TR $(TD $(D $(LREF takeNone)))\n        $(TD Creates a random-access _range consisting of zero elements of the\n        given _range.\n    ))\n    $(TR $(TD $(D $(LREF drop)))\n        $(TD Creates the _range that results from discarding the first $(I n)\n        elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF dropExactly)))\n        $(TD Creates the _range that results from discarding exactly $(I n)\n        of the first elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF dropOne)))\n        $(TD Creates the _range that results from discarding\n        the first elements from the given _range.\n    ))\n    $(TR $(TD $(D $(LREF repeat)))\n        $(TD Creates a _range that consists of a single element repeated $(I n)\n        times, or an infinite _range repeating that element indefinitely.\n    ))\n    $(TR $(TD $(D $(LREF cycle)))\n        $(TD Creates an infinite _range that repeats the given forward _range\n        indefinitely. Good for implementing circular buffers.\n    ))\n    $(TR $(TD $(D $(LREF zip)))\n        $(TD Given $(I n) _ranges, creates a _range that successively returns a\n        tuple of all the first elements, a tuple of all the second elements,\n        etc.\n    ))\n    $(TR $(TD $(D $(LREF lockstep)))\n        $(TD Iterates $(I n) _ranges in lockstep, for use in a $(D foreach)\n        loop. Similar to $(D zip), except that $(D lockstep) is designed\n        especially for $(D foreach) loops.\n    ))\n    $(TR $(TD $(D $(LREF recurrence)))\n        $(TD Creates a forward _range whose values are defined by a\n        mathematical recurrence relation.\n    ))\n    $(TR $(TD $(D $(LREF sequence)))\n        $(TD Similar to $(D recurrence), except that a random-access _range is\n        created.\n    ))\n    $(TR $(TD $(D $(LREF iota)))\n        $(TD Creates a _range consisting of numbers between a starting point\n        and ending point, spaced apart by a given interval.\n    ))\n    $(TR $(TD $(D $(LREF frontTransversal)))\n        $(TD Creates a _range that iterates over the first elements of the\n        given ranges.\n    ))\n    $(TR $(TD $(D $(LREF transversal)))\n        $(TD Creates a _range that iterates over the $(I n)'th elements of the\n        given random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF indexed)))\n        $(TD Creates a _range that offers a view of a given _range as though\n        its elements were reordered according to a given _range of indices.\n    ))\n    $(TR $(TD $(D $(LREF chunks)))\n        $(TD Creates a _range that returns fixed-size chunks of the original\n        _range.\n    ))\n    $(TR $(TD $(D $(LREF only)))\n        $(TD Creates a _range that iterates over a single value.\n    ))\n)\n\nThese _range-construction tools are implemented using templates; but sometimes\nan object-based interface for ranges is needed. For this purpose, this module\nprovides a number of object and $(D interface) definitions that can be used to\nwrap around _range objects created by the above templates:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF InputRange)))\n        $(TD Wrapper for input ranges.\n    ))\n    $(TR $(TD $(D $(LREF InputAssignable)))\n        $(TD Wrapper for input ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF ForwardRange)))\n        $(TD Wrapper for forward ranges.\n    ))\n    $(TR $(TD $(D $(LREF ForwardAssignable)))\n        $(TD Wrapper for forward ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF BidirectionalRange)))\n        $(TD Wrapper for bidirectional ranges.\n    ))\n    $(TR $(TD $(D $(LREF BidirectionalAssignable)))\n        $(TD Wrapper for bidirectional ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessFinite)))\n        $(TD Wrapper for finite random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessAssignable)))\n        $(TD Wrapper for finite random-access ranges with assignable elements.\n    ))\n    $(TR $(TD $(D $(LREF RandomAccessInfinite)))\n        $(TD Wrapper for infinite random-access ranges.\n    ))\n    $(TR $(TD $(D $(LREF OutputRange)))\n        $(TD Wrapper for output ranges.\n    ))\n    $(TR $(TD $(D $(LREF OutputRangeObject)))\n        $(TD Class that implements the $(D OutputRange) interface and wraps the\n        $(D put) methods in virtual functions.\n    ))\n    $(TR $(TD $(D $(LREF InputRangeObject)))\n        $(TD Class that implements the $(D InputRange) interface and wraps the\n        input _range methods in virtual functions.\n    ))\n)\n\nRanges whose elements are sorted afford better efficiency with certain\noperations. For this, the $(D $(LREF assumeSorted)) function can be used to\nconstruct a $(D $(LREF SortedRange)) from a pre-sorted _range. The $(LINK2\nstd_algorithm.html#sort, $(D std.algorithm.sort)) function also conveniently\nreturns a $(D SortedRange). $(D SortedRange) objects provide some additional\n_range operations that take advantage of the fact that the _range is sorted.\n\nFinally, this module also defines some convenience functions for\nmanipulating ranges:\n\n$(BOOKTABLE ,\n    $(TR $(TD $(D $(LREF popFrontN)))\n        $(TD Advances a given _range by up to $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popBackN)))\n        $(TD Advances a given bidirectional _range from the right by up to\n        $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popFrontExactly)))\n        $(TD Advances a given _range by up exactly $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF popBackExactly)))\n        $(TD Advances a given bidirectional _range from the right by exactly\n        $(I n) elements.\n    ))\n    $(TR $(TD $(D $(LREF moveFront)))\n        $(TD Removes the front element of a _range.\n    ))\n    $(TR $(TD $(D $(LREF moveBack)))\n        $(TD Removes the back element of a bidirectional _range.\n    ))\n    $(TR $(TD $(D $(LREF moveAt)))\n        $(TD Removes the $(I i)'th element of a random-access _range.\n    ))\n)\n\nSource: $(PHOBOSSRC std/_range.d)\n\nMacros:\n\nWIKI = Phobos/StdRange\n\nCopyright: Copyright by authors 2008-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB erdani.com, Andrei Alexandrescu), David Simcha,\nand Jonathan M Davis. Credit for some of the ideas in building this module goes\nto $(WEB fantascienza.net/leonardo/so/, Leonardo Maffi).\n \n",
  "members" : [
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 286
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 287,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 287,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 288,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 288,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 288,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 288,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 289,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 289,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 289,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 289,
    "protection" : "private"
   },
   {
    "name" : "dummyRanges",
    "kind" : "variable",
    "line" : 460,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"\\x0a    // Used with the dummy ranges for testing higher order ranges.\\x0a    enum RangeType\\x0a    {\\x0a        Input,\\x0a        Forward,\\x0a        Bidirectional,\\x0a        Random\\x0a    }\\x0a\\x0a    enum Length\\x0a    {\\x0a        Yes,\\x0a        No\\x0a    }\\x0a\\x0a    enum ReturnBy\\x0a    {\\x0a        Reference,\\x0a        Value\\x0a    }\\x0a\\x0a    // Range that's useful for testing other higher order ranges,\\x0a    // can be parametrized with attributes.  It just dumbs down an array of\\x0a    // numbers 1..10.\\x0a    struct DummyRange(ReturnBy _r, Length _l, RangeType _rt)\\x0a    {\\x0a        // These enums are so that the template params are visible outside\\x0a        // this instantiation.\\x0a        enum r = _r;\\x0a        enum l = _l;\\x0a        enum rt = _rt;\\x0a\\x0a        uint[] arr = [1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U];\\x0a\\x0a        void reinit()\\x0a        {\\x0a            // Workaround for DMD bug 4378\\x0a            arr = [1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U];\\x0a        }\\x0a\\x0a        void popFront()\\x0a        {\\x0a            arr = arr[1..$];\\x0a        }\\x0a\\x0a        @property bool empty() const\\x0a        {\\x0a            return arr.length == 0;\\x0a        }\\x0a\\x0a        static if(r == ReturnBy.Reference)\\x0a        {\\x0a            @property ref inout(uint) front() inout\\x0a            {\\x0a                return arr[0];\\x0a            }\\x0a\\x0a            @property void front(uint val)\\x0a            {\\x0a                arr[0] = val;\\x0a            }\\x0a        }\\x0a        else\\x0a        {\\x0a            @property uint front() const\\x0a            {\\x0a                return arr[0];\\x0a            }\\x0a        }\\x0a\\x0a        static if(rt >= RangeType.Forward)\\x0a        {\\x0a            @property typeof(this) save()\\x0a            {\\x0a                return this;\\x0a            }\\x0a        }\\x0a\\x0a        static if(rt >= RangeType.Bidirectional)\\x0a        {\\x0a            void popBack()\\x0a            {\\x0a                arr = arr[0..$ - 1];\\x0a            }\\x0a\\x0a            static if(r == ReturnBy.Reference)\\x0a            {\\x0a                @property ref inout(uint) back() inout\\x0a                {\\x0a                    return arr[$ - 1];\\x0a                }\\x0a\\x0a                @property void back(uint val)\\x0a                {\\x0a                    arr[$ - 1] = val;\\x0a                }\\x0a\\x0a            }\\x0a            else\\x0a            {\\x0a                @property uint back() const\\x0a                {\\x0a                    return arr[$ - 1];\\x0a                }\\x0a            }\\x0a        }\\x0a\\x0a        static if(rt >= RangeType.Random)\\x0a        {\\x0a            static if(r == ReturnBy.Reference)\\x0a            {\\x0a                ref inout(uint) opIndex(size_t index) inout\\x0a                {\\x0a                    return arr[index];\\x0a                }\\x0a\\x0a                void opIndexAssign(uint val, size_t index)\\x0a                {\\x0a                    arr[index] = val;\\x0a                }\\x0a            }\\x0a            else\\x0a            {\\x0a                uint opIndex(size_t index) const\\x0a                {\\x0a                    return arr[index];\\x0a                }\\x0a            }\\x0a\\x0a            typeof(this) opSlice(size_t lower, size_t upper)\\x0a            {\\x0a                auto ret = this;\\x0a                ret.arr = arr[lower..upper];\\x0a                return ret;\\x0a            }\\x0a        }\\x0a\\x0a        static if(l == Length.Yes)\\x0a        {\\x0a            @property size_t length() const\\x0a            {\\x0a                return arr.length;\\x0a            }\\x0a\\x0a            alias length opDollar;\\x0a        }\\x0a    }\\x0a\\x0a    enum dummyLength = 10;\\x0a\\x0a    alias TypeTuple!(\\x0a        DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Forward),\\x0a        DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Bidirectional),\\x0a        DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Random),\\x0a        DummyRange!(ReturnBy.Reference, Length.No, RangeType.Forward),\\x0a        DummyRange!(ReturnBy.Reference, Length.No, RangeType.Bidirectional),\\x0a        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Input),\\x0a        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Forward),\\x0a        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Bidirectional),\\x0a        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Random),\\x0a        DummyRange!(ReturnBy.Value, Length.No, RangeType.Input),\\x0a        DummyRange!(ReturnBy.Value, Length.No, RangeType.Forward),\\x0a        DummyRange!(ReturnBy.Value, Length.No, RangeType.Bidirectional)\\x0a    ) AllDummyRanges;\\x0a\\x0a\""
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is an input range. An input range must\ndefine the primitives $(D empty), $(D popFront), and $(D front). The\nfollowing code should compile for any input range.\n\n----\nR r;              // can define a range object\nif (r.empty) {}   // can test for empty\nr.popFront();     // can invoke popFront()\nauto h = r.front; // can get the front of the range of non-void type\n----\n\nThe semantics of an input range (not checkable during compilation) are\nassumed to be the following ($(D r) is an object of type $(D R)):\n\n$(UL $(LI $(D r.empty) returns $(D false) iff there is more data\navailable in the range.)  $(LI $(D r.front) returns the current\nelement in the range. It may return by value or by reference. Calling\n$(D r.front) is allowed only if calling $(D r.empty) has, or would\nhave, returned $(D false).) $(LI $(D r.popFront) advances to the next\nelement in the range. Calling $(D r.popFront) is allowed only if\ncalling $(D r.empty) has, or would have, returned $(D false).))\n \n",
    "line" : 516,
    "name" : "isInputRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isInputRange",
      "kind" : "variable",
      "line" : 518,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof((int = 0)\n{\nR r = void;\nif (r.empty)\n{\n}\nr.popFront();\nauto h = r.front;\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL528_1399",
    "kind" : "function",
    "line" : 528,
    "endline" : 574
   },
   {
    "kind" : "template",
    "comment" : "\nOutputs $(D e) to $(D r). The exact effect is dependent upon the two\ntypes. Several cases are accepted, as described below. The code snippets\nare attempted in order, and the first to compile \"wins\" and gets\nevaluated.\n\n$(BOOKTABLE ,\n$(TR $(TH Code Snippet) $(TH Scenario\n))\n$(TR $(TD $(D r.put(e);)) $(TD $(D R) specifically defines a method\n    $(D put) accepting an $(D E).\n))\n$(TR $(TD $(D r.put([ e ]);)) $(TD $(D R) specifically defines a\n    method $(D put) accepting an $(D E[]).\n))\n$(TR $(TD $(D r.front = e; r.popFront();)) $(TD $(D R) is an input\n    range and $(D e) is assignable to $(D r.front).\n))\n$(TR $(TD $(D for (; !e.empty; e.popFront()) put(r, e.front);)) $(TD\n    Copying range $(D E) to range $(D R).\n))\n$(TR $(TD $(D r(e);)) $(TD $(D R) is e.g. a delegate accepting an $(D\n    E).\n))\n$(TR $(TD $(D r([ e ]);)) $(TD $(D R) is e.g. a $(D delegate)\n    accepting an $(D E[]).\n))\n)\n \n",
    "line" : 574,
    "name" : "put",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "put",
      "kind" : "function",
      "comment" : "\nOutputs $(D e) to $(D r). The exact effect is dependent upon the two\ntypes. Several cases are accepted, as described below. The code snippets\nare attempted in order, and the first to compile \"wins\" and gets\nevaluated.\n\n$(BOOKTABLE ,\n$(TR $(TH Code Snippet) $(TH Scenario\n))\n$(TR $(TD $(D r.put(e);)) $(TD $(D R) specifically defines a method\n    $(D put) accepting an $(D E).\n))\n$(TR $(TD $(D r.put([ e ]);)) $(TD $(D R) specifically defines a\n    method $(D put) accepting an $(D E[]).\n))\n$(TR $(TD $(D r.front = e; r.popFront();)) $(TD $(D R) is an input\n    range and $(D e) is assignable to $(D r.front).\n))\n$(TR $(TD $(D for (; !e.empty; e.popFront()) put(r, e.front);)) $(TD\n    Copying range $(D E) to range $(D R).\n))\n$(TR $(TD $(D r(e);)) $(TD $(D R) is e.g. a delegate accepting an $(D\n    E).\n))\n$(TR $(TD $(D r([ e ]);)) $(TD $(D R) is e.g. a $(D delegate)\n    accepting an $(D E[]).\n))\n)\n \n",
      "line" : 574,
      "type" : "void(ref R r, E e)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "e",
        "type" : "E"
       }
      ],
      "endline" : 614
     }
    ]
   },
   {
    "name" : "__unittestL616_1400",
    "kind" : "function",
    "line" : 616,
    "endline" : 628
   },
   {
    "name" : "__unittestL628_1401",
    "kind" : "function",
    "line" : 628,
    "endline" : 637
   },
   {
    "name" : "__unittestL637_1402",
    "kind" : "function",
    "line" : 637,
    "endline" : 645
   },
   {
    "name" : "__unittestL645_1403",
    "kind" : "function",
    "line" : 645,
    "endline" : 652
   },
   {
    "name" : "__unittestL652_1404",
    "kind" : "function",
    "line" : 652,
    "endline" : 666
   },
   {
    "name" : "__unittestL666_1405",
    "kind" : "function",
    "line" : 666,
    "endline" : 676
   },
   {
    "name" : "__unittestL676_1406",
    "kind" : "function",
    "line" : 676,
    "endline" : 700
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is an output range for elements of type\n$(D E). An output range is defined functionally as a range that\nsupports the operation $(D put(r, e)) as defined above.\n \n",
    "line" : 700,
    "name" : "isOutputRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isOutputRange",
      "kind" : "variable",
      "line" : 702,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof((int = 0)\n{\nR r = void;\nE e;\nput(r, e);\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL711_1408",
    "kind" : "function",
    "line" : 711,
    "endline" : 758
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is a forward range. A forward range is an\ninput range $(D r) that can save \"checkpoints\" by saving $(D r.save)\nto another value of type $(D R). Notable examples of input ranges that\nare $(I not) forward ranges are file/socket ranges; copying such a\nrange will not save the position in the stream, and they most likely\nreuse an internal buffer as the entire stream does not sit in\nmemory. Subsequently, advancing either the original or the copy will\nadvance the stream, so the copies are not independent.\n\nThe following code should compile for any forward range.\n\n----\nstatic assert(isInputRange!R);\nR r1;\nstatic assert (is(typeof(r1.save) == R));\n----\n\nSaving a range is not duplicating it; in the example above, $(D r1)\nand $(D r2) still refer to the same underlying data. They just\nnavigate that data independently.\n\nThe semantics of a forward range (not checkable during compilation)\nare the same as for an input range, with the additional requirement\nthat backtracking must be possible by saving a copy of the range\nobject with $(D save) and using it later.\n \n",
    "line" : 758,
    "name" : "isForwardRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isForwardRange",
      "kind" : "variable",
      "line" : 760,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isInputRange!(R) && is(typeof((int = 0)\n{\nR r1 = void;\nstatic assert(is(typeof(r1.save) == R));\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL768_1410",
    "kind" : "function",
    "line" : 768,
    "endline" : 798
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is a bidirectional range. A bidirectional\nrange is a forward range that also offers the primitives $(D back) and\n$(D popBack). The following code should compile for any bidirectional\nrange.\n\n----\nR r;\nstatic assert(isForwardRange!R);           // is forward range\nr.popBack();                               // can invoke popBack\nauto t = r.back;                           // can get the back of the range\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w))); // same type for front and back\n----\n\nThe semantics of a bidirectional range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)):\n\n$(UL $(LI $(D r.back) returns (possibly a reference to) the last\nelement in the range. Calling $(D r.back) is allowed only if calling\n$(D r.empty) has, or would have, returned $(D false).))\n \n",
    "line" : 798,
    "name" : "isBidirectionalRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isBidirectionalRange",
      "kind" : "variable",
      "line" : 800,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isForwardRange!(R) && is(typeof((int = 0)\n{\nR r = void;\nr.popBack();\nauto t = r.back;\nauto w = r.front;\nstatic assert(is(typeof(t) == typeof(w)));\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL811_1412",
    "kind" : "function",
    "line" : 811,
    "endline" : 879
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is a random-access range. A random-access\nrange is a bidirectional range that also offers the primitive $(D\nopIndex), OR an infinite forward range that offers $(D opIndex). In\neither case, the range must either offer $(D length) or be\ninfinite. The following code should compile for any random-access\nrange.\n\n----\n// range is finite and bidirectional or infinite and forward.\nstatic assert(isBidirectionalRange!R ||\n              isForwardRange!R && isInfinite!R);\n\nR r = void;\nauto e = r[1]; // can index\nstatic assert(is(typeof(e) == typeof(r.front))); // same type for indexed and front\nstatic assert(!isNarrowString!R); // narrow strings cannot be indexed as ranges\nstatic assert(hasLength!R || isInfinite!R); // must have length or be infinite\n\n// $ must work as it does with arrays if opIndex works with $\nstatic if(is(typeof(r[$])))\n{\n    static assert(is(typeof(r.front) == typeof(r[$])));\n\n    // $ - 1 doesn't make sense with infinite ranges but needs to work\n    // with finite ones.\n    static if(!isInfinite!R)\n        static assert(is(typeof(r.front) == typeof(r[$ - 1])));\n}\n----\n\nThe semantics of a random-access range (not checkable during\ncompilation) are assumed to be the following ($(D r) is an object of\ntype $(D R)): $(UL $(LI $(D r.opIndex(n)) returns a reference to the\n$(D n)th element in the range.))\n\nAlthough $(D char[]) and $(D wchar[]) (as well as their qualified\nversions including $(D string) and $(D wstring)) are arrays, $(D\nisRandomAccessRange) yields $(D false) for them because they use\nvariable-length encodings (UTF-8 and UTF-16 respectively). These types\nare bidirectional ranges only.\n \n",
    "line" : 879,
    "name" : "isRandomAccessRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isRandomAccessRange",
      "kind" : "variable",
      "line" : 881,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof((int = 0)\n{\nstatic assert(isBidirectionalRange!(R) || isForwardRange!(R) && isInfinite!(R));\nR r = void;\nauto e = r[1];\nstatic assert(is(typeof(e) == typeof(r.front)));\nstatic assert(!isNarrowString!(R));\nstatic assert(hasLength!(R) || isInfinite!(R));\nstatic if (is(typeof(r[__dollar])))\n{\nstatic assert(is(typeof(r.front) == typeof(r[__dollar])));\nstatic if (!isInfinite!(R))\n{\nstatic assert(is(typeof(r.front) == typeof(r[__dollar - 1])));\n}\n\n}\n\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL902_1414",
    "kind" : "function",
    "line" : 902,
    "endline" : 940
   },
   {
    "name" : "__unittestL940_1415",
    "kind" : "function",
    "line" : 940,
    "endline" : 978
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) iff $(D R) supports the $(D moveFront) primitive,\nas well as $(D moveBack) and $(D moveAt) if it's a bidirectional or\nrandom access range.  These may be explicitly implemented, or may work\nvia the default behavior of the module level functions $(D moveFront)\nand friends.\n \n",
    "line" : 978,
    "name" : "hasMobileElements",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasMobileElements",
      "kind" : "variable",
      "line" : 980,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof((int = 0)\n{\nR r = void;\nreturn moveFront(r);\n}\n)) && (!isBidirectionalRange!(R) || is(typeof((int = 0)\n{\nR r = void;\nreturn moveBack(r);\n}\n))) && (!isRandomAccessRange!(R) || is(typeof((int = 0)\n{\nR r = void;\nreturn moveAt(r, 0);\n}\n)))"
     }
    ]
   },
   {
    "name" : "__unittestL1000_1419",
    "kind" : "function",
    "line" : 1000,
    "endline" : 1022
   },
   {
    "kind" : "template",
    "comment" : "\nThe element type of $(D R). $(D R) does not have to be a range. The\nelement type is determined as the type yielded by $(D r.front) for an\nobject $(D r) of type $(D R). For example, $(D ElementType!(T[])) is\n$(D T) if $(D T[]) isn't a narrow string; if it is, the element type is\n$(D dchar). If $(D R) doesn't have $(D front), $(D ElementType!R) is\n$(D void).\n \n",
    "line" : 1022,
    "name" : "ElementType",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1030_1421",
    "kind" : "function",
    "line" : 1030,
    "endline" : 1051
   },
   {
    "kind" : "template",
    "comment" : "\nThe encoding element type of $(D R). For narrow strings ($(D char[]),\n$(D wchar[]) and their qualified variants including $(D string) and\n$(D wstring)), $(D ElementEncodingType) is the character type of the\nstring. For all other types, $(D ElementEncodingType) is the same as\n$(D ElementType).\n \n",
    "line" : 1051,
    "name" : "ElementEncodingType",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1059_1423",
    "kind" : "function",
    "line" : 1059,
    "endline" : 1088
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is a forward range and has swappable\nelements. The following code should compile for any range\nwith swappable elements.\n\n----\nR r;\nstatic assert(isForwardRange!(R));   // range is forward\nswap(r.front, r.front);              // can swap elements of the range\n----\n \n",
    "line" : 1088,
    "name" : "hasSwappableElements",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasSwappableElements",
      "kind" : "variable",
      "line" : 1090,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isForwardRange!(R) && is(typeof((int = 0)\n{\nR r = void;\nswap(r.front, r.front);\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL1098_1425",
    "kind" : "function",
    "line" : 1098,
    "endline" : 1119
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is a forward range and has mutable\nelements. The following code should compile for any range\nwith assignable elements.\n\n----\nR r;\nstatic assert(isForwardRange!R);  // range is forward\nauto e = r.front;\nr.front = e;                      // can assign elements of the range\n----\n \n",
    "line" : 1119,
    "name" : "hasAssignableElements",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasAssignableElements",
      "kind" : "variable",
      "line" : 1121,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isForwardRange!(R) && is(typeof((int = 0)\n{\nR r = void;\nstatic assert(isForwardRange!(R));\nauto e = r.front;\nr.front = e;\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL1131_1427",
    "kind" : "function",
    "line" : 1131,
    "endline" : 1143
   },
   {
    "kind" : "template",
    "comment" : "\nTests whether $(D R) has lvalue elements.  These are defined as elements that\ncan be passed by reference and have their address taken.\n",
    "line" : 1143,
    "name" : "hasLvalueElements",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasLvalueElements",
      "kind" : "variable",
      "line" : 1145,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof((int = 0)\n{\nvoid checkRef(ref ElementType!(R) stuff)\n{\n}\n\nR r = void;\nstatic assert(is(typeof(checkRef(r.front))));\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL1154_1429",
    "kind" : "function",
    "line" : 1154,
    "endline" : 1186
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) has a $(D length) member that returns an\nintegral type. $(D R) does not have to be a range. Note that $(D\nlength) is an optional primitive as no range must implement it. Some\nranges do not store their length explicitly, some cannot compute it\nwithout actually exhausting the range (e.g. socket streams), and some\nother ranges may be infinite.\n\nAlthough narrow string types ($(D char[]), $(D wchar[]), and their\nqualified derivatives) do define a $(D length) property, $(D\nhasLength) yields $(D false) for them. This is because a narrow\nstring's length does not reflect the number of characters, but instead\nthe number of encoding units, and as such is not useful with\nrange-oriented algorithms.\n \n",
    "line" : 1186,
    "name" : "hasLength",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasLength",
      "kind" : "variable",
      "line" : 1188,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "!isNarrowString!(R) && is(typeof((int = 0)\n{\nR r = void;\nstatic assert(is(typeof(r.length) : ulong));\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL1196_1431",
    "kind" : "function",
    "line" : 1196,
    "endline" : 1225
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) is an infinite input range. An\ninfinite input range is an input range that has a statically-defined\nenumerated member called $(D empty) that is always $(D false),\nfor example:\n\n----\nstruct MyInfiniteRange\n{\n    enum bool empty = false;\n    ...\n}\n----\n \n",
    "line" : 1225,
    "name" : "isInfinite",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1233_1433",
    "kind" : "function",
    "line" : 1233,
    "endline" : 1286
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if $(D R) offers a slicing operator with integral boundaries\nthat returns a forward range type.\n\nFor finite ranges, the result of $(D opSlice) must be of the same type as the\noriginal range type. If the range defines $(D opDollar), then it must support\nsubtraction.\n\nFor infinite ranges, when $(I not) using $(D opDollar), the result of\n$(D opSlice) must be the result of $(LREF take) or $(LREF takeExactly) on the\noriginal range (they both return the same type for infinite ranges). However,\nwhen using $(D opDollar), the result of $(D opSlice) must be that of the\noriginal range type.\n\nThe following code must compile for $(D hasSlicing) to be $(D true):\n\n----\nR r = void;\n\nstatic if(isInfinite!R)\n    typeof(take(r, 1)) s = r[1 .. 2];\nelse\n{\n    static assert(is(typeof(r[1 .. 2]) == R));\n    R s = r[1 .. 2];\n}\n\ns = r[1 .. 2];\n\nstatic if(is(typeof(r[0 .. $])))\n{\n    static assert(is(typeof(r[0 .. $]) == R));\n    R t = r[0 .. $];\n    t = r[0 .. $];\n\n    static if(!isInfinite!R)\n    {\n        static assert(is(typeof(r[0 .. $ - 1]) == R));\n        R u = r[0 .. $ - 1];\n        u = r[0 .. $ - 1];\n    }\n}\n\nstatic assert(isForwardRange!(typeof(r[1 .. 2])));\nstatic assert(hasLength!(typeof(r[1 .. 2])));\n----\n \n",
    "line" : 1286,
    "name" : "hasSlicing",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "hasSlicing",
      "kind" : "variable",
      "line" : 1288,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isForwardRange!(R) && !isNarrowString!(R) && is(typeof((int = 0)\n{\nR r = void;\nstatic if (isInfinite!(R))\n{\ntypeof(take(r, 1)) s = r[1..2];\n}\nelse\n{\nstatic assert(is(typeof(r[1..2]) == R));\nR s = r[1..2];\n}\n\ns = r[1..2];\nstatic if (is(typeof(r[0..__dollar])))\n{\nstatic assert(is(typeof(r[0..__dollar]) == R));\nR t = r[0..__dollar];\nt = r[0..__dollar];\nstatic if (!isInfinite!(R))\n{\nstatic assert(is(typeof(r[0..__dollar - 1]) == R));\nR u = r[0..__dollar - 1];\nu = r[0..__dollar - 1];\n}\n\n}\n\nstatic assert(isForwardRange!(typeof(r[1..2])));\nstatic assert(hasLength!(typeof(r[1..2])));\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL1322_1435",
    "kind" : "function",
    "line" : 1322,
    "endline" : 1385
   },
   {
    "kind" : "template",
    "comment" : "\nThis is a best-effort implementation of $(D length) for any kind of\nrange.\n\nIf $(D hasLength!Range), simply returns $(D range.length) without\nchecking $(D upTo) (when specified).\n\nOtherwise, walks the range through its length and returns the number\nof elements seen. Performes $(BIGOH n) evaluations of $(D range.empty)\nand $(D range.popFront()), where $(D n) is the effective length of $(D\nrange).\n\nThe $(D upTo) parameter is useful to \"cut the losses\" in case\nthe interest is in seeing whether the range has at least some number\nof elements. If the parameter $(D upTo) is specified, stops if $(D\nupTo) steps have been taken and returns $(D upTo).\n\nInfinite ranges are compatible, provided the parameter $(D upTo) is\nspecified, in which case the implementation simply returns upTo.\n \n",
    "line" : 1385,
    "name" : "walkLength",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "walkLength",
      "kind" : "function",
      "comment" : "\nThis is a best-effort implementation of $(D length) for any kind of\nrange.\n\nIf $(D hasLength!Range), simply returns $(D range.length) without\nchecking $(D upTo) (when specified).\n\nOtherwise, walks the range through its length and returns the number\nof elements seen. Performes $(BIGOH n) evaluations of $(D range.empty)\nand $(D range.popFront()), where $(D n) is the effective length of $(D\nrange).\n\nThe $(D upTo) parameter is useful to \"cut the losses\" in case\nthe interest is in seeing whether the range has at least some number\nof elements. If the parameter $(D upTo) is specified, stops if $(D\nupTo) steps have been taken and returns $(D upTo).\n\nInfinite ranges are compatible, provided the parameter $(D upTo) is\nspecified, in which case the implementation simply returns upTo.\n \n",
      "line" : 1385,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       }
      ],
      "endline" : 1397
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1399,
    "name" : "walkLength",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "walkLength",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1399,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range range, const size_t upTo)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "Range"
       },
       {
        "name" : "upTo",
        "type" : "size_t",
        "storageClass" : [
         "const"
        ]
       }
      ],
      "endline" : 1413
     }
    ]
   },
   {
    "name" : "__unittestL1415_1436",
    "kind" : "function",
    "line" : 1415,
    "endline" : 1452
   },
   {
    "kind" : "template",
    "comment" : "\nIterates a bidirectional range backwards. The original range can be\naccessed by using the $(D source) property. Applying retro twice to\nthe same range yields the original range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(retro(a), [ 5, 4, 3, 2, 1 ][]));\nassert(retro(a).source is a);\nassert(retro(retro(a)) is a);\n----\n \n",
    "line" : 1452,
    "name" : "retro",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "retro",
      "kind" : "function",
      "comment" : "\nIterates a bidirectional range backwards. The original range can be\naccessed by using the $(D source) property. Applying retro twice to\nthe same range yields the original range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(retro(a), [ 5, 4, 3, 2, 1 ][]));\nassert(retro(a).source is a);\nassert(retro(retro(a)) is a);\n----\n \n",
      "line" : 1452,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       }
      ],
      "endline" : 1561
     }
    ]
   },
   {
    "name" : "__unittestL1563_1437",
    "kind" : "function",
    "line" : 1563,
    "endline" : 1637
   },
   {
    "name" : "__unittestL1637_1438",
    "kind" : "function",
    "line" : 1637,
    "endline" : 1661
   },
   {
    "kind" : "template",
    "comment" : "\nIterates range $(D r) with stride $(D n). If the range is a\nrandom-access range, moves by indexing into the range; otherwise,\nmoves by successive calls to $(D popFront). Applying stride twice to\nthe same range results in a stride with a step that is the\nproduct of the two applications.\n\nThrows: $(D Exception) if $(D n == 0).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\nassert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));\nassert(stride(stride(a, 2), 3) == stride(a, 6));\n----\n \n",
    "line" : 1661,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "comment" : "\nIterates range $(D r) with stride $(D n). If the range is a\nrandom-access range, moves by indexing into the range; otherwise,\nmoves by successive calls to $(D popFront). Applying stride twice to\nthe same range results in a stride with a step that is the\nproduct of the two applications.\n\nThrows: $(D Exception) if $(D n == 0).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ];\nassert(equal(stride(a, 3), [ 1, 4, 7, 10 ][]));\nassert(stride(stride(a, 2), 3) == stride(a, 6));\n----\n \n",
      "line" : 1661,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 1864
     }
    ]
   },
   {
    "name" : "__unittestL1866_1439",
    "kind" : "function",
    "line" : 1866,
    "endline" : 1989
   },
   {
    "name" : "__unittestL1989_1440",
    "kind" : "function",
    "line" : 1989,
    "endline" : 2019
   },
   {
    "kind" : "template",
    "comment" : "\nSpans multiple ranges in sequence. The function $(D chain) takes any\nnumber of ranges and returns a $(D Chain!(R1, R2,...)) object. The\nranges may be different, but they must have the same element type. The\nresult is a range that offers the $(D front), $(D popFront), and $(D\nempty) primitives. If all input ranges offer random access and $(D\nlength), $(D Chain) offers them as well.\n\nIf only one range is offered to $(D Chain) or $(D chain), the $(D\nChain) type exits the picture by aliasing itself directly to that\nrange's type.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\nauto s = chain(arr1, arr2, arr3);\nassert(s.length == 7);\nassert(s[5] == 6);\nassert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));\n----\n \n",
    "line" : 2019,
    "name" : "chain",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "chain",
      "kind" : "function",
      "comment" : "\nSpans multiple ranges in sequence. The function $(D chain) takes any\nnumber of ranges and returns a $(D Chain!(R1, R2,...)) object. The\nranges may be different, but they must have the same element type. The\nresult is a range that offers the $(D front), $(D popFront), and $(D\nempty) primitives. If all input ranges offer random access and $(D\nlength), $(D Chain) offers them as well.\n\nIf only one range is offered to $(D Chain) or $(D chain), the $(D\nChain) type exits the picture by aliasing itself directly to that\nrange's type.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4 ];\nint[] arr2 = [ 5, 6 ];\nint[] arr3 = [ 7 ];\nauto s = chain(arr1, arr2, arr3);\nassert(s.length == 7);\nassert(s[5] == 6);\nassert(equal(s, [1, 2, 3, 4, 5, 6, 7][]));\n----\n \n",
      "line" : 2019,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Ranges rs)",
      "parameters" : [
       {
        "name" : "rs",
        "type" : "Ranges"
       }
      ],
      "endline" : 2333
     }
    ]
   },
   {
    "name" : "__unittestL2335_1441",
    "kind" : "function",
    "line" : 2335,
    "endline" : 2442
   },
   {
    "kind" : "template",
    "comment" : "\n$(D roundRobin(r1, r2, r3)) yields $(D r1.front), then $(D r2.front),\nthen $(D r3.front), after which it pops off one element from each and\ncontinues again from $(D r1). For example, if two ranges are involved,\nit alternately yields elements off the two ranges. $(D roundRobin)\nstops after it has consumed all ranges (skipping over the ones that\nfinish early).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4];\nint[] b = [ 10, 20 ];\nassert(equal(roundRobin(a, b), [1, 10, 2, 20, 3, 4]));\n----\n \n",
    "line" : 2442,
    "name" : "roundRobin",
    "parameters" : [
     {
      "name" : "Rs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "roundRobin",
      "kind" : "function",
      "comment" : "\n$(D roundRobin(r1, r2, r3)) yields $(D r1.front), then $(D r2.front),\nthen $(D r3.front), after which it pops off one element from each and\ncontinues again from $(D r1). For example, if two ranges are involved,\nit alternately yields elements off the two ranges. $(D roundRobin)\nstops after it has consumed all ranges (skipping over the ones that\nfinish early).\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4];\nint[] b = [ 10, 20 ];\nassert(equal(roundRobin(a, b), [1, 10, 2, 20, 3, 4]));\n----\n \n",
      "line" : 2442,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Rs rs)",
      "parameters" : [
       {
        "name" : "rs",
        "type" : "Rs"
       }
      ],
      "endline" : 2538
     }
    ]
   },
   {
    "name" : "__unittestL2540_1442",
    "kind" : "function",
    "line" : 2540,
    "endline" : 2562
   },
   {
    "kind" : "template",
    "comment" : "\nIterates a random-access range starting from a given point and\nprogressively extending left and right from that point. If no initial\npoint is given, iteration starts from the middle of the\nrange. Iteration spans the entire range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));\na = [ 1, 2, 3, 4 ];\nassert(equal(radial(a), [ 2, 3, 1, 4 ]));\n----\n \n",
    "line" : 2562,
    "name" : "radial",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "I",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "radial",
      "kind" : "function",
      "comment" : "\nIterates a random-access range starting from a given point and\nprogressively extending left and right from that point. If no initial\npoint is given, iteration starts from the middle of the\nrange. Iteration spans the entire range.\n\nExample:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\nassert(equal(radial(a), [ 3, 4, 2, 5, 1 ]));\na = [ 1, 2, 3, 4 ];\nassert(equal(radial(a), [ 2, 3, 1, 4 ]));\n----\n \n",
      "line" : 2562,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Range r, I startingIndex)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "startingIndex",
        "type" : "I"
       }
      ],
      "endline" : 2567
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 2570,
    "name" : "radial",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "radial",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 2570,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       }
      ],
      "endline" : 2574
     }
    ]
   },
   {
    "name" : "__unittestL2576_1443",
    "kind" : "function",
    "line" : 2576,
    "endline" : 2610
   },
   {
    "name" : "__unittestL2610_1444",
    "kind" : "function",
    "line" : 2610,
    "endline" : 2631
   },
   {
    "kind" : "template",
    "comment" : "\nLazily takes only up to $(D n) elements of a range. This is\nparticularly useful when using with infinite ranges. If the range\noffers random access and $(D length), $(D Take) offers them as well.\n\nExample:\n----\nint[] arr1 = [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nauto s = take(arr1, 5);\nassert(s.length == 5);\nassert(s[4] == 5);\nassert(equal(s, [ 1, 2, 3, 4, 5 ][]));\n----\n \n",
    "line" : 2636,
    "name" : "Take",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Take",
      "kind" : "struct",
      "line" : 2636,
      "members" : [
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 2637,
        "type" : "Unqual!(Range)"
       },
       {
        "name" : "source",
        "kind" : "variable",
        "line" : 2640,
        "type" : "R"
       },
       {
        "name" : "_maxAvailable",
        "kind" : "variable",
        "line" : 2642,
        "type" : "size_t"
       },
       {
        "name" : "Source",
        "kind" : "alias",
        "line" : 2644,
        "type" : "R"
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 2646,
        "type" : "bool()",
        "endline" : 2649
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 2652,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 2657
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 2659,
        "type" : "void()",
        "endline" : 2666
       },
       {
        "name" : "maxLength",
        "kind" : "function",
        "line" : 2781,
        "type" : "const size_t()",
        "endline" : 2784
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2789,
    "name" : "Take",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Take",
      "kind" : "alias",
      "line" : 2793,
      "type" : "R"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2798,
    "name" : "take",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "take",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2798,
      "type" : "Take!(R)(R input, size_t n)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 2804
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2807,
    "name" : "take",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "take",
      "kind" : "function",
      "line" : 2807,
      "type" : "Take!(R)(R input, size_t n)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 2811
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2814,
    "name" : "take",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "take",
      "kind" : "function",
      "line" : 2814,
      "type" : "Take!(R)(R input, size_t n)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 2818
     }
    ]
   },
   {
    "name" : "__unittestL2820_1445",
    "kind" : "function",
    "line" : 2820,
    "endline" : 2878
   },
   {
    "name" : "__unittestL2878_1446",
    "kind" : "function",
    "line" : 2878,
    "endline" : 2904
   },
   {
    "kind" : "template",
    "comment" : "\nSimilar to $(LREF take), but assumes that $(D range) has at least $(D\nn) elements. Consequently, the result of $(D takeExactly(range, n))\nalways defines the $(D length) property (and initializes it to $(D n))\neven when $(D range) itself does not define $(D length).\n\nThe result of $(D takeExactly) is identical to that of $(LREF take) in\ncases where the original range defines $(D length) or is infinite.\n \n",
    "line" : 2904,
    "name" : "takeExactly",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "takeExactly",
      "kind" : "function",
      "comment" : "\nSimilar to $(LREF take), but assumes that $(D range) has at least $(D\nn) elements. Consequently, the result of $(D takeExactly(range, n))\nalways defines the $(D length) property (and initializes it to $(D n))\neven when $(D range) itself does not define $(D length).\n\nThe result of $(D takeExactly) is identical to that of $(LREF take) in\ncases where the original range defines $(D length) or is infinite.\n \n",
      "line" : 2904,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R range, size_t n)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 2951
     }
    ]
   },
   {
    "name" : "__unittestL2953_1447",
    "kind" : "function",
    "line" : 2953,
    "endline" : 3039
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a range with at most one element; for example, $(D\ntakeOne([42, 43, 44])) returns a range consisting of the integer $(D\n42). Calling $(D popFront()) off that range renders it empty.\n\n----\nauto s = takeOne([42, 43, 44]);\nstatic assert(isRandomAccessRange!(typeof(s)));\nassert(s.length == 1);\nassert(!s.empty);\nassert(s.front == 42);\ns.front() = 43;\nassert(s.front == 43);\nassert(s.back == 43);\nassert(s[0] == 43);\ns.popFront();\nassert(s.length == 0);\nassert(s.empty);\n----\n\nIn effect $(D takeOne(r)) is somewhat equivalent to $(D take(r, 1)) but in\ncertain interfaces it is important to know statically that the range may only\nhave at most one element.\n\nThe type returned by $(D takeOne) is a random-access range with length\nregardless of $(D R)'s capabilities (another feature that distinguishes\n$(D takeOne) from $(D take)).\n \n",
    "line" : 3039,
    "name" : "takeOne",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "takeOne",
      "kind" : "function",
      "comment" : "\nReturns a range with at most one element; for example, $(D\ntakeOne([42, 43, 44])) returns a range consisting of the integer $(D\n42). Calling $(D popFront()) off that range renders it empty.\n\n----\nauto s = takeOne([42, 43, 44]);\nstatic assert(isRandomAccessRange!(typeof(s)));\nassert(s.length == 1);\nassert(!s.empty);\nassert(s.front == 42);\ns.front() = 43;\nassert(s.front == 43);\nassert(s.back == 43);\nassert(s[0] == 43);\ns.popFront();\nassert(s.length == 0);\nassert(s.empty);\n----\n\nIn effect $(D takeOne(r)) is somewhat equivalent to $(D take(r, 1)) but in\ncertain interfaces it is important to know statically that the range may only\nhave at most one element.\n\nThe type returned by $(D takeOne) is a random-access range with length\nregardless of $(D R)'s capabilities (another feature that distinguishes\n$(D takeOne) from $(D take)).\n \n",
      "line" : 3039,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R source)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "R"
       }
      ],
      "endline" : 3071
     }
    ]
   },
   {
    "name" : "__unittestL3073_1448",
    "kind" : "function",
    "line" : 3073,
    "endline" : 3101
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns an empty range which is statically known to be empty and is\n    guaranteed to have $(D length) and be random access regardless of $(D R)'s\n    capabilities.\n\n    Examples:\n--------------------\nauto range = takeNone!(int[])();\nassert(range.length == 0);\nassert(range.empty);\n--------------------\n  \n",
    "line" : 3101,
    "name" : "takeNone",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "takeNone",
      "kind" : "function",
      "comment" : "\n    Returns an empty range which is statically known to be empty and is\n    guaranteed to have $(D length) and be random access regardless of $(D R)'s\n    capabilities.\n\n    Examples:\n--------------------\nauto range = takeNone!(int[])();\nassert(range.length == 0);\nassert(range.empty);\n--------------------\n  \n",
      "line" : 3101,
      "storageClass" : [
       "auto"
      ],
      "type" : "()",
      "endline" : 3105
     }
    ]
   },
   {
    "name" : "__unittestL3107_1449",
    "kind" : "function",
    "line" : 3107,
    "endline" : 3131
   },
   {
    "kind" : "template",
    "comment" : "\n    Creates an empty range from the given range in $(BIGOH 1). If it can, it\n    will return the same range type. If not, it will return\n    $(D takeExactly(range, 0)).\n\n    Examples:\n--------------------\nassert(takeNone([42, 27, 19]).empty);\nassert(takeNone(\"dlang.org\").empty);\nassert(takeNone(filter!\"true\"([42, 27, 19])).empty);\n--------------------\n  \n",
    "line" : 3131,
    "name" : "takeNone",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "takeNone",
      "kind" : "function",
      "comment" : "\n    Creates an empty range from the given range in $(BIGOH 1). If it can, it\n    will return the same range type. If not, it will return\n    $(D takeExactly(range, 0)).\n\n    Examples:\n--------------------\nassert(takeNone([42, 27, 19]).empty);\nassert(takeNone(\"dlang.org\").empty);\nassert(takeNone(filter!\"true\"([42, 27, 19])).empty);\n--------------------\n  \n",
      "line" : 3131,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 3153
     }
    ]
   },
   {
    "name" : "__unittestL3156_1450",
    "kind" : "function",
    "line" : 3156,
    "endline" : 3163
   },
   {
    "name" : "__unittestL3163_1451",
    "kind" : "function",
    "line" : 3163,
    "endline" : 3320
   },
   {
    "kind" : "template",
    "comment" : "\n    Convenience function which calls\n    $(D range.$(LREF popFrontN)(n)) and returns $(D range). $(D drop)\n    makes it easier to pop elements from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFrontN) would require multiple statements.\n\n    $(D dropBack) provides the same functionality but instead calls\n    $(D range.popBackN(n)).\n\n    Note: $(D drop) and $(D dropBack) will only pop $(I up to)\n    $(D n) elements but will stop if the range is empty first.\n\n    Examples:\n--------------------\nassert([0, 2, 1, 5, 0, 3].drop(3) == [5, 0, 3]);\nassert(\"hello world\".drop(6) == \"world\");\nassert(\"hello world\".drop(50).empty);\nassert(\"hello world\".take(6).drop(3).equal(\"lo \"));\n--------------------\n\n--------------------\n//Remove all but the first two elements\nauto a = DList!int(0, 1, 9, 9, 9);\na.remove(a[].drop(2));\nassert(a[].equal(a[].take(2)));\n--------------------\n\n--------------------\nassert([0, 2, 1, 5, 0, 3].dropBack(3) == [0, 2, 1]);\nassert(\"hello world\".dropBack(6) == \"hello\");\nassert(\"hello world\".dropBack(50).empty);\nassert(\"hello world\".drop(4).dropBack(4).equal(\"o w\"));\n--------------------\n\n--------------------\n//insert before the last two elements\nauto a = DList!int(0, 1, 2, 5, 6);\na.insertAfter(a[].dropBack(2), [3, 4]);\nassert(a[].equal(iota(0, 7)));\n--------------------\n  \n",
    "line" : 3320,
    "name" : "drop",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "drop",
      "kind" : "function",
      "comment" : "\n    Convenience function which calls\n    $(D range.$(LREF popFrontN)(n)) and returns $(D range). $(D drop)\n    makes it easier to pop elements from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFrontN) would require multiple statements.\n\n    $(D dropBack) provides the same functionality but instead calls\n    $(D range.popBackN(n)).\n\n    Note: $(D drop) and $(D dropBack) will only pop $(I up to)\n    $(D n) elements but will stop if the range is empty first.\n\n    Examples:\n--------------------\nassert([0, 2, 1, 5, 0, 3].drop(3) == [5, 0, 3]);\nassert(\"hello world\".drop(6) == \"world\");\nassert(\"hello world\".drop(50).empty);\nassert(\"hello world\".take(6).drop(3).equal(\"lo \"));\n--------------------\n\n--------------------\n//Remove all but the first two elements\nauto a = DList!int(0, 1, 9, 9, 9);\na.remove(a[].drop(2));\nassert(a[].equal(a[].take(2)));\n--------------------\n\n--------------------\nassert([0, 2, 1, 5, 0, 3].dropBack(3) == [0, 2, 1]);\nassert(\"hello world\".dropBack(6) == \"hello\");\nassert(\"hello world\".dropBack(50).empty);\nassert(\"hello world\".drop(4).dropBack(4).equal(\"o w\"));\n--------------------\n\n--------------------\n//insert before the last two elements\nauto a = DList!int(0, 1, 2, 5, 6);\na.insertAfter(a[].dropBack(2), [3, 4]);\nassert(a[].equal(iota(0, 7)));\n--------------------\n  \n",
      "line" : 3320,
      "type" : "R(R range, size_t n)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3325
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3327,
    "name" : "dropBack",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dropBack",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3327,
      "type" : "R(R range, size_t n)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3332
     }
    ]
   },
   {
    "name" : "__unittestL3335_1452",
    "kind" : "function",
    "line" : 3335,
    "endline" : 3342
   },
   {
    "name" : "__unittestL3342_1453",
    "kind" : "function",
    "line" : 3342,
    "endline" : 3349
   },
   {
    "name" : "__unittestL3349_1454",
    "kind" : "function",
    "line" : 3349,
    "endline" : 3354
   },
   {
    "name" : "__unittestL3354_1455",
    "kind" : "function",
    "line" : 3354,
    "endline" : 3361
   },
   {
    "name" : "__unittestL3361_1456",
    "kind" : "function",
    "line" : 3361,
    "endline" : 3382
   },
   {
    "kind" : "template",
    "comment" : "\n    Similar to $(LREF drop) and $(D dropBack) but they call\n    $(D range.$(LREF popFrontExactly)(n)) and $(D range.popBackExactly(n))\n    instead.\n\n    Note: Unlike $(D drop), $(D dropExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D dropExactly)\n    faster than $(D drop), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\n",
    "line" : 3382,
    "name" : "dropExactly",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dropExactly",
      "kind" : "function",
      "comment" : "\n    Similar to $(LREF drop) and $(D dropBack) but they call\n    $(D range.$(LREF popFrontExactly)(n)) and $(D range.popBackExactly(n))\n    instead.\n\n    Note: Unlike $(D drop), $(D dropExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D dropExactly)\n    faster than $(D drop), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\n",
      "line" : 3382,
      "type" : "R(R range, size_t n)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3387
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3389,
    "name" : "dropBackExactly",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dropBackExactly",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3389,
      "type" : "R(R range, size_t n)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3394
     }
    ]
   },
   {
    "name" : "__unittestL3396_1457",
    "kind" : "function",
    "line" : 3396,
    "endline" : 3430
   },
   {
    "kind" : "template",
    "comment" : "\n    Convenience function which calls\n    $(D range.popFront()) and returns $(D range). $(D dropOne)\n    makes it easier to pop an element from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFront) would require multiple statements.\n\n    $(D dropBackOne) provides the same functionality but instead calls\n    $(D range.popBack()).\n\n    Example:\n----\nauto dl = DList!int(9, 1, 2, 3, 9);\nassert(dl[].dropOne().dropBackOne().equal([1, 2, 3]));\n----\n",
    "line" : 3430,
    "name" : "dropOne",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dropOne",
      "kind" : "function",
      "comment" : "\n    Convenience function which calls\n    $(D range.popFront()) and returns $(D range). $(D dropOne)\n    makes it easier to pop an element from a range\n    and then pass it to another function within a single expression,\n    whereas $(D popFront) would require multiple statements.\n\n    $(D dropBackOne) provides the same functionality but instead calls\n    $(D range.popBack()).\n\n    Example:\n----\nauto dl = DList!int(9, 1, 2, 3, 9);\nassert(dl[].dropOne().dropBackOne().equal([1, 2, 3]));\n----\n",
      "line" : 3430,
      "type" : "R(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 3435
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3437,
    "name" : "dropBackOne",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "dropBackOne",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3437,
      "type" : "R(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 3442
     }
    ]
   },
   {
    "name" : "__unittestL3444_1458",
    "kind" : "function",
    "line" : 3444,
    "endline" : 3449
   },
   {
    "name" : "__unittestL3449_1459",
    "kind" : "function",
    "line" : 3449,
    "endline" : 3498
   },
   {
    "kind" : "template",
    "comment" : "\n    Eagerly advances $(D r) itself (not a copy) up to $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontN) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing and have length.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Returns:\n    How much $(D r) was actually advanced, which may be less than $(D n) if\n    $(D r) did not have at least $(D n) elements.\n\n    $(D popBackN) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\n\n    Example:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popFrontN(2);\nassert(a == [ 3, 4, 5 ]);\na.popFrontN(7);\nassert(a == [ ]);\n----\n\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popBackN(2);\nassert(a == [ 1, 2, 3 ]);\na.popBackN(7);\nassert(a == [ ]);\n----\n",
    "line" : 3498,
    "name" : "popFrontN",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popFrontN",
      "kind" : "function",
      "comment" : "\n    Eagerly advances $(D r) itself (not a copy) up to $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontN) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing and have length.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Returns:\n    How much $(D r) was actually advanced, which may be less than $(D n) if\n    $(D r) did not have at least $(D n) elements.\n\n    $(D popBackN) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\n\n    Example:\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popFrontN(2);\nassert(a == [ 3, 4, 5 ]);\na.popFrontN(7);\nassert(a == [ ]);\n----\n\n----\nint[] a = [ 1, 2, 3, 4, 5 ];\na.popBackN(2);\nassert(a == [ 1, 2, 3 ]);\na.popBackN(7);\nassert(a == [ ]);\n----\n",
      "line" : 3498,
      "type" : "size_t(ref Range r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3529
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3531,
    "name" : "popBackN",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popBackN",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3531,
      "type" : "size_t(ref Range r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3562
     }
    ]
   },
   {
    "name" : "__unittestL3564_1460",
    "kind" : "function",
    "line" : 3564,
    "endline" : 3572
   },
   {
    "name" : "__unittestL3572_1461",
    "kind" : "function",
    "line" : 3572,
    "endline" : 3579
   },
   {
    "name" : "__unittestL3579_1462",
    "kind" : "function",
    "line" : 3579,
    "endline" : 3587
   },
   {
    "name" : "__unittestL3587_1463",
    "kind" : "function",
    "line" : 3587,
    "endline" : 3613
   },
   {
    "kind" : "template",
    "comment" : "\n    Eagerly advances $(D r) itself (not a copy) exactly $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontExactly) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing, and have either length or are infinite.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Note: Unlike $(LREF popFrontN), $(D popFrontExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D popFrontExactly)\n    faster than $(D popFrontN), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\n\n    $(D popBackExactly) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\n",
    "line" : 3613,
    "name" : "popFrontExactly",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popFrontExactly",
      "kind" : "function",
      "comment" : "\n    Eagerly advances $(D r) itself (not a copy) exactly $(D n) times (by\n    calling $(D r.popFront)). $(D popFrontExactly) takes $(D r) by $(D ref),\n    so it mutates the original range. Completes in $(BIGOH 1) steps for ranges\n    that support slicing, and have either length or are infinite.\n    Completes in $(BIGOH n) time for all other ranges.\n\n    Note: Unlike $(LREF popFrontN), $(D popFrontExactly) will assume that the\n    range holds at least $(D n) elements. This makes $(D popFrontExactly)\n    faster than $(D popFrontN), but it also means that if $(D range) does\n    not contain at least $(D n) elements, it will attempt to call $(D popFront)\n    on an empty range, which is undefined behavior. So, only use\n    $(D popFrontExactly) when it is guaranteed that $(D range) holds at least\n    $(D n) elements.\n\n    $(D popBackExactly) will behave the same but instead removes elements from\n    the back of the (bidirectional) range instead of the front.\n",
      "line" : 3613,
      "type" : "void(ref Range r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3626
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3628,
    "name" : "popBackExactly",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "popBackExactly",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3628,
      "type" : "void(ref Range r, size_t n)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3641
     }
    ]
   },
   {
    "name" : "__unittestL3643_1464",
    "kind" : "function",
    "line" : 3643,
    "endline" : 3675
   },
   {
    "kind" : "template",
    "comment" : "\nRepeats one value forever.\n\nExample:\n----\nenforce(equal(take(repeat(5), 4), [ 5, 5, 5, 5 ][]));\n----\n",
    "line" : 3676,
    "name" : "Repeat",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Repeat",
      "kind" : "struct",
      "line" : 3676,
      "members" : [
       {
        "name" : "_value",
        "kind" : "variable",
        "line" : 3677,
        "type" : "T"
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Range primitive implementations.\n",
        "line" : 3679,
        "type" : "T()",
        "endline" : 3679
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "comment" : " Ditto\n",
        "line" : 3681,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 3683,
        "type" : "void()",
        "endline" : 3683
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 3685,
        "type" : "Repeat!(T)()",
        "endline" : 3685
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 3687,
        "type" : "T(size_t)",
        "parameters" : [
         {
          "type" : "size_t"
         }
        ],
        "endline" : 3687
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 3690,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t i, size_t j)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "size_t"
         },
         {
          "name" : "j",
          "type" : "size_t"
         }
        ],
        "endline" : 3694
       },
       {
        "name" : "opDollar",
        "kind" : "variable",
        "comment" : " Ditto\n",
        "line" : 3699,
        "storageClass" : [
         "enum"
        ],
        "init" : "DollarToken()"
       },
       {
        "name" : "DollarToken",
        "kind" : "struct",
        "line" : 3701,
        "members" : []
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 3702,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t, DollarToken)",
        "parameters" : [
         {
          "type" : "size_t"
         },
         {
          "type" : "DollarToken"
         }
        ],
        "endline" : 3702
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3706,
    "name" : "repeat",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "repeat",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3706,
      "type" : "Repeat!(T)(T value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       }
      ],
      "endline" : 3706
     }
    ]
   },
   {
    "name" : "__unittestL3708_1465",
    "kind" : "function",
    "line" : 3708,
    "endline" : 3726
   },
   {
    "kind" : "template",
    "comment" : "\n   Repeats $(D value) exactly $(D n) times. Equivalent to $(D\n   take(repeat(value), n)).\n",
    "line" : 3726,
    "name" : "repeat",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "repeat",
      "kind" : "function",
      "comment" : "\n   Repeats $(D value) exactly $(D n) times. Equivalent to $(D\n   take(repeat(value), n)).\n",
      "line" : 3726,
      "type" : "Take!(Repeat!(T))(T value, size_t n)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3729
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3732,
    "name" : "replicate",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replicate",
      "kind" : "function",
      "line" : 3732,
      "type" : "Take!(Repeat!(T))(T value, size_t n)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3735
     }
    ]
   },
   {
    "name" : "__unittestL3737_1466",
    "kind" : "function",
    "line" : 3737,
    "endline" : 3758
   },
   {
    "kind" : "template",
    "comment" : "\nRepeats the given forward range ad infinitum. If the original range is\ninfinite (fact that would make $(D Cycle) the identity application),\n$(D Cycle) detects that and aliases itself to the range type\nitself. If the original range has random access, $(D Cycle) offers\nrandom access and also offers a constructor taking an initial position\n$(D index). $(D Cycle) works with static arrays in addition to ranges,\nmostly for performance reasons.\n\nExample:\n----\nassert(equal(take(cycle([1, 2][]), 5), [ 1, 2, 1, 2, 1 ][]));\n----\n\nTip: This is a great way to implement simple circular buffers.\n",
    "line" : 3760,
    "name" : "Cycle",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Cycle",
      "kind" : "struct",
      "line" : 3760,
      "members" : [
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 3761,
        "type" : "Unqual!(Range)"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3886,
    "name" : "Cycle",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Cycle",
      "kind" : "alias",
      "line" : 3889,
      "type" : "R"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3894,
    "name" : "Cycle",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Cycle",
      "kind" : "struct",
      "line" : 3894,
      "members" : [
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 3895,
        "type" : "typeof(R.init[0])"
       },
       {
        "name" : "_ptr",
        "kind" : "variable",
        "line" : 3896,
        "type" : "ElementType*"
       },
       {
        "name" : "_index",
        "kind" : "variable",
        "line" : 3897,
        "type" : "size_t"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3899,
        "type" : "(ref R input, size_t index = 0)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "R",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "index",
          "type" : "size_t",
          "default" : "0"
         }
        ],
        "endline" : 3903
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 3905,
        "type" : "inout inout(ElementType)()",
        "endline" : 3908
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "line" : 3910,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 3912,
        "type" : "void()",
        "endline" : 3912
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "line" : 3914,
        "type" : "inout inout(ElementType)(size_t n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "size_t"
         }
        ],
        "endline" : 3917
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 3919,
        "type" : "Cycle()",
        "endline" : 3922
       },
       {
        "name" : "DollarToken",
        "kind" : "struct",
        "line" : 3924,
        "members" : []
       },
       {
        "name" : "opDollar",
        "kind" : "function",
        "line" : 3926,
        "type" : "DollarToken()",
        "endline" : 3929
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 3932,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t i, size_t j)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "size_t"
         },
         {
          "name" : "j",
          "type" : "size_t"
         }
        ],
        "endline" : 3937
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 3940,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t i, DollarToken)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "size_t"
         },
         {
          "type" : "DollarToken"
         }
        ],
        "endline" : 3944
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3948,
    "name" : "cycle",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cycle",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3948,
      "type" : "Cycle!(R)(R input)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       }
      ],
      "endline" : 3952
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 3955,
    "name" : "cycle",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cycle",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3955,
      "type" : "Cycle!(R)(R input, size_t index = 0)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "index",
        "type" : "size_t",
        "default" : "0"
       }
      ],
      "endline" : 3959
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3961,
    "name" : "cycle",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cycle",
      "kind" : "function",
      "line" : 3961,
      "type" : "Cycle!(R)(R input)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       }
      ],
      "endline" : 3965
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 3967,
    "name" : "cycle",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "cycle",
      "kind" : "function",
      "line" : 3967,
      "type" : "Cycle!(R)(ref R input, size_t index = 0)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "default" : "0"
       }
      ],
      "endline" : 3971
     }
    ]
   },
   {
    "name" : "__unittestL3973_1467",
    "kind" : "function",
    "line" : 3973,
    "endline" : 4042
   },
   {
    "name" : "__unittestL4042_1468",
    "kind" : "function",
    "line" : 4042,
    "endline" : 4056
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4056,
    "name" : "lengthType",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "lengthType",
      "kind" : "alias",
      "line" : 4056,
      "type" : "typeof((int = 0)\n{\nR r = void;\nreturn r.length;\n}\n())"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Iterate several ranges in lockstep. The element type is a proxy tuple\n   that allows accessing the current element in the $(D n)th range by\n   using $(D e[n]).\n\n   Example:\n   ----\n   int[] a = [ 1, 2, 3 ];\n   string[] b = [ \"a\", \"b\", \"c\" ];\n   // prints 1:a 2:b 3:c\n   foreach (e; zip(a, b))\n   {\n   write(e[0], ':', e[1], ' ');\n   }\n   ----\n\n   $(D Zip) offers the lowest range facilities of all components, e.g. it\n   offers random access iff all ranges offer random access, and also\n   offers mutation and swapping if all ranges offer it. Due to this, $(D\n   Zip) is extremely powerful because it allows manipulating several\n   ranges in lockstep. For example, the following code sorts two arrays\n   in parallel:\n\n   ----\n   int[] a = [ 1, 2, 3 ];\n   string[] b = [ \"a\", \"b\", \"c\" ];\n   sort!(\"a[0] > b[0]\")(zip(a, b));\n   assert(a == [ 3, 2, 1 ]);\n   assert(b == [ \"c\", \"b\", \"a\" ]);\n   ----\n",
    "line" : 4091,
    "name" : "Zip",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Zip",
      "kind" : "struct",
      "line" : 4091,
      "members" : [
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 4092,
        "type" : "Ranges"
       },
       {
        "name" : "ranges",
        "kind" : "variable",
        "line" : 4093,
        "type" : "R"
       },
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 4094,
        "type" : "Tuple!(staticMap!(.ElementType, R))"
       },
       {
        "name" : "stoppingPolicy",
        "kind" : "variable",
        "line" : 4095,
        "type" : "StoppingPolicy",
        "init" : "StoppingPolicy.shortest"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n   Builds an object. Usually this is invoked indirectly by using the\n   $(LREF zip) function.\n \n",
        "line" : 4101,
        "type" : "(R rs, StoppingPolicy s = StoppingPolicy.shortest)",
        "parameters" : [
         {
          "name" : "rs",
          "type" : "R"
         },
         {
          "name" : "s",
          "type" : "StoppingPolicy",
          "default" : "StoppingPolicy.shortest"
         }
        ],
        "endline" : 4108
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n   Returns the current iterated element.\n",
        "line" : 4166,
        "type" : "ElementType()",
        "endline" : 4182
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n   Advances to the next element in all controlled ranges.\n",
        "line" : 4293,
        "type" : "void()",
        "endline" : 4318
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4451,
    "name" : "zip",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "zip",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4451,
      "storageClass" : [
       "auto"
      ],
      "type" : "(Ranges ranges)",
      "parameters" : [
       {
        "name" : "ranges",
        "type" : "Ranges"
       }
      ],
      "endline" : 4455
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4458,
    "name" : "zip",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "zip",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4458,
      "storageClass" : [
       "auto"
      ],
      "type" : "(StoppingPolicy sp, Ranges ranges)",
      "parameters" : [
       {
        "name" : "sp",
        "type" : "StoppingPolicy"
       },
       {
        "name" : "ranges",
        "type" : "Ranges"
       }
      ],
      "endline" : 4462
     }
    ]
   },
   {
    "name" : "StoppingPolicy",
    "kind" : "enum",
    "comment" : "\n   Dictates how iteration in a $(D Zip) should stop. By default stop at\n   the end of the shortest of all ranges.\n",
    "line" : 4469,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "shortest",
      "kind" : "enum member",
      "comment" : " Stop when the shortest range is exhausted\n",
      "line" : 4471
     },
     {
      "name" : "longest",
      "kind" : "enum member",
      "comment" : " Stop when the longest range is exhausted\n",
      "line" : 4473
     },
     {
      "name" : "requireSameLength",
      "kind" : "enum member",
      "comment" : " Require that all ranges are equal\n",
      "line" : 4475
     }
    ]
   },
   {
    "name" : "__unittestL4478_1470",
    "kind" : "function",
    "line" : 4478,
    "endline" : 4586
   },
   {
    "name" : "__unittestL4586_1471",
    "kind" : "function",
    "line" : 4586,
    "endline" : 4597
   },
   {
    "name" : "__unittestL4597_1472",
    "kind" : "function",
    "line" : 4597,
    "endline" : 4613
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4613,
    "name" : "lockstepMixin",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "lockstepMixin",
      "kind" : "function",
      "line" : 4613,
      "type" : "string(bool withIndex)",
      "parameters" : [
       {
        "name" : "withIndex",
        "deco" : "b"
       }
      ],
      "endline" : 4661
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Iterate multiple ranges in lockstep using a $(D foreach) loop.  If only a single\n   range is passed in, the $(D Lockstep) aliases itself away.  If the\n   ranges are of different lengths and $(D s) == $(D StoppingPolicy.shortest)\n   stop after the shortest range is empty.  If the ranges are of different\n   lengths and $(D s) == $(D StoppingPolicy.requireSameLength), throw an\n   exception.  $(D s) may not be $(D StoppingPolicy.longest), and passing this\n   will throw an exception.\n\n   By default $(D StoppingPolicy) is set to $(D StoppingPolicy.shortest).\n\n   BUGS:  If a range does not offer lvalue access, but $(D ref) is used in the\n   $(D foreach) loop, it will be silently accepted but any modifications\n   to the variable will not be propagated to the underlying range.\n\n   Examples:\n   ---\n   auto arr1 = [1,2,3,4,5];\n   auto arr2 = [6,7,8,9,10];\n\n   foreach(ref a, ref b; lockstep(arr1, arr2))\n   {\n       a += b;\n   }\n\n   assert(arr1 == [7,9,11,13,15]);\n\n   // Lockstep also supports iterating with an index variable:\n   foreach(index, a, b; lockstep(arr1, arr2)) {\n       writefln(\"Index %s:  a = %s, b = %s\", index, a, b);\n   }\n   ---\n",
    "line" : 4698,
    "name" : "Lockstep",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Lockstep",
      "kind" : "struct",
      "line" : 4698,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 4699,
        "type" : "(R ranges, StoppingPolicy sp = StoppingPolicy.shortest)",
        "parameters" : [
         {
          "name" : "ranges",
          "type" : "R"
         },
         {
          "name" : "sp",
          "type" : "StoppingPolicy",
          "default" : "StoppingPolicy.shortest"
         }
        ],
        "endline" : 4705
       },
       {
        "name" : "R",
        "kind" : "alias",
        "line" : 4711,
        "type" : "Ranges"
       },
       {
        "name" : "_ranges",
        "kind" : "variable",
        "line" : 4712,
        "type" : "R"
       },
       {
        "name" : "_stoppingPolicy",
        "kind" : "variable",
        "line" : 4713,
        "type" : "StoppingPolicy"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 4718,
    "name" : "Lockstep",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Lockstep",
      "kind" : "alias",
      "line" : 4720,
      "type" : "Range"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4724,
    "name" : "lockstep",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "lockstep",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4724,
      "type" : "Lockstep!(Ranges)(Ranges ranges)",
      "parameters" : [
       {
        "name" : "ranges",
        "type" : "Ranges"
       }
      ],
      "endline" : 4728
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4730,
    "name" : "lockstep",
    "parameters" : [
     {
      "name" : "Ranges",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "lockstep",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4730,
      "type" : "Lockstep!(Ranges)(Ranges ranges, StoppingPolicy s)",
      "parameters" : [
       {
        "name" : "ranges",
        "type" : "Ranges"
       },
       {
        "name" : "s",
        "type" : "StoppingPolicy"
       }
      ],
      "endline" : 4737
     }
    ]
   },
   {
    "name" : "__unittestL4739_1473",
    "kind" : "function",
    "line" : 4739,
    "endline" : 4852
   },
   {
    "kind" : "template",
    "comment" : "\nCreates a mathematical sequence given the initial values and a\nrecurrence function that computes the next value from the existing\nvalues. The sequence comes in the form of an infinite forward\nrange. The type $(D Recurrence) itself is seldom used directly; most\noften, recurrences are obtained by calling the function $(D\nrecurrence).\n\nWhen calling $(D recurrence), the function that computes the next\nvalue is specified as a template argument, and the initial values in\nthe recurrence are passed as regular arguments. For example, in a\nFibonacci sequence, there are two initial values (and therefore a\nstate size of 2) because computing the next Fibonacci value needs the\npast two values.\n\nIf the function is passed in string form, the state has name $(D \"a\")\nand the zero-based index in the recurrence has name $(D \"n\"). The\ngiven string must return the desired value for $(D a[n]) given $(D a[n\n- 1]), $(D a[n - 2]), $(D a[n - 3]),..., $(D a[n - stateSize]). The\nstate size is dictated by the number of arguments passed to the call\nto $(D recurrence). The $(D Recurrence) struct itself takes care of\nmanaging the recurrence's state and shifting it appropriately.\n\nExample:\n----\n// a[0] = 1, a[1] = 1, and compute a[n+1] = a[n-1] + a[n]\nauto fib = recurrence!(\"a[n-1] + a[n-2]\")(1, 1);\n// print the first 10 Fibonacci numbers\nforeach (e; take(fib, 10)) { writeln(e); }\n// print the first 10 factorials\nforeach (e; take(recurrence!(\"a[n-1] * n\")(1), 10)) { writeln(e); }\n----\n \n",
    "line" : 4853,
    "name" : "Recurrence",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "StateType",
      "kind" : "type"
     },
     {
      "name" : "stateSize",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "Recurrence",
      "kind" : "struct",
      "line" : 4853,
      "members" : [
       {
        "name" : "_state",
        "kind" : "variable",
        "line" : 4854,
        "type" : "StateType[stateSize]"
       },
       {
        "name" : "_n",
        "kind" : "variable",
        "line" : 4855,
        "type" : "size_t"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 4857,
        "type" : "(StateType[stateSize] initial)",
        "parameters" : [
         {
          "name" : "initial",
          "type" : "StateType[stateSize]"
         }
        ],
        "endline" : 4857
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 4859,
        "type" : "void()",
        "endline" : 4867
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 4869,
        "type" : "StateType()",
        "endline" : 4872
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 4874,
        "type" : "typeof(this)()",
        "endline" : 4877
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "line" : 4879,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4884,
    "name" : "recurrence",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "State",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "recurrence",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4884,
      "type" : "Recurrence!(fun, CommonType!(State), State.length)(State initial)",
      "parameters" : [
       {
        "name" : "initial",
        "type" : "State"
       }
      ],
      "endline" : 4892
     }
    ]
   },
   {
    "name" : "__unittestL4894_1474",
    "kind" : "function",
    "line" : 4894,
    "endline" : 4931
   },
   {
    "kind" : "template",
    "comment" : "\n   $(D Sequence) is similar to $(D Recurrence) except that iteration is\n   presented in the so-called $(WEB en.wikipedia.org/wiki/Closed_form,\n   closed form). This means that the $(D n)th element in the series is\n   computable directly from the initial values and $(D n) itself. This\n   implies that the interface offered by $(D Sequence) is a random-access\n   range, as opposed to the regular $(D Recurrence), which only offers\n   forward iteration.\n\n   The state of the sequence is stored as a $(D Tuple) so it can be\n   heterogeneous.\n\n   Example:\n   ----\n   // a[0] = 1, a[1] = 2, a[n] = a[0] + n * a[1]\n   auto odds = sequence!(\"a[0] + n * a[1]\")(1, 2);\n   ----\n",
    "line" : 4932,
    "name" : "Sequence",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "State",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Sequence",
      "kind" : "struct",
      "line" : 4932,
      "members" : [
       {
        "name" : "compute",
        "kind" : "alias",
        "line" : 4934,
        "type" : "binaryFun!(fun, \"a\", \"n\")"
       },
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 4935,
        "type" : "typeof(compute(State.init, cast(size_t)1))"
       },
       {
        "name" : "_state",
        "kind" : "variable",
        "line" : 4936,
        "type" : "State"
       },
       {
        "name" : "_n",
        "kind" : "variable",
        "line" : 4937,
        "type" : "size_t"
       },
       {
        "name" : "_cache",
        "kind" : "variable",
        "line" : 4938,
        "type" : "ElementType"
       },
       {
        "name" : "DollarToken",
        "kind" : "struct",
        "line" : 4940,
        "members" : []
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 4943,
        "type" : "(State initial, size_t n = 0)",
        "parameters" : [
         {
          "name" : "initial",
          "type" : "State"
         },
         {
          "name" : "n",
          "type" : "size_t",
          "default" : "0"
         }
        ],
        "endline" : 4948
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 4950,
        "type" : "ElementType()",
        "endline" : 4953
       },
       {
        "name" : "moveFront",
        "kind" : "function",
        "line" : 4955,
        "type" : "ElementType()",
        "endline" : 4958
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 4960,
        "type" : "void()",
        "endline" : 4963
       },
       {
        "name" : "opDollar",
        "kind" : "variable",
        "line" : 4965,
        "storageClass" : [
         "enum"
        ],
        "init" : "DollarToken()"
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 4968,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t lower, size_t upper)",
        "parameters" : [
         {
          "name" : "lower",
          "type" : "size_t"
         },
         {
          "name" : "upper",
          "type" : "size_t"
         }
        ],
        "endline" : 4975
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 4978,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t lower, DollarToken)",
        "parameters" : [
         {
          "name" : "lower",
          "type" : "size_t"
         },
         {
          "type" : "DollarToken"
         }
        ],
        "endline" : 4980
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "line" : 4982,
        "type" : "ElementType(size_t n)",
        "parameters" : [
         {
          "name" : "n",
          "type" : "size_t"
         }
        ],
        "endline" : 4985
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "line" : 4987,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "false"
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 4989,
        "type" : "Sequence()",
        "endline" : 4989
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 4993,
    "name" : "sequence",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "State",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "sequence",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 4993,
      "type" : "Sequence!(fun, Tuple!(State))(State args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "State"
       }
      ],
      "endline" : 4996
     }
    ]
   },
   {
    "name" : "__unittestL4998_1475",
    "kind" : "function",
    "line" : 4998,
    "endline" : 5020
   },
   {
    "name" : "__unittestL5020_1476",
    "kind" : "function",
    "line" : 5020,
    "endline" : 5031
   },
   {
    "name" : "__unittestL5031_1477",
    "kind" : "function",
    "line" : 5031,
    "endline" : 5076
   },
   {
    "kind" : "template",
    "comment" : "\n   Returns a range that goes through the numbers $(D begin), $(D begin +\n   step), $(D begin + 2 * step), $(D ...), up to and excluding $(D\n   end). The range offered is a random access range. The two-arguments\n   version has $(D step = 1). If $(D begin < end && step < 0) or $(D\n   begin > end && step > 0) or $(D begin == end), then an empty range is\n   returned.\n\n   Throws:\n   $(D Exception) if $(D begin != end && step == 0), an exception is\n   thrown.\n\n   Example:\n   ----\n   auto r = iota(0, 10, 1);\n   assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][]));\n   r = iota(0, 11, 3);\n   assert(equal(r, [0, 3, 6, 9][]));\n   assert(r[2] == 6);\n   auto rf = iota(0.0, 0.5, 0.1);\n   assert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));\n   ----\n",
    "line" : 5076,
    "name" : "iota",
    "parameters" : [
     {
      "name" : "B",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "iota",
      "kind" : "function",
      "comment" : "\n   Returns a range that goes through the numbers $(D begin), $(D begin +\n   step), $(D begin + 2 * step), $(D ...), up to and excluding $(D\n   end). The range offered is a random access range. The two-arguments\n   version has $(D step = 1). If $(D begin < end && step < 0) or $(D\n   begin > end && step > 0) or $(D begin == end), then an empty range is\n   returned.\n\n   Throws:\n   $(D Exception) if $(D begin != end && step == 0), an exception is\n   thrown.\n\n   Example:\n   ----\n   auto r = iota(0, 10, 1);\n   assert(equal(r, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9][]));\n   r = iota(0, 11, 3);\n   assert(equal(r, [0, 3, 6, 9][]));\n   assert(r[2] == 6);\n   auto rf = iota(0.0, 0.5, 0.1);\n   assert(approxEqual(rf, [0.0, 0.1, 0.2, 0.3, 0.4]));\n   ----\n",
      "line" : 5076,
      "storageClass" : [
       "auto"
      ],
      "type" : "(B begin, E end, S step)",
      "parameters" : [
       {
        "name" : "begin",
        "type" : "B"
       },
       {
        "name" : "end",
        "type" : "E"
       },
       {
        "name" : "step",
        "type" : "S"
       }
      ],
      "endline" : 5158
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5161,
    "name" : "iota",
    "parameters" : [
     {
      "name" : "B",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "iota",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5161,
      "storageClass" : [
       "auto"
      ],
      "type" : "(B begin, E end)",
      "parameters" : [
       {
        "name" : "begin",
        "type" : "B"
       },
       {
        "name" : "end",
        "type" : "E"
       }
      ],
      "endline" : 5165
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5168,
    "name" : "iota",
    "parameters" : [
     {
      "name" : "B",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "iota",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5168,
      "storageClass" : [
       "auto"
      ],
      "type" : "(B begin, E end)",
      "parameters" : [
       {
        "name" : "begin",
        "type" : "B"
       },
       {
        "name" : "end",
        "type" : "E"
       }
      ],
      "endline" : 5226
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5229,
    "name" : "iota",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "iota",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5229,
      "storageClass" : [
       "auto"
      ],
      "type" : "(E end)",
      "parameters" : [
       {
        "name" : "end",
        "type" : "E"
       }
      ],
      "endline" : 5233
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 5236,
    "name" : "iota",
    "parameters" : [
     {
      "name" : "B",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "iota",
      "kind" : "function",
      "line" : 5236,
      "storageClass" : [
       "auto"
      ],
      "type" : "(B begin, E end, S step)",
      "parameters" : [
       {
        "name" : "begin",
        "type" : "B"
       },
       {
        "name" : "end",
        "type" : "E"
       },
       {
        "name" : "step",
        "type" : "S"
       }
      ],
      "endline" : 5313
     }
    ]
   },
   {
    "name" : "__unittestL5315_1478",
    "kind" : "function",
    "line" : 5315,
    "endline" : 5437
   },
   {
    "name" : "__unittestL5437_1479",
    "kind" : "function",
    "line" : 5437,
    "endline" : 5443
   },
   {
    "name" : "__unittestL5443_1480",
    "kind" : "function",
    "line" : 5443,
    "endline" : 5491
   },
   {
    "name" : "TransverseOptions",
    "kind" : "enum",
    "comment" : "\n   Options for the $(LREF FrontTransversal) and $(LREF Transversal) ranges\n   (below).\n",
    "line" : 5492,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "assumeJagged",
      "kind" : "enum member",
      "comment" : "\n   When transversed, the elements of a range of ranges are assumed to\n   have different lengths (e.g. a jagged array).\n",
      "line" : 5497
     },
     {
      "name" : "enforceNotJagged",
      "kind" : "enum member",
      "comment" : "\n       The transversal enforces that the elements of a range of ranges have\n       all the same length (e.g. an array of arrays, all having the same\n       length). Checking is done once upon construction of the transversal\n       range.\n    \n",
      "line" : 5504
     },
     {
      "name" : "assumeNotJagged",
      "kind" : "enum member",
      "comment" : "\n       The transversal assumes, without verifying, that the elements of a\n       range of ranges have all the same length. This option is useful if\n       checking was already done from the outside of the range.\n    \n",
      "line" : 5510
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Given a range of ranges, iterate transversally through the first\n   elements of each of the enclosed ranges.\n\n   Example:\n   ----\n   int[][] x = new int[][2];\n   x[0] = [1, 2];\n   x[1] = [3, 4];\n   auto ror = frontTransversal(x);\n   assert(equal(ror, [ 1, 3 ][]));\n   ---\n",
    "line" : 5528,
    "name" : "FrontTransversal",
    "parameters" : [
     {
      "name" : "Ror",
      "kind" : "type"
     },
     {
      "name" : "opt",
      "kind" : "value",
      "deco" : "E3std5range17TransverseOptions",
      "defaultValue" : "TransverseOptions.assumeJagged"
     }
    ],
    "members" : [
     {
      "name" : "FrontTransversal",
      "kind" : "struct",
      "line" : 5528,
      "members" : [
       {
        "name" : "RangeOfRanges",
        "kind" : "alias",
        "line" : 5529,
        "type" : "Unqual!(Ror)"
       },
       {
        "name" : "RangeType",
        "kind" : "alias",
        "line" : 5530,
        "type" : ".ElementType!(RangeOfRanges)"
       },
       {
        "name" : "ElementType",
        "kind" : "alias",
        "line" : 5531,
        "type" : ".ElementType!(RangeType)"
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 5533,
        "type" : "void()",
        "endline" : 5549
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n   Construction from an input.\n",
        "line" : 5554,
        "type" : "(RangeOfRanges input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "RangeOfRanges"
         }
        ],
        "endline" : 5569
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 5588,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 5591
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 5611,
        "type" : "void()",
        "endline" : 5616
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 5713,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 5713
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 5716,
        "type" : "RangeOfRanges"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5720,
    "name" : "frontTransversal",
    "parameters" : [
     {
      "name" : "opt",
      "kind" : "value",
      "deco" : "E3std5range17TransverseOptions",
      "defaultValue" : "TransverseOptions.assumeJagged"
     },
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "frontTransversal",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5720,
      "type" : "FrontTransversal!(RangeOfRanges, opt)(RangeOfRanges rr)",
      "parameters" : [
       {
        "name" : "rr",
        "type" : "RangeOfRanges"
       }
      ],
      "endline" : 5726
     }
    ]
   },
   {
    "name" : "__unittestL5728_1481",
    "kind" : "function",
    "line" : 5728,
    "endline" : 5801
   },
   {
    "kind" : "template",
    "comment" : "\n   Given a range of ranges, iterate transversally through the the $(D\n   n)th element of each of the enclosed ranges. All elements of the\n   enclosing range must offer random access.\n\n   Example:\n   ----\n   int[][] x = new int[][2];\n   x[0] = [1, 2];\n   x[1] = [3, 4];\n   auto ror = transversal(x, 1);\n   assert(equal(ror, [ 2, 4 ][]));\n   ---\n",
    "line" : 5803,
    "name" : "Transversal",
    "parameters" : [
     {
      "name" : "Ror",
      "kind" : "type"
     },
     {
      "name" : "opt",
      "kind" : "value",
      "deco" : "E3std5range17TransverseOptions",
      "defaultValue" : "TransverseOptions.assumeJagged"
     }
    ],
    "members" : [
     {
      "name" : "Transversal",
      "kind" : "struct",
      "line" : 5803,
      "members" : [
       {
        "name" : "RangeOfRanges",
        "kind" : "alias",
        "line" : 5804,
        "type" : "Unqual!(Ror)"
       },
       {
        "name" : "InnerRange",
        "kind" : "alias",
        "line" : 5805,
        "type" : "ElementType!(RangeOfRanges)"
       },
       {
        "name" : "E",
        "kind" : "alias",
        "line" : 5806,
        "type" : "ElementType!(InnerRange)"
       },
       {
        "name" : "prime",
        "kind" : "function",
        "line" : 5808,
        "type" : "void()",
        "endline" : 5824
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n   Construction from an input and an index.\n",
        "line" : 5829,
        "type" : "(RangeOfRanges input, size_t n)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "RangeOfRanges"
         },
         {
          "name" : "n",
          "type" : "size_t"
         }
        ],
        "endline" : 5843
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 5862,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 5865
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 5887,
        "type" : "void()",
        "endline" : 5892
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 6001,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 6001
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 6004,
        "type" : "RangeOfRanges"
       },
       {
        "name" : "_n",
        "kind" : "variable",
        "line" : 6005,
        "type" : "size_t"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 6009,
    "name" : "transversal",
    "parameters" : [
     {
      "name" : "opt",
      "kind" : "value",
      "deco" : "E3std5range17TransverseOptions",
      "defaultValue" : "TransverseOptions.assumeJagged"
     },
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "transversal",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 6009,
      "type" : "Transversal!(RangeOfRanges, opt)(RangeOfRanges rr, size_t n)",
      "parameters" : [
       {
        "name" : "rr",
        "type" : "RangeOfRanges"
       },
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 6014
     }
    ]
   },
   {
    "name" : "__unittestL6016_1482",
    "kind" : "function",
    "line" : 6016,
    "endline" : 6073
   },
   {
    "kind" : "template",
    "line" : 6074,
    "name" : "Transposed",
    "parameters" : [
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Transposed",
      "kind" : "struct",
      "line" : 6074,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 6077,
        "type" : "(RangeOfRanges input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "RangeOfRanges"
         }
        ],
        "endline" : 6080
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 6083,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 6085
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 6087,
        "type" : "void()",
        "endline" : 6094
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 6101,
        "type" : "bool()",
        "endline" : 6106
       },
       {
        "name" : "save",
        "kind" : "function",
        "line" : 6108,
        "type" : "Transposed()",
        "endline" : 6111
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 6113,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 6113
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 6116,
        "type" : "RangeOfRanges"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 6119,
    "name" : "transposed",
    "parameters" : [
     {
      "name" : "RangeOfRanges",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "transposed",
      "kind" : "function",
      "line" : 6119,
      "storageClass" : [
       "auto"
      ],
      "type" : "(RangeOfRanges rr)",
      "parameters" : [
       {
        "name" : "rr",
        "type" : "RangeOfRanges"
       }
      ],
      "endline" : 6122
     }
    ]
   },
   {
    "name" : "__unittestL6124_1483",
    "kind" : "function",
    "line" : 6124,
    "endline" : 6163
   },
   {
    "kind" : "template",
    "comment" : "\nThis struct takes two ranges, $(D source) and $(D indices), and creates a view\nof $(D source) as if its elements were reordered according to $(D indices).\n$(D indices) may include only a subset of the elements of $(D source) and\nmay also repeat elements.\n\n$(D Source) must be a random access range.  The returned range will be\nbidirectional or random-access if $(D Indices) is bidirectional or\nrandom-access, respectively.\n\nExamples:\n---\nauto source = [1, 2, 3, 4, 5];\nauto indices = [4, 3, 1, 2, 0, 4];\nauto ind = indexed(source, indices);\nassert(equal(ind, [5, 4, 2, 3, 1, 5]));\n\n// When elements of indices are duplicated and Source has lvalue elements,\n// these are aliased in ind.\nind[0]++;\nassert(ind[0] == 6);\nassert(ind[5] == 6);\n---\n",
    "line" : 6166,
    "name" : "Indexed",
    "parameters" : [
     {
      "name" : "Source",
      "kind" : "type"
     },
     {
      "name" : "Indices",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Indexed",
      "kind" : "struct",
      "line" : 6166,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 6167,
        "type" : "(Source source, Indices indices)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "Source"
         },
         {
          "name" : "indices",
          "type" : "Indices"
         }
        ],
        "endline" : 6171
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Range primitives\n",
        "line" : 6175,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ref ()",
        "endline" : 6178
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6181,
        "type" : "void()",
        "endline" : 6185
       },
       {
        "name" : "source",
        "kind" : "function",
        "comment" : "\n    Returns the source range.\n    \n",
        "line" : 6321,
        "type" : "Source()",
        "endline" : 6324
       },
       {
        "name" : "indices",
        "kind" : "function",
        "comment" : "\n    Returns the indices range.\n    \n",
        "line" : 6329,
        "type" : "Indices()",
        "endline" : 6332
       },
       {
        "name" : "_source",
        "kind" : "variable",
        "line" : 6354,
        "type" : "Source"
       },
       {
        "name" : "_indices",
        "kind" : "variable",
        "line" : 6355,
        "type" : "Indices"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 6360,
    "name" : "indexed",
    "parameters" : [
     {
      "name" : "Source",
      "kind" : "type"
     },
     {
      "name" : "Indices",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "indexed",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 6360,
      "type" : "Indexed!(Source, Indices)(Source source, Indices indices)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "Source"
       },
       {
        "name" : "indices",
        "type" : "Indices"
       }
      ],
      "endline" : 6363
     }
    ]
   },
   {
    "name" : "__unittestL6365_1484",
    "kind" : "function",
    "line" : 6365,
    "endline" : 6412
   },
   {
    "kind" : "template",
    "comment" : "\nThis range iterates over fixed-sized chunks of size $(D chunkSize) of a\n$(D source) range.  $(D Source) must be an input range with slicing and length.\nIf $(D source.length) is not evenly divisible by $(D chunkSize), the back\nelement of this range will contain fewer than $(D chunkSize) elements.\n\nExamples:\n---\nauto source = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nauto chunks = chunks(source, 4);\nassert(chunks[0] == [1, 2, 3, 4]);\nassert(chunks[1] == [5, 6, 7, 8]);\nassert(chunks[2] == [9, 10]);\nassert(chunks.back == chunks[2]);\nassert(chunks.front == chunks[0]);\nassert(chunks.length == 3);\n---\n",
    "line" : 6413,
    "name" : "Chunks",
    "parameters" : [
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Chunks",
      "kind" : "struct",
      "line" : 6413,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n",
        "line" : 6415,
        "type" : "(Source source, size_t chunkSize)",
        "parameters" : [
         {
          "name" : "source",
          "type" : "Source"
         },
         {
          "name" : "chunkSize",
          "type" : "size_t"
         }
        ],
        "endline" : 6419
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Range primitives.\n",
        "line" : 6423,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 6426
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6429,
        "type" : "void()",
        "endline" : 6433
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6436,
        "type" : "bool()",
        "endline" : 6439
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6452,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t index)",
        "parameters" : [
         {
          "name" : "index",
          "type" : "size_t"
         }
        ],
        "endline" : 6455
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6458,
        "type" : "typeof(this)(size_t lower, size_t upper)",
        "parameters" : [
         {
          "name" : "lower",
          "type" : "size_t"
         },
         {
          "name" : "upper",
          "type" : "size_t"
         }
        ],
        "endline" : 6463
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6466,
        "type" : "size_t()",
        "endline" : 6470
       },
       {
        "name" : "opDollar",
        "kind" : "alias",
        "line" : 6472,
        "type" : "length"
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6476,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 6491
       },
       {
        "name" : "popBack",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6494,
        "type" : "void()",
        "endline" : 6509
       },
       {
        "name" : "_source",
        "kind" : "variable",
        "line" : 6512,
        "type" : "Source"
       },
       {
        "name" : "_chunkSize",
        "kind" : "variable",
        "line" : 6513,
        "type" : "size_t"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 6517,
    "name" : "chunks",
    "parameters" : [
     {
      "name" : "Source",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "chunks",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 6517,
      "type" : "Chunks!(Source)(Source source, size_t chunkSize)",
      "parameters" : [
       {
        "name" : "source",
        "type" : "Source"
       },
       {
        "name" : "chunkSize",
        "type" : "size_t"
       }
      ],
      "endline" : 6520
     }
    ]
   },
   {
    "name" : "__unittestL6522_1485",
    "kind" : "function",
    "line" : 6522,
    "endline" : 6558
   },
   {
    "kind" : "template",
    "comment" : "\nThis range iterates a single element. This is useful when a sole value\nmust be passed to an algorithm expecting a range.\n\nExample:\n----\nassert(equal(only('♡'), \"♡\"));\nassert([1, 2, 3, 4].findSplitBefore(only(3))[0] == [1, 2]);\n\nstring title = \"The D Programming Language\";\nassert(filter!isUpper(title).map!only().join(\".\") == \"T.D.P.L\");\n----\n \n",
    "line" : 6558,
    "name" : "only",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "only",
      "kind" : "function",
      "comment" : "\nThis range iterates a single element. This is useful when a sole value\nmust be passed to an algorithm expecting a range.\n\nExample:\n----\nassert(equal(only('♡'), \"♡\"));\nassert([1, 2, 3, 4].findSplitBefore(only(3))[0] == [1, 2]);\n\nstring title = \"The D Programming Language\";\nassert(filter!isUpper(title).map!only().join(\".\") == \"T.D.P.L\");\n----\n \n",
      "line" : 6558,
      "storageClass" : [
       "auto"
      ],
      "type" : "(T value)",
      "parameters" : [
       {
        "name" : "value",
        "type" : "T"
       }
      ],
      "endline" : 6595
     }
    ]
   },
   {
    "name" : "__unittestL6597_1486",
    "kind" : "function",
    "line" : 6597,
    "endline" : 6655
   },
   {
    "kind" : "template",
    "comment" : "\n   Moves the front of $(D r) out and returns it. Leaves $(D r.front) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
    "line" : 6655,
    "name" : "moveFront",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "moveFront",
      "kind" : "function",
      "comment" : "\n   Moves the front of $(D r) out and returns it. Leaves $(D r.front) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
      "line" : 6655,
      "type" : "ElementType!(R)(R r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       }
      ],
      "endline" : 6667
     }
    ]
   },
   {
    "name" : "__unittestL6669_1487",
    "kind" : "function",
    "line" : 6669,
    "endline" : 6685
   },
   {
    "kind" : "template",
    "comment" : "\n   Moves the back of $(D r) out and returns it. Leaves $(D r.back) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
    "line" : 6685,
    "name" : "moveBack",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "moveBack",
      "kind" : "function",
      "comment" : "\n   Moves the back of $(D r) out and returns it. Leaves $(D r.back) in a\n   destroyable state that does not allocate any resources (usually equal\n   to its $(D .init) value).\n",
      "line" : 6685,
      "type" : "ElementType!(R)(R r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       }
      ],
      "endline" : 6697
     }
    ]
   },
   {
    "name" : "__unittestL6699_1488",
    "kind" : "function",
    "line" : 6699,
    "endline" : 6721
   },
   {
    "kind" : "template",
    "comment" : "\n   Moves element at index $(D i) of $(D r) out and returns it. Leaves $(D\n   r.front) in a destroyable state that does not allocate any resources\n   (usually equal to its $(D .init) value).\n",
    "line" : 6721,
    "name" : "moveAt",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "I",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "moveAt",
      "kind" : "function",
      "comment" : "\n   Moves element at index $(D i) of $(D r) out and returns it. Leaves $(D\n   r.front) in a destroyable state that does not allocate any resources\n   (usually equal to its $(D .init) value).\n",
      "line" : 6721,
      "type" : "ElementType!(R)(R r, I i)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       },
       {
        "name" : "i",
        "type" : "I"
       }
      ],
      "endline" : 6733
     }
    ]
   },
   {
    "name" : "__unittestL6735_1489",
    "kind" : "function",
    "line" : 6735,
    "endline" : 6798
   },
   {
    "kind" : "template",
    "comment" : "These interfaces are intended to provide virtual function-based wrappers\n around input ranges with element type E.  This is useful where a well-defined\n binary interface is required, such as when a DLL function or virtual function\n needs to accept a generic range as a parameter.  Note that\n $(LREF isInputRange) and friends check for conformance to structural\n interfaces, not for implementation of these $(D interface) types.\n\n Examples:\n ---\n void useRange(InputRange!int range) {\n     // Function body.\n }\n\n // Create a range type.\n auto squares = map!\"a * a\"(iota(10));\n\n // Wrap it in an interface.\n auto squaresWrapped = inputRangeObject(squares);\n\n // Use it.\n useRange(squaresWrapped);\n ---\n\n Limitations:\n\n These interfaces are not capable of forwarding $(D ref) access to elements.\n\n Infiniteness of the wrapped range is not propagated.\n\n Length is not propagated in the case of non-random access ranges.\n\n See_Also:\n $(LREF inputRangeObject)\n \n",
    "line" : 6798,
    "name" : "InputRange",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "InputRange",
      "kind" : "interface",
      "line" : 6798,
      "members" : [
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6800,
        "type" : "E()"
       },
       {
        "name" : "moveFront",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6803,
        "type" : "E()"
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6806,
        "type" : "void()"
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6809,
        "type" : "bool()"
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "comment" : "$(D foreach) iteration uses opApply, since one delegate call per loop\n iteration is faster than three virtual function calls.\n     \n",
        "line" : 6823,
        "type" : "int(int delegate(E))",
        "parameters" : [
         {
          "type" : "int delegate(E)"
         }
        ]
       },
       {
        "name" : "opApply",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 6826,
        "type" : "int(int delegate(size_t, E))",
        "parameters" : [
         {
          "type" : "int delegate(size_t, E)"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Interface for a forward range of type $(D E).\n",
    "line" : 6831,
    "name" : "ForwardRange",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ForwardRange",
      "kind" : "interface",
      "line" : 6831,
      "members" : [
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6833,
        "type" : "ForwardRange!(E)()"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Interface for a bidirectional range of type $(D E).\n",
    "line" : 6837,
    "name" : "BidirectionalRange",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "BidirectionalRange",
      "kind" : "interface",
      "line" : 6837,
      "members" : [
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6839,
        "type" : "BidirectionalRange!(E)()"
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6842,
        "type" : "E()"
       },
       {
        "name" : "moveBack",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6845,
        "type" : "E()"
       },
       {
        "name" : "popBack",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6848,
        "type" : "void()"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Interface for a finite random access range of type $(D E).\n",
    "line" : 6852,
    "name" : "RandomAccessFinite",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RandomAccessFinite",
      "kind" : "interface",
      "line" : 6852,
      "members" : [
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6854,
        "type" : "RandomAccessFinite!(E)()"
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6857,
        "type" : "E(size_t)",
        "parameters" : [
         {
          "type" : "size_t"
         }
        ]
       },
       {
        "name" : "moveAt",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6860,
        "type" : "E(size_t)",
        "parameters" : [
         {
          "type" : "size_t"
         }
        ]
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6863,
        "type" : "size_t()"
       },
       {
        "name" : "opDollar",
        "kind" : "alias",
        "comment" : "\n",
        "line" : 6866,
        "type" : "length"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Interface for an infinite random access range of type $(D E).\n",
    "line" : 6877,
    "name" : "RandomAccessInfinite",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RandomAccessInfinite",
      "kind" : "interface",
      "line" : 6877,
      "members" : [
       {
        "name" : "moveAt",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6879,
        "type" : "E(size_t)",
        "parameters" : [
         {
          "type" : "size_t"
         }
        ]
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6882,
        "type" : "RandomAccessInfinite!(E)()"
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6885,
        "type" : "E(size_t)",
        "parameters" : [
         {
          "type" : "size_t"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Adds assignable elements to InputRange.\n",
    "line" : 6889,
    "name" : "InputAssignable",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "InputAssignable",
      "kind" : "interface",
      "line" : 6889,
      "members" : [
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6891,
        "type" : "void(E newVal)",
        "parameters" : [
         {
          "name" : "newVal",
          "type" : "E"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Adds assignable elements to ForwardRange.\n",
    "line" : 6895,
    "name" : "ForwardAssignable",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ForwardAssignable",
      "kind" : "interface",
      "line" : 6895,
      "members" : [
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6897,
        "type" : "ForwardAssignable!(E)()"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Adds assignable elements to BidirectionalRange.\n",
    "line" : 6901,
    "name" : "BidirectionalAssignable",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "BidirectionalAssignable",
      "kind" : "interface",
      "line" : 6901,
      "members" : [
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6903,
        "type" : "BidirectionalAssignable!(E)()"
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6906,
        "type" : "void(E newVal)",
        "parameters" : [
         {
          "name" : "newVal",
          "type" : "E"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Adds assignable elements to RandomAccessFinite.\n",
    "line" : 6910,
    "name" : "RandomFiniteAssignable",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RandomFiniteAssignable",
      "kind" : "interface",
      "line" : 6910,
      "members" : [
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6912,
        "type" : "RandomFiniteAssignable!(E)()"
       },
       {
        "name" : "opIndexAssign",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6915,
        "type" : "void(E val, size_t index)",
        "parameters" : [
         {
          "name" : "val",
          "type" : "E"
         },
         {
          "name" : "index",
          "type" : "size_t"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Interface for an output range of type $(D E).  Usage is similar to the\n $(D InputRange) interface and descendants.\n",
    "line" : 6920,
    "name" : "OutputRange",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "OutputRange",
      "kind" : "interface",
      "line" : 6920,
      "members" : [
       {
        "name" : "put",
        "kind" : "function",
        "comment" : "\n",
        "line" : 6922,
        "type" : "void(E)",
        "parameters" : [
         {
          "type" : "E"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 6927,
    "name" : "putMethods",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "putMethods",
      "kind" : "function",
      "line" : 6927,
      "type" : "string()",
      "endline" : 6935
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Implements the $(D OutputRange) interface for all types E and wraps the\n $(D put) method for each type $(D E) in a virtual function.\n \n",
    "line" : 6940,
    "name" : "OutputRangeObject",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "E",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "OutputRangeObject",
      "kind" : "class",
      "line" : 6940,
      "members" : [
       {
        "name" : "_range",
        "kind" : "variable",
        "line" : 6943,
        "type" : "R"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 6945,
        "type" : "(R range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         }
        ],
        "endline" : 6947
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Returns the interface type that best matches $(D R).\n",
    "line" : 6954,
    "name" : "MostDerivedInputRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "E",
      "kind" : "alias",
      "line" : 6955,
      "type" : "ElementType!(R)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Implements the most derived interface that $(D R) works with and wraps\n all relevant range primitives in virtual functions.  If $(D R) is already\n derived from the $(D InputRange) interface, aliases itself away.\n \n",
    "line" : 6990,
    "name" : "InputRangeObject",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "Convenience function for creating an $(D InputRangeObject) of the proper type.\n See $(LREF InputRange) for an example.\n \n",
    "line" : 7108,
    "name" : "inputRangeObject",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "inputRangeObject",
      "kind" : "function",
      "comment" : "Convenience function for creating an $(D InputRangeObject) of the proper type.\n See $(LREF InputRange) for an example.\n \n",
      "line" : 7108,
      "type" : "InputRangeObject!(R)(R range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R"
       }
      ],
      "endline" : 7114
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "Convenience function for creating an $(D OutputRangeObject) with a base range\n of type $(D R) that accepts types $(D E).\n\n Examples:\n ---\n uint[] outputArray;\n auto app = appender(&outputArray);\n auto appWrapped = outputRangeObject!(uint, uint[])(app);\n static assert(is(typeof(appWrapped) : OutputRange!(uint[])));\n static assert(is(typeof(appWrapped) : OutputRange!(uint)));\n ---\n",
    "line" : 7128,
    "name" : "outputRangeObject",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "comment" : "\n",
      "line" : 7131,
      "name" : "outputRangeObject",
      "parameters" : [
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "outputRangeObject",
        "kind" : "function",
        "comment" : "\n",
        "line" : 7131,
        "type" : "OutputRangeObject!(R, E)(R range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R"
         }
        ],
        "endline" : 7133
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL7136_1490",
    "kind" : "function",
    "line" : 7136,
    "endline" : 7190
   },
   {
    "kind" : "template",
    "comment" : "\n  Returns true if $(D fn) accepts variables of type T1 and T2 in any order.\n  The following code should compile:\n  ---\n  T1 foo();\n  T2 bar();\n\n  fn(foo(), bar());\n  fn(bar(), foo());\n  ---\n",
    "line" : 7190,
    "name" : "isTwoWayCompatible",
    "parameters" : [
     {
      "name" : "fn",
      "kind" : "alias"
     },
     {
      "name" : "T1",
      "kind" : "type"
     },
     {
      "name" : "T2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isTwoWayCompatible",
      "kind" : "variable",
      "line" : 7199,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(typeof(()\n{\nT1 foo();\n\nT2 bar();\n\nfn(foo(), bar());\nfn(bar(), foo());\n}\n))"
     }
    ]
   },
   {
    "name" : "SearchPolicy",
    "kind" : "enum",
    "comment" : "\n   Policy used with the searching primitives $(D lowerBound), $(D\n   upperBound), and $(D equalRange) of $(LREF SortedRange) below.\n \n",
    "line" : 7208,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "trot",
      "kind" : "enum member",
      "comment" : "\n       Searches with a step that is grows linearly (1, 2, 3,...)\n       leading to a quadratic search schedule (indexes tried are 0, 1,\n       3, 6, 10, 15, 21, 28,...) Once the search overshoots its target,\n       the remaining interval is searched using binary search. The\n       search is completed in $(BIGOH sqrt(n)) time. Use it when you\n       are reasonably confident that the value is around the beginning\n       of the range.\n    \n",
      "line" : 7218
     },
     {
      "name" : "gallop",
      "kind" : "enum member",
      "comment" : "\n       Performs a $(LUCKY galloping search algorithm), i.e. searches\n       with a step that doubles every time, (1, 2, 4, 8, ...)  leading\n       to an exponential search schedule (indexes tried are 0, 1, 3,\n       7, 15, 31, 63,...) Once the search overshoots its target, the\n       remaining interval is searched using binary search. A value is\n       found in $(BIGOH log(n)) time.\n    \n",
      "line" : 7228
     },
     {
      "name" : "binarySearch",
      "kind" : "enum member",
      "comment" : "\n       Searches using a classic interval halving policy. The search\n       starts in the middle of the range, and each search step cuts\n       the range in half. This policy finds a value in $(BIGOH log(n))\n       time but is less cache friendly than $(D gallop) for large\n       ranges. The $(D binarySearch) policy is used as the last step\n       of $(D trot), $(D gallop), $(D trotBackwards), and $(D\n       gallopBackwards) strategies.\n    \n",
      "line" : 7239
     },
     {
      "name" : "trotBackwards",
      "kind" : "enum member",
      "comment" : "\n       Similar to $(D trot) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n    \n",
      "line" : 7245
     },
     {
      "name" : "gallopBackwards",
      "kind" : "enum member",
      "comment" : "\n       Similar to $(D gallop) but starts backwards. Use it when\n       confident that the value is around the end of the range.\n    \n",
      "line" : 7251
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Represents a sorted random-access range. In addition to the regular\n   range primitives, supports fast operations using binary search. To\n   obtain a $(D SortedRange) from an unsorted range $(D r), use\n   $(XREF algorithm, sort) which sorts $(D r) in place and returns the\n   corresponding $(D SortedRange). To construct a $(D SortedRange)\n   from a range $(D r) that is known to be already sorted, use\n   $(LREF assumeSorted) described below.\n\n   Example:\n\n   ----\n   auto a = [ 1, 2, 3, 42, 52, 64 ];\n   auto r = assumeSorted(a);\n   assert(r.contains(3));\n   assert(!r.contains(32));\n   auto r1 = sort!\"a > b\"(a);\n   assert(r1.contains(3));\n   assert(!r1.contains(32));\n   assert(r1.release() == [ 64, 52, 42, 3, 2, 1 ]);\n   ----\n\n   $(D SortedRange) could accept ranges weaker than random-access, but it\n   is unable to provide interesting functionality for them. Therefore,\n   $(D SortedRange) is currently restricted to random-access ranges.\n\n   No copy of the original range is ever made. If the underlying range is\n   changed concurrently with its corresponding $(D SortedRange) in ways\n   that break its sortedness, $(D SortedRange) will work erratically.\n\n   Example:\n\n   ----\n   auto a = [ 1, 2, 3, 42, 52, 64 ];\n   auto r = assumeSorted(a);\n   assert(r.contains(42));\n   swap(a[3], a[5]);                      // illegal to break sortedness of original range\n   assert(!r.contains(42));                // passes although it shouldn't\n   ----\n",
    "line" : 7296,
    "name" : "SortedRange",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     }
    ],
    "members" : [
     {
      "name" : "SortedRange",
      "kind" : "struct",
      "line" : 7296,
      "members" : [
       {
        "name" : "predFun",
        "kind" : "alias",
        "line" : 7297,
        "type" : "binaryFun!(pred)"
       },
       {
        "kind" : "template",
        "line" : 7298,
        "name" : "geq",
        "parameters" : [
         {
          "name" : "L",
          "kind" : "type"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "geq",
          "kind" : "function",
          "line" : 7298,
          "type" : "bool(L lhs, R rhs)",
          "parameters" : [
           {
            "name" : "lhs",
            "type" : "L"
           },
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 7301
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 7302,
        "name" : "gt",
        "parameters" : [
         {
          "name" : "L",
          "kind" : "type"
         },
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "gt",
          "kind" : "function",
          "line" : 7302,
          "type" : "bool(L lhs, R rhs)",
          "parameters" : [
           {
            "name" : "lhs",
            "type" : "L"
           },
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 7305
         }
        ]
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 7306,
        "type" : "Range"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 7310,
        "type" : "(Range input)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         }
        ],
        "endline" : 7328
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : " Range primitives.\n",
        "line" : 7331,
        "type" : "bool()",
        "endline" : 7334
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7338,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 7343
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7347,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 7349
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7352,
        "type" : "void()",
        "endline" : 7355
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7359,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 7361
       },
       {
        "name" : "popBack",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7364,
        "type" : "void()",
        "endline" : 7367
       },
       {
        "name" : "opIndex",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7371,
        "storageClass" : [
         "auto"
        ],
        "type" : "(size_t i)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "size_t"
         }
        ],
        "endline" : 7373
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 7386,
        "type" : "size_t()",
        "endline" : 7389
       },
       {
        "name" : "opDollar",
        "kind" : "alias",
        "line" : 7391,
        "type" : "length"
       },
       {
        "name" : "release",
        "kind" : "function",
        "comment" : "\n   Releases the controlled range and returns it.\n",
        "line" : 7397,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 7399
       },
       {
        "kind" : "template",
        "line" : 7404,
        "name" : "getTransitionIndex",
        "parameters" : [
         {
          "name" : "sp",
          "kind" : "value",
          "type" : "SearchPolicy"
         },
         {
          "name" : "test",
          "kind" : "alias"
         },
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "getTransitionIndex",
          "kind" : "function",
          "line" : 7404,
          "type" : "size_t(V v)",
          "parameters" : [
           {
            "name" : "v",
            "type" : "V"
           }
          ],
          "endline" : 7422
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 7425,
        "name" : "getTransitionIndex",
        "parameters" : [
         {
          "name" : "sp",
          "kind" : "value",
          "type" : "SearchPolicy"
         },
         {
          "name" : "test",
          "kind" : "alias"
         },
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "getTransitionIndex",
          "kind" : "function",
          "line" : 7425,
          "type" : "size_t(V v)",
          "parameters" : [
           {
            "name" : "v",
            "type" : "V"
           }
          ],
          "endline" : 7454
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 7457,
        "name" : "getTransitionIndex",
        "parameters" : [
         {
          "name" : "sp",
          "kind" : "value",
          "type" : "SearchPolicy"
         },
         {
          "name" : "test",
          "kind" : "alias"
         },
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "getTransitionIndex",
          "kind" : "function",
          "line" : 7457,
          "type" : "size_t(V v)",
          "parameters" : [
           {
            "name" : "v",
            "type" : "V"
           }
          ],
          "endline" : 7485
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest left subrange on which $(D pred(x, value)) is $(D true) for\n   all $(D x) (e.g., if $(D pred) is \"less than\", returns the portion of\n   the range with elements strictly smaller than $(D value)). The search\n   schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com/tech/stl/lower_bound.html, lower_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n   auto p = a.lowerBound(4);\n   assert(equal(p, [ 0, 1, 2, 3 ]));\n   ----\n",
        "line" : 7504,
        "name" : "lowerBound",
        "parameters" : [
         {
          "name" : "sp",
          "kind" : "value",
          "type" : "SearchPolicy",
          "defaultValue" : "SearchPolicy.binarySearch"
         },
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "lowerBound",
          "kind" : "function",
          "comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest left subrange on which $(D pred(x, value)) is $(D true) for\n   all $(D x) (e.g., if $(D pred) is \"less than\", returns the portion of\n   the range with elements strictly smaller than $(D value)). The search\n   schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com/tech/stl/lower_bound.html, lower_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]);\n   auto p = a.lowerBound(4);\n   assert(equal(p, [ 0, 1, 2, 3 ]));\n   ----\n",
          "line" : 7504,
          "storageClass" : [
           "auto"
          ],
          "type" : "(V value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "V"
           }
          ],
          "endline" : 7508
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest right subrange on which $(D pred(value, x)) is $(D true)\n   for all $(D x) (e.g., if $(D pred) is \"less than\", returns the\n   portion of the range with elements strictly greater than $(D\n   value)). The search schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com/tech/stl/lower_bound.html,upper_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);\n   auto p = a.upperBound(3);\n   assert(equal(p, [4, 4, 5, 6]));\n   ----\n",
        "line" : 7527,
        "name" : "upperBound",
        "parameters" : [
         {
          "name" : "sp",
          "kind" : "value",
          "type" : "SearchPolicy",
          "defaultValue" : "SearchPolicy.binarySearch"
         },
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "upperBound",
          "kind" : "function",
          "comment" : "\n   This function uses binary search with policy $(D sp) to find the\n   largest right subrange on which $(D pred(value, x)) is $(D true)\n   for all $(D x) (e.g., if $(D pred) is \"less than\", returns the\n   portion of the range with elements strictly greater than $(D\n   value)). The search schedule and its complexity are documented in\n   $(LREF SearchPolicy).  See also STL's\n   $(WEB sgi.com/tech/stl/lower_bound.html,upper_bound).\n\n   Example:\n   ----\n   auto a = assumeSorted([ 1, 2, 3, 3, 3, 4, 4, 5, 6 ]);\n   auto p = a.upperBound(3);\n   assert(equal(p, [4, 4, 5, 6]));\n   ----\n",
          "line" : 7527,
          "storageClass" : [
           "auto"
          ],
          "type" : "(V value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "V"
           }
          ],
          "endline" : 7531
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Returns the subrange containing all elements $(D e) for which both $(D\n   pred(e, value)) and $(D pred(value, e)) evaluate to $(D false) (e.g.,\n   if $(D pred) is \"less than\", returns the portion of the range with\n   elements equal to $(D value)). Uses a classic binary search with\n   interval halving until it finds a value that satisfies the condition,\n   then uses $(D SearchPolicy.gallopBackwards) to find the left boundary\n   and $(D SearchPolicy.gallop) to find the right boundary. These\n   policies are justified by the fact that the two boundaries are likely\n   to be near the first found value (i.e., equal ranges are relatively\n   small). Completes the entire search in $(BIGOH log(n)) time. See also\n   STL's $(WEB sgi.com/tech/stl/equal_range.html, equal_range).\n\n   Example:\n   ----\n   auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\n   auto r = equalRange(a, 3);\n   assert(equal(r, [ 3, 3, 3 ]));\n   ----\n",
        "line" : 7554,
        "name" : "equalRange",
        "parameters" : [
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "equalRange",
          "kind" : "function",
          "comment" : "\n   Returns the subrange containing all elements $(D e) for which both $(D\n   pred(e, value)) and $(D pred(value, e)) evaluate to $(D false) (e.g.,\n   if $(D pred) is \"less than\", returns the portion of the range with\n   elements equal to $(D value)). Uses a classic binary search with\n   interval halving until it finds a value that satisfies the condition,\n   then uses $(D SearchPolicy.gallopBackwards) to find the left boundary\n   and $(D SearchPolicy.gallop) to find the right boundary. These\n   policies are justified by the fact that the two boundaries are likely\n   to be near the first found value (i.e., equal ranges are relatively\n   small). Completes the entire search in $(BIGOH log(n)) time. See also\n   STL's $(WEB sgi.com/tech/stl/equal_range.html, equal_range).\n\n   Example:\n   ----\n   auto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\n   auto r = equalRange(a, 3);\n   assert(equal(r, [ 3, 3, 3 ]));\n   ----\n",
          "line" : 7554,
          "storageClass" : [
           "auto"
          ],
          "type" : "(V value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "V"
           }
          ],
          "endline" : 7590
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nReturns a tuple $(D r) such that $(D r[0]) is the same as the result\nof $(D lowerBound(value)), $(D r[1]) is the same as the result of $(D\nequalRange(value)), and $(D r[2]) is the same as the result of $(D\nupperBound(value)). The call is faster than computing all three\nseparately. Uses a search schedule similar to $(D\nequalRange). Completes the entire search in $(BIGOH log(n)) time.\n\nExample:\n----\nauto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\nauto r = assumeSorted(a).trisect(3);\nassert(equal(r[0], [ 1, 2 ]));\nassert(equal(r[1], [ 3, 3, 3 ]));\nassert(equal(r[2], [ 4, 4, 5, 6 ]));\n----\n",
        "line" : 7610,
        "name" : "trisect",
        "parameters" : [
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "trisect",
          "kind" : "function",
          "comment" : "\nReturns a tuple $(D r) such that $(D r[0]) is the same as the result\nof $(D lowerBound(value)), $(D r[1]) is the same as the result of $(D\nequalRange(value)), and $(D r[2]) is the same as the result of $(D\nupperBound(value)). The call is faster than computing all three\nseparately. Uses a search schedule similar to $(D\nequalRange). Completes the entire search in $(BIGOH log(n)) time.\n\nExample:\n----\nauto a = [ 1, 2, 3, 3, 3, 4, 4, 5, 6 ];\nauto r = assumeSorted(a).trisect(3);\nassert(equal(r[0], [ 1, 2 ]));\nassert(equal(r[1], [ 3, 3, 3 ]));\nassert(equal(r[2], [ 4, 4, 5, 6 ]));\n----\n",
          "line" : 7610,
          "storageClass" : [
           "auto"
          ],
          "type" : "(V value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "V"
           }
          ],
          "endline" : 7648
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange), which is assumed to be sorted. Performs $(BIGOH log(r.length))\nevaluations of $(D pred). See also STL's $(WEB\nsgi.com/tech/stl/binary_search.html, binary_search).\n \n",
        "line" : 7658,
        "name" : "contains",
        "parameters" : [
         {
          "name" : "V",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "contains",
          "kind" : "function",
          "comment" : "\nReturns $(D true) if and only if $(D value) can be found in $(D\nrange), which is assumed to be sorted. Performs $(BIGOH log(r.length))\nevaluations of $(D pred). See also STL's $(WEB\nsgi.com/tech/stl/binary_search.html, binary_search).\n \n",
          "line" : 7658,
          "type" : "bool(V value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "V"
           }
          ],
          "endline" : 7682
         }
        ]
       },
       {
        "name" : "canFind",
        "kind" : "alias",
        "line" : 7685,
        "type" : "contains"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL7689_1492",
    "kind" : "function",
    "line" : 7689,
    "endline" : 7701
   },
   {
    "name" : "__unittestL7701_1493",
    "kind" : "function",
    "line" : 7701,
    "endline" : 7715
   },
   {
    "name" : "__unittestL7715_1494",
    "kind" : "function",
    "line" : 7715,
    "endline" : 7728
   },
   {
    "name" : "__unittestL7728_1495",
    "kind" : "function",
    "line" : 7728,
    "endline" : 7762
   },
   {
    "name" : "__unittestL7762_1496",
    "kind" : "function",
    "line" : 7762,
    "endline" : 7775
   },
   {
    "name" : "__unittestL7775_1497",
    "kind" : "function",
    "line" : 7775,
    "endline" : 7784
   },
   {
    "name" : "__unittestL7784_1498",
    "kind" : "function",
    "line" : 7784,
    "endline" : 7803
   },
   {
    "kind" : "template",
    "comment" : "\nAssumes $(D r) is sorted by predicate $(D pred) and returns the\ncorresponding $(D SortedRange!(pred, R)) having $(D r) as support. To\nkeep the checking costs low, the cost is $(BIGOH 1) in release mode\n(no checks for sortedness are performed). In debug mode, a few random\nelements of $(D r) are checked for sortedness. The size of the sample\nis proportional $(BIGOH log(r.length)). That way, checking has no\neffect on the complexity of subsequent operations specific to sorted\nranges (such as binary search). The probability of an arbitrary\nunsorted range failing the test is very high (however, an\nalmost-sorted range is likely to pass it). To check for sortedness at\ncost $(BIGOH n), use $(XREF algorithm,isSorted).\n \n",
    "line" : 7803,
    "name" : "assumeSorted",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "assumeSorted",
      "kind" : "function",
      "comment" : "\nAssumes $(D r) is sorted by predicate $(D pred) and returns the\ncorresponding $(D SortedRange!(pred, R)) having $(D r) as support. To\nkeep the checking costs low, the cost is $(BIGOH 1) in release mode\n(no checks for sortedness are performed). In debug mode, a few random\nelements of $(D r) are checked for sortedness. The size of the sample\nis proportional $(BIGOH log(r.length)). That way, checking has no\neffect on the complexity of subsequent operations specific to sorted\nranges (such as binary search). The probability of an arbitrary\nunsorted range failing the test is very high (however, an\nalmost-sorted range is likely to pass it). To check for sortedness at\ncost $(BIGOH n), use $(XREF algorithm,isSorted).\n \n",
      "line" : 7803,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R r)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "R"
       }
      ],
      "endline" : 7807
     }
    ]
   },
   {
    "name" : "__unittestL7809_1499",
    "kind" : "function",
    "line" : 7809,
    "endline" : 7823
   },
   {
    "name" : "__unittestL7823_1500",
    "kind" : "function",
    "line" : 7823,
    "endline" : 7832
   },
   {
    "name" : "__unittestL7832_1501",
    "kind" : "function",
    "line" : 7832,
    "endline" : 7849
   },
   {
    "name" : "__unittestL7849_1502",
    "kind" : "function",
    "line" : 7849,
    "endline" : 7860
   },
   {
    "name" : "__unittestL7860_1503",
    "kind" : "function",
    "line" : 7860,
    "endline" : 7919
   },
   {
    "kind" : "template",
    "comment" : "\n    Wrapper which effectively makes it possible to pass a range by reference.\n    Both the original range and the RefRange will always have the exact same\n    elements. Any operation done on one will affect the other. So, for instance,\n    if it's passed to a function which would implicitly copy the original range\n    if it were passed to it, the original range is $(I not) copied but is\n    consumed as if it were a reference type.\n\n    Note that $(D save) works as normal and operates on a new range, so if\n    $(D save) is ever called on the RefRange, then no operations on the saved\n    range will affect the original.\n\n    Examples:\n--------------------\nimport std.algorithm;\nubyte[] buffer = [1, 9, 45, 12, 22];\nauto found1 = find(buffer, 45);\nassert(found1 == [45, 12, 22]);\nassert(buffer == [1, 9, 45, 12, 22]);\n\nauto wrapped1 = refRange(&buffer);\nauto found2 = find(wrapped1, 45);\nassert(*found2.ptr == [45, 12, 22]);\nassert(buffer == [45, 12, 22]);\n\nauto found3 = find(wrapped2.save, 22);\nassert(*found3.ptr == [22]);\nassert(buffer == [45, 12, 22]);\n\nstring str = \"hello world\";\nauto wrappedStr = refRange(&str);\nassert(str.front == 'h');\nstr.popFrontN(5);\nassert(str == \" world\");\nassert(wrappedStr.front == ' ');\nassert(*wrappedStr.ptr == \" world\");\n--------------------\n  \n",
    "line" : 7921,
    "name" : "RefRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RefRange",
      "kind" : "struct",
      "line" : 7921,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : " \n",
        "line" : 7925,
        "type" : "pure nothrow @safe (R* range)",
        "parameters" : [
         {
          "name" : "range",
          "type" : "R*"
         }
        ],
        "endline" : 7928
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\n        This does not assign the pointer of $(D rhs) to this $(D RefRange).\n        Rather it assigns the range pointed to by $(D rhs) to the range pointed\n        to by this $(D RefRange). This is because $(I any) operation on a\n        $(D RefRange) is the same is if it occurred to the original range. The\n        one exception is when a $(D RefRange) is assigned $(D null) either\n        directly or because $(D rhs) is $(D null). In that case, $(D RefRange)\n        no longer refers to the original range but is $(D null).\n\n    Examples:\n--------------------\nubyte[] buffer1 = [1, 2, 3, 4, 5];\nubyte[] buffer2 = [6, 7, 8, 9, 10];\nauto wrapped1 = refRange(&buffer1);\nauto wrapped2 = refRange(&buffer2);\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\nassert(buffer1 != buffer2);\n\nwrapped1 = wrapped2;\n\n//Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//But buffer1 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [6, 7, 8, 9, 10]);\n\nbuffer2 = [11, 12, 13, 14, 15];\n\n//Everything points to the same stuff as before.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is &buffer2);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//But buffer2 has changed due to the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n\nwrapped2 = null;\n\n//The pointer changed for wrapped2 but not wrapped1.\nassert(wrapped1.ptr is &buffer1);\nassert(wrapped2.ptr is null);\nassert(wrapped1.ptr !is wrapped2.ptr);\n\n//buffer2 is not affected by the assignment.\nassert(buffer1 == [6, 7, 8, 9, 10]);\nassert(buffer2 == [11, 12, 13, 14, 15]);\n--------------------\n      \n",
        "line" : 7986,
        "storageClass" : [
         "auto"
        ],
        "type" : "(RefRange rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "RefRange"
         }
        ],
        "endline" : 7993
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : " \n",
        "line" : 7997,
        "storageClass" : [
         "auto"
        ],
        "type" : "(typeof(null) rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "typeof(null)"
         }
        ],
        "endline" : 7999
       },
       {
        "name" : "ptr",
        "kind" : "function",
        "comment" : "\n        A pointer to the wrapped range.\n      \n",
        "line" : 8005,
        "type" : "inout pure nothrow @safe inout(R*)()",
        "endline" : 8008
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " \n",
        "line" : 8061,
        "type" : "void()",
        "endline" : 8064
       },
       {
        "name" : "_range",
        "kind" : "variable",
        "line" : 8294,
        "type" : "R*"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL8298_1504",
    "kind" : "function",
    "line" : 8298,
    "endline" : 8325
   },
   {
    "name" : "__unittestL8325_1505",
    "kind" : "function",
    "line" : 8325,
    "endline" : 8370
   },
   {
    "name" : "__unittestL8370_1506",
    "kind" : "function",
    "line" : 8370,
    "endline" : 8447
   },
   {
    "name" : "__unittestL8447_1507",
    "kind" : "function",
    "line" : 8447,
    "endline" : 8474
   },
   {
    "name" : "__unittestL8474_1508",
    "kind" : "function",
    "line" : 8474,
    "endline" : 8591
   },
   {
    "name" : "__unittestL8591_1509",
    "kind" : "function",
    "line" : 8591,
    "endline" : 8606
   },
   {
    "name" : "__unittestL8606_1510",
    "kind" : "function",
    "line" : 8606,
    "endline" : 8646
   },
   {
    "kind" : "template",
    "comment" : "\n    Helper function for constructing a $(LREF RefRange).\n\n    If the given range is not a forward range or it is a class type (and thus is\n    already a reference type), then the original range is returned rather than\n    a $(LREF RefRange).\n  \n",
    "line" : 8646,
    "name" : "refRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "refRange",
      "kind" : "function",
      "comment" : "\n    Helper function for constructing a $(LREF RefRange).\n\n    If the given range is not a forward range or it is a class type (and thus is\n    already a reference type), then the original range is returned rather than\n    a $(LREF RefRange).\n  \n",
      "line" : 8646,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R* range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R*"
       }
      ],
      "endline" : 8650
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 8652,
    "name" : "refRange",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "refRange",
      "kind" : "function",
      "line" : 8652,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R* range)",
      "parameters" : [
       {
        "name" : "range",
        "type" : "R*"
       }
      ],
      "endline" : 8657
     }
    ]
   },
   {
    "name" : "__unittestL8661_1515",
    "kind" : "function",
    "comment" : "\n",
    "line" : 8661,
    "endline" : 8700
   }
  ]
 },
 {
  "name" : "std.regex",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/regex.d",
  "comment" : "\n  $(LUCKY Regular expressions) are a commonly used method of pattern matching\n  on strings, with $(I regex) being a catchy word for a pattern in this domain\n  specific language. Typical problems usually solved by regular expressions\n  include validation of user input and the ubiquitous find & replace\n  in text processing utilities.\n\n  Synposis:\n  ---\n  import std.regex;\n  import std.stdio;\n  void main()\n  {\n      // Print out all possible dd/mm/yy(yy) dates found in user input.\n      // g - global: find all matches.\n      auto r = regex(r\"\\b[0-9][0-9]?/[0-9][0-9]?/[0-9][0-9](?:[0-9][0-9])?\\b\", \"g\");\n      foreach(line; stdin.byLine)\n      {\n        // Match returns a range that can be iterated\n        // to get all subsequent matches.\n        foreach(c; match(line, r))\n            writeln(c.hit);\n      }\n  }\n  ...\n\n  // Create a static regex at compile-time, which contains fast native code.\n  enum ctr = ctRegex!(`^.*/([^/]+)/?$`);\n\n  // It works just like a normal regex:\n  auto m2 = match(\"foo/bar\", ctr);   // First match found here, if any\n  assert(m2);   // Be sure to check if there is a match before examining contents!\n  assert(m2.captures[1] == \"bar\");   // Captures is a range of submatches: 0 = full match.\n\n  ...\n\n  // The result of the match is directly testable with if/assert/while.\n  // e.g. test if a string consists of letters:\n  assert(match(\"Letter\", `^\\p{L}+$`));\n\n\n  ---\n\n  The general usage guideline is to keep regex complexity on the side of simplicity,\n  as its capabilities reside in purely character-level manipulation,\n  and as such are ill-suited for tasks involving higher level invariants\n  like matching an integer number $(U bounded) in an [a,b] interval.\n  Checks of this sort of are better addressed by additional post-processing.\n\n  The basic syntax shouldn't surprise experienced users of regular expressions.\n  Thankfully, nowadays the web is bustling with resources to help newcomers, and a good\n  $(WEB www.regular-expressions.info, reference with tutorial) on regular expressions\n  can be found.\n\n  This library uses an ECMAScript syntax flavor with the following extensions:\n  $(UL\n    $(LI Named subexpressions, with Python syntax. )\n    $(LI Unicode properties such as Scripts, Blocks and common binary properties e.g Alphabetic, White_Space, Hex_Digit etc.)\n    $(LI Arbitrary length and complexity lookbehind, including lookahead in lookbehind and vise-versa.)\n  )\n\n  $(REG_START Pattern syntax )\n  $(I std.regex operates on codepoint level,\n    'character' in this table denotes a single unicode codepoint.)\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_TITLE Atoms, Match single characters )\n    $(REG_ROW any character except [{|*+?()^$, Matches the character itself. )\n    $(REG_ROW ., In single line mode matches any charcter.\n      Otherwise it matches any character except '\\n' and '\\r'. )\n    $(REG_ROW [class], Matches a single character\n      that belongs to this character class. )\n    $(REG_ROW [^class], Matches a single character that\n      does $(U not) belong to this character class.)\n    $(REG_ROW \\cC, Matches the control character corresponding to letter C)\n    $(REG_ROW \\xXX, Matches a character with hexadecimal value of XX. )\n    $(REG_ROW \\uXXXX, Matches a character  with hexadecimal value of XXXX. )\n    $(REG_ROW \\U00YYYYYY, Matches a character with hexadecimal value of YYYYYY. )\n    $(REG_ROW \\f, Matches a formfeed character. )\n    $(REG_ROW \\n, Matches a linefeed character. )\n    $(REG_ROW \\r, Matches a carriage return character. )\n    $(REG_ROW \\t, Matches a tab character. )\n    $(REG_ROW \\v, Matches a vertical tab character. )\n    $(REG_ROW \\d, Matches any unicode digit. )\n    $(REG_ROW \\D, Matches any character except unicode digits. )\n    $(REG_ROW \\w, Matches any word character (note: this includes numbers).)\n    $(REG_ROW \\W, Matches any non-word character.)\n    $(REG_ROW \\s, Matches whitespace, same as \\p{White_Space}.)\n    $(REG_ROW \\S, Matches any character except those recognized as $(I \\s ). )\n    $(REG_ROW \\\\, Matches \\ character. )\n    $(REG_ROW \\c where c is one of [|*+?(), Matches the character c itself. )\n    $(REG_ROW \\p{PropertyName}, Matches a character that belongs\n      to the unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW  \\P{PropertyName}, Matches a character that does not belong\n      to the unicode PropertyName set.\n      Single letter abbreviations can be used without surrounding {,}. )\n    $(REG_ROW \\p{InBasicLatin}, Matches any character that is part of\n        the BasicLatin unicode $(U block).)\n    $(REG_ROW \\P{InBasicLatin}, Matches any character except ones in\n        the BasicLatin unicode $(U block).)\n    $(REG_ROW \\p{Cyrilic}, Matches any character that is part of\n        Cyrilic $(U script).)\n    $(REG_ROW \\P{Cyrilic}, Matches any character except ones in\n        Cyrilic $(U script).)\n    $(REG_TITLE Quantifiers, Specify repetition of other elements)\n    $(REG_ROW *, Matches previous character/subexpression 0 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW *?, Matches previous character/subexpression 0 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW +, Matches previous character/subexpression 1 or more times.\n      Greedy version - tries as many times as possible.)\n    $(REG_ROW +?, Matches previous character/subexpression 1 or more times.\n      Lazy version  - stops as early as possible.)\n    $(REG_ROW {n}, Matches previous character/subexpression exactly n times. )\n    $(REG_ROW {n&#44}, Matches previous character/subexpression n times or more.\n      Greedy version - tries as many times as possible. )\n    $(REG_ROW {n&#44}?, Matches previous character/subexpression n times or more.\n      Lazy version - stops as early as possible.)\n    $(REG_ROW {n&#44m}, Matches previous character/subexpression n to m times.\n      Greedy version - tries as many times as possible, but no more than m times. )\n    $(REG_ROW {n&#44m}?, Matches previous character/subexpression n to m times.\n      Lazy version - stops as early as possible, but no less then n times.)\n    $(REG_TITLE Other, Subexpressions & alternations )\n    $(REG_ROW (regex),  Matches subexpression regex,\n      saving matched portion of text for later retrieval. )\n    $(REG_ROW (?:regex), Matches subexpression regex,\n      $(U not) saving matched portion of text. Useful to speed up matching. )\n    $(REG_ROW A|B, Matches subexpression A, or failing that, matches B. )\n    $(REG_ROW (?P&lt;name&gt;regex), Matches named subexpression\n        regex labeling it with name 'name'.\n        When referring to a matched portion of text,\n        names work like aliases in addition to direct numbers.\n     )\n    $(REG_TITLE Assertions, Match position rather than character )\n    $(REG_ROW ^, Matches at the begining of input or line (in multiline mode).)\n    $(REG_ROW $, Matches at the end of input or line (in multiline mode). )\n    $(REG_ROW \\b, Matches at word boundary. )\n    $(REG_ROW \\B, Matches when $(U not) at word boundary. )\n    $(REG_ROW (?=regex), Zero-width lookahead assertion.\n        Matches at a point where the subexpression\n        regex could be matched starting from the current position.\n      )\n    $(REG_ROW (?!regex), Zero-width negative lookahead assertion.\n        Matches at a point where the subexpression\n        regex could $(U not) be matched starting from the current position.\n      )\n    $(REG_ROW (?<=regex), Zero-width lookbehind assertion. Matches at a point\n        where the subexpression regex could be matched ending\n        at the current position (matching goes backwards).\n      )\n    $(REG_ROW  (?<!regex), Zero-width negative lookbehind assertion.\n      Matches at a point where the subexpression regex could $(U not)\n      be matched ending at the current position (matching goes backwards).\n     )\n  )\n\n  $(REG_START Character classes )\n  $(REG_TABLE\n    $(REG_TITLE Pattern element, Semantics )\n    $(REG_ROW Any atom, Has the same meaning as outside of a character class.)\n    $(REG_ROW a-z, Includes characters a, b, c, ..., z. )\n    $(REG_ROW [a||b]&#44 [a--b]&#44 [a~~b]&#44 [a&&b], Where a, b are arbitrary classes,\n     means union, set difference, symmetric set difference, and intersection respectively.\n     $(I Any sequence of character class elements implicitly forms a union.) )\n  )\n\n  $(REG_START Regex flags )\n  $(REG_TABLE\n    $(REG_TITLE Flag, Semantics )\n    $(REG_ROW g, Global regex, repeat over the whole input. )\n    $(REG_ROW i, Case insensitive matching. )\n    $(REG_ROW m, Multi-line mode, match ^, $ on start and end line separators\n       as well as start and end of input.)\n    $(REG_ROW s, Single-line mode, makes . match '\\n' and '\\r' as well. )\n    $(REG_ROW x, Free-form syntax, ignores whitespace in pattern,\n      useful for formatting complex regular expressions. )\n  )\n\n  $(B Unicode support)\n\n  This library provides full Level 1 support* according to\n    $(WEB unicode.org/reports/tr18/, UTS 18). Specifically:\n  $(UL\n    $(LI 1.1 Hex notation via any of \\uxxxx, \\U00YYYYYY, \\xZZ.)\n    $(LI 1.2 Unicode properties.)\n    $(LI 1.3 Character classes with set operations.)\n    $(LI 1.4 Word boundaries use the full set of \"word\" characters.)\n    $(LI 1.5 Using simple casefolding to match case\n        insensitively across the full range of codepoints.)\n    $(LI 1.6 Respecting line breaks as any of\n        \\u000A | \\u000B | \\u000C | \\u000D | \\u0085 | \\u2028 | \\u2029 | \\u000D\\u000A.)\n    $(LI 1.7 Operating on codepoint level.)\n  )\n  *With exception of point 1.1.1, as of yet, normalization of input\n    is expected to be enforced by user.\n\n  $(B Slicing)\n\n  All matches returned by pattern matching functionality in this library\n  are slices of the original input, with the notable exception of the $(D replace)\n  family of functions which generate a new string from the input.\n\n  Copyright: Copyright Dmitry Olshansky, 2011\n\n  License: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\n  Authors: Dmitry Olshansky,\n\n  API and utility constructs are based on original $(D std.regex)\n  by Walter Bright and Andrei Alexandrescu.\n\n  Source: $(PHOBOSSRC std/_regex.d)\n\nMacros:\n    REG_ROW = $(TR $(TD $(I $1 )) $(TD $+) )\n    REG_TITLE = $(TR $(TD $(B $1)) $(TD $(B $2)) )\n    REG_TABLE = <table border=\"1\" cellspacing=\"0\" cellpadding=\"5\" > $0 </table>\n    REG_START = <h3><div align=\"center\"> $0 </div></h3>\n \n",
  "members" : [
   {
    "name" : "std.internal.uni",
    "kind" : "import",
    "line" : 225,
    "protection" : "private"
   },
   {
    "name" : "std.internal.uni_tab",
    "kind" : "import",
    "line" : 225,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 226,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 226,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 226,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 227,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 227,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 227,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 227,
    "protection" : "private"
   },
   {
    "name" : "std.uni",
    "kind" : "import",
    "line" : 228,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 228,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 228,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 228,
    "protection" : "private"
   },
   {
    "name" : "std.bitmanip",
    "kind" : "import",
    "line" : 228,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 229,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 229,
    "protection" : "private"
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 230,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 230,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 230,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 231,
    "protection" : "private",
    "alias" : "ascii"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 232,
    "protection" : "private",
    "selective" : [
     "representation"
    ]
   },
   {
    "name" : "IR",
    "kind" : "enum",
    "line" : 257,
    "baseDeco" : "k",
    "members" : [
     {
      "name" : "Char",
      "kind" : "enum member",
      "line" : 258
     },
     {
      "name" : "Any",
      "kind" : "enum member",
      "line" : 259
     },
     {
      "name" : "CodepointSet",
      "kind" : "enum member",
      "line" : 260
     },
     {
      "name" : "Trie",
      "kind" : "enum member",
      "line" : 261
     },
     {
      "name" : "OrChar",
      "kind" : "enum member",
      "line" : 267
     },
     {
      "name" : "Nop",
      "kind" : "enum member",
      "line" : 268
     },
     {
      "name" : "End",
      "kind" : "enum member",
      "line" : 269
     },
     {
      "name" : "Bol",
      "kind" : "enum member",
      "line" : 270
     },
     {
      "name" : "Eol",
      "kind" : "enum member",
      "line" : 271
     },
     {
      "name" : "Wordboundary",
      "kind" : "enum member",
      "line" : 272
     },
     {
      "name" : "Notwordboundary",
      "kind" : "enum member",
      "line" : 273
     },
     {
      "name" : "Backref",
      "kind" : "enum member",
      "line" : 274
     },
     {
      "name" : "GroupStart",
      "kind" : "enum member",
      "line" : 275
     },
     {
      "name" : "GroupEnd",
      "kind" : "enum member",
      "line" : 276
     },
     {
      "name" : "Option",
      "kind" : "enum member",
      "line" : 277
     },
     {
      "name" : "GotoEndOr",
      "kind" : "enum member",
      "line" : 278
     },
     {
      "name" : "OrStart",
      "kind" : "enum member",
      "line" : 281
     },
     {
      "name" : "OrEnd",
      "kind" : "enum member",
      "line" : 282
     },
     {
      "name" : "InfiniteStart",
      "kind" : "enum member",
      "line" : 285
     },
     {
      "name" : "InfiniteEnd",
      "kind" : "enum member",
      "line" : 286
     },
     {
      "name" : "InfiniteQStart",
      "kind" : "enum member",
      "line" : 287
     },
     {
      "name" : "InfiniteQEnd",
      "kind" : "enum member",
      "line" : 288
     },
     {
      "name" : "RepeatStart",
      "kind" : "enum member",
      "line" : 289
     },
     {
      "name" : "RepeatEnd",
      "kind" : "enum member",
      "line" : 290
     },
     {
      "name" : "RepeatQStart",
      "kind" : "enum member",
      "line" : 291
     },
     {
      "name" : "RepeatQEnd",
      "kind" : "enum member",
      "line" : 292
     },
     {
      "name" : "LookaheadStart",
      "kind" : "enum member",
      "line" : 294
     },
     {
      "name" : "LookaheadEnd",
      "kind" : "enum member",
      "line" : 295
     },
     {
      "name" : "NeglookaheadStart",
      "kind" : "enum member",
      "line" : 296
     },
     {
      "name" : "NeglookaheadEnd",
      "kind" : "enum member",
      "line" : 297
     },
     {
      "name" : "LookbehindStart",
      "kind" : "enum member",
      "line" : 298
     },
     {
      "name" : "LookbehindEnd",
      "kind" : "enum member",
      "line" : 299
     },
     {
      "name" : "NeglookbehindStart",
      "kind" : "enum member",
      "line" : 300
     },
     {
      "name" : "NeglookbehindEnd",
      "kind" : "enum member",
      "line" : 301
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 305,
    "name" : "IRL",
    "parameters" : [
     {
      "name" : "code",
      "kind" : "value",
      "deco" : "E3std5regex2IR"
     }
    ],
    "members" : [
     {
      "name" : "IRL",
      "kind" : "variable",
      "line" : 307,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "lengthOfIR(code)"
     }
    ]
   },
   {
    "name" : "immediateParamsIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 313,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZi",
    "originalType" : "int(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 324
   },
   {
    "name" : "lengthOfIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 327,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZi",
    "originalType" : "int(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 330
   },
   {
    "name" : "lengthOfPairedIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 333,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZi",
    "originalType" : "int(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 336
   },
   {
    "name" : "hasMerge",
    "kind" : "function",
    "protection" : "private",
    "line" : 339,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZb",
    "originalType" : "bool(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 342
   },
   {
    "name" : "isStartIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 345,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZb",
    "originalType" : "bool(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 348
   },
   {
    "name" : "isEndIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 351,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZb",
    "originalType" : "bool(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 354
   },
   {
    "name" : "isAtomIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 357,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZb",
    "originalType" : "bool(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 360
   },
   {
    "name" : "pairedIR",
    "kind" : "function",
    "protection" : "private",
    "line" : 363,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfE3std5regex2IRZE3std5regex2IR",
    "originalType" : "IR(IR i)",
    "parameters" : [
     {
      "name" : "i",
      "deco" : "E3std5regex2IR"
     }
    ],
    "endline" : 367
   },
   {
    "name" : "Bytecode",
    "kind" : "struct",
    "protection" : "private",
    "line" : 371,
    "members" : [
     {
      "name" : "raw",
      "kind" : "variable",
      "line" : 372,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "k",
      "offset" : 0
     },
     {
      "name" : "maxSequence",
      "kind" : "variable",
      "line" : 374,
      "storageClass" : [
       "enum",
       "@safe"
      ],
      "deco" : "i",
      "init" : "6"
     },
     {
      "name" : "maxData",
      "kind" : "variable",
      "line" : 375,
      "storageClass" : [
       "enum",
       "@safe"
      ],
      "deco" : "i",
      "init" : "4194304"
     },
     {
      "name" : "maxRaw",
      "kind" : "variable",
      "line" : 376,
      "storageClass" : [
       "enum",
       "@safe"
      ],
      "deco" : "i",
      "init" : "-2147483648"
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 378,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNcNfE3std5regex2IRkZS3std5regex8Bytecode",
      "originalType" : "(IR code, uint data)",
      "parameters" : [
       {
        "name" : "code",
        "deco" : "E3std5regex2IR"
       },
       {
        "name" : "data",
        "deco" : "k"
       }
      ],
      "endline" : 382
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 384,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNcNfE3std5regex2IRkkZS3std5regex8Bytecode",
      "originalType" : "(IR code, uint data, uint seq)",
      "parameters" : [
       {
        "name" : "code",
        "deco" : "E3std5regex2IR"
       },
       {
        "name" : "data",
        "deco" : "k"
       },
       {
        "name" : "seq",
        "deco" : "k"
       }
      ],
      "endline" : 389
     },
     {
      "name" : "fromRaw",
      "kind" : "function",
      "line" : 392,
      "storageClass" : [
       "static",
       "@safe"
      ],
      "deco" : "FNfkZS3std5regex8Bytecode",
      "originalType" : "Bytecode(uint data)",
      "parameters" : [
       {
        "name" : "data",
        "deco" : "k"
       }
      ],
      "endline" : 397
     },
     {
      "name" : "data",
      "kind" : "function",
      "line" : 400,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZk",
      "originalType" : "const uint()",
      "endline" : 400
     },
     {
      "name" : "sequence",
      "kind" : "function",
      "line" : 403,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZk",
      "originalType" : "const uint()",
      "endline" : 403
     },
     {
      "name" : "code",
      "kind" : "function",
      "line" : 406,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZE3std5regex2IR",
      "originalType" : "const IR()",
      "endline" : 406
     },
     {
      "name" : "hotspot",
      "kind" : "function",
      "line" : 409,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZb",
      "originalType" : "const bool()",
      "endline" : 409
     },
     {
      "name" : "isAtom",
      "kind" : "function",
      "line" : 412,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZb",
      "originalType" : "const bool()",
      "endline" : 412
     },
     {
      "name" : "isStart",
      "kind" : "function",
      "line" : 415,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZb",
      "originalType" : "const bool()",
      "endline" : 415
     },
     {
      "name" : "isEnd",
      "kind" : "function",
      "line" : 418,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZb",
      "originalType" : "const bool()",
      "endline" : 418
     },
     {
      "name" : "args",
      "kind" : "function",
      "line" : 421,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZi",
      "originalType" : "const int()",
      "endline" : 421
     },
     {
      "name" : "setBackrefence",
      "kind" : "function",
      "line" : 424,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfZv",
      "originalType" : "void()",
      "endline" : 428
     },
     {
      "name" : "backreference",
      "kind" : "function",
      "line" : 431,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZb",
      "originalType" : "const bool()",
      "endline" : 435
     },
     {
      "name" : "setLocalRef",
      "kind" : "function",
      "line" : 438,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfZv",
      "originalType" : "void()",
      "endline" : 442
     },
     {
      "name" : "localRef",
      "kind" : "function",
      "line" : 445,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZb",
      "originalType" : "const bool()",
      "endline" : 449
     },
     {
      "name" : "mnemonic",
      "kind" : "function",
      "line" : 452,
      "storageClass" : [
       "@property",
       "@trusted"
      ],
      "deco" : "xFNdNeZAya",
      "originalType" : "const string()",
      "endline" : 455
     },
     {
      "name" : "length",
      "kind" : "function",
      "line" : 458,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZk",
      "originalType" : "const uint()",
      "endline" : 461
     },
     {
      "name" : "pairedLength",
      "kind" : "function",
      "line" : 464,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZk",
      "originalType" : "const uint()",
      "endline" : 467
     },
     {
      "name" : "paired",
      "kind" : "function",
      "line" : 470,
      "storageClass" : [
       "@property",
       "@safe"
      ],
      "deco" : "xFNdNfZS3std5regex8Bytecode",
      "originalType" : "const Bytecode()",
      "endline" : 474
     },
     {
      "name" : "indexOfPair",
      "kind" : "function",
      "line" : 477,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "xFNfkZk",
      "originalType" : "const uint(uint pc)",
      "parameters" : [
       {
        "name" : "pc",
        "deco" : "k"
       }
      ],
      "endline" : 481
     }
    ]
   },
   {
    "name" : "disassemble",
    "kind" : "function",
    "protection" : "private",
    "line" : 487,
    "storageClass" : [
     "@trusted"
    ],
    "deco" : "FNexAS3std5regex8BytecodekxAS3std5regex10NamedGroupZAya",
    "originalType" : "string(in Bytecode[] irb, uint pc, in NamedGroup[] dict = [])",
    "parameters" : [
     {
      "name" : "irb",
      "deco" : "xAS3std5regex8Bytecode"
     },
     {
      "name" : "pc",
      "deco" : "k"
     },
     {
      "name" : "dict",
      "deco" : "xAS3std5regex10NamedGroup",
      "default" : "[]"
     }
    ],
    "endline" : 545
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 548,
    "name" : "prettyPrint",
    "parameters" : [
     {
      "name" : "Sink",
      "kind" : "type"
     },
     {
      "name" : "Char",
      "kind" : "type",
      "defaultDeco" : "xa"
     }
    ],
    "members" : [
     {
      "name" : "prettyPrint",
      "kind" : "function",
      "line" : 548,
      "type" : "void(Sink sink, const(Bytecode)[] irb, uint pc = (uint).max, int indent = 3, size_t index = 0)",
      "parameters" : [
       {
        "name" : "sink",
        "type" : "Sink"
       },
       {
        "name" : "irb",
        "type" : "const(Bytecode)[]"
       },
       {
        "name" : "pc",
        "deco" : "k",
        "default" : "(uint).max"
       },
       {
        "name" : "indent",
        "deco" : "i",
        "default" : "3"
       },
       {
        "name" : "index",
        "type" : "size_t",
        "default" : "0"
       }
      ],
      "endline" : 618
     }
    ]
   },
   {
    "name" : "NamedGroup",
    "kind" : "struct",
    "protection" : "private",
    "line" : 622,
    "members" : [
     {
      "name" : "name",
      "kind" : "variable",
      "line" : 623,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "Aya",
      "offset" : 0
     },
     {
      "name" : "group",
      "kind" : "variable",
      "line" : 624,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "k",
      "offset" : 16
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std5regex10NamedGroupKxS3std5regex10NamedGroupZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5regex10NamedGroup",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std5regex10NamedGroup",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 629,
    "name" : "Group",
    "parameters" : [
     {
      "name" : "DataIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Group",
      "kind" : "struct",
      "line" : 629,
      "members" : [
       {
        "name" : "begin",
        "kind" : "variable",
        "line" : 630,
        "type" : "DataIndex"
       },
       {
        "name" : "end",
        "kind" : "variable",
        "line" : 630,
        "type" : "DataIndex"
       },
       {
        "name" : "toString",
        "kind" : "function",
        "line" : 631,
        "type" : "const string()",
        "endline" : 636
       }
      ]
     }
    ]
   },
   {
    "name" : "RegexOption",
    "kind" : "enum",
    "line" : 644,
    "baseDeco" : "k",
    "members" : [
     {
      "name" : "global",
      "kind" : "enum member",
      "line" : 645
     },
     {
      "name" : "casefold",
      "kind" : "enum member",
      "line" : 646
     },
     {
      "name" : "freeform",
      "kind" : "enum member",
      "line" : 647
     },
     {
      "name" : "nonunicode",
      "kind" : "enum member",
      "line" : 648
     },
     {
      "name" : "multiline",
      "kind" : "enum member",
      "line" : 649
     },
     {
      "name" : "singleline",
      "kind" : "enum member",
      "line" : 650
     }
    ]
   },
   {
    "name" : "RegexOptionNames",
    "kind" : "alias",
    "protection" : "private",
    "line" : 652
   },
   {
    "name" : "RegexInfo",
    "kind" : "enum",
    "line" : 654,
    "baseDeco" : "k",
    "members" : [
     {
      "name" : "oneShot",
      "kind" : "enum member",
      "line" : 654
     }
    ]
   },
   {
    "name" : "NEL",
    "kind" : "variable",
    "protection" : "private",
    "line" : 656,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "u",
    "init" : "'\\x85'"
   },
   {
    "name" : "LS",
    "kind" : "variable",
    "protection" : "private",
    "line" : 656,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "u",
    "init" : "'\\U00002028'"
   },
   {
    "name" : "PS",
    "kind" : "variable",
    "protection" : "private",
    "line" : 656,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "u",
    "init" : "'\\U00002029'"
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 660,
    "name" : "parseUniHex",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseUniHex",
      "kind" : "function",
      "line" : 660,
      "type" : "dchar(ref Char[] str, size_t maxDigit)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "Char[]",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "maxDigit",
        "type" : "size_t"
       }
      ],
      "endline" : 680
     }
    ]
   },
   {
    "name" : "__unittestL682_1516",
    "kind" : "function",
    "protection" : "private",
    "line" : 682,
    "endline" : 698
   },
   {
    "name" : "maxCharsetUsed",
    "kind" : "variable",
    "protection" : "private",
    "line" : 698,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "i",
    "init" : "6"
   },
   {
    "name" : "maxCachedTries",
    "kind" : "variable",
    "protection" : "private",
    "line" : 700,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "i",
    "init" : "8"
   },
   {
    "name" : "Trie",
    "kind" : "alias",
    "protection" : "private",
    "line" : 702,
    "deco" : "S3std8internal3uni22__T13CodepointTrieVi8Z13CodepointTrie"
   },
   {
    "name" : "trieCache",
    "kind" : "variable",
    "protection" : "private",
    "line" : 704,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "HxS3std8internal3uni12CodepointSetS3std8internal3uni22__T13CodepointTrieVi8Z13CodepointTrie",
    "originalType" : "Trie[const(CodepointSet)]"
   },
   {
    "name" : "getTrie",
    "kind" : "function",
    "protection" : "private",
    "line" : 707,
    "storageClass" : [
     "@trusted"
    ],
    "deco" : "FNexS3std8internal3uni12CodepointSetZS3std8internal3uni22__T13CodepointTrieVi8Z13CodepointTrie",
    "originalType" : "Trie(in CodepointSet set)",
    "parameters" : [
     {
      "name" : "set",
      "deco" : "xS3std8internal3uni12CodepointSet"
     }
    ],
    "endline" : 723
   },
   {
    "name" : "wordCharacter",
    "kind" : "function",
    "protection" : "private",
    "line" : 726,
    "storageClass" : [
     "@property",
     "@safe"
    ],
    "deco" : "FNdNfZS3std8internal3uni12CodepointSet",
    "originalType" : "CodepointSet()",
    "endline" : 730
   },
   {
    "name" : "wordTrie",
    "kind" : "function",
    "protection" : "private",
    "line" : 732,
    "storageClass" : [
     "@property",
     "@safe"
    ],
    "deco" : "FNdNfZS3std8internal3uni22__T13CodepointTrieVi8Z13CodepointTrie",
    "originalType" : "Trie()",
    "endline" : 735
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 737,
    "name" : "memoizeExpr",
    "parameters" : [
     {
      "name" : "expr",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "memoizeExpr",
      "kind" : "function",
      "line" : 737,
      "storageClass" : [
       "auto"
      ],
      "type" : "()",
      "endline" : 750
     }
    ]
   },
   {
    "name" : "getUnicodeSet",
    "kind" : "function",
    "protection" : "private",
    "line" : 755,
    "storageClass" : [
     "@trusted"
    ],
    "deco" : "FNexAabbZxS3std8internal3uni12CodepointSet",
    "originalType" : "const(CodepointSet)(in char[] name, bool negated, bool casefold)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "negated",
      "deco" : "b"
     },
     {
      "name" : "casefold",
      "deco" : "b"
     }
    ],
    "endline" : 812
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 816,
    "name" : "Stack",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "CTFE",
      "kind" : "value",
      "deco" : "b",
      "defaultValue" : "false"
     }
    ],
    "members" : [
     {
      "name" : "Stack",
      "kind" : "struct",
      "line" : 816,
      "members" : [
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 832,
        "type" : "bool()",
        "endline" : 832
       },
       {
        "name" : "push",
        "kind" : "function",
        "line" : 833,
        "type" : "void(T item)",
        "parameters" : [
         {
          "name" : "item",
          "type" : "T"
         }
        ],
        "endline" : 836
       },
       {
        "name" : "top",
        "kind" : "function",
        "line" : 837,
        "type" : "T()",
        "endline" : 841
       },
       {
        "name" : "length",
        "kind" : "function",
        "line" : 842,
        "type" : "size_t()",
        "endline" : 842
       },
       {
        "name" : "pop",
        "kind" : "function",
        "line" : 843,
        "type" : "T()",
        "endline" : 849
       }
      ]
     }
    ]
   },
   {
    "name" : "maxGroupNumber",
    "kind" : "variable",
    "protection" : "private",
    "line" : 853,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "i",
    "init" : "524288"
   },
   {
    "name" : "maxLookaroundDepth",
    "kind" : "variable",
    "protection" : "private",
    "line" : 854,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "i",
    "init" : "16"
   },
   {
    "name" : "maxCompiledLength",
    "kind" : "variable",
    "protection" : "private",
    "line" : 856,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "i",
    "init" : "262144"
   },
   {
    "name" : "maxCumulativeRepetitionLength",
    "kind" : "variable",
    "protection" : "private",
    "line" : 858,
    "storageClass" : [
     "enum",
     "@safe"
    ],
    "deco" : "i",
    "init" : "1048576"
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 860,
    "name" : "BasicElementOf",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "BasicElementOf",
      "kind" : "alias",
      "line" : 862,
      "type" : "Unqual!(ElementEncodingType!(Range))"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 867,
    "name" : "Parser",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "CTFE",
      "kind" : "value",
      "deco" : "b",
      "defaultValue" : "false"
     }
    ],
    "members" : [
     {
      "name" : "Parser",
      "kind" : "struct",
      "line" : 867,
      "members" : [
       {
        "name" : "infinite",
        "kind" : "variable",
        "line" : 868,
        "storageClass" : [
         "enum"
        ],
        "init" : "~0u"
       },
       {
        "name" : "_current",
        "kind" : "variable",
        "line" : 869,
        "deco" : "w"
       },
       {
        "name" : "empty",
        "kind" : "variable",
        "line" : 870,
        "deco" : "b"
       },
       {
        "name" : "pat",
        "kind" : "variable",
        "line" : 871,
        "type" : "R"
       },
       {
        "name" : "origin",
        "kind" : "variable",
        "line" : 871,
        "type" : "R"
       },
       {
        "name" : "ir",
        "kind" : "variable",
        "line" : 872,
        "type" : "Bytecode[]"
       },
       {
        "name" : "re_flags",
        "kind" : "variable",
        "line" : 873,
        "deco" : "k",
        "init" : "0"
       },
       {
        "name" : "fixupStack",
        "kind" : "variable",
        "line" : 874,
        "type" : "Stack!(uint, CTFE)"
       },
       {
        "name" : "dict",
        "kind" : "variable",
        "line" : 875,
        "type" : "NamedGroup[]"
       },
       {
        "name" : "groupStack",
        "kind" : "variable",
        "line" : 877,
        "type" : "Stack!(uint, CTFE)"
       },
       {
        "name" : "nesting",
        "kind" : "variable",
        "line" : 878,
        "deco" : "k",
        "init" : "0"
       },
       {
        "name" : "lookaroundNest",
        "kind" : "variable",
        "line" : 879,
        "deco" : "k",
        "init" : "0"
       },
       {
        "name" : "counterDepth",
        "kind" : "variable",
        "line" : 880,
        "deco" : "k",
        "init" : "0"
       },
       {
        "name" : "charsets",
        "kind" : "variable",
        "line" : 881,
        "type" : "const(CodepointSet)[]"
       },
       {
        "name" : "tries",
        "kind" : "variable",
        "line" : 882,
        "type" : "const(Trie)[]"
       },
       {
        "name" : "backrefed",
        "kind" : "variable",
        "line" : 883,
        "type" : "uint[]"
       },
       {
        "kind" : "template",
        "line" : 885,
        "name" : "this",
        "parameters" : [
         {
          "name" : "S",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 885,
          "type" : "(R pattern, S flags)",
          "parameters" : [
           {
            "name" : "pattern",
            "type" : "R"
           },
           {
            "name" : "flags",
            "type" : "S"
           }
          ],
          "endline" : 904
         }
        ]
       },
       {
        "name" : "markBackref",
        "kind" : "function",
        "line" : 907,
        "type" : "void(uint n)",
        "parameters" : [
         {
          "name" : "n",
          "deco" : "k"
         }
        ],
        "endline" : 912
       },
       {
        "name" : "current",
        "kind" : "function",
        "line" : 914,
        "type" : "dchar()",
        "endline" : 914
       },
       {
        "name" : "_next",
        "kind" : "function",
        "line" : 916,
        "type" : "bool()",
        "endline" : 926
       },
       {
        "name" : "skipSpace",
        "kind" : "function",
        "line" : 928,
        "type" : "void()",
        "endline" : 931
       },
       {
        "name" : "next",
        "kind" : "function",
        "line" : 933,
        "type" : "bool()",
        "endline" : 943
       },
       {
        "name" : "put",
        "kind" : "function",
        "line" : 945,
        "type" : "void(Bytecode code)",
        "parameters" : [
         {
          "name" : "code",
          "type" : "Bytecode"
         }
        ],
        "endline" : 955
       },
       {
        "name" : "putRaw",
        "kind" : "function",
        "line" : 957,
        "type" : "void(uint number)",
        "parameters" : [
         {
          "name" : "number",
          "deco" : "k"
         }
        ],
        "endline" : 962
       },
       {
        "name" : "parseDecimal",
        "kind" : "function",
        "line" : 965,
        "type" : "uint()",
        "endline" : 977
       },
       {
        "name" : "parseControlCode",
        "kind" : "function",
        "line" : 980,
        "type" : "dchar()",
        "endline" : 986
       },
       {
        "kind" : "template",
        "line" : 989,
        "name" : "parseFlags",
        "parameters" : [
         {
          "name" : "S",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "parseFlags",
          "kind" : "function",
          "line" : 989,
          "type" : "void(S flags)",
          "parameters" : [
           {
            "name" : "flags",
            "type" : "S"
           }
          ],
          "endline" : 1012
         }
        ]
       },
       {
        "name" : "parseRegex",
        "kind" : "function",
        "line" : 1015,
        "type" : "void()",
        "endline" : 1179
       },
       {
        "name" : "finishAlternation",
        "kind" : "function",
        "line" : 1182,
        "type" : "void(uint fix)",
        "parameters" : [
         {
          "name" : "fix",
          "deco" : "k"
         }
        ],
        "endline" : 1200
       },
       {
        "name" : "parseQuantifier",
        "kind" : "function",
        "line" : 1203,
        "type" : "void(uint offset)",
        "parameters" : [
         {
          "name" : "offset",
          "deco" : "k"
         }
        ],
        "endline" : 1319
       },
       {
        "name" : "parseAtom",
        "kind" : "function",
        "line" : 1322,
        "type" : "void()",
        "endline" : 1366
       },
       {
        "name" : "genLookaround",
        "kind" : "function",
        "line" : 1369,
        "type" : "void(IR opcode)",
        "parameters" : [
         {
          "name" : "opcode",
          "type" : "IR"
         }
        ],
        "endline" : 1378
       },
       {
        "name" : "fixLookaround",
        "kind" : "function",
        "line" : 1381,
        "type" : "void(uint fix)",
        "parameters" : [
         {
          "name" : "fix",
          "deco" : "k"
         }
        ],
        "endline" : 1391
       },
       {
        "name" : "Operator",
        "kind" : "enum",
        "line" : 1394,
        "baseDeco" : "k",
        "members" : [
         {
          "name" : "Open",
          "kind" : "enum member",
          "line" : 1395
         },
         {
          "name" : "Negate",
          "kind" : "enum member",
          "line" : 1395
         },
         {
          "name" : "Difference",
          "kind" : "enum member",
          "line" : 1395
         },
         {
          "name" : "SymDifference",
          "kind" : "enum member",
          "line" : 1395
         },
         {
          "name" : "Intersection",
          "kind" : "enum member",
          "line" : 1395
         },
         {
          "name" : "Union",
          "kind" : "enum member",
          "line" : 1395
         },
         {
          "name" : "None",
          "kind" : "enum member",
          "line" : 1395
         }
        ]
       },
       {
        "name" : "parseCharTerm",
        "kind" : "function",
        "line" : 1400,
        "type" : "Tuple!(CodepointSet, Operator)()",
        "endline" : 1669
       },
       {
        "name" : "ValStack",
        "kind" : "alias",
        "line" : 1671,
        "type" : "Stack!(CodepointSet, CTFE)"
       },
       {
        "name" : "OpStack",
        "kind" : "alias",
        "line" : 1672,
        "type" : "Stack!(Operator, CTFE)"
       },
       {
        "name" : "parseCharset",
        "kind" : "function",
        "line" : 1675,
        "type" : "void()",
        "endline" : 1779
       },
       {
        "name" : "charsetToIr",
        "kind" : "function",
        "line" : 1781,
        "type" : "void(in CodepointSet set)",
        "parameters" : [
         {
          "name" : "set",
          "type" : "CodepointSet",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 1816
       },
       {
        "name" : "parseEscape",
        "kind" : "function",
        "line" : 1819,
        "type" : "void()",
        "endline" : 1909
       },
       {
        "name" : "parseUnicodePropertySpec",
        "kind" : "function",
        "line" : 1913,
        "type" : "const(CodepointSet)(bool negated)",
        "parameters" : [
         {
          "name" : "negated",
          "deco" : "b"
         }
        ],
        "endline" : 1938
       },
       {
        "name" : "error",
        "kind" : "function",
        "line" : 1941,
        "type" : "void(string msg)",
        "parameters" : [
         {
          "name" : "msg",
          "type" : "string"
         }
        ],
        "endline" : 1948
       },
       {
        "name" : "Char",
        "kind" : "alias",
        "line" : 1950,
        "type" : "BasicElementOf!(R)"
       },
       {
        "name" : "program",
        "kind" : "function",
        "line" : 1952,
        "type" : "Regex!(Char)()",
        "endline" : 1955
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D Regex) object holds regular expression pattern in compiled form.\n    Instances of this object are constructed via calls to $(D regex).\n    This is an intended form for caching and storage of frequently\n    used regular expressions.\n",
    "line" : 1966,
    "name" : "Regex",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Regex",
      "kind" : "struct",
      "line" : 1966,
      "members" : [
       {
        "name" : "charsets",
        "kind" : "variable",
        "line" : 1968,
        "type" : "const(CodepointSet)[]"
       },
       {
        "name" : "ir",
        "kind" : "variable",
        "line" : 1969,
        "type" : "Bytecode[]"
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "\n        Test if this object doesn't contain any compiled pattern.\n        Example:\n        ---\n        Regex!char r;\n        assert(r.empty);\n        r = regex(\"\"); // Note: \"\" is a valid regex pattern.\n        assert(!r.empty);\n        ---\n    \n",
        "line" : 1981,
        "type" : "const nothrow bool()",
        "endline" : 1981
       },
       {
        "name" : "dict",
        "kind" : "variable",
        "line" : 1984,
        "type" : "NamedGroup[]"
       },
       {
        "name" : "ngroup",
        "kind" : "variable",
        "line" : 1985,
        "deco" : "k"
       },
       {
        "name" : "maxCounterDepth",
        "kind" : "variable",
        "line" : 1986,
        "deco" : "k"
       },
       {
        "name" : "hotspotTableSize",
        "kind" : "variable",
        "line" : 1987,
        "deco" : "k"
       },
       {
        "name" : "threadCount",
        "kind" : "variable",
        "line" : 1988,
        "deco" : "k"
       },
       {
        "name" : "flags",
        "kind" : "variable",
        "line" : 1989,
        "deco" : "k"
       },
       {
        "name" : "tries",
        "kind" : "variable",
        "line" : 1990,
        "type" : "const(Trie)[]"
       },
       {
        "name" : "backrefed",
        "kind" : "variable",
        "line" : 1991,
        "type" : "uint[]"
       },
       {
        "name" : "kickstart",
        "kind" : "variable",
        "line" : 1992,
        "type" : "Kickstart!(Char)"
       },
       {
        "name" : "isBackref",
        "kind" : "function",
        "line" : 1995,
        "type" : "uint(uint n)",
        "parameters" : [
         {
          "name" : "n",
          "deco" : "k"
         }
        ],
        "endline" : 2000
       },
       {
        "name" : "checkIfOneShot",
        "kind" : "function",
        "line" : 2003,
        "type" : "void()",
        "endline" : 2021
       },
       {
        "name" : "lightPostprocess",
        "kind" : "function",
        "line" : 2027,
        "type" : "void()",
        "endline" : 2089
       },
       {
        "name" : "validate",
        "kind" : "function",
        "line" : 2092,
        "type" : "void()",
        "endline" : 2111
       },
       {
        "kind" : "template",
        "line" : 2128,
        "name" : "this",
        "parameters" : [
         {
          "name" : "S",
          "kind" : "type"
         },
         {
          "name" : "x",
          "kind" : "value",
          "deco" : "b"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2128,
          "type" : "(Parser!(S, x) p)",
          "parameters" : [
           {
            "name" : "p",
            "type" : "Parser!(S, x)"
           }
          ],
          "endline" : 2147
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2151,
    "name" : "lookupNamedGroup",
    "parameters" : [
     {
      "name" : "String",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "lookupNamedGroup",
      "kind" : "function",
      "line" : 2151,
      "type" : "uint(NamedGroup[] dict, String name)",
      "parameters" : [
       {
        "name" : "dict",
        "type" : "NamedGroup[]"
       },
       {
        "name" : "name",
        "type" : "String"
       }
      ],
      "endline" : 2156
     }
    ]
   },
   {
    "name" : "endOfLine",
    "kind" : "function",
    "protection" : "private",
    "line" : 2159,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfwbZb",
    "originalType" : "bool(dchar front, bool seenCr)",
    "parameters" : [
     {
      "name" : "front",
      "deco" : "w"
     },
     {
      "name" : "seenCr",
      "deco" : "b"
     }
    ],
    "endline" : 2163
   },
   {
    "name" : "startOfLine",
    "kind" : "function",
    "protection" : "private",
    "line" : 2166,
    "storageClass" : [
     "@safe"
    ],
    "deco" : "FNfwbZb",
    "originalType" : "bool(dchar back, bool seenNl)",
    "parameters" : [
     {
      "name" : "back",
      "deco" : "w"
     },
     {
      "name" : "seenNl",
      "deco" : "b"
     }
    ],
    "endline" : 2170
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2174,
    "name" : "quickTestFwd",
    "parameters" : [
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "quickTestFwd",
      "kind" : "function",
      "line" : 2174,
      "type" : "int(uint pc, dchar front, ref const RegEx re)",
      "parameters" : [
       {
        "name" : "pc",
        "deco" : "k"
       },
       {
        "name" : "front",
        "deco" : "w"
       },
       {
        "name" : "re",
        "type" : "RegEx",
        "storageClass" : [
         "const",
         "ref"
        ]
       }
      ],
      "endline" : 2215
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2223,
    "name" : "SampleGenerator",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "SampleGenerator",
      "kind" : "struct",
      "line" : 2223,
      "members" : [
       {
        "name" : "std.random",
        "kind" : "import",
        "line" : 2224,
        "protection" : "private"
       },
       {
        "name" : "re",
        "kind" : "variable",
        "line" : 2225,
        "type" : "const(Regex!(Char))"
       },
       {
        "name" : "app",
        "kind" : "variable",
        "line" : 2226,
        "type" : "Appender!(char[])"
       },
       {
        "name" : "limit",
        "kind" : "variable",
        "line" : 2227,
        "deco" : "k"
       },
       {
        "name" : "seed",
        "kind" : "variable",
        "line" : 2227,
        "deco" : "k"
       },
       {
        "name" : "gen",
        "kind" : "variable",
        "line" : 2228,
        "type" : "Xorshift"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 2231,
        "type" : "(in Regex!(Char) r, uint threshold, uint randomSeed)",
        "parameters" : [
         {
          "name" : "r",
          "type" : "Regex!(Char)",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "threshold",
          "deco" : "k"
         },
         {
          "name" : "randomSeed",
          "deco" : "k"
         }
        ],
        "endline" : 2238
       },
       {
        "name" : "rand",
        "kind" : "function",
        "line" : 2240,
        "type" : "uint(uint x)",
        "parameters" : [
         {
          "name" : "x",
          "deco" : "k"
         }
        ],
        "endline" : 2245
       },
       {
        "name" : "compose",
        "kind" : "function",
        "line" : 2247,
        "type" : "void()",
        "endline" : 2368
       },
       {
        "name" : "front",
        "kind" : "function",
        "line" : 2370,
        "type" : "Char[]()",
        "endline" : 2373
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 2375,
        "type" : "@property ()",
        "endline" : 2375
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "line" : 2377,
        "type" : "void()",
        "endline" : 2381
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    A $(D StaticRegex) is $(D Regex) object that contains specially\n    generated machine code to speed up matching.\n    Implicitly convertible to normal $(D Regex),\n    however doing so will result in losing this additional capability.\n",
    "line" : 2391,
    "name" : "StaticRegex",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "StaticRegex",
      "kind" : "struct",
      "line" : 2391,
      "members" : [
       {
        "name" : "Matcher",
        "kind" : "alias",
        "line" : 2393,
        "type" : "BacktrackingMatcher!(true)"
       },
       {
        "name" : "MatchFn",
        "kind" : "alias",
        "line" : 2394,
        "type" : "bool function(ref Matcher!(Char))"
       },
       {
        "name" : "nativeFn",
        "kind" : "variable",
        "line" : 2395,
        "type" : "MatchFn"
       },
       {
        "name" : "_regex",
        "kind" : "variable",
        "line" : 2397,
        "type" : "Regex!(Char)"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 2399,
        "type" : "(Regex!(Char) re, MatchFn fn)",
        "parameters" : [
         {
          "name" : "re",
          "type" : "Regex!(Char)"
         },
         {
          "name" : "fn",
          "type" : "MatchFn"
         }
        ],
        "endline" : 2404
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2409,
    "name" : "effectiveSize",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "effectiveSize",
      "kind" : "function",
      "line" : 2409,
      "type" : "uint()",
      "endline" : 2419
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2426,
    "name" : "ShiftOr",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ShiftOr",
      "kind" : "struct",
      "line" : 2426,
      "members" : [
       {
        "name" : "table",
        "kind" : "variable",
        "line" : 2428,
        "type" : "uint[]"
       },
       {
        "name" : "fChar",
        "kind" : "variable",
        "line" : 2429,
        "deco" : "k"
       },
       {
        "name" : "n_length",
        "kind" : "variable",
        "line" : 2430,
        "deco" : "k"
       },
       {
        "name" : "charSize",
        "kind" : "variable",
        "line" : 2431,
        "storageClass" : [
         "enum"
        ],
        "init" : "effectiveSize!(Char)()"
       },
       {
        "name" : "charsetThreshold",
        "kind" : "variable",
        "line" : 2433,
        "storageClass" : [
         "enum"
        ],
        "deco" : "k",
        "init" : "32000"
       },
       {
        "name" : "ShiftThread",
        "kind" : "struct",
        "line" : 2435,
        "members" : [
         {
          "name" : "tab",
          "kind" : "variable",
          "line" : 2436,
          "type" : "uint[]"
         },
         {
          "name" : "mask",
          "kind" : "variable",
          "line" : 2437,
          "deco" : "k"
         },
         {
          "name" : "idx",
          "kind" : "variable",
          "line" : 2438,
          "deco" : "k"
         },
         {
          "name" : "pc",
          "kind" : "variable",
          "line" : 2439,
          "deco" : "k"
         },
         {
          "name" : "counter",
          "kind" : "variable",
          "line" : 2439,
          "deco" : "k"
         },
         {
          "name" : "hops",
          "kind" : "variable",
          "line" : 2439,
          "deco" : "k"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2440,
          "type" : "(uint newPc, uint newCounter, uint[] table)",
          "parameters" : [
           {
            "name" : "newPc",
            "deco" : "k"
           },
           {
            "name" : "newCounter",
            "deco" : "k"
           },
           {
            "name" : "table",
            "type" : "uint[]"
           }
          ],
          "endline" : 2448
         },
         {
          "name" : "setMask",
          "kind" : "function",
          "line" : 2450,
          "type" : "void(uint idx, uint mask)",
          "parameters" : [
           {
            "name" : "idx",
            "deco" : "k"
           },
           {
            "name" : "mask",
            "deco" : "k"
           }
          ],
          "endline" : 2453
         },
         {
          "name" : "setInvMask",
          "kind" : "function",
          "line" : 2455,
          "type" : "void(uint idx, uint mask)",
          "parameters" : [
           {
            "name" : "idx",
            "deco" : "k"
           },
           {
            "name" : "mask",
            "deco" : "k"
           }
          ],
          "endline" : 2458
         },
         {
          "kind" : "template",
          "line" : 2460,
          "name" : "set",
          "parameters" : [
           {
            "name" : "setBits",
            "kind" : "alias",
            "defaultAlias" : "setInvMask"
           }
          ],
          "members" : [
           {
            "name" : "set",
            "kind" : "function",
            "line" : 2460,
            "type" : "void(dchar ch)",
            "parameters" : [
             {
              "name" : "ch",
              "deco" : "w"
             }
            ],
            "endline" : 2492
           }
          ]
         },
         {
          "name" : "add",
          "kind" : "function",
          "line" : 2493,
          "type" : "void(dchar ch)",
          "parameters" : [
           {
            "name" : "ch",
            "deco" : "w"
           }
          ],
          "endline" : 2493
         },
         {
          "name" : "advance",
          "kind" : "function",
          "line" : 2494,
          "type" : "void(uint s)",
          "parameters" : [
           {
            "name" : "s",
            "deco" : "k"
           }
          ],
          "endline" : 2498
         },
         {
          "name" : "full",
          "kind" : "function",
          "line" : 2499,
          "type" : "bool()",
          "endline" : 2499
         }
        ]
       },
       {
        "name" : "fork",
        "kind" : "function",
        "line" : 2502,
        "type" : "ShiftThread(ShiftThread t, uint newPc, uint newCounter)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "ShiftThread"
         },
         {
          "name" : "newPc",
          "deco" : "k"
         },
         {
          "name" : "newCounter",
          "deco" : "k"
         }
        ],
        "endline" : 2508
       },
       {
        "name" : "fetch",
        "kind" : "function",
        "line" : 2510,
        "type" : "ShiftThread(ref ShiftThread[] worklist)",
        "parameters" : [
         {
          "name" : "worklist",
          "type" : "ShiftThread[]",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 2517
       },
       {
        "name" : "charLen",
        "kind" : "function",
        "line" : 2519,
        "type" : "uint(uint ch)",
        "parameters" : [
         {
          "name" : "ch",
          "deco" : "k"
         }
        ],
        "endline" : 2523
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 2526,
        "type" : "(ref const Regex!(Char) re, uint[] memory)",
        "parameters" : [
         {
          "name" : "re",
          "type" : "Regex!(Char)",
          "storageClass" : [
           "const",
           "ref"
          ]
         },
         {
          "name" : "memory",
          "type" : "uint[]"
         }
        ],
        "endline" : 2741
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 2743,
        "type" : "const bool()",
        "endline" : 2743
       },
       {
        "name" : "length",
        "kind" : "function",
        "line" : 2745,
        "type" : "const uint()",
        "endline" : 2745
       },
       {
        "name" : "search",
        "kind" : "function",
        "line" : 2751,
        "type" : "size_t(const(Char)[] haystack, size_t idx)",
        "parameters" : [
         {
          "name" : "haystack",
          "type" : "const(Char)[]"
         },
         {
          "name" : "idx",
          "type" : "size_t"
         }
        ],
        "endline" : 2856
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2868_1521",
    "kind" : "function",
    "protection" : "private",
    "line" : 2868,
    "endline" : 2932
   },
   {
    "name" : "Kickstart",
    "kind" : "alias",
    "protection" : "private",
    "line" : 2932
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2937,
    "name" : "Input",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Input",
      "kind" : "struct",
      "line" : 2937,
      "members" : [
       {
        "name" : "DataIndex",
        "kind" : "alias",
        "line" : 2938,
        "type" : "size_t"
       },
       {
        "name" : "String",
        "kind" : "alias",
        "line" : 2939,
        "type" : "const(Char)[]"
       },
       {
        "name" : "_origin",
        "kind" : "variable",
        "line" : 2940,
        "type" : "String"
       },
       {
        "name" : "_index",
        "kind" : "variable",
        "line" : 2941,
        "type" : "size_t"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 2944,
        "type" : "(String input, size_t idx = 0)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "String"
         },
         {
          "name" : "idx",
          "type" : "size_t",
          "default" : "0"
         }
        ],
        "endline" : 2948
       },
       {
        "name" : "nextChar",
        "kind" : "function",
        "line" : 2951,
        "type" : "bool(ref dchar res, ref size_t pos)",
        "parameters" : [
         {
          "name" : "res",
          "deco" : "w",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "pos",
          "type" : "size_t",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 2958
       },
       {
        "name" : "atEnd",
        "kind" : "function",
        "line" : 2959,
        "type" : "bool()",
        "endline" : 2961
       },
       {
        "kind" : "template",
        "line" : 2962,
        "name" : "search",
        "parameters" : [
         {
          "name" : "Kickstart",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "search",
          "kind" : "function",
          "line" : 2962,
          "type" : "bool(ref Kickstart kick, ref dchar res, ref size_t pos)",
          "parameters" : [
           {
            "name" : "kick",
            "type" : "Kickstart",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "res",
            "deco" : "w",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "pos",
            "type" : "size_t",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 2967
         }
        ]
       },
       {
        "name" : "lastIndex",
        "kind" : "function",
        "line" : 2970,
        "type" : "size_t()",
        "endline" : 2970
       },
       {
        "name" : "reset",
        "kind" : "function",
        "line" : 2973,
        "type" : "void(size_t index)",
        "parameters" : [
         {
          "name" : "index",
          "type" : "size_t"
         }
        ],
        "endline" : 2973
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 2975,
        "type" : "String(size_t start, size_t end)",
        "parameters" : [
         {
          "name" : "start",
          "type" : "size_t"
         },
         {
          "name" : "end",
          "type" : "size_t"
         }
        ],
        "endline" : 2975
       },
       {
        "name" : "BackLooper",
        "kind" : "struct",
        "line" : 2978,
        "members" : [
         {
          "name" : "DataIndex",
          "kind" : "alias",
          "line" : 2979,
          "type" : "size_t"
         },
         {
          "name" : "_origin",
          "kind" : "variable",
          "line" : 2980,
          "type" : "String"
         },
         {
          "name" : "_index",
          "kind" : "variable",
          "line" : 2981,
          "type" : "size_t"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2982,
          "type" : "(Input input)",
          "parameters" : [
           {
            "name" : "input",
            "type" : "Input"
           }
          ],
          "endline" : 2986
         },
         {
          "name" : "nextChar",
          "kind" : "function",
          "line" : 2987,
          "type" : "bool(ref dchar res, ref size_t pos)",
          "parameters" : [
           {
            "name" : "res",
            "deco" : "w",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "pos",
            "type" : "size_t",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 2997
         },
         {
          "name" : "atEnd",
          "kind" : "function",
          "line" : 2998,
          "type" : "@property ()",
          "endline" : 2998
         },
         {
          "name" : "loopBack",
          "kind" : "function",
          "line" : 2999,
          "storageClass" : [
           "auto"
          ],
          "type" : "@property ()",
          "endline" : 2999
         },
         {
          "name" : "reset",
          "kind" : "function",
          "line" : 3002,
          "type" : "void(size_t index)",
          "parameters" : [
           {
            "name" : "index",
            "type" : "size_t"
           }
          ],
          "endline" : 3002
         },
         {
          "name" : "opSlice",
          "kind" : "function",
          "line" : 3004,
          "type" : "String(size_t start, size_t end)",
          "parameters" : [
           {
            "name" : "start",
            "type" : "size_t"
           },
           {
            "name" : "end",
            "type" : "size_t"
           }
          ],
          "endline" : 3004
         },
         {
          "name" : "lastIndex",
          "kind" : "function",
          "line" : 3006,
          "type" : "size_t()",
          "endline" : 3006
         }
        ]
       },
       {
        "name" : "loopBack",
        "kind" : "function",
        "line" : 3008,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 3008
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3014,
    "name" : "StreamTester",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "StreamTester",
      "kind" : "struct",
      "line" : 3014,
      "members" : [
       {
        "name" : "DataIndex",
        "kind" : "alias",
        "line" : 3015,
        "deco" : "m"
       },
       {
        "name" : "String",
        "kind" : "alias",
        "line" : 3016,
        "type" : "const(Char)[]"
       },
       {
        "name" : "refStream",
        "kind" : "variable",
        "line" : 3017,
        "type" : "Input!(Char)"
       },
       {
        "name" : "allStr",
        "kind" : "variable",
        "line" : 3018,
        "type" : "String"
       },
       {
        "name" : "stream",
        "kind" : "variable",
        "line" : 3019,
        "type" : "StreamCBuf!(Char)"
       },
       {
        "name" : "splits",
        "kind" : "variable",
        "line" : 3020,
        "type" : "size_t[]"
       },
       {
        "name" : "pos",
        "kind" : "variable",
        "line" : 3021,
        "type" : "size_t"
       },
       {
        "name" : "addNextChunk",
        "kind" : "function",
        "line" : 3024,
        "type" : "bool()",
        "endline" : 3043
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3046,
        "type" : "(String input, size_t[] splits)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "String"
         },
         {
          "name" : "splits",
          "type" : "size_t[]"
         }
        ],
        "endline" : 3059
       },
       {
        "name" : "nextChar",
        "kind" : "function",
        "line" : 3062,
        "type" : "bool(ref dchar res, ref size_t pos)",
        "parameters" : [
         {
          "name" : "res",
          "deco" : "w",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "pos",
          "type" : "size_t",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 3083
       },
       {
        "name" : "atEnd",
        "kind" : "function",
        "line" : 3085,
        "type" : "bool()",
        "endline" : 3089
       },
       {
        "kind" : "template",
        "line" : 3091,
        "name" : "search",
        "parameters" : [
         {
          "name" : "Kickstart",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "search",
          "kind" : "function",
          "line" : 3091,
          "type" : "bool(ref Kickstart kick, ref dchar res, ref ulong pos)",
          "parameters" : [
           {
            "name" : "kick",
            "type" : "Kickstart",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "res",
            "deco" : "w",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "pos",
            "deco" : "m",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 3108
         }
        ]
       },
       {
        "name" : "lastIndex",
        "kind" : "function",
        "line" : 3111,
        "type" : "size_t()",
        "endline" : 3111
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 3113,
        "type" : "String(size_t start, size_t end)",
        "parameters" : [
         {
          "name" : "start",
          "type" : "size_t"
         },
         {
          "name" : "end",
          "type" : "size_t"
         }
        ],
        "endline" : 3116
       },
       {
        "name" : "BackLooper",
        "kind" : "struct",
        "line" : 3119,
        "members" : [
         {
          "name" : "DataIndex",
          "kind" : "alias",
          "line" : 3120,
          "deco" : "m"
         },
         {
          "name" : "refBacklooper",
          "kind" : "variable",
          "line" : 3121,
          "type" : "Input!(Char).BackLooper"
         },
         {
          "name" : "backlooper",
          "kind" : "variable",
          "line" : 3122,
          "type" : "StreamCBuf!(Char).BackLooper"
         },
         {
          "name" : "startPos",
          "kind" : "variable",
          "line" : 3123,
          "deco" : "m"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 3125,
          "type" : "(Input!(Char).BackLooper refBacklooper, StreamCBuf!(Char).BackLooper backlooper)",
          "parameters" : [
           {
            "name" : "refBacklooper",
            "type" : "Input!(Char).BackLooper"
           },
           {
            "name" : "backlooper",
            "type" : "StreamCBuf!(Char).BackLooper"
           }
          ],
          "endline" : 3129
         },
         {
          "name" : "nextChar",
          "kind" : "function",
          "line" : 3130,
          "type" : "bool(ref dchar res, ref ulong pos)",
          "parameters" : [
           {
            "name" : "res",
            "deco" : "w",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "pos",
            "deco" : "m",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 3147
         },
         {
          "name" : "atEnd",
          "kind" : "function",
          "line" : 3148,
          "type" : "@property ()",
          "endline" : 3164
         },
         {
          "name" : "loopBack",
          "kind" : "function",
          "line" : 3165,
          "storageClass" : [
           "auto"
          ],
          "type" : "@property ()",
          "endline" : 3165
         },
         {
          "name" : "reset",
          "kind" : "function",
          "line" : 3168,
          "type" : "void(size_t index)",
          "parameters" : [
           {
            "name" : "index",
            "type" : "size_t"
           }
          ],
          "endline" : 3168
         },
         {
          "name" : "opSlice",
          "kind" : "function",
          "line" : 3170,
          "type" : "String(size_t start, size_t end)",
          "parameters" : [
           {
            "name" : "start",
            "type" : "size_t"
           },
           {
            "name" : "end",
            "type" : "size_t"
           }
          ],
          "endline" : 3170
         },
         {
          "name" : "lastIndex",
          "kind" : "function",
          "line" : 3172,
          "type" : "size_t()",
          "endline" : 3172
         }
        ]
       },
       {
        "name" : "loopBack",
        "kind" : "function",
        "line" : 3174,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 3174
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3180,
    "name" : "mallocArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "mallocArray",
      "kind" : "function",
      "line" : 3180,
      "type" : "T[](size_t len)",
      "parameters" : [
       {
        "name" : "len",
        "type" : "size_t"
       }
      ],
      "endline" : 3183
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3186,
    "name" : "arrayInChunk",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "arrayInChunk",
      "kind" : "function",
      "line" : 3186,
      "type" : "T[](size_t len, ref void[] chunk)",
      "parameters" : [
       {
        "name" : "len",
        "type" : "size_t"
       },
       {
        "name" : "chunk",
        "type" : "void[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 3191
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3197,
    "name" : "BacktrackingMatcher",
    "parameters" : [
     {
      "name" : "CTregex",
      "kind" : "value",
      "deco" : "b"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 3201,
      "name" : "BacktrackingMatcher",
      "parameters" : [
       {
        "name" : "Char",
        "kind" : "type"
       },
       {
        "name" : "Stream",
        "kind" : "type",
        "default" : "Input!(Char)"
       }
      ],
      "members" : [
       {
        "name" : "BacktrackingMatcher",
        "kind" : "struct",
        "line" : 3201,
        "members" : [
         {
          "name" : "DataIndex",
          "kind" : "alias",
          "line" : 3202,
          "type" : "Stream.DataIndex"
         },
         {
          "name" : "State",
          "kind" : "struct",
          "line" : 3204,
          "members" : [
           {
            "name" : "index",
            "kind" : "variable",
            "line" : 3205,
            "type" : "DataIndex"
           },
           {
            "name" : "pc",
            "kind" : "variable",
            "line" : 3206,
            "deco" : "k"
           },
           {
            "name" : "counter",
            "kind" : "variable",
            "line" : 3206,
            "deco" : "k"
           },
           {
            "name" : "infiniteNesting",
            "kind" : "variable",
            "line" : 3206,
            "deco" : "k"
           }
          ]
         },
         {
          "name" : "stateSize",
          "kind" : "variable",
          "line" : 3209,
          "storageClass" : [
           "enum"
          ],
          "init" : "State.sizeof / size_t.sizeof"
         },
         {
          "name" : "initialStack",
          "kind" : "variable",
          "line" : 3210,
          "storageClass" : [
           "enum"
          ],
          "init" : "1 << 16"
         },
         {
          "name" : "String",
          "kind" : "alias",
          "line" : 3211,
          "type" : "const(Char)[]"
         },
         {
          "name" : "re",
          "kind" : "variable",
          "line" : 3216,
          "type" : "RegEx"
         },
         {
          "name" : "s",
          "kind" : "variable",
          "line" : 3218,
          "type" : "Stream"
         },
         {
          "name" : "index",
          "kind" : "variable",
          "line" : 3219,
          "type" : "DataIndex"
         },
         {
          "name" : "front",
          "kind" : "variable",
          "line" : 3220,
          "deco" : "w"
         },
         {
          "name" : "exhausted",
          "kind" : "variable",
          "line" : 3221,
          "deco" : "b"
         },
         {
          "name" : "pc",
          "kind" : "variable",
          "line" : 3223,
          "deco" : "k"
         },
         {
          "name" : "counter",
          "kind" : "variable",
          "line" : 3223,
          "deco" : "k"
         },
         {
          "name" : "lastState",
          "kind" : "variable",
          "line" : 3224,
          "type" : "DataIndex",
          "init" : "0"
         },
         {
          "name" : "trackers",
          "kind" : "variable",
          "line" : 3225,
          "type" : "DataIndex[]"
         },
         {
          "name" : "memory",
          "kind" : "variable",
          "line" : 3228,
          "type" : "size_t[]"
         },
         {
          "name" : "matches",
          "kind" : "variable",
          "line" : 3230,
          "type" : "Group!(DataIndex)[]"
         },
         {
          "name" : "backrefed",
          "kind" : "variable",
          "line" : 3230,
          "type" : "Group!(DataIndex)[]"
         },
         {
          "name" : "initialMemory",
          "kind" : "function",
          "line" : 3239,
          "type" : "size_t(ref const RegEx re)",
          "parameters" : [
           {
            "name" : "re",
            "type" : "RegEx",
            "storageClass" : [
             "const",
             "ref"
            ]
           }
          ],
          "endline" : 3243
         },
         {
          "name" : "stackSize",
          "kind" : "function",
          "line" : 3245,
          "type" : "size_t(ref const RegEx re)",
          "parameters" : [
           {
            "name" : "re",
            "type" : "RegEx",
            "storageClass" : [
             "const",
             "ref"
            ]
           }
          ],
          "endline" : 3248
         },
         {
          "name" : "atStart",
          "kind" : "function",
          "line" : 3250,
          "type" : "bool()",
          "endline" : 3250
         },
         {
          "name" : "atEnd",
          "kind" : "function",
          "line" : 3252,
          "type" : "bool()",
          "endline" : 3252
         },
         {
          "name" : "next",
          "kind" : "function",
          "line" : 3254,
          "type" : "void()",
          "endline" : 3258
         },
         {
          "name" : "search",
          "kind" : "function",
          "line" : 3260,
          "type" : "void()",
          "endline" : 3271
         },
         {
          "name" : "newStack",
          "kind" : "function",
          "line" : 3274,
          "type" : "void()",
          "endline" : 3279
         },
         {
          "name" : "initExternalMemory",
          "kind" : "function",
          "line" : 3281,
          "type" : "void(void[] memBlock)",
          "parameters" : [
           {
            "name" : "memBlock",
            "type" : "void[]"
           }
          ],
          "endline" : 3287
         },
         {
          "name" : "initialize",
          "kind" : "function",
          "line" : 3289,
          "type" : "void(ref RegEx program, Stream stream, void[] memBlock)",
          "parameters" : [
           {
            "name" : "program",
            "type" : "RegEx",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "stream",
            "type" : "Stream"
           },
           {
            "name" : "memBlock",
            "type" : "void[]"
           }
          ],
          "endline" : 3296
         },
         {
          "name" : "dupTo",
          "kind" : "function",
          "line" : 3299,
          "storageClass" : [
           "auto"
          ],
          "type" : "(void[] memory)",
          "parameters" : [
           {
            "name" : "memory",
            "type" : "void[]"
           }
          ],
          "endline" : 3303
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 3306,
          "type" : "(ref RegEx program, Stream stream, void[] memBlock)",
          "parameters" : [
           {
            "name" : "program",
            "type" : "RegEx",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "stream",
            "type" : "Stream"
           },
           {
            "name" : "memBlock",
            "type" : "void[]"
           }
          ],
          "endline" : 3310
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 3313,
          "type" : "(ref RegEx program, Stream stream, void[] memBlock, dchar ch, DataIndex idx)",
          "parameters" : [
           {
            "name" : "program",
            "type" : "RegEx",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "stream",
            "type" : "Stream"
           },
           {
            "name" : "memBlock",
            "type" : "void[]"
           },
           {
            "name" : "ch",
            "deco" : "w"
           },
           {
            "name" : "idx",
            "type" : "DataIndex"
           }
          ],
          "endline" : 3318
         },
         {
          "name" : "matchFinalize",
          "kind" : "function",
          "line" : 3321,
          "type" : "bool()",
          "endline" : 3336
         },
         {
          "name" : "match",
          "kind" : "function",
          "line" : 3339,
          "type" : "bool(Group!(DataIndex)[] matches)",
          "parameters" : [
           {
            "name" : "matches",
            "type" : "Group!(DataIndex)[]"
           }
          ],
          "endline" : 3384
         },
         {
          "name" : "matchImpl",
          "kind" : "function",
          "line" : 3390,
          "type" : "bool()",
          "endline" : 3729
         },
         {
          "name" : "stackAvail",
          "kind" : "function",
          "line" : 3731,
          "type" : "size_t()",
          "endline" : 3734
         },
         {
          "name" : "prevStack",
          "kind" : "function",
          "line" : 3736,
          "type" : "bool()",
          "endline" : 3747
         },
         {
          "kind" : "template",
          "line" : 3749,
          "name" : "stackPush",
          "parameters" : [
           {
            "name" : "T",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "stackPush",
            "kind" : "function",
            "line" : 3749,
            "type" : "void(T val)",
            "parameters" : [
             {
              "name" : "val",
              "type" : "T"
             }
            ],
            "endline" : 3756
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 3758,
          "name" : "stackPush",
          "parameters" : [
           {
            "name" : "T",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "stackPush",
            "kind" : "function",
            "line" : 3758,
            "type" : "void(T[] val)",
            "parameters" : [
             {
              "name" : "val",
              "type" : "T[]"
             }
            ],
            "endline" : 3765
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 3767,
          "name" : "stackPop",
          "parameters" : [
           {
            "name" : "T",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "stackPop",
            "kind" : "function",
            "line" : 3767,
            "type" : "void(ref T val)",
            "parameters" : [
             {
              "name" : "val",
              "type" : "T",
              "storageClass" : [
               "ref"
              ]
             }
            ],
            "endline" : 3774
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 3776,
          "name" : "stackPop",
          "parameters" : [
           {
            "name" : "T",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "stackPop",
            "kind" : "function",
            "line" : 3776,
            "type" : "void(T[] val)",
            "parameters" : [
             {
              "name" : "val",
              "type" : "T[]"
             }
            ],
            "endline" : 3779
           }
          ]
         },
         {
          "kind" : "template",
          "line" : 3780,
          "name" : "stackPop",
          "parameters" : [
           {
            "name" : "T",
            "kind" : "type"
           }
          ],
          "members" : [
           {
            "name" : "stackPop",
            "kind" : "function",
            "line" : 3780,
            "type" : "void(ref T[] val)",
            "parameters" : [
             {
              "name" : "val",
              "type" : "T[]",
              "storageClass" : [
               "ref"
              ]
             }
            ],
            "endline" : 3785
           }
          ]
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4193,
    "name" : "ctSub",
    "parameters" : [
     {
      "name" : "U",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "ctSub",
      "kind" : "function",
      "line" : 4193,
      "type" : "string(string format, U args)",
      "parameters" : [
       {
        "name" : "format",
        "type" : "string"
       },
       {
        "name" : "args",
        "type" : "U"
       }
      ],
      "endline" : 4218
     }
    ]
   },
   {
    "name" : "ctGenSeq",
    "kind" : "function",
    "protection" : "private",
    "line" : 4221,
    "storageClass" : [
     "@system"
    ],
    "deco" : "FiiZAya",
    "originalType" : "string(int S, int E)",
    "parameters" : [
     {
      "name" : "S",
      "deco" : "i"
     },
     {
      "name" : "E",
      "deco" : "i"
     }
    ],
    "endline" : 4232
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4235,
    "name" : "Sequence",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "value",
      "deco" : "i"
     },
     {
      "name" : "E",
      "kind" : "value",
      "deco" : "i"
     }
    ],
    "members" : []
   },
   {
    "name" : "CtContext",
    "kind" : "struct",
    "protection" : "private",
    "line" : 4241,
    "members" : [
     {
      "name" : "counter",
      "kind" : "variable",
      "line" : 4243,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "b",
      "offset" : 0
     },
     {
      "name" : "infNesting",
      "kind" : "variable",
      "line" : 4243,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "b",
      "offset" : 1
     },
     {
      "name" : "nInfLoops",
      "kind" : "variable",
      "line" : 4244,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "i",
      "offset" : 4
     },
     {
      "name" : "match",
      "kind" : "variable",
      "line" : 4245,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "i",
      "offset" : 8
     },
     {
      "name" : "total_matches",
      "kind" : "variable",
      "line" : 4245,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "i",
      "offset" : 12
     },
     {
      "name" : "CtState",
      "kind" : "struct",
      "line" : 4250,
      "members" : [
       {
        "name" : "code",
        "kind" : "variable",
        "line" : 4251,
        "storageClass" : [
         "@safe"
        ],
        "deco" : "Aya",
        "offset" : 0
       },
       {
        "name" : "addr",
        "kind" : "variable",
        "line" : 4252,
        "storageClass" : [
         "@safe"
        ],
        "deco" : "i",
        "offset" : 16
       },
       {
        "name" : "__xopEquals",
        "kind" : "function",
        "storageClass" : [
         "static"
        ],
        "deco" : "FKxS3std5regex9CtContext7CtStateKxS3std5regex9CtContext7CtStateZb",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "xS3std5regex9CtContext7CtState",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "q",
          "deco" : "xS3std5regex9CtContext7CtState",
          "storageClass" : [
           "ref"
          ]
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4255,
      "name" : "this",
      "parameters" : [
       {
        "name" : "Char",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 4255,
        "type" : "(Regex!(Char) re)",
        "parameters" : [
         {
          "name" : "re",
          "type" : "Regex!(Char)"
         }
        ],
        "endline" : 4259
       }
      ]
     },
     {
      "name" : "restoreCode",
      "kind" : "function",
      "line" : 4262,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfZAya",
      "originalType" : "string()",
      "endline" : 4282
     },
     {
      "name" : "saveCode",
      "kind" : "function",
      "line" : 4285,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfkAyaZAya",
      "originalType" : "string(uint pc, string count_expr = \"counter\")",
      "parameters" : [
       {
        "name" : "pc",
        "deco" : "k"
       },
       {
        "name" : "count_expr",
        "deco" : "Aya",
        "default" : "\"counter\""
       }
      ],
      "endline" : 4304
     },
     {
      "name" : "ctGenBlock",
      "kind" : "function",
      "line" : 4307,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfAS3std5regex8BytecodeiZS3std5regex9CtContext7CtState",
      "originalType" : "CtState(Bytecode[] ir, int addr)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode"
       },
       {
        "name" : "addr",
        "deco" : "i"
       }
      ],
      "endline" : 4318
     },
     {
      "name" : "ctGenGroup",
      "kind" : "function",
      "line" : 4321,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfKAS3std5regex8BytecodeiZS3std5regex9CtContext7CtState",
      "originalType" : "CtState(ref Bytecode[] ir, int addr)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "addr",
        "deco" : "i"
       }
      ],
      "endline" : 4359
     },
     {
      "name" : "ctGenAlternation",
      "kind" : "function",
      "line" : 4362,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfAS3std5regex8BytecodeiZS3std5regex9CtContext7CtState",
      "originalType" : "CtState(Bytecode[] ir, int addr)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode"
       },
       {
        "name" : "addr",
        "deco" : "i"
       }
      ],
      "endline" : 4399
     },
     {
      "name" : "ctGenFixupCode",
      "kind" : "function",
      "line" : 4403,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfAS3std5regex8BytecodeiiZAya",
      "originalType" : "string(Bytecode[] ir, int addr, int fixup)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode"
       },
       {
        "name" : "addr",
        "deco" : "i"
       },
       {
        "name" : "fixup",
        "deco" : "i"
       }
      ],
      "endline" : 4406
     },
     {
      "name" : "ctGenFixupCode",
      "kind" : "function",
      "line" : 4407,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfKAS3std5regex8BytecodeiiZAya",
      "originalType" : "string(ref Bytecode[] ir, int addr, int fixup)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "addr",
        "deco" : "i"
       },
       {
        "name" : "fixup",
        "deco" : "i"
       }
      ],
      "endline" : 4534
     },
     {
      "name" : "ctQuickTest",
      "kind" : "function",
      "line" : 4537,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfAS3std5regex8BytecodeiZAya",
      "originalType" : "string(Bytecode[] ir, int id)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode"
       },
       {
        "name" : "id",
        "deco" : "i"
       }
      ],
      "endline" : 4559
     },
     {
      "name" : "ctGenAtom",
      "kind" : "function",
      "line" : 4562,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfKAS3std5regex8BytecodeiZS3std5regex9CtContext7CtState",
      "originalType" : "CtState(ref Bytecode[] ir, int addr)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "addr",
        "deco" : "i"
       }
      ],
      "endline" : 4569
     },
     {
      "name" : "ctAtomCode",
      "kind" : "function",
      "line" : 4572,
      "storageClass" : [
       "@safe"
      ],
      "deco" : "FNfAS3std5regex8BytecodeiZAya",
      "originalType" : "string(Bytecode[] ir, int addr)",
      "parameters" : [
       {
        "name" : "ir",
        "deco" : "AS3std5regex8Bytecode"
       },
       {
        "name" : "addr",
        "deco" : "i"
       }
      ],
      "endline" : 4746
     },
     {
      "kind" : "template",
      "line" : 4749,
      "name" : "ctGenRegEx",
      "parameters" : [
       {
        "name" : "Char",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "ctGenRegEx",
        "kind" : "function",
        "line" : 4749,
        "type" : "string(ref Regex!(Char) re)",
        "parameters" : [
         {
          "name" : "re",
          "type" : "Regex!(Char)",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 4793
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4797,
    "name" : "ctGenRegExCode",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ctGenRegExCode",
      "kind" : "function",
      "line" : 4797,
      "type" : "string(Regex!(Char) re)",
      "parameters" : [
       {
        "name" : "re",
        "type" : "Regex!(Char)"
       }
      ],
      "endline" : 4801
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4805,
    "name" : "Thread",
    "parameters" : [
     {
      "name" : "DataIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Thread",
      "kind" : "struct",
      "line" : 4805,
      "members" : [
       {
        "name" : "next",
        "kind" : "variable",
        "line" : 4806,
        "type" : "Thread*"
       },
       {
        "name" : "pc",
        "kind" : "variable",
        "line" : 4807,
        "deco" : "k"
       },
       {
        "name" : "counter",
        "kind" : "variable",
        "line" : 4808,
        "deco" : "k"
       },
       {
        "name" : "uopCounter",
        "kind" : "variable",
        "line" : 4809,
        "deco" : "k"
       },
       {
        "name" : "matches",
        "kind" : "variable",
        "line" : 4810,
        "type" : "Group!(DataIndex)[1]"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4815,
    "name" : "ThreadList",
    "parameters" : [
     {
      "name" : "DataIndex",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ThreadList",
      "kind" : "struct",
      "line" : 4815,
      "members" : [
       {
        "name" : "tip",
        "kind" : "variable",
        "line" : 4816,
        "type" : "Thread!(DataIndex)*",
        "init" : "null"
       },
       {
        "name" : "toe",
        "kind" : "variable",
        "line" : 4816,
        "type" : "Thread!(DataIndex)*",
        "init" : "null"
       },
       {
        "name" : "insertFront",
        "kind" : "function",
        "line" : 4818,
        "type" : "void(Thread!(DataIndex)* t)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "Thread!(DataIndex)*"
         }
        ],
        "endline" : 4830
       },
       {
        "name" : "insertBack",
        "kind" : "function",
        "line" : 4832,
        "type" : "void(Thread!(DataIndex)* t)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "Thread!(DataIndex)*"
         }
        ],
        "endline" : 4842
       },
       {
        "name" : "fetch",
        "kind" : "function",
        "line" : 4844,
        "type" : "Thread!(DataIndex)*()",
        "endline" : 4852
       },
       {
        "name" : "ThreadRange",
        "kind" : "struct",
        "line" : 4855,
        "members" : [
         {
          "name" : "ct",
          "kind" : "variable",
          "line" : 4856,
          "type" : "const(Thread!(DataIndex))*"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 4857,
          "type" : "(ThreadList tlist)",
          "parameters" : [
           {
            "name" : "tlist",
            "type" : "ThreadList"
           }
          ],
          "endline" : 4857
         },
         {
          "name" : "empty",
          "kind" : "function",
          "line" : 4858,
          "type" : "bool()",
          "endline" : 4858
         },
         {
          "name" : "front",
          "kind" : "function",
          "line" : 4859,
          "type" : "const(Thread!(DataIndex))*()",
          "endline" : 4859
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "line" : 4861,
          "type" : "@property ()",
          "endline" : 4864
         }
        ]
       },
       {
        "name" : "empty",
        "kind" : "function",
        "line" : 4866,
        "type" : "bool()",
        "endline" : 4869
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 4870,
        "type" : "ThreadRange()",
        "endline" : 4873
       }
      ]
     }
    ]
   },
   {
    "name" : "OneShot",
    "kind" : "enum",
    "line" : 4877,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "Fwd",
      "kind" : "enum member",
      "line" : 4877
     },
     {
      "name" : "Bwd",
      "kind" : "enum member",
      "line" : 4877
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 4885,
    "name" : "ThompsonMatcher",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     },
     {
      "name" : "Stream",
      "kind" : "type",
      "default" : "Input!(Char)"
     }
    ],
    "members" : [
     {
      "name" : "ThompsonMatcher",
      "kind" : "struct",
      "line" : 4885,
      "members" : [
       {
        "name" : "DataIndex",
        "kind" : "alias",
        "line" : 4886,
        "type" : "Stream.DataIndex"
       },
       {
        "name" : "freelist",
        "kind" : "variable",
        "line" : 4887,
        "type" : "Thread!(DataIndex)*"
       },
       {
        "name" : "clist",
        "kind" : "variable",
        "line" : 4888,
        "type" : "ThreadList!(DataIndex)"
       },
       {
        "name" : "nlist",
        "kind" : "variable",
        "line" : 4888,
        "type" : "ThreadList!(DataIndex)"
       },
       {
        "name" : "merge",
        "kind" : "variable",
        "line" : 4889,
        "type" : "DataIndex[]"
       },
       {
        "name" : "backrefed",
        "kind" : "variable",
        "line" : 4890,
        "type" : "Group!(DataIndex)[]"
       },
       {
        "name" : "re",
        "kind" : "variable",
        "line" : 4891,
        "type" : "Regex!(Char)"
       },
       {
        "name" : "s",
        "kind" : "variable",
        "line" : 4892,
        "type" : "Stream"
       },
       {
        "name" : "front",
        "kind" : "variable",
        "line" : 4893,
        "deco" : "w"
       },
       {
        "name" : "index",
        "kind" : "variable",
        "line" : 4894,
        "type" : "DataIndex"
       },
       {
        "name" : "genCounter",
        "kind" : "variable",
        "line" : 4895,
        "type" : "DataIndex"
       },
       {
        "name" : "threadSize",
        "kind" : "variable",
        "line" : 4896,
        "type" : "size_t"
       },
       {
        "name" : "matched",
        "kind" : "variable",
        "line" : 4897,
        "deco" : "b"
       },
       {
        "name" : "exhausted",
        "kind" : "variable",
        "line" : 4898,
        "deco" : "b"
       },
       {
        "name" : "getThreadSize",
        "kind" : "function",
        "line" : 4906,
        "type" : "size_t(ref const Regex!(Char) re)",
        "parameters" : [
         {
          "name" : "re",
          "type" : "Regex!(Char)",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 4911
       },
       {
        "name" : "initialMemory",
        "kind" : "function",
        "line" : 4913,
        "type" : "size_t(ref const Regex!(Char) re)",
        "parameters" : [
         {
          "name" : "re",
          "type" : "Regex!(Char)",
          "storageClass" : [
           "const",
           "ref"
          ]
         }
        ],
        "endline" : 4916
       },
       {
        "name" : "atStart",
        "kind" : "function",
        "line" : 4919,
        "type" : "bool()",
        "endline" : 4919
       },
       {
        "name" : "atEnd",
        "kind" : "function",
        "line" : 4922,
        "type" : "bool()",
        "endline" : 4922
       },
       {
        "name" : "next",
        "kind" : "function",
        "line" : 4924,
        "type" : "bool()",
        "endline" : 4932
       },
       {
        "name" : "initExternalMemory",
        "kind" : "function",
        "line" : 4948,
        "type" : "void(void[] memory)",
        "parameters" : [
         {
          "name" : "memory",
          "type" : "void[]"
         }
        ],
        "endline" : 4957
       },
       {
        "kind" : "template",
        "line" : 4959,
        "name" : "this",
        "parameters" : [],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 4959,
          "type" : "(Regex!(Char) program, Stream stream, void[] memory)",
          "parameters" : [
           {
            "name" : "program",
            "type" : "Regex!(Char)"
           },
           {
            "name" : "stream",
            "type" : "Stream"
           },
           {
            "name" : "memory",
            "type" : "void[]"
           }
          ],
          "endline" : 4965
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 4967,
        "name" : "this",
        "parameters" : [
         {
          "name" : "S",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 4967,
          "type" : "(ref ThompsonMatcher!(Char, S) matcher, Bytecode[] piece, Stream stream)",
          "parameters" : [
           {
            "name" : "matcher",
            "type" : "ThompsonMatcher!(Char, S)",
            "storageClass" : [
             "ref"
            ]
           },
           {
            "name" : "piece",
            "type" : "Bytecode[]"
           },
           {
            "name" : "stream",
            "type" : "Stream"
           }
          ],
          "endline" : 4976
         }
        ]
       },
       {
        "name" : "dupTo",
        "kind" : "function",
        "line" : 4979,
        "storageClass" : [
         "auto"
        ],
        "type" : "(void[] memory)",
        "parameters" : [
         {
          "name" : "memory",
          "type" : "void[]"
         }
        ],
        "endline" : 4984
       },
       {
        "name" : "MatchResult",
        "kind" : "enum",
        "line" : 4986,
        "members" : [
         {
          "name" : "NoMatch",
          "kind" : "enum member",
          "line" : 4987
         },
         {
          "name" : "PartialMatch",
          "kind" : "enum member",
          "line" : 4988
         },
         {
          "name" : "Match",
          "kind" : "enum member",
          "line" : 4989
         }
        ]
       },
       {
        "name" : "match",
        "kind" : "function",
        "line" : 4993,
        "type" : "bool(Group!(DataIndex)[] matches)",
        "parameters" : [
         {
          "name" : "matches",
          "type" : "Group!(DataIndex)[]"
         }
        ],
        "endline" : 5082
       },
       {
        "name" : "finish",
        "kind" : "function",
        "line" : 5087,
        "type" : "void(const(Thread!(DataIndex))* t, Group!(DataIndex)[] matches)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "const(Thread!(DataIndex))*"
         },
         {
          "name" : "matches",
          "type" : "Group!(DataIndex)[]"
         }
        ],
        "endline" : 5100
       },
       {
        "kind" : "template",
        "line" : 5106,
        "name" : "eval",
        "parameters" : [
         {
          "name" : "withInput",
          "kind" : "value",
          "deco" : "b"
         }
        ],
        "members" : [
         {
          "name" : "eval",
          "kind" : "function",
          "line" : 5106,
          "type" : "void(Thread!(DataIndex)* t, Group!(DataIndex)[] matches)",
          "parameters" : [
           {
            "name" : "t",
            "type" : "Thread!(DataIndex)*"
           },
           {
            "name" : "matches",
            "type" : "Group!(DataIndex)[]"
           }
          ],
          "endline" : 5572
         }
        ]
       },
       {
        "name" : "RestartPc",
        "kind" : "variable",
        "line" : 5573,
        "storageClass" : [
         "enum"
        ],
        "deco" : "k",
        "init" : "(uint).max"
       },
       {
        "kind" : "template",
        "line" : 5575,
        "name" : "matchOneShot",
        "parameters" : [
         {
          "name" : "direction",
          "kind" : "value",
          "type" : "OneShot"
         }
        ],
        "members" : [
         {
          "name" : "matchOneShot",
          "kind" : "function",
          "line" : 5575,
          "type" : "MatchResult(Group!(DataIndex)[] matches, uint startPc = 0)",
          "parameters" : [
           {
            "name" : "matches",
            "type" : "Group!(DataIndex)[]"
           },
           {
            "name" : "startPc",
            "deco" : "k",
            "default" : "0"
           }
          ],
          "endline" : 5649
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 5654,
        "name" : "evalBack",
        "parameters" : [
         {
          "name" : "withInput",
          "kind" : "value",
          "deco" : "b"
         }
        ],
        "members" : [
         {
          "name" : "evalBack",
          "kind" : "function",
          "line" : 5654,
          "type" : "void(Thread!(DataIndex)* t, Group!(DataIndex)[] matches)",
          "parameters" : [
           {
            "name" : "t",
            "type" : "Thread!(DataIndex)*"
           },
           {
            "name" : "matches",
            "type" : "Group!(DataIndex)[]"
           }
          ],
          "endline" : 6079
         }
        ]
       },
       {
        "name" : "allocate",
        "kind" : "function",
        "line" : 6082,
        "type" : "Thread!(DataIndex)*()",
        "endline" : 6088
       },
       {
        "name" : "prepareFreeList",
        "kind" : "function",
        "line" : 6091,
        "type" : "void(size_t size, ref void[] memory)",
        "parameters" : [
         {
          "name" : "size",
          "type" : "size_t"
         },
         {
          "name" : "memory",
          "type" : "void[]",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 6100
       },
       {
        "name" : "recycle",
        "kind" : "function",
        "line" : 6103,
        "type" : "void(Thread!(DataIndex)* t)",
        "parameters" : [
         {
          "name" : "t",
          "type" : "Thread!(DataIndex)*"
         }
        ],
        "endline" : 6107
       },
       {
        "name" : "recycle",
        "kind" : "function",
        "line" : 6110,
        "type" : "void(ref ThreadList!(DataIndex) list)",
        "parameters" : [
         {
          "name" : "list",
          "type" : "ThreadList!(DataIndex)",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 6120
       },
       {
        "name" : "fork",
        "kind" : "function",
        "line" : 6123,
        "type" : "Thread!(DataIndex)*(Thread!(DataIndex)* master, uint pc, uint counter)",
        "parameters" : [
         {
          "name" : "master",
          "type" : "Thread!(DataIndex)*"
         },
         {
          "name" : "pc",
          "deco" : "k"
         },
         {
          "name" : "counter",
          "deco" : "k"
         }
        ],
        "endline" : 6131
       },
       {
        "name" : "createStart",
        "kind" : "function",
        "line" : 6134,
        "type" : "Thread!(DataIndex)*(DataIndex index, uint pc = 0)",
        "parameters" : [
         {
          "name" : "index",
          "type" : "DataIndex"
         },
         {
          "name" : "pc",
          "deco" : "k",
          "default" : "0"
         }
        ],
        "endline" : 6143
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D Captures) object contains submatches captured during a call\n    to $(D match) or iteration over $(D RegexMatch) range.\n\n    First element of range is the whole match.\n\n    Example, showing basic operations on $(D Captures):\n    ----\n    import std.regex;\n    import std.range;\n\n    void main()\n    {\n        auto m = match(\"@abc#\", regex(`(\\w)(\\w)(\\w)`));\n        auto c = m.captures;\n        assert(c.pre == \"@\"); // Part of input preceeding match\n        assert(c.post == \"#\"); // Immediately after match\n        assert(c.hit == c[0] && c.hit == \"abc\"); // The whole match\n        assert(c[2] ==\"b\");\n        assert(c.front == \"abc\");\n        c.popFront();\n        assert(c.front == \"a\");\n        assert(c.back == \"c\");\n        c.popBack();\n        assert(c.back == \"b\");\n        popFrontN(c, 2);\n        assert(c.empty);\n    }\n    ----\n",
    "line" : 6178,
    "name" : "Captures",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "DIndex",
      "kind" : "type",
      "default" : "size_t"
     }
    ],
    "members" : [
     {
      "name" : "Captures",
      "kind" : "struct",
      "line" : 6178,
      "members" : [
       {
        "name" : "DataIndex",
        "kind" : "alias",
        "line" : 6179,
        "type" : "DIndex"
       },
       {
        "name" : "String",
        "kind" : "alias",
        "line" : 6180,
        "type" : "R"
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 6182,
        "type" : "R"
       },
       {
        "name" : "_empty",
        "kind" : "variable",
        "line" : 6183,
        "deco" : "b"
       },
       {
        "name" : "smallString",
        "kind" : "variable",
        "line" : 6184,
        "storageClass" : [
         "enum"
        ],
        "init" : "3"
       },
       {
        "name" : "big_matches",
        "kind" : "variable",
        "line" : 6187,
        "type" : "Group!(DataIndex)[]"
       },
       {
        "name" : "small_matches",
        "kind" : "variable",
        "line" : 6188,
        "type" : "Group!(DataIndex)[smallString]"
       },
       {
        "name" : "f",
        "kind" : "variable",
        "line" : 6190,
        "deco" : "k"
       },
       {
        "name" : "b",
        "kind" : "variable",
        "line" : 6190,
        "deco" : "k"
       },
       {
        "name" : "ngroup",
        "kind" : "variable",
        "line" : 6191,
        "deco" : "k"
       },
       {
        "name" : "names",
        "kind" : "variable",
        "line" : 6192,
        "type" : "NamedGroup[]"
       },
       {
        "kind" : "template",
        "line" : 6194,
        "name" : "this",
        "parameters" : [
         {
          "name" : "Engine",
          "kind" : "alias"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 6194,
          "type" : "(ref RegexMatch!(R, Engine) rmatch)",
          "parameters" : [
           {
            "name" : "rmatch",
            "type" : "RegexMatch!(R, Engine)",
            "storageClass" : [
             "ref"
            ]
           }
          ],
          "endline" : 6202
         }
        ]
       },
       {
        "name" : "matches",
        "kind" : "function",
        "line" : 6204,
        "type" : "Group!(DataIndex)[]()",
        "endline" : 6207
       },
       {
        "name" : "newMatches",
        "kind" : "function",
        "line" : 6209,
        "type" : "void()",
        "endline" : 6213
       },
       {
        "name" : "pre",
        "kind" : "function",
        "comment" : "Slice of input prior to the match.\n",
        "line" : 6217,
        "type" : "R()",
        "endline" : 6220
       },
       {
        "name" : "post",
        "kind" : "function",
        "comment" : "Slice of input immediately after the match.\n",
        "line" : 6223,
        "type" : "R()",
        "endline" : 6226
       },
       {
        "name" : "hit",
        "kind" : "function",
        "comment" : "Slice of matched portion of input.\n",
        "line" : 6229,
        "type" : "R()",
        "endline" : 6233
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "Range interface.\n",
        "line" : 6236,
        "type" : "R()",
        "endline" : 6240
       },
       {
        "name" : "back",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6243,
        "type" : "R()",
        "endline" : 6247
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6250,
        "type" : "void()",
        "endline" : 6254
       },
       {
        "name" : "popBack",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6257,
        "type" : "void()",
        "endline" : 6261
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6264,
        "type" : "const bool()",
        "endline" : 6264
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 6267,
        "name" : "opIndex",
        "parameters" : [],
        "members" : [
         {
          "name" : "opIndex",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 6267,
          "type" : "R(size_t i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "size_t"
           }
          ],
          "endline" : 6272
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n        Lookup named submatch.\n\n        ---\n        import std.regex;\n        import std.range;\n\n        auto m = match(\"a = 42;\", regex(`(?P<var>\\w+)\\s*=\\s*(?P<value>\\d+);`));\n        auto c = m.captures;\n        assert(c[\"var\"] == \"a\");\n        assert(c[\"value\"] == \"42\");\n        popFrontN(c, 2);\n        //named groups are unaffected by range primitives\n        assert(c[\"var\"] ==\"a\");\n        assert(c.front == \"42\");\n        ----\n    \n",
        "line" : 6291,
        "name" : "opIndex",
        "parameters" : [
         {
          "name" : "String",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opIndex",
          "kind" : "function",
          "comment" : "\n        Lookup named submatch.\n\n        ---\n        import std.regex;\n        import std.range;\n\n        auto m = match(\"a = 42;\", regex(`(?P<var>\\w+)\\s*=\\s*(?P<value>\\d+);`));\n        auto c = m.captures;\n        assert(c[\"var\"] == \"a\");\n        assert(c[\"value\"] == \"42\");\n        popFrontN(c, 2);\n        //named groups are unaffected by range primitives\n        assert(c[\"var\"] ==\"a\");\n        assert(c.front == \"42\");\n        ----\n    \n",
          "line" : 6291,
          "type" : "R(String i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "String"
           }
          ],
          "endline" : 6296
         }
        ]
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : "Number of matches in this object.\n",
        "line" : 6299,
        "type" : "const size_t()",
        "endline" : 6299
       },
       {
        "name" : "captures",
        "kind" : "function",
        "comment" : "A hook for compatibility with original std.regex.\n",
        "line" : 6302,
        "type" : "@property ref ()",
        "endline" : 6302
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL6305_1522",
    "kind" : "function",
    "protection" : "private",
    "line" : 6305,
    "endline" : 6332
   },
   {
    "kind" : "template",
    "comment" : "\n    A regex engine state, as returned by $(D match) family of functions.\n\n    Effectively it's a forward range of Captures!R, produced\n    by lazily searching for matches in a given input.\n\n    alias Engine specifies an engine type to use during matching,\n    and is automatically deduced in a call to $(D match)/$(D bmatch).\n",
    "line" : 6334,
    "name" : "RegexMatch",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Engine",
      "kind" : "alias",
      "defaultAlias" : "ThompsonMatcher"
     }
    ],
    "members" : [
     {
      "name" : "RegexMatch",
      "kind" : "struct",
      "line" : 6334,
      "members" : [
       {
        "name" : "Char",
        "kind" : "alias",
        "line" : 6336,
        "type" : "BasicElementOf!(R)"
       },
       {
        "name" : "EngineType",
        "kind" : "alias",
        "line" : 6337,
        "type" : "Engine!(Char)"
       },
       {
        "name" : "_engine",
        "kind" : "variable",
        "line" : 6338,
        "type" : "EngineType"
       },
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 6339,
        "type" : "R"
       },
       {
        "name" : "_captures",
        "kind" : "variable",
        "line" : 6340,
        "type" : "Captures!(R, EngineType.DataIndex)"
       },
       {
        "name" : "_memory",
        "kind" : "variable",
        "line" : 6341,
        "type" : "void[]"
       },
       {
        "kind" : "template",
        "line" : 6343,
        "name" : "this",
        "parameters" : [
         {
          "name" : "RegEx",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 6343,
          "type" : "(RegEx prog, R input)",
          "parameters" : [
           {
            "name" : "prog",
            "type" : "RegEx"
           },
           {
            "name" : "input",
            "type" : "R"
           }
          ],
          "endline" : 6354
         }
        ]
       },
       {
        "name" : "counter",
        "kind" : "function",
        "line" : 6356,
        "type" : "size_t()",
        "endline" : 6356
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "line" : 6368,
        "endline" : 6376
       },
       {
        "name" : "pre",
        "kind" : "function",
        "comment" : "Shorthands for front.pre, front.post, front.hit.\n",
        "line" : 6379,
        "type" : "R()",
        "endline" : 6382
       },
       {
        "name" : "post",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6385,
        "type" : "R()",
        "endline" : 6388
       },
       {
        "name" : "hit",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6391,
        "type" : "R()",
        "endline" : 6394
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "\n        Functionality for processing subsequent matches of global regexes via range interface:\n        ---\n        import std.regex;\n        auto m = match(\"Hello, world!\", regex(`\\w+`, \"g\"));\n        assert(m.front.hit == \"Hello\");\n        m.popFront();\n        assert(m.front.hit == \"world\");\n        m.popFront();\n        assert(m.empty);\n        ---\n    \n",
        "line" : 6409,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 6411
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6414,
        "type" : "void()",
        "endline" : 6428
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6431,
        "storageClass" : [
         "auto"
        ],
        "type" : "()",
        "endline" : 6431
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "Test if this match object is empty.\n",
        "line" : 6434,
        "type" : "bool()",
        "endline" : 6434
       },
       {
        "kind" : "template",
        "comment" : "Same as !(x.empty), provided for its convenience  in conditional statements.\n",
        "line" : 6437,
        "name" : "opCast",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type",
          "deco" : "b"
         }
        ],
        "members" : [
         {
          "name" : "opCast",
          "kind" : "function",
          "comment" : "Same as !(x.empty), provided for its convenience  in conditional statements.\n",
          "line" : 6437,
          "type" : "T()",
          "endline" : 6437
         }
        ]
       },
       {
        "name" : "captures",
        "kind" : "function",
        "comment" : " Same as .front, provided for compatibility with original std.regex.\n",
        "line" : 6440,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 6440
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Compile regular expression pattern for the later execution.\n    Returns: $(D Regex) object that works on inputs having\n    the same character width as $(D pattern).\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n\n    Throws: $(D RegexException) if there were any errors during compilation.\n",
    "line" : 6455,
    "name" : "regex",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "regex",
      "kind" : "function",
      "line" : 6455,
      "storageClass" : [
       "auto"
      ],
      "type" : "(S pattern, const(char)[] flags = \"\")",
      "parameters" : [
       {
        "name" : "pattern",
        "type" : "S"
       },
       {
        "name" : "flags",
        "type" : "const(char)[]",
        "default" : "\"\""
       }
      ],
      "endline" : 6462
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 6464,
    "name" : "regexImpl",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "regexImpl",
      "kind" : "function",
      "line" : 6464,
      "storageClass" : [
       "auto"
      ],
      "type" : "(S pattern, const(char)[] flags = \"\")",
      "parameters" : [
       {
        "name" : "pattern",
        "type" : "S"
       },
       {
        "name" : "flags",
        "type" : "const(char)[]",
        "default" : "\"\""
       }
      ],
      "endline" : 6480
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 6483,
    "name" : "ctRegexImpl",
    "parameters" : [
     {
      "name" : "pattern",
      "kind" : "alias"
     },
     {
      "name" : "flags",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "[]"
     }
    ],
    "members" : [
     {
      "name" : "r",
      "kind" : "variable",
      "line" : 6485,
      "storageClass" : [
       "enum"
      ],
      "init" : "regex(pattern, flags)"
     },
     {
      "name" : "Char",
      "kind" : "alias",
      "line" : 6486,
      "type" : "BasicElementOf!(typeof(pattern))"
     },
     {
      "name" : "source",
      "kind" : "variable",
      "line" : 6487,
      "storageClass" : [
       "enum"
      ],
      "init" : "ctGenRegExCode(r)"
     },
     {
      "name" : "Matcher",
      "kind" : "alias",
      "line" : 6488,
      "type" : "BacktrackingMatcher!(true)"
     },
     {
      "name" : "func",
      "kind" : "function",
      "line" : 6489,
      "type" : "bool(ref Matcher!(Char) matcher)",
      "parameters" : [
       {
        "name" : "matcher",
        "type" : "Matcher!(Char)",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 6493
     },
     {
      "name" : "nr",
      "kind" : "variable",
      "line" : 6494,
      "storageClass" : [
       "enum"
      ],
      "init" : "StaticRegex!(Char)(r, &func)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Experimental feature.\n\n    Compile regular expression using CTFE\n    and generate optimized native machine code for matching it.\n\n    Returns: StaticRegex object for faster matching.\n\n    Params:\n    pattern = Regular expression\n    flags = The _attributes (g, i, m and x accepted)\n",
    "line" : 6509,
    "name" : "ctRegex",
    "parameters" : [
     {
      "name" : "pattern",
      "kind" : "alias"
     },
     {
      "name" : "flags",
      "kind" : "alias",
      "defaultAlias" : "[]"
     }
    ],
    "members" : [
     {
      "name" : "ctRegex",
      "kind" : "variable",
      "line" : 6511,
      "storageClass" : [
       "enum"
      ],
      "init" : "ctRegexImpl!(pattern, flags).nr"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 6514,
    "name" : "isRegexFor",
    "parameters" : [
     {
      "name" : "RegEx",
      "kind" : "type"
     },
     {
      "name" : "R",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isRegexFor",
      "kind" : "variable",
      "line" : 6517,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(RegEx == Regex!(BasicElementOf!(R))) || is(RegEx == StaticRegex!(BasicElementOf!(R)))"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Start matching $(D input) to regex pattern $(D re),\n    using Thompson NFA matching scheme.\n\n    This is the $(U recommended) method for matching regular expression.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar/dchar) that contains pattern in form of\n        precompiled  bytecode. )\n      $(LI StaticRegex!char (wchar/dchar) that contains pattern in form of\n        specially crafted native code. )\n    )\n    Returns: a $(D RegexMatch) object holding engine state after first match.\n",
    "line" : 6537,
    "name" : "match",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "match",
      "kind" : "function",
      "line" : 6537,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R input, RegEx re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "RegEx"
       }
      ],
      "endline" : 6541
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 6544,
    "name" : "match",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "String",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "match",
      "kind" : "function",
      "line" : 6544,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R input, String re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "String"
       }
      ],
      "endline" : 6548
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 6550,
    "name" : "match",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "match",
      "kind" : "function",
      "line" : 6550,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R input, RegEx re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "RegEx"
       }
      ],
      "endline" : 6554
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Start matching $(D input) to regex pattern $(D re),\n    using traditional $(LUCKY backtracking) matching scheme.\n\n    $(D re) parameter can be one of three types:\n    $(UL\n      $(LI Plain string, in which case it's compiled to bytecode before matching. )\n      $(LI Regex!char (wchar/dchar) that contains pattern in form of\n        precompiled  bytecode. )\n      $(LI StaticRegex!char (wchar/dchar) that contains pattern in form of\n        specially crafted native code. )\n    )\n\n    Returns: a $(D RegexMatch) object holding engine\n    state after first match.\n\n",
    "line" : 6573,
    "name" : "bmatch",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "bmatch",
      "kind" : "function",
      "line" : 6573,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R input, RegEx re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "RegEx"
       }
      ],
      "endline" : 6577
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 6580,
    "name" : "bmatch",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "String",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "bmatch",
      "kind" : "function",
      "line" : 6580,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R input, String re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "String"
       }
      ],
      "endline" : 6584
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 6586,
    "name" : "bmatch",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "bmatch",
      "kind" : "function",
      "line" : 6586,
      "storageClass" : [
       "auto"
      ],
      "type" : "(R input, RegEx re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "RegEx"
       }
      ],
      "endline" : 6590
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Construct a new string from $(D input) by replacing each match with\n    a string generated from match according to $(D format) specifier.\n\n    To replace all occurrences use regex with \"g\" flag, otherwise\n    only the first occurrence gets replaced.\n\n    Params:\n    input = string to search\n    re = compiled regular expression to use\n    format = format string to generate replacements from\n\n    Example:\n    ---\n    // Comify a number\n    auto com = regex(r\"(?<=\\d)(?=(\\d\\d\\d)+\\b)\",\"g\");\n    assert(replace(\"12000 + 42100 = 54100\", com, \",\") == \"12,000 + 42,100 = 54,100\");\n    ---\n\n    The format string can reference parts of match using the following notation.\n    $(REG_TABLE\n        $(REG_TITLE Format specifier, Replaced by )\n        $(REG_ROW $&amp;, the whole match. )\n        $(REG_ROW $`, part of input $(I preceding) the match. )\n        $(REG_ROW $', part of input $(I following) the match. )\n        $(REG_ROW $$, '$' character. )\n        $(REG_ROW \\c &#44 where c is any character, the character c itself. )\n        $(REG_ROW \\\\, '\\' character. )\n        $(REG_ROW &#36;1 .. &#36;99, submatch number 1 to 99 respectively. )\n    )\n    ---\n    assert(replace(\"noon\", regex(\"^n\"), \"[$&]\") == \"[n]oon\");\n    ---\n",
    "line" : 6626,
    "name" : "replace",
    "parameters" : [
     {
      "name" : "scheme",
      "kind" : "alias",
      "defaultAlias" : "match"
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replace",
      "kind" : "function",
      "line" : 6626,
      "type" : "R(R input, RegEx re, R format)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "RegEx"
       },
       {
        "name" : "format",
        "type" : "R"
       }
      ],
      "endline" : 6640
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Search string for matches using regular expression pattern $(D re)\n    and pass captures for each match to user-defined functor $(D fun).\n\n    To replace all occurrances use regex with \"g\" flag, otherwise\n    only first occurrence gets replaced.\n\n    Returns: new string with all matches replaced by return values of $(D fun).\n\n    Params:\n    s = string to search\n    re = compiled regular expression\n    fun = delegate to use\n\n    Example:\n    Capitalize the letters 'a' and 'r':\n    ---\n    string baz(Captures!(string) m)\n    {\n        return std.string.toUpper(m.hit);\n    }\n    auto s = replace!(baz)(\"Strap a rocket engine on a chicken.\",\n            regex(\"[ar]\", \"g\"));\n    assert(s == \"StRAp A Rocket engine on A chicken.\");\n    ---\n",
    "line" : 6668,
    "name" : "replace",
    "parameters" : [
     {
      "name" : "fun",
      "kind" : "alias"
     },
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     },
     {
      "name" : "scheme",
      "kind" : "alias",
      "defaultAlias" : "match"
     }
    ],
    "members" : [
     {
      "name" : "replace",
      "kind" : "function",
      "line" : 6668,
      "type" : "R(R input, RegEx re)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "R"
       },
       {
        "name" : "re",
        "type" : "RegEx"
       }
      ],
      "endline" : 6682
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 6685,
    "name" : "replaceFmt",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type"
     },
     {
      "name" : "Capt",
      "kind" : "type"
     },
     {
      "name" : "OutR",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "replaceFmt",
      "kind" : "function",
      "line" : 6685,
      "type" : "void(R format, Capt captures, OutR sink, bool ignoreBadSubs = false)",
      "parameters" : [
       {
        "name" : "format",
        "type" : "R"
       },
       {
        "name" : "captures",
        "type" : "Capt"
       },
       {
        "name" : "sink",
        "type" : "OutR"
       },
       {
        "name" : "ignoreBadSubs",
        "deco" : "b",
        "default" : "false"
       }
      ],
      "endline" : 6752
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nRange that splits a string using a regular expression as a\nseparator.\n\nExample:\n----\nauto s1 = \", abc, de,  fg, hi, \";\nassert(equal(splitter(s1, regex(\", *\")),\n    [\"\", \"abc\", \"de\", \"fg\", \"hi\", \"\"]));\n----\n",
    "line" : 6767,
    "name" : "Splitter",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "alias",
      "defaultAlias" : "Regex"
     }
    ],
    "members" : [
     {
      "name" : "Splitter",
      "kind" : "struct",
      "line" : 6767,
      "members" : [
       {
        "name" : "_input",
        "kind" : "variable",
        "line" : 6769,
        "type" : "Range"
       },
       {
        "name" : "_offset",
        "kind" : "variable",
        "line" : 6770,
        "type" : "size_t"
       },
       {
        "name" : "Rx",
        "kind" : "alias",
        "line" : 6771,
        "type" : "typeof(match(Range.init, RegEx.init))"
       },
       {
        "name" : "_match",
        "kind" : "variable",
        "line" : 6772,
        "type" : "Rx"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 6774,
        "type" : "(Range input, RegEx separator)",
        "parameters" : [
         {
          "name" : "input",
          "type" : "Range"
         },
         {
          "name" : "separator",
          "type" : "RegEx"
         }
        ],
        "endline" : 6787
       },
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 6791,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref ()",
        "endline" : 6793
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : "Forward range primitives.\n",
        "line" : 6796,
        "type" : "Range()",
        "endline" : 6801
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6804,
        "type" : "bool()",
        "endline" : 6807
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6810,
        "type" : "void()",
        "endline" : 6824
       },
       {
        "name" : "save",
        "kind" : "function",
        "comment" : "ditto\n",
        "line" : 6828,
        "storageClass" : [
         "auto"
        ],
        "type" : "@property ()",
        "endline" : 6830
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    A helper function, creates a $(D Splitter) on range $(D r) separated by regex $(D pat).\n    Captured subexpressions have no effect on the resulting range.\n",
    "line" : 6837,
    "name" : "splitter",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitter",
      "kind" : "function",
      "line" : 6837,
      "type" : "Splitter!(Range, RegEx)(Range r, RegEx pat)",
      "parameters" : [
       {
        "name" : "r",
        "type" : "Range"
       },
       {
        "name" : "pat",
        "type" : "RegEx"
       }
      ],
      "endline" : 6841
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "An eager version of $(D splitter) that creates an array with splitted slices of $(D input).\n",
    "line" : 6844,
    "name" : "split",
    "parameters" : [
     {
      "name" : "String",
      "kind" : "type"
     },
     {
      "name" : "RegEx",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "split",
      "kind" : "function",
      "line" : 6844,
      "type" : "String[](String input, RegEx rx)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "String"
       },
       {
        "name" : "rx",
        "type" : "RegEx"
       }
      ],
      "endline" : 6851
     }
    ]
   },
   {
    "name" : "RegexException",
    "kind" : "class",
    "comment" : "Exception object thrown in case of errors during regex compilation.\n",
    "line" : 6854,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 6857,
      "storageClass" : [
       "@trusted"
      ],
      "deco" : "FNeAyaAyamZC3std5regex14RegexException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 6860
     }
    ]
   }
  ]
 },
 {
  "name" : "std.signals",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/signals.d",
  "comment" : "\n Signals and Slots are an implementation of the Observer Pattern.\n Essentially, when a Signal is emitted, a list of connected Observers\n (called slots) are called.\n\n There have been several D implementations of Signals and Slots.\n This version makes use of several new features in D, which make\n using it simpler and less error prone. In particular, it is no\n longer necessary to instrument the slots.\n\n References:\n      $(LUCKY A Deeper Look at Signals and Slots)$(BR)\n      $(LINK2 http://en.wikipedia.org/wiki/Observer_pattern, Observer pattern)$(BR)\n      $(LINK2 http://en.wikipedia.org/wiki/Signals_and_slots, Wikipedia)$(BR)\n      $(LINK2 http://boost.org/doc/html/$(SIGNALS).html, Boost Signals)$(BR)\n      $(LINK2 http://doc.trolltech.com/4.1/signalsandslots.html, Qt)$(BR)\n\n      There has been a great deal of discussion in the D newsgroups\n      over this, and several implementations:\n\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/announce/signal_slots_library_4825.html, signal slots library)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Signals_and_Slots_in_D_42387.html, Signals and Slots in D)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Dynamic_binding_--_Qt_s_Signals_and_Slots_vs_Objective-C_42260.html, Dynamic binding -- Qt's Signals and Slots vs Objective-C)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/Dissecting_the_SS_42377.html, Dissecting the SS)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/dwt/about_harmonia_454.html, about harmonia)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/announce/1502.html, Another event handling module)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/41825.html, Suggestion: signal/slot mechanism)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/13251.html, Signals and slots?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/10714.html, Signals and slots ready for evaluation)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/digitalmars/D/1393.html, Signals &amp; Slots for Walter)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/28456.html, Signal/Slot mechanism?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/19470.html, Modern Features?)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16592.html, Delegates vs interfaces)$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16583.html, The importance of component programming (properties$(COMMA) signals and slots$(COMMA) etc))$(BR)\n      $(LINK2 http://www.digitalmars.com/d/archives/16368.html, signals and slots)$(BR)\n\n Bugs:\n      Slots can only be delegates formed from class objects or\n      interfaces to class objects. If a delegate to something else\n      is passed to connect(), such as a struct member function,\n      a nested function or a COM interface, undefined behavior\n      will result.\n\n      Not safe for multiple threads operating on the same signals\n      or slots.\n Macros:\n      WIKI = Phobos/StdSignals\n      SIGNALS=signals\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_signals.d)\n \n",
  "members" : [
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 64,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdlib",
    "kind" : "import",
    "line" : 65,
    "protection" : "private",
    "selective" : [
     "calloc",
     "realloc",
     "free"
    ]
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 66,
    "protection" : "private",
    "selective" : [
     "onOutOfMemoryError"
    ]
   },
   {
    "name" : "_d_toObject",
    "kind" : "function",
    "line" : 71,
    "deco" : "UPvZC6Object",
    "parameters" : [
     {
      "name" : "p",
      "deco" : "Pv"
     }
    ]
   },
   {
    "name" : "DisposeEvt",
    "kind" : "alias",
    "line" : 74,
    "deco" : "DFC6ObjectZv"
   },
   {
    "name" : "rt_attachDisposeEvent",
    "kind" : "function",
    "line" : 75,
    "deco" : "UC6ObjectDFC6ObjectZvZv",
    "originalType" : "extern (C) void(Object obj, DisposeEvt evt)",
    "parameters" : [
     {
      "name" : "obj",
      "deco" : "C6Object"
     },
     {
      "name" : "evt",
      "deco" : "DFC6ObjectZv"
     }
    ]
   },
   {
    "name" : "rt_detachDisposeEvent",
    "kind" : "function",
    "line" : 76,
    "deco" : "UC6ObjectDFC6ObjectZvZv",
    "originalType" : "extern (C) void(Object obj, DisposeEvt evt)",
    "parameters" : [
     {
      "name" : "obj",
      "deco" : "C6Object"
     },
     {
      "name" : "evt",
      "deco" : "DFC6ObjectZv"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Mixin to create a signal within a class object.\n\n Different signals can be added to a class by naming the mixins.\n\n Example:\n---\nimport std.signals;\nimport std.stdio;\n\nclass Observer\n{   // our slot\n    void watch(string msg, int i)\n    {\n        writefln(\"Observed msg '%s' and value %s\", msg, i);\n    }\n}\n\nclass Foo\n{\n    int value() { return _value; }\n\n    int value(int v)\n    {\n        if (v != _value)\n        {   _value = v;\n            // call all the connected slots with the two parameters\n            emit(\"setting new value\", v);\n        }\n        return v;\n    }\n\n    // Mix in all the code we need to make Foo into a signal\n    mixin Signal!(string, int);\n\n  private :\n    int _value;\n}\n\nvoid main()\n{\n    Foo a = new Foo;\n    Observer o = new Observer;\n\n    a.value = 3;                // should not call o.watch()\n    a.connect(&o.watch);        // o.watch is the slot\n    a.value = 4;                // should call o.watch()\n    a.disconnect(&o.watch);     // o.watch is no longer a slot\n    a.value = 5;                // so should not call o.watch()\n    a.connect(&o.watch);        // connect again\n    a.value = 6;                // should call o.watch()\n    destroy(o);                 // destroying o should automatically disconnect it\n    a.value = 7;                // should not call o.watch()\n}\n---\n which should print:\n <pre>\n Observed msg 'setting new value' and value 4\n Observed msg 'setting new value' and value 6\n </pre>\n\n \n",
    "line" : 142,
    "name" : "Signal",
    "parameters" : [
     {
      "name" : "T1",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "std.c.stdlib",
      "kind" : "static import",
      "line" : 144,
      "protection" : "private"
     },
     {
      "name" : "core.exception",
      "kind" : "static import",
      "line" : 145,
      "protection" : "private"
     },
     {
      "name" : "slot_t",
      "kind" : "alias",
      "comment" : "\n A slot is implemented as a delegate.\n The slot_t is the type of the delegate.\n The delegate must be to an instance of a class or an interface\n to a class instance.\n Delegates to struct instances or nested functions must not be\n used as slots.\n     \n",
      "line" : 154,
      "type" : "void delegate(T1)"
     },
     {
      "name" : "emit",
      "kind" : "function",
      "comment" : "\n Call each of the connected slots, passing the argument(s) i to them.\n     \n",
      "line" : 159,
      "type" : "void(T1 i)",
      "parameters" : [
       {
        "name" : "i",
        "type" : "T1"
       }
      ],
      "endline" : 165
     },
     {
      "name" : "connect",
      "kind" : "function",
      "comment" : "\n Add a slot to the list of slots to be called when emit() is called.\n     \n",
      "line" : 170,
      "type" : "void(slot_t slot)",
      "parameters" : [
       {
        "name" : "slot",
        "type" : "slot_t"
       }
      ],
      "endline" : 202
     },
     {
      "name" : "disconnect",
      "kind" : "function",
      "comment" : "\n Remove a slot from the list of slots to be called when emit() is called.\n     \n",
      "line" : 207,
      "type" : "void(slot_t slot)",
      "parameters" : [
       {
        "name" : "slot",
        "type" : "slot_t"
       }
      ],
      "endline" : 223
     },
     {
      "name" : "unhook",
      "kind" : "function",
      "line" : 230,
      "type" : "void(Object o)",
      "parameters" : [
       {
        "name" : "o",
        "type" : "Object"
       }
      ],
      "endline" : 243
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 248,
      "endline" : 267
     },
     {
      "name" : "slots",
      "kind" : "variable",
      "line" : 270,
      "type" : "slot_t[]"
     },
     {
      "name" : "slots_idx",
      "kind" : "variable",
      "line" : 271,
      "type" : "size_t"
     }
    ]
   },
   {
    "name" : "linkin",
    "kind" : "function",
    "line" : 276,
    "deco" : "FZv",
    "endline" : 276
   },
   {
    "name" : "__unittestL278_1544",
    "kind" : "function",
    "line" : 278,
    "endline" : 348
   },
   {
    "name" : "__unittestL348_1545",
    "kind" : "function",
    "line" : 348,
    "endline" : 526
   }
  ]
 },
 {
  "name" : "std.socket",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/socket.d",
  "comment" : "\n Example: See $(SAMPLESRC listener.d) and $(SAMPLESRC htmlget.d)\n License: <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors: Christopher E. Miller, $(WEB klickverbot.at, David Nadlinger),\n      $(WEB thecybershadow.net, Vladimir Panteleev)\n Source:  $(PHOBOSSRC std/_socket.d)\n Macros:\n      WIKI=Phobos/StdSocket\n \n",
  "members" : [
   {
    "name" : "core.stdc.stdint",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.c.string",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdlib",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.config",
    "kind" : "import",
    "line" : 50,
    "protection" : "private"
   },
   {
    "name" : "core.time",
    "kind" : "import",
    "line" : 51,
    "protection" : "private",
    "selective" : [
     "dur",
     "Duration"
    ]
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 52,
    "protection" : "private",
    "selective" : [
     "max"
    ]
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 53,
    "protection" : "private",
    "selective" : [
     "assumeUnique",
     "enforce",
     "collectException"
    ]
   },
   {
    "name" : "std.c.linux.socket",
    "kind" : "import",
    "line" : 76,
    "protection" : "private",
    "selective" : [
     "AF_IPX",
     "AF_APPLETALK",
     "SOCK_RDM",
     "IPPROTO_IGMP",
     "IPPROTO_GGP",
     "IPPROTO_PUP",
     "IPPROTO_IDP",
     "SD_RECEIVE",
     "SD_SEND",
     "SD_BOTH",
     "MSG_NOSIGNAL",
     "INADDR_NONE",
     "TCP_KEEPIDLE",
     "TCP_KEEPINTVL"
    ]
   },
   {
    "name" : "core.sys.posix.netdb",
    "kind" : "import",
    "line" : 96,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.fcntl",
    "kind" : "import",
    "line" : 97,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 98,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.arpa.inet",
    "kind" : "import",
    "line" : 99,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.netinet.tcp",
    "kind" : "import",
    "line" : 100,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.netinet.in_",
    "kind" : "import",
    "line" : 101,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.time",
    "kind" : "import",
    "line" : 102,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.sys.socket",
    "kind" : "import",
    "line" : 104,
    "protection" : "private"
   },
   {
    "name" : "_ctimeval",
    "kind" : "alias",
    "protection" : "private",
    "line" : 105,
    "deco" : "S4core3sys5posix3sys4time7timeval"
   },
   {
    "name" : "_clinger",
    "kind" : "alias",
    "protection" : "private",
    "line" : 106,
    "deco" : "S4core3sys5posix3sys6socket6linger"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 108,
    "protection" : "private"
   },
   {
    "name" : "socket_t",
    "kind" : "enum",
    "line" : 110,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "init",
      "kind" : "enum member",
      "line" : 110
     }
    ]
   },
   {
    "name" : "_SOCKET_ERROR",
    "kind" : "variable",
    "protection" : "private",
    "line" : 111,
    "storageClass" : [
     "const"
    ],
    "deco" : "xi",
    "originalType" : "int",
    "init" : "-1"
   },
   {
    "name" : "_lasterr",
    "kind" : "function",
    "protection" : "private",
    "line" : 114,
    "deco" : "FZi",
    "endline" : 117
   },
   {
    "name" : "SocketException",
    "kind" : "class",
    "comment" : " Base exception thrown by $(D std.socket).\n",
    "line" : 145,
    "base" : "Exception",
    "members" : [
     {
      "name" : "errorCode",
      "kind" : "function",
      "line" : 148,
      "storageClass" : [
       "deprecated",
       "@property"
      ],
      "deco" : "xFNdZi",
      "originalType" : "const int()",
      "endline" : 155
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 158,
      "deco" : "FAyaAyamC6object9ThrowableZC3std6socket15SocketException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 161
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 164,
      "deco" : "FAyaC6object9ThrowableAyamZC3std6socket15SocketException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 167
     }
    ]
   },
   {
    "name" : "formatSocketError",
    "kind" : "function",
    "line" : 175,
    "deco" : "FiZAya",
    "parameters" : [
     {
      "name" : "err",
      "deco" : "i"
     }
    ],
    "endline" : 219
   },
   {
    "name" : "lastSocketError",
    "kind" : "function",
    "comment" : " Retrieve the error message for the most recently encountered network error.\n",
    "line" : 222,
    "storageClass" : [
     "@property"
    ],
    "deco" : "FNdZAya",
    "originalType" : "string()",
    "endline" : 225
   },
   {
    "name" : "SocketOSException",
    "kind" : "class",
    "comment" : " Socket exceptions representing network errors reported by the operating\n system.\n",
    "line" : 229,
    "base" : "SocketException",
    "members" : [
     {
      "name" : "errorCode",
      "kind" : "variable",
      "comment" : " Platform-specific error code.\n",
      "line" : 231,
      "deco" : "i",
      "offset" : 72
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 234,
      "deco" : "FAyaAyamC6object9ThrowableiPFiZAyaZC3std6socket17SocketOSException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr(), string function(int) errorFormatter = &formatSocketError)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       },
       {
        "name" : "errorFormatter",
        "deco" : "PFiZAya",
        "default" : "& formatSocketError"
       }
      ],
      "endline" : 247
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 250,
      "deco" : "FAyaC6object9ThrowableAyamiPFiZAyaZC3std6socket17SocketOSException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr(), string function(int) errorFormatter = &formatSocketError)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       },
       {
        "name" : "errorFormatter",
        "deco" : "PFiZAya",
        "default" : "& formatSocketError"
       }
      ],
      "endline" : 258
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 261,
      "deco" : "FAyaiPFiZAyaAyamC6object9ThrowableZC3std6socket17SocketOSException",
      "originalType" : "(string msg, int err, string function(int) errorFormatter = &formatSocketError, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "err",
        "deco" : "i"
       },
       {
        "name" : "errorFormatter",
        "deco" : "PFiZAya",
        "default" : "& formatSocketError"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 269
     }
    ]
   },
   {
    "name" : "SocketParameterException",
    "kind" : "class",
    "comment" : " Socket exceptions representing invalid parameters specified by user code.\n",
    "line" : 273,
    "base" : "SocketException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 276,
      "deco" : "FAyaAyamC6object9ThrowableZC3std6socket24SocketParameterException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 279
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 282,
      "deco" : "FAyaC6object9ThrowableAyamZC3std6socket24SocketParameterException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 285
     }
    ]
   },
   {
    "name" : "SocketFeatureException",
    "kind" : "class",
    "comment" : " Socket exceptions representing attempts to use network capabilities not\n available on the current system.\n",
    "line" : 290,
    "base" : "SocketException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 293,
      "deco" : "FAyaAyamC6object9ThrowableZC3std6socket22SocketFeatureException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 296
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 299,
      "deco" : "FAyaC6object9ThrowableAyamZC3std6socket22SocketFeatureException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 302
     }
    ]
   },
   {
    "name" : "wouldHaveBlocked",
    "kind" : "function",
    "comment" : " Return $(D true) if the last socket operation failed because the socket\n was in non-blocking mode and the operation would have blocked.\n",
    "line" : 308,
    "deco" : "FZb",
    "endline" : 316
   },
   {
    "name" : "getnameinfoPointer",
    "kind" : "variable",
    "protection" : "private",
    "line" : 318,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "PUPxS4core3sys5posix3sys6socket8sockaddrkPakPakiZi",
    "originalType" : "typeof(&getnameinfo)"
   },
   {
    "name" : "getaddrinfoPointer",
    "kind" : "variable",
    "protection" : "private",
    "line" : 319,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "PUPxaPxaPxS4core3sys5posix5netdb8addrinfoPPS4core3sys5posix5netdb8addrinfoZi",
    "originalType" : "typeof(&getaddrinfo)"
   },
   {
    "name" : "freeaddrinfoPointer",
    "kind" : "variable",
    "protection" : "private",
    "line" : 320,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "PUPS4core3sys5posix5netdb8addrinfoZv",
    "originalType" : "typeof(&freeaddrinfo)"
   },
   {
    "name" : "_sharedStaticCtor22",
    "kind" : "function",
    "line" : 322,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 354
   },
   {
    "name" : "_sharedStaticDtor23",
    "kind" : "function",
    "line" : 357,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 363
   },
   {
    "name" : "AddressFamily",
    "kind" : "enum",
    "comment" : "\n The communication domain used to resolve an address.\n \n",
    "line" : 368,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "UNSPEC",
      "kind" : "enum member",
      "comment" : " Unspecified address family\n",
      "line" : 370
     },
     {
      "name" : "UNIX",
      "kind" : "enum member",
      "comment" : " Local communication\n",
      "line" : 371
     },
     {
      "name" : "INET",
      "kind" : "enum member",
      "comment" : " Internet Protocol version 4\n",
      "line" : 372
     },
     {
      "name" : "IPX",
      "kind" : "enum member",
      "comment" : " Novell IPX\n",
      "line" : 373
     },
     {
      "name" : "APPLETALK",
      "kind" : "enum member",
      "comment" : " AppleTalk\n",
      "line" : 374
     },
     {
      "name" : "INET6",
      "kind" : "enum member",
      "comment" : " Internet Protocol version 6\n",
      "line" : 375
     }
    ]
   },
   {
    "name" : "SocketType",
    "kind" : "enum",
    "comment" : "\n Communication semantics\n \n",
    "line" : 382,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "STREAM",
      "kind" : "enum member",
      "comment" : " Sequenced, reliable, two-way communication-based byte streams\n",
      "line" : 384
     },
     {
      "name" : "DGRAM",
      "kind" : "enum member",
      "comment" : " Connectionless, unreliable datagrams with a fixed maximum length; data may be lost or arrive out of order\n",
      "line" : 385
     },
     {
      "name" : "RAW",
      "kind" : "enum member",
      "comment" : " Raw protocol access\n",
      "line" : 386
     },
     {
      "name" : "RDM",
      "kind" : "enum member",
      "comment" : " Reliably-delivered message datagrams\n",
      "line" : 387
     },
     {
      "name" : "SEQPACKET",
      "kind" : "enum member",
      "comment" : " Sequenced, reliable, two-way connection-based datagrams with a fixed maximum length\n",
      "line" : 388
     }
    ]
   },
   {
    "name" : "ProtocolType",
    "kind" : "enum",
    "comment" : "\n Protocol\n \n",
    "line" : 395,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "IP",
      "kind" : "enum member",
      "comment" : " Internet Protocol version 4\n",
      "line" : 397
     },
     {
      "name" : "ICMP",
      "kind" : "enum member",
      "comment" : " Internet Control Message Protocol\n",
      "line" : 398
     },
     {
      "name" : "IGMP",
      "kind" : "enum member",
      "comment" : " Internet Group Management Protocol\n",
      "line" : 399
     },
     {
      "name" : "GGP",
      "kind" : "enum member",
      "comment" : " Gateway to Gateway Protocol\n",
      "line" : 400
     },
     {
      "name" : "TCP",
      "kind" : "enum member",
      "comment" : " Transmission Control Protocol\n",
      "line" : 401
     },
     {
      "name" : "PUP",
      "kind" : "enum member",
      "comment" : " PARC Universal Packet Protocol\n",
      "line" : 402
     },
     {
      "name" : "UDP",
      "kind" : "enum member",
      "comment" : " User Datagram Protocol\n",
      "line" : 403
     },
     {
      "name" : "IDP",
      "kind" : "enum member",
      "comment" : " Xerox NS protocol\n",
      "line" : 404
     },
     {
      "name" : "RAW",
      "kind" : "enum member",
      "comment" : " Raw IP packets\n",
      "line" : 405
     },
     {
      "name" : "IPV6",
      "kind" : "enum member",
      "comment" : " Internet Protocol version 6\n",
      "line" : 406
     }
    ]
   },
   {
    "name" : "Protocol",
    "kind" : "class",
    "comment" : "\n $(D Protocol) is a class for retrieving protocol information.\n\n Example:\n ---\n auto proto = new Protocol;\n writeln(\"About protocol TCP:\");\n if (proto.getProtocolByType(ProtocolType.TCP))\n {\n     writefln(\"  Name: %s\", proto.name);\n     foreach(string s; proto.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writeln(\"  No information found\");\n ---\n \n",
    "line" : 428,
    "members" : [
     {
      "name" : "type",
      "kind" : "variable",
      "comment" : " These members are populated when one of the following functions are called successfully:\n",
      "line" : 430,
      "deco" : "E3std6socket12ProtocolType",
      "offset" : 16
     },
     {
      "name" : "name",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 431,
      "deco" : "Aya",
      "offset" : 24
     },
     {
      "name" : "aliases",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 432,
      "deco" : "AAya",
      "offset" : 40
     },
     {
      "name" : "populate",
      "kind" : "function",
      "line" : 435,
      "deco" : "FPS4core3sys5posix5netdb8protoentZv",
      "parameters" : [
       {
        "name" : "proto",
        "deco" : "PS4core3sys5posix5netdb8protoent"
       }
      ],
      "endline" : 460
     },
     {
      "name" : "getProtocolByName",
      "kind" : "function",
      "comment" : " Returns: false on failure \n",
      "line" : 463,
      "deco" : "FxAaZb",
      "originalType" : "bool(in char[] name)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "xAa"
       }
      ],
      "endline" : 471
     },
     {
      "name" : "getProtocolByType",
      "kind" : "function",
      "comment" : " Returns: false on failure \n",
      "line" : 476,
      "deco" : "FE3std6socket12ProtocolTypeZb",
      "parameters" : [
       {
        "name" : "type",
        "deco" : "E3std6socket12ProtocolType"
       }
      ],
      "endline" : 484
     }
    ]
   },
   {
    "name" : "__unittestL488_1548",
    "kind" : "function",
    "line" : 488,
    "endline" : 524
   },
   {
    "name" : "Service",
    "kind" : "class",
    "comment" : "\n $(D Service) is a class for retrieving service information.\n\n Example:\n ---\n auto serv = new Service;\n writeln(\"About service epmap:\");\n if (serv.getServiceByName(\"epmap\", \"tcp\"))\n {\n     writefln(\"  Service: %s\", serv.name);\n     writefln(\"  Port: %d\", serv.port);\n     writefln(\"  Protocol: %s\", serv.protocolName);\n     foreach (string s; serv.aliases)\n          writefln(\"  Alias: %s\", s);\n }\n else\n     writefln(\"  No service for epmap.\");\n ---\n \n",
    "line" : 525,
    "members" : [
     {
      "name" : "name",
      "kind" : "variable",
      "comment" : " These members are populated when one of the following functions are called successfully:\n",
      "line" : 527,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "aliases",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 528,
      "deco" : "AAya",
      "offset" : 32
     },
     {
      "name" : "port",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 529,
      "deco" : "t",
      "offset" : 48
     },
     {
      "name" : "protocolName",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 530,
      "deco" : "Aya",
      "offset" : 56
     },
     {
      "name" : "populate",
      "kind" : "function",
      "line" : 533,
      "deco" : "FPS4core3sys5posix5netdb7serventZv",
      "parameters" : [
       {
        "name" : "serv",
        "deco" : "PS4core3sys5posix5netdb7servent"
       }
      ],
      "endline" : 559
     },
     {
      "name" : "getServiceByName",
      "kind" : "function",
      "comment" : "\n If a protocol name is omitted, any protocol will be matched.\n Returns: false on failure.\n     \n",
      "line" : 565,
      "deco" : "FxAaxAaZb",
      "originalType" : "bool(in char[] name, in char[] protocolName = null)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "xAa"
       },
       {
        "name" : "protocolName",
        "deco" : "xAa",
        "default" : "null"
       }
      ],
      "endline" : 573
     },
     {
      "name" : "getServiceByPort",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 577,
      "deco" : "FtxAaZb",
      "originalType" : "bool(ushort port, in char[] protocolName = null)",
      "parameters" : [
       {
        "name" : "port",
        "deco" : "t"
       },
       {
        "name" : "protocolName",
        "deco" : "xAa",
        "default" : "null"
       }
      ],
      "endline" : 585
     }
    ]
   },
   {
    "name" : "__unittestL589_1550",
    "kind" : "function",
    "line" : 589,
    "endline" : 619
   },
   {
    "name" : "HostException",
    "kind" : "class",
    "comment" : "\n Class for exceptions thrown from an $(D InternetHost).\n \n",
    "line" : 619,
    "base" : "SocketOSException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 622,
      "deco" : "FAyaAyamC6object9ThrowableiZC3std6socket13HostException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       }
      ],
      "endline" : 625
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 628,
      "deco" : "FAyaC6object9ThrowableAyamiZC3std6socket13HostException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       }
      ],
      "endline" : 631
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 634,
      "deco" : "FAyaiAyamC6object9ThrowableZC3std6socket13HostException",
      "originalType" : "(string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "err",
        "deco" : "i"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 637
     }
    ]
   },
   {
    "name" : "InternetHost",
    "kind" : "class",
    "comment" : "\n $(D InternetHost) is a class for resolving IPv4 addresses.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n\n Example:\n ---\n auto ih = new InternetHost;\n\n // Forward lookup\n writeln(\"About www.digitalmars.com:\");\n if (ih.getHostByName(\"www.digitalmars.com\"))\n {\n     writefln(\"  Name: %s\", ih.name);\n     auto ip = InternetAddress.addrToString(ih.addrList[0]);\n     writefln(\"  IP address: %s\", ip);\n     foreach (string s; ih.aliases)\n          writefln(\"  Alias: %s\", s);\n     writeln(\"---\");\n\n     // Reverse lookup\n     writefln(\"About IP %s:\", ip);\n     if (ih.getHostByAddr(ih.addrList[0]))\n     {\n         writefln(\"  Name: %s\", ih.name);\n         foreach (string s; ih.aliases)\n              writefln(\"  Alias: %s\", s);\n     }\n     else\n         writeln(\"  Reverse lookup failed\");\n }\n else\n     writeln(\"  Can't resolve www.digitalmars.com\");\n ---\n \n",
    "line" : 677,
    "members" : [
     {
      "name" : "name",
      "kind" : "variable",
      "comment" : " These members are populated when one of the following functions are called successfully:\n",
      "line" : 679,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "aliases",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 680,
      "deco" : "AAya",
      "offset" : 32
     },
     {
      "name" : "addrList",
      "kind" : "variable",
      "comment" : " ditto\n",
      "line" : 681,
      "deco" : "Ak",
      "offset" : 48
     },
     {
      "name" : "validHostent",
      "kind" : "function",
      "line" : 684,
      "deco" : "FPS4core3sys5posix5netdb7hostentZv",
      "parameters" : [
       {
        "name" : "he",
        "deco" : "PS4core3sys5posix5netdb7hostent"
       }
      ],
      "endline" : 688
     },
     {
      "name" : "populate",
      "kind" : "function",
      "line" : 691,
      "deco" : "FPS4core3sys5posix5netdb7hostentZv",
      "parameters" : [
       {
        "name" : "he",
        "deco" : "PS4core3sys5posix5netdb7hostent"
       }
      ],
      "endline" : 738
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 740,
      "name" : "getHostNoSync",
      "parameters" : [
       {
        "name" : "opMixin",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "getHostNoSync",
        "kind" : "function",
        "line" : 740,
        "type" : "bool(T param)",
        "parameters" : [
         {
          "name" : "param",
          "type" : "T"
         }
        ],
        "endline" : 748
       }
      ]
     },
     {
      "kind" : "template",
      "protection" : "private",
      "line" : 756,
      "name" : "getHost",
      "parameters" : [
       {
        "name" : "opMixin",
        "kind" : "value",
        "deco" : "Aya"
       },
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "getHost",
        "kind" : "function",
        "line" : 756,
        "type" : "bool(T param)",
        "parameters" : [
         {
          "name" : "param",
          "type" : "T"
         }
        ],
        "endline" : 760
       }
      ]
     },
     {
      "name" : "getHostByName",
      "kind" : "function",
      "comment" : "\n Resolve host name.\n Returns: false if unable to resolve.\n     \n",
      "line" : 767,
      "deco" : "FxAaZb",
      "originalType" : "bool(in char[] name)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "xAa"
       }
      ],
      "endline" : 794
     },
     {
      "name" : "getHostByAddr",
      "kind" : "function",
      "comment" : "\n Resolve IPv4 address number.\n\n Params:\n   addr = The IPv4 address to resolve, in host byte order.\n Returns:\n   false if unable to resolve.\n     \n",
      "line" : 804,
      "deco" : "FkZb",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "k"
       }
      ],
      "endline" : 810
     },
     {
      "name" : "getHostByAddr",
      "kind" : "function",
      "comment" : "\n Same as previous, but addr is an IPv4 address string in the\n dotted-decimal form $(I a.b.c.d).\n Returns: false if unable to resolve.\n     \n",
      "line" : 817,
      "deco" : "FxAaZb",
      "originalType" : "bool(in char[] addr)",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "xAa"
       }
      ],
      "endline" : 825
     }
    ]
   },
   {
    "name" : "__unittestL829_1552",
    "kind" : "function",
    "line" : 829,
    "endline" : 865
   },
   {
    "name" : "AddressInfo",
    "kind" : "struct",
    "comment" : " Holds information about a socket _address retrieved by $(D getAddressInfo).\n",
    "line" : 866,
    "members" : [
     {
      "name" : "family",
      "kind" : "variable",
      "comment" : " Address _family\n",
      "line" : 867,
      "deco" : "E3std6socket13AddressFamily",
      "offset" : 0
     },
     {
      "name" : "type",
      "kind" : "variable",
      "comment" : " Socket _type\n",
      "line" : 868,
      "deco" : "E3std6socket10SocketType",
      "offset" : 4
     },
     {
      "name" : "protocol",
      "kind" : "variable",
      "comment" : " Protocol\n",
      "line" : 869,
      "deco" : "E3std6socket12ProtocolType",
      "offset" : 8
     },
     {
      "name" : "address",
      "kind" : "variable",
      "comment" : " Socket _address\n",
      "line" : 870,
      "deco" : "C3std6socket7Address",
      "originalType" : "Address",
      "offset" : 16
     },
     {
      "name" : "canonicalName",
      "kind" : "variable",
      "comment" : " Canonical name, when $(D AddressInfoFlags.CANONNAME) is used.\n",
      "line" : 871,
      "deco" : "Aya",
      "offset" : 24
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std6socket11AddressInfoKxS3std6socket11AddressInfoZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std6socket11AddressInfo",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std6socket11AddressInfo",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "AddressInfoFlags",
    "kind" : "enum",
    "comment" : " Specifies option flags for $(D getAddressInfo).\n",
    "line" : 876,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "PASSIVE",
      "kind" : "enum member",
      "comment" : " The resulting addresses will be used in a call to $(D Socket.bind).\n",
      "line" : 879
     },
     {
      "name" : "CANONNAME",
      "kind" : "enum member",
      "comment" : " The canonical name is returned in $(D canonicalName) member in the first $(D AddressInfo).\n",
      "line" : 882
     },
     {
      "name" : "NUMERICHOST",
      "kind" : "enum member",
      "comment" : " The $(D node) parameter passed to $(D getAddressInfo) must be a numeric string.\n This will suppress any potentially lengthy network host address lookups.\n",
      "line" : 886
     }
    ]
   },
   {
    "name" : "formatGaiError",
    "kind" : "function",
    "protection" : "private",
    "comment" : " On POSIX, getaddrinfo uses its own error codes, and thus has its own\n formatting function.\n",
    "line" : 892,
    "deco" : "FiZAya",
    "parameters" : [
     {
      "name" : "err",
      "deco" : "i"
     }
    ],
    "endline" : 903
   },
   {
    "kind" : "template",
    "comment" : "\n Provides _protocol-independent translation from host names to socket\n addresses. If advanced functionality is not required, consider using\n $(D getAddress) for compatibility with older systems.\n\n Returns: Array with one $(D AddressInfo) per socket address.\n\n Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)\n if this functionality is not available on the current system.\n\n Params:\n  node     = string containing host name or numeric address\n  options  = optional additional parameters, identified by type:\n             $(UL $(LI $(D string) - service name or port number)\n                  $(LI $(D AddressInfoFlags) - option flags)\n                  $(LI $(D AddressFamily) - address family to filter by)\n                  $(LI $(D SocketType) - socket type to filter by)\n                  $(LI $(D ProtocolType) - protocol to filter by))\n\n Example:\n ---\n // Roundtrip DNS resolution\n auto results = getAddressInfo(\"www.digitalmars.com\");\n assert(results[0].address.toHostNameString() ==\n     \"digitalmars.com\");\n\n // Canonical name\n results = getAddressInfo(\"www.digitalmars.com\",\n     AddressInfoFlags.CANONNAME);\n assert(results[0].canonicalName == \"digitalmars.com\");\n\n // IPv6 resolution\n results = getAddressInfo(\"ipv6.google.com\");\n assert(results[0].family == AddressFamily.INET6);\n\n // Multihomed resolution\n results = getAddressInfo(\"google.com\");\n assert(results.length > 1);\n\n // Parsing IPv4\n results = getAddressInfo(\"127.0.0.1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET);\n\n // Parsing IPv6\n results = getAddressInfo(\"::1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET6);\n ---\n \n",
    "line" : 957,
    "name" : "getAddressInfo",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "getAddressInfo",
      "kind" : "function",
      "comment" : "\n Provides _protocol-independent translation from host names to socket\n addresses. If advanced functionality is not required, consider using\n $(D getAddress) for compatibility with older systems.\n\n Returns: Array with one $(D AddressInfo) per socket address.\n\n Throws: $(D SocketOSException) on failure, or $(D SocketFeatureException)\n if this functionality is not available on the current system.\n\n Params:\n  node     = string containing host name or numeric address\n  options  = optional additional parameters, identified by type:\n             $(UL $(LI $(D string) - service name or port number)\n                  $(LI $(D AddressInfoFlags) - option flags)\n                  $(LI $(D AddressFamily) - address family to filter by)\n                  $(LI $(D SocketType) - socket type to filter by)\n                  $(LI $(D ProtocolType) - protocol to filter by))\n\n Example:\n ---\n // Roundtrip DNS resolution\n auto results = getAddressInfo(\"www.digitalmars.com\");\n assert(results[0].address.toHostNameString() ==\n     \"digitalmars.com\");\n\n // Canonical name\n results = getAddressInfo(\"www.digitalmars.com\",\n     AddressInfoFlags.CANONNAME);\n assert(results[0].canonicalName == \"digitalmars.com\");\n\n // IPv6 resolution\n results = getAddressInfo(\"ipv6.google.com\");\n assert(results[0].family == AddressFamily.INET6);\n\n // Multihomed resolution\n results = getAddressInfo(\"google.com\");\n assert(results.length > 1);\n\n // Parsing IPv4\n results = getAddressInfo(\"127.0.0.1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET);\n\n // Parsing IPv6\n results = getAddressInfo(\"::1\",\n     AddressInfoFlags.NUMERICHOST);\n assert(results.length && results[0].family ==\n     AddressFamily.INET6);\n ---\n \n",
      "line" : 957,
      "type" : "AddressInfo[](in char[] node, T options)",
      "parameters" : [
       {
        "name" : "node",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "options",
        "type" : "T"
       }
      ],
      "endline" : 984
     }
    ]
   },
   {
    "name" : "getAddressInfoImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 986,
    "deco" : "FxAaxAaPS4core3sys5posix5netdb8addrinfoZAS3std6socket11AddressInfo",
    "originalType" : "AddressInfo[](in char[] node, in char[] service, addrinfo* hints)",
    "parameters" : [
     {
      "name" : "node",
      "deco" : "xAa"
     },
     {
      "name" : "service",
      "deco" : "xAa"
     },
     {
      "name" : "hints",
      "deco" : "PS4core3sys5posix5netdb8addrinfo"
     }
    ],
    "endline" : 1015
   },
   {
    "name" : "__unittestL1018_1554",
    "kind" : "function",
    "line" : 1018,
    "endline" : 1052
   },
   {
    "name" : "serviceToPort",
    "kind" : "function",
    "protection" : "private",
    "line" : 1052,
    "deco" : "FxAaZt",
    "originalType" : "ushort(in char[] service)",
    "parameters" : [
     {
      "name" : "service",
      "deco" : "xAa"
     }
    ],
    "endline" : 1065
   },
   {
    "name" : "getAddress",
    "kind" : "function",
    "comment" : "\n Provides _protocol-independent translation from host names to socket\n addresses. Uses $(D getAddressInfo) if the current system supports it,\n and $(D InternetHost) otherwise.\n\n Returns: Array with one $(D Address) instance per socket address.\n\n Throws: $(D SocketOSException) on failure.\n\n Example:\n ---\n writeln(\"Resolving www.digitalmars.com:\");\n try\n {\n     auto addresses = getAddress(\"www.digitalmars.com\");\n     foreach (address; addresses)\n         writefln(\"  IP: %s\", address.toAddrString());\n }\n catch (SocketException e)\n     writefln(\"  Lookup failed: %s\", e.msg);\n ---\n \n",
    "line" : 1089,
    "deco" : "FxAaxAaZAC3std6socket7Address",
    "originalType" : "Address[](in char[] hostname, in char[] service = null)",
    "parameters" : [
     {
      "name" : "hostname",
      "deco" : "xAa"
     },
     {
      "name" : "service",
      "deco" : "xAa",
      "default" : "null"
     }
    ],
    "endline" : 1102
   },
   {
    "name" : "getAddress",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1105,
    "deco" : "FxAatZAC3std6socket7Address",
    "originalType" : "Address[](in char[] hostname, ushort port)",
    "parameters" : [
     {
      "name" : "hostname",
      "deco" : "xAa"
     },
     {
      "name" : "port",
      "deco" : "t"
     }
    ],
    "endline" : 1122
   },
   {
    "name" : "__unittestL1125_1556",
    "kind" : "function",
    "line" : 1125,
    "endline" : 1182
   },
   {
    "name" : "parseAddress",
    "kind" : "function",
    "comment" : "\n Provides _protocol-independent parsing of network addresses. Does not\n attempt name resolution. Uses $(D getAddressInfo) with\n $(D AddressInfoFlags.NUMERICHOST) if the current system supports it, and\n $(D InternetAddress) otherwise.\n\n Returns: An $(D Address) instance representing specified address.\n\n Throws: $(D SocketException) on failure.\n\n Example:\n ---\n writeln(\"Enter IP address:\");\n string ip = readln().chomp();\n try\n {\n     Address address = parseAddress(ip);\n     writefln(\"Looking up reverse of %s:\",\n         address.toAddrString());\n     try\n     {\n         string reverse = address.toHostNameString();\n         if (reverse)\n             writefln(\"  Reverse name: %s\", reverse);\n         else\n             writeln(\"  Reverse hostname not found.\");\n     }\n     catch (SocketException e)\n         writefln(\"  Lookup error: %s\", e.msg);\n }\n catch (SocketException e)\n {\n     writefln(\"  %s is not a valid IP address: %s\",\n         ip, e.msg);\n }\n ---\n \n",
    "line" : 1182,
    "deco" : "FxAaxAaZC3std6socket7Address",
    "originalType" : "Address(in char[] hostaddr, in char[] service = null)",
    "parameters" : [
     {
      "name" : "hostaddr",
      "deco" : "xAa"
     },
     {
      "name" : "service",
      "deco" : "xAa",
      "default" : "null"
     }
    ],
    "endline" : 1188
   },
   {
    "name" : "parseAddress",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1191,
    "deco" : "FxAatZC3std6socket7Address",
    "originalType" : "Address(in char[] hostaddr, ushort port)",
    "parameters" : [
     {
      "name" : "hostaddr",
      "deco" : "xAa"
     },
     {
      "name" : "port",
      "deco" : "t"
     }
    ],
    "endline" : 1202
   },
   {
    "name" : "__unittestL1205_1558",
    "kind" : "function",
    "line" : 1205,
    "endline" : 1230
   },
   {
    "name" : "AddressException",
    "kind" : "class",
    "comment" : "\n Class for exceptions thrown from an $(D Address).\n \n",
    "line" : 1230,
    "base" : "SocketOSException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 1233,
      "deco" : "FAyaAyamC6object9ThrowableiZC3std6socket16AddressException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       }
      ],
      "endline" : 1236
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 1239,
      "deco" : "FAyaC6object9ThrowableAyamiZC3std6socket16AddressException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       }
      ],
      "endline" : 1242
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 1245,
      "deco" : "FAyaiAyamC6object9ThrowableZC3std6socket16AddressException",
      "originalType" : "(string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "err",
        "deco" : "i"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 1248
     }
    ]
   },
   {
    "name" : "Address",
    "kind" : "class",
    "comment" : "\n $(D Address) is an abstract class for representing a socket addresses.\n\n Example:\n ---\n writeln(\"About www.google.com port 80:\");\n try\n {\n     Address[] addresses = getAddress(\"www.google.com\", 80);\n     writefln(\"  %d addresses found.\", addresses.length);\n     foreach (int i, Address a; addresses)\n     {\n         writefln(\"  Address %d:\", i+1);\n         writefln(\"    IP address: %s\", a.toAddrString());\n         writefln(\"    Hostname: %s\", a.toHostNameString());\n         writefln(\"    Port: %s\", a.toPortString());\n         writefln(\"    Service name: %s\",\n             a.toServiceNameString());\n     }\n }\n catch (SocketException e)\n     writefln(\"  Lookup error: %s\", e.msg);\n ---\n \n",
    "line" : 1277,
    "members" : [
     {
      "name" : "name",
      "kind" : "function",
      "comment" : " Returns pointer to underlying $(D sockaddr) structure.\n",
      "line" : 1279,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "FNdZPS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "sockaddr*()"
     },
     {
      "name" : "name",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1280,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "xFNdZPxS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "const const(sockaddr)*()"
     },
     {
      "name" : "nameLen",
      "kind" : "function",
      "comment" : " Returns actual size of underlying $(D sockaddr) structure.\n",
      "line" : 1283,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const socklen_t()"
     },
     {
      "name" : "addressFamily",
      "kind" : "function",
      "comment" : " Family of this address.\n",
      "line" : 1286,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZE3std6socket13AddressFamily",
      "originalType" : "const AddressFamily()",
      "endline" : 1289
     },
     {
      "name" : "toHostString",
      "kind" : "function",
      "protection" : "private",
      "line" : 1292,
      "storageClass" : [
       "final"
      ],
      "deco" : "xFbZAya",
      "parameters" : [
       {
        "name" : "numeric",
        "deco" : "b"
       }
      ],
      "endline" : 1329
     },
     {
      "name" : "toServiceString",
      "kind" : "function",
      "protection" : "private",
      "line" : 1332,
      "storageClass" : [
       "final"
      ],
      "deco" : "xFbZAya",
      "parameters" : [
       {
        "name" : "numeric",
        "deco" : "b"
       }
      ],
      "endline" : 1350
     },
     {
      "name" : "toAddrString",
      "kind" : "function",
      "comment" : "\n Attempts to retrieve the host address as a human-readable string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if address retrieval for this address family is not available on the\n current system.\n     \n",
      "line" : 1359,
      "deco" : "xFZAya",
      "endline" : 1362
     },
     {
      "name" : "toHostNameString",
      "kind" : "function",
      "comment" : "\n Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D Address), or $(D null) if\n the host name did not resolve.\n\n Throws: $(D AddressException) on error, or $(D SocketFeatureException)\n if host name lookup for this address family is not available on the\n current system.\n     \n",
      "line" : 1374,
      "deco" : "xFZAya",
      "endline" : 1377
     },
     {
      "name" : "toPortString",
      "kind" : "function",
      "comment" : "\n Attempts to retrieve the numeric port number as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if port number retrieval for this address family is not available on the\n current system.\n     \n",
      "line" : 1386,
      "deco" : "xFZAya",
      "endline" : 1389
     },
     {
      "name" : "toServiceNameString",
      "kind" : "function",
      "comment" : "\n Attempts to retrieve the service name as a string.\n\n Throws: $(D AddressException) on failure, or $(D SocketFeatureException)\n if service name lookup for this address family is not available on the\n current system.\n     \n",
      "line" : 1398,
      "deco" : "xFZAya",
      "endline" : 1401
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : " Human readable string representing this address.\n",
      "line" : 1404,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFZAya",
      "endline" : 1417,
      "overrides" : [
       "object.Object.toString"
      ]
     }
    ]
   },
   {
    "name" : "UnknownAddress",
    "kind" : "class",
    "comment" : "\n $(D UnknownAddress) encapsulates an unknown socket address.\n \n",
    "line" : 1423,
    "base" : "Address",
    "members" : [
     {
      "name" : "sa",
      "kind" : "variable",
      "protection" : "protected",
      "line" : 1426,
      "deco" : "S4core3sys5posix3sys6socket8sockaddr",
      "offset" : 16
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1430,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZPS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "sockaddr*()",
      "endline" : 1433,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1435,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZPxS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "const const(sockaddr)*()",
      "endline" : 1438,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "nameLen",
      "kind" : "function",
      "line" : 1441,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const socklen_t()",
      "endline" : 1444,
      "overrides" : [
       "std.socket.Address.nameLen"
      ]
     }
    ]
   },
   {
    "name" : "UnknownAddressReference",
    "kind" : "class",
    "comment" : "\n $(D UnknownAddressReference) encapsulates a reference to an arbitrary\n socket address.\n \n",
    "line" : 1453,
    "base" : "Address",
    "members" : [
     {
      "name" : "sa",
      "kind" : "variable",
      "protection" : "protected",
      "line" : 1456,
      "deco" : "PS4core3sys5posix3sys6socket8sockaddr",
      "offset" : 16
     },
     {
      "name" : "len",
      "kind" : "variable",
      "protection" : "protected",
      "line" : 1457,
      "deco" : "k",
      "originalType" : "socklen_t",
      "offset" : 24
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs an $(D Address) with a reference to the specified $(D sockaddr).\n",
      "line" : 1461,
      "deco" : "FPS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference",
      "originalType" : "(sockaddr* sa, socklen_t len)",
      "parameters" : [
       {
        "name" : "sa",
        "deco" : "PS4core3sys5posix3sys6socket8sockaddr"
       },
       {
        "name" : "len",
        "deco" : "k"
       }
      ],
      "endline" : 1465
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs an $(D Address) with a copy of the specified $(D sockaddr).\n",
      "line" : 1468,
      "deco" : "FPxS4core3sys5posix3sys6socket8sockaddrkZC3std6socket23UnknownAddressReference",
      "originalType" : "(const(sockaddr)* sa, socklen_t len)",
      "parameters" : [
       {
        "name" : "sa",
        "deco" : "PxS4core3sys5posix3sys6socket8sockaddr"
       },
       {
        "name" : "len",
        "deco" : "k"
       }
      ],
      "endline" : 1472
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1474,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZPS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "sockaddr*()",
      "endline" : 1477,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1479,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZPxS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "const const(sockaddr)*()",
      "endline" : 1482,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "nameLen",
      "kind" : "function",
      "line" : 1485,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const socklen_t()",
      "endline" : 1488,
      "overrides" : [
       "std.socket.Address.nameLen"
      ]
     }
    ]
   },
   {
    "name" : "InternetAddress",
    "kind" : "class",
    "comment" : "\n $(D InternetAddress) encapsulates an IPv4 (Internet Protocol version 4)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n \n",
    "line" : 1499,
    "base" : "Address",
    "members" : [
     {
      "name" : "sin",
      "kind" : "variable",
      "protection" : "protected",
      "line" : 1502,
      "deco" : "S4core3sys5posix7netinet3in_11sockaddr_in",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "protected",
      "line" : 1505,
      "deco" : "FZC3std6socket15InternetAddress",
      "originalType" : "()",
      "endline" : 1507
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1511,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZPS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "sockaddr*()",
      "endline" : 1514,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1516,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZPxS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "const const(sockaddr)*()",
      "endline" : 1519,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "nameLen",
      "kind" : "function",
      "line" : 1522,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const socklen_t()",
      "endline" : 1525,
      "overrides" : [
       "std.socket.Address.nameLen"
      ]
     },
     {
      "name" : "ADDR_ANY",
      "kind" : "variable",
      "comment" : " Any IPv4 host address.\n",
      "line" : 1528,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "0u"
     },
     {
      "name" : "ADDR_NONE",
      "kind" : "variable",
      "comment" : " An invalid IPv4 host address.\n",
      "line" : 1529,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "4294967295u"
     },
     {
      "name" : "PORT_ANY",
      "kind" : "variable",
      "comment" : " Any IPv4 port number.\n",
      "line" : 1530,
      "storageClass" : [
       "enum"
      ],
      "deco" : "t",
      "init" : "cast(ushort)0u"
     },
     {
      "name" : "port",
      "kind" : "function",
      "comment" : " Returns the IPv4 _port number (in host byte order).\n",
      "line" : 1533,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZt",
      "originalType" : "const ushort()",
      "endline" : 1536
     },
     {
      "name" : "addr",
      "kind" : "function",
      "comment" : " Returns the IPv4 address number (in host byte order).\n",
      "line" : 1539,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const uint()",
      "endline" : 1542
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a new $(D InternetAddress).\n Params:\n   addr = an IPv4 address string in the dotted-decimal form a.b.c.d,\n          or a host name which will be resolved using an $(D InternetHost)\n          object.\n   port = port number, may be $(D PORT_ANY).\n     \n",
      "line" : 1552,
      "deco" : "FxAatZC3std6socket15InternetAddress",
      "originalType" : "(in char[] addr, ushort port)",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "xAa"
       },
       {
        "name" : "port",
        "deco" : "t"
       }
      ],
      "endline" : 1567
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a new $(D InternetAddress).\n Params:\n   addr = (optional) an IPv4 address in host byte order, may be $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n     \n",
      "line" : 1575,
      "deco" : "FktZC3std6socket15InternetAddress",
      "originalType" : "(uint addr, ushort port)",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "k"
       },
       {
        "name" : "port",
        "deco" : "t"
       }
      ],
      "endline" : 1580
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 1583,
      "deco" : "FtZC3std6socket15InternetAddress",
      "originalType" : "(ushort port)",
      "parameters" : [
       {
        "name" : "port",
        "deco" : "t"
       }
      ],
      "endline" : 1588
     },
     {
      "name" : "toAddrString",
      "kind" : "function",
      "comment" : " Human readable string representing the IPv4 address in dotted-decimal form.\n",
      "line" : 1591,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFZAya",
      "endline" : 1594,
      "overrides" : [
       "std.socket.Address.toAddrString"
      ]
     },
     {
      "name" : "toPortString",
      "kind" : "function",
      "comment" : " Human readable string representing the IPv4 port.\n",
      "line" : 1597,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFZAya",
      "endline" : 1600,
      "overrides" : [
       "std.socket.Address.toPortString"
      ]
     },
     {
      "name" : "toHostNameString",
      "kind" : "function",
      "comment" : "\n Attempts to retrieve the host name as a fully qualified domain name.\n\n Returns: The FQDN corresponding to this $(D InternetAddress), or\n $(D null) if the host name did not resolve.\n\n Throws: $(D AddressException) on error.\n     \n",
      "line" : 1610,
      "storageClass" : [
       "override"
      ],
      "deco" : "xFZAya",
      "endline" : 1629,
      "overrides" : [
       "std.socket.Address.toHostNameString"
      ]
     },
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\n Parse an IPv4 address string in the dotted-decimal form $(I a.b.c.d)\n and return the number.\n Returns: If the string is not a legitimate IPv4 address,\n $(D ADDR_NONE) is returned.\n     \n",
      "line" : 1637,
      "storageClass" : [
       "static"
      ],
      "deco" : "FxAaZk",
      "originalType" : "uint(in char[] addr)",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "xAa"
       }
      ],
      "endline" : 1640
     },
     {
      "name" : "addrToString",
      "kind" : "function",
      "comment" : "\n Convert an IPv4 address number in host byte order to a human readable\n string representing the IPv4 address in dotted-decimal form.\n     \n",
      "line" : 1646,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkZAya",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "k"
       }
      ],
      "endline" : 1651
     }
    ]
   },
   {
    "name" : "__unittestL1655_1562",
    "kind" : "function",
    "line" : 1655,
    "endline" : 1708
   },
   {
    "name" : "Internet6Address",
    "kind" : "class",
    "comment" : "\n $(D Internet6Address) encapsulates an IPv6 (Internet Protocol version 6)\n socket address.\n\n Consider using $(D getAddress), $(D parseAddress) and $(D Address) methods\n instead of using this class directly.\n \n",
    "line" : 1708,
    "base" : "Address",
    "members" : [
     {
      "name" : "sin6",
      "kind" : "variable",
      "protection" : "protected",
      "line" : 1711,
      "deco" : "S4core3sys5posix7netinet3in_12sockaddr_in6",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "protected",
      "line" : 1714,
      "deco" : "FZC3std6socket16Internet6Address",
      "originalType" : "()",
      "endline" : 1716
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1720,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZPS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "sockaddr*()",
      "endline" : 1723,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "name",
      "kind" : "function",
      "line" : 1725,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZPxS4core3sys5posix3sys6socket8sockaddr",
      "originalType" : "const const(sockaddr)*()",
      "endline" : 1728,
      "overrides" : [
       "std.socket.Address.name"
      ]
     },
     {
      "name" : "nameLen",
      "kind" : "function",
      "line" : 1731,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const socklen_t()",
      "endline" : 1734,
      "overrides" : [
       "std.socket.Address.nameLen"
      ]
     },
     {
      "name" : "ADDR_ANY",
      "kind" : "function",
      "comment" : " Any IPv6 host address.\n",
      "line" : 1738,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNcNdZxG16h",
      "originalType" : "const(ubyte)[16]()",
      "endline" : 1748
     },
     {
      "name" : "PORT_ANY",
      "kind" : "variable",
      "comment" : " Any IPv6 port number.\n",
      "line" : 1751,
      "storageClass" : [
       "enum"
      ],
      "deco" : "t",
      "init" : "cast(ushort)0u"
     },
     {
      "name" : "port",
      "kind" : "function",
      "comment" : " Returns the IPv6 port number.\n",
      "line" : 1754,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZt",
      "originalType" : "const ushort()",
      "endline" : 1757
     },
     {
      "name" : "addr",
      "kind" : "function",
      "comment" : " Returns the IPv6 address.\n",
      "line" : 1760,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZG16h",
      "originalType" : "const ubyte[16]()",
      "endline" : 1763
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a new $(D Internet6Address).\n Params:\n   node = an IPv6 host address string in the form described in RFC 2373,\n          or a host name which will be resolved using $(D getAddressInfo).\n   port = (optional) service name or port number.\n     \n",
      "line" : 1772,
      "deco" : "FxAaxAaZC3std6socket16Internet6Address",
      "originalType" : "(in char[] node, in char[] service = null)",
      "parameters" : [
       {
        "name" : "node",
        "deco" : "xAa"
       },
       {
        "name" : "service",
        "deco" : "xAa",
        "default" : "null"
       }
      ],
      "endline" : 1777
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a new $(D Internet6Address).\n Params:\n   addr = an IPv6 host address string in the form described in RFC 2373,\n          or a host name which will be resolved using $(D getAddressInfo).\n   port = port number, may be $(D PORT_ANY).\n     \n",
      "line" : 1786,
      "deco" : "FxAatZC3std6socket16Internet6Address",
      "originalType" : "(in char[] node, ushort port)",
      "parameters" : [
       {
        "name" : "node",
        "deco" : "xAa"
       },
       {
        "name" : "port",
        "deco" : "t"
       }
      ],
      "endline" : 1792
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a new $(D Internet6Address).\n Params:\n   addr = (optional) an IPv6 host address in host byte order, or\n                $(D ADDR_ANY).\n   port = port number, may be $(D PORT_ANY).\n     \n",
      "line" : 1801,
      "deco" : "FG16htZC3std6socket16Internet6Address",
      "originalType" : "(ubyte[16] addr, ushort port)",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "G16h"
       },
       {
        "name" : "port",
        "deco" : "t"
       }
      ],
      "endline" : 1806
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 1809,
      "deco" : "FtZC3std6socket16Internet6Address",
      "originalType" : "(ushort port)",
      "parameters" : [
       {
        "name" : "port",
        "deco" : "t"
       }
      ],
      "endline" : 1814
     },
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\n Parse an IPv6 host address string as described in RFC 2373, and return the\n address.\n Throws: $(D SocketException) on error.\n     \n",
      "line" : 1821,
      "storageClass" : [
       "static"
      ],
      "deco" : "FxAaZG16h",
      "originalType" : "ubyte[16](in char[] addr)",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "xAa"
       }
      ],
      "endline" : 1830
     }
    ]
   },
   {
    "name" : "__unittestL1834_1564",
    "kind" : "function",
    "line" : 1834,
    "endline" : 1843
   },
   {
    "name" : "SocketAcceptException",
    "kind" : "class",
    "comment" : "\n Class for exceptions thrown by $(D Socket.accept).\n \n",
    "line" : 1919,
    "base" : "SocketOSException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 1922,
      "deco" : "FAyaAyamC6object9ThrowableiZC3std6socket21SocketAcceptException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null, int err = _lasterr())",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       }
      ],
      "endline" : 1925
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 1928,
      "deco" : "FAyaC6object9ThrowableAyamiZC3std6socket21SocketAcceptException",
      "originalType" : "(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__, int err = _lasterr())",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "err",
        "deco" : "i",
        "default" : "_lasterr()"
       }
      ],
      "endline" : 1931
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n",
      "line" : 1934,
      "deco" : "FAyaiAyamC6object9ThrowableZC3std6socket21SocketAcceptException",
      "originalType" : "(string msg, int err, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "err",
        "deco" : "i"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 1937
     }
    ]
   },
   {
    "name" : "SocketShutdown",
    "kind" : "enum",
    "comment" : " How a socket is shutdown:\n",
    "line" : 1941,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "RECEIVE",
      "kind" : "enum member",
      "comment" : " socket receives are disallowed\n",
      "line" : 1943
     },
     {
      "name" : "SEND",
      "kind" : "enum member",
      "comment" : " socket sends are disallowed\n",
      "line" : 1944
     },
     {
      "name" : "BOTH",
      "kind" : "enum member",
      "comment" : " both RECEIVE and SEND\n",
      "line" : 1945
     }
    ]
   },
   {
    "name" : "SocketFlags",
    "kind" : "enum",
    "comment" : " Flags may be OR'ed together:\n",
    "line" : 1950,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "NONE",
      "kind" : "enum member",
      "comment" : " no flags specified\n",
      "line" : 1952
     },
     {
      "name" : "OOB",
      "kind" : "enum member",
      "comment" : " out-of-band stream data\n",
      "line" : 1954
     },
     {
      "name" : "PEEK",
      "kind" : "enum member",
      "comment" : " peek at incoming data without removing it from the queue, only for receiving\n",
      "line" : 1955
     },
     {
      "name" : "DONTROUTE",
      "kind" : "enum member",
      "comment" : " data should not be subject to routing; this flag may be ignored. Only for sending\n",
      "line" : 1956
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1960,
    "name" : "FieldProxy",
    "parameters" : [
     {
      "name" : "target",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "field",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : []
   },
   {
    "name" : "TimeVal",
    "kind" : "struct",
    "comment" : " Duration timeout value.\n",
    "line" : 1979,
    "members" : [
     {
      "name" : "ctimeval",
      "kind" : "variable",
      "line" : 1980,
      "deco" : "S4core3sys5posix3sys4time7timeval",
      "originalType" : "_ctimeval",
      "offset" : 0
     },
     {
      "name" : "tv_sec_t",
      "kind" : "alias",
      "line" : 1981,
      "deco" : "l"
     },
     {
      "name" : "tv_usec_t",
      "kind" : "alias",
      "line" : 1982,
      "deco" : "l"
     },
     {
      "name" : "FieldProxy!(\"ctimeval.tv_sec\", \"seconds\")",
      "kind" : "mixin",
      "line" : 1992
     },
     {
      "name" : "FieldProxy!(\"ctimeval.tv_usec\", \"microseconds\")",
      "kind" : "mixin",
      "line" : 1993
     }
    ]
   },
   {
    "name" : "timeval",
    "kind" : "alias",
    "line" : 1998,
    "storageClass" : [
     "deprecated"
    ],
    "deco" : "S3std6socket7TimeVal"
   },
   {
    "name" : "SocketSet",
    "kind" : "class",
    "comment" : "\n A collection of sockets for use with $(D Socket.select).\n\n $(D SocketSet) allows specifying the capacity of the underlying\n $(D fd_set), however users should be aware that the exact meaning of this\n value varies depending on the current platform:\n $(UL $(LI On POSIX, $(D fd_set) is a bit array of file descriptors. The\n $(D SocketSet) capacity specifies the highest file descriptor which can be\n stored in the set.)\n $(LI on Windows, $(D fd_set) is an array of socket handles. Capacity\n indicates the actual number of sockets that can be stored in the set.))\n \n",
    "line" : 2014,
    "members" : [
     {
      "name" : "fdsetMax",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2026,
      "deco" : "i",
      "offset" : 16
     },
     {
      "name" : "setData",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2028,
      "deco" : "S4core3sys5posix3sys6select6fd_set",
      "offset" : 24
     },
     {
      "name" : "set",
      "kind" : "function",
      "protection" : "private",
      "line" : 2029,
      "storageClass" : [
       "final",
       "@property"
      ],
      "deco" : "FNdZPS4core3sys5posix3sys6select6fd_set",
      "originalType" : "fd_set*()",
      "endline" : 2029
     },
     {
      "name" : "set",
      "kind" : "function",
      "protection" : "private",
      "line" : 2030,
      "storageClass" : [
       "final",
       "@property"
      ],
      "deco" : "xFNdZPxS4core3sys5posix3sys6select6fd_set",
      "originalType" : "const const(fd_set)*()",
      "endline" : 2030
     },
     {
      "name" : "maxfd",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2031,
      "deco" : "i",
      "offset" : 152
     },
     {
      "name" : "count",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2032,
      "deco" : "k",
      "offset" : 156
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Set the capacity of this $(D SocketSet). The exact meaning of the\n $(D max) parameter varies from platform to platform.\n Throws: $(D SocketParameterException) if $(D max) exceeds this\n platform's maximum socket set size.\n     \n",
      "line" : 2044,
      "deco" : "FkZC3std6socket9SocketSet",
      "originalType" : "(uint max)",
      "parameters" : [
       {
        "name" : "max",
        "deco" : "k"
       }
      ],
      "endline" : 2059
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Uses the default capacity for the system.\n",
      "line" : 2062,
      "deco" : "FZC3std6socket9SocketSet",
      "originalType" : "()",
      "endline" : 2065
     },
     {
      "name" : "reset",
      "kind" : "function",
      "comment" : " Reset the $(D SocketSet) so that there are 0 $(D Socket)s in the collection.\n",
      "line" : 2068,
      "deco" : "FZv",
      "endline" : 2077
     },
     {
      "name" : "add",
      "kind" : "function",
      "line" : 2080,
      "deco" : "FE3std6socket8socket_tZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "E3std6socket8socket_t"
       }
      ],
      "endline" : 2102
     },
     {
      "name" : "add",
      "kind" : "function",
      "comment" : " Add a $(D Socket) to the collection.\n Throws: $(D SocketParameterException) if the capacity of this\n $(D SocketSet) has been exceeded.\n",
      "line" : 2107,
      "deco" : "FC3std6socket6SocketZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6socket6Socket"
       }
      ],
      "endline" : 2110
     },
     {
      "name" : "remove",
      "kind" : "function",
      "line" : 2112,
      "deco" : "FE3std6socket8socket_tZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "E3std6socket8socket_t"
       }
      ],
      "endline" : 2126
     },
     {
      "name" : "remove",
      "kind" : "function",
      "comment" : " Remove this $(D Socket) from the collection.\n",
      "line" : 2130,
      "deco" : "FC3std6socket6SocketZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6socket6Socket"
       }
      ],
      "endline" : 2133
     },
     {
      "name" : "isSet",
      "kind" : "function",
      "line" : 2135,
      "deco" : "xFE3std6socket8socket_tZi",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "E3std6socket8socket_t"
       }
      ],
      "endline" : 2144
     },
     {
      "name" : "isSet",
      "kind" : "function",
      "comment" : " Returns nonzero if this $(D Socket) is in the collection.\n",
      "line" : 2148,
      "deco" : "xFC3std6socket6SocketZi",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6socket6Socket"
       }
      ],
      "endline" : 2151
     },
     {
      "name" : "max",
      "kind" : "function",
      "comment" : " Return the capacity of this $(D SocketSet). The exact meaning of the\n return value varies from platform to platform.\n",
      "line" : 2156,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZk",
      "originalType" : "const uint()",
      "endline" : 2166
     },
     {
      "name" : "toFd_set",
      "kind" : "function",
      "line" : 2169,
      "deco" : "FZPS4core3sys5posix3sys6select6fd_set",
      "endline" : 2172
     },
     {
      "name" : "selectn",
      "kind" : "function",
      "line" : 2175,
      "deco" : "xFZi",
      "endline" : 2185
     }
    ]
   },
   {
    "name" : "SocketOptionLevel",
    "kind" : "enum",
    "comment" : " The level at which a socket option is defined:\n",
    "line" : 2190,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "SOCKET",
      "kind" : "enum member",
      "comment" : " Socket level\n",
      "line" : 2192
     },
     {
      "name" : "IP",
      "kind" : "enum member",
      "comment" : " Internet Protocol version 4 level\n",
      "line" : 2193
     },
     {
      "name" : "ICMP",
      "kind" : "enum member",
      "comment" : " Internet Control Message Protocol level\n",
      "line" : 2194
     },
     {
      "name" : "IGMP",
      "kind" : "enum member",
      "comment" : " Internet Group Management Protocol level\n",
      "line" : 2195
     },
     {
      "name" : "GGP",
      "kind" : "enum member",
      "comment" : " Gateway to Gateway Protocol level\n",
      "line" : 2196
     },
     {
      "name" : "TCP",
      "kind" : "enum member",
      "comment" : " Transmission Control Protocol level\n",
      "line" : 2197
     },
     {
      "name" : "PUP",
      "kind" : "enum member",
      "comment" : " PARC Universal Packet Protocol level\n",
      "line" : 2198
     },
     {
      "name" : "UDP",
      "kind" : "enum member",
      "comment" : " User Datagram Protocol level\n",
      "line" : 2199
     },
     {
      "name" : "IDP",
      "kind" : "enum member",
      "comment" : " Xerox NS protocol level\n",
      "line" : 2200
     },
     {
      "name" : "RAW",
      "kind" : "enum member",
      "comment" : " Raw IP packet level\n",
      "line" : 2201
     },
     {
      "name" : "IPV6",
      "kind" : "enum member",
      "comment" : " Internet Protocol version 6 level\n",
      "line" : 2202
     }
    ]
   },
   {
    "name" : "Linger",
    "kind" : "struct",
    "comment" : " _Linger information for use with SocketOption.LINGER.\n",
    "line" : 2207,
    "members" : [
     {
      "name" : "clinger",
      "kind" : "variable",
      "line" : 2208,
      "deco" : "S4core3sys5posix3sys6socket6linger",
      "originalType" : "_clinger",
      "offset" : 0
     },
     {
      "name" : "FieldProxy!(\"clinger.l_onoff\", \"on\")",
      "kind" : "mixin",
      "line" : 2220
     },
     {
      "name" : "FieldProxy!(\"clinger.l_linger\", \"time\")",
      "kind" : "mixin",
      "line" : 2221
     }
    ]
   },
   {
    "name" : "linger",
    "kind" : "alias",
    "line" : 2226,
    "storageClass" : [
     "deprecated"
    ],
    "deco" : "S3std6socket6Linger"
   },
   {
    "name" : "SocketOption",
    "kind" : "enum",
    "comment" : " Specifies a socket option:\n",
    "line" : 2229,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "DEBUG",
      "kind" : "enum member",
      "comment" : " Record debugging information\n",
      "line" : 2231
     },
     {
      "name" : "BROADCAST",
      "kind" : "enum member",
      "comment" : " Allow transmission of broadcast messages\n",
      "line" : 2232
     },
     {
      "name" : "REUSEADDR",
      "kind" : "enum member",
      "comment" : " Allow local reuse of address\n",
      "line" : 2233
     },
     {
      "name" : "LINGER",
      "kind" : "enum member",
      "comment" : " Linger on close if unsent data is present\n",
      "line" : 2234
     },
     {
      "name" : "OOBINLINE",
      "kind" : "enum member",
      "comment" : " Receive out-of-band data in band\n",
      "line" : 2235
     },
     {
      "name" : "SNDBUF",
      "kind" : "enum member",
      "comment" : " Send buffer size\n",
      "line" : 2236
     },
     {
      "name" : "RCVBUF",
      "kind" : "enum member",
      "comment" : " Receive buffer size\n",
      "line" : 2237
     },
     {
      "name" : "DONTROUTE",
      "kind" : "enum member",
      "comment" : " Do not route\n",
      "line" : 2238
     },
     {
      "name" : "SNDTIMEO",
      "kind" : "enum member",
      "comment" : " Send timeout\n",
      "line" : 2239
     },
     {
      "name" : "RCVTIMEO",
      "kind" : "enum member",
      "comment" : " Receive timeout\n",
      "line" : 2240
     },
     {
      "name" : "ERROR",
      "kind" : "enum member",
      "comment" : " Retrieve and clear error status\n",
      "line" : 2241
     },
     {
      "name" : "KEEPALIVE",
      "kind" : "enum member",
      "comment" : " Enable keep-alive packets\n",
      "line" : 2242
     },
     {
      "name" : "ACCEPTCONN",
      "kind" : "enum member",
      "comment" : " Listen\n",
      "line" : 2243
     },
     {
      "name" : "RCVLOWAT",
      "kind" : "enum member",
      "comment" : " Minimum number of input bytes to process\n",
      "line" : 2244
     },
     {
      "name" : "SNDLOWAT",
      "kind" : "enum member",
      "comment" : " Minimum number of output bytes to process\n",
      "line" : 2245
     },
     {
      "name" : "TYPE",
      "kind" : "enum member",
      "comment" : " Socket type\n",
      "line" : 2246
     },
     {
      "name" : "TCP_NODELAY",
      "kind" : "enum member",
      "comment" : " Disable the Nagle algorithm for send coalescing\n",
      "line" : 2249
     },
     {
      "name" : "IPV6_UNICAST_HOPS",
      "kind" : "enum member",
      "comment" : " IP unicast hop limit\n",
      "line" : 2252
     },
     {
      "name" : "IPV6_MULTICAST_IF",
      "kind" : "enum member",
      "comment" : " IP multicast interface\n",
      "line" : 2253
     },
     {
      "name" : "IPV6_MULTICAST_LOOP",
      "kind" : "enum member",
      "comment" : " IP multicast loopback\n",
      "line" : 2254
     },
     {
      "name" : "IPV6_MULTICAST_HOPS",
      "kind" : "enum member",
      "comment" : " IP multicast hops\n",
      "line" : 2255
     },
     {
      "name" : "IPV6_JOIN_GROUP",
      "kind" : "enum member",
      "comment" : " Add an IP group membership\n",
      "line" : 2256
     },
     {
      "name" : "IPV6_LEAVE_GROUP",
      "kind" : "enum member",
      "comment" : " Drop an IP group membership\n",
      "line" : 2257
     },
     {
      "name" : "IPV6_V6ONLY",
      "kind" : "enum member",
      "comment" : " Treat wildcard bind as AF_INET6-only\n",
      "line" : 2258
     }
    ]
   },
   {
    "name" : "Socket",
    "kind" : "class",
    "comment" : "\n $(D Socket) is a class that creates a network communication endpoint using\n the Berkeley sockets interface.\n \n",
    "line" : 2267,
    "members" : [
     {
      "name" : "sock",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2269,
      "deco" : "E3std6socket8socket_t",
      "offset" : 16
     },
     {
      "name" : "_family",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2270,
      "deco" : "E3std6socket13AddressFamily",
      "offset" : 20
     },
     {
      "name" : "WINSOCK_TIMEOUT_SKEW",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2280,
      "storageClass" : [
       "enum"
      ],
      "deco" : "i",
      "init" : "500"
     },
     {
      "name" : "__unittestL2282_1566",
      "kind" : "function",
      "protection" : "private",
      "line" : 2282,
      "endline" : 2307
     },
     {
      "name" : "setSock",
      "kind" : "function",
      "protection" : "private",
      "line" : 2307,
      "deco" : "FE3std6socket8socket_tZv",
      "parameters" : [
       {
        "name" : "handle",
        "deco" : "E3std6socket8socket_t"
       }
      ],
      "endline" : 2318
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "protected",
      "line" : 2322,
      "deco" : "FZC3std6socket6Socket",
      "originalType" : "()",
      "endline" : 2324
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create a blocking socket. If a single protocol type exists to support\n this socket type within the address family, the $(D ProtocolType) may be\n omitted.\n     \n",
      "line" : 2334,
      "deco" : "FE3std6socket13AddressFamilyE3std6socket10SocketTypeE3std6socket12ProtocolTypeZC3std6socket6Socket",
      "originalType" : "(AddressFamily af, SocketType type, ProtocolType protocol)",
      "parameters" : [
       {
        "name" : "af",
        "deco" : "E3std6socket13AddressFamily"
       },
       {
        "name" : "type",
        "deco" : "E3std6socket10SocketType"
       },
       {
        "name" : "protocol",
        "deco" : "E3std6socket12ProtocolType"
       }
      ],
      "endline" : 2341
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 2347,
      "deco" : "FE3std6socket13AddressFamilyE3std6socket10SocketTypeZC3std6socket6Socket",
      "originalType" : "(AddressFamily af, SocketType type)",
      "parameters" : [
       {
        "name" : "af",
        "deco" : "E3std6socket13AddressFamily"
       },
       {
        "name" : "type",
        "deco" : "E3std6socket10SocketType"
       }
      ],
      "endline" : 2350
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 2354,
      "deco" : "FE3std6socket13AddressFamilyE3std6socket10SocketTypexAaZC3std6socket6Socket",
      "originalType" : "(AddressFamily af, SocketType type, in char[] protocolName)",
      "parameters" : [
       {
        "name" : "af",
        "deco" : "E3std6socket13AddressFamily"
       },
       {
        "name" : "type",
        "deco" : "E3std6socket10SocketType"
       },
       {
        "name" : "protocolName",
        "deco" : "xAa"
       }
      ],
      "endline" : 2361
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create a blocking socket using the parameters from the specified\n $(D AddressInfo) structure.\n     \n",
      "line" : 2368,
      "deco" : "FxS3std6socket11AddressInfoZC3std6socket6Socket",
      "originalType" : "(in AddressInfo info)",
      "parameters" : [
       {
        "name" : "info",
        "deco" : "xS3std6socket11AddressInfo"
       }
      ],
      "endline" : 2371
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Use an existing socket handle.\n",
      "line" : 2374,
      "deco" : "FE3std6socket8socket_tE3std6socket13AddressFamilyZC3std6socket6Socket",
      "originalType" : "(socket_t sock, AddressFamily af)",
      "parameters" : [
       {
        "name" : "sock",
        "deco" : "E3std6socket8socket_t"
       },
       {
        "name" : "af",
        "deco" : "E3std6socket13AddressFamily"
       }
      ],
      "endline" : 2379
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 2382,
      "deco" : "FZv",
      "endline" : 2385
     },
     {
      "name" : "handle",
      "kind" : "function",
      "comment" : " Get underlying socket handle.\n",
      "line" : 2389,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZE3std6socket8socket_t",
      "originalType" : "const socket_t()",
      "endline" : 2392
     },
     {
      "name" : "blocking",
      "kind" : "function",
      "comment" : "\n Get/set socket's blocking flag.\n\n When a socket is blocking, calls to receive(), accept(), and send()\n will block and wait for data/action.\n A non-blocking socket will immediately return instead of blocking.\n     \n",
      "line" : 2401,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "const bool()",
      "endline" : 2411
     },
     {
      "name" : "blocking",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2414,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdbZv",
      "originalType" : "void(bool byes)",
      "parameters" : [
       {
        "name" : "byes",
        "deco" : "b"
       }
      ],
      "endline" : 2439
     },
     {
      "name" : "addressFamily",
      "kind" : "function",
      "comment" : " Get the socket's address family.\n",
      "line" : 2443,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZE3std6socket13AddressFamily",
      "originalType" : "AddressFamily()",
      "endline" : 2446
     },
     {
      "name" : "isAlive",
      "kind" : "function",
      "comment" : " Property that indicates if this is a valid, alive socket.\n",
      "line" : 2449,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "const bool()",
      "endline" : 2454
     },
     {
      "name" : "bind",
      "kind" : "function",
      "comment" : " Associate a local address with this socket.\n",
      "line" : 2457,
      "deco" : "FC3std6socket7AddressZv",
      "parameters" : [
       {
        "name" : "addr",
        "deco" : "C3std6socket7Address"
       }
      ],
      "endline" : 2461
     },
     {
      "name" : "connect",
      "kind" : "function",
      "comment" : "\n Establish a connection. If the socket is blocking, connect waits for\n the connection to be made. If the socket is nonblocking, connect\n returns immediately and the connection attempt is still in progress.\n     \n",
      "line" : 2468,
      "deco" : "FC3std6socket7AddressZv",
      "parameters" : [
       {
        "name" : "to",
        "deco" : "C3std6socket7Address"
       }
      ],
      "endline" : 2494
     },
     {
      "name" : "listen",
      "kind" : "function",
      "comment" : "\n Listen for an incoming connection. $(D bind) must be called before you\n can $(D listen). The $(D backlog) is a request of how many pending\n incoming connections are queued until $(D accept)ed.\n     \n",
      "line" : 2501,
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "backlog",
        "deco" : "i"
       }
      ],
      "endline" : 2505
     },
     {
      "name" : "accepting",
      "kind" : "function",
      "protection" : "protected",
      "comment" : "\n Called by $(D accept) when a new $(D Socket) must be created for a new\n connection. To use a derived class, override this method and return an\n instance of your class. The returned $(D Socket)'s handle must not be\n set; $(D Socket) has a protected constructor $(D this()) to use in this\n situation.\n     \n",
      "line" : 2516,
      "deco" : "FZC3std6socket6Socket",
      "endline" : 2519
     },
     {
      "name" : "accept",
      "kind" : "function",
      "comment" : "\n Accept an incoming connection. If the socket is blocking, $(D accept)\n waits for a connection request. Throws $(D SocketAcceptException) if\n unable to _accept. See $(D accepting) for use with derived classes.\n     \n",
      "line" : 2526,
      "deco" : "FZC3std6socket6Socket",
      "endline" : 2550
     },
     {
      "name" : "shutdown",
      "kind" : "function",
      "comment" : " Disables sends and/or receives.\n",
      "line" : 2553,
      "deco" : "FE3std6socket14SocketShutdownZv",
      "parameters" : [
       {
        "name" : "how",
        "deco" : "E3std6socket14SocketShutdown"
       }
      ],
      "endline" : 2556
     },
     {
      "name" : "_close",
      "kind" : "function",
      "protection" : "private",
      "line" : 2559,
      "storageClass" : [
       "static"
      ],
      "deco" : "FE3std6socket8socket_tZv",
      "parameters" : [
       {
        "name" : "sock",
        "deco" : "E3std6socket8socket_t"
       }
      ],
      "endline" : 2569
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : "\n Immediately drop any connections and release socket resources.\n Calling $(D shutdown) before $(D close) is recommended for\n connection-oriented sockets. The $(D Socket) object is no longer\n usable after $(D close).\n     \n",
      "line" : 2580,
      "deco" : "FZv",
      "endline" : 2584
     },
     {
      "name" : "hostName",
      "kind" : "function",
      "comment" : " Returns the local machine's host name.\n",
      "line" : 2589,
      "storageClass" : [
       "static",
       "@property"
      ],
      "deco" : "FNdZAya",
      "originalType" : "string()",
      "endline" : 2595
     },
     {
      "name" : "remoteAddress",
      "kind" : "function",
      "comment" : " Remote endpoint $(D Address).\n",
      "line" : 2598,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZC3std6socket7Address",
      "originalType" : "Address()",
      "endline" : 2608
     },
     {
      "name" : "localAddress",
      "kind" : "function",
      "comment" : " Local endpoint $(D Address).\n",
      "line" : 2611,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZC3std6socket7Address",
      "originalType" : "Address()",
      "endline" : 2621
     },
     {
      "name" : "ERROR",
      "kind" : "variable",
      "comment" : "\n Send or receive error code. See $(D wouldHaveBlocked),\n $(D lastSocketError) and $(D Socket.getErrorText) for obtaining more\n information about the error.\n     \n",
      "line" : 2628,
      "storageClass" : [
       "enum"
      ],
      "deco" : "i",
      "init" : "-1"
     },
     {
      "name" : "send",
      "kind" : "function",
      "comment" : "\n Send data on the connection. If the socket is blocking and there is no\n buffer space left, $(D send) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n     \n",
      "line" : 2637,
      "deco" : "FAxvE3std6socket11SocketFlagsZl",
      "originalType" : "ptrdiff_t(const(void)[] buf, SocketFlags flags)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       },
       {
        "name" : "flags",
        "deco" : "E3std6socket11SocketFlags"
       }
      ],
      "endline" : 2648
     },
     {
      "name" : "send",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2651,
      "deco" : "FAxvZl",
      "originalType" : "ptrdiff_t(const(void)[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       }
      ],
      "endline" : 2654
     },
     {
      "name" : "sendTo",
      "kind" : "function",
      "comment" : "\n Send data to a specific destination Address. If the destination address is\n not specified, a connection must have been made and that address is used.\n If the socket is blocking and there is no buffer space left, $(D sendTo) waits.\n Returns: The number of bytes actually sent, or $(D Socket.ERROR) on\n failure.\n     \n",
      "line" : 2663,
      "deco" : "FAxvE3std6socket11SocketFlagsC3std6socket7AddressZl",
      "originalType" : "ptrdiff_t(const(void)[] buf, SocketFlags flags, Address to)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       },
       {
        "name" : "flags",
        "deco" : "E3std6socket11SocketFlags"
       },
       {
        "name" : "to",
        "deco" : "C3std6socket7Address"
       }
      ],
      "endline" : 2676
     },
     {
      "name" : "sendTo",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2679,
      "deco" : "FAxvC3std6socket7AddressZl",
      "originalType" : "ptrdiff_t(const(void)[] buf, Address to)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       },
       {
        "name" : "to",
        "deco" : "C3std6socket7Address"
       }
      ],
      "endline" : 2682
     },
     {
      "name" : "sendTo",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2687,
      "deco" : "FAxvE3std6socket11SocketFlagsZl",
      "originalType" : "ptrdiff_t(const(void)[] buf, SocketFlags flags)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       },
       {
        "name" : "flags",
        "deco" : "E3std6socket11SocketFlags"
       }
      ],
      "endline" : 2697
     },
     {
      "name" : "sendTo",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2702,
      "deco" : "FAxvZl",
      "originalType" : "ptrdiff_t(const(void)[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       }
      ],
      "endline" : 2705
     },
     {
      "name" : "receive",
      "kind" : "function",
      "comment" : "\n Receive data on the connection. If the socket is blocking, $(D receive)\n waits until there is data to be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n     \n",
      "line" : 2715,
      "deco" : "FAvE3std6socket11SocketFlagsZl",
      "originalType" : "ptrdiff_t(void[] buf, SocketFlags flags)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       },
       {
        "name" : "flags",
        "deco" : "E3std6socket11SocketFlags"
       }
      ],
      "endline" : 2727
     },
     {
      "name" : "receive",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2730,
      "deco" : "FAvZl",
      "originalType" : "ptrdiff_t(void[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       }
      ],
      "endline" : 2733
     },
     {
      "name" : "receiveFrom",
      "kind" : "function",
      "comment" : "\n Receive data and get the remote endpoint $(D Address).\n If the socket is blocking, $(D receiveFrom) waits until there is data to\n be received.\n Returns: The number of bytes actually received, $(D 0) if the remote side\n has closed the connection, or $(D Socket.ERROR) on failure.\n     \n",
      "line" : 2742,
      "deco" : "FAvE3std6socket11SocketFlagsKC3std6socket7AddressZl",
      "originalType" : "ptrdiff_t(void[] buf, SocketFlags flags, ref Address from)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       },
       {
        "name" : "flags",
        "deco" : "E3std6socket11SocketFlags"
       },
       {
        "name" : "from",
        "deco" : "C3std6socket7Address",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2761
     },
     {
      "name" : "receiveFrom",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2765,
      "deco" : "FAvKC3std6socket7AddressZl",
      "originalType" : "ptrdiff_t(void[] buf, ref Address from)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       },
       {
        "name" : "from",
        "deco" : "C3std6socket7Address",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2768
     },
     {
      "name" : "receiveFrom",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2773,
      "deco" : "FAvE3std6socket11SocketFlagsZl",
      "originalType" : "ptrdiff_t(void[] buf, SocketFlags flags)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       },
       {
        "name" : "flags",
        "deco" : "E3std6socket11SocketFlags"
       }
      ],
      "endline" : 2787
     },
     {
      "name" : "receiveFrom",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2792,
      "deco" : "FAvZl",
      "originalType" : "ptrdiff_t(void[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       }
      ],
      "endline" : 2795
     },
     {
      "name" : "getOption",
      "kind" : "function",
      "comment" : " Get a socket option.\n Returns: The number of bytes written to $(D result).\n",
      "line" : 2801,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionAvZi",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "result",
        "deco" : "Av"
       }
      ],
      "endline" : 2807
     },
     {
      "name" : "getOption",
      "kind" : "function",
      "comment" : " Common case of getting integer and boolean options.\n",
      "line" : 2811,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJiZi",
      "originalType" : "int(SocketOptionLevel level, SocketOption option, out int32_t result)",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "result",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2814
     },
     {
      "name" : "getOption",
      "kind" : "function",
      "comment" : " Get the linger option.\n",
      "line" : 2818,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJS3std6socket6LingerZi",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "result",
        "deco" : "S3std6socket6Linger",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2822
     },
     {
      "name" : "getOption",
      "kind" : "function",
      "comment" : " Get a timeout (duration) option.\n",
      "line" : 2825,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionJS4core4time8DurationZv",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "result",
        "deco" : "S4core4time8Duration",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2846
     },
     {
      "name" : "setOption",
      "kind" : "function",
      "line" : 2849,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionAvZv",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "value",
        "deco" : "Av"
       }
      ],
      "endline" : 2854
     },
     {
      "name" : "setOption",
      "kind" : "function",
      "comment" : " Common case for setting integer and boolean options.\n",
      "line" : 2858,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptioniZv",
      "originalType" : "void(SocketOptionLevel level, SocketOption option, int32_t value)",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "value",
        "deco" : "i"
       }
      ],
      "endline" : 2861
     },
     {
      "name" : "setOption",
      "kind" : "function",
      "comment" : " Set the linger option.\n",
      "line" : 2865,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionS3std6socket6LingerZv",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "value",
        "deco" : "S3std6socket6Linger"
       }
      ],
      "endline" : 2869
     },
     {
      "name" : "setOption",
      "kind" : "function",
      "comment" : "\n Sets a timeout (duration) option, i.e. $(D SocketOption.SNDTIMEO) or\n $(D RCVTIMEO). Zero indicates no timeout.\n\n In a typical application, you might also want to consider using\n a non-blocking socket instead of setting a timeout on a blocking one.\n\n Note: While the receive timeout setting is generally quite accurate\n on *nix systems even for smaller durations, there are two issues to\n be aware of on Windows: First, although undocumented, the effective\n timeout duration seems to be the one set on the socket plus half\n a second. $(D setOption()) tries to compensate for that, but still,\n timeouts under 500ms are not possible on Windows. Second, be aware\n that the actual amount of time spent until a blocking call returns\n randomly varies on the order of 10ms.\n\n Params:\n   value = The timeout duration to set. Must not be negative.\n\n Throws: $(D SocketException) if setting the options fails.\n\n Example:\n ---\n import std.datetime;\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n // Set a receive timeout, and then wait at one end of\n // the socket pair, knowing that no data will arrive.\n pair[0].setOption(SocketOptionLevel.SOCKET,\n     SocketOption.RCVTIMEO, dur!\"seconds\"(1));\n\n auto sw = StopWatch(AutoStart.yes);\n ubyte[1] buffer;\n pair[0].receive(buffer);\n writefln(\"Waited %s ms until the socket timed out.\",\n     sw.peek.msecs);\n ---\n     \n",
      "line" : 2910,
      "deco" : "FE3std6socket17SocketOptionLevelE3std6socket12SocketOptionS4core4time8DurationZv",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "E3std6socket17SocketOptionLevel"
       },
       {
        "name" : "option",
        "deco" : "E3std6socket12SocketOption"
       },
       {
        "name" : "value",
        "deco" : "S4core4time8Duration"
       }
      ],
      "endline" : 2933
     },
     {
      "name" : "getErrorText",
      "kind" : "function",
      "comment" : " Get a text description of this socket's error status, and clear the\n socket's error status.\n",
      "line" : 2937,
      "deco" : "FZAya",
      "endline" : 2942
     },
     {
      "name" : "setKeepAlive",
      "kind" : "function",
      "comment" : "\n Enables TCP keep-alive with the specified parameters.\n\n Params:\n   time     = Number of seconds with no activity until the first\n              keep-alive packet is sent.\n   interval = Number of seconds between when successive keep-alive\n              packets are sent if no acknowledgement is received.\n\n Throws: $(D SocketOSException) if setting the options fails, or\n $(D SocketFeatureException) if setting keep-alive parameters is\n unsupported on the current platform.\n     \n",
      "line" : 2957,
      "deco" : "FiiZv",
      "parameters" : [
       {
        "name" : "time",
        "deco" : "i"
       },
       {
        "name" : "interval",
        "deco" : "i"
       }
      ],
      "endline" : 2982
     },
     {
      "name" : "select",
      "kind" : "function",
      "comment" : "\n Wait for a socket to change status. A wait timeout of $(Duration) or\n $(D TimeVal), may be specified; if a timeout is not specified or the\n $(D TimeVal) is $(D null), the maximum timeout is used. The $(D TimeVal)\n timeout has an unspecified value when $(D select) returns.\n Returns: The number of sockets with status changes, $(D 0) on timeout,\n or $(D -1) on interruption. If the return value is greater than $(D 0),\n the $(D SocketSets) are updated to only contain the sockets having status\n changes. For a connecting socket, a write status change means the\n connection is established and it's able to send. For a listening socket,\n a read status change means there is an incoming connection request and\n it's able to accept.\n     \n",
      "line" : 3002,
      "storageClass" : [
       "static"
      ],
      "deco" : "FC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetS4core4time8DurationZi",
      "parameters" : [
       {
        "name" : "checkRead",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkWrite",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkError",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "timeout",
        "deco" : "S4core4time8Duration"
       }
      ],
      "endline" : 3008
     },
     {
      "name" : "select",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3012,
      "storageClass" : [
       "static"
      ],
      "deco" : "FC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetZi",
      "parameters" : [
       {
        "name" : "checkRead",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkWrite",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkError",
        "deco" : "C3std6socket9SocketSet"
       }
      ],
      "endline" : 3015
     },
     {
      "name" : "select",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 3018,
      "storageClass" : [
       "static"
      ],
      "deco" : "FC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetPS3std6socket7TimeValZi",
      "parameters" : [
       {
        "name" : "checkRead",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkWrite",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkError",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "timeout",
        "deco" : "PS3std6socket7TimeVal"
       }
      ],
      "endline" : 3104
     },
     {
      "name" : "select",
      "kind" : "function",
      "line" : 3109,
      "storageClass" : [
       "static"
      ],
      "deco" : "FC3std6socket9SocketSetC3std6socket9SocketSetC3std6socket9SocketSetlZi",
      "parameters" : [
       {
        "name" : "checkRead",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkWrite",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "checkError",
        "deco" : "C3std6socket9SocketSet"
       },
       {
        "name" : "microseconds",
        "deco" : "l"
       }
      ],
      "endline" : 3115
     },
     {
      "name" : "createAddress",
      "kind" : "function",
      "protection" : "protected",
      "comment" : " Returns a new Address object for the current address family.\n Can be overridden to support other addresses.\n",
      "line" : 3120,
      "deco" : "FZC3std6socket7Address",
      "endline" : 3137
     }
    ]
   },
   {
    "name" : "TcpSocket",
    "kind" : "class",
    "comment" : " $(D TcpSocket) is a shortcut class for a TCP Socket.\n",
    "line" : 3143,
    "base" : "Socket",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs a blocking TCP Socket.\n",
      "line" : 3146,
      "deco" : "FE3std6socket13AddressFamilyZC3std6socket9TcpSocket",
      "originalType" : "(AddressFamily family)",
      "parameters" : [
       {
        "name" : "family",
        "deco" : "E3std6socket13AddressFamily"
       }
      ],
      "endline" : 3149
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs a blocking IPv4 TCP Socket.\n",
      "line" : 3152,
      "deco" : "FZC3std6socket9TcpSocket",
      "originalType" : "()",
      "endline" : 3155
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs a blocking TCP Socket and connects to an $(D Address).\n",
      "line" : 3160,
      "deco" : "FC3std6socket7AddressZC3std6socket9TcpSocket",
      "originalType" : "(Address connectTo)",
      "parameters" : [
       {
        "name" : "connectTo",
        "deco" : "C3std6socket7Address"
       }
      ],
      "endline" : 3164
     }
    ]
   },
   {
    "name" : "UdpSocket",
    "kind" : "class",
    "comment" : " $(D UdpSocket) is a shortcut class for a UDP Socket.\n",
    "line" : 3169,
    "base" : "Socket",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs a blocking UDP Socket.\n",
      "line" : 3172,
      "deco" : "FE3std6socket13AddressFamilyZC3std6socket9UdpSocket",
      "originalType" : "(AddressFamily family)",
      "parameters" : [
       {
        "name" : "family",
        "deco" : "E3std6socket13AddressFamily"
       }
      ],
      "endline" : 3175
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructs a blocking IPv4 UDP Socket.\n",
      "line" : 3179,
      "deco" : "FZC3std6socket9UdpSocket",
      "originalType" : "()",
      "endline" : 3182
     }
    ]
   },
   {
    "name" : "socketPair",
    "kind" : "function",
    "comment" : "\n Creates a pair of connected sockets.\n\n The two sockets are indistinguishable.\n\n Throws: $(D SocketException) if creation of the sockets fails.\n\n Example:\n ---\n immutable ubyte[] data = [1, 2, 3, 4];\n auto pair = socketPair();\n scope(exit) foreach (s; pair) s.close();\n\n pair[0].send(data);\n\n auto buf = new ubyte[data.length];\n pair[1].receive(buf);\n assert(buf == data);\n ---\n \n",
    "line" : 3205,
    "deco" : "FZG2C3std6socket6Socket",
    "originalType" : "Socket[2]()",
    "endline" : 3243
   },
   {
    "name" : "__unittestL3245_1567",
    "kind" : "function",
    "line" : 3245,
    "endline" : 3257
   }
  ]
 },
 {
  "name" : "std.socketstream",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/socketstream.d",
  "comment" : "\n $(RED Warning: This module is considered out-dated and not up to Phobos'\n       current standards. It will remain until we have a suitable replacement,\n       but be aware that it will not remain long term.)\n\n $(D SocketStream) is a stream for a blocking,\n connected $(D Socket).\n\n Example:\n      See $(SAMPLESRC htmlget.d)\n Authors: Christopher E. Miller\n References:\n      $(LINK2 std_stream.html, std.stream)\n Source:    $(PHOBOSSRC std/_socketstream.d)\n Macros: WIKI=Phobos/StdSocketstream\n \n",
  "members" : [
   {
    "name" : "std.stream",
    "kind" : "import",
    "line" : 42,
    "protection" : "private"
   },
   {
    "name" : "std.socket",
    "kind" : "import",
    "line" : 43,
    "protection" : "private"
   },
   {
    "name" : "SocketStream",
    "kind" : "class",
    "comment" : "\n $(D SocketStream) is a stream for a blocking,\n connected $(D Socket).\n \n",
    "line" : 49,
    "base" : "Stream",
    "members" : [
     {
      "name" : "sock",
      "kind" : "variable",
      "protection" : "private",
      "line" : 52,
      "deco" : "C3std6socket6Socket",
      "originalType" : "Socket",
      "offset" : 56
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs a SocketStream with the specified Socket and FileMode flags.\n         \n",
      "line" : 59,
      "deco" : "FC3std6socket6SocketE3std6stream8FileModeZC3std12socketstream12SocketStream",
      "originalType" : "(Socket sock, FileMode mode)",
      "parameters" : [
       {
        "name" : "sock",
        "deco" : "C3std6socket6Socket"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode"
       }
      ],
      "endline" : 67
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Uses mode $(D FileMode.In | FileMode.Out).\n         \n",
      "line" : 72,
      "deco" : "FC3std6socket6SocketZC3std12socketstream12SocketStream",
      "originalType" : "(Socket sock)",
      "parameters" : [
       {
        "name" : "sock",
        "deco" : "C3std6socket6Socket"
       }
      ],
      "endline" : 76
     },
     {
      "name" : "socket",
      "kind" : "function",
      "comment" : "\n Property to get the $(D Socket) that is being streamed.\n         \n",
      "line" : 81,
      "deco" : "FZC3std6socket6Socket",
      "endline" : 84
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "comment" : "\n Attempts to read the entire block, waiting if necessary.\n         \n",
      "line" : 89,
      "storageClass" : [
       "override"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* _buffer, size_t size)",
      "parameters" : [
       {
        "name" : "_buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 102,
      "overrides" : [
       "std.stream.Stream.readBlock"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "comment" : "\n Attempts to write the entire block, waiting if necessary.\n         \n",
      "line" : 107,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* _buffer, size_t size)",
      "parameters" : [
       {
        "name" : "_buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 120,
      "overrides" : [
       "std.stream.Stream.writeBlock"
      ]
     },
     {
      "name" : "seek",
      "kind" : "function",
      "comment" : "\n Socket streams do not support seeking. This disabled method throws\n a $(D SeekException).\n         \n",
      "line" : 126,
      "storageClass" : [
       "override",
       "@disable"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "whence",
        "deco" : "E3std6stream7SeekPos"
       }
      ],
      "endline" : 129,
      "overrides" : [
       "std.stream.Stream.seek"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Does not return the entire stream because that would\n require the remote connection to be closed.\n         \n",
      "line" : 135,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZAya",
      "endline" : 138,
      "overrides" : [
       "std.stream.Stream.toString"
      ]
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : "\n Close the $(D Socket).\n         \n",
      "line" : 143,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 147,
      "overrides" : [
       "std.stream.Stream.close"
      ]
     }
    ]
   }
  ]
 },
 {
  "name" : "std.stdint",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/stdint.d",
  "comment" : "\n\n    D constrains integral types to specific sizes. But efficiency\n    of different sizes varies from machine to machine,\n    pointer sizes vary, and the maximum integer size varies.\n    <b>stdint</b> offers a portable way of trading off size\n    vs efficiency, in a manner compatible with the <tt>stdint.h</tt>\n    definitions in C.\n\n    The exact aliases are types of exactly the specified number of bits.\n    The at least aliases are at least the specified number of bits\n    large, and can be larger.\n    The fast aliases are the fastest integral type supported by the\n    processor that is at least as wide as the specified number of bits.\n\n    The aliases are:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Exact Alias\n    <th>Description\n    <th>At Least Alias\n    <th>Description\n    <th>Fast Alias\n    <th>Description\n    <tr>\n    <td>int8_t\n    <td>exactly 8 bits signed\n    <td>int_least8_t\n    <td>at least 8 bits signed\n    <td>int_fast8_t\n    <td>fast 8 bits signed\n    <tr>\n    <td>uint8_t\n    <td>exactly 8 bits unsigned\n    <td>uint_least8_t\n    <td>at least 8 bits unsigned\n    <td>uint_fast8_t\n    <td>fast 8 bits unsigned\n\n    <tr>\n    <td>int16_t\n    <td>exactly 16 bits signed\n    <td>int_least16_t\n    <td>at least 16 bits signed\n    <td>int_fast16_t\n    <td>fast 16 bits signed\n    <tr>\n    <td>uint16_t\n    <td>exactly 16 bits unsigned\n    <td>uint_least16_t\n    <td>at least 16 bits unsigned\n    <td>uint_fast16_t\n    <td>fast 16 bits unsigned\n\n    <tr>\n    <td>int32_t\n    <td>exactly 32 bits signed\n    <td>int_least32_t\n    <td>at least 32 bits signed\n    <td>int_fast32_t\n    <td>fast 32 bits signed\n    <tr>\n    <td>uint32_t\n    <td>exactly 32 bits unsigned\n    <td>uint_least32_t\n    <td>at least 32 bits unsigned\n    <td>uint_fast32_t\n    <td>fast 32 bits unsigned\n\n    <tr>\n    <td>int64_t\n    <td>exactly 64 bits signed\n    <td>int_least64_t\n    <td>at least 64 bits signed\n    <td>int_fast64_t\n    <td>fast 64 bits signed\n    <tr>\n    <td>uint64_t\n    <td>exactly 64 bits unsigned\n    <td>uint_least64_t\n    <td>at least 64 bits unsigned\n    <td>uint_fast64_t\n    <td>fast 64 bits unsigned\n    </table>\n\n    The ptr aliases are integral types guaranteed to be large enough\n    to hold a pointer without losing bits:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Alias\n    <th>Description\n    <tr>\n    <td>intptr_t\n    <td>signed integral type large enough to hold a pointer\n    <tr>\n    <td>uintptr_t\n    <td>unsigned integral type large enough to hold a pointer\n    </table>\n\n    The max aliases are the largest integral types:\n\n    <table border=1 cellspacing=0 cellpadding=5>\n    <th>Alias\n    <th>Description\n    <tr>\n    <td>intmax_t\n    <td>the largest signed integral type\n    <tr>\n    <td>uintmax_t\n    <td>the largest unsigned integral type\n    </table>\n\n Macros:\n  WIKI=Phobos/StdStdint\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_stdint.d)\n \n",
  "members" : [
   {
    "name" : "core.stdc.stdint",
    "kind" : "import",
    "line" : 130
   }
  ]
 },
 {
  "name" : "std.stdiobase",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/stdiobase.d",
  "comment" : "\n The only purpose of this module is to do the static construction for\n std.stdio, to eliminate cyclic construction errors.\n\n Copyright: Copyright Andrei Alexandrescu 2008 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB erdani.org, Andrei Alexandrescu)\n Source:    $(PHOBOSSRC std/_stdiobase.d)\n \n",
  "members" : [
   {
    "name" : "std_stdio_static_this",
    "kind" : "function",
    "line" : 19,
    "deco" : "UZv"
   },
   {
    "name" : "_sharedStaticCtor24",
    "kind" : "function",
    "line" : 21,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 24
   }
  ]
 },
 {
  "name" : "std.stdio",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/stdio.d",
  "comment" : "\nStandard I/O functions that extend $(B std.c.stdio).  $(B std.c.stdio)\nis $(D_PARAM public)ally imported when importing $(B std.stdio).\n\nSource: $(PHOBOSSRC std/_stdio.d)\nMacros:\nWIKI=Phobos/StdStdio\n\nCopyright: Copyright Digital Mars 2007-.\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB digitalmars.com, Walter Bright),\n           $(WEB erdani.org, Andrei Alexandrescu),\n           Alex Rønne Petersen\n \n",
  "members" : [
   {
    "name" : "core.stdc.stdio",
    "kind" : "import",
    "line" : 19
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 19,
    "protection" : "private",
    "selective" : [
     "KeepTerminator"
    ]
   },
   {
    "name" : "std.c.stdio",
    "kind" : "static import",
    "line" : 20,
    "protection" : "private"
   },
   {
    "name" : "std.stdiobase",
    "kind" : "import",
    "line" : 21,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.errno",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stddef",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 22,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.wchar_",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.stdio",
    "kind" : "import",
    "line" : 45,
    "protection" : "private"
   },
   {
    "name" : "fileno",
    "kind" : "alias",
    "line" : 46
   },
   {
    "name" : "fputc_unlocked",
    "kind" : "function",
    "line" : 135,
    "deco" : "UiPS4core4stdc5stdio6_iobufZi",
    "parameters" : [
     {
      "deco" : "i"
     },
     {
      "deco" : "PS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "fputwc_unlocked",
    "kind" : "function",
    "line" : 136,
    "deco" : "UwPS4core4stdc5stdio6_iobufZi",
    "originalType" : "extern (C) int(wchar_t, _iobuf*)",
    "parameters" : [
     {
      "deco" : "w"
     },
     {
      "deco" : "PS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "fgetc_unlocked",
    "kind" : "function",
    "line" : 137,
    "deco" : "UPS4core4stdc5stdio6_iobufZi",
    "parameters" : [
     {
      "deco" : "PS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "fgetwc_unlocked",
    "kind" : "function",
    "line" : 138,
    "deco" : "UPS4core4stdc5stdio6_iobufZi",
    "parameters" : [
     {
      "deco" : "PS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "flockfile",
    "kind" : "function",
    "line" : 139,
    "deco" : "UPOS4core4stdc5stdio6_iobufZv",
    "originalType" : "extern (C) void(FILE*)",
    "parameters" : [
     {
      "deco" : "POS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "funlockfile",
    "kind" : "function",
    "line" : 140,
    "deco" : "UPOS4core4stdc5stdio6_iobufZv",
    "originalType" : "extern (C) void(FILE*)",
    "parameters" : [
     {
      "deco" : "POS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "getline",
    "kind" : "function",
    "line" : 141,
    "deco" : "UPPaPmPOS4core4stdc5stdio6_iobufZl",
    "originalType" : "extern (C) ptrdiff_t(char**, size_t*, FILE*)",
    "parameters" : [
     {
      "deco" : "PPa"
     },
     {
      "deco" : "Pm"
     },
     {
      "deco" : "POS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "getdelim",
    "kind" : "function",
    "line" : 142,
    "deco" : "UPPaPmiPOS4core4stdc5stdio6_iobufZl",
    "originalType" : "extern (C) ptrdiff_t(char**, size_t*, int, FILE*)",
    "parameters" : [
     {
      "deco" : "PPa"
     },
     {
      "deco" : "Pm"
     },
     {
      "deco" : "i"
     },
     {
      "deco" : "POS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "fwrite_unlocked",
    "kind" : "function",
    "protection" : "private",
    "line" : 144,
    "deco" : "UPxvmmPS4core4stdc5stdio6_iobufZm",
    "originalType" : "extern (C) size_t(const(void)* ptr, size_t size, size_t n, _iobuf* stream)",
    "parameters" : [
     {
      "name" : "ptr",
      "deco" : "Pxv"
     },
     {
      "name" : "size",
      "deco" : "m"
     },
     {
      "name" : "n",
      "deco" : "m"
     },
     {
      "name" : "stream",
      "deco" : "PS4core4stdc5stdio6_iobuf"
     }
    ]
   },
   {
    "name" : "FPUTC",
    "kind" : "alias",
    "line" : 148
   },
   {
    "name" : "FPUTWC",
    "kind" : "alias",
    "line" : 149
   },
   {
    "name" : "FGETC",
    "kind" : "alias",
    "line" : 150
   },
   {
    "name" : "FGETWC",
    "kind" : "alias",
    "line" : 151
   },
   {
    "name" : "FLOCK",
    "kind" : "alias",
    "line" : 153
   },
   {
    "name" : "FUNLOCK",
    "kind" : "alias",
    "line" : 154
   },
   {
    "kind" : "template",
    "line" : 187,
    "name" : "ByRecord",
    "parameters" : [
     {
      "name" : "Fields",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "ByRecord",
      "kind" : "struct",
      "line" : 187,
      "members" : [
       {
        "name" : "file",
        "kind" : "variable",
        "line" : 189,
        "type" : "File"
       },
       {
        "name" : "line",
        "kind" : "variable",
        "line" : 190,
        "type" : "char[]"
       },
       {
        "name" : "current",
        "kind" : "variable",
        "line" : 191,
        "type" : "Tuple!(Fields)"
       },
       {
        "name" : "format",
        "kind" : "variable",
        "line" : 192,
        "type" : "string"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 195,
        "type" : "(File f, string format)",
        "parameters" : [
         {
          "name" : "f",
          "type" : "File"
         },
         {
          "name" : "format",
          "type" : "string"
         }
        ],
        "endline" : 201
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : " Range primitive implementations.\n",
        "line" : 204,
        "type" : "bool()",
        "endline" : 207
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 210,
        "type" : "Tuple!(Fields)()",
        "endline" : 213
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 216,
        "type" : "void()",
        "endline" : 231
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 234,
    "name" : "byRecord",
    "parameters" : [
     {
      "name" : "Fields",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "byRecord",
      "kind" : "function",
      "line" : 236,
      "type" : "ByRecord!(Fields)(File f, string format)",
      "parameters" : [
       {
        "name" : "f",
        "type" : "File"
       },
       {
        "name" : "format",
        "type" : "string"
       }
      ],
      "endline" : 239
     }
    ]
   },
   {
    "name" : "File",
    "kind" : "struct",
    "comment" : "\nEncapsulates a $(D FILE*). Generally D does not attempt to provide\nthin wrappers over equivalent functions in the C standard library, but\nmanipulating $(D FILE*) values directly is unsafe and error-prone in\nmany ways. The $(D File) type ensures safe manipulation, automatic\nfile closing, and a lot of convenience.\n\nThe underlying $(D FILE*) handle is maintained in a reference-counted\nmanner, such that as soon as the last $(D File) variable bound to a\ngiven $(D FILE*) goes out of scope, the underlying $(D FILE*) is\nautomatically closed.\n\nBugs:\n$(D File) expects file names to be encoded in $(B CP_ACP) on $(I Windows)\ninstead of UTF-8 ($(BUGZILLA 7648)) thus must not be used in $(I Windows)\nor cross-platform applications other than with an immediate ASCII string as\na file name to prevent accidental changes to result in incorrect behavior.\nOne can use $(XREF file, read)/$(XREF file, write)/$(XREF stream, File)\ninstead.\n\nExample:\n----\n// test.d\nvoid main(string args[])\n{\n    auto f = File(\"test.txt\", \"w\"); // open for writing\n    f.write(\"Hello\");\n    if (args.length > 1)\n    {\n        auto g = f; // now g and f write to the same file\n                    // internal reference count is 2\n        g.write(\", \", args[1]);\n        // g exits scope, reference count decreases to 1\n    }\n    f.writeln(\"!\");\n    // f exits scope, reference count falls to zero,\n    // underlying $(D FILE*) is closed.\n}\n----\n<pre class=console>\n% rdmd test.d Jimmy\n% cat test.txt\nHello, Jimmy!\n% __\n</pre>\n \n",
    "line" : 289,
    "members" : [
     {
      "name" : "Impl",
      "kind" : "struct",
      "protection" : "private",
      "line" : 291,
      "members" : [
       {
        "name" : "handle",
        "kind" : "variable",
        "line" : 292,
        "deco" : "POS4core4stdc5stdio6_iobuf",
        "originalType" : "FILE*",
        "init" : "null",
        "offset" : 0
       },
       {
        "name" : "refs",
        "kind" : "variable",
        "line" : 293,
        "deco" : "k",
        "init" : "2147483647u",
        "offset" : 8
       },
       {
        "name" : "isPopened",
        "kind" : "variable",
        "line" : 294,
        "deco" : "b",
        "offset" : 12
       }
      ]
     },
     {
      "name" : "_p",
      "kind" : "variable",
      "protection" : "private",
      "line" : 296,
      "deco" : "PS3std5stdio4File4Impl",
      "offset" : 0
     },
     {
      "name" : "_name",
      "kind" : "variable",
      "protection" : "private",
      "line" : 297,
      "deco" : "Aya",
      "offset" : 8
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "package",
      "line" : 299,
      "deco" : "FNcPOS4core4stdc5stdio6_iobufAyakbZS3std5stdio4File",
      "originalType" : "(FILE* handle, string name, uint refs = 1, bool isPopened = false)",
      "parameters" : [
       {
        "name" : "handle",
        "deco" : "POS4core4stdc5stdio6_iobuf"
       },
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "refs",
        "deco" : "k",
        "default" : "1u"
       },
       {
        "name" : "isPopened",
        "deco" : "b",
        "default" : "false"
       }
      ],
      "endline" : 307
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\nConstructor taking the name of the file to open and the open mode\n(with the same semantics as in the C standard library $(WEB\ncplusplus.com/reference/clibrary/cstdio/fopen.html, fopen)\nfunction).\n\nCopying one $(D File) object to another results in the two $(D File)\nobjects referring to the same underlying file.\n\nThe destructor automatically closes the file as soon as no $(D File)\nobject refers to it anymore.\n\nThrows: $(D ErrnoException) if the file could not be opened.\n \n",
      "line" : 323,
      "deco" : "FNcAyaxAaZS3std5stdio4File",
      "originalType" : "(string name, in char[] stdioOpenmode = \"rb\")",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "stdioOpenmode",
        "deco" : "xAa",
        "default" : "\"rb\""
       }
      ],
      "endline" : 329
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 331,
      "deco" : "FZv",
      "endline" : 334
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "comment" : "\nAssigns a file to another. The target of the assignment gets detached\nfrom whatever file it was attached to, and attaches itself to the new\nfile.\n \n",
      "line" : 348,
      "deco" : "FS3std5stdio4FileZv",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "S3std5stdio4File"
       }
      ],
      "endline" : 351
     },
     {
      "name" : "open",
      "kind" : "function",
      "comment" : "\nFirst calls $(D detach) (throwing on failure), and then attempts to\n_open file $(D name) with mode $(D stdioOpenmode). The mode has the\nsame semantics as in the C standard library $(WEB\ncplusplus.com/reference/clibrary/cstdio/fopen.html, fopen) function.\n\nThrows: $(D ErrnoException) in case of error.\n \n",
      "line" : 361,
      "deco" : "FAyaxAaZv",
      "originalType" : "void(string name, in char[] stdioOpenmode = \"rb\")",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "stdioOpenmode",
        "deco" : "xAa",
        "default" : "\"rb\""
       }
      ],
      "endline" : 365
     },
     {
      "name" : "popen",
      "kind" : "function",
      "comment" : "\nFirst calls $(D detach) (throwing on failure), and then runs a command\nby calling the C standard library function $(WEB\nopengroup.org/onlinepubs/007908799/xsh/_popen.html, _popen).\n\nThrows: $(D ErrnoException) in case of error.\n \n",
      "line" : 374,
      "deco" : "FAyaxAaZv",
      "originalType" : "void(string command, in char[] stdioOpenmode = \"r\")",
      "parameters" : [
       {
        "name" : "command",
        "deco" : "Aya"
       },
       {
        "name" : "stdioOpenmode",
        "deco" : "xAa",
        "default" : "\"r\""
       }
      ],
      "endline" : 380
     },
     {
      "name" : "isOpen",
      "kind" : "function",
      "comment" : " Returns $(D true) if the file is opened. \n",
      "line" : 383,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 386
     },
     {
      "name" : "eof",
      "kind" : "function",
      "comment" : "\nReturns $(D true) if the file is at end (see $(WEB\ncplusplus.com/reference/clibrary/cstdio/feof.html, feof)).\n\nThrows: $(D Exception) if the file is not opened.\n \n",
      "line" : 394,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNdZb",
      "originalType" : "const pure bool()",
      "endline" : 398
     },
     {
      "name" : "name",
      "kind" : "function",
      "comment" : " Returns the name of the last opened file, if any.\nIf a $(D File) was created with $(LREF tmpfile) and $(LREF wrapFile)\nit has no name.\n",
      "line" : 403,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZAya",
      "originalType" : "const pure nothrow string()",
      "endline" : 406
     },
     {
      "name" : "error",
      "kind" : "function",
      "comment" : "\nIf the file is not opened, returns $(D false). Otherwise, returns\n$(WEB cplusplus.com/reference/clibrary/cstdio/ferror.html, ferror) for\nthe file handle.\n \n",
      "line" : 413,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNaNbNdZb",
      "originalType" : "const pure nothrow bool()",
      "endline" : 416
     },
     {
      "name" : "detach",
      "kind" : "function",
      "comment" : "\nDetaches from the underlying file. If the sole owner, calls $(D close).\n\nThrows: $(D ErrnoException) on failure if closing the file.\n  \n",
      "line" : 423,
      "deco" : "FZv",
      "endline" : 434
     },
     {
      "name" : "__unittestL436_1568",
      "kind" : "function",
      "line" : 436,
      "endline" : 460
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : "\nIf the file was unopened, succeeds vacuously. Otherwise closes the\nfile (by calling $(WEB\ncplusplus.com/reference/clibrary/cstdio/fclose.html, fclose)),\nthrowing on error. Even if an exception is thrown, afterwards the $(D\nFile) object is empty. This is different from $(D detach) in that it\nalways closes the file; consequently, all other $(D File) objects\nreferring to the same handle will see a closed file henceforth.\n\nThrows: $(D ErrnoException) on error.\n \n",
      "line" : 460,
      "deco" : "FZv",
      "endline" : 487
     },
     {
      "name" : "clearerr",
      "kind" : "function",
      "comment" : "\nIf the file is not opened, succeeds vacuously. Otherwise, returns\n$(WEB cplusplus.com/reference/clibrary/cstdio/_clearerr.html,\n_clearerr) for the file handle.\n \n",
      "line" : 494,
      "deco" : "FNaNbZv",
      "endline" : 498
     },
     {
      "name" : "flush",
      "kind" : "function",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/_fflush.html, _fflush)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened or if the call to $D(fflush) fails.\n \n",
      "line" : 506,
      "deco" : "FZv",
      "endline" : 511
     },
     {
      "kind" : "template",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/fread.html, fread) for the\nfile handle. The number of items to read and the size of\neach item is inferred from the size and type of the input array, respectively.\n\nReturns: The slice of $(D buffer) containing the data that was actually read.\nThis will be shorter than $(D buffer) if EOF was reached before the buffer\ncould be filled.\n\nThrows: $(D Exception) if $(D buffer) is empty.\n        $(D ErrnoException) if the file is not opened or the call to $D(fread) fails.\n\n$(D rawRead) always reads in binary mode on Windows.\n \n",
      "line" : 527,
      "name" : "rawRead",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "rawRead",
        "kind" : "function",
        "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/fread.html, fread) for the\nfile handle. The number of items to read and the size of\neach item is inferred from the size and type of the input array, respectively.\n\nReturns: The slice of $(D buffer) containing the data that was actually read.\nThis will be shorter than $(D buffer) if EOF was reached before the buffer\ncould be filled.\n\nThrows: $(D Exception) if $(D buffer) is empty.\n        $(D ErrnoException) if the file is not opened or the call to $D(fread) fails.\n\n$(D rawRead) always reads in binary mode on Windows.\n \n",
        "line" : 527,
        "type" : "T[](T[] buffer)",
        "parameters" : [
         {
          "name" : "buffer",
          "type" : "T[]"
         }
        ],
        "endline" : 547
       }
      ]
     },
     {
      "name" : "__unittestL549_1569",
      "kind" : "function",
      "line" : 549,
      "endline" : 574
     },
     {
      "kind" : "template",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/fwrite.html, fwrite) for the file\nhandle. The number of items to write and the size of each\nitem is inferred from the size and type of the input array, respectively. An\nerror is thrown if the buffer could not be written in its entirety.\n\n$(D rawWrite) always writes in binary mode on Windows.\n\nThrows: $(D ErrnoException) if the file is not opened or if the call to $D(fread) fails.\n \n",
      "line" : 574,
      "name" : "rawWrite",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "rawWrite",
        "kind" : "function",
        "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/fwrite.html, fwrite) for the file\nhandle. The number of items to write and the size of each\nitem is inferred from the size and type of the input array, respectively. An\nerror is thrown if the buffer could not be written in its entirety.\n\n$(D rawWrite) always writes in binary mode on Windows.\n\nThrows: $(D ErrnoException) if the file is not opened or if the call to $D(fread) fails.\n \n",
        "line" : 574,
        "type" : "void(in T[] buffer)",
        "parameters" : [
         {
          "name" : "buffer",
          "type" : "T[]",
          "storageClass" : [
           "in"
          ]
         }
        ],
        "endline" : 598
       }
      ]
     },
     {
      "name" : "__unittestL601_1570",
      "kind" : "function",
      "line" : 601,
      "endline" : 618
     },
     {
      "name" : "seek",
      "kind" : "function",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/fseek.html, fseek)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $D(fseek) fails.\n \n",
      "line" : 618,
      "deco" : "FliZv",
      "originalType" : "void(long offset, int origin = SEEK_SET)",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "origin",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 632
     },
     {
      "name" : "__unittestL635_1571",
      "kind" : "function",
      "line" : 635,
      "endline" : 667
     },
     {
      "name" : "tell",
      "kind" : "function",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/ftell.html, ftell) for the\nmanaged file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $D(ftell) fails.\n \n",
      "line" : 667,
      "storageClass" : [
       "@property"
      ],
      "deco" : "xFNdZm",
      "originalType" : "const ulong()",
      "endline" : 681
     },
     {
      "name" : "__unittestL683_1572",
      "kind" : "function",
      "line" : 683,
      "endline" : 700
     },
     {
      "name" : "rewind",
      "kind" : "function",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/_rewind.html, _rewind)\nfor the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n \n",
      "line" : 700,
      "deco" : "FZv",
      "endline" : 704
     },
     {
      "name" : "setvbuf",
      "kind" : "function",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html, _setvbuf) for\nthe file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $D(setvbuf) fails.\n \n",
      "line" : 713,
      "deco" : "FmiZv",
      "originalType" : "void(size_t size, int mode = _IOFBF)",
      "parameters" : [
       {
        "name" : "size",
        "deco" : "m"
       },
       {
        "name" : "mode",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 718
     },
     {
      "name" : "setvbuf",
      "kind" : "function",
      "comment" : "\nCalls $(WEB cplusplus.com/reference/clibrary/cstdio/_setvbuf.html,\n_setvbuf) for the file handle.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) if the call to $D(setvbuf) fails.\n",
      "line" : 727,
      "deco" : "FAviZv",
      "originalType" : "void(void[] buf, int mode = _IOFBF)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Av"
       },
       {
        "name" : "mode",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 733
     },
     {
      "kind" : "template",
      "comment" : "\nWrites its arguments in text format to the file.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
      "line" : 741,
      "name" : "write",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "write",
        "kind" : "function",
        "comment" : "\nWrites its arguments in text format to the file.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
        "line" : 741,
        "type" : "void(S args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "S"
         }
        ],
        "endline" : 773
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\nWrites its arguments in text format to the file, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
      "line" : 781,
      "name" : "writeln",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "writeln",
        "kind" : "function",
        "comment" : "\nWrites its arguments in text format to the file, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
        "line" : 781,
        "type" : "void(S args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "S"
         }
        ],
        "endline" : 784
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\nWrites its arguments in text format to the file, according to the\nformat in the first argument.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
      "line" : 793,
      "name" : "writef",
      "parameters" : [
       {
        "name" : "Char",
        "kind" : "type"
       },
       {
        "name" : "A",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "writef",
        "kind" : "function",
        "comment" : "\nWrites its arguments in text format to the file, according to the\nformat in the first argument.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
        "line" : 793,
        "type" : "void(in Char[] fmt, A args)",
        "parameters" : [
         {
          "name" : "fmt",
          "type" : "Char[]",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "args",
          "type" : "A"
         }
        ],
        "endline" : 796
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\nWrites its arguments in text format to the file, according to the\nformat in the first argument, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
      "line" : 805,
      "name" : "writefln",
      "parameters" : [
       {
        "name" : "Char",
        "kind" : "type"
       },
       {
        "name" : "A",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "writefln",
        "kind" : "function",
        "comment" : "\nWrites its arguments in text format to the file, according to the\nformat in the first argument, followed by a newline.\n\nThrows: $(D Exception) if the file is not opened.\n        $(D ErrnoException) on an error writing to the file.\n",
        "line" : 805,
        "type" : "void(in Char[] fmt, A args)",
        "parameters" : [
         {
          "name" : "fmt",
          "type" : "Char[]",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "args",
          "type" : "A"
         }
        ],
        "endline" : 810
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\nRead line from stream $(D fp) and return it as a specified type.\n\nThis version manages its own read buffer, which means one memory allocation per call. If you are not\nretaining a reference to the read data, consider the $(D File.readln(buf)) version, which may offer\nbetter performance as it reuses its read buffer.\n\nParams:\n    S = Template parameter; the type of the allocated buffer, and the type returned. Defaults to $(D string)\n    terminator = line terminator (by default, '\\n')\n\nReturns:\n    The line that was read, including the line terminator character.\n\nExample:\n---\n// Reads $(D stdin) and writes it to $(D stdout).\nimport std.stdio;\n\nint main()\n{\n    string buf;\n    while ((buf = readln()) !is null)\n        write(buf);\n    return 0;\n}\n---\n",
      "line" : 840,
      "name" : "readln",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type",
        "default" : "string"
       }
      ],
      "members" : [
       {
        "name" : "readln",
        "kind" : "function",
        "comment" : "\nRead line from stream $(D fp) and return it as a specified type.\n\nThis version manages its own read buffer, which means one memory allocation per call. If you are not\nretaining a reference to the read data, consider the $(D File.readln(buf)) version, which may offer\nbetter performance as it reuses its read buffer.\n\nParams:\n    S = Template parameter; the type of the allocated buffer, and the type returned. Defaults to $(D string)\n    terminator = line terminator (by default, '\\n')\n\nReturns:\n    The line that was read, including the line terminator character.\n\nExample:\n---\n// Reads $(D stdin) and writes it to $(D stdout).\nimport std.stdio;\n\nint main()\n{\n    string buf;\n    while ((buf = readln()) !is null)\n        write(buf);\n    return 0;\n}\n---\n",
        "line" : 840,
        "type" : "S(dchar terminator = '\\x0a')",
        "parameters" : [
         {
          "name" : "terminator",
          "deco" : "w",
          "default" : "'\\x0a'"
         }
        ],
        "endline" : 845
       }
      ]
     },
     {
      "name" : "__unittestL847_1573",
      "kind" : "function",
      "line" : 847,
      "endline" : 918
     },
     {
      "kind" : "template",
      "comment" : "\nRead line from stream $(D fp) and write it to $(D buf[]), including\nterminating character.\n\nThis is often faster than $(D buf = File.readln()) because the buffer\nis reused each call. Note that reusing the buffer means that the\nprevious contents of it has to be copied if needed.\n\nParams:\nfp = input stream\nbuf = buffer used to store the resulting line data. buf is\nresized as necessary.\n\nReturns:\n0 for end of file, otherwise number of characters read\n\nThrows: $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode\nconversion error.\n\nExample:\n---\n// Reads $(D stdin) into a buffer\n// Dumps the buffer to $(D stdout) when it gets a \"q\"\n\nint main()\n{\n    string[] outBuf;\n    string buf;\n\n    while (stdin.readln(buf))\n    {\n        if (buf[0] == 'q')\n            break;\n\n        outBuf ~= buf.idup;\n    }\n\n    foreach (line; outBuf)\n    {\n        write(line);\n    }\n\n    return 0;\n}\n---\n\nThis method is more efficient than the one in the previous example\nbecause $(D stdin.readln(buf)) reuses (if possible) memory allocated\nby $(D buf), whereas $(D buf = stdin.readln()) makes a new memory allocation\nwith every line.\n",
      "line" : 918,
      "name" : "readln",
      "parameters" : [
       {
        "name" : "C",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "readln",
        "kind" : "function",
        "comment" : "\nRead line from stream $(D fp) and write it to $(D buf[]), including\nterminating character.\n\nThis is often faster than $(D buf = File.readln()) because the buffer\nis reused each call. Note that reusing the buffer means that the\nprevious contents of it has to be copied if needed.\n\nParams:\nfp = input stream\nbuf = buffer used to store the resulting line data. buf is\nresized as necessary.\n\nReturns:\n0 for end of file, otherwise number of characters read\n\nThrows: $(D StdioException) on I/O error, or $(D UnicodeException) on Unicode\nconversion error.\n\nExample:\n---\n// Reads $(D stdin) into a buffer\n// Dumps the buffer to $(D stdout) when it gets a \"q\"\n\nint main()\n{\n    string[] outBuf;\n    string buf;\n\n    while (stdin.readln(buf))\n    {\n        if (buf[0] == 'q')\n            break;\n\n        outBuf ~= buf.idup;\n    }\n\n    foreach (line; outBuf)\n    {\n        write(line);\n    }\n\n    return 0;\n}\n---\n\nThis method is more efficient than the one in the previous example\nbecause $(D stdin.readln(buf)) reuses (if possible) memory allocated\nby $(D buf), whereas $(D buf = stdin.readln()) makes a new memory allocation\nwith every line.\n",
        "line" : 918,
        "type" : "size_t(ref C[] buf, dchar terminator = '\\x0a')",
        "parameters" : [
         {
          "name" : "buf",
          "type" : "C[]",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "terminator",
          "deco" : "w",
          "default" : "'\\x0a'"
         }
        ],
        "endline" : 937
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : " ditto \n",
      "line" : 940,
      "name" : "readln",
      "parameters" : [
       {
        "name" : "C",
        "kind" : "type"
       },
       {
        "name" : "R",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "readln",
        "kind" : "function",
        "comment" : " ditto \n",
        "line" : 940,
        "type" : "size_t(ref C[] buf, R terminator)",
        "parameters" : [
         {
          "name" : "buf",
          "type" : "C[]",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "terminator",
          "type" : "R"
         }
        ],
        "endline" : 958
       }
      ]
     },
     {
      "name" : "__unittestL960_1574",
      "kind" : "function",
      "line" : 960,
      "endline" : 981
     },
     {
      "kind" : "template",
      "comment" : "\n Read data from the file according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n     \n",
      "line" : 981,
      "name" : "readf",
      "parameters" : [
       {
        "name" : "Data",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "readf",
        "kind" : "function",
        "comment" : "\n Read data from the file according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n     \n",
        "line" : 981,
        "type" : "uint(in char[] format, Data data)",
        "parameters" : [
         {
          "name" : "format",
          "type" : "char[]",
          "storageClass" : [
           "in"
          ]
         },
         {
          "name" : "data",
          "type" : "Data"
         }
        ],
        "endline" : 986
       }
      ]
     },
     {
      "name" : "__unittestL988_1575",
      "kind" : "function",
      "line" : 988,
      "endline" : 1003
     },
     {
      "name" : "tmpfile",
      "kind" : "function",
      "comment" : "\n Returns a temporary file by calling $(WEB\n cplusplus.com/reference/clibrary/cstdio/_tmpfile.html, _tmpfile).\n Note that the created file has no $(LREF name).\n",
      "line" : 1003,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZS3std5stdio4File",
      "endline" : 1008
     },
     {
      "name" : "wrapFile",
      "kind" : "function",
      "comment" : "\nUnsafe function that wraps an existing $(D FILE*). The resulting $(D\nFile) never takes the initiative in closing the file.\nNote that the created file has no $(LREF name)\n",
      "line" : 1014,
      "storageClass" : [
       "static"
      ],
      "deco" : "FPOS4core4stdc5stdio6_iobufZS3std5stdio4File",
      "originalType" : "File(FILE* f)",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "POS4core4stdc5stdio6_iobuf"
       }
      ],
      "endline" : 1018
     },
     {
      "name" : "getFP",
      "kind" : "function",
      "comment" : "\nReturns the $(D FILE*) corresponding to this object.\n \n",
      "line" : 1023,
      "deco" : "FNaZPOS4core4stdc5stdio6_iobuf",
      "originalType" : "pure FILE*()",
      "endline" : 1028
     },
     {
      "name" : "__unittestL1030_1576",
      "kind" : "function",
      "line" : 1030,
      "endline" : 1038
     },
     {
      "name" : "fileno",
      "kind" : "function",
      "comment" : "\nReturns the file number corresponding to this object.\n \n",
      "line" : 1038,
      "deco" : "xFZi",
      "endline" : 1042
     },
     {
      "kind" : "template",
      "comment" : "\nRange that reads one line at a time. \n ditto\n",
      "line" : 1048,
      "name" : "ByLine",
      "parameters" : [
       {
        "name" : "Char",
        "kind" : "type"
       },
       {
        "name" : "Terminator",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "ByLine",
        "kind" : "struct",
        "line" : 1048,
        "members" : [
         {
          "name" : "file",
          "kind" : "variable",
          "line" : 1049,
          "type" : "File"
         },
         {
          "name" : "line",
          "kind" : "variable",
          "line" : 1050,
          "type" : "Char[]"
         },
         {
          "name" : "terminator",
          "kind" : "variable",
          "line" : 1051,
          "type" : "Terminator"
         },
         {
          "name" : "keepTerminator",
          "kind" : "variable",
          "line" : 1052,
          "type" : "KeepTerminator"
         },
         {
          "name" : "first_call",
          "kind" : "variable",
          "line" : 1053,
          "deco" : "b",
          "init" : "true"
         },
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1055,
          "type" : "(File f, KeepTerminator kt = KeepTerminator.no, Terminator terminator = '\\x0a')",
          "parameters" : [
           {
            "name" : "f",
            "type" : "File"
           },
           {
            "name" : "kt",
            "type" : "KeepTerminator",
            "default" : "KeepTerminator.no"
           },
           {
            "name" : "terminator",
            "type" : "Terminator",
            "default" : "'\\x0a'"
           }
          ],
          "endline" : 1061
         },
         {
          "name" : "empty",
          "kind" : "function",
          "comment" : " Range primitive implementations.\n",
          "line" : 1064,
          "type" : "const bool()",
          "endline" : 1084
         },
         {
          "name" : "front",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 1087,
          "type" : "Char[]()",
          "endline" : 1095
         },
         {
          "name" : "popFront",
          "kind" : "function",
          "comment" : " Ditto\n",
          "line" : 1098,
          "type" : "void()",
          "endline" : 1113
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : "\nConvenience function that returns the $(D LinesReader) corresponding\nto this file. \n",
      "line" : 1119,
      "name" : "byLine",
      "parameters" : [
       {
        "name" : "Terminator",
        "kind" : "type",
        "defaultDeco" : "a"
       },
       {
        "name" : "Char",
        "kind" : "type",
        "defaultDeco" : "a"
       }
      ],
      "members" : [
       {
        "name" : "byLine",
        "kind" : "function",
        "comment" : "\nConvenience function that returns the $(D LinesReader) corresponding\nto this file. \n",
        "line" : 1119,
        "type" : "ByLine!(Char, Terminator)(KeepTerminator keepTerminator = KeepTerminator.no, Terminator terminator = '\\x0a')",
        "parameters" : [
         {
          "name" : "keepTerminator",
          "type" : "KeepTerminator",
          "default" : "KeepTerminator.no"
         },
         {
          "name" : "terminator",
          "type" : "Terminator",
          "default" : "'\\x0a'"
         }
        ],
        "endline" : 1124
       }
      ]
     },
     {
      "name" : "__unittestL1126_1577",
      "kind" : "function",
      "line" : 1126,
      "endline" : 1180
     },
     {
      "kind" : "template",
      "line" : 1180,
      "name" : "byRecord",
      "parameters" : [
       {
        "name" : "Fields",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "byRecord",
        "kind" : "function",
        "line" : 1182,
        "type" : "ByRecord!(Fields)(string format)",
        "parameters" : [
         {
          "name" : "format",
          "type" : "string"
         }
        ],
        "endline" : 1185
       }
      ]
     },
     {
      "name" : "__unittestL1188_1578",
      "kind" : "function",
      "line" : 1188,
      "endline" : 1210
     },
     {
      "name" : "ByChunk",
      "kind" : "struct",
      "comment" : "\n Range that reads a chunk at a time.\n     \n",
      "line" : 1211,
      "members" : [
       {
        "name" : "file_",
        "kind" : "variable",
        "protection" : "private",
        "line" : 1213,
        "deco" : "S3std5stdio4File",
        "offset" : 0
       },
       {
        "name" : "chunk_",
        "kind" : "variable",
        "protection" : "private",
        "line" : 1214,
        "deco" : "Ah",
        "offset" : 24
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1218,
        "deco" : "FNcS3std5stdio4FilemZS3std5stdio4File7ByChunk",
        "originalType" : "(File file, size_t size)",
        "parameters" : [
         {
          "name" : "file",
          "deco" : "S3std5stdio4File"
         },
         {
          "name" : "size",
          "deco" : "m"
         }
        ],
        "endline" : 1229
       },
       {
        "name" : "empty",
        "kind" : "function",
        "comment" : " Range primitive operations.\n",
        "line" : 1234,
        "storageClass" : [
         "nothrow",
         "@property"
        ],
        "deco" : "xFNbNdZb",
        "originalType" : "const bool()",
        "endline" : 1237
       },
       {
        "name" : "front",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 1242,
        "storageClass" : [
         "nothrow",
         "@property"
        ],
        "deco" : "FNbNdZAh",
        "originalType" : "ubyte[]()",
        "endline" : 1246
       },
       {
        "name" : "popFront",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 1250,
        "deco" : "FZv",
        "endline" : 1257
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "line" : 1211,
        "deco" : "FZv"
       },
       {
        "name" : "__cpctor",
        "kind" : "function",
        "line" : 1211,
        "deco" : "xFKxS3std5stdio4File7ByChunkZv",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "xS3std5stdio4File7ByChunk",
          "storageClass" : [
           "ref"
          ]
         }
        ]
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "line" : 1211,
        "deco" : "FNcS3std5stdio4File7ByChunkZS3std5stdio4File7ByChunk",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "S3std5stdio4File7ByChunk"
         }
        ]
       },
       {
        "name" : "__xopEquals",
        "kind" : "function",
        "storageClass" : [
         "static"
        ],
        "deco" : "FKxS3std5stdio4File7ByChunkKxS3std5stdio4File7ByChunkZb",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "xS3std5stdio4File7ByChunk",
          "storageClass" : [
           "ref"
          ]
         },
         {
          "name" : "q",
          "deco" : "xS3std5stdio4File7ByChunk",
          "storageClass" : [
           "ref"
          ]
         }
        ]
       }
      ]
     },
     {
      "name" : "byChunk",
      "kind" : "function",
      "comment" : "\nIterates through a file a chunk at a time by using $(D foreach).\n\nExample:\n\n---------\nvoid main()\n{\n  foreach (ubyte[] buffer; stdin.byChunk(4096))\n  {\n    ... use buffer ...\n  }\n}\n---------\n\nThe content of $(D buffer) is reused across calls. In the example\nabove, $(D buffer.length) is 4096 for all iterations, except for the\nlast one, in which case $(D buffer.length) may be less than 4096 (but\nalways greater than zero).\n\nIn case of an I/O error, an $(D StdioException) is thrown.\n \n",
      "line" : 1282,
      "deco" : "FmZS3std5stdio4File7ByChunk",
      "originalType" : "ByChunk(size_t chunkSize)",
      "parameters" : [
       {
        "name" : "chunkSize",
        "deco" : "m"
       }
      ],
      "endline" : 1285
     },
     {
      "name" : "__unittestL1287_1579",
      "kind" : "function",
      "line" : 1287,
      "endline" : 1313
     },
     {
      "name" : "LockingTextWriter",
      "kind" : "struct",
      "comment" : "\n$(D Range) that locks the file and allows fast writing to it.\n \n",
      "line" : 1314,
      "members" : [
       {
        "name" : "fps",
        "kind" : "variable",
        "line" : 1315,
        "deco" : "POS4core4stdc5stdio6_iobuf",
        "originalType" : "FILE*",
        "offset" : 0
       },
       {
        "name" : "handle",
        "kind" : "variable",
        "line" : 1316,
        "deco" : "PS4core4stdc5stdio6_iobuf",
        "offset" : 8
       },
       {
        "name" : "orientation",
        "kind" : "variable",
        "line" : 1317,
        "deco" : "i",
        "offset" : 16
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1319,
        "deco" : "FNcKS3std5stdio4FileZS3std5stdio4File17LockingTextWriter",
        "originalType" : "(ref File f)",
        "parameters" : [
         {
          "name" : "f",
          "deco" : "S3std5stdio4File",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 1326
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "line" : 1328,
        "deco" : "FZv",
        "endline" : 1333
       },
       {
        "kind" : "template",
        "comment" : " Range primitive implementations.\n",
        "line" : 1342,
        "name" : "put",
        "parameters" : [
         {
          "name" : "A",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "put",
          "kind" : "function",
          "comment" : " Range primitive implementations.\n",
          "line" : 1342,
          "type" : "void(A writeme)",
          "parameters" : [
           {
            "name" : "writeme",
            "type" : "A"
           }
          ],
          "endline" : 1362
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1367,
        "name" : "put",
        "parameters" : [
         {
          "name" : "C",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "put",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1367,
          "type" : "void(C c)",
          "parameters" : [
           {
            "name" : "c",
            "type" : "C"
           }
          ],
          "endline" : 1441
         }
        ]
       },
       {
        "name" : "__cpctor",
        "kind" : "function",
        "line" : 1335,
        "deco" : "xFKxS3std5stdio4File17LockingTextWriterZv",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "xS3std5stdio4File17LockingTextWriter",
          "storageClass" : [
           "ref"
          ]
         }
        ]
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "line" : 1314,
        "deco" : "FNcS3std5stdio4File17LockingTextWriterZS3std5stdio4File17LockingTextWriter",
        "parameters" : [
         {
          "name" : "p",
          "deco" : "S3std5stdio4File17LockingTextWriter"
         }
        ]
       }
      ]
     },
     {
      "name" : "lockingTextWriter",
      "kind" : "function",
      "comment" : " Convenience function.\n",
      "line" : 1445,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZS3std5stdio4File17LockingTextWriter",
      "originalType" : "LockingTextWriter()",
      "endline" : 1448
     },
     {
      "name" : "size",
      "kind" : "function",
      "comment" : " Get the size of the file, ulong.max if file is not searchable, but still throws if an actual error occurs.\n",
      "line" : 1451,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "ulong()",
      "endline" : 1458
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 336,
      "deco" : "xFKxS3std5stdio4FileZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio4File",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std5stdio4FileKxS3std5stdio4FileZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio4File",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std5stdio4File",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1461_1580",
    "kind" : "function",
    "line" : 1461,
    "endline" : 1471
   },
   {
    "name" : "LockingTextReader",
    "kind" : "struct",
    "line" : 1472,
    "members" : [
     {
      "name" : "_f",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1473,
      "deco" : "S3std5stdio4File",
      "offset" : 0
     },
     {
      "name" : "_crt",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1474,
      "deco" : "w",
      "offset" : 24
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1476,
      "deco" : "FNcS3std5stdio4FileZS3std5stdio17LockingTextReader",
      "originalType" : "(File f)",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "S3std5stdio4File"
       }
      ],
      "endline" : 1481
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 1488,
      "deco" : "FZv",
      "endline" : 1492
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 1494,
      "deco" : "FS3std5stdio17LockingTextReaderZv",
      "parameters" : [
       {
        "name" : "r",
        "deco" : "S3std5stdio17LockingTextReader"
       }
      ],
      "endline" : 1497
     },
     {
      "name" : "empty",
      "kind" : "function",
      "line" : 1499,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1516
     },
     {
      "name" : "front",
      "kind" : "function",
      "line" : 1518,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZw",
      "originalType" : "dchar()",
      "endline" : 1522
     },
     {
      "name" : "popFront",
      "kind" : "function",
      "line" : 1524,
      "deco" : "FZv",
      "endline" : 1532
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 1488,
      "deco" : "FZv"
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 1488,
      "deco" : "FZv"
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 1483,
      "deco" : "xFKxS3std5stdio17LockingTextReaderZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio17LockingTextReader",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std5stdio17LockingTextReaderKxS3std5stdio17LockingTextReaderZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio17LockingTextReader",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std5stdio17LockingTextReader",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1540_1581",
    "kind" : "function",
    "line" : 1540,
    "endline" : 1557
   },
   {
    "name" : "writefx",
    "kind" : "function",
    "protection" : "private",
    "line" : 1558,
    "deco" : "FPOS4core4stdc5stdio6_iobufAC8TypeInfoPviZv",
    "originalType" : "void(FILE* fps, TypeInfo[] arguments, void* argptr, int newline = false)",
    "parameters" : [
     {
      "name" : "fps",
      "deco" : "POS4core4stdc5stdio6_iobuf"
     },
     {
      "name" : "arguments",
      "deco" : "AC8TypeInfo"
     },
     {
      "name" : "argptr",
      "deco" : "Pv"
     },
     {
      "name" : "newline",
      "deco" : "i",
      "default" : "0"
     }
    ],
    "endline" : 1625
   },
   {
    "kind" : "template",
    "comment" : "\n Indicates whether $(D T) is a file handle of some kind.\n \n",
    "line" : 1630,
    "name" : "isFileHandle",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isFileHandle",
      "kind" : "variable",
      "line" : 1633,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(T : FILE*) || is(T : File)"
     }
    ]
   },
   {
    "name" : "__unittestL1636_1582",
    "kind" : "function",
    "line" : 1636,
    "endline" : 1646
   },
   {
    "name" : "isStreamingDevice",
    "kind" : "alias",
    "comment" : "\n $(RED Scheduled for deprecation in January 2013.\n       Please use $(D isFileHandle) instead.)\n \n",
    "line" : 1646
   },
   {
    "kind" : "template",
    "comment" : "\nFor each argument $(D arg) in $(D args), format the argument (as per\n$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting\nstring to $(D args[0]). A call without any arguments will fail to\ncompile.\n\nThrows: In case of an I/O error, throws an $(D StdioException).\n \n",
    "line" : 1656,
    "name" : "write",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "write",
      "kind" : "function",
      "comment" : "\nFor each argument $(D arg) in $(D args), format the argument (as per\n$(LINK2 std_conv.html, to!(string)(arg))) and write the resulting\nstring to $(D args[0]). A call without any arguments will fail to\ncompile.\n\nThrows: In case of an I/O error, throws an $(D StdioException).\n \n",
      "line" : 1656,
      "type" : "void(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 1659
     }
    ]
   },
   {
    "name" : "__unittestL1661_1583",
    "kind" : "function",
    "line" : 1661,
    "endline" : 1690
   },
   {
    "kind" : "template",
    "comment" : "\n Equivalent to $(D write(args, '\\n')).  Calling $(D writeln) without\n arguments is valid and just prints a newline to the standard\n output.\n \n",
    "line" : 1690,
    "name" : "writeln",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "writeln",
      "kind" : "function",
      "comment" : "\n Equivalent to $(D write(args, '\\n')).  Calling $(D writeln) without\n arguments is valid and just prints a newline to the standard\n output.\n \n",
      "line" : 1690,
      "type" : "void(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 1710
     }
    ]
   },
   {
    "name" : "__unittestL1712_1584",
    "kind" : "function",
    "line" : 1712,
    "endline" : 1724
   },
   {
    "name" : "__unittestL1724_1585",
    "kind" : "function",
    "line" : 1724,
    "endline" : 1768
   },
   {
    "name" : "__unittestL1768_1586",
    "kind" : "function",
    "line" : 1768,
    "endline" : 1842
   },
   {
    "kind" : "template",
    "comment" : "\n If the first argument $(D args[0]) is a $(D FILE*), use\n $(LINK2 std_format.html#format-string, the format specifier) in\n $(D args[1]) to control the formatting of $(D\n args[2..$]), and write the resulting string to $(D args[0]).\n If $(D arg[0]) is not a $(D FILE*), the call is\n equivalent to $(D writef(stdout, args)).\n\n\nIMPORTANT:\n\nNew behavior starting with D 2.006: unlike previous versions,\n$(D writef) (and also $(D writefln)) only scans its first\nstring argument for format specifiers, but not subsequent string\narguments. This decision was made because the old behavior made it\nunduly hard to simply print string variables that occasionally\nembedded percent signs.\n\nAlso new starting with 2.006 is support for positional\nparameters with\n$(LINK2 http://opengroup.org/onlinepubs/009695399/functions/printf.html,\nPOSIX) syntax.\n\nExample:\n\n-------------------------\nwritef(\"Date: %2$s %1$s\", \"October\", 5); // \"Date: 5 October\"\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the popFront parameter after\nthe largest positional parameter already used.\n\nNew starting with 2.008: raw format specifiers. Using the \"%r\"\nspecifier makes $(D writef) simply write the binary\nrepresentation of the argument. Use \"%-r\" to write numbers in little\nendian format, \"%+r\" to write numbers in big endian format, and \"%r\"\nto write numbers in platform-native format.\n\n",
    "line" : 1842,
    "name" : "writef",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "writef",
      "kind" : "function",
      "comment" : "\n If the first argument $(D args[0]) is a $(D FILE*), use\n $(LINK2 std_format.html#format-string, the format specifier) in\n $(D args[1]) to control the formatting of $(D\n args[2..$]), and write the resulting string to $(D args[0]).\n If $(D arg[0]) is not a $(D FILE*), the call is\n equivalent to $(D writef(stdout, args)).\n\n\nIMPORTANT:\n\nNew behavior starting with D 2.006: unlike previous versions,\n$(D writef) (and also $(D writefln)) only scans its first\nstring argument for format specifiers, but not subsequent string\narguments. This decision was made because the old behavior made it\nunduly hard to simply print string variables that occasionally\nembedded percent signs.\n\nAlso new starting with 2.006 is support for positional\nparameters with\n$(LINK2 http://opengroup.org/onlinepubs/009695399/functions/printf.html,\nPOSIX) syntax.\n\nExample:\n\n-------------------------\nwritef(\"Date: %2$s %1$s\", \"October\", 5); // \"Date: 5 October\"\n------------------------\n\nThe positional and non-positional styles can be mixed in the same\nformat string. (POSIX leaves this behavior undefined.) The internal\ncounter for non-positional parameters tracks the popFront parameter after\nthe largest positional parameter already used.\n\nNew starting with 2.008: raw format specifiers. Using the \"%r\"\nspecifier makes $(D writef) simply write the binary\nrepresentation of the argument. Use \"%-r\" to write numbers in little\nendian format, \"%+r\" to write numbers in big endian format, and \"%r\"\nto write numbers in platform-native format.\n\n",
      "line" : 1842,
      "type" : "void(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 1845
     }
    ]
   },
   {
    "name" : "__unittestL1847_1587",
    "kind" : "function",
    "line" : 1847,
    "endline" : 1870
   },
   {
    "kind" : "template",
    "comment" : "\n Equivalent to $(D writef(args, '\\n')).\n \n",
    "line" : 1870,
    "name" : "writefln",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "writefln",
      "kind" : "function",
      "comment" : "\n Equivalent to $(D writef(args, '\\n')).\n \n",
      "line" : 1870,
      "type" : "void(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 1873
     }
    ]
   },
   {
    "name" : "__unittestL1875_1588",
    "kind" : "function",
    "line" : 1875,
    "endline" : 1917
   },
   {
    "kind" : "template",
    "comment" : "\n Read data from $(D stdin) according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n \n",
    "line" : 1917,
    "name" : "readf",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "readf",
      "kind" : "function",
      "comment" : "\n Read data from $(D stdin) according to the specified\n $(LINK2 std_format.html#format-string, format specifier) using\n $(XREF format,formattedRead).\n \n",
      "line" : 1917,
      "type" : "uint(in char[] format, A args)",
      "parameters" : [
       {
        "name" : "format",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "args",
        "type" : "A"
       }
      ],
      "endline" : 1920
     }
    ]
   },
   {
    "name" : "__unittestL1922_1589",
    "kind" : "function",
    "line" : 1922,
    "endline" : 1957
   },
   {
    "name" : "readln",
    "kind" : "function",
    "comment" : "\n Read line from stream $(D fp).\n Returns:\n        $(D null) for end of file,\n        $(D char[]) for line read from $(D fp), including terminating character\n Params:\n        $(D fp) = input stream\n        $(D terminator) = line terminator, '\\n' by default\n Throws:\n        $(D StdioException) on error\n Example:\n        Reads $(D stdin) and writes it to $(D stdout).\n---\nimport std.stdio;\n\nint main()\n{\n    string buf;\n    while ((buf = stdin.readln()) !is null)\n        write(buf);\n    return 0;\n}\n---\n",
    "line" : 1957,
    "deco" : "FwZAya",
    "parameters" : [
     {
      "name" : "terminator",
      "deco" : "w",
      "default" : "'\\x0a'"
     }
    ],
    "endline" : 1960
   },
   {
    "name" : "readln",
    "kind" : "function",
    "comment" : " ditto \n",
    "line" : 1963,
    "deco" : "FKAawZm",
    "originalType" : "size_t(ref char[] buf, dchar terminator = '\\x0a')",
    "parameters" : [
     {
      "name" : "buf",
      "deco" : "Aa",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "terminator",
      "deco" : "w",
      "default" : "'\\x0a'"
     }
    ],
    "endline" : 1966
   },
   {
    "name" : "fopen",
    "kind" : "function",
    "protection" : "private",
    "line" : 1973,
    "deco" : "FxAaxAaZPOS4core4stdc5stdio6_iobuf",
    "originalType" : "FILE*(in char[] name, in char[] mode = \"r\")",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "mode",
      "deco" : "xAa",
      "default" : "\"r\""
     }
    ],
    "endline" : 1993
   },
   {
    "name" : "popen",
    "kind" : "function",
    "comment" : "\n Convenience function that forwards to $(D std.c.stdio.popen)\n with appropriately-constructed C-style strings.\n     \n",
    "line" : 2001,
    "deco" : "FxAaxAaZPOS4core4stdc5stdio6_iobuf",
    "originalType" : "FILE*(in char[] name, in char[] mode = \"r\")",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "mode",
      "deco" : "xAa",
      "default" : "\"r\""
     }
    ],
    "endline" : 2004
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2011,
    "name" : "binaryWrite",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "binaryWrite",
      "kind" : "function",
      "line" : 2011,
      "type" : "void(FILE* f, T obj)",
      "parameters" : [
       {
        "name" : "f",
        "type" : "FILE*"
       },
       {
        "name" : "obj",
        "type" : "T"
       }
      ],
      "endline" : 2015
     }
    ]
   },
   {
    "name" : "lines",
    "kind" : "struct",
    "comment" : "\n Iterates through the lines of a file by using $(D foreach).\n\n Example:\n\n---------\nvoid main()\n{\n  foreach (string line; lines(stdin))\n  {\n    ... use line ...\n  }\n}\n---------\n The line terminator ('\\n' by default) is part of the string read (it\ncould be missing in the last line of the file). Several types are\nsupported for $(D line), and the behavior of $(D lines)\nchanges accordingly:\n\n$(OL $(LI If $(D line) has type $(D string), $(D\nwstring), or $(D dstring), a new string of the respective type\nis allocated every read.) $(LI If $(D line) has type $(D\nchar[]), $(D wchar[]), $(D dchar[]), the line's content\nwill be reused (overwritten) across reads.) $(LI If $(D line)\nhas type $(D immutable(ubyte)[]), the behavior is similar to\ncase (1), except that no UTF checking is attempted upon input.) $(LI\nIf $(D line) has type $(D ubyte[]), the behavior is\nsimilar to case (2), except that no UTF checking is attempted upon\ninput.))\n\nIn all cases, a two-symbols versions is also accepted, in which case\nthe first symbol (of integral type, e.g. $(D ulong) or $(D\nuint)) tracks the zero-based number of the current line.\n\nExample:\n----\n  foreach (ulong i, string line; lines(stdin))\n  {\n    ... use line ...\n  }\n----\n\n In case of an I/O error, an $(D StdioException) is thrown.\n \n",
    "line" : 2063,
    "members" : [
     {
      "name" : "f",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2064,
      "deco" : "S3std5stdio4File",
      "offset" : 0
     },
     {
      "name" : "terminator",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2065,
      "deco" : "w",
      "init" : "'\\x0a'",
      "offset" : 24
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2068,
      "deco" : "FNcS3std5stdio4FilewZS3std5stdio5lines",
      "originalType" : "(File f, dchar terminator = '\\x0a')",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "S3std5stdio4File"
       },
       {
        "name" : "terminator",
        "deco" : "w",
        "default" : "'\\x0a'"
       }
      ],
      "endline" : 2072
     },
     {
      "kind" : "template",
      "line" : 2086,
      "name" : "opApply",
      "parameters" : [
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 2086,
        "type" : "int(scope D dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "D",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 2129
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2131,
      "name" : "opApplyRaw",
      "parameters" : [
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opApplyRaw",
        "kind" : "function",
        "line" : 2131,
        "type" : "int(scope D dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "D",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 2171
       }
      ]
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 2063,
      "deco" : "FZv"
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 2063,
      "deco" : "xFKxS3std5stdio5linesZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio5lines",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 2063,
      "deco" : "FNcS3std5stdio5linesZS3std5stdio5lines",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std5stdio5lines"
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std5stdio5linesKxS3std5stdio5linesZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio5lines",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std5stdio5lines",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2174_1590",
    "kind" : "function",
    "line" : 2174,
    "endline" : 2310
   },
   {
    "name" : "chunks",
    "kind" : "struct",
    "comment" : "\nIterates through a file a chunk at a time by using $(D\nforeach).\n\nExample:\n\n---------\nvoid main()\n{\n  foreach (ubyte[] buffer; chunks(stdin, 4096))\n  {\n    ... use buffer ...\n  }\n}\n---------\n\nThe content of $(D buffer) is reused across calls. In the\n example above, $(D buffer.length) is 4096 for all iterations,\n except for the last one, in which case $(D buffer.length) may\n be less than 4096 (but always greater than zero).\n\n In case of an I/O error, an $(D StdioException) is thrown.\n",
    "line" : 2311,
    "members" : [
     {
      "name" : "f",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2312,
      "deco" : "S3std5stdio4File",
      "offset" : 0
     },
     {
      "name" : "size",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2313,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 24
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2316,
      "deco" : "FNcS3std5stdio4FilemZS3std5stdio6chunks",
      "originalType" : "(File f, size_t size)",
      "parameters" : [
       {
        "name" : "f",
        "deco" : "S3std5stdio4File"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2325
     },
     {
      "kind" : "template",
      "line" : 2336,
      "name" : "opApply",
      "parameters" : [
       {
        "name" : "D",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opApply",
        "kind" : "function",
        "line" : 2336,
        "type" : "int(scope D dg)",
        "parameters" : [
         {
          "name" : "dg",
          "type" : "D",
          "storageClass" : [
           "scope"
          ]
         }
        ],
        "endline" : 2365
       }
      ]
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 2311,
      "deco" : "FZv"
     },
     {
      "name" : "__cpctor",
      "kind" : "function",
      "line" : 2311,
      "deco" : "xFKxS3std5stdio6chunksZv",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio6chunks",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     },
     {
      "name" : "opAssign",
      "kind" : "function",
      "line" : 2311,
      "deco" : "FNcS3std5stdio6chunksZS3std5stdio6chunks",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "S3std5stdio6chunks"
       }
      ]
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std5stdio6chunksKxS3std5stdio6chunksZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std5stdio6chunks",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std5stdio6chunks",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2368_1591",
    "kind" : "function",
    "line" : 2368,
    "endline" : 2401
   },
   {
    "name" : "StdioException",
    "kind" : "class",
    "comment" : "\n Thrown if I/O errors happen.\n \n",
    "line" : 2401,
    "base" : "Exception",
    "members" : [
     {
      "name" : "errno",
      "kind" : "variable",
      "comment" : " Operating system error code.\n",
      "line" : 2404,
      "deco" : "k",
      "offset" : 72
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\nInitialize with a message and an error code. \n",
      "line" : 2408,
      "deco" : "FAyakZC3std5stdio14StdioException",
      "originalType" : "(string message, uint e = .errno)",
      "parameters" : [
       {
        "name" : "message",
        "deco" : "Aya"
       },
       {
        "name" : "e",
        "deco" : "k",
        "default" : "cast(uint)errno()"
       }
      ],
      "endline" : 2433
     },
     {
      "name" : "opCall",
      "kind" : "function",
      "comment" : " Convenience functions that throw an $(D StdioException). \n",
      "line" : 2436,
      "storageClass" : [
       "static"
      ],
      "deco" : "FAyaZv",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2439
     },
     {
      "name" : "opCall",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 2442,
      "storageClass" : [
       "static"
      ],
      "deco" : "FZv",
      "endline" : 2445
     }
    ]
   },
   {
    "name" : "std_stdio_static_this",
    "kind" : "function",
    "line" : 2448,
    "deco" : "UZv",
    "endline" : 2462
   },
   {
    "name" : "stdin",
    "kind" : "variable",
    "comment" : " The standard input stream.\n",
    "line" : 2467,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "S3std5stdio4File"
   },
   {
    "name" : "stdout",
    "kind" : "variable",
    "comment" : " The standard output stream.\n",
    "line" : 2468,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "S3std5stdio4File"
   },
   {
    "name" : "stderr",
    "kind" : "variable",
    "comment" : " The standard error stream.\n",
    "line" : 2469,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "S3std5stdio4File"
   },
   {
    "name" : "__unittestL2472_1592",
    "kind" : "function",
    "line" : 2472,
    "endline" : 2493
   },
   {
    "name" : "readlnImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 2671,
    "deco" : "FPOS4core4stdc5stdio6_iobufKAawZm",
    "originalType" : "size_t(FILE* fps, ref char[] buf, dchar terminator = '\\x0a')",
    "parameters" : [
     {
      "name" : "fps",
      "deco" : "POS4core4stdc5stdio6_iobuf"
     },
     {
      "name" : "buf",
      "deco" : "Aa",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "terminator",
      "deco" : "w",
      "default" : "'\\x0a'"
     }
    ],
    "endline" : 2753
   },
   {
    "name" : "std.c.linux.linux",
    "kind" : "static import",
    "comment" : " Experimental network access via the File interface\n\n        Opens a TCP connection to the given host and port, then returns\n        a File struct with read and write access through the same interface\n        as any other file (meaning writef and the byLine ranges work!).\n\n        Authors:\n                Adam D. Ruppe\n\n        Bugs:\n                Only works on Linux\n",
    "line" : 2865,
    "protection" : "private",
    "alias" : "linux"
   },
   {
    "name" : "std.c.linux.socket",
    "kind" : "static import",
    "comment" : " Experimental network access via the File interface\n\n        Opens a TCP connection to the given host and port, then returns\n        a File struct with read and write access through the same interface\n        as any other file (meaning writef and the byLine ranges work!).\n\n        Authors:\n                Adam D. Ruppe\n\n        Bugs:\n                Only works on Linux\n",
    "line" : 2866,
    "protection" : "private",
    "alias" : "sock"
   },
   {
    "name" : "openNetwork",
    "kind" : "function",
    "comment" : " Experimental network access via the File interface\n\n        Opens a TCP connection to the given host and port, then returns\n        a File struct with read and write access through the same interface\n        as any other file (meaning writef and the byLine ranges work!).\n\n        Authors:\n                Adam D. Ruppe\n\n        Bugs:\n                Only works on Linux\n",
    "line" : 2868,
    "deco" : "FAyatZS3std5stdio4File",
    "parameters" : [
     {
      "name" : "host",
      "deco" : "Aya"
     },
     {
      "name" : "port",
      "deco" : "t"
     }
    ],
    "endline" : 2894
   }
  ]
 },
 {
  "name" : "std.stream",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/stream.d",
  "comment" : "\n $(RED Warning: This module is considered out-dated and not up to Phobos'\n       current standards. It will remain until we have a suitable replacement,\n       but be aware that it will not remain long term.)\n\n Source:    $(PHOBOSSRC std/_stream.d)\n Macros:\n      WIKI = Phobos/StdStream\n \n",
  "members" : [
   {
    "name" : "StreamException",
    "kind" : "class",
    "comment" : " A base class for stream exceptions.\n",
    "line" : 48,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct a StreamException with given error message.\n",
      "line" : 50,
      "deco" : "FAyaZC3std6stream15StreamException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 50
     }
    ]
   },
   {
    "name" : "ReadException",
    "kind" : "class",
    "comment" : " Thrown when unable to read data from Stream.\n",
    "line" : 54,
    "base" : "StreamException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct a ReadException with given error message.\n",
      "line" : 56,
      "deco" : "FAyaZC3std6stream13ReadException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 56
     }
    ]
   },
   {
    "name" : "WriteException",
    "kind" : "class",
    "comment" : " Thrown when unable to write data to Stream.\n",
    "line" : 60,
    "base" : "StreamException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct a WriteException with given error message.\n",
      "line" : 62,
      "deco" : "FAyaZC3std6stream14WriteException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 62
     }
    ]
   },
   {
    "name" : "SeekException",
    "kind" : "class",
    "comment" : " Thrown when unable to move Stream pointer.\n",
    "line" : 66,
    "base" : "StreamException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct a SeekException with given error message.\n",
      "line" : 68,
      "deco" : "FAyaZC3std6stream13SeekException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 68
     }
    ]
   },
   {
    "name" : "SeekPos",
    "kind" : "enum",
    "line" : 72,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "Set",
      "kind" : "enum member",
      "line" : 73
     },
     {
      "name" : "Current",
      "kind" : "enum member",
      "line" : 74
     },
     {
      "name" : "End",
      "kind" : "enum member",
      "line" : 75
     }
    ]
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 79,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 80,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 81,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 82,
    "protection" : "private"
   },
   {
    "name" : "std.system",
    "kind" : "import",
    "line" : 83,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 84,
    "protection" : "private"
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 85,
    "protection" : "private"
   },
   {
    "name" : "core.vararg",
    "kind" : "import",
    "line" : 86,
    "protection" : "private"
   },
   {
    "name" : "InputStream",
    "kind" : "interface",
    "comment" : " InputStream is the interface for readable streams.\n",
    "line" : 95,
    "members" : [
     {
      "name" : "readExact",
      "kind" : "function",
      "comment" : "\n Read exactly size bytes into the buffer.\n\n Throws a ReadException if it is not correct.\n   \n",
      "line" : 102,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FPvmZv",
      "originalType" : "void(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : "\n Read a block of data big enough to fill the given array buffer.\n\n Returns: the actual number of bytes read. Unfilled bytes are not modified.\n   \n",
      "line" : 109,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAhZm",
      "originalType" : "size_t(ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : "\n Read a basic type or counted string.\n\n Throw a ReadException if it could not be read.\n Outside of byte, ubyte, and char, the format is\n implementation-specific and should not be used except as opposite actions\n to write.\n   \n",
      "line" : 119,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJgZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "g",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 120,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJhZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "h",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 121,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJsZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "s",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 122,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJtZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "t",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 123,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJiZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 124,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJkZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 125,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJlZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "l",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 126,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJmZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "m",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 127,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJfZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "f",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 128,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJdZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "d",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 129,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJeZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "e",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 130,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJoZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "o",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 131,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJpZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "p",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 132,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJjZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "j",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 133,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJqZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "q",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 134,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJrZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "r",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 135,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJcZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "c",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 136,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJaZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "a",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 137,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJuZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "u",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 138,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJwZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "w",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 141,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJAaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aa",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 144,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FJAuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Au",
        "storageClass" : [
         "out"
        ]
       }
      ]
     },
     {
      "name" : "readLine",
      "kind" : "function",
      "comment" : "\n Read a line that is terminated with some combination of carriage return and\n line feed or end-of-file.\n\n The terminators are not included. The wchar version\n is identical. The optional buffer parameter is filled (reallocating\n it if necessary) and a slice of the result is returned.\n   \n",
      "line" : 154,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FZAa"
     },
     {
      "name" : "readLine",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 155,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAaZAa",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "Aa"
       }
      ]
     },
     {
      "name" : "readLineW",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 156,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FZAu"
     },
     {
      "name" : "readLineW",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 157,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAuZAu",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "Au"
       }
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : "\n Overload foreach statements to read the stream line by line and call the\n supplied delegate with each line or with each line with line number.\n\n The string passed in line may be reused between calls to the delegate.\n Line numbering starts at 1.\n Breaking out of the foreach will leave the stream\n position at the beginning of the next line to be read.\n For example, to echo a file line-by-line with line numbers run:\n ------------------------------------\n Stream file = new BufferedFile(\"sample.txt\");\n foreach(ulong n, char[] line; file)\n {\n     writefln(\"line %d: %s\", n, line);\n }\n file.close();\n ------------------------------------\n   \n",
      "line" : 179,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FMDFKAaZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKAaZi",
        "storageClass" : [
         "scope"
        ]
       }
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 180,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FMDFKmKAaZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKmKAaZi",
        "storageClass" : [
         "scope"
        ]
       }
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 181,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FMDFKAuZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKAuZi",
        "storageClass" : [
         "scope"
        ]
       }
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 182,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FMDFKmKAuZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKmKAuZi",
        "storageClass" : [
         "scope"
        ]
       }
      ]
     },
     {
      "name" : "readString",
      "kind" : "function",
      "comment" : " Read a string of the given length,\n throwing ReadException if there was a problem.\n",
      "line" : 186,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FmZAa",
      "originalType" : "char[](size_t length)",
      "parameters" : [
       {
        "name" : "length",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "readStringW",
      "kind" : "function",
      "comment" : "\n Read a string of the given length, throwing ReadException if there was a\n problem.\n\n The file format is implementation-specific and should not be used\n except as opposite actions to <b>write</b>.\n   \n",
      "line" : 196,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FmZAu",
      "originalType" : "wchar[](size_t length)",
      "parameters" : [
       {
        "name" : "length",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "getc",
      "kind" : "function",
      "comment" : "\n Read and return the next character in the stream.\n\n This is the only method that will handle ungetc properly.\n getcw's format is implementation-specific.\n If EOF is reached then getc returns char.init and getcw returns wchar.init.\n   \n",
      "line" : 207,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FZa"
     },
     {
      "name" : "getcw",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 208,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FZu"
     },
     {
      "name" : "ungetc",
      "kind" : "function",
      "comment" : "\n Push a character back onto the stream.\n\n They will be returned in first-in last-out order from getc/getcw.\n Only has effect on further calls to getc() and getcw().\n   \n",
      "line" : 216,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FaZa",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "a"
       }
      ]
     },
     {
      "name" : "ungetcw",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 217,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FuZu",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "u"
       }
      ]
     },
     {
      "name" : "vreadf",
      "kind" : "function",
      "comment" : "\n Scan a string from the input using a similar form to C's scanf\n and <a href=\"std_format.html\">std.format</a>.\n\n An argument of type string is interpreted as a format string.\n All other arguments must be pointer types.\n If a format string is not present a default will be supplied computed from\n the base type of the pointer type. An argument of type string* is filled\n (possibly with appending characters) and a slice of the result is assigned\n back into the argument. For example the following readf statements\n are equivalent:\n --------------------------\n int x;\n double y;\n string s;\n file.readf(&x, \" hello \", &y, &s);\n file.readf(\"%d hello %f %s\", &x, &y, &s);\n file.readf(\"%d hello %f\", &x, &y, \"%s\", &s);\n --------------------------\n   \n",
      "line" : 239,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAC8TypeInfoPvZi",
      "parameters" : [
       {
        "name" : "arguments",
        "deco" : "AC8TypeInfo"
       },
       {
        "name" : "args",
        "deco" : "Pv"
       }
      ]
     },
     {
      "name" : "readf",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 240,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FYi"
     },
     {
      "name" : "available",
      "kind" : "function",
      "comment" : " Retrieve the number of bytes available for immediate reading.\n",
      "line" : 243,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "size_t()"
     },
     {
      "name" : "eof",
      "kind" : "function",
      "comment" : "\n Return whether the current file position is the same as the end of the\n file.\n\n This does not require actually reading past the end, as with stdio. For\n non-seekable streams this might only return true after attempting to read\n past the end.\n   \n",
      "line" : 254,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()"
     },
     {
      "name" : "isOpen",
      "kind" : "function",
      "comment" : " Return true if the stream is currently open.\n",
      "line" : 256,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()"
     }
    ]
   },
   {
    "name" : "OutputStream",
    "kind" : "interface",
    "comment" : " Interface for writable streams.\n",
    "line" : 260,
    "members" : [
     {
      "name" : "writeExact",
      "kind" : "function",
      "comment" : "\n Write exactly size bytes from buffer, or throw a WriteException if that\n could not be done.\n   \n",
      "line" : 266,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FxPvmZv",
      "originalType" : "void(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : "\n Write as much of the buffer as possible,\n returning the number of bytes written.\n   \n",
      "line" : 272,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxhZm",
      "originalType" : "size_t(const(ubyte)[] buffer)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Axh"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : "\n Write a basic type.\n\n Outside of byte, ubyte, and char, the format is implementation-specific\n and should only be used in conjunction with read.\n Throw WriteException on error.\n   \n",
      "line" : 281,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FgZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "g"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 282,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FhZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "h"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 283,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FsZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "s"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 284,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FtZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "t"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 285,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "i"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 286,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FkZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 287,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FlZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "l"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 288,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FmZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 289,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FfZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "f"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 290,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FdZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "d"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 291,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FeZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "e"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 292,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FoZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "o"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 293,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FpZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "p"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 294,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FjZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "j"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 295,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FqZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "q"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 296,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FrZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "r"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 297,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FcZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "c"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 298,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FaZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "a"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 299,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FuZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "u"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 300,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FwZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "w"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : "\n Writes a string, together with its length.\n\n The format is implementation-specific\n and should only be used in conjunction with read.\n Throw WriteException on error.\n   \n",
      "line" : 309,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 310,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ]
     },
     {
      "name" : "writeLine",
      "kind" : "function",
      "comment" : "\n Write a line of text,\n appending the line with an operating-system-specific line ending.\n\n Throws WriteException on error.\n   \n",
      "line" : 318,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ]
     },
     {
      "name" : "writeLineW",
      "kind" : "function",
      "comment" : "\n Write a line of text,\n appending the line with an operating-system-specific line ending.\n\n The format is implementation-specific.\n Throws WriteException on error.\n   \n",
      "line" : 327,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ]
     },
     {
      "name" : "writeString",
      "kind" : "function",
      "comment" : "\n Write a string of text.\n\n Throws WriteException if it could not be fully written.\n   \n",
      "line" : 334,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ]
     },
     {
      "name" : "writeStringW",
      "kind" : "function",
      "comment" : "\n Write a string of text.\n\n The format is implementation-specific.\n Throws WriteException if it could not be fully written.\n   \n",
      "line" : 342,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ]
     },
     {
      "name" : "vprintf",
      "kind" : "function",
      "comment" : "\n Print a formatted string into the stream using printf-style syntax,\n returning the number of bytes written.\n   \n",
      "line" : 348,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxaPvZm",
      "originalType" : "size_t(const(char)[] format, va_list args)",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "Axa"
       },
       {
        "name" : "args",
        "deco" : "Pv"
       }
      ]
     },
     {
      "name" : "printf",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 349,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAxaYm",
      "originalType" : "size_t(const(char)[] format, ...)",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "Axa"
       }
      ]
     },
     {
      "name" : "writef",
      "kind" : "function",
      "comment" : "\n Print a formatted string into the stream using writef-style syntax.\n References: <a href=\"std_format.html\">std.format</a>.\n Returns: self to chain with other stream commands like flush.\n   \n",
      "line" : 356,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FYC3std6stream12OutputStream"
     },
     {
      "name" : "writefln",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 357,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FYC3std6stream12OutputStream"
     },
     {
      "name" : "writefx",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 358,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FAC8TypeInfoPviZC3std6stream12OutputStream",
      "originalType" : "OutputStream(TypeInfo[] arguments, void* argptr, int newline = false)",
      "parameters" : [
       {
        "name" : "arguments",
        "deco" : "AC8TypeInfo"
       },
       {
        "name" : "argptr",
        "deco" : "Pv"
       },
       {
        "name" : "newline",
        "deco" : "i",
        "default" : "0"
       }
      ]
     },
     {
      "name" : "flush",
      "kind" : "function",
      "comment" : " Flush pending output if appropriate.\n",
      "line" : 360,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FZv"
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : " Close the stream, flushing output if appropriate.\n",
      "line" : 361,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FZv"
     },
     {
      "name" : "isOpen",
      "kind" : "function",
      "comment" : " Return true if the stream is currently open.\n",
      "line" : 362,
      "storageClass" : [
       "abstract",
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()"
     }
    ]
   },
   {
    "name" : "Stream",
    "kind" : "class",
    "comment" : "\n Stream is the base abstract class from which the other stream classes derive.\n\n Stream's byte order is the format native to the computer.\n\n Reading:\n These methods require that the readable flag be set.\n Problems with reading result in a ReadException being thrown.\n Stream implements the InputStream interface in addition to the\n readBlock method.\n\n Writing:\n These methods require that the writeable flag be set. Problems with writing\n result in a WriteException being thrown. Stream implements the OutputStream\n interface in addition to the following methods:\n writeBlock\n copyFrom\n copyFrom\n\n Seeking:\n These methods require that the seekable flag be set.\n Problems with seeking result in a SeekException being thrown.\n seek, seekSet, seekCur, seekEnd, position, size, toString, toHash\n \n",
    "line" : 392,
    "interfaces" : [
     "InputStream",
     "OutputStream"
    ],
    "members" : [
     {
      "name" : "std.string",
      "kind" : "import",
      "line" : 393,
      "protection" : "private"
     },
     {
      "name" : "std.digest.crc",
      "kind" : "import",
      "line" : 393,
      "protection" : "private"
     },
     {
      "name" : "std.c.stdlib",
      "kind" : "import",
      "line" : 393,
      "protection" : "private"
     },
     {
      "name" : "std.c.stdio",
      "kind" : "import",
      "line" : 393,
      "protection" : "private"
     },
     {
      "name" : "readable",
      "kind" : "variable",
      "comment" : " Indicates whether this stream can be read from.\n",
      "line" : 396,
      "deco" : "b",
      "init" : "false",
      "offset" : 16
     },
     {
      "name" : "writeable",
      "kind" : "variable",
      "comment" : " Indicates whether this stream can be written to.\n",
      "line" : 397,
      "deco" : "b",
      "init" : "false",
      "offset" : 17
     },
     {
      "name" : "seekable",
      "kind" : "variable",
      "comment" : " Indicates whether this stream can be seeked within.\n",
      "line" : 398,
      "deco" : "b",
      "init" : "false",
      "offset" : 18
     },
     {
      "name" : "isopen",
      "kind" : "variable",
      "protection" : "protected",
      "comment" : " Indicates whether this stream is open.\n",
      "line" : 399,
      "deco" : "b",
      "init" : "true",
      "offset" : 19
     },
     {
      "name" : "readEOF",
      "kind" : "variable",
      "protection" : "protected",
      "comment" : " Indicates whether this stream is at eof\n after the last read attempt.\n                                   \n",
      "line" : 401,
      "deco" : "b",
      "init" : "false",
      "offset" : 20
     },
     {
      "name" : "prevCr",
      "kind" : "variable",
      "protection" : "protected",
      "comment" : " For a non-seekable stream indicates that\n the last readLine or readLineW ended on a\n '\\r' character.\n                                  \n",
      "line" : 405,
      "deco" : "b",
      "init" : "false",
      "offset" : 21
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 410,
      "deco" : "FZC3std6stream6Stream",
      "originalType" : "()",
      "endline" : 410
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "comment" : "\n Read up to size bytes into the buffer and return the number of bytes\n actually read. A return value of 0 indicates end-of-file.\n   \n",
      "line" : 416,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "readExact",
      "kind" : "function",
      "line" : 420,
      "deco" : "FPvmZv",
      "originalType" : "void(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 430,
      "overrides" : [
       "std.stream.InputStream.readExact"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 434,
      "deco" : "FAhZm",
      "originalType" : "size_t(ubyte[] buffer)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Ah"
       }
      ],
      "endline" : 436,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 440,
      "deco" : "FJgZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "g",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 440,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 441,
      "deco" : "FJhZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "h",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 441,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 442,
      "deco" : "FJsZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "s",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 442,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 443,
      "deco" : "FJtZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "t",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 443,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 444,
      "deco" : "FJiZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 444,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 445,
      "deco" : "FJkZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 445,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 446,
      "deco" : "FJlZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "l",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 446,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 447,
      "deco" : "FJmZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "m",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 447,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 448,
      "deco" : "FJfZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "f",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 448,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 449,
      "deco" : "FJdZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "d",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 449,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 450,
      "deco" : "FJeZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "e",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 450,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 451,
      "deco" : "FJoZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "o",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 451,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 452,
      "deco" : "FJpZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "p",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 452,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 453,
      "deco" : "FJjZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "j",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 453,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 454,
      "deco" : "FJqZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "q",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 454,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 455,
      "deco" : "FJrZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "r",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 455,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 456,
      "deco" : "FJcZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "c",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 456,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 457,
      "deco" : "FJaZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "a",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 457,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 458,
      "deco" : "FJuZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "u",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 458,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 459,
      "deco" : "FJwZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "w",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 459,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 462,
      "deco" : "FJAaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aa",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 466,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 469,
      "deco" : "FJAuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Au",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 473,
      "overrides" : [
       "std.stream.InputStream.read"
      ]
     },
     {
      "name" : "readLine",
      "kind" : "function",
      "line" : 476,
      "deco" : "FZAa",
      "endline" : 478,
      "overrides" : [
       "std.stream.InputStream.readLine"
      ]
     },
     {
      "name" : "readLine",
      "kind" : "function",
      "line" : 483,
      "deco" : "FAaZAa",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "Aa"
       }
      ],
      "endline" : 514,
      "overrides" : [
       "std.stream.InputStream.readLine"
      ]
     },
     {
      "name" : "readLineW",
      "kind" : "function",
      "line" : 519,
      "deco" : "FZAu",
      "endline" : 521,
      "overrides" : [
       "std.stream.InputStream.readLineW"
      ]
     },
     {
      "name" : "readLineW",
      "kind" : "function",
      "line" : 526,
      "deco" : "FAuZAu",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "Au"
       }
      ],
      "endline" : 557,
      "overrides" : [
       "std.stream.InputStream.readLineW"
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "line" : 560,
      "deco" : "FMDFKAaZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKAaZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 569,
      "overrides" : [
       "std.stream.InputStream.opApply"
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "line" : 572,
      "deco" : "FMDFKmKAaZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKmKAaZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 583,
      "overrides" : [
       "std.stream.InputStream.opApply"
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "line" : 586,
      "deco" : "FMDFKAuZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKAuZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 595,
      "overrides" : [
       "std.stream.InputStream.opApply"
      ]
     },
     {
      "name" : "opApply",
      "kind" : "function",
      "line" : 598,
      "deco" : "FMDFKmKAuZiZi",
      "parameters" : [
       {
        "name" : "dg",
        "deco" : "DFKmKAuZi",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 609,
      "overrides" : [
       "std.stream.InputStream.opApply"
      ]
     },
     {
      "name" : "readString",
      "kind" : "function",
      "line" : 613,
      "deco" : "FmZAa",
      "originalType" : "char[](size_t length)",
      "parameters" : [
       {
        "name" : "length",
        "deco" : "m"
       }
      ],
      "endline" : 617,
      "overrides" : [
       "std.stream.InputStream.readString"
      ]
     },
     {
      "name" : "readStringW",
      "kind" : "function",
      "line" : 621,
      "deco" : "FmZAu",
      "originalType" : "wchar[](size_t length)",
      "parameters" : [
       {
        "name" : "length",
        "deco" : "m"
       }
      ],
      "endline" : 625,
      "overrides" : [
       "std.stream.InputStream.readStringW"
      ]
     },
     {
      "name" : "unget",
      "kind" : "variable",
      "protection" : "private",
      "line" : 628,
      "deco" : "Au",
      "offset" : 24
     },
     {
      "name" : "ungetAvailable",
      "kind" : "function",
      "line" : 629,
      "storageClass" : [
       "final"
      ],
      "deco" : "FZb",
      "endline" : 629
     },
     {
      "name" : "getc",
      "kind" : "function",
      "line" : 634,
      "deco" : "FZa",
      "endline" : 649,
      "overrides" : [
       "std.stream.InputStream.getc"
      ]
     },
     {
      "name" : "getcw",
      "kind" : "function",
      "line" : 654,
      "deco" : "FZu",
      "endline" : 672,
      "overrides" : [
       "std.stream.InputStream.getcw"
      ]
     },
     {
      "name" : "ungetc",
      "kind" : "function",
      "line" : 676,
      "deco" : "FaZa",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "a"
       }
      ],
      "endline" : 683,
      "overrides" : [
       "std.stream.InputStream.ungetc"
      ]
     },
     {
      "name" : "ungetcw",
      "kind" : "function",
      "line" : 687,
      "deco" : "FuZu",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "u"
       }
      ],
      "endline" : 694,
      "overrides" : [
       "std.stream.InputStream.ungetcw"
      ]
     },
     {
      "name" : "vreadf",
      "kind" : "function",
      "line" : 696,
      "deco" : "FAC8TypeInfoPvZi",
      "parameters" : [
       {
        "name" : "arguments",
        "deco" : "AC8TypeInfo"
       },
       {
        "name" : "args",
        "deco" : "Pv"
       }
      ],
      "endline" : 1030,
      "overrides" : [
       "std.stream.InputStream.vreadf"
      ]
     },
     {
      "name" : "readf",
      "kind" : "function",
      "line" : 1032,
      "deco" : "FYi",
      "endline" : 1034,
      "overrides" : [
       "std.stream.InputStream.readf"
      ]
     },
     {
      "name" : "available",
      "kind" : "function",
      "line" : 1037,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "size_t()",
      "endline" : 1037,
      "overrides" : [
       "std.stream.InputStream.available"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "comment" : "\n Write up to size bytes from buffer in the stream, returning the actual\n number of bytes that were written.\n   \n",
      "line" : 1043,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ]
     },
     {
      "name" : "writeExact",
      "kind" : "function",
      "line" : 1047,
      "deco" : "FxPvmZv",
      "originalType" : "void(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 1058,
      "overrides" : [
       "std.stream.OutputStream.writeExact"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1062,
      "deco" : "FAxhZm",
      "originalType" : "size_t(const(ubyte)[] buffer)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Axh"
       }
      ],
      "endline" : 1064,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1068,
      "deco" : "FgZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "g"
       }
      ],
      "endline" : 1068,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1069,
      "deco" : "FhZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "h"
       }
      ],
      "endline" : 1069,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1070,
      "deco" : "FsZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "s"
       }
      ],
      "endline" : 1070,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1071,
      "deco" : "FtZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "t"
       }
      ],
      "endline" : 1071,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1072,
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "i"
       }
      ],
      "endline" : 1072,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1073,
      "deco" : "FkZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       }
      ],
      "endline" : 1073,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1074,
      "deco" : "FlZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "l"
       }
      ],
      "endline" : 1074,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1075,
      "deco" : "FmZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "m"
       }
      ],
      "endline" : 1075,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1076,
      "deco" : "FfZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "f"
       }
      ],
      "endline" : 1076,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1077,
      "deco" : "FdZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "d"
       }
      ],
      "endline" : 1077,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1078,
      "deco" : "FeZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "e"
       }
      ],
      "endline" : 1078,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1079,
      "deco" : "FoZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "o"
       }
      ],
      "endline" : 1079,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1080,
      "deco" : "FpZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "p"
       }
      ],
      "endline" : 1080,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1081,
      "deco" : "FjZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "j"
       }
      ],
      "endline" : 1081,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1082,
      "deco" : "FqZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "q"
       }
      ],
      "endline" : 1082,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1083,
      "deco" : "FrZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "r"
       }
      ],
      "endline" : 1083,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1084,
      "deco" : "FcZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "c"
       }
      ],
      "endline" : 1084,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1085,
      "deco" : "FaZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "a"
       }
      ],
      "endline" : 1085,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1086,
      "deco" : "FuZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "u"
       }
      ],
      "endline" : 1086,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1087,
      "deco" : "FwZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "w"
       }
      ],
      "endline" : 1087,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1090,
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ],
      "endline" : 1093,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 1096,
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ],
      "endline" : 1099,
      "overrides" : [
       "std.stream.OutputStream.write"
      ]
     },
     {
      "name" : "writeLine",
      "kind" : "function",
      "line" : 1102,
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ],
      "endline" : 1110,
      "overrides" : [
       "std.stream.OutputStream.writeLine"
      ]
     },
     {
      "name" : "writeLineW",
      "kind" : "function",
      "line" : 1113,
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ],
      "endline" : 1121,
      "overrides" : [
       "std.stream.OutputStream.writeLineW"
      ]
     },
     {
      "name" : "writeString",
      "kind" : "function",
      "line" : 1124,
      "deco" : "FAxaZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axa"
       }
      ],
      "endline" : 1126,
      "overrides" : [
       "std.stream.OutputStream.writeString"
      ]
     },
     {
      "name" : "writeStringW",
      "kind" : "function",
      "line" : 1129,
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Axu"
       }
      ],
      "endline" : 1131,
      "overrides" : [
       "std.stream.OutputStream.writeStringW"
      ]
     },
     {
      "name" : "vprintf",
      "kind" : "function",
      "line" : 1135,
      "deco" : "FAxaPvZm",
      "originalType" : "size_t(const(char)[] format, va_list args)",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "Axa"
       },
       {
        "name" : "args",
        "deco" : "Pv"
       }
      ],
      "endline" : 1164,
      "overrides" : [
       "std.stream.OutputStream.vprintf"
      ]
     },
     {
      "name" : "printf",
      "kind" : "function",
      "line" : 1176,
      "deco" : "FAxaYm",
      "originalType" : "size_t(const(char)[] format, ...)",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "Axa"
       }
      ],
      "endline" : 1182,
      "overrides" : [
       "std.stream.OutputStream.printf"
      ]
     },
     {
      "name" : "doFormatCallback",
      "kind" : "function",
      "protection" : "private",
      "line" : 1191,
      "deco" : "FwZv",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1195
     },
     {
      "name" : "writef",
      "kind" : "function",
      "line" : 1198,
      "deco" : "FYC3std6stream12OutputStream",
      "endline" : 1200,
      "overrides" : [
       "std.stream.OutputStream.writef"
      ]
     },
     {
      "name" : "writefln",
      "kind" : "function",
      "line" : 1203,
      "deco" : "FYC3std6stream12OutputStream",
      "endline" : 1205,
      "overrides" : [
       "std.stream.OutputStream.writefln"
      ]
     },
     {
      "name" : "writefx",
      "kind" : "function",
      "line" : 1208,
      "deco" : "FAC8TypeInfoPviZC3std6stream12OutputStream",
      "originalType" : "OutputStream(TypeInfo[] arguments, void* argptr, int newline = false)",
      "parameters" : [
       {
        "name" : "arguments",
        "deco" : "AC8TypeInfo"
       },
       {
        "name" : "argptr",
        "deco" : "Pv"
       },
       {
        "name" : "newline",
        "deco" : "i",
        "default" : "0"
       }
      ],
      "endline" : 1213,
      "overrides" : [
       "std.stream.OutputStream.writefx"
      ]
     },
     {
      "name" : "copyFrom",
      "kind" : "function",
      "comment" : "\n Copies all data from s into this stream.\n This may throw ReadException or WriteException on failure.\n This restores the file position of s so that it is unchanged.\n   \n",
      "line" : 1220,
      "deco" : "FC3std6stream6StreamZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6stream6Stream"
       }
      ],
      "endline" : 1233
     },
     {
      "name" : "copyFrom",
      "kind" : "function",
      "comment" : "\n Copy a specified number of bytes from the given stream into this one.\n This may throw ReadException or WriteException on failure.\n Unlike the previous form, this doesn't restore the file position of s.\n   \n",
      "line" : 1240,
      "deco" : "FC3std6stream6StreammZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6stream6Stream"
       },
       {
        "name" : "count",
        "deco" : "m"
       }
      ],
      "endline" : 1248
     },
     {
      "name" : "seek",
      "kind" : "function",
      "comment" : "\n Change the current position of the stream. whence is either SeekPos.Set, in\n   which case the offset is an absolute index from the beginning of the stream,\n   SeekPos.Current, in which case the offset is a delta from the current\n   position, or SeekPos.End, in which case the offset is a delta from the end of\n   the stream (negative or zero offsets only make sense in that case). This\n   returns the new file position.\n   \n",
      "line" : 1258,
      "storageClass" : [
       "abstract"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "whence",
        "deco" : "E3std6stream7SeekPos"
       }
      ]
     },
     {
      "name" : "seekSet",
      "kind" : "function",
      "comment" : "\n Aliases for their normal seek counterparts.\n   \n",
      "line" : 1263,
      "deco" : "FlZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       }
      ],
      "endline" : 1263
     },
     {
      "name" : "seekCur",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1264,
      "deco" : "FlZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       }
      ],
      "endline" : 1264
     },
     {
      "name" : "seekEnd",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1265,
      "deco" : "FlZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       }
      ],
      "endline" : 1265
     },
     {
      "name" : "position",
      "kind" : "function",
      "comment" : "\n Sets file position. Equivalent to calling seek(pos, SeekPos.Set).\n   \n",
      "line" : 1270,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdmZv",
      "originalType" : "void(ulong pos)",
      "parameters" : [
       {
        "name" : "pos",
        "deco" : "m"
       }
      ],
      "endline" : 1270
     },
     {
      "name" : "position",
      "kind" : "function",
      "comment" : "\n Returns current file position. Equivalent to seek(0, SeekPos.Current).\n   \n",
      "line" : 1275,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "ulong()",
      "endline" : 1275
     },
     {
      "name" : "size",
      "kind" : "function",
      "comment" : "\n Retrieve the size of the stream in bytes.\n The stream must be seekable or a SeekException is thrown.\n   \n",
      "line" : 1281,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "ulong()",
      "endline" : 1286
     },
     {
      "name" : "eof",
      "kind" : "function",
      "line" : 1289,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1297,
      "overrides" : [
       "std.stream.InputStream.eof"
      ]
     },
     {
      "name" : "isOpen",
      "kind" : "function",
      "line" : 1300,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1300,
      "overrides" : [
       "std.stream.InputStream.isOpen"
      ]
     },
     {
      "name" : "flush",
      "kind" : "function",
      "line" : 1303,
      "deco" : "FZv",
      "endline" : 1306,
      "overrides" : [
       "std.stream.OutputStream.flush"
      ]
     },
     {
      "name" : "close",
      "kind" : "function",
      "line" : 1309,
      "deco" : "FZv",
      "endline" : 1313,
      "overrides" : [
       "std.stream.OutputStream.close"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Read the entire stream and return it as a string.\n If the stream is not seekable the contents from the current position to eof\n is read and returned.\n   \n",
      "line" : 1320,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZAya",
      "endline" : 1355,
      "overrides" : [
       "object.Object.toString"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Get a hash of the stream by reading each byte and using it in a CRC-32\n checksum.\n   \n",
      "line" : 1361,
      "storageClass" : [
       "override"
      ],
      "deco" : "FNbNeZm",
      "originalType" : "@trusted size_t()",
      "endline" : 1392,
      "overrides" : [
       "object.Object.toHash"
      ]
     },
     {
      "name" : "assertReadable",
      "kind" : "function",
      "protection" : "protected",
      "line" : 1395,
      "storageClass" : [
       "final"
      ],
      "deco" : "FZv",
      "endline" : 1398
     },
     {
      "name" : "assertWriteable",
      "kind" : "function",
      "protection" : "protected",
      "line" : 1400,
      "storageClass" : [
       "final"
      ],
      "deco" : "FZv",
      "endline" : 1403
     },
     {
      "name" : "assertSeekable",
      "kind" : "function",
      "protection" : "protected",
      "line" : 1405,
      "storageClass" : [
       "final"
      ],
      "deco" : "FZv",
      "endline" : 1408
     }
    ]
   },
   {
    "name" : "FilterStream",
    "kind" : "class",
    "comment" : "\n A base class for streams that wrap a source stream with additional\n functionality.\n\n The method implementations forward read/write/seek calls to the\n source stream. A FilterStream can change the position of the source stream\n arbitrarily and may not keep the source stream state in sync with the\n FilterStream, even upon flushing and closing the FilterStream. It is\n recommended to not make any assumptions about the state of the source position\n and read/write state after a FilterStream has acted upon it. Specifc subclasses\n of FilterStream should document how they modify the source stream and if any\n invariants hold true between the source and filter.\n \n",
    "line" : 1424,
    "base" : "Stream",
    "members" : [
     {
      "name" : "s",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1425,
      "deco" : "C3std6stream6Stream",
      "originalType" : "Stream",
      "offset" : 56
     },
     {
      "name" : "nestClose",
      "kind" : "variable",
      "comment" : " Property indicating when this stream closes to close the source stream as\n well.\n Defaults to true.\n",
      "line" : 1430,
      "deco" : "b",
      "init" : "true",
      "offset" : 64
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct a FilterStream for the given source.\n",
      "line" : 1433,
      "deco" : "FC3std6stream6StreamZC3std6stream12FilterStream",
      "originalType" : "(Stream source)",
      "parameters" : [
       {
        "name" : "source",
        "deco" : "C3std6stream6Stream"
       }
      ],
      "endline" : 1436
     },
     {
      "name" : "source",
      "kind" : "function",
      "comment" : "\n Get the current source stream.\n   \n",
      "line" : 1443,
      "storageClass" : [
       "final"
      ],
      "deco" : "FZC3std6stream6Stream",
      "endline" : 1443
     },
     {
      "name" : "source",
      "kind" : "function",
      "comment" : "\n Set the current source stream.\n\n Setting the source stream closes this stream before attaching the new\n source. Attaching an open stream reopens this stream and resets the stream\n state.\n   \n",
      "line" : 1452,
      "deco" : "FC3std6stream6StreamZv",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6stream6Stream"
       }
      ],
      "endline" : 1456
     },
     {
      "name" : "resetSource",
      "kind" : "function",
      "comment" : "\n Indicates the source stream changed state and that this stream should reset\n any readable, writeable, seekable, isopen and buffering flags.\n   \n",
      "line" : 1462,
      "deco" : "FZv",
      "endline" : 1473
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "line" : 1476,
      "storageClass" : [
       "override"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 1480,
      "overrides" : [
       "std.stream.Stream.readBlock"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "line" : 1483,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 1485,
      "overrides" : [
       "std.stream.Stream.writeBlock"
      ]
     },
     {
      "name" : "close",
      "kind" : "function",
      "line" : 1488,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 1494,
      "overrides" : [
       "std.stream.Stream.close"
      ]
     },
     {
      "name" : "seek",
      "kind" : "function",
      "line" : 1497,
      "storageClass" : [
       "override"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "whence",
        "deco" : "E3std6stream7SeekPos"
       }
      ],
      "endline" : 1500,
      "overrides" : [
       "std.stream.Stream.seek"
      ]
     },
     {
      "name" : "available",
      "kind" : "function",
      "line" : 1502,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "size_t()",
      "endline" : 1502,
      "overrides" : [
       "std.stream.Stream.available"
      ]
     },
     {
      "name" : "flush",
      "kind" : "function",
      "line" : 1503,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 1503,
      "overrides" : [
       "std.stream.Stream.flush"
      ]
     }
    ]
   },
   {
    "name" : "BufferedStream",
    "kind" : "class",
    "comment" : "\n This subclass is for buffering a source stream.\n\n A buffered stream must be\n closed explicitly to ensure the final buffer content is written to the source\n stream. The source stream position is changed according to the block size so\n reading or writing to the BufferedStream may not change the source stream\n position by the same amount.\n \n",
    "line" : 1515,
    "base" : "FilterStream",
    "members" : [
     {
      "name" : "buffer",
      "kind" : "variable",
      "line" : 1516,
      "deco" : "Ah",
      "offset" : 72
     },
     {
      "name" : "bufferCurPos",
      "kind" : "variable",
      "line" : 1517,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 88
     },
     {
      "name" : "bufferLen",
      "kind" : "variable",
      "line" : 1518,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 96
     },
     {
      "name" : "bufferDirty",
      "kind" : "variable",
      "line" : 1519,
      "deco" : "b",
      "init" : "false",
      "offset" : 104
     },
     {
      "name" : "bufferSourcePos",
      "kind" : "variable",
      "line" : 1520,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 112
     },
     {
      "name" : "streamPos",
      "kind" : "variable",
      "line" : 1521,
      "deco" : "m",
      "offset" : 120
     },
     {
      "name" : "__invariant25",
      "kind" : "function",
      "line" : 1533,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     },
     {
      "name" : "DefaultBufferSize",
      "kind" : "variable",
      "line" : 1539,
      "storageClass" : [
       "enum"
      ],
      "deco" : "m",
      "originalType" : "size_t",
      "init" : "8192LU"
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create a buffered stream for the stream source with the buffer size\n bufferSize.\n   \n",
      "line" : 1545,
      "deco" : "FC3std6stream6StreammZC3std6stream14BufferedStream",
      "originalType" : "(Stream source, size_t bufferSize = DefaultBufferSize)",
      "parameters" : [
       {
        "name" : "source",
        "deco" : "C3std6stream6Stream"
       },
       {
        "name" : "bufferSize",
        "deco" : "m",
        "default" : "8192LU"
       }
      ],
      "endline" : 1549
     },
     {
      "name" : "resetSource",
      "kind" : "function",
      "protection" : "protected",
      "line" : 1551,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 1556,
      "overrides" : [
       "std.stream.FilterStream.resetSource"
      ]
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "line" : 1560,
      "storageClass" : [
       "override"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* result, size_t len)",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "Pv"
       },
       {
        "name" : "len",
        "deco" : "m"
       }
      ],
      "endline" : 1605,
      "overrides" : [
       "std.stream.FilterStream.readBlock"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "line" : 1609,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* result, size_t len)",
      "parameters" : [
       {
        "name" : "result",
        "deco" : "xPv"
       },
       {
        "name" : "len",
        "deco" : "m"
       }
      ],
      "endline" : 1660,
      "overrides" : [
       "std.stream.FilterStream.writeBlock"
      ]
     },
     {
      "name" : "seek",
      "kind" : "function",
      "line" : 1662,
      "storageClass" : [
       "override"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "whence",
        "deco" : "E3std6stream7SeekPos"
       }
      ],
      "endline" : 1675,
      "overrides" : [
       "std.stream.FilterStream.seek"
      ]
     },
     {
      "kind" : "template",
      "line" : 1681,
      "name" : "TreadLine",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "readLine",
        "kind" : "function",
        "line" : 1682,
        "type" : "T[](T[] inBuffer)",
        "parameters" : [
         {
          "name" : "inBuffer",
          "type" : "T[]"
         }
        ],
        "endline" : 1726
       }
      ]
     },
     {
      "name" : "readLine",
      "kind" : "function",
      "line" : 1729,
      "storageClass" : [
       "override"
      ],
      "deco" : "FAaZAa",
      "parameters" : [
       {
        "name" : "inBuffer",
        "deco" : "Aa"
       }
      ],
      "endline" : 1734,
      "overrides" : [
       "std.stream.Stream.readLine"
      ]
     },
     {
      "name" : "readLine",
      "kind" : "alias",
      "line" : 1735
     },
     {
      "name" : "readLineW",
      "kind" : "function",
      "line" : 1737,
      "storageClass" : [
       "override"
      ],
      "deco" : "FAuZAu",
      "parameters" : [
       {
        "name" : "inBuffer",
        "deco" : "Au"
       }
      ],
      "endline" : 1742,
      "overrides" : [
       "std.stream.Stream.readLineW"
      ]
     },
     {
      "name" : "readLineW",
      "kind" : "alias",
      "line" : 1743
     },
     {
      "name" : "flush",
      "kind" : "function",
      "line" : 1745,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 1772,
      "overrides" : [
       "std.stream.FilterStream.flush"
      ],
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 1746,
       "deco" : "FZv",
       "endline" : 1746
      }
     },
     {
      "name" : "eof",
      "kind" : "function",
      "line" : 1775,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 1789,
      "overrides" : [
       "std.stream.Stream.eof"
      ]
     },
     {
      "name" : "size",
      "kind" : "function",
      "line" : 1792,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "ulong()",
      "endline" : 1795,
      "overrides" : [
       "std.stream.Stream.size"
      ]
     },
     {
      "name" : "available",
      "kind" : "function",
      "line" : 1798,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "size_t()",
      "endline" : 1800,
      "overrides" : [
       "std.stream.FilterStream.available"
      ]
     },
     {
      "name" : "__invariant",
      "kind" : "function",
      "line" : 1515,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     }
    ]
   },
   {
    "name" : "StreamFileException",
    "kind" : "class",
    "comment" : " An exception for File errors.\n",
    "line" : 1804,
    "base" : "StreamException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct a StreamFileException with given error message.\n",
      "line" : 1806,
      "deco" : "FAyaZC3std6stream19StreamFileException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 1806
     }
    ]
   },
   {
    "name" : "OpenException",
    "kind" : "class",
    "comment" : " An exception for errors during File.open.\n",
    "line" : 1810,
    "base" : "StreamFileException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Construct an OpenFileException with given error message.\n",
      "line" : 1812,
      "deco" : "FAyaZC3std6stream13OpenException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 1812
     }
    ]
   },
   {
    "name" : "FileMode",
    "kind" : "enum",
    "line" : 1816,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "In",
      "kind" : "enum member",
      "line" : 1817
     },
     {
      "name" : "Out",
      "kind" : "enum member",
      "line" : 1818
     },
     {
      "name" : "OutNew",
      "kind" : "enum member",
      "line" : 1819
     },
     {
      "name" : "Append",
      "kind" : "enum member",
      "line" : 1820
     }
    ]
   },
   {
    "name" : "core.sys.posix.fcntl",
    "kind" : "import",
    "line" : 1831,
    "protection" : "private"
   },
   {
    "name" : "core.sys.posix.unistd",
    "kind" : "import",
    "line" : 1832,
    "protection" : "private"
   },
   {
    "name" : "HANDLE",
    "kind" : "alias",
    "line" : 1833,
    "deco" : "i"
   },
   {
    "name" : "File",
    "kind" : "class",
    "comment" : " This subclass is for unbuffered file system streams.\n",
    "line" : 1837,
    "base" : "Stream",
    "members" : [
     {
      "name" : "hFile",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1843,
      "deco" : "i",
      "originalType" : "HANDLE",
      "init" : "-1",
      "offset" : 56
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1846,
      "deco" : "FZC3std6stream4File",
      "originalType" : "()",
      "endline" : 1855
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1858,
      "deco" : "FiE3std6stream8FileModeZC3std6stream4File",
      "originalType" : "(HANDLE hFile, FileMode mode)",
      "parameters" : [
       {
        "name" : "hFile",
        "deco" : "i"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode"
       }
      ],
      "endline" : 1869
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create the stream with no open file, an open file in read mode, or an open\n file with explicit file mode.\n mode, if given, is a combination of FileMode.In\n (indicating a file that can be read) and FileMode.Out (indicating a file\n that can be written).\n Opening a file for reading that doesn't exist will error.\n Opening a file for writing that doesn't exist will create the file.\n The FileMode.OutNew mode will open the file for writing and reset the\n length to zero.\n The FileMode.Append mode will open the file for writing and move the\n file position to the end of the file.\n   \n",
      "line" : 1884,
      "deco" : "FAyaE3std6stream8FileModeZC3std6stream4File",
      "originalType" : "(string filename, FileMode mode = FileMode.In)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode",
        "default" : "cast(FileMode)1"
       }
      ],
      "endline" : 1888
     },
     {
      "name" : "open",
      "kind" : "function",
      "comment" : "\n Open a file for the stream, in an identical manner to the constructors.\n If an error occurs an OpenException is thrown.\n   \n",
      "line" : 1895,
      "deco" : "FAyaE3std6stream8FileModeZv",
      "originalType" : "void(string filename, FileMode mode = FileMode.In)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode",
        "default" : "cast(FileMode)1"
       }
      ],
      "endline" : 1916
     },
     {
      "name" : "parseMode",
      "kind" : "function",
      "protection" : "private",
      "line" : 1918,
      "deco" : "FiJiJiJiZv",
      "parameters" : [
       {
        "name" : "mode",
        "deco" : "i"
       },
       {
        "name" : "access",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       },
       {
        "name" : "share",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       },
       {
        "name" : "createMode",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 1952
     },
     {
      "name" : "create",
      "kind" : "function",
      "comment" : " Create a file for writing.\n",
      "line" : 1955,
      "deco" : "FAyaZv",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       }
      ],
      "endline" : 1957
     },
     {
      "name" : "create",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1960,
      "deco" : "FAyaE3std6stream8FileModeZv",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode"
       }
      ],
      "endline" : 1963
     },
     {
      "name" : "close",
      "kind" : "function",
      "comment" : " Close the current file if it is open; otherwise it does nothing.\n",
      "line" : 1966,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 1979,
      "overrides" : [
       "std.stream.Stream.close"
      ]
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 1982,
      "deco" : "FZv",
      "endline" : 1982
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "line" : 1994,
      "storageClass" : [
       "override"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2007,
      "overrides" : [
       "std.stream.Stream.readBlock"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "line" : 2009,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2021,
      "overrides" : [
       "std.stream.Stream.writeBlock"
      ]
     },
     {
      "name" : "seek",
      "kind" : "function",
      "line" : 2023,
      "storageClass" : [
       "override"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "rel",
        "deco" : "E3std6stream7SeekPos"
       }
      ],
      "endline" : 2038,
      "overrides" : [
       "std.stream.Stream.seek"
      ]
     },
     {
      "name" : "available",
      "kind" : "function",
      "comment" : "\n For a seekable file returns the difference of the size and position and\n otherwise returns 0.\n   \n",
      "line" : 2045,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "size_t()",
      "endline" : 2052,
      "overrides" : [
       "std.stream.Stream.available"
      ]
     },
     {
      "name" : "handle",
      "kind" : "function",
      "line" : 2056,
      "deco" : "FZi",
      "originalType" : "HANDLE()",
      "endline" : 2056
     },
     {
      "name" : "__unittestL2059_1593",
      "kind" : "function",
      "line" : 2059,
      "endline" : 2131
     }
    ]
   },
   {
    "name" : "BufferedFile",
    "kind" : "class",
    "comment" : "\n This subclass is for buffered file system streams.\n\n It is a convenience class for wrapping a File in a BufferedStream.\n A buffered stream must be closed explicitly to ensure the final buffer\n content is written to the file.\n \n",
    "line" : 2140,
    "base" : "BufferedStream",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " opens file for reading\n",
      "line" : 2143,
      "deco" : "FZC3std6stream12BufferedFile",
      "originalType" : "()",
      "endline" : 2143
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " opens file in requested mode and buffer size\n",
      "line" : 2146,
      "deco" : "FAyaE3std6stream8FileModemZC3std6stream12BufferedFile",
      "originalType" : "(string filename, FileMode mode = FileMode.In, size_t bufferSize = DefaultBufferSize)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode",
        "default" : "cast(FileMode)1"
       },
       {
        "name" : "bufferSize",
        "deco" : "m",
        "default" : "8192LU"
       }
      ],
      "endline" : 2149
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " opens file for reading with requested buffer size\n",
      "line" : 2152,
      "deco" : "FC3std6stream4FilemZC3std6stream12BufferedFile",
      "originalType" : "(File file, size_t bufferSize = DefaultBufferSize)",
      "parameters" : [
       {
        "name" : "file",
        "deco" : "C3std6stream4File"
       },
       {
        "name" : "bufferSize",
        "deco" : "m",
        "default" : "8192LU"
       }
      ],
      "endline" : 2154
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " opens existing handle; use with care!\n",
      "line" : 2157,
      "deco" : "FiE3std6stream8FileModemZC3std6stream12BufferedFile",
      "originalType" : "(HANDLE hFile, FileMode mode, size_t buffersize = DefaultBufferSize)",
      "parameters" : [
       {
        "name" : "hFile",
        "deco" : "i"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode"
       },
       {
        "name" : "buffersize",
        "deco" : "m",
        "default" : "8192LU"
       }
      ],
      "endline" : 2159
     },
     {
      "name" : "open",
      "kind" : "function",
      "comment" : " opens file in requested mode\n",
      "line" : 2162,
      "deco" : "FAyaE3std6stream8FileModeZv",
      "originalType" : "void(string filename, FileMode mode = FileMode.In)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode",
        "default" : "cast(FileMode)1"
       }
      ],
      "endline" : 2166
     },
     {
      "name" : "create",
      "kind" : "function",
      "comment" : " creates file in requested mode\n",
      "line" : 2169,
      "deco" : "FAyaE3std6stream8FileModeZv",
      "originalType" : "void(string filename, FileMode mode = FileMode.OutNew)",
      "parameters" : [
       {
        "name" : "filename",
        "deco" : "Aya"
       },
       {
        "name" : "mode",
        "deco" : "E3std6stream8FileMode",
        "default" : "cast(FileMode)6"
       }
      ],
      "endline" : 2173
     },
     {
      "name" : "__unittestL2176_1594",
      "kind" : "function",
      "line" : 2176,
      "endline" : 2224
     }
    ]
   },
   {
    "name" : "BOM",
    "kind" : "enum",
    "comment" : " UTF byte-order-mark signatures\n",
    "line" : 2227,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "UTF8",
      "kind" : "enum member",
      "comment" : " UTF-8\n",
      "line" : 2228
     },
     {
      "name" : "UTF16LE",
      "kind" : "enum member",
      "comment" : " UTF-16 Little Endian\n",
      "line" : 2229
     },
     {
      "name" : "UTF16BE",
      "kind" : "enum member",
      "comment" : " UTF-16 Big Endian\n",
      "line" : 2230
     },
     {
      "name" : "UTF32LE",
      "kind" : "enum member",
      "comment" : " UTF-32 Little Endian\n",
      "line" : 2231
     },
     {
      "name" : "UTF32BE",
      "kind" : "enum member",
      "comment" : " UTF-32 Big Endian\n",
      "line" : 2232
     }
    ]
   },
   {
    "name" : "NBOMS",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2235,
    "storageClass" : [
     "enum"
    ],
    "deco" : "i",
    "init" : "5"
   },
   {
    "name" : "BOMEndian",
    "kind" : "variable",
    "line" : 2236,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG5E3std6system6Endian",
    "originalType" : "Endian[NBOMS]",
    "init" : "[cast(Endian)1, cast(Endian)1, cast(Endian)0, cast(Endian)1, cast(Endian)0]"
   },
   {
    "name" : "ByteOrderMarks",
    "kind" : "variable",
    "line" : 2242,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG5Ah",
    "originalType" : "ubyte[][NBOMS]",
    "init" : "[[cast(ubyte)239u, cast(ubyte)187u, cast(ubyte)191u], [cast(ubyte)255u, cast(ubyte)254u], [cast(ubyte)254u, cast(ubyte)255u], [cast(ubyte)255u, cast(ubyte)254u, cast(ubyte)0u, cast(ubyte)0u], [cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)254u, cast(ubyte)255u]]"
   },
   {
    "name" : "EndianStream",
    "kind" : "class",
    "comment" : "\n This subclass wraps a stream with big-endian or little-endian byte order\n swapping.\n\n UTF Byte-Order-Mark (BOM) signatures can be read and deduced or\n written.\n Note that an EndianStream should not be used as the source of another\n FilterStream since a FilterStream call the source with byte-oriented\n read/write requests and the EndianStream will not perform any byte swapping.\n The EndianStream reads and writes binary data (non-getc functions) in a\n one-to-one\n manner with the source stream so the source stream's position and state will be\n kept in sync with the EndianStream if only non-getc functions are called.\n \n",
    "line" : 2265,
    "base" : "FilterStream",
    "members" : [
     {
      "name" : "endian",
      "kind" : "variable",
      "comment" : " Endianness property of the source stream.\n",
      "line" : 2267,
      "deco" : "E3std6system6Endian",
      "offset" : 68
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create the endian stream for the source stream source with endianness end.\n The default endianness is the native byte order.\n The Endian type is defined\n in the std.system module.\n   \n",
      "line" : 2275,
      "deco" : "FC3std6stream6StreamE3std6system6EndianZC3std6stream12EndianStream",
      "originalType" : "(Stream source, Endian end = std.system.endian)",
      "parameters" : [
       {
        "name" : "source",
        "deco" : "C3std6stream6Stream"
       },
       {
        "name" : "end",
        "deco" : "E3std6system6Endian",
        "default" : "cast(Endian)1"
       }
      ],
      "endline" : 2278
     },
     {
      "name" : "readBOM",
      "kind" : "function",
      "comment" : "\n Return -1 if no BOM and otherwise read the BOM and return it.\n\n If there is no BOM or if bytes beyond the BOM are read then the bytes read\n are pushed back onto the ungetc buffer or ungetcw buffer.\n Pass ungetCharSize == 2 to use\n ungetcw instead of ungetc when no BOM is present.\n   \n",
      "line" : 2288,
      "deco" : "FiZi",
      "parameters" : [
       {
        "name" : "ungetCharSize",
        "deco" : "i",
        "default" : "1"
       }
      ],
      "endline" : 2326
     },
     {
      "name" : "fixBO",
      "kind" : "function",
      "comment" : "\n Correct the byte order of buffer to match native endianness.\n size must be even.\n   \n",
      "line" : 2332,
      "storageClass" : [
       "final"
      ],
      "deco" : "FPxvmZv",
      "originalType" : "void(const(void)* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pxv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2365
     },
     {
      "name" : "fixBlockBO",
      "kind" : "function",
      "comment" : "\n Correct the byte order of the given buffer in blocks of the given size and\n repeated the given number of times.\n size must be even.\n   \n",
      "line" : 2372,
      "storageClass" : [
       "final"
      ],
      "deco" : "FPvkmZv",
      "originalType" : "void(void* buffer, uint size, size_t repeat)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "k"
       },
       {
        "name" : "repeat",
        "deco" : "m"
       }
      ],
      "endline" : 2377
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2379,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJgZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "g",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2379,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2380,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJhZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "h",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2380,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2381,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJsZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "s",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2381,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2382,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJtZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "t",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2382,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2383,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJiZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "i",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2383,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2384,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJkZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2384,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2385,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJlZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "l",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2385,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2386,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJmZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "m",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2386,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2387,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJfZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "f",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2387,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2388,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJdZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "d",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2388,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2389,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJeZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "e",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2389,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2390,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJoZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "o",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2390,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2391,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJpZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "p",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2391,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2392,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJjZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "j",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2392,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2393,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJqZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "q",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2393,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2394,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJrZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "r",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2394,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2395,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJcZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "c",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2395,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2396,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJaZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "a",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2396,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2397,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJuZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "u",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2397,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "read",
      "kind" : "function",
      "line" : 2398,
      "storageClass" : [
       "override"
      ],
      "deco" : "FJwZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "w",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 2398,
      "overrides" : [
       "std.stream.Stream.read"
      ]
     },
     {
      "name" : "getcw",
      "kind" : "function",
      "line" : 2400,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZu",
      "endline" : 2419,
      "overrides" : [
       "std.stream.Stream.getcw"
      ]
     },
     {
      "name" : "readStringW",
      "kind" : "function",
      "line" : 2421,
      "storageClass" : [
       "override"
      ],
      "deco" : "FmZAu",
      "originalType" : "wchar[](size_t length)",
      "parameters" : [
       {
        "name" : "length",
        "deco" : "m"
       }
      ],
      "endline" : 2426,
      "overrides" : [
       "std.stream.Stream.readStringW"
      ]
     },
     {
      "name" : "writeBOM",
      "kind" : "function",
      "comment" : " Write the specified BOM b to the source stream.\n",
      "line" : 2429,
      "deco" : "FE3std6stream3BOMZv",
      "parameters" : [
       {
        "name" : "b",
        "deco" : "E3std6stream3BOM"
       }
      ],
      "endline" : 2432
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2434,
      "storageClass" : [
       "override"
      ],
      "deco" : "FgZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "g"
       }
      ],
      "endline" : 2434,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2435,
      "storageClass" : [
       "override"
      ],
      "deco" : "FhZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "h"
       }
      ],
      "endline" : 2435,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2436,
      "storageClass" : [
       "override"
      ],
      "deco" : "FsZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "s"
       }
      ],
      "endline" : 2436,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2437,
      "storageClass" : [
       "override"
      ],
      "deco" : "FtZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "t"
       }
      ],
      "endline" : 2437,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2438,
      "storageClass" : [
       "override"
      ],
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "i"
       }
      ],
      "endline" : 2438,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2439,
      "storageClass" : [
       "override"
      ],
      "deco" : "FkZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "k"
       }
      ],
      "endline" : 2439,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2440,
      "storageClass" : [
       "override"
      ],
      "deco" : "FlZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "l"
       }
      ],
      "endline" : 2440,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2441,
      "storageClass" : [
       "override"
      ],
      "deco" : "FmZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "m"
       }
      ],
      "endline" : 2441,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2442,
      "storageClass" : [
       "override"
      ],
      "deco" : "FfZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "f"
       }
      ],
      "endline" : 2442,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2443,
      "storageClass" : [
       "override"
      ],
      "deco" : "FdZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "d"
       }
      ],
      "endline" : 2443,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2444,
      "storageClass" : [
       "override"
      ],
      "deco" : "FeZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "e"
       }
      ],
      "endline" : 2444,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2445,
      "storageClass" : [
       "override"
      ],
      "deco" : "FoZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "o"
       }
      ],
      "endline" : 2445,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2446,
      "storageClass" : [
       "override"
      ],
      "deco" : "FpZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "p"
       }
      ],
      "endline" : 2446,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2447,
      "storageClass" : [
       "override"
      ],
      "deco" : "FjZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "j"
       }
      ],
      "endline" : 2447,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2448,
      "storageClass" : [
       "override"
      ],
      "deco" : "FqZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "q"
       }
      ],
      "endline" : 2448,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2449,
      "storageClass" : [
       "override"
      ],
      "deco" : "FrZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "r"
       }
      ],
      "endline" : 2449,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2450,
      "storageClass" : [
       "override"
      ],
      "deco" : "FcZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "c"
       }
      ],
      "endline" : 2450,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2451,
      "storageClass" : [
       "override"
      ],
      "deco" : "FaZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "a"
       }
      ],
      "endline" : 2451,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2452,
      "storageClass" : [
       "override"
      ],
      "deco" : "FuZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "u"
       }
      ],
      "endline" : 2452,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "write",
      "kind" : "function",
      "line" : 2453,
      "storageClass" : [
       "override"
      ],
      "deco" : "FwZv",
      "parameters" : [
       {
        "name" : "x",
        "deco" : "w"
       }
      ],
      "endline" : 2453,
      "overrides" : [
       "std.stream.Stream.write"
      ]
     },
     {
      "name" : "writeStringW",
      "kind" : "function",
      "line" : 2455,
      "storageClass" : [
       "override"
      ],
      "deco" : "FAxuZv",
      "parameters" : [
       {
        "name" : "str",
        "deco" : "Axu"
       }
      ],
      "endline" : 2460,
      "overrides" : [
       "std.stream.Stream.writeStringW"
      ]
     },
     {
      "name" : "eof",
      "kind" : "function",
      "line" : 2462,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZb",
      "originalType" : "bool()",
      "endline" : 2462,
      "overrides" : [
       "std.stream.Stream.eof"
      ]
     },
     {
      "name" : "size",
      "kind" : "function",
      "line" : 2463,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "ulong()",
      "endline" : 2463,
      "overrides" : [
       "std.stream.Stream.size"
      ]
     },
     {
      "name" : "__unittestL2465_1595",
      "kind" : "function",
      "line" : 2465,
      "endline" : 2548
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Parameterized subclass that wraps an array-like buffer with a stream\n interface.\n\n The type Buffer must support the length property, opIndex and opSlice.\n Compile in release mode when directly instantiating a TArrayStream to avoid\n link errors.\n \n",
    "line" : 2558,
    "name" : "TArrayStream",
    "parameters" : [
     {
      "name" : "Buffer",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "TArrayStream",
      "kind" : "class",
      "line" : 2558,
      "members" : [
       {
        "name" : "buf",
        "kind" : "variable",
        "line" : 2559,
        "type" : "Buffer"
       },
       {
        "name" : "len",
        "kind" : "variable",
        "line" : 2560,
        "deco" : "m"
       },
       {
        "name" : "cur",
        "kind" : "variable",
        "line" : 2561,
        "deco" : "m"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : " Create the stream for the the buffer buf. Non-copying.\n",
        "line" : 2564,
        "type" : "(Buffer buf)",
        "parameters" : [
         {
          "name" : "buf",
          "type" : "Buffer"
         }
        ],
        "endline" : 2569
       },
       {
        "name" : "__invariant26",
        "kind" : "function",
        "line" : 2572
       },
       {
        "name" : "readBlock",
        "kind" : "function",
        "line" : 2577,
        "type" : "size_t(void* buffer, size_t size)",
        "parameters" : [
         {
          "name" : "buffer",
          "type" : "void*"
         },
         {
          "name" : "size",
          "type" : "size_t"
         }
        ],
        "endline" : 2586
       },
       {
        "name" : "writeBlock",
        "kind" : "function",
        "line" : 2588,
        "type" : "size_t(const void* buffer, size_t size)",
        "parameters" : [
         {
          "name" : "buffer",
          "type" : "void*",
          "storageClass" : [
           "const"
          ]
         },
         {
          "name" : "size",
          "type" : "size_t"
         }
        ],
        "endline" : 2600
       },
       {
        "name" : "seek",
        "kind" : "function",
        "line" : 2602,
        "type" : "ulong(long offset, SeekPos rel)",
        "parameters" : [
         {
          "name" : "offset",
          "deco" : "l"
         },
         {
          "name" : "rel",
          "type" : "SeekPos"
         }
        ],
        "endline" : 2622
       },
       {
        "name" : "available",
        "kind" : "function",
        "line" : 2624,
        "type" : "size_t()",
        "endline" : 2624
       },
       {
        "name" : "data",
        "kind" : "function",
        "comment" : " Get the current memory data in total.\n",
        "line" : 2627,
        "type" : "ubyte[]()",
        "endline" : 2632
       },
       {
        "name" : "toString",
        "kind" : "function",
        "line" : 2634,
        "type" : "string()",
        "endline" : 2637
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2641_1596",
    "kind" : "function",
    "line" : 2641,
    "endline" : 2670
   },
   {
    "name" : "MemoryStream",
    "kind" : "class",
    "comment" : " This subclass reads and constructs an array of bytes in memory.\n",
    "line" : 2670,
    "base" : "TArrayStream",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Create the output buffer and setup for reading, writing, and seeking.\n",
      "line" : 2674,
      "deco" : "FZC3std6stream12MemoryStream",
      "originalType" : "()",
      "endline" : 2674
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Create the output buffer and setup for reading, writing, and seeking.\n Load it with specific input data.\n   \n",
      "line" : 2680,
      "deco" : "FAhZC3std6stream12MemoryStream",
      "originalType" : "(ubyte[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Ah"
       }
      ],
      "endline" : 2680
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 2681,
      "deco" : "FAgZC3std6stream12MemoryStream",
      "originalType" : "(byte[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Ag"
       }
      ],
      "endline" : 2681
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 2682,
      "deco" : "FAaZC3std6stream12MemoryStream",
      "originalType" : "(char[] buf)",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Aa"
       }
      ],
      "endline" : 2682
     },
     {
      "name" : "reserve",
      "kind" : "function",
      "comment" : " Ensure the stream can hold count bytes.\n",
      "line" : 2685,
      "deco" : "FmZv",
      "originalType" : "void(size_t count)",
      "parameters" : [
       {
        "name" : "count",
        "deco" : "m"
       }
      ],
      "endline" : 2688
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "line" : 2690,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2693,
      "overrides" : [
       "std.stream.TArrayStream!(ubyte[]).TArrayStream.writeBlock"
      ]
     },
     {
      "name" : "__unittestL2695_1597",
      "kind" : "function",
      "line" : 2695,
      "endline" : 2739
     }
    ]
   },
   {
    "name" : "std.mmfile",
    "kind" : "import",
    "line" : 2741,
    "protection" : "private"
   },
   {
    "name" : "MmFileStream",
    "kind" : "class",
    "comment" : "\n This subclass wraps a memory-mapped file with the stream API.\n See std.mmfile module.\n \n",
    "line" : 2747,
    "base" : "TArrayStream",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Create stream wrapper for file.\n",
      "line" : 2750,
      "deco" : "FC3std6mmfile6MmFileZC3std6stream12MmFileStream",
      "originalType" : "(MmFile file)",
      "parameters" : [
       {
        "name" : "file",
        "deco" : "C3std6mmfile6MmFile"
       }
      ],
      "endline" : 2754
     },
     {
      "name" : "flush",
      "kind" : "function",
      "line" : 2756,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 2761,
      "overrides" : [
       "std.stream.Stream.flush"
      ]
     },
     {
      "name" : "close",
      "kind" : "function",
      "line" : 2763,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZv",
      "endline" : 2769,
      "overrides" : [
       "std.stream.Stream.close"
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2772_1598",
    "kind" : "function",
    "line" : 2772,
    "endline" : 2812
   },
   {
    "name" : "SliceStream",
    "kind" : "class",
    "comment" : "\n This subclass slices off a portion of another stream, making seeking relative\n to the boundaries of the slice.\n\n It could be used to section a large file into a\n set of smaller files, such as with tar archives. Reading and writing a\n SliceStream does not modify the position of the source stream if it is\n seekable.\n \n",
    "line" : 2812,
    "base" : "FilterStream",
    "members" : [
     {
      "name" : "pos",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2814,
      "deco" : "m",
      "offset" : 72
     },
     {
      "name" : "low",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2815,
      "deco" : "m",
      "offset" : 80
     },
     {
      "name" : "high",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2816,
      "deco" : "m",
      "offset" : 88
     },
     {
      "name" : "bounded",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2817,
      "deco" : "b",
      "offset" : 96
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Indicate both the source stream to use for reading from and the low part of\n the slice.\n\n The high part of the slice is dependent upon the end of the source\n stream, so that if you write beyond the end it resizes the stream normally.\n   \n",
      "line" : 2827,
      "deco" : "FC3std6stream6StreammZC3std6stream11SliceStream",
      "originalType" : "(Stream s, ulong low)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6stream6Stream"
       },
       {
        "name" : "low",
        "deco" : "m"
       }
      ],
      "endline" : 2836
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Indicate the high index as well.\n\n Attempting to read or write past the high\n index results in the end being clipped off.\n   \n",
      "line" : 2844,
      "deco" : "FC3std6stream6StreammmZC3std6stream11SliceStream",
      "originalType" : "(Stream s, ulong low, ulong high)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "C3std6stream6Stream"
       },
       {
        "name" : "low",
        "deco" : "m"
       },
       {
        "name" : "high",
        "deco" : "m"
       }
      ],
      "endline" : 2854
     },
     {
      "name" : "__invariant27",
      "kind" : "function",
      "line" : 2856,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     },
     {
      "name" : "readBlock",
      "kind" : "function",
      "line" : 2864,
      "storageClass" : [
       "override"
      ],
      "deco" : "FPvmZm",
      "originalType" : "size_t(void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Pv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2877,
      "overrides" : [
       "std.stream.FilterStream.readBlock"
      ]
     },
     {
      "name" : "writeBlock",
      "kind" : "function",
      "line" : 2879,
      "storageClass" : [
       "override"
      ],
      "deco" : "FxPvmZm",
      "originalType" : "size_t(const void* buffer, size_t size)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "xPv"
       },
       {
        "name" : "size",
        "deco" : "m"
       }
      ],
      "endline" : 2892,
      "overrides" : [
       "std.stream.FilterStream.writeBlock"
      ]
     },
     {
      "name" : "seek",
      "kind" : "function",
      "line" : 2894,
      "storageClass" : [
       "override"
      ],
      "deco" : "FlE3std6stream7SeekPosZm",
      "parameters" : [
       {
        "name" : "offset",
        "deco" : "l"
       },
       {
        "name" : "rel",
        "deco" : "E3std6stream7SeekPos"
       }
      ],
      "endline" : 2926,
      "overrides" : [
       "std.stream.FilterStream.seek"
      ]
     },
     {
      "name" : "available",
      "kind" : "function",
      "line" : 2928,
      "storageClass" : [
       "override",
       "@property"
      ],
      "deco" : "FNdZm",
      "originalType" : "size_t()",
      "endline" : 2938,
      "overrides" : [
       "std.stream.FilterStream.available"
      ]
     },
     {
      "name" : "__unittestL2940_1599",
      "kind" : "function",
      "line" : 2940,
      "endline" : 2985
     },
     {
      "name" : "__invariant",
      "kind" : "function",
      "line" : 2812,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     }
    ]
   }
  ]
 },
 {
  "name" : "std.string",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/string.d",
  "comment" : "\nString handling functions. Objects of types $(D _string), $(D\nwstring), and $(D dstring) are value types and cannot be mutated\nelement-by-element. For using mutation during building strings, use\n$(D char[]), $(D wchar[]), or $(D dchar[]). The $(D *_string) types\nare preferable because they don't exhibit undesired aliasing, thus\nmaking code more robust.\n\nMacros: WIKI = Phobos/StdString\n\nCopyright: Copyright Digital Mars 2007-.\n\nLicense: $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\n\nAuthors: $(WEB digitalmars.com, Walter Bright),\n         $(WEB erdani.org, Andrei Alexandrescu),\n         and Jonathan M Davis\n\nSource:    $(PHOBOSSRC std/_string.d)\n\n",
  "members" : [
   {
    "name" : "core.exception",
    "kind" : "import",
    "line" : 28,
    "protection" : "private",
    "selective" : [
     "RangeError",
     "onRangeError"
    ]
   },
   {
    "name" : "core.vararg",
    "kind" : "import",
    "line" : 29,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 29,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.string",
    "kind" : "import",
    "line" : 29,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.functional",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 31,
    "protection" : "private"
   },
   {
    "name" : "std.regex",
    "kind" : "import",
    "line" : 31,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 31,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 32,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 32,
    "protection" : "private"
   },
   {
    "name" : "std.uni",
    "kind" : "import",
    "line" : 32,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 32,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 36,
    "protection" : "private",
    "selective" : [
     "startsWith",
     "endsWith",
     "cmp",
     "count"
    ]
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 37,
    "protection" : "private",
    "selective" : [
     "join",
     "split"
    ]
   },
   {
    "name" : "StringException",
    "kind" : "class",
    "comment" : "\n    Exception thrown on errors in std.string functions.\n  \n",
    "line" : 52,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n        Params:\n            msg  = The message for the exception.\n            file = The file where the exception occurred.\n            line = The line number where the exception occurred.\n            next = The previous exception in the chain of exceptions, if any.\n      \n",
      "line" : 61,
      "deco" : "FAyaAyamC6object9ThrowableZC3std6string15StringException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 67
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Compares two ranges of characters lexicographically. The comparison is\n    case insensitive. Use $(XREF algorithm, cmp) for a case sensitive\n    comparison. icmp works like $(XREF algorithm, cmp) except that it\n    converts characters to lowercase prior to applying $(D pred). Technically,\n    $(D icmp(r1, r2)) is equivalent to\n    $(D cmp!\"std.uni.toLower(a) < std.uni.toLower(b)\"(r1, r2)).\n\n    $(BOOKTABLE,\n        $(TR $(TD $(D < 0))  $(TD $(D s1 < s2) ))\n        $(TR $(TD $(D = 0))  $(TD $(D s1 == s2)))\n        $(TR $(TD $(D > 0))  $(TD $(D s1 > s2)))\n     )\n  \n",
    "line" : 85,
    "name" : "icmp",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "S1",
      "kind" : "type"
     },
     {
      "name" : "S2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "icmp",
      "kind" : "function",
      "comment" : "\n    Compares two ranges of characters lexicographically. The comparison is\n    case insensitive. Use $(XREF algorithm, cmp) for a case sensitive\n    comparison. icmp works like $(XREF algorithm, cmp) except that it\n    converts characters to lowercase prior to applying $(D pred). Technically,\n    $(D icmp(r1, r2)) is equivalent to\n    $(D cmp!\"std.uni.toLower(a) < std.uni.toLower(b)\"(r1, r2)).\n\n    $(BOOKTABLE,\n        $(TR $(TD $(D < 0))  $(TD $(D s1 < s2) ))\n        $(TR $(TD $(D = 0))  $(TD $(D s1 == s2)))\n        $(TR $(TD $(D > 0))  $(TD $(D s1 > s2)))\n     )\n  \n",
      "line" : 85,
      "type" : "int(S1 s1, S2 s2)",
      "parameters" : [
       {
        "name" : "s1",
        "type" : "S1"
       },
       {
        "name" : "s2",
        "type" : "S2"
       }
      ],
      "endline" : 118
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 120,
    "name" : "icmp",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias",
      "defaultAlias" : "\"a < b\""
     },
     {
      "name" : "S1",
      "kind" : "type"
     },
     {
      "name" : "S2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "icmp",
      "kind" : "function",
      "line" : 120,
      "type" : "int(S1 s1, S2 s2)",
      "parameters" : [
       {
        "name" : "s1",
        "type" : "S1"
       },
       {
        "name" : "s2",
        "type" : "S2"
       }
      ],
      "endline" : 152
     }
    ]
   },
   {
    "name" : "__unittestL154_1600",
    "kind" : "function",
    "line" : 154,
    "endline" : 217
   },
   {
    "name" : "toStringz",
    "kind" : "function",
    "comment" : "\n    Returns a C-style zero-terminated string equivalent to $(D s). $(D s)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D s.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(RED Important Note:) When passing a $(D char*) to a C function, and the C\n    function keeps it around for any reason, make sure that you keep a reference\n    to it in your D code. Otherwise, it may go away during a garbage collection\n    cycle and cause a nasty bug when the C code tries to use it.\n  \n",
    "line" : 217,
    "deco" : "FNaNbAxaZPya",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Axa"
     }
    ],
    "endline" : 257
   },
   {
    "name" : "toStringz",
    "kind" : "function",
    "comment" : " Ditto \n",
    "line" : 260,
    "deco" : "FNaNbAyaZPya",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     }
    ],
    "endline" : 277
   },
   {
    "name" : "__unittestL279_1601",
    "kind" : "function",
    "line" : 279,
    "endline" : 306
   },
   {
    "name" : "CaseSensitive",
    "kind" : "enum",
    "comment" : "\n   Flag indicating whether a search is case-sensitive.\n",
    "line" : 306,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "line" : 306
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "line" : 306
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the index of the first occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
    "line" : 314,
    "name" : "indexOf",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "indexOf",
      "kind" : "function",
      "comment" : "\n    Returns the index of the first occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
      "line" : 314,
      "type" : "pure ptrdiff_t(in Char[] s, dchar c, CaseSensitive cs = CaseSensitive.yes)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "cs",
        "type" : "CaseSensitive",
        "default" : "CaseSensitive.yes"
       }
      ],
      "endline" : 366
     }
    ]
   },
   {
    "name" : "__unittestL368_1602",
    "kind" : "function",
    "line" : 368,
    "endline" : 404
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the index of the first occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
    "line" : 404,
    "name" : "indexOf",
    "parameters" : [
     {
      "name" : "Char1",
      "kind" : "type"
     },
     {
      "name" : "Char2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "indexOf",
      "kind" : "function",
      "comment" : "\n    Returns the index of the first occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
      "line" : 404,
      "type" : "ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, CaseSensitive cs = CaseSensitive.yes)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(Char1)[]"
       },
       {
        "name" : "sub",
        "type" : "const(Char2)[]"
       },
       {
        "name" : "cs",
        "type" : "CaseSensitive",
        "default" : "CaseSensitive.yes"
       }
      ],
      "endline" : 421
     }
    ]
   },
   {
    "name" : "__unittestL423_1604",
    "kind" : "function",
    "line" : 423,
    "endline" : 478
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the index of the last occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
    "line" : 478,
    "name" : "lastIndexOf",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "lastIndexOf",
      "kind" : "function",
      "comment" : "\n    Returns the index of the last occurence of $(D c) in $(D s). If $(D c)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
      "line" : 478,
      "type" : "ptrdiff_t(const(Char)[] s, dchar c, CaseSensitive cs = CaseSensitive.yes)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(Char)[]"
       },
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "cs",
        "type" : "CaseSensitive",
        "default" : "CaseSensitive.yes"
       }
      ],
      "endline" : 534
     }
    ]
   },
   {
    "name" : "__unittestL536_1605",
    "kind" : "function",
    "line" : 536,
    "endline" : 573
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the index of the last occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
    "line" : 573,
    "name" : "lastIndexOf",
    "parameters" : [
     {
      "name" : "Char1",
      "kind" : "type"
     },
     {
      "name" : "Char2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "lastIndexOf",
      "kind" : "function",
      "comment" : "\n    Returns the index of the last occurence of $(D sub) in $(D s). If $(D sub)\n    is not found, then $(D -1) is returned.\n\n    $(D cs) indicates whether the comparisons are case sensitive.\n  \n",
      "line" : 573,
      "type" : "ptrdiff_t(const(Char1)[] s, const(Char2)[] sub, CaseSensitive cs = CaseSensitive.yes)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "const(Char1)[]"
       },
       {
        "name" : "sub",
        "type" : "const(Char2)[]"
       },
       {
        "name" : "cs",
        "type" : "CaseSensitive",
        "default" : "CaseSensitive.yes"
       }
      ],
      "endline" : 624
     }
    ]
   },
   {
    "name" : "__unittestL626_1607",
    "kind" : "function",
    "line" : 626,
    "endline" : 691
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the representation of a string, which has the same type\n as the string except the character type is replaced by $(D ubyte),\n $(D ushort), or $(D uint) depending on the character width.\n\n Example:\n----\nstring s = \"hello\";\nstatic assert(is(typeof(representation(s)) == immutable(ubyte)[]));\nassert(representation(s) is cast(immutable(ubyte)[]) s);\nassert(representation(s) == [0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n----\n \n",
    "line" : 691,
    "name" : "representation",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "representation",
      "kind" : "function",
      "comment" : "\n Returns the representation of a string, which has the same type\n as the string except the character type is replaced by $(D ubyte),\n $(D ushort), or $(D uint) depending on the character width.\n\n Example:\n----\nstring s = \"hello\";\nstatic assert(is(typeof(representation(s)) == immutable(ubyte)[]));\nassert(representation(s) is cast(immutable(ubyte)[]) s);\nassert(representation(s) == [0x68, 0x65, 0x6c, 0x6c, 0x6f]);\n----\n \n",
      "line" : 691,
      "storageClass" : [
       "auto"
      ],
      "type" : "pure nothrow (Char[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "Char[]"
       }
      ],
      "endline" : 707
     }
    ]
   },
   {
    "name" : "__unittestL709_1608",
    "kind" : "function",
    "line" : 709,
    "endline" : 717
   },
   {
    "name" : "__unittestL717_1609",
    "kind" : "function",
    "line" : 717,
    "endline" : 747
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are lowercase (in unicode, not just ASCII). If $(D s) does not\n    have any uppercase characters, then $(D s) is returned.\n  \n",
    "line" : 747,
    "name" : "toLower",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toLower",
      "kind" : "function",
      "comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are lowercase (in unicode, not just ASCII). If $(D s) does not\n    have any uppercase characters, then $(D s) is returned.\n  \n",
      "line" : 747,
      "type" : "pure @trusted S(S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       }
      ],
      "endline" : 765
     }
    ]
   },
   {
    "name" : "__unittestL767_1610",
    "kind" : "function",
    "line" : 767,
    "endline" : 793
   },
   {
    "kind" : "template",
    "comment" : "\n    Converts $(D s) to lowercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any uppercase characters, then $(D s) is unaltered.\n \n",
    "line" : 793,
    "name" : "toLowerInPlace",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toLowerInPlace",
      "kind" : "function",
      "comment" : "\n    Converts $(D s) to lowercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any uppercase characters, then $(D s) is unaltered.\n \n",
      "line" : 793,
      "type" : "void(ref C[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "C[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 823
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 825,
    "name" : "toLowerInPlace",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toLowerInPlace",
      "kind" : "function",
      "line" : 825,
      "type" : "pure nothrow @safe void(ref C[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "C[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 833
     }
    ]
   },
   {
    "name" : "__unittestL835_1611",
    "kind" : "function",
    "line" : 835,
    "endline" : 851
   },
   {
    "name" : "__unittestL851_1612",
    "kind" : "function",
    "line" : 851,
    "endline" : 899
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are uppercase (in unicode, not just ASCII). If $(D s) does not\n    have any lowercase characters, then $(D s) is returned.\n  \n",
    "line" : 899,
    "name" : "toUpper",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUpper",
      "kind" : "function",
      "comment" : "\n    Returns a string which is identical to $(D s) except that all of its\n    characters are uppercase (in unicode, not just ASCII). If $(D s) does not\n    have any lowercase characters, then $(D s) is returned.\n  \n",
      "line" : 899,
      "type" : "pure @trusted S(S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       }
      ],
      "endline" : 917
     }
    ]
   },
   {
    "name" : "__unittestL919_1613",
    "kind" : "function",
    "line" : 919,
    "endline" : 945
   },
   {
    "kind" : "template",
    "comment" : "\n    Converts $(D s) to uppercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any lowercase characters, then $(D s) is unaltered.\n \n",
    "line" : 945,
    "name" : "toUpperInPlace",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUpperInPlace",
      "kind" : "function",
      "comment" : "\n    Converts $(D s) to uppercase (in unicode, not just ASCII) in place.\n    If $(D s) does not have any lowercase characters, then $(D s) is unaltered.\n \n",
      "line" : 945,
      "type" : "void(ref C[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "C[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 976
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 978,
    "name" : "toUpperInPlace",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUpperInPlace",
      "kind" : "function",
      "line" : 978,
      "type" : "pure nothrow @safe void(ref C[] s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "C[]",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 986
     }
    ]
   },
   {
    "name" : "__unittestL988_1614",
    "kind" : "function",
    "line" : 988,
    "endline" : 1004
   },
   {
    "name" : "__unittestL1004_1615",
    "kind" : "function",
    "line" : 1004,
    "endline" : 1038
   },
   {
    "kind" : "template",
    "comment" : "\n    Capitalize the first character of $(D s) and conver the rest of $(D s)\n    to lowercase.\n \n",
    "line" : 1038,
    "name" : "capitalize",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "capitalize",
      "kind" : "function",
      "comment" : "\n    Capitalize the first character of $(D s) and conver the rest of $(D s)\n    to lowercase.\n \n",
      "line" : 1038,
      "type" : "pure @trusted S(S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       }
      ],
      "endline" : 1072
     }
    ]
   },
   {
    "name" : "__unittestL1074_1616",
    "kind" : "function",
    "line" : 1074,
    "endline" : 1115
   },
   {
    "name" : "KeepTerminator",
    "kind" : "enum",
    "comment" : "\n    Split $(D s) into an array of lines using $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(XREF uni, lineSep), and $(XREF uni, paraSep) as delimiters.\n    If $(D keepTerm) is set to $(D KeepTerminator.yes), then the delimiter\n    is included in the strings returned.\n  \n",
    "line" : 1115,
    "baseDeco" : "b",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "line" : 1115
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "line" : 1115
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1117,
    "name" : "splitLines",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "splitLines",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 1117,
      "type" : "S[](S s, KeepTerminator keepTerm = KeepTerminator.no)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "keepTerm",
        "type" : "KeepTerminator",
        "default" : "KeepTerminator.no"
       }
      ],
      "endline" : 1153
     }
    ]
   },
   {
    "name" : "__unittestL1155_1617",
    "kind" : "function",
    "line" : 1155,
    "endline" : 1216
   },
   {
    "kind" : "template",
    "comment" : "\n    Strips leading whitespace.\n\n    Examples:\n--------------------\nassert(stripLeft(\"     hello world     \") ==\n       \"hello world     \");\nassert(stripLeft(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\\n\\t\\v\\r\");\nassert(stripLeft(\"hello world\") ==\n       \"hello world\");\nassert(stripLeft([lineSep] ~ \"hello world\" ~ lineSep) ==\n       \"hello world\" ~ [lineSep]);\nassert(stripLeft([paraSep] ~ \"hello world\" ~ paraSep) ==\n       \"hello world\" ~ [paraSep]);\n--------------------\n  \n",
    "line" : 1216,
    "name" : "stripLeft",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stripLeft",
      "kind" : "function",
      "comment" : "\n    Strips leading whitespace.\n\n    Examples:\n--------------------\nassert(stripLeft(\"     hello world     \") ==\n       \"hello world     \");\nassert(stripLeft(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\\n\\t\\v\\r\");\nassert(stripLeft(\"hello world\") ==\n       \"hello world\");\nassert(stripLeft([lineSep] ~ \"hello world\" ~ lineSep) ==\n       \"hello world\" ~ [lineSep]);\nassert(stripLeft([paraSep] ~ \"hello world\" ~ paraSep) ==\n       \"hello world\" ~ [paraSep]);\n--------------------\n  \n",
      "line" : 1216,
      "type" : "pure @safe C[](C[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C[]"
       }
      ],
      "endline" : 1226
     }
    ]
   },
   {
    "name" : "__unittestL1229_1618",
    "kind" : "function",
    "line" : 1229,
    "endline" : 1261
   },
   {
    "kind" : "template",
    "comment" : "\n    Strips trailing whitespace.\n\n    Examples:\n--------------------\nassert(stripRight(\"     hello world     \") ==\n       \"     hello world\");\nassert(stripRight(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"\\n\\t\\v\\rhello world\");\nassert(stripRight(\"hello world\") ==\n       \"hello world\");\nassert(stripRight([lineSep] ~ \"hello world\" ~ lineSep) ==\n       [lineSep] ~ \"hello world\");\nassert(stripRight([paraSep] ~ \"hello world\" ~ paraSep) ==\n       [paraSep] ~ \"hello world\");\n--------------------\n  \n",
    "line" : 1261,
    "name" : "stripRight",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stripRight",
      "kind" : "function",
      "comment" : "\n    Strips trailing whitespace.\n\n    Examples:\n--------------------\nassert(stripRight(\"     hello world     \") ==\n       \"     hello world\");\nassert(stripRight(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"\\n\\t\\v\\rhello world\");\nassert(stripRight(\"hello world\") ==\n       \"hello world\");\nassert(stripRight([lineSep] ~ \"hello world\" ~ lineSep) ==\n       [lineSep] ~ \"hello world\");\nassert(stripRight([paraSep] ~ \"hello world\" ~ paraSep) ==\n       [paraSep] ~ \"hello world\");\n--------------------\n  \n",
      "line" : 1261,
      "type" : "C[](C[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C[]"
       }
      ],
      "endline" : 1271
     }
    ]
   },
   {
    "name" : "__unittestL1274_1619",
    "kind" : "function",
    "line" : 1274,
    "endline" : 1306
   },
   {
    "kind" : "template",
    "comment" : "\n    Strips both leading and trailing whitespace.\n\n    Examples:\n--------------------\nassert(strip(\"     hello world     \") ==\n       \"hello world\");\nassert(strip(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\");\nassert(strip(\"hello world\") ==\n       \"hello world\");\nassert(strip([lineSep] ~ \"hello world\" ~ [lineSep]) ==\n       \"hello world\");\nassert(strip([paraSep] ~ \"hello world\" ~ [paraSep]) ==\n       \"hello world\");\n--------------------\n  \n",
    "line" : 1306,
    "name" : "strip",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strip",
      "kind" : "function",
      "comment" : "\n    Strips both leading and trailing whitespace.\n\n    Examples:\n--------------------\nassert(strip(\"     hello world     \") ==\n       \"hello world\");\nassert(strip(\"\\n\\t\\v\\rhello world\\n\\t\\v\\r\") ==\n       \"hello world\");\nassert(strip(\"hello world\") ==\n       \"hello world\");\nassert(strip([lineSep] ~ \"hello world\" ~ [lineSep]) ==\n       \"hello world\");\nassert(strip([paraSep] ~ \"hello world\" ~ [paraSep]) ==\n       \"hello world\");\n--------------------\n  \n",
      "line" : 1306,
      "type" : "C[](C[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C[]"
       }
      ],
      "endline" : 1310
     }
    ]
   },
   {
    "name" : "__unittestL1313_1620",
    "kind" : "function",
    "line" : 1313,
    "endline" : 1327
   },
   {
    "name" : "__unittestL1327_1621",
    "kind" : "function",
    "line" : 1327,
    "endline" : 1357
   },
   {
    "name" : "__unittestL1357_1622",
    "kind" : "function",
    "line" : 1357,
    "endline" : 1391
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D str) ends with $(D delimiter), then $(D str) is returned without\n    $(D delimiter) on its end. If it $(D str) does $(I not) end with\n    $(D delimiter), then it is returned unchanged.\n\n    If no $(D delimiter) is given, then one trailing  $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(XREF uni, lineSep), or $(XREF uni, paraSep) is removed from\n    the end of $(D str). If $(D str) does not end with any of those characters,\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chomp(\" hello world  \\n\\r\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\r\\n\") == \" hello world  \");\nassert(chomp(\" hello world  \\n\\n\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\n\\n \") == \" hello world  \\n\\n \");\nassert(chomp(\" hello world  \\n\\n\" ~ [lineSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [paraSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world\") == \" hello world\");\nassert(chomp(\"\") == \"\");\n\nassert(chomp(\" hello world\", \"orld\") == \" hello w\");\nassert(chomp(\" hello world\", \" he\") == \" hello world\");\nassert(chomp(\"\", \"hello\") == \"\");\n--------------------\n  \n",
    "line" : 1391,
    "name" : "chomp",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "chomp",
      "kind" : "function",
      "comment" : "\n    If $(D str) ends with $(D delimiter), then $(D str) is returned without\n    $(D delimiter) on its end. If it $(D str) does $(I not) end with\n    $(D delimiter), then it is returned unchanged.\n\n    If no $(D delimiter) is given, then one trailing  $(D '\\r'), $(D '\\n'),\n    $(D \"\\r\\n\"), $(XREF uni, lineSep), or $(XREF uni, paraSep) is removed from\n    the end of $(D str). If $(D str) does not end with any of those characters,\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chomp(\" hello world  \\n\\r\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\r\\n\") == \" hello world  \");\nassert(chomp(\" hello world  \\n\\n\") == \" hello world  \\n\");\nassert(chomp(\" hello world  \\n\\n \") == \" hello world  \\n\\n \");\nassert(chomp(\" hello world  \\n\\n\" ~ [lineSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world  \\n\\n\" ~ [paraSep]) == \" hello world  \\n\\n\");\nassert(chomp(\" hello world\") == \" hello world\");\nassert(chomp(\"\") == \"\");\n\nassert(chomp(\" hello world\", \"orld\") == \" hello w\");\nassert(chomp(\" hello world\", \" he\") == \" hello world\");\nassert(chomp(\"\", \"hello\") == \"\");\n--------------------\n  \n",
      "line" : 1391,
      "type" : "C[](C[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C[]"
       }
      ],
      "endline" : 1430
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1433,
    "name" : "chomp",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "chomp",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 1433,
      "type" : "C1[](C1[] str, const(C2)[] delimiter)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C1[]"
       },
       {
        "name" : "delimiter",
        "type" : "const(C2)[]"
       }
      ],
      "endline" : 1456
     }
    ]
   },
   {
    "name" : "__unittestL1459_1623",
    "kind" : "function",
    "line" : 1459,
    "endline" : 1475
   },
   {
    "name" : "__unittestL1475_1624",
    "kind" : "function",
    "line" : 1475,
    "endline" : 1527
   },
   {
    "kind" : "template",
    "comment" : "\n    If $(D str) starts with $(D delimiter), then the part of $(D str) following\n    $(D delimiter) is returned. If it $(D str) does $(I not) start with\n    $(D delimiter), then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chompPrefix(\"hello world\", \"he\") == \"llo world\");\nassert(chompPrefix(\"hello world\", \"hello w\") == \"orld\");\nassert(chompPrefix(\"hello world\", \" world\") == \"hello world\");\nassert(chompPrefix(\"\", \"hello\") == \"\");\n--------------------\n \n",
    "line" : 1527,
    "name" : "chompPrefix",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "chompPrefix",
      "kind" : "function",
      "comment" : "\n    If $(D str) starts with $(D delimiter), then the part of $(D str) following\n    $(D delimiter) is returned. If it $(D str) does $(I not) start with\n    $(D delimiter), then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chompPrefix(\"hello world\", \"he\") == \"llo world\");\nassert(chompPrefix(\"hello world\", \"hello w\") == \"orld\");\nassert(chompPrefix(\"hello world\", \" world\") == \"hello world\");\nassert(chompPrefix(\"\", \"hello\") == \"\");\n--------------------\n \n",
      "line" : 1527,
      "type" : "C1[](C1[] str, C2[] delimiter)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C1[]"
       },
       {
        "name" : "delimiter",
        "type" : "C2[]"
       }
      ],
      "endline" : 1549
     }
    ]
   },
   {
    "name" : "__unittestL1552_1625",
    "kind" : "function",
    "line" : 1552,
    "endline" : 1560
   },
   {
    "name" : "__unittestL1560_1626",
    "kind" : "function",
    "line" : 1560,
    "endline" : 1592
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns $(D str) without its last character, if there is one. If $(D str)\n    ends with $(D \"\\r\\n\"), then both are removed. If $(D str) is empty, then\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chop(\"hello world\") == \"hello worl\");\nassert(chop(\"hello world\\n\") == \"hello world\");\nassert(chop(\"hello world\\r\") == \"hello world\");\nassert(chop(\"hello world\\n\\r\") == \"hello world\\n\");\nassert(chop(\"hello world\\r\\n\") == \"hello world\");\nassert(chop(\"Walter Bright\") == \"Walter Brigh\");\nassert(chop(\"\") == \"\");\n--------------------\n \n",
    "line" : 1592,
    "name" : "chop",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "chop",
      "kind" : "function",
      "comment" : "\n    Returns $(D str) without its last character, if there is one. If $(D str)\n    ends with $(D \"\\r\\n\"), then both are removed. If $(D str) is empty, then\n    then it is returned unchanged.\n\n    Examples:\n--------------------\nassert(chop(\"hello world\") == \"hello worl\");\nassert(chop(\"hello world\\n\") == \"hello world\");\nassert(chop(\"hello world\\r\") == \"hello world\");\nassert(chop(\"hello world\\n\\r\") == \"hello world\\n\");\nassert(chop(\"hello world\\r\\n\") == \"hello world\");\nassert(chop(\"Walter Bright\") == \"Walter Brigh\");\nassert(chop(\"\") == \"\");\n--------------------\n \n",
      "line" : 1592,
      "type" : "S(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 1604
     }
    ]
   },
   {
    "name" : "__unittestL1607_1627",
    "kind" : "function",
    "line" : 1607,
    "endline" : 1618
   },
   {
    "name" : "__unittestL1618_1628",
    "kind" : "function",
    "line" : 1618,
    "endline" : 1640
   },
   {
    "kind" : "template",
    "comment" : "\n    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
    "line" : 1640,
    "name" : "leftJustify",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "leftJustify",
      "kind" : "function",
      "comment" : "\n    Left justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
      "line" : 1640,
      "type" : "@trusted S(S s, size_t width, dchar fillChar = ' ')",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "width",
        "type" : "size_t"
       },
       {
        "name" : "fillChar",
        "deco" : "w",
        "default" : "' '"
       }
      ],
      "endline" : 1667
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
    "line" : 1675,
    "name" : "rightJustify",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "rightJustify",
      "kind" : "function",
      "comment" : "\n    Right justify $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
      "line" : 1675,
      "type" : "@trusted S(S s, size_t width, dchar fillChar = ' ')",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "width",
        "type" : "size_t"
       },
       {
        "name" : "fillChar",
        "deco" : "w",
        "default" : "' '"
       }
      ],
      "endline" : 1702
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    Center $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
    "line" : 1710,
    "name" : "center",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "center",
      "kind" : "function",
      "comment" : "\n    Center $(D s) in a field $(D width) characters wide. $(D fillChar)\n    is the character that will be used to fill up the space in the field that\n    $(D s) doesn't fill.\n  \n",
      "line" : 1710,
      "type" : "@trusted S(S s, size_t width, dchar fillChar = ' ')",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "width",
        "type" : "size_t"
       },
       {
        "name" : "fillChar",
        "deco" : "w",
        "default" : "' '"
       }
      ],
      "endline" : 1741
     }
    ]
   },
   {
    "name" : "__unittestL1743_1629",
    "kind" : "function",
    "line" : 1743,
    "endline" : 1775
   },
   {
    "kind" : "template",
    "comment" : "\n    Replace each tab character in $(D s) with the number of spaces necessary\n    to align the following character at the next tab stop where $(D tabSize)\n    is the distance between tab stops.\n  \n",
    "line" : 1775,
    "name" : "detab",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "detab",
      "kind" : "function",
      "comment" : "\n    Replace each tab character in $(D s) with the number of spaces necessary\n    to align the following character at the next tab stop where $(D tabSize)\n    is the distance between tab stops.\n  \n",
      "line" : 1775,
      "type" : "pure @trusted S(S s, size_t tabSize = 8)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "tabSize",
        "type" : "size_t",
        "default" : "8"
       }
      ],
      "endline" : 1831
     }
    ]
   },
   {
    "name" : "__unittestL1833_1630",
    "kind" : "function",
    "line" : 1833,
    "endline" : 1862
   },
   {
    "kind" : "template",
    "comment" : "\n    Replaces spaces in $(D s) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        s       = String to convert.\n        tabSize = Tab columns are $(D tabSize) spaces apart.\n \n",
    "line" : 1862,
    "name" : "entab",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "entab",
      "kind" : "function",
      "comment" : "\n    Replaces spaces in $(D s) with the optimal number of tabs.\n    All spaces and tabs at the end of a line are removed.\n\n    Params:\n        s       = String to convert.\n        tabSize = Tab columns are $(D tabSize) spaces apart.\n \n",
      "line" : 1862,
      "type" : "pure @trusted S(S s, size_t tabSize = 8)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "tabSize",
        "type" : "size_t",
        "default" : "8"
       }
      ],
      "endline" : 1959
     }
    ]
   },
   {
    "name" : "__unittestL1961_1631",
    "kind" : "function",
    "line" : 1961,
    "endline" : 2029
   },
   {
    "kind" : "template",
    "comment" : "\n    Replaces the characters in $(D str) which are keys in $(D transTable) with\n    their corresponding values in $(D transTable). $(D transTable) is an AA\n    where its keys are $(D dchar) and its values are either $(D dchar) or some\n    type of string. Also, if $(D toRemove) is given, the characters in it are\n    removed from $(D str) prior to translation. $(D str) itself is unaltered.\n    A copy with the changes is returned.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\nassert(translate(\"hello world\", transTable2) == \"h5llorange worangerld\");\n--------------------\n  \n",
    "line" : 2029,
    "name" : "translate",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type",
      "defaultDeco" : "ya"
     }
    ],
    "members" : [
     {
      "name" : "translate",
      "kind" : "function",
      "comment" : "\n    Replaces the characters in $(D str) which are keys in $(D transTable) with\n    their corresponding values in $(D transTable). $(D transTable) is an AA\n    where its keys are $(D dchar) and its values are either $(D dchar) or some\n    type of string. Also, if $(D toRemove) is given, the characters in it are\n    removed from $(D str) prior to translation. $(D str) itself is unaltered.\n    A copy with the changes is returned.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The AA indicating which characters to replace and what to\n                     replace them with.\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\ndchar[dchar] transTable1 = ['e' : '5', 'o' : '7', '5': 'q'];\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n\nstring[dchar] transTable2 = ['e' : \"5\", 'o' : \"orange\"];\nassert(translate(\"hello world\", transTable2) == \"h5llorange worangerld\");\n--------------------\n  \n",
      "line" : 2029,
      "type" : "@safe C1[](C1[] str, dchar[dchar] transTable, const(C2)[] toRemove = null)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C1[]"
       },
       {
        "name" : "transTable",
        "type" : "dchar[dchar]"
       },
       {
        "name" : "toRemove",
        "type" : "const(C2)[]",
        "default" : "null"
       }
      ],
      "endline" : 2035
     }
    ]
   },
   {
    "name" : "__unittestL2038_1632",
    "kind" : "function",
    "line" : 2038,
    "endline" : 2049
   },
   {
    "name" : "__unittestL2049_1633",
    "kind" : "function",
    "line" : 2049,
    "endline" : 2094
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 2094,
    "name" : "translate",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type",
      "defaultDeco" : "ya"
     }
    ],
    "members" : [
     {
      "name" : "translate",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 2094,
      "type" : "@safe C1[](C1[] str, S[dchar] transTable, const(C2)[] toRemove = null)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C1[]"
       },
       {
        "name" : "transTable",
        "type" : "S[dchar]"
       },
       {
        "name" : "toRemove",
        "type" : "const(C2)[]",
        "default" : "null"
       }
      ],
      "endline" : 2100
     }
    ]
   },
   {
    "name" : "__unittestL2102_1634",
    "kind" : "function",
    "line" : 2102,
    "endline" : 2148
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2148,
    "name" : "translateImpl",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "translateImpl",
      "kind" : "function",
      "line" : 2148,
      "storageClass" : [
       "auto"
      ],
      "type" : "@trusted (C1[] str, T transTable, const(C2)[] toRemove)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C1[]"
       },
       {
        "name" : "transTable",
        "type" : "T"
       },
       {
        "name" : "toRemove",
        "type" : "const(C2)[]"
       }
      ],
      "endline" : 2173
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    This is an $(I $(RED ASCII-only)) overload of $(LREF _translate). It\n    will $(I not) work with Unicode. It exists as an optimization for the\n    cases where Unicode processing is not necessary.\n\n    Unlike the other overloads of $(LREF _translate), this one does not take\n    an AA. Rather, it takes a $(D string) generated by $(LREF makeTrans).\n\n    The array generated by $(D makeTrans) is $(D 256) elements long such that\n    the index is equal to the ASCII character being replaced and the value is\n    equal to the character that it's being replaced with. Note that translate\n    does not decode any of the characters, so you can actually pass it Extended\n    ASCII characters if you want to (ASCII only actually uses $(D 128)\n    characters), but be warned that Extended ASCII characters are not valid\n    Unicode and therefore will result in a $(D UTFException) being thrown from\n    most other Phobos functions.\n\n    Also, because no decoding occurs, it is possible to use this overload to\n    translate ASCII characters within a proper UTF-8 string without altering the\n    other, non-ASCII characters. It's replacing any code unit greater than\n    $(D 127) with another code unit or replacing any code unit with another code\n    unit greater than $(D 127) which will cause UTF validation issues.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTrans).\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\nauto transTable1 = makeTrans(\"eo5\", \"57q\");\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n--------------------\n  \n",
    "line" : 2217,
    "name" : "translate",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type",
      "defaultDeco" : "ya"
     }
    ],
    "members" : [
     {
      "name" : "translate",
      "kind" : "function",
      "comment" : "\n    This is an $(I $(RED ASCII-only)) overload of $(LREF _translate). It\n    will $(I not) work with Unicode. It exists as an optimization for the\n    cases where Unicode processing is not necessary.\n\n    Unlike the other overloads of $(LREF _translate), this one does not take\n    an AA. Rather, it takes a $(D string) generated by $(LREF makeTrans).\n\n    The array generated by $(D makeTrans) is $(D 256) elements long such that\n    the index is equal to the ASCII character being replaced and the value is\n    equal to the character that it's being replaced with. Note that translate\n    does not decode any of the characters, so you can actually pass it Extended\n    ASCII characters if you want to (ASCII only actually uses $(D 128)\n    characters), but be warned that Extended ASCII characters are not valid\n    Unicode and therefore will result in a $(D UTFException) being thrown from\n    most other Phobos functions.\n\n    Also, because no decoding occurs, it is possible to use this overload to\n    translate ASCII characters within a proper UTF-8 string without altering the\n    other, non-ASCII characters. It's replacing any code unit greater than\n    $(D 127) with another code unit or replacing any code unit with another code\n    unit greater than $(D 127) which will cause UTF validation issues.\n\n    See_Also:\n        $(LREF tr)\n        $(XREF array, replace)\n\n    Params:\n        str        = The original string.\n        transTable = The string indicating which characters to replace and what\n                     to replace them with. It is generated by $(LREF makeTrans).\n        toRemove   = The characters to remove from the string.\n\n        Examples:\n--------------------\nauto transTable1 = makeTrans(\"eo5\", \"57q\");\nassert(translate(\"hello world\", transTable1) == \"h5ll7 w7rld\");\n\nassert(translate(\"hello world\", transTable1, \"low\") == \"h5 rd\");\n--------------------\n  \n",
      "line" : 2217,
      "type" : "nothrow @trusted C[](in char[] str, in char[] transTable, in char[] toRemove = null)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "transTable",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "toRemove",
        "type" : "char[]",
        "storageClass" : [
         "in"
        ],
        "default" : "null"
       }
      ],
      "endline" : 2246
     }
    ]
   },
   {
    "name" : "makeTrans",
    "kind" : "function",
    "comment" : " Ditto \n",
    "line" : 2250,
    "deco" : "FNaNbNexAaxAaZAya",
    "originalType" : "pure nothrow @trusted string(in char[] from, in char[] to)",
    "parameters" : [
     {
      "name" : "from",
      "deco" : "xAa"
     },
     {
      "name" : "to",
      "deco" : "xAa"
     }
    ],
    "endline" : 2270
   },
   {
    "name" : "__unittestL2273_1635",
    "kind" : "function",
    "line" : 2273,
    "endline" : 2281
   },
   {
    "name" : "__unittestL2281_1636",
    "kind" : "function",
    "line" : 2281,
    "endline" : 2338
   },
   {
    "kind" : "template",
    "comment" : "\n Format arguments into a string.\n\n  $(RED format's current implementation has been replaced with $(LREF xformat)'s\n        implementation. in November 2012.\n        This is seamless for most code, but it makes it so that the only\n        argument that can be a format string is the first one, so any\n        code which used multiple format strings has broken. Please change\n        your calls to format accordingly.\n\n        e.g.:\n----\nformat(\"key = %s\", key, \", value = %s\", value)\n----\n        needs to be rewritten as:\n----\nformat(\"key = %s, value = %s\", key, value)\n----\n   )\n \n",
    "line" : 2338,
    "name" : "format",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "format",
      "kind" : "function",
      "comment" : "\n Format arguments into a string.\n\n  $(RED format's current implementation has been replaced with $(LREF xformat)'s\n        implementation. in November 2012.\n        This is seamless for most code, but it makes it so that the only\n        argument that can be a format string is the first one, so any\n        code which used multiple format strings has broken. Please change\n        your calls to format accordingly.\n\n        e.g.:\n----\nformat(\"key = %s\", key, \", value = %s\", value)\n----\n        needs to be rewritten as:\n----\nformat(\"key = %s, value = %s\", key, value)\n----\n   )\n \n",
      "line" : 2338,
      "type" : "string(in Char[] fmt, Args args)",
      "parameters" : [
       {
        "name" : "fmt",
        "type" : "Char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 2350
     }
    ]
   },
   {
    "name" : "__unittestL2352_1637",
    "kind" : "function",
    "line" : 2352,
    "endline" : 2396
   },
   {
    "kind" : "template",
    "comment" : "\n Format arguments into string <i>s</i> which must be large\n enough to hold the result. Throws RangeError if it is not.\n Returns: s\n\n  $(RED sformat's current implementation has been replaced with $(LREF xsformat)'s\n        implementation. in November 2012.\n        This is seamless for most code, but it makes it so that the only\n        argument that can be a format string is the first one, so any\n        code which used multiple format strings has broken. Please change\n        your calls to sformat accordingly.\n\n        e.g.:\n----\nsformat(buf, \"key = %s\", key, \", value = %s\", value)\n----\n        needs to be rewritten as:\n----\nsformat(buf, \"key = %s, value = %s\", key, value)\n----\n   )\n \n",
    "line" : 2396,
    "name" : "sformat",
    "parameters" : [
     {
      "name" : "Char",
      "kind" : "type"
     },
     {
      "name" : "Args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "sformat",
      "kind" : "function",
      "comment" : "\n Format arguments into string <i>s</i> which must be large\n enough to hold the result. Throws RangeError if it is not.\n Returns: s\n\n  $(RED sformat's current implementation has been replaced with $(LREF xsformat)'s\n        implementation. in November 2012.\n        This is seamless for most code, but it makes it so that the only\n        argument that can be a format string is the first one, so any\n        code which used multiple format strings has broken. Please change\n        your calls to sformat accordingly.\n\n        e.g.:\n----\nsformat(buf, \"key = %s\", key, \", value = %s\", value)\n----\n        needs to be rewritten as:\n----\nsformat(buf, \"key = %s, value = %s\", key, value)\n----\n   )\n \n",
      "line" : 2396,
      "type" : "char[](char[] buf, in Char[] fmt, Args args)",
      "parameters" : [
       {
        "name" : "buf",
        "type" : "char[]"
       },
       {
        "name" : "fmt",
        "type" : "Char[]",
        "storageClass" : [
         "in"
        ]
       },
       {
        "name" : "args",
        "type" : "Args"
       }
      ],
      "endline" : 2441
     }
    ]
   },
   {
    "name" : "__unittestL2443_1638",
    "kind" : "function",
    "line" : 2443,
    "endline" : 2473
   },
   {
    "name" : "xformat",
    "kind" : "alias",
    "comment" : "\n $(RED Deprecated. It will be removed in November 2013.\n       Please us std.string.format instead)\n\n Format arguments into a string.\n\n $(LREF format) was changed to use this implementation in November 2012,\n \n",
    "line" : 2473,
    "storageClass" : [
     "deprecated"
    ]
   },
   {
    "name" : "__unittestL2475_1639",
    "kind" : "function",
    "line" : 2475,
    "endline" : 2503
   },
   {
    "name" : "xsformat",
    "kind" : "alias",
    "comment" : "\n $(RED Deprecated. It will be removed in November 2013).\n       Please us std.string.sformat instead)\n\n Format arguments into string $(D buf) which must be large\n enough to hold the result. Throws RangeError if it is not.\n\n $(LREF sformat) was changed to use this implementation in November 2012,\n \n",
    "line" : 2503,
    "storageClass" : [
     "deprecated"
    ]
   },
   {
    "name" : "__unittestL2505_1640",
    "kind" : "function",
    "line" : 2505,
    "endline" : 2545
   },
   {
    "kind" : "template",
    "comment" : "\n See if character c is in the pattern.\n Patterns:\n\n  A <i>pattern</i> is an array of characters much like a <i>character\n  class</i> in regular expressions. A sequence of characters\n  can be given, such as \"abcde\". The '-' can represent a range\n  of characters, as \"a-e\" represents the same pattern as \"abcde\".\n  \"a-fA-F0-9\" represents all the hex characters.\n  If the first character of a pattern is '^', then the pattern\n  is negated, i.e. \"^0-9\" means any character except a digit.\n  The functions inPattern, <b>countchars</b>, <b>removeschars</b>,\n  and <b>squeeze</b>\n  use patterns.\n\n Note: In the future, the pattern syntax may be improved\n  to be more like regular expression character classes.\n \n",
    "line" : 2545,
    "name" : "inPattern",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "inPattern",
      "kind" : "function",
      "comment" : "\n See if character c is in the pattern.\n Patterns:\n\n  A <i>pattern</i> is an array of characters much like a <i>character\n  class</i> in regular expressions. A sequence of characters\n  can be given, such as \"abcde\". The '-' can represent a range\n  of characters, as \"a-e\" represents the same pattern as \"abcde\".\n  \"a-fA-F0-9\" represents all the hex characters.\n  If the first character of a pattern is '^', then the pattern\n  is negated, i.e. \"^0-9\" means any character except a digit.\n  The functions inPattern, <b>countchars</b>, <b>removeschars</b>,\n  and <b>squeeze</b>\n  use patterns.\n\n Note: In the future, the pattern syntax may be improved\n  to be more like regular expression character classes.\n \n",
      "line" : 2545,
      "type" : "bool(dchar c, in S pattern)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "pattern",
        "type" : "S",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2574
     }
    ]
   },
   {
    "name" : "__unittestL2577_1641",
    "kind" : "function",
    "line" : 2577,
    "endline" : 2628
   },
   {
    "kind" : "template",
    "comment" : "\n See if character c is in the intersection of the patterns.\n \n",
    "line" : 2628,
    "name" : "inPattern",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "inPattern",
      "kind" : "function",
      "comment" : "\n See if character c is in the intersection of the patterns.\n \n",
      "line" : 2628,
      "type" : "bool(dchar c, S[] patterns)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       },
       {
        "name" : "patterns",
        "type" : "S[]"
       }
      ],
      "endline" : 2638
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Count characters in s that match pattern.\n \n",
    "line" : 2645,
    "name" : "countchars",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     },
     {
      "name" : "S1",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "countchars",
      "kind" : "function",
      "comment" : "\n Count characters in s that match pattern.\n \n",
      "line" : 2645,
      "type" : "size_t(S s, in S1 pattern)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "pattern",
        "type" : "S1",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2653
     }
    ]
   },
   {
    "name" : "__unittestL2655_1642",
    "kind" : "function",
    "line" : 2655,
    "endline" : 2672
   },
   {
    "kind" : "template",
    "comment" : "\n Return string that is s with all characters removed that match pattern.\n \n",
    "line" : 2672,
    "name" : "removechars",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "removechars",
      "kind" : "function",
      "comment" : "\n Return string that is s with all characters removed that match pattern.\n \n",
      "line" : 2672,
      "type" : "S(S s, in S pattern)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "pattern",
        "type" : "S",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 2693
     }
    ]
   },
   {
    "name" : "__unittestL2695_1643",
    "kind" : "function",
    "line" : 2695,
    "endline" : 2718
   },
   {
    "kind" : "template",
    "comment" : "\n Return string where sequences of a character in s[] from pattern[]\n are replaced with a single instance of that character.\n If pattern is null, it defaults to all characters.\n \n",
    "line" : 2718,
    "name" : "squeeze",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "squeeze",
      "kind" : "function",
      "comment" : "\n Return string where sequences of a character in s[] from pattern[]\n are replaced with a single instance of that character.\n If pattern is null, it defaults to all characters.\n \n",
      "line" : 2718,
      "type" : "S(S s, in S pattern = null)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "pattern",
        "type" : "S",
        "storageClass" : [
         "in"
        ],
        "default" : "null"
       }
      ],
      "endline" : 2755
     }
    ]
   },
   {
    "name" : "__unittestL2757_1644",
    "kind" : "function",
    "line" : 2757,
    "endline" : 2796
   },
   {
    "kind" : "template",
    "comment" : "\n Finds the position $(D_PARAM pos) of the first character in $(D_PARAM\n s) that does not match $(D_PARAM pattern) (in the terminology used by\n $(LINK2 std_string.html,inPattern)). Updates $(D_PARAM s =\n s[pos..$]). Returns the slice from the beginning of the original\n (before update) string up to, and excluding, $(D_PARAM pos).\n\n Example:\n ---\nstring s = \"123abc\";\nstring t = munch(s, \"0123456789\");\nassert(t == \"123\" && s == \"abc\");\nt = munch(s, \"0123456789\");\nassert(t == \"\" && s == \"abc\");\n ---\n\nThe $(D_PARAM munch) function is mostly convenient for skipping\ncertain category of characters (e.g. whitespace) when parsing\nstrings. (In such cases, the return value is not used.)\n \n",
    "line" : 2796,
    "name" : "munch",
    "parameters" : [
     {
      "name" : "S1",
      "kind" : "type"
     },
     {
      "name" : "S2",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "munch",
      "kind" : "function",
      "comment" : "\n Finds the position $(D_PARAM pos) of the first character in $(D_PARAM\n s) that does not match $(D_PARAM pattern) (in the terminology used by\n $(LINK2 std_string.html,inPattern)). Updates $(D_PARAM s =\n s[pos..$]). Returns the slice from the beginning of the original\n (before update) string up to, and excluding, $(D_PARAM pos).\n\n Example:\n ---\nstring s = \"123abc\";\nstring t = munch(s, \"0123456789\");\nassert(t == \"123\" && s == \"abc\");\nt = munch(s, \"0123456789\");\nassert(t == \"\" && s == \"abc\");\n ---\n\nThe $(D_PARAM munch) function is mostly convenient for skipping\ncertain category of characters (e.g. whitespace) when parsing\nstrings. (In such cases, the return value is not used.)\n \n",
      "line" : 2796,
      "type" : "S1(ref S1 s, S2 pattern)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S1",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "pattern",
        "type" : "S2"
       }
      ],
      "endline" : 2809
     }
    ]
   },
   {
    "name" : "__unittestL2811_1645",
    "kind" : "function",
    "line" : 2811,
    "endline" : 2828
   },
   {
    "kind" : "template",
    "comment" : "\n Return string that is the 'successor' to s[].\n If the rightmost character is a-zA-Z0-9, it is incremented within\n its case or digits. If it generates a carry, the process is\n repeated with the one to its immediate left.\n \n",
    "line" : 2828,
    "name" : "succ",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "succ",
      "kind" : "function",
      "comment" : "\n Return string that is the 'successor' to s[].\n If the rightmost character is a-zA-Z0-9, it is incremented within\n its case or digits. If it generates a carry, the process is\n repeated with the one to its immediate left.\n \n",
      "line" : 2828,
      "type" : "S(S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       }
      ],
      "endline" : 2870
     }
    ]
   },
   {
    "name" : "__unittestL2872_1646",
    "kind" : "function",
    "line" : 2872,
    "endline" : 2932
   },
   {
    "kind" : "template",
    "comment" : "\n    Replaces the characters in $(D str) which are in $(D from) with the\n    the corresponding characters in $(D to) and returns the resulting string.\n\n    $(D tr) is based on\n    $(WEB pubs.opengroup.org/onlinepubs/9699919799/utilities/_tr.html, Posix's tr),\n    though it doesn't do everything that the Posix utility does.\n\n    Params:\n        str       = The original string.\n        from      = The characters to replace.\n        to        = The characters to replace with.\n        modifiers = String containing modifiers.\n\n    Modifiers:\n        $(BOOKTABLE,\n        $(TR $(TD Modifier) $(TD Description))\n        $(TR $(TD $(D 'c')) $(TD Complement the list of characters in $(D from)))\n        $(TR $(TD $(D 'd')) $(TD Removes matching characters with no corresponding\n                              replacement in $(D to)))\n        $(TR $(TD $(D 's')) $(TD Removes adjacent duplicates in the replaced\n                              characters))\n        )\n\n    If the modifier $(D 'd') is present, then the number of characters in\n    $(D to) may be only $(D 0) or $(D 1).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is empty, then\n    $(D to) is taken to be the same as $(D from).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is shorter than\n    $(D from), then $(D to) is extended by replicating the last charcter in\n    $(D to).\n\n    Both $(D from) and $(D to) may contain ranges using the $(D '-') character\n    (e.g. $(D \"a-d\") is synonymous with $(D \"abcd\").) Neither accept a leading\n    $(D '^') as meaning the complement of the string (use the $(D 'c') modifier\n    for that).\n  \n",
    "line" : 2932,
    "name" : "tr",
    "parameters" : [
     {
      "name" : "C1",
      "kind" : "type"
     },
     {
      "name" : "C2",
      "kind" : "type"
     },
     {
      "name" : "C3",
      "kind" : "type"
     },
     {
      "name" : "C4",
      "kind" : "type",
      "defaultDeco" : "ya"
     }
    ],
    "members" : [
     {
      "name" : "tr",
      "kind" : "function",
      "comment" : "\n    Replaces the characters in $(D str) which are in $(D from) with the\n    the corresponding characters in $(D to) and returns the resulting string.\n\n    $(D tr) is based on\n    $(WEB pubs.opengroup.org/onlinepubs/9699919799/utilities/_tr.html, Posix's tr),\n    though it doesn't do everything that the Posix utility does.\n\n    Params:\n        str       = The original string.\n        from      = The characters to replace.\n        to        = The characters to replace with.\n        modifiers = String containing modifiers.\n\n    Modifiers:\n        $(BOOKTABLE,\n        $(TR $(TD Modifier) $(TD Description))\n        $(TR $(TD $(D 'c')) $(TD Complement the list of characters in $(D from)))\n        $(TR $(TD $(D 'd')) $(TD Removes matching characters with no corresponding\n                              replacement in $(D to)))\n        $(TR $(TD $(D 's')) $(TD Removes adjacent duplicates in the replaced\n                              characters))\n        )\n\n    If the modifier $(D 'd') is present, then the number of characters in\n    $(D to) may be only $(D 0) or $(D 1).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is empty, then\n    $(D to) is taken to be the same as $(D from).\n\n    If the modifier $(D 'd') is $(I not) present, and $(D to) is shorter than\n    $(D from), then $(D to) is extended by replicating the last charcter in\n    $(D to).\n\n    Both $(D from) and $(D to) may contain ranges using the $(D '-') character\n    (e.g. $(D \"a-d\") is synonymous with $(D \"abcd\").) Neither accept a leading\n    $(D '^') as meaning the complement of the string (use the $(D 'c') modifier\n    for that).\n  \n",
      "line" : 2932,
      "type" : "C1[](C1[] str, const(C2)[] from, const(C3)[] to, const(C4)[] modifiers = null)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "C1[]"
       },
       {
        "name" : "from",
        "type" : "const(C2)[]"
       },
       {
        "name" : "to",
        "type" : "const(C3)[]"
       },
       {
        "name" : "modifiers",
        "type" : "const(C4)[]",
        "default" : "null"
       }
      ],
      "endline" : 3040
     }
    ]
   },
   {
    "name" : "__unittestL3042_1647",
    "kind" : "function",
    "line" : 3042,
    "endline" : 3130
   },
   {
    "name" : "isNumeric",
    "kind" : "function",
    "comment" : "\n [in] string s can be formatted in the following ways:\n\n Integer Whole Number:\n (for byte, ubyte, short, ushort, int, uint, long, and ulong)\n ['+'|'-']digit(s)[U|L|UL]\n\n examples: 123, 123UL, 123L, +123U, -123L\n\n Floating-Point Number:\n (for float, double, real, ifloat, idouble, and ireal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|inf|-inf]\n\n examples: +123., -123.01, 123.3e-10f, 123.3e-10fi, 123.3e-10L\n\n (for cfloat, cdouble, and creal)\n ['+'|'-']digit(s)[.][digit(s)][[e-|e+]digit(s)][+]\n         [digit(s)[.][digit(s)][[e-|e+]digit(s)][i|f|L|Li|fi]]\n      or [nan|nani|nan+nani|inf|-inf]\n\n examples: nan, -123e-1+456.9e-10Li, +123e+10+456i, 123+456\n\n [in] bool bAllowSep\n False by default, but when set to true it will accept the\n separator characters \",\" and \"_\" within the string, but these\n characters should be stripped from the string before using any\n of the conversion functions like toInt(), toFloat(), and etc\n else an error will occur.\n\n Also please note, that no spaces are allowed within the string\n anywhere whether it's a leading, trailing, or embedded space(s),\n thus they too must be stripped from the string before using this\n function, or any of the conversion functions.\n \n",
    "line" : 3130,
    "deco" : "FAxaxbZb",
    "originalType" : "bool(const(char)[] s, in bool bAllowSep = false)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Axa"
     },
     {
      "name" : "bAllowSep",
      "deco" : "xb",
      "default" : "false"
     }
    ],
    "endline" : 3270
   },
   {
    "name" : "__unittestL3273_1648",
    "kind" : "function",
    "line" : 3273,
    "endline" : 3342
   },
   {
    "name" : "soundex",
    "kind" : "function",
    "comment" : "\n Soundex algorithm.\n\n The Soundex algorithm converts a word into 4 characters\n based on how the word sounds phonetically. The idea is that\n two spellings that sound alike will have the same Soundex\n value, which means that Soundex can be used for fuzzy matching\n of names.\n\n Params:\n  string = String to convert to Soundex representation.\n  buffer = Optional 4 char array to put the resulting Soundex\n      characters into. If null, the return value\n      buffer will be allocated on the heap.\n Returns:\n  The four character array with the Soundex result in it.\n  Returns null if there is no Soundex representation for the string.\n\n See_Also:\n  $(LINK2 http://en.wikipedia.org/wiki/Soundex, Wikipedia),\n  $(LUCKY The Soundex Indexing System)\n\n Bugs:\n  Only works well with English names.\n  There are other arguably better Soundex algorithms,\n  but this one is the standard one.\n \n",
    "line" : 3342,
    "deco" : "FAxaAaZAa",
    "parameters" : [
     {
      "name" : "string",
      "deco" : "Axa"
     },
     {
      "name" : "buffer",
      "deco" : "Aa",
      "default" : "null"
     }
    ],
    "endline" : 3408
   },
   {
    "name" : "__unittestL3410_1649",
    "kind" : "function",
    "line" : 3410,
    "endline" : 3488
   },
   {
    "name" : "abbrev",
    "kind" : "function",
    "comment" : "\n Construct an associative array consisting of all\n abbreviations that uniquely map to the strings in values.\n\n This is useful in cases where the user is expected to type\n in one of a known set of strings, and the program will helpfully\n autocomplete the string once sufficient characters have been\n entered that uniquely identify it.\n Example:\n ---\n import std.stdio;\n import std.string;\n\n void main()\n {\n    static string[] list = [ \"food\", \"foxy\" ];\n\n    auto abbrevs = std.string.abbrev(list);\n\n    foreach (key, value; abbrevs)\n    {\n       writefln(\"%s => %s\", key, value);\n    }\n }\n ---\n produces the output:\n <pre>\n fox =&gt; foxy\n food =&gt; food\n foxy =&gt; foxy\n foo =&gt; food\n </pre>\n \n",
    "line" : 3488,
    "deco" : "FAAyaZHAyaAya",
    "parameters" : [
     {
      "name" : "values",
      "deco" : "AAya"
     }
    ],
    "endline" : 3525
   },
   {
    "name" : "__unittestL3527_1650",
    "kind" : "function",
    "line" : 3527,
    "endline" : 3560
   },
   {
    "kind" : "template",
    "comment" : "\n Compute column number after string if string starts in the\n leftmost column, which is numbered starting from 0.\n \n",
    "line" : 3560,
    "name" : "column",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "column",
      "kind" : "function",
      "comment" : "\n Compute column number after string if string starts in the\n leftmost column, which is numbered starting from 0.\n \n",
      "line" : 3560,
      "type" : "size_t(S str, size_t tabsize = 8)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       },
       {
        "name" : "tabsize",
        "type" : "size_t",
        "default" : "8"
       }
      ],
      "endline" : 3585
     }
    ]
   },
   {
    "name" : "__unittestL3587_1651",
    "kind" : "function",
    "line" : 3587,
    "endline" : 3616
   },
   {
    "kind" : "template",
    "comment" : "\n Wrap text into a paragraph.\n\n The input text string s is formed into a paragraph\n by breaking it up into a sequence of lines, delineated\n by \\n, such that the number of columns is not exceeded\n on each line.\n The last line is terminated with a \\n.\n Params:\n  s = text string to be wrapped\n  columns = maximum number of _columns in the paragraph\n  firstindent = string used to _indent first line of the paragraph\n  indent = string to use to _indent following lines of the paragraph\n  tabsize = column spacing of tabs\n Returns:\n  The resulting paragraph.\n \n",
    "line" : 3616,
    "name" : "wrap",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "wrap",
      "kind" : "function",
      "comment" : "\n Wrap text into a paragraph.\n\n The input text string s is formed into a paragraph\n by breaking it up into a sequence of lines, delineated\n by \\n, such that the number of columns is not exceeded\n on each line.\n The last line is terminated with a \\n.\n Params:\n  s = text string to be wrapped\n  columns = maximum number of _columns in the paragraph\n  firstindent = string used to _indent first line of the paragraph\n  indent = string to use to _indent following lines of the paragraph\n  tabsize = column spacing of tabs\n Returns:\n  The resulting paragraph.\n \n",
      "line" : 3616,
      "type" : "S(S s, size_t columns = 80, S firstindent = null, S indent = null, size_t tabsize = 8)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       },
       {
        "name" : "columns",
        "type" : "size_t",
        "default" : "80"
       },
       {
        "name" : "firstindent",
        "type" : "S",
        "default" : "null"
       },
       {
        "name" : "indent",
        "type" : "S",
        "default" : "null"
       },
       {
        "name" : "tabsize",
        "type" : "size_t",
        "default" : "8"
       }
      ],
      "endline" : 3679
     }
    ]
   },
   {
    "name" : "__unittestL3681_1652",
    "kind" : "function",
    "line" : 3681,
    "endline" : 3729
   },
   {
    "kind" : "template",
    "comment" : "\n Removes indentation from a multi-line string or an array of single-line strings.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n A StringException will be thrown if inconsistent indentation prevents\n the input from being outdented.\n\n Works at compile-time.\n\n Example:\n ---\n writeln(q{\n     import std.stdio;\n     void main() {\n         writeln(\"Hello\");\n     }\n }.outdent());\n ---\n\n Output:\n ---\n\n import std.stdio;\n void main() {\n     writeln(\"Hello\");\n }\n\n ---\n\n \n",
    "line" : 3729,
    "name" : "outdent",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "outdent",
      "kind" : "function",
      "comment" : "\n Removes indentation from a multi-line string or an array of single-line strings.\n\n This uniformly outdents the text as much as possible.\n Whitespace-only lines are always converted to blank lines.\n\n A StringException will be thrown if inconsistent indentation prevents\n the input from being outdented.\n\n Works at compile-time.\n\n Example:\n ---\n writeln(q{\n     import std.stdio;\n     void main() {\n         writeln(\"Hello\");\n     }\n }.outdent());\n ---\n\n Output:\n ---\n\n import std.stdio;\n void main() {\n     writeln(\"Hello\");\n }\n\n ---\n\n \n",
      "line" : 3729,
      "type" : "S(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 3732
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3735,
    "name" : "outdent",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "outdent",
      "kind" : "function",
      "comment" : " ditto\n",
      "line" : 3735,
      "type" : "S[](S[] lines)",
      "parameters" : [
       {
        "name" : "lines",
        "type" : "S[]"
       }
      ],
      "endline" : 3789
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3792,
    "name" : "ctfe_strip",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ctfe_strip",
      "kind" : "function",
      "line" : 3792,
      "type" : "S(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 3795
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3798,
    "name" : "ctfe_stripRight",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ctfe_stripRight",
      "kind" : "function",
      "line" : 3798,
      "type" : "S(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 3814
     }
    ]
   },
   {
    "name" : "__unittestL3843_1653",
    "kind" : "function",
    "line" : 3843,
    "endline" : 3907
   }
  ]
 },
 {
  "name" : "std.syserror",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/syserror.d",
  "comment" : "\n Convert Win32 error code to string\n\n Source:    $(PHOBOSSRC std/_syserror.d)\n",
  "members" : [
   {
    "name" : "SysError",
    "kind" : "class",
    "line" : 17,
    "members" : [
     {
      "name" : "std.c.stdio",
      "kind" : "import",
      "line" : 18,
      "protection" : "private"
     },
     {
      "name" : "std.c.string",
      "kind" : "import",
      "line" : 19,
      "protection" : "private"
     },
     {
      "name" : "std.string",
      "kind" : "import",
      "line" : 20,
      "protection" : "private"
     },
     {
      "name" : "msg",
      "kind" : "function",
      "line" : 22,
      "storageClass" : [
       "static"
      ],
      "deco" : "FkZAya",
      "parameters" : [
       {
        "name" : "errcode",
        "deco" : "k"
       }
      ],
      "endline" : 48
     }
    ]
   }
  ]
 },
 {
  "name" : "std.system",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/system.d",
  "comment" : "\n Information about the target operating system, environment, and CPU.\n\n Macros:\n      WIKI = Phobos/StdSystem\n\n  Copyright: Copyright Digital Mars 2000 - 2011\n  License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n  Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n  Source:    $(PHOBOSSRC std/_system.d)\n \n",
  "members" : [
   {
    "name" : "OS",
    "kind" : "enum",
    "comment" : "\n        Operating system.\n\n        Note:\n            This is for cases where you need a value representing the OS at\n            runtime. If you're doing something which should compile differently\n            on different OSes, then please use $(D version(Windows)),\n            $(D version(linux)), etc.\n\n        See_Also:\n            <a href=\"../version.html#PredefinedVersions\">Predefined Versions</a>\n      \n",
    "line" : 31,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "win32",
      "kind" : "enum member",
      "comment" : " Microsoft 32 bit Windows systems\n",
      "line" : 32
     },
     {
      "name" : "win64",
      "kind" : "enum member",
      "comment" : " Microsoft 64 bit Windows systems\n",
      "line" : 33
     },
     {
      "name" : "linux",
      "kind" : "enum member",
      "comment" : " All Linux Systems\n",
      "line" : 34
     },
     {
      "name" : "osx",
      "kind" : "enum member",
      "comment" : " Mac OS X\n",
      "line" : 35
     },
     {
      "name" : "freeBSD",
      "kind" : "enum member",
      "comment" : " FreeBSD\n",
      "line" : 36
     },
     {
      "name" : "solaris",
      "kind" : "enum member",
      "comment" : " Solaris\n",
      "line" : 37
     },
     {
      "name" : "otherPosix",
      "kind" : "enum member",
      "comment" : " Other Posix Systems\n",
      "line" : 38
     }
    ]
   },
   {
    "name" : "os",
    "kind" : "variable",
    "comment" : " The OS that the program was compiled for.\n",
    "line" : 44,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yE3std6system2OS",
    "originalType" : "OS",
    "init" : "cast(OS)3"
   },
   {
    "name" : "Endian",
    "kind" : "enum",
    "comment" : "\n        Byte order endianness.\n\n        Note:\n            This is intended for cases where you need to deal with endianness at\n            runtime. If you're doing something which should compile differently\n            depending on whether you're compiling on a big endian or little\n            endian machine, then please use $(D version(BigEndian)) and\n            $(D version(LittleEndian)).\n\n        See_Also:\n            <a href=\"../version.html#PredefinedVersions\">Predefined Versions</a>\n      \n",
    "line" : 64,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "bigEndian",
      "kind" : "enum member",
      "comment" : " Big endian byte order\n",
      "line" : 65
     },
     {
      "name" : "littleEndian",
      "kind" : "enum member",
      "comment" : " Little endian byte order\n",
      "line" : 66
     }
    ]
   },
   {
    "name" : "endian",
    "kind" : "variable",
    "comment" : " The endianness that the program was compiled for.\n",
    "line" : 70,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yE3std6system6Endian",
    "originalType" : "Endian",
    "init" : "cast(Endian)1"
   }
  ]
 },
 {
  "name" : "std.traits",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/traits.d",
  "comment" : "\n Templates with which to extract information about types and symbols at\n compile time.\n\n Macros:\n  WIKI = Phobos/StdTraits\n\n Copyright: Copyright Digital Mars 2005 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright),\n            Tomasz Stachowiak ($(D isExpressionTuple)),\n            $(WEB erdani.org, Andrei Alexandrescu),\n            Shin Fujishiro,\n            $(WEB octarineparrot.com, Robert Clipsham),\n            $(WEB klickverbot.at, David Nadlinger),\n            Kenji Hara,\n            Shoichi Kato\n Source:    $(PHOBOSSRC std/_traits.d)\n \n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 28,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 29,
    "protection" : "private"
   },
   {
    "name" : "std.typecons",
    "kind" : "import",
    "line" : 30,
    "protection" : "private"
   },
   {
    "name" : "core.vararg",
    "kind" : "import",
    "line" : 31,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 43,
    "name" : "Demangle",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Demangle",
      "kind" : "struct",
      "line" : 43,
      "members" : [
       {
        "name" : "value",
        "kind" : "variable",
        "line" : 44,
        "type" : "T"
       },
       {
        "name" : "rest",
        "kind" : "variable",
        "line" : 45,
        "type" : "string"
       }
      ]
     }
    ]
   },
   {
    "name" : "demangleParameterStorageClass",
    "kind" : "function",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 49,
    "deco" : "FAyaZS3std6traits15__T8DemangleTkZ8Demangle",
    "parameters" : [
     {
      "name" : "mstr",
      "deco" : "Aya"
     }
    ],
    "endline" : 77
   },
   {
    "name" : "demangleFunctionAttributes",
    "kind" : "function",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 80,
    "deco" : "FAyaZS3std6traits15__T8DemangleTkZ8Demangle",
    "parameters" : [
     {
      "name" : "mstr",
      "deco" : "Aya"
     }
    ],
    "endline" : 106
   },
   {
    "name" : "IntegralTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 108,
    "deco" : "B8ghstiklm"
   },
   {
    "name" : "SignedIntTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 109,
    "deco" : "B4gsil"
   },
   {
    "name" : "UnsignedIntTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 110,
    "deco" : "B4htkm"
   },
   {
    "name" : "FloatingPointTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 111,
    "deco" : "B3fde"
   },
   {
    "name" : "ImaginaryTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 112,
    "deco" : "B3opj"
   },
   {
    "name" : "ComplexTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 113,
    "deco" : "B3qrc"
   },
   {
    "name" : "NumericTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 114,
    "deco" : "B11ghstiklmfde"
   },
   {
    "name" : "CharTypeList",
    "kind" : "alias",
    "protection" : "private",
    "comment" : "\n\n",
    "line" : 115,
    "deco" : "B3auw"
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 120,
    "name" : "defaultInit",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n Get the full package name for the given symbol.\n Example:\n ---\n import std.traits;\n static assert(packageName!packageName == \"std\");\n ---\n \n",
    "line" : 157,
    "name" : "packageName",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL172_1655",
    "kind" : "function",
    "line" : 172,
    "endline" : 186
   },
   {
    "kind" : "template",
    "comment" : "\n Get the module name (including package) for the given symbol.\n Example:\n ---\n import std.traits;\n static assert(moduleName!moduleName == \"std.traits\");\n ---\n \n",
    "line" : 202,
    "name" : "moduleName",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL219_1656",
    "kind" : "function",
    "line" : 219,
    "endline" : 233
   },
   {
    "kind" : "template",
    "comment" : "\n Get the fully qualified name of a type or a symbol. Can act as an intelligent type/symbol to string  converter.\n Example:\n ---\n module mymodule;\n import std.traits;\n struct MyStruct {}\n static assert(fullyQualifiedName!(const MyStruct[]) == \"const(mymodule.MyStruct[])\");\n static assert(fullyQualifiedName!fullyQualifiedName == \"std.traits.fullyQualifiedName\");\n ---\n \n",
    "line" : 252,
    "name" : "fullyQualifiedName",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 293,
    "name" : "fullyQualifiedNameImplForSymbols",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "fullyQualifiedNameImplForSymbols",
      "kind" : "variable",
      "line" : 305,
      "storageClass" : [
       "enum"
      ],
      "init" : "parentPrefix ~ (s)\n{\nif (s.skipOver(\"package \") || s.skipOver(\"module \"))\nreturn s;\nreturn s.findSplit(\"(\")[0];\n}\n(__traits(identifier, T))"
     }
    ]
   },
   {
    "name" : "__unittestL308_1659",
    "kind" : "function",
    "line" : 308,
    "endline" : 323
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 323,
    "name" : "fullyQualifiedNameImplForTypes",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "alreadyConst",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "alreadyImmutable",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "alreadyShared",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "alreadyInout",
      "kind" : "value",
      "deco" : "b"
     }
    ],
    "members" : [
     {
      "name" : "std.string",
      "kind" : "import",
      "line" : 326,
      "protection" : "private"
     },
     {
      "name" : "_const",
      "kind" : "enum member",
      "line" : 330
     },
     {
      "name" : "_immutable",
      "kind" : "enum member",
      "line" : 331
     },
     {
      "name" : "_shared",
      "kind" : "enum member",
      "line" : 332
     },
     {
      "name" : "_inout",
      "kind" : "enum member",
      "line" : 333
     },
     {
      "name" : "qualifiers",
      "kind" : "alias",
      "line" : 336,
      "type" : "TypeTuple!(is(T == const), is(T == immutable), is(T == shared), is(T == inout))"
     },
     {
      "name" : "noQualifiers",
      "kind" : "alias",
      "line" : 337,
      "type" : "TypeTuple!(false, false, false, false)"
     },
     {
      "kind" : "template",
      "line" : 339,
      "name" : "storageClassesString",
      "parameters" : [
       {
        "name" : "psc",
        "kind" : "value",
        "deco" : "k"
       }
      ],
      "members" : [
       {
        "name" : "storageClassesString",
        "kind" : "function",
        "line" : 339,
        "type" : "@property string()",
        "endline" : 349
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 351,
      "name" : "parametersTypeString",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "parametersTypeString",
        "kind" : "function",
        "line" : 351,
        "type" : "@property string()",
        "endline" : 384
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 386,
      "name" : "linkageString",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "linkageString",
        "kind" : "function",
        "line" : 386,
        "type" : "@property string()",
        "endline" : 394
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 396,
      "name" : "functionAttributeString",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "functionAttributeString",
        "kind" : "function",
        "line" : 396,
        "type" : "@property string()",
        "endline" : 412
       }
      ]
     },
     {
      "name" : "addQualifiers",
      "kind" : "function",
      "line" : 414,
      "type" : "string(string typeString, bool addConst, bool addImmutable, bool addShared, bool addInout)",
      "parameters" : [
       {
        "name" : "typeString",
        "type" : "string"
       },
       {
        "name" : "addConst",
        "deco" : "b"
       },
       {
        "name" : "addImmutable",
        "deco" : "b"
       },
       {
        "name" : "addShared",
        "deco" : "b"
       },
       {
        "name" : "addInout",
        "deco" : "b"
       }
      ],
      "endline" : 431
     },
     {
      "kind" : "template",
      "line" : 434,
      "name" : "chain",
      "parameters" : [
       {
        "name" : "current",
        "kind" : "value",
        "type" : "string"
       }
      ],
      "members" : [
       {
        "name" : "chain",
        "kind" : "variable",
        "line" : 440,
        "storageClass" : [
         "enum"
        ],
        "init" : "addQualifiers(current, qualifiers[_const] && !alreadyConst, qualifiers[_immutable] && !alreadyImmutable, qualifiers[_shared] && !alreadyShared, qualifiers[_inout] && !alreadyInout)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL523_1662",
    "kind" : "function",
    "line" : 523,
    "endline" : 589
   },
   {
    "kind" : "template",
    "comment" : "\n Get the type of the return value from a function,\n a pointer to function, a delegate, a struct\n with an opCall, a pointer to a struct with an opCall,\n or a class with an $(D opCall). Please note that $(D_KEYWORD ref)\n is not part of a type, but the attribute of the function\n (see template $(LREF functionAttributes)).\n Example:\n ---\n import std.traits;\n int foo();\n ReturnType!foo x;   // x is declared as int\n ---\n \n",
    "line" : 589,
    "name" : "ReturnType",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL598_1664",
    "kind" : "function",
    "line" : 598,
    "endline" : 649
   },
   {
    "kind" : "template",
    "comment" : "\nGet, as a tuple, the types of the parameters to a function, a pointer\nto function, a delegate, a struct with an $(D opCall), a pointer to a\nstruct with an $(D opCall), or a class with an $(D opCall).\n\nExample:\n---\nimport std.traits;\nint foo(int, long);\nvoid bar(ParameterTypeTuple!foo);      // declares void bar(int, long);\nvoid abc(ParameterTypeTuple!foo[1]);   // declares void abc(long);\n---\n",
    "line" : 649,
    "name" : "ParameterTypeTuple",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL658_1666",
    "kind" : "function",
    "line" : 658,
    "endline" : 694
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the number of arguments of function $(D func).\narity is undefined for variadic functions.\n\nExample:\n---\nvoid foo(){}\nstatic assert(arity!foo==0);\nvoid bar(uint){}\nstatic assert(arity!bar==1);\n---\n \n",
    "line" : 694,
    "name" : "arity",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "arity",
      "kind" : "variable",
      "line" : 697,
      "storageClass" : [
       "enum"
      ],
      "type" : "size_t",
      "init" : "ParameterTypeTuple!(func).length"
     }
    ]
   },
   {
    "name" : "__unittestL700_1667",
    "kind" : "function",
    "line" : 700,
    "endline" : 727
   },
   {
    "name" : "ParameterStorageClass",
    "kind" : "enum",
    "comment" : "\nReturns a tuple consisting of the storage classes of the parameters of a\nfunction $(D func).\n\nExample:\n--------------------\nalias ParameterStorageClass STC; // shorten the enum name\n\nvoid func(ref int ctx, out real result, real param)\n{\n}\nalias ParameterStorageClassTuple!func pstc;\nstatic assert(pstc.length == 3); // three parameters\nstatic assert(pstc[0] == STC.ref_);\nstatic assert(pstc[1] == STC.out_);\nstatic assert(pstc[2] == STC.none);\n--------------------\n \n",
    "line" : 727,
    "baseDeco" : "k",
    "members" : [
     {
      "name" : "none",
      "kind" : "enum member",
      "comment" : "\n These flags can be bitwise OR-ed together to represent complex storage\n class.\n     \n ditto\n",
      "line" : 733
     },
     {
      "name" : "scope_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 734
     },
     {
      "name" : "out_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 735
     },
     {
      "name" : "ref_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 736
     },
     {
      "name" : "lazy_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 737
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 741,
    "name" : "ParameterStorageClassTuple",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Func",
      "kind" : "alias",
      "line" : 744,
      "type" : "Unqual!(FunctionTypeOf!(func))"
     },
     {
      "name" : "Params",
      "kind" : "alias",
      "line" : 750,
      "type" : "ParameterTypeTuple!(Func)"
     },
     {
      "name" : "margs",
      "kind" : "variable",
      "line" : 753,
      "storageClass" : [
       "enum"
      ],
      "init" : "demangleFunctionAttributes(mangledName!(Func)[1..__dollar]).rest"
     },
     {
      "kind" : "template",
      "line" : 756,
      "name" : "demangleNextParameter",
      "parameters" : [
       {
        "name" : "margs",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "i",
        "kind" : "value",
        "type" : "size_t",
        "defaultValue" : "0"
       }
      ],
      "members" : []
     },
     {
      "name" : "ParameterStorageClassTuple",
      "kind" : "alias",
      "line" : 775,
      "type" : "demangleNextParameter!(margs)"
     }
    ]
   },
   {
    "name" : "__unittestL778_1669",
    "kind" : "function",
    "line" : 778,
    "endline" : 829
   },
   {
    "kind" : "template",
    "comment" : "\nGet, as a tuple, the identifiers of the parameters to a function symbol.\n\nExample:\n---\nimport std.traits;\nint foo(int num, string name);\nstatic assert([ParameterIdentifierTuple!foo] == [\"num\", \"name\"]);\n---\n \n",
    "line" : 829,
    "name" : "ParameterIdentifierTuple",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 855,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "i",
        "kind" : "value",
        "type" : "size_t",
        "defaultValue" : "0"
       }
      ],
      "members" : []
     },
     {
      "name" : "ParameterIdentifierTuple",
      "kind" : "alias",
      "line" : 863,
      "type" : "Impl!()"
     }
    ]
   },
   {
    "name" : "__unittestL866_1670",
    "kind" : "function",
    "line" : 866,
    "endline" : 873
   },
   {
    "name" : "__unittestL873_1671",
    "kind" : "function",
    "line" : 873,
    "endline" : 912
   },
   {
    "kind" : "template",
    "comment" : "\nGet, as a tuple, the default value of the parameters to a function symbol.\nIf a parameter doesn't have the default value, $(D void) is returned instead.\n\nExample:\n---\nimport std.traits;\nint foo(int num, string name = \"hello\", int[] arr = [1,2,3]);\nstatic assert(is(ParameterDefaultValueTuple!foo[0] == void));\nstatic assert(   ParameterDefaultValueTuple!foo[1] == \"hello\");\nstatic assert(   ParameterDefaultValueTuple!foo[2] == [1,2,3]);\n---\n \n",
    "line" : 912,
    "name" : "ParameterDefaultValueTuple",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 943,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "i",
        "kind" : "value",
        "type" : "size_t",
        "defaultValue" : "0"
       }
      ],
      "members" : []
     },
     {
      "name" : "ParameterDefaultValueTuple",
      "kind" : "alias",
      "line" : 951,
      "type" : "Impl!()"
     }
    ]
   },
   {
    "name" : "__unittestL954_1673",
    "kind" : "function",
    "line" : 954,
    "endline" : 962
   },
   {
    "name" : "__unittestL962_1674",
    "kind" : "function",
    "line" : 962,
    "endline" : 1007
   },
   {
    "name" : "FunctionAttribute",
    "kind" : "enum",
    "comment" : "\nReturns the attributes attached to a function $(D func).\n\nExample:\n--------------------\nalias FunctionAttribute FA; // shorten the enum name\n\nreal func(real x) pure nothrow @safe\n{\n    return x;\n}\nstatic assert(functionAttributes!func & FA.pure_);\nstatic assert(functionAttributes!func & FA.safe);\nstatic assert(!(functionAttributes!func & FA.trusted)); // not @trusted\n--------------------\n \n",
    "line" : 1007,
    "baseDeco" : "k",
    "members" : [
     {
      "name" : "none",
      "kind" : "enum member",
      "comment" : "\n These flags can be bitwise OR-ed together to represent complex attribute.\n     \n ditto\n",
      "line" : 1012
     },
     {
      "name" : "pure_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1013
     },
     {
      "name" : "nothrow_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1014
     },
     {
      "name" : "ref_",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1015
     },
     {
      "name" : "property",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1016
     },
     {
      "name" : "trusted",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1017
     },
     {
      "name" : "safe",
      "kind" : "enum member",
      "comment" : " ditto\n",
      "line" : 1018
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1022,
    "name" : "functionAttributes",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Func",
      "kind" : "alias",
      "line" : 1025,
      "type" : "Unqual!(FunctionTypeOf!(func))"
     },
     {
      "name" : "functionAttributes",
      "kind" : "variable",
      "line" : 1027,
      "storageClass" : [
       "enum"
      ],
      "deco" : "k",
      "init" : "demangleFunctionAttributes(mangledName!(Func)[1..__dollar]).value"
     }
    ]
   },
   {
    "name" : "__unittestL1031_1679",
    "kind" : "function",
    "line" : 1031,
    "endline" : 1095
   },
   {
    "kind" : "template",
    "comment" : "\n$(D true) if $(D func) is $(D @safe) or $(D @trusted).\n\nExample:\n--------------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( isSafe!add);\nstatic assert( isSafe!sub);\nstatic assert(!isSafe!mul);\n--------------------\n \n",
    "line" : 1095,
    "name" : "isSafe",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "isSafe",
      "kind" : "variable",
      "line" : 1099,
      "storageClass" : [
       "enum"
      ],
      "init" : "(functionAttributes!(func) & FunctionAttribute.safe) != 0 || (functionAttributes!(func) & FunctionAttribute.trusted) != 0"
     }
    ]
   },
   {
    "name" : "__unittestL1103_1680",
    "kind" : "function",
    "line" : 1103,
    "endline" : 1115
   },
   {
    "name" : "__unittestL1115_1687",
    "kind" : "function",
    "line" : 1115,
    "endline" : 1185
   },
   {
    "kind" : "template",
    "comment" : "\n$(D true) if $(D func) is $(D @system).\n\nExample:\n--------------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert(!isUnsafe!add);\nstatic assert(!isUnsafe!sub);\nstatic assert( isUnsafe!mul);\n--------------------\n \n",
    "line" : 1185,
    "name" : "isUnsafe",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "isUnsafe",
      "kind" : "variable",
      "line" : 1187,
      "storageClass" : [
       "enum"
      ],
      "init" : "!isSafe!(func)"
     }
    ]
   },
   {
    "name" : "__unittestL1191_1688",
    "kind" : "function",
    "line" : 1191,
    "endline" : 1202
   },
   {
    "name" : "__unittestL1202_1695",
    "kind" : "function",
    "line" : 1202,
    "endline" : 1277
   },
   {
    "kind" : "template",
    "comment" : "\n$(RED Scheduled for deprecation in January 2013. It's badly named and provides\nredundant functionality. It was also badly broken prior to 2.060 (bug# 8362), so\nany code which uses it probably needs to be changed anyway. Please use\n$(D allSatisfy(isSafe, ...)) instead.)\n\n$(D true) all functions are $(D isSafe).\n\nExample:\n--------------------\n@safe    int add(int a, int b) {return a+b;}\n@trusted int sub(int a, int b) {return a-b;}\n@system  int mul(int a, int b) {return a*b;}\n\nstatic assert( areAllSafe!(add, add));\nstatic assert( areAllSafe!(add, sub));\nstatic assert(!areAllSafe!(sub, mul));\n--------------------\n \n",
    "line" : 1277,
    "name" : "areAllSafe",
    "parameters" : [
     {
      "name" : "funcs",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1295_1696",
    "kind" : "function",
    "line" : 1295,
    "endline" : 1306
   },
   {
    "name" : "__unittestL1306_1699",
    "kind" : "function",
    "line" : 1306,
    "endline" : 1333
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the calling convention of function as a string.\n\nExample:\n--------------------\nstring a = functionLinkage!(writeln!(string, int));\nassert(a == \"D\"); // extern(D)\n\nauto fp = &printf;\nstring b = functionLinkage!fp;\nassert(b == \"C\"); // extern(C)\n--------------------\n \n",
    "line" : 1333,
    "name" : "functionLinkage",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Func",
      "kind" : "alias",
      "line" : 1336,
      "type" : "Unqual!(FunctionTypeOf!(func))"
     },
     {
      "name" : "functionLinkage",
      "kind" : "variable",
      "line" : 1338,
      "storageClass" : [
       "enum"
      ],
      "type" : "string",
      "init" : "['F':\"D\", 'U':\"C\", 'W':\"Windows\", 'V':\"Pascal\", 'R':\"C++\"][mangledName!(Func)[0]]"
     }
    ]
   },
   {
    "name" : "__unittestL1348_1701",
    "kind" : "function",
    "line" : 1348,
    "endline" : 1379
   },
   {
    "name" : "Variadic",
    "kind" : "enum",
    "comment" : "\nDetermines what kind of variadic parameters function has.\n\nExample:\n--------------------\nvoid func() {}\nstatic assert(variadicFunctionStyle!func == Variadic.no);\n\nextern(C) int printf(in char*, ...);\nstatic assert(variadicFunctionStyle!printf == Variadic.c);\n--------------------\n \n",
    "line" : 1380,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " Function is not variadic.\n",
      "line" : 1381
     },
     {
      "name" : "c",
      "kind" : "enum member",
      "comment" : " Function is a _C-style variadic function.\n",
      "line" : 1382
     },
     {
      "name" : "d",
      "kind" : "enum member",
      "comment" : " Function is a _D-style variadic function, which uses\n __argptr and __arguments.\n",
      "line" : 1384
     },
     {
      "name" : "typesafe",
      "kind" : "enum member",
      "comment" : " Function is a typesafe variadic function.\n",
      "line" : 1385
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 1389,
    "name" : "variadicFunctionStyle",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Func",
      "kind" : "alias",
      "line" : 1392,
      "type" : "Unqual!(FunctionTypeOf!(func))"
     },
     {
      "name" : "callconv",
      "kind" : "variable",
      "line" : 1395,
      "storageClass" : [
       "enum"
      ],
      "init" : "functionLinkage!(Func)"
     },
     {
      "name" : "mfunc",
      "kind" : "variable",
      "line" : 1396,
      "storageClass" : [
       "enum"
      ],
      "init" : "mangledName!(Func)"
     },
     {
      "name" : "mtype",
      "kind" : "variable",
      "line" : 1397,
      "storageClass" : [
       "enum"
      ],
      "init" : "mangledName!(ReturnType!(Func))"
     },
     {
      "name" : "argclose",
      "kind" : "variable",
      "line" : 1400,
      "storageClass" : [
       "enum"
      ],
      "init" : "mfunc[__dollar - mtype.length - 1]"
     },
     {
      "name" : "variadicFunctionStyle",
      "kind" : "variable",
      "line" : 1403,
      "storageClass" : [
       "enum"
      ],
      "type" : "Variadic",
      "init" : "argclose == 'X' ? Variadic.typesafe : argclose == 'Y' ? callconv == \"C\" ? Variadic.c : Variadic.d : Variadic.no"
     }
    ]
   },
   {
    "name" : "__unittestL1409_1703",
    "kind" : "function",
    "line" : 1409,
    "endline" : 1444
   },
   {
    "kind" : "template",
    "comment" : "\nGet the function type from a callable object $(D func).\n\nUsing builtin $(D typeof) on a property function yields the types of the\nproperty value, not of the property function itself.  Still,\n$(D FunctionTypeOf) is able to obtain function types of properties.\n--------------------\nclass C\n{\n    int value() @property;\n}\nstatic assert(is( typeof(C.value) == int ));\nstatic assert(is( FunctionTypeOf!(C.value) == function ));\n--------------------\n\nNote:\nDo not confuse function types with function pointer types; function types are\nusually used for compile-time reflection purposes.\n \n",
    "line" : 1444,
    "name" : "FunctionTypeOf",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1472_1705",
    "kind" : "function",
    "line" : 1472,
    "endline" : 1554
   },
   {
    "kind" : "template",
    "comment" : "\n Constructs a new function or delegate type with the same basic signature\n as the given one, but different attributes (including linkage).\n\n This is especially useful for adding/removing attributes to/from types in\n generic code, where the actual type name cannot be spelt out.\n\n Params:\n    T = The base type.\n    linkage = The desired linkage of the result type.\n    attrs = The desired $(LREF FunctionAttribute)s of the result type.\n\n Examples:\n ---\n template ExternC(T)\n     if (isFunctionPointer!T || isDelegate!T || is(T == function))\n {\n     alias SetFunctionAttributes!(T, \"C\", functionAttributes!T) ExternC;\n }\n ---\n\n ---\n auto assumePure(T)(T t)\n     if (isFunctionPointer!T || isDelegate!T)\n {\n     enum attrs = functionAttributes!T | FunctionAttribute.pure_;\n     return cast(SetFunctionAttributes!(T, functionLinkage!T, attrs)) t;\n }\n ---\n \n",
    "line" : 1554,
    "name" : "SetFunctionAttributes",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "linkage",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "attrs",
      "kind" : "value",
      "deco" : "k"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 1613,
    "name" : "SetFunctionAttributes",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "linkage",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "attrs",
      "kind" : "value",
      "deco" : "k"
     }
    ],
    "members" : [
     {
      "name" : "SetFunctionAttributes",
      "kind" : "alias",
      "line" : 1620,
      "type" : "FunctionTypeOf!(SetFunctionAttributes!(T*, linkage, attrs))"
     }
    ]
   },
   {
    "name" : "__unittestL1632_1707",
    "kind" : "function",
    "line" : 1632,
    "endline" : 1683
   },
   {
    "kind" : "template",
    "comment" : "\nDetermines whether $(D T) has its own context pointer.\n$(D T) must be either $(D class), $(D struct), or $(D union).\n",
    "line" : 1683,
    "name" : "isNested",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isNested",
      "kind" : "variable",
      "line" : 1686,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(isNested, T)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nDetermines whether $(D T) or any of its representation types\nhave a context pointer.\n",
    "line" : 1693,
    "name" : "hasNested",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1704_1708",
    "kind" : "function",
    "line" : 1704,
    "endline" : 1765
   },
   {
    "kind" : "template",
    "comment" : "\n Get as a typetuple the types of the fields of a struct, class, or union.\n This consists of the fields that take up memory space,\n excluding the hidden fields like the virtual function\n table pointer or a context pointer for nested types.\n If $(D T) isn't a struct, class, or union returns typetuple\n with one element $(D T).\n \n",
    "line" : 1765,
    "name" : "FieldTypeTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1775_1709",
    "kind" : "function",
    "line" : 1775,
    "endline" : 1894
   },
   {
    "kind" : "template",
    "comment" : "\nGet the primitive types of the fields of a struct or class, in\ntopological order.\n\nExample:\n----\nstruct S1 { int a; float b; }\nstruct S2 { char[] a; union { S1 b; S1 * c; } }\nalias RepresentationTypeTuple!S2 R;\nassert(R.length == 4\n    && is(R[0] == char[]) && is(R[1] == int)\n    && is(R[2] == float) && is(R[3] == S1*));\n----\n",
    "line" : 1894,
    "name" : "RepresentationTypeTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1896,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     }
    ]
   },
   {
    "name" : "__unittestL1940_1710",
    "kind" : "function",
    "line" : 1940,
    "endline" : 2054
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2054,
    "name" : "hasRawAliasing",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 2056,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "name" : "hasRawAliasing",
      "kind" : "variable",
      "line" : 2077,
      "storageClass" : [
       "enum"
      ],
      "init" : "Impl!(RepresentationTypeTuple!(T))"
     }
    ]
   },
   {
    "name" : "__unittestL2080_1711",
    "kind" : "function",
    "line" : 2080,
    "endline" : 2174
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2174,
    "name" : "hasRawUnsharedAliasing",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 2176,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "name" : "hasRawUnsharedAliasing",
      "kind" : "variable",
      "line" : 2197,
      "storageClass" : [
       "enum"
      ],
      "init" : "Impl!(RepresentationTypeTuple!(T))"
     }
    ]
   },
   {
    "name" : "__unittestL2200_1712",
    "kind" : "function",
    "line" : 2200,
    "endline" : 2346
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2346,
    "name" : "hasObjects",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2374,
    "name" : "hasUnsharedObjects",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable;) $(LI an array $(D U[]) and $(D U) is not\nimmutable;) $(LI a reference to a class or interface type $(D C) and $(D C) is\nnot immutable.) $(LI an associative array that is not immutable.)\n$(LI a delegate.))\n",
    "line" : 2406,
    "name" : "hasAliasing",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 2408,
      "name" : "isAliasingDelegate",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "isAliasingDelegate",
        "kind" : "variable",
        "line" : 2412,
        "storageClass" : [
         "enum"
        ],
        "init" : "isDelegate!(T) && !is(T == immutable) && !is(FunctionTypeOf!(T) == immutable)"
       }
      ]
     },
     {
      "name" : "hasAliasing",
      "kind" : "variable",
      "line" : 2415,
      "storageClass" : [
       "enum"
      ],
      "init" : "hasRawAliasing!(T) || hasObjects!(T) || anySatisfy!(isAliasingDelegate, T, RepresentationTypeTuple!(T))"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 2419,
    "name" : "hasAliasing",
    "parameters" : [
     {
      "name" : "R",
      "kind" : "type",
      "type" : "Rebindable!(R)"
     }
    ],
    "members" : [
     {
      "name" : "hasAliasing",
      "kind" : "variable",
      "line" : 2421,
      "storageClass" : [
       "enum"
      ],
      "init" : "hasAliasing!(R)"
     }
    ]
   },
   {
    "name" : "__unittestL2424_1713",
    "kind" : "function",
    "line" : 2424,
    "endline" : 2502
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*);) $(LI an\narray $(D U[]);) $(LI a reference to a class type $(D C).)\n$(LI an associative array.) $(LI a delegate.))\n \n",
    "line" : 2502,
    "name" : "hasIndirections",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 2504,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "name" : "hasIndirections",
      "kind" : "variable",
      "line" : 2531,
      "storageClass" : [
       "enum"
      ],
      "init" : "Impl!(T, RepresentationTypeTuple!(T))"
     }
    ]
   },
   {
    "name" : "__unittestL2534_1714",
    "kind" : "function",
    "line" : 2534,
    "endline" : 2605
   },
   {
    "name" : "hasLocalAliasing",
    "kind" : "alias",
    "line" : 2605
   },
   {
    "name" : "hasRawLocalAliasing",
    "kind" : "alias",
    "line" : 2606
   },
   {
    "name" : "hasLocalObjects",
    "kind" : "alias",
    "line" : 2607
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if $(D T)'s representation includes at\nleast one of the following: $(OL $(LI a raw pointer $(D U*) and $(D U)\nis not immutable or shared;) $(LI an array $(D U[]) and $(D U) is not\nimmutable or shared;) $(LI a reference to a class type $(D C) and\n$(D C) is not immutable or shared.) $(LI an associative array that is not\nimmutable or shared.) $(LI a delegate that is not shared.))\n",
    "line" : 2618,
    "name" : "hasUnsharedAliasing",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL2648_1715",
    "kind" : "function",
    "line" : 2648,
    "endline" : 2781
   },
   {
    "kind" : "template",
    "comment" : "\n True if $(D S) or any type embedded directly in the representation of $(D S)\n defines an elaborate copy constructor. Elaborate copy constructors are\n introduced by defining $(D this(this)) for a $(D struct).\n\n Classes and unions never have elaborate copy constructors.\n \n",
    "line" : 2781,
    "name" : "hasElaborateCopyConstructor",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL2798_1716",
    "kind" : "function",
    "line" : 2798,
    "endline" : 2834
   },
   {
    "kind" : "template",
    "comment" : "\n   True if $(D S) or any type directly embedded in the representation of $(D S)\n   defines an elaborate assignment. Elaborate assignments are introduced by\n   defining $(D opAssign(typeof(this))) or $(D opAssign(ref typeof(this)))\n   for a $(D struct) or when there is a compiler-generated $(D opAssign)\n   (in case $(D S) has an elaborate copy constructor or destructor).\n\n   Classes and unions never have elaborate assignments.\n\n   Note: Structs with (possibly nested) postblit operator(s) will have a\n   hidden yet elaborate compiler generated assignement operator (unless\n   explicitly disabled).\n \n",
    "line" : 2834,
    "name" : "hasElaborateAssign",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL2854_1717",
    "kind" : "function",
    "line" : 2854,
    "endline" : 2910
   },
   {
    "kind" : "template",
    "comment" : "\n   True if $(D S) or any type directly embedded in the representation\n   of $(D S) defines an elaborate destructor. Elaborate destructors\n   are introduced by defining $(D ~this()) for a $(D\n   struct).\n\n   Classes and unions never have elaborate destructors, even\n   though classes may define $(D ~this()).\n \n",
    "line" : 2910,
    "name" : "hasElaborateDestructor",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL2927_1718",
    "kind" : "function",
    "line" : 2927,
    "endline" : 2950
   },
   {
    "kind" : "template",
    "line" : 2950,
    "name" : "Identity",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "Identity",
      "kind" : "alias",
      "line" : 2950,
      "type" : "A"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n   Yields $(D true) if and only if $(D T) is an aggregate that defines\n   a symbol called $(D name).\n \n",
    "line" : 2956,
    "name" : "hasMember",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "name",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL2970_1720",
    "kind" : "function",
    "line" : 2970,
    "endline" : 2988
   },
   {
    "name" : "__unittestL2988_1721",
    "kind" : "function",
    "line" : 2988,
    "endline" : 3079
   },
   {
    "kind" : "template",
    "comment" : "\nRetrieves the members of an enumerated type $(D enum E).\n\nParams:\n E = An enumerated type. $(D E) may have duplicated values.\n\nReturns:\n Static tuple composed of the members of the enumerated type $(D E).\n The members are arranged in the same order as declared in $(D E).\n\nNote:\n Returned values are strictly typed with $(D E). Thus, the following code\n does not work without the explicit cast:\n--------------------\nenum E : int { a, b, c }\nint[] abc = cast(int[]) [ EnumMembers!E ];\n--------------------\n Cast is not necessary if the type of the variable is inferred. See the\n example below.\n\nExamples:\n Creating an array of enumerated values:\n--------------------\nenum Sqrts : real\n{\n    one   = 1,\n    two   = 1.41421,\n    three = 1.73205,\n}\nauto sqrts = [ EnumMembers!Sqrts ];\nassert(sqrts == [ Sqrts.one, Sqrts.two, Sqrts.three ]);\n--------------------\n\n A generic function $(D rank(v)) in the following example uses this\n template for finding a member $(D e) in an enumerated type $(D E).\n--------------------\n// Returns i if e is the i-th enumerator of E.\nsize_t rank(E)(E e)\n    if (is(E == enum))\n{\n    foreach (i, member; EnumMembers!E)\n    {\n        if (e == member)\n            return i;\n    }\n    assert(0, \"Not an enum member\");\n}\n\nenum Mode\n{\n    read  = 1,\n    write = 2,\n    map   = 4,\n}\nassert(rank(Mode.read ) == 0);\nassert(rank(Mode.write) == 1);\nassert(rank(Mode.map  ) == 2);\n--------------------\n \n",
    "line" : 3079,
    "name" : "EnumMembers",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 3083,
      "name" : "WithIdentifier",
      "parameters" : [
       {
        "name" : "ident",
        "kind" : "value",
        "type" : "string"
       }
      ],
      "members" : []
     },
     {
      "kind" : "template",
      "line" : 3101,
      "name" : "EnumSpecificMembers",
      "parameters" : [
       {
        "name" : "names",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "name" : "EnumMembers",
      "kind" : "alias",
      "line" : 3117,
      "type" : "EnumSpecificMembers!(__traits(allMembers, E))"
     }
    ]
   },
   {
    "name" : "__unittestL3120_1722",
    "kind" : "function",
    "line" : 3120,
    "endline" : 3128
   },
   {
    "name" : "__unittestL3128_1723",
    "kind" : "function",
    "line" : 3128,
    "endline" : 3142
   },
   {
    "name" : "__unittestL3142_1724",
    "kind" : "function",
    "line" : 3142,
    "endline" : 3152
   },
   {
    "name" : "__unittestL3152_1725",
    "kind" : "function",
    "line" : 3152,
    "endline" : 3185
   },
   {
    "kind" : "template",
    "comment" : "\n Get a $(D_PARAM TypeTuple) of the base class and base interfaces of\n this class or interface. $(D_PARAM BaseTypeTuple!Object) returns\n the empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I { }\n class A { }\n class B : A, I { }\n\n void main()\n {\n     alias BaseTypeTuple!B TL;\n     writeln(typeid(TL));        // prints: (A,I)\n }\n ---\n \n",
    "line" : 3185,
    "name" : "BaseTypeTuple",
    "parameters" : [
     {
      "name" : "A",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3193_1726",
    "kind" : "function",
    "line" : 3193,
    "endline" : 3205
   },
   {
    "name" : "__unittestL3205_1727",
    "kind" : "function",
    "line" : 3205,
    "endline" : 3242
   },
   {
    "kind" : "template",
    "comment" : "\n Get a $(D_PARAM TypeTuple) of $(I all) base classes of this class,\n in decreasing order. Interfaces are not included. $(D_PARAM\n BaseClassesTuple!Object) yields the empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I { }\n class A { }\n class B : A, I { }\n class C : B { }\n\n void main()\n {\n     alias BaseClassesTuple!C TL;\n     writeln(typeid(TL));        // prints: (B,A,Object)\n }\n ---\n \n",
    "line" : 3242,
    "name" : "BaseClassesTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3261_1728",
    "kind" : "function",
    "line" : 3261,
    "endline" : 3303
   },
   {
    "kind" : "template",
    "comment" : "\n Get a $(D_PARAM TypeTuple) of $(I all) interfaces directly or\n indirectly inherited by this class or interface. Interfaces do not\n repeat if multiply implemented. $(D_PARAM InterfacesTuple!Object)\n yields the empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I1 { }\n interface I2 { }\n class A : I1, I2 { }\n class B : A, I1 { }\n class C : B { }\n\n void main()\n {\n     alias InterfacesTuple!C TL;\n     writeln(typeid(TL));        // prints: (I1, I2)\n }\n ---\n \n",
    "line" : 3303,
    "name" : "InterfacesTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 3305,
      "name" : "Flatten",
      "parameters" : [
       {
        "name" : "H",
        "kind" : "type"
       },
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     }
    ]
   },
   {
    "name" : "__unittestL3326_1729",
    "kind" : "function",
    "line" : 3326,
    "endline" : 3378
   },
   {
    "kind" : "template",
    "comment" : "\n Get a $(D_PARAM TypeTuple) of $(I all) base classes of $(D_PARAM\n T), in decreasing order, followed by $(D_PARAM T)'s\n interfaces. $(D_PARAM TransitiveBaseTypeTuple!Object) yields the\n empty type tuple.\n\n Example:\n ---\n import std.traits, std.typetuple, std.stdio;\n interface I { }\n class A { }\n class B : A, I { }\n class C : B { }\n\n void main()\n {\n     alias TransitiveBaseTypeTuple!C TL;\n     writeln(typeid(TL));        // prints: (B,A,Object,I)\n }\n ---\n \n",
    "line" : 3378,
    "name" : "TransitiveBaseTypeTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3387_1730",
    "kind" : "function",
    "line" : 3387,
    "endline" : 3428
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a tuple of non-static functions with the name $(D name) declared in the\nclass or interface $(D C).  Covariant duplicates are shrunk into the most\nderived one.\n\nExample:\n--------------------\ninterface I { I foo(); }\nclass B\n{\n    real foo(real v) { return v; }\n}\nclass C : B, I\n{\n    override C foo() { return this; } // covariant overriding of I.foo()\n}\nalias MemberFunctionsTuple!(C, \"foo\") foos;\nstatic assert(foos.length == 2);\nstatic assert(__traits(isSame, foos[0], C.foo));\nstatic assert(__traits(isSame, foos[1], B.foo));\n--------------------\n \n",
    "line" : 3428,
    "name" : "MemberFunctionsTuple",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     },
     {
      "name" : "name",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3518_1731",
    "kind" : "function",
    "line" : 3518,
    "endline" : 3559
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3559,
    "name" : "maxAlignment",
    "parameters" : [
     {
      "name" : "U",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nReturns class instance alignment.\n\nExample:\n---\nclass A { byte b; }\nclass B { long l; }\n\n// As class instance always has a hidden pointer\nstatic assert(classInstanceAlignment!A == (void*).alignof);\nstatic assert(classInstanceAlignment!B == long.alignof);\n---\n \n",
    "line" : 3581,
    "name" : "classInstanceAlignment",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "classInstanceAlignment",
      "kind" : "alias",
      "line" : 3583,
      "type" : "maxAlignment!(void*, typeof(T.tupleof))"
     }
    ]
   },
   {
    "name" : "__unittestL3586_1732",
    "kind" : "function",
    "line" : 3586,
    "endline" : 3615
   },
   {
    "kind" : "template",
    "comment" : "\nGet the type that all types can be implicitly converted to. Useful\ne.g. in figuring out an array type from a bunch of initializing\nvalues. Returns $(D_PARAM void) if passed an empty list, or if the\ntypes have no common type.\n\nExample:\n\n----\nalias CommonType!(int, long, short) X;\nassert(is(X == long));\nalias CommonType!(int, char[], short) Y;\nassert(is(Y == void));\n----\n",
    "line" : 3615,
    "name" : "CommonType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3640_1733",
    "kind" : "function",
    "line" : 3640,
    "endline" : 3664
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a tuple with all possible target types of an implicit\n conversion of a value of type $(D_PARAM T).\n\n Important note:\n\n The possible targets are computed more conservatively than the D\n 2.005 compiler does, eliminating all dangerous conversions. For\n example, $(D_PARAM ImplicitConversionTargets!double) does not\n include $(D_PARAM float).\n \n",
    "line" : 3664,
    "name" : "ImplicitConversionTargets",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3732_1734",
    "kind" : "function",
    "line" : 3732,
    "endline" : 3740
   },
   {
    "kind" : "template",
    "comment" : "\nIs $(D From) implicitly convertible to $(D To)?\n \n",
    "line" : 3740,
    "name" : "isImplicitlyConvertible",
    "parameters" : [
     {
      "name" : "From",
      "kind" : "type"
     },
     {
      "name" : "To",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isImplicitlyConvertible",
      "kind" : "variable",
      "line" : 3742,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof(()\n{\nvoid fun(ref From v)\n{\nvoid gun(To)\n{\n}\n\ngun(v);\n}\n\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL3751_1736",
    "kind" : "function",
    "line" : 3751,
    "endline" : 3789
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) iff a value of type $(D Rhs) can be assigned to a variable of\ntype $(D Lhs).\n\nIf you omit $(D Rhs), $(D isAssignable) will check identity assignable of $(D Lhs).\n\nExamples:\n---\nstatic assert(isAssignable!(long, int));\nstatic assert(!isAssignable!(int, long));\nstatic assert( isAssignable!(const(char)[], string));\nstatic assert(!isAssignable!(string, char[]));\n\n// int is assignable to int\nstatic assert( isAssignable!int);\n\n// immutable int is not assinable to immutable int\nstatic assert(!isAssignable!(immutable int));\n---\n",
    "line" : 3789,
    "name" : "isAssignable",
    "parameters" : [
     {
      "name" : "Lhs",
      "kind" : "type"
     },
     {
      "name" : "Rhs",
      "kind" : "type",
      "default" : "Lhs"
     }
    ],
    "members" : [
     {
      "name" : "isAssignable",
      "kind" : "variable",
      "line" : 3791,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(typeof(()\n{\nLhs l = void;\nvoid f(Rhs r)\n{\nl = r;\n}\n\nreturn l;\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL3798_1738",
    "kind" : "function",
    "line" : 3798,
    "endline" : 3832
   },
   {
    "name" : "__unittestL3832_1739",
    "kind" : "function",
    "line" : 3832,
    "endline" : 3843
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3843,
    "name" : "isStorageClassImplicitlyConvertible",
    "parameters" : [
     {
      "name" : "From",
      "kind" : "type"
     },
     {
      "name" : "To",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isStorageClassImplicitlyConvertible",
      "kind" : "variable",
      "line" : 3847,
      "storageClass" : [
       "enum"
      ],
      "init" : "isImplicitlyConvertible!(ModifyTypePreservingSTC!(Pointify, From), ModifyTypePreservingSTC!(Pointify, To))"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3849,
    "name" : "Pointify",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Pointify",
      "kind" : "alias",
      "line" : 3849,
      "type" : "void*"
     }
    ]
   },
   {
    "name" : "__unittestL3851_1740",
    "kind" : "function",
    "line" : 3851,
    "endline" : 3887
   },
   {
    "kind" : "template",
    "comment" : "\nDetermines whether the function type $(D F) is covariant with $(D G), i.e.,\nfunctions of the type $(D F) can override ones of the type $(D G).\n\nExample:\n--------------------\ninterface I { I clone(); }\ninterface J { J clone(); }\nclass C : I\n{\n    override C clone()   // covariant overriding of I.clone()\n    {\n        return new C;\n    }\n}\n\n// C.clone() can override I.clone(), indeed.\nstatic assert(isCovariantWith!(typeof(C.clone), typeof(I.clone)));\n\n// C.clone() can't override J.clone(); the return type C is not implicitly\n// convertible to J.\nstatic assert(isCovariantWith!(typeof(C.clone), typeof(J.clone)));\n--------------------\n \n",
    "line" : 3887,
    "name" : "isCovariantWith",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "type"
     },
     {
      "name" : "G",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL3999_1741",
    "kind" : "function",
    "line" : 3999,
    "endline" : 4064
   },
   {
    "kind" : "template",
    "line" : 4064,
    "name" : "BooleanTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4066,
      "type" : "inout(bool)(inout(bool))",
      "parameters" : [
       {
        "type" : "inout(bool)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4067,
      "type" : "shared(inout(bool))(shared(inout(bool)))",
      "parameters" : [
       {
        "type" : "shared(inout(bool))"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4069,
      "type" : "immutable(bool)(immutable(bool))",
      "parameters" : [
       {
        "type" : "immutable(bool)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4081_1742",
    "kind" : "function",
    "line" : 4081,
    "endline" : 4100
   },
   {
    "kind" : "template",
    "line" : 4100,
    "name" : "IntegralTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4102,
      "type" : "inout(byte)(inout(byte))",
      "parameters" : [
       {
        "type" : "inout(byte)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4103,
      "type" : "inout(ubyte)(inout(ubyte))",
      "parameters" : [
       {
        "type" : "inout(ubyte)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4104,
      "type" : "inout(short)(inout(short))",
      "parameters" : [
       {
        "type" : "inout(short)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4105,
      "type" : "inout(ushort)(inout(ushort))",
      "parameters" : [
       {
        "type" : "inout(ushort)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4106,
      "type" : "inout(int)(inout(int))",
      "parameters" : [
       {
        "deco" : "Ngi"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4107,
      "type" : "inout(uint)(inout(uint))",
      "parameters" : [
       {
        "type" : "inout(uint)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4108,
      "type" : "inout(long)(inout(long))",
      "parameters" : [
       {
        "type" : "inout(long)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4109,
      "type" : "inout(ulong)(inout(ulong))",
      "parameters" : [
       {
        "type" : "inout(ulong)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4110,
      "type" : "shared(inout(byte))(shared(inout(byte)))",
      "parameters" : [
       {
        "type" : "shared(inout(byte))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4111,
      "type" : "shared(inout(ubyte))(shared(inout(ubyte)))",
      "parameters" : [
       {
        "type" : "shared(inout(ubyte))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4112,
      "type" : "shared(inout(short))(shared(inout(short)))",
      "parameters" : [
       {
        "type" : "shared(inout(short))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4113,
      "type" : "shared(inout(ushort))(shared(inout(ushort)))",
      "parameters" : [
       {
        "type" : "shared(inout(ushort))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4114,
      "type" : "shared(inout(int))(shared(inout(int)))",
      "parameters" : [
       {
        "type" : "shared(inout(int))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4115,
      "type" : "shared(inout(uint))(shared(inout(uint)))",
      "parameters" : [
       {
        "type" : "shared(inout(uint))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4116,
      "type" : "shared(inout(long))(shared(inout(long)))",
      "parameters" : [
       {
        "type" : "shared(inout(long))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4117,
      "type" : "shared(inout(ulong))(shared(inout(ulong)))",
      "parameters" : [
       {
        "type" : "shared(inout(ulong))"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4119,
      "type" : "immutable(char)(immutable(char))",
      "parameters" : [
       {
        "deco" : "ya"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4120,
      "type" : "immutable(wchar)(immutable(wchar))",
      "parameters" : [
       {
        "type" : "immutable(wchar)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4121,
      "type" : "immutable(dchar)(immutable(dchar))",
      "parameters" : [
       {
        "type" : "immutable(dchar)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4124,
      "type" : "immutable(byte)(immutable(byte))",
      "parameters" : [
       {
        "type" : "immutable(byte)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4125,
      "type" : "immutable(ubyte)(immutable(ubyte))",
      "parameters" : [
       {
        "type" : "immutable(ubyte)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4126,
      "type" : "immutable(short)(immutable(short))",
      "parameters" : [
       {
        "deco" : "ys"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4127,
      "type" : "immutable(ushort)(immutable(ushort))",
      "parameters" : [
       {
        "type" : "immutable(ushort)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4128,
      "type" : "immutable(int)(immutable(int))",
      "parameters" : [
       {
        "deco" : "yi"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4129,
      "type" : "immutable(uint)(immutable(uint))",
      "parameters" : [
       {
        "deco" : "yk"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4130,
      "type" : "immutable(long)(immutable(long))",
      "parameters" : [
       {
        "type" : "immutable(long)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4131,
      "type" : "immutable(ulong)(immutable(ulong))",
      "parameters" : [
       {
        "type" : "immutable(ulong)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4143_1743",
    "kind" : "function",
    "line" : 4143,
    "endline" : 4161
   },
   {
    "kind" : "template",
    "line" : 4161,
    "name" : "FloatingPointTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4163,
      "type" : "inout(float)(inout(float))",
      "parameters" : [
       {
        "type" : "inout(float)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4164,
      "type" : "inout(double)(inout(double))",
      "parameters" : [
       {
        "type" : "inout(double)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4165,
      "type" : "inout(real)(inout(real))",
      "parameters" : [
       {
        "type" : "inout(real)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4166,
      "type" : "shared(inout(float))(shared(inout(float)))",
      "parameters" : [
       {
        "type" : "shared(inout(float))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4167,
      "type" : "shared(inout(double))(shared(inout(double)))",
      "parameters" : [
       {
        "type" : "shared(inout(double))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4168,
      "type" : "shared(inout(real))(shared(inout(real)))",
      "parameters" : [
       {
        "type" : "shared(inout(real))"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4170,
      "type" : "immutable(float)(immutable(float))",
      "parameters" : [
       {
        "type" : "immutable(float)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4171,
      "type" : "immutable(double)(immutable(double))",
      "parameters" : [
       {
        "type" : "immutable(double)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4172,
      "type" : "immutable(real)(immutable(real))",
      "parameters" : [
       {
        "type" : "immutable(real)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4184_1744",
    "kind" : "function",
    "line" : 4184,
    "endline" : 4202
   },
   {
    "kind" : "template",
    "line" : 4202,
    "name" : "NumericTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL4212_1745",
    "kind" : "function",
    "line" : 4212,
    "endline" : 4230
   },
   {
    "kind" : "template",
    "line" : 4230,
    "name" : "UnsignedTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "line" : 4241,
    "name" : "SignedTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "line" : 4254,
    "name" : "CharTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4256,
      "type" : "inout(char)(inout(char))",
      "parameters" : [
       {
        "deco" : "Nga"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4257,
      "type" : "inout(wchar)(inout(wchar))",
      "parameters" : [
       {
        "type" : "inout(wchar)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4258,
      "type" : "inout(dchar)(inout(dchar))",
      "parameters" : [
       {
        "type" : "inout(dchar)"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4259,
      "type" : "shared(inout(char))(shared(inout(char)))",
      "parameters" : [
       {
        "type" : "shared(inout(char))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4260,
      "type" : "shared(inout(wchar))(shared(inout(wchar)))",
      "parameters" : [
       {
        "type" : "shared(inout(wchar))"
       }
      ]
     },
     {
      "name" : "idx",
      "kind" : "function",
      "line" : 4261,
      "type" : "shared(inout(dchar))(shared(inout(dchar)))",
      "parameters" : [
       {
        "type" : "shared(inout(dchar))"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4263,
      "type" : "immutable(char)(immutable(char))",
      "parameters" : [
       {
        "deco" : "ya"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4264,
      "type" : "immutable(wchar)(immutable(wchar))",
      "parameters" : [
       {
        "type" : "immutable(wchar)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4265,
      "type" : "immutable(dchar)(immutable(dchar))",
      "parameters" : [
       {
        "type" : "immutable(dchar)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4268,
      "type" : "immutable(byte)(immutable(byte))",
      "parameters" : [
       {
        "type" : "immutable(byte)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4269,
      "type" : "immutable(ubyte)(immutable(ubyte))",
      "parameters" : [
       {
        "type" : "immutable(ubyte)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4270,
      "type" : "immutable(short)(immutable(short))",
      "parameters" : [
       {
        "deco" : "ys"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4271,
      "type" : "immutable(ushort)(immutable(ushort))",
      "parameters" : [
       {
        "type" : "immutable(ushort)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4272,
      "type" : "immutable(int)(immutable(int))",
      "parameters" : [
       {
        "deco" : "yi"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4273,
      "type" : "immutable(uint)(immutable(uint))",
      "parameters" : [
       {
        "deco" : "yk"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4274,
      "type" : "immutable(long)(immutable(long))",
      "parameters" : [
       {
        "type" : "immutable(long)"
       }
      ]
     },
     {
      "name" : "idy",
      "kind" : "function",
      "line" : 4275,
      "type" : "immutable(ulong)(immutable(ulong))",
      "parameters" : [
       {
        "type" : "immutable(ulong)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4287_1746",
    "kind" : "function",
    "line" : 4287,
    "endline" : 4311
   },
   {
    "kind" : "template",
    "line" : 4311,
    "name" : "StaticArrayTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 4313,
      "name" : "idx",
      "parameters" : [
       {
        "name" : "U",
        "kind" : "type"
       },
       {
        "name" : "n",
        "kind" : "value",
        "type" : "size_t"
       }
      ],
      "members" : [
       {
        "name" : "idx",
        "kind" : "function",
        "line" : 4313,
        "type" : "inout(U[n])(inout(U[n]))",
        "parameters" : [
         {
          "type" : "inout(U[n])"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4323_1747",
    "kind" : "function",
    "line" : 4323,
    "endline" : 4344
   },
   {
    "kind" : "template",
    "line" : 4344,
    "name" : "DynamicArrayTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 4346,
      "name" : "idx",
      "parameters" : [
       {
        "name" : "U",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idx",
        "kind" : "function",
        "line" : 4346,
        "type" : "inout(U[])(inout(U[]))",
        "parameters" : [
         {
          "type" : "inout(U[])"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4369_1748",
    "kind" : "function",
    "line" : 4369,
    "endline" : 4391
   },
   {
    "kind" : "template",
    "line" : 4391,
    "name" : "ArrayTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL4401_1749",
    "kind" : "function",
    "line" : 4401,
    "endline" : 4407
   },
   {
    "kind" : "template",
    "line" : 4407,
    "name" : "StringTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL4424_1750",
    "kind" : "function",
    "line" : 4424,
    "endline" : 4449
   },
   {
    "kind" : "template",
    "line" : 4449,
    "name" : "AssocArrayTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 4451,
      "name" : "idx",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idx",
        "kind" : "function",
        "line" : 4451,
        "type" : "immutable(V[K])(immutable(V[K]))",
        "parameters" : [
         {
          "type" : "immutable(V[K])"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4453,
      "name" : "idy",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idy",
        "kind" : "function",
        "line" : 4453,
        "type" : "inout(V)[K](inout(V)[K])",
        "parameters" : [
         {
          "type" : "inout(V)[K]"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4454,
      "name" : "idy",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idy",
        "kind" : "function",
        "line" : 4454,
        "type" : "shared(V[K])(shared(V[K]))",
        "parameters" : [
         {
          "type" : "shared(V[K])"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4456,
      "name" : "idz",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idz",
        "kind" : "function",
        "line" : 4456,
        "type" : "inout(V[K])(inout(V[K]))",
        "parameters" : [
         {
          "type" : "inout(V[K])"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4457,
      "name" : "idz",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idz",
        "kind" : "function",
        "line" : 4457,
        "type" : "shared(inout(V[K]))(shared(inout(V[K])))",
        "parameters" : [
         {
          "type" : "shared(inout(V[K]))"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4459,
      "name" : "idw",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idw",
        "kind" : "function",
        "line" : 4459,
        "type" : "inout(immutable(V)[K])(inout(immutable(V)[K]))",
        "parameters" : [
         {
          "type" : "inout(immutable(V)[K])"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 4460,
      "name" : "idw",
      "parameters" : [
       {
        "name" : "K",
        "kind" : "type"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "idw",
        "kind" : "function",
        "line" : 4460,
        "type" : "shared(inout(immutable(V)[K]))(shared(inout(immutable(V)[K])))",
        "parameters" : [
         {
          "type" : "shared(inout(immutable(V)[K]))"
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL4488_1751",
    "kind" : "function",
    "line" : 4488,
    "endline" : 4509
   },
   {
    "kind" : "template",
    "line" : 4509,
    "name" : "BuiltinTypeOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a built-in boolean type.\n \n",
    "line" : 4530,
    "name" : "isBoolean",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isBoolean",
      "kind" : "variable",
      "line" : 4532,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(BooleanTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4535_1752",
    "kind" : "function",
    "line" : 4535,
    "endline" : 4547
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a built-in integral type. Types $(D bool),\n $(D char), $(D wchar), and $(D dchar) are not considered integral.\n \n",
    "line" : 4547,
    "name" : "isIntegral",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isIntegral",
      "kind" : "variable",
      "line" : 4549,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(IntegralTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4552_1753",
    "kind" : "function",
    "line" : 4552,
    "endline" : 4574
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a built-in floating point type.\n \n",
    "line" : 4574,
    "name" : "isFloatingPoint",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isFloatingPoint",
      "kind" : "variable",
      "line" : 4576,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(FloatingPointTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4579_1754",
    "kind" : "function",
    "line" : 4579,
    "endline" : 4604
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is a built-in numeric type (integral or floating\npoint).\n \n",
    "line" : 4604,
    "name" : "isNumeric",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isNumeric",
      "kind" : "variable",
      "line" : 4606,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(NumericTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4609_1755",
    "kind" : "function",
    "line" : 4609,
    "endline" : 4624
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is a scalar type.\n \n",
    "line" : 4624,
    "name" : "isScalarType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isScalarType",
      "kind" : "variable",
      "line" : 4626,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isNumeric!(T) || isSomeChar!(T) || isBoolean!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4629_1756",
    "kind" : "function",
    "line" : 4629,
    "endline" : 4641
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is a basic type.\n \n",
    "line" : 4641,
    "name" : "isBasicType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isBasicType",
      "kind" : "variable",
      "line" : 4643,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isScalarType!(T) || is(T == void)"
     }
    ]
   },
   {
    "name" : "__unittestL4646_1757",
    "kind" : "function",
    "line" : 4646,
    "endline" : 4658
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is a built-in unsigned numeric type.\n \n",
    "line" : 4658,
    "name" : "isUnsigned",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isUnsigned",
      "kind" : "variable",
      "line" : 4660,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(UnsignedTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4663_1758",
    "kind" : "function",
    "line" : 4663,
    "endline" : 4678
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is a built-in signed numeric type.\n \n",
    "line" : 4678,
    "name" : "isSigned",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSigned",
      "kind" : "variable",
      "line" : 4680,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(SignedTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4683_1759",
    "kind" : "function",
    "line" : 4683,
    "endline" : 4698
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is one of the built-in character types.\n \n",
    "line" : 4698,
    "name" : "isSomeChar",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSomeChar",
      "kind" : "variable",
      "line" : 4700,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(CharTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4703_1760",
    "kind" : "function",
    "line" : 4703,
    "endline" : 4727
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is one of the built-in string types.\n \n",
    "line" : 4727,
    "name" : "isSomeString",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isSomeString",
      "kind" : "variable",
      "line" : 4729,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(StringTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4732_1761",
    "kind" : "function",
    "line" : 4732,
    "endline" : 4749
   },
   {
    "kind" : "template",
    "line" : 4749,
    "name" : "isNarrowString",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isNarrowString",
      "kind" : "variable",
      "line" : 4751,
      "storageClass" : [
       "enum"
      ],
      "init" : "(is(T : const(char[])) || is(T : const(wchar[]))) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4754_1762",
    "kind" : "function",
    "line" : 4754,
    "endline" : 4778
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether type $(D T) is a static array.\n \n",
    "line" : 4778,
    "name" : "isStaticArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isStaticArray",
      "kind" : "variable",
      "line" : 4780,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(StaticArrayTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4783_1763",
    "kind" : "function",
    "line" : 4783,
    "endline" : 4812
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether type $(D T) is a dynamic array.\n \n",
    "line" : 4812,
    "name" : "isDynamicArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isDynamicArray",
      "kind" : "variable",
      "line" : 4814,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(DynamicArrayTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4817_1764",
    "kind" : "function",
    "line" : 4817,
    "endline" : 4838
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether type $(D T) is an array.\n \n",
    "line" : 4838,
    "name" : "isArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isArray",
      "kind" : "variable",
      "line" : 4840,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "isStaticArray!(T) || isDynamicArray!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4843_1765",
    "kind" : "function",
    "line" : 4843,
    "endline" : 4862
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is an associative array type\n \n",
    "line" : 4862,
    "name" : "isAssociativeArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isAssociativeArray",
      "kind" : "variable",
      "line" : 4864,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "is(AssocArrayTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "name" : "__unittestL4867_1766",
    "kind" : "function",
    "line" : 4867,
    "endline" : 4893
   },
   {
    "kind" : "template",
    "line" : 4893,
    "name" : "isBuiltinType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isBuiltinType",
      "kind" : "variable",
      "line" : 4895,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(BuiltinTypeOf!(T)) && !isAggregateType!(T)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether type $(D T) is a pointer.\n \n",
    "line" : 4901,
    "name" : "isPointer",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL4909_1767",
    "kind" : "function",
    "line" : 4909,
    "endline" : 4929
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the target type of a pointer.\n",
    "line" : 4929,
    "name" : "PointerTarget",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "type" : "T*"
     }
    ],
    "members" : [
     {
      "name" : "PointerTarget",
      "kind" : "alias",
      "line" : 4931,
      "type" : "T"
     }
    ]
   },
   {
    "name" : "pointerTarget",
    "kind" : "alias",
    "comment" : " $(RED Scheduled for deprecation. Please use $(LREF PointerTarget) instead.)\n",
    "line" : 4935
   },
   {
    "name" : "__unittestL4937_1768",
    "kind" : "function",
    "line" : 4937,
    "endline" : 4948
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether type $(D T) is an aggregate type.\n \n",
    "line" : 4948,
    "name" : "isAggregateType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isAggregateType",
      "kind" : "variable",
      "line" : 4951,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(T == struct) || is(T == union) || is(T == class) || is(T == interface)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Returns $(D true) if T can be iterated over using a $(D foreach) loop with\n a single loop variable of automatically inferred type, regardless of how\n the $(D foreach) loop is implemented.  This includes ranges, structs/classes\n that define $(D opApply) with a single loop variable, and builtin dynamic,\n static and associative arrays.\n \n",
    "line" : 4961,
    "name" : "isIterable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isIterable",
      "kind" : "variable",
      "line" : 4963,
      "storageClass" : [
       "enum"
      ],
      "init" : "is(typeof(()\n{\nforeach (elem; T.init)\n{\n}\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL4966_1770",
    "kind" : "function",
    "line" : 4966,
    "endline" : 4992
   },
   {
    "kind" : "template",
    "comment" : "\n Returns true if T is not const or immutable.  Note that isMutable is true for\n string, or immutable(char)[], because the 'head' is mutable.\n \n",
    "line" : 4992,
    "name" : "isMutable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "isMutable",
      "kind" : "variable",
      "line" : 4994,
      "storageClass" : [
       "enum"
      ],
      "init" : "!is(T == const) && !is(T == immutable) && !is(T == inout)"
     }
    ]
   },
   {
    "name" : "__unittestL4997_1771",
    "kind" : "function",
    "line" : 4997,
    "endline" : 5014
   },
   {
    "kind" : "template",
    "comment" : "\n Returns true if T is an instance of the template S.\n \n",
    "line" : 5014,
    "name" : "isInstanceOf",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5022_1772",
    "kind" : "function",
    "line" : 5022,
    "endline" : 5039
   },
   {
    "kind" : "template",
    "comment" : "\n Tells whether the tuple T is an expression tuple.\n \n",
    "line" : 5039,
    "name" : "isExpressionTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5049_1776",
    "kind" : "function",
    "line" : 5049,
    "endline" : 5072
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether tuple $(D T) is a type tuple.\n \n",
    "line" : 5072,
    "name" : "isTypeTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5080_1777",
    "kind" : "function",
    "line" : 5080,
    "endline" : 5102
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether symbol or type $(D T) is a function pointer.\n \n",
    "line" : 5102,
    "name" : "isFunctionPointer",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5116_1779",
    "kind" : "function",
    "line" : 5116,
    "endline" : 5137
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether symbol or type $(D T) is a delegate.\n",
    "line" : 5137,
    "name" : "isDelegate",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5154_1780",
    "kind" : "function",
    "line" : 5154,
    "endline" : 5174
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether symbol or type $(D T) is a function, a function pointer or a delegate.\n \n",
    "line" : 5174,
    "name" : "isSomeFunction",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5194_1782",
    "kind" : "function",
    "line" : 5194,
    "endline" : 5235
   },
   {
    "kind" : "template",
    "comment" : "\nDetect whether $(D T) is a callable object, which can be called with the\nfunction call operator $(D $(LPAREN)...$(RPAREN)).\n \n",
    "line" : 5235,
    "name" : "isCallable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5248_1784",
    "kind" : "function",
    "line" : 5248,
    "endline" : 5268
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a an abstract function.\n \n",
    "line" : 5268,
    "name" : "isAbstractFunction",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "isAbstractFunction",
      "kind" : "variable",
      "line" : 5271,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "__traits(isAbstractFunction, T[0])"
     }
    ]
   },
   {
    "name" : "__unittestL5274_1785",
    "kind" : "function",
    "line" : 5274,
    "endline" : 5287
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a a final function.\n \n",
    "line" : 5287,
    "name" : "isFinalFunction",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "isFinalFunction",
      "kind" : "variable",
      "line" : 5290,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "__traits(isFinalFunction, T[0])"
     }
    ]
   },
   {
    "name" : "__unittestL5293_1786",
    "kind" : "function",
    "line" : 5293,
    "endline" : 5311
   },
   {
    "kind" : "template",
    "comment" : "\nDetermines whether function $(D f) requires a context pointer.\n",
    "line" : 5311,
    "name" : "isNestedFunction",
    "parameters" : [
     {
      "name" : "f",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "isNestedFunction",
      "kind" : "variable",
      "line" : 5313,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(isNested, f)"
     }
    ]
   },
   {
    "name" : "__unittestL5316_1787",
    "kind" : "function",
    "line" : 5316,
    "endline" : 5327
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a an abstract class.\n \n",
    "line" : 5327,
    "name" : "isAbstractClass",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "isAbstractClass",
      "kind" : "variable",
      "line" : 5330,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "__traits(isAbstractClass, T[0])"
     }
    ]
   },
   {
    "name" : "__unittestL5333_1788",
    "kind" : "function",
    "line" : 5333,
    "endline" : 5346
   },
   {
    "kind" : "template",
    "comment" : "\n Detect whether $(D T) is a a final class.\n \n",
    "line" : 5346,
    "name" : "isFinalClass",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "isFinalClass",
      "kind" : "variable",
      "line" : 5349,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "__traits(isFinalClass, T[0])"
     }
    ]
   },
   {
    "name" : "__unittestL5352_1789",
    "kind" : "function",
    "line" : 5352,
    "endline" : 5380
   },
   {
    "kind" : "template",
    "comment" : "\nRemoves all qualifiers, if any, from type $(D T).\n\nExample:\n----\nstatic assert(is(Unqual!int == int));\nstatic assert(is(Unqual!(const int) == int));\nstatic assert(is(Unqual!(immutable int) == int));\nstatic assert(is(Unqual!(shared int) == int));\nstatic assert(is(Unqual!(shared(const int)) == int));\n----\n \n",
    "line" : 5380,
    "name" : "Unqual",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5401_1790",
    "kind" : "function",
    "line" : 5401,
    "endline" : 5414
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 5414,
    "name" : "ModifyTypePreservingSTC",
    "parameters" : [
     {
      "name" : "Modifier",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5423_1791",
    "kind" : "function",
    "line" : 5423,
    "endline" : 5430
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the inferred type of the loop variable when a variable of type T\nis iterated over using a $(D foreach) loop with a single loop variable and\nautomatically inferred return type.  Note that this may not be the same as\n$(D std.range.ElementType!Range) in the case of narrow strings, or if T\nhas both opApply and a range interface.\n",
    "line" : 5439,
    "name" : "ForeachType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ForeachType",
      "kind" : "alias",
      "line" : 5449,
      "type" : "ReturnType!(typeof((int x = 0)\n{\nforeach (elem; T.init)\n{\nreturn elem;\n}\nassert(0);\n}\n))"
     }
    ]
   },
   {
    "name" : "__unittestL5452_1793",
    "kind" : "function",
    "line" : 5452,
    "endline" : 5472
   },
   {
    "kind" : "template",
    "comment" : "\nStrips off all $(D typedef)s (including $(D enum) ones) from type $(D T).\n\nExample:\n--------------------\nenum E : int { a }\ntypedef E F;\ntypedef const F G;\nstatic assert(is(OriginalType!G == const int));\n--------------------\n \n",
    "line" : 5472,
    "name" : "OriginalType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 5474,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : []
     },
     {
      "name" : "OriginalType",
      "kind" : "alias",
      "line" : 5481,
      "type" : "ModifyTypePreservingSTC!(Impl, T)"
     }
    ]
   },
   {
    "name" : "__unittestL5484_1794",
    "kind" : "function",
    "line" : 5484,
    "endline" : 5510
   },
   {
    "kind" : "template",
    "comment" : "\n Get the Key type of an Associative Array.\n Example:\n ---\n import std.traits;\n alias int[string] Hash;\n static assert(is(KeyType!Hash == string));\n KeyType!Hash str = \"string\";   // str is declared as string\n ---\n \n",
    "line" : 5510,
    "name" : "KeyType",
    "parameters" : [
     {
      "name" : "V",
      "kind" : "type",
      "type" : "V[K]"
     },
     {
      "name" : "K",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "KeyType",
      "kind" : "alias",
      "line" : 5512,
      "type" : "K"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Get the Value type of an Associative Array.\n Example:\n ---\n import std.traits;\n alias int[string] Hash;\n static assert(is(ValueType!Hash == int));\n ValueType!Hash num = 1;   // num is declared as int\n ---\n \n",
    "line" : 5525,
    "name" : "ValueType",
    "parameters" : [
     {
      "name" : "V",
      "kind" : "type",
      "type" : "V[K]"
     },
     {
      "name" : "K",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "ValueType",
      "kind" : "alias",
      "line" : 5527,
      "type" : "V"
     }
    ]
   },
   {
    "name" : "__unittestL5530_1795",
    "kind" : "function",
    "line" : 5530,
    "endline" : 5543
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the corresponding unsigned type for T. T must be a numeric\n integral type, otherwise a compile-time error occurs.\n \n",
    "line" : 5543,
    "name" : "Unsigned",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 5545,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : []
     },
     {
      "name" : "Unsigned",
      "kind" : "alias",
      "line" : 5561,
      "type" : "ModifyTypePreservingSTC!(Impl, OriginalType!(T))"
     }
    ]
   },
   {
    "name" : "__unittestL5564_1796",
    "kind" : "function",
    "line" : 5564,
    "endline" : 5582
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the largest type, i.e. T such that T.sizeof is the largest.  If more\nthan one type is of the same size, the leftmost argument of these in will be\nreturned.\n",
    "line" : 5582,
    "name" : "Largest",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5605_1797",
    "kind" : "function",
    "line" : 5605,
    "endline" : 5617
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the corresponding signed type for T. T must be a numeric integral type,\notherwise a compile-time error occurs.\n \n",
    "line" : 5617,
    "name" : "Signed",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 5619,
      "name" : "Impl",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : []
     },
     {
      "name" : "Signed",
      "kind" : "alias",
      "line" : 5635,
      "type" : "ModifyTypePreservingSTC!(Impl, OriginalType!(T))"
     }
    ]
   },
   {
    "name" : "__unittestL5638_1798",
    "kind" : "function",
    "line" : 5638,
    "endline" : 5654
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the corresponding unsigned value for $(D x), e.g. if $(D x)\n has type $(D int), returns $(D cast(uint) x). The advantage\n compared to the cast is that you do not need to rewrite the cast if\n $(D x) later changes type to e.g. $(D long).\n \n",
    "line" : 5654,
    "name" : "unsigned",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unsigned",
      "kind" : "function",
      "comment" : "\n Returns the corresponding unsigned value for $(D x), e.g. if $(D x)\n has type $(D int), returns $(D cast(uint) x). The advantage\n compared to the cast is that you do not need to rewrite the cast if\n $(D x) later changes type to e.g. $(D long).\n \n",
      "line" : 5654,
      "storageClass" : [
       "auto"
      ],
      "type" : "(T x)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "T"
       }
      ],
      "endline" : 5665
     }
    ]
   },
   {
    "name" : "__unittestL5667_1799",
    "kind" : "function",
    "line" : 5667,
    "endline" : 5698
   },
   {
    "kind" : "template",
    "line" : 5698,
    "name" : "unsigned",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "unsigned",
      "kind" : "function",
      "line" : 5698,
      "storageClass" : [
       "auto"
      ],
      "type" : "(T x)",
      "parameters" : [
       {
        "name" : "x",
        "type" : "T"
       }
      ],
      "endline" : 5703
     }
    ]
   },
   {
    "name" : "__unittestL5705_1800",
    "kind" : "function",
    "line" : 5705,
    "endline" : 5718
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the most negative value of the numeric type T.\n",
    "line" : 5718,
    "name" : "mostNegative",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL5729_1801",
    "kind" : "function",
    "line" : 5729,
    "endline" : 5764
   },
   {
    "kind" : "template",
    "comment" : "\nReturns the mangled name of symbol or type $(D sth).\n\n$(D mangledName) is the same as builtin $(D .mangleof) property, except that\nthe correct names of property functions are obtained.\n--------------------\nmodule test;\nimport std.traits : mangledName;\n\nclass C\n{\n    int value() @property;\n}\npragma(msg, C.value.mangleof);      // prints \"i\"\npragma(msg, mangledName!(C.value)); // prints \"_D4test1C5valueMFNdZi\"\n--------------------\n \n",
    "line" : 5764,
    "name" : "mangledName",
    "parameters" : [
     {
      "name" : "sth",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 5778,
    "name" : "Dummy",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Hook",
      "kind" : "struct",
      "line" : 5778,
      "members" : []
     }
    ]
   },
   {
    "name" : "removeDummyEnvelope",
    "kind" : "function",
    "protection" : "private",
    "line" : 5780,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     }
    ],
    "endline" : 5825
   },
   {
    "name" : "__unittestL5827_1803",
    "kind" : "function",
    "line" : 5827,
    "endline" : 5845
   },
   {
    "name" : "__unittestL5845_1804",
    "kind" : "function",
    "line" : 5845,
    "endline" : 5864
   },
   {
    "kind" : "template",
    "comment" : "\nAliases itself to $(D T[0]) if the boolean $(D condition) is $(D true)\nand to $(D T[1]) otherwise.\n \n",
    "line" : 5864,
    "name" : "Select",
    "parameters" : [
     {
      "name" : "condition",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Select",
      "kind" : "alias",
      "line" : 5866,
      "type" : "T[!condition]"
     }
    ]
   },
   {
    "name" : "__unittestL5870_1805",
    "kind" : "function",
    "comment" : "\n",
    "line" : 5870,
    "endline" : 5889
   },
   {
    "kind" : "template",
    "comment" : "\nIf $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n \n",
    "line" : 5889,
    "name" : "select",
    "parameters" : [
     {
      "name" : "cond",
      "kind" : "value",
      "deco" : "b",
      "specValue" : "true"
     },
     {
      "name" : "A",
      "kind" : "type"
     },
     {
      "name" : "B",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "select",
      "kind" : "function",
      "comment" : "\nIf $(D cond) is $(D true), returns $(D a) without evaluating $(D\nb). Otherwise, returns $(D b) without evaluating $(D a).\n \n",
      "line" : 5889,
      "type" : "A(A a, lazy B b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "A"
       },
       {
        "name" : "b",
        "type" : "B",
        "storageClass" : [
         "lazy"
        ]
       }
      ],
      "endline" : 5889
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 5891,
    "name" : "select",
    "parameters" : [
     {
      "name" : "cond",
      "kind" : "value",
      "deco" : "b",
      "specValue" : "false"
     },
     {
      "name" : "A",
      "kind" : "type"
     },
     {
      "name" : "B",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "select",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 5891,
      "type" : "B(lazy A a, B b)",
      "parameters" : [
       {
        "name" : "a",
        "type" : "A",
        "storageClass" : [
         "lazy"
        ]
       },
       {
        "name" : "b",
        "type" : "B"
       }
      ],
      "endline" : 5891
     }
    ]
   },
   {
    "name" : "__unittestL5893_1806",
    "kind" : "function",
    "line" : 5893,
    "endline" : 5902
   }
  ]
 },
 {
  "name" : "std.typecons",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/typecons.d",
  "comment" : "\nThis module implements a variety of type constructors, i.e., templates\nthat allow construction of new, useful general-purpose types.\n\nSource:    $(PHOBOSSRC std/_typecons.d)\n\nMacros:\n\nWIKI = Phobos/StdVariant\n\nSynopsis:\n\n----\n// value tuples\nalias Tuple!(float, \"x\", float, \"y\", float, \"z\") Coord;\nCoord c;\nc[1] = 1;       // access by index\nc.z = 1;        // access by given name\nalias Tuple!(string, string) DicEntry; // names can be omitted\n\n// Rebindable references to const and immutable objects\nvoid bar()\n{\n    const w1 = new Widget, w2 = new Widget;\n    w1.foo();\n    // w1 = w2 would not work; can't rebind const object\n    auto r = Rebindable!(const Widget)(w1);\n    // invoke method as if r were a Widget object\n    r.foo();\n    // rebind r to refer to another object\n    r = w2;\n}\n----\n\nCopyright: Copyright the respective authors, 2008-\nLicense:   $(WEB boost.org/LICENSE_1_0.txt, Boost License 1.0).\nAuthors:   $(WEB erdani.org, Andrei Alexandrescu),\n           $(WEB bartoszmilewski.wordpress.com, Bartosz Milewski),\n           Don Clugston,\n           Shin Fujishiro,\n           Kenji Hara\n \n",
  "members" : [
   {
    "name" : "core.memory",
    "kind" : "import",
    "line" : 46,
    "protection" : "private"
   },
   {
    "name" : "core.stdc.stdlib",
    "kind" : "import",
    "line" : 46,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.format",
    "kind" : "import",
    "line" : 47,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 48,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\nEncapsulates unique ownership of a resource.  Resource of type T is\ndeleted at the end of the scope, unless it is transferred.  The\ntransfer can be explicit, by calling $(D release), or implicit, when\nreturning Unique from a function. The resource can be a polymorphic\nclass object, in which case Unique behaves polymorphically too.\n\nExample:\n",
    "line" : 62,
    "name" : "Unique",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Unique",
      "kind" : "struct",
      "line" : 62,
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n    Constructor that takes an rvalue.\n    It will ensure uniqueness, as long as the rvalue\n    isn't just a view on an lvalue (e.g., a cast)\n    Typical usage:\n    ----\n    Unique!(Foo) f = new Foo;\n    ----\n    \n",
        "line" : 89,
        "type" : "(RefT p)",
        "parameters" : [
         {
          "name" : "p",
          "type" : "RefT"
         }
        ],
        "endline" : 93
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\n    Constructor that takes an lvalue. It nulls its source.\n    The nulling will ensure uniqueness as long as there\n    are no previous aliases to the source.\n    \n",
        "line" : 99,
        "type" : "(ref RefT p)",
        "parameters" : [
         {
          "name" : "p",
          "type" : "RefT",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 105
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "line" : 132,
        "endline" : 137
       },
       {
        "name" : "isEmpty",
        "kind" : "function",
        "line" : 138,
        "type" : "const bool()",
        "endline" : 141
       },
       {
        "name" : "release",
        "kind" : "function",
        "comment" : " Returns a unique rvalue. Nullifies the current contents \n",
        "line" : 143,
        "type" : "Unique()",
        "endline" : 150
       },
       {
        "name" : "opDot",
        "kind" : "function",
        "comment" : " Forwards member access to contents \n",
        "line" : 152,
        "type" : "RefT()",
        "endline" : 152
       },
       {
        "name" : "_p",
        "kind" : "variable",
        "line" : 162,
        "type" : "RefT"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nTuple of values, for example $(D Tuple!(int, string)) is a record that\nstores an $(D int) and a $(D string). $(D Tuple) can be used to bundle\nvalues together, notably when returning multiple values from a\nfunction. If $(D obj) is a tuple, the individual members are\naccessible with the syntax $(D obj[0]) for the first field, $(D obj[1])\nfor the second, and so on.\n\nThe choice of zero-based indexing instead of one-base indexing was\nmotivated by the ability to use value tuples with various compile-time\nloop constructs (e.g. type tuple iteration), all of which use\nzero-based indexing.\n\nExample:\n\n----\nTuple!(int, int) point;\n// assign coordinates\npoint[0] = 5;\npoint[1] = 6;\n// read coordinates\nauto x = point[0];\nauto y = point[1];\n----\n\nTuple members can be named. It is legal to mix named and unnamed\nmembers. The method above is still applicable to all fields.\n\nExample:\n\n----\nalias Tuple!(int, \"index\", string, \"value\") Entry;\nEntry e;\ne.index = 4;\ne.value = \"Hello\";\nassert(e[1] == \"Hello\");\nassert(e[0] == 4);\n----\n\nTuples with named fields are distinct types from tuples with unnamed\nfields, i.e. each naming imparts a separate type for the tuple. Two\ntuple differing in naming only are still distinct, even though they\nmight have the same structure.\n\nExample:\n\n----\nTuple!(int, \"x\", int, \"y\") point1;\nTuple!(int, int) point2;\nassert(!is(typeof(point1) == typeof(point2))); // passes\n----\n",
    "line" : 272,
    "name" : "Tuple",
    "parameters" : [
     {
      "name" : "Specs",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Tuple",
      "kind" : "struct",
      "line" : 272,
      "members" : [
       {
        "kind" : "template",
        "line" : 277,
        "name" : "parseSpecs",
        "parameters" : [
         {
          "name" : "Specs",
          "kind" : "tuple"
         }
        ],
        "members" : []
       },
       {
        "kind" : "template",
        "line" : 303,
        "name" : "FieldSpec",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "s",
          "kind" : "value",
          "type" : "string",
          "defaultValue" : "\"\""
         }
        ],
        "members" : [
         {
          "name" : "Type",
          "kind" : "alias",
          "line" : 305,
          "type" : "T"
         },
         {
          "name" : "name",
          "kind" : "alias",
          "line" : 306,
          "type" : "s"
         }
        ]
       },
       {
        "name" : "fieldSpecs",
        "kind" : "alias",
        "line" : 309,
        "type" : "parseSpecs!(Specs)"
       },
       {
        "kind" : "template",
        "line" : 312,
        "name" : "extractType",
        "parameters" : [
         {
          "name" : "spec",
          "kind" : "alias"
         }
        ],
        "members" : [
         {
          "name" : "extractType",
          "kind" : "alias",
          "line" : 312,
          "type" : "spec.Type"
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 313,
        "name" : "extractName",
        "parameters" : [
         {
          "name" : "spec",
          "kind" : "alias"
         }
        ],
        "members" : [
         {
          "name" : "extractName",
          "kind" : "alias",
          "line" : 313,
          "type" : "spec.name"
         }
        ]
       },
       {
        "name" : "injectNamedFields",
        "kind" : "function",
        "line" : 321,
        "type" : "string()",
        "endline" : 333
       },
       {
        "kind" : "template",
        "line" : 337,
        "name" : "sliceSpecs",
        "parameters" : [
         {
          "name" : "from",
          "kind" : "value",
          "type" : "size_t"
         },
         {
          "name" : "to",
          "kind" : "value",
          "type" : "size_t"
         }
        ],
        "members" : [
         {
          "name" : "sliceSpecs",
          "kind" : "alias",
          "line" : 340,
          "type" : "staticMap!(expandSpec, fieldSpecs[from .. to])"
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 343,
        "name" : "expandSpec",
        "parameters" : [
         {
          "name" : "spec",
          "kind" : "alias"
         }
        ],
        "members" : []
       },
       {
        "name" : "std.traits",
        "kind" : "import",
        "line" : 355,
        "protection" : "private",
        "selective" : [
         "defaultInit"
        ]
       },
       {
        "kind" : "template",
        "line" : 356,
        "name" : "isCompatibleTuples",
        "parameters" : [
         {
          "name" : "Tup1",
          "kind" : "type"
         },
         {
          "name" : "Tup2",
          "kind" : "type"
         },
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "isCompatibleTuples",
          "kind" : "variable",
          "line" : 372,
          "storageClass" : [
           "enum"
          ],
          "init" : "is(typeof(()\n{\nTup1 tup1 = void;\nTup2 tup2 = void;\nstatic assert(tup1.field.length == tup2.field.length);\nforeach (i, _; Tup1.Types)\n{\nauto lhs = defaultInit!(typeof(tup1.field[i]));\nauto rhs = defaultInit!(typeof(tup2.field[i]));\nauto result = mixin(\"lhs \" ~ op ~ \" rhs\");\n}\n}\n))"
         }
        ]
       },
       {
        "name" : "Types",
        "kind" : "alias",
        "comment" : "\n   The type of the tuple's components.\n",
        "line" : 379,
        "type" : "staticMap!(extractType, fieldSpecs)"
       },
       {
        "name" : "expand",
        "kind" : "variable",
        "comment" : "\nUse $(D t.expand) for a tuple $(D t) to expand it into its\ncomponents. The result of $(D expand) acts as if the tuple components\nwere listed as a list of values. (Ordinarily, a $(D Tuple) acts as a\nsingle value.)\n\nExamples:\n----\nauto t = tuple(1, \" hello \", 2.3);\nwriteln(t);        // Tuple!(int, string, double)(1, \" hello \", 2.3)\nwriteln(t.expand); // 1 hello 2.3\n----\n \n",
        "line" : 394,
        "type" : "Types"
       },
       {
        "name" : "field",
        "kind" : "alias",
        "line" : 401,
        "type" : "expand"
       },
       {
        "kind" : "template",
        "line" : 407,
        "name" : "at",
        "parameters" : [
         {
          "name" : "index",
          "kind" : "value",
          "type" : "size_t"
         }
        ],
        "members" : [
         {
          "name" : "at",
          "kind" : "function",
          "line" : 407,
          "storageClass" : [
           "auto",
           "deprecated"
          ],
          "type" : "()",
          "endline" : 409
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Constructor taking one value for each field. Each argument must be\n   implicitly assignable to the respective element of the target.\n \n",
        "line" : 415,
        "name" : "this",
        "parameters" : [],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 415,
          "type" : "(Types values)",
          "parameters" : [
           {
            "name" : "values",
            "type" : "Types"
           }
          ],
          "endline" : 421
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Constructor taking a compatible array. The array element type must\n   be implicitly assignable to each element of the target.\n\nExamples:\n----\nint[2] ints;\nTuple!(int, int) t = ints;\n----\n \n",
        "line" : 433,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         },
         {
          "name" : "n",
          "kind" : "value",
          "type" : "size_t"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 433,
          "type" : "(U[n] values)",
          "parameters" : [
           {
            "name" : "values",
            "type" : "U[n]"
           }
          ],
          "endline" : 441
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Constructor taking a compatible tuple. Each element of the source\n   must be implicitly assignable to the respective element of the\n   target.\n \n",
        "line" : 448,
        "name" : "this",
        "parameters" : [
         {
          "name" : "U",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 448,
          "type" : "(U another)",
          "parameters" : [
           {
            "name" : "another",
            "type" : "U"
           }
          ],
          "endline" : 455
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Comparison for equality.\n \n",
        "line" : 460,
        "name" : "opEquals",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opEquals",
          "kind" : "function",
          "comment" : "\n   Comparison for equality.\n \n",
          "line" : 460,
          "type" : "bool(R rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 468
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 470,
        "name" : "opEquals",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opEquals",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 470,
          "type" : "const bool(R rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 478
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Comparison for ordering.\n \n",
        "line" : 483,
        "name" : "opCmp",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCmp",
          "kind" : "function",
          "comment" : "\n   Comparison for ordering.\n \n",
          "line" : 483,
          "type" : "int(R rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 494
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 496,
        "name" : "opCmp",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCmp",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 496,
          "type" : "const int(R rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 507
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n   Assignment from another tuple. Each element of the source must be\n   implicitly assignable to the respective element of the target.\n \n",
        "line" : 513,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "R",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : "\n   Assignment from another tuple. Each element of the source must be\n   implicitly assignable to the respective element of the target.\n \n",
          "line" : 513,
          "type" : "void(R rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "R"
           }
          ],
          "endline" : 524
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 527,
        "name" : "_workaround4424",
        "parameters" : [],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "line" : 529,
          "type" : "void(typeof(this))",
          "parameters" : [
           {
            "type" : "typeof(this)"
           }
          ]
         }
        ]
       },
       {
        "name" : "_workaround4424!()",
        "kind" : "mixin",
        "line" : 531
       },
       {
        "kind" : "template",
        "comment" : "\n   Takes a slice of the tuple.\n\n   Example:\n\n----\nTuple!(int, string, float, double) a;\na[1] = \"abc\";\na[2] = 4.5;\nauto s = a.slice!(1, 3);\nstatic assert(is(typeof(s) == Tuple!(string, float)));\nassert(s[0] == \"abc\" && s[1] == 4.5);\n----\n \n",
        "line" : 548,
        "name" : "slice",
        "parameters" : [
         {
          "name" : "from",
          "kind" : "value",
          "deco" : "k"
         },
         {
          "name" : "to",
          "kind" : "value",
          "deco" : "k"
         }
        ],
        "members" : [
         {
          "name" : "slice",
          "kind" : "function",
          "line" : 548,
          "type" : "Tuple!(sliceSpecs!(from, to))()",
          "endline" : 551
         }
        ]
       },
       {
        "name" : "length",
        "kind" : "variable",
        "comment" : "\n   The length of the tuple.\n \n",
        "line" : 556,
        "storageClass" : [
         "enum"
        ],
        "init" : "field.length"
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : "\n   Converts to string.\n \n",
        "line" : 561,
        "type" : "string()",
        "endline" : 586
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 589,
    "name" : "Identity",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "Identity",
      "kind" : "alias",
      "line" : 591,
      "type" : "T"
     }
    ]
   },
   {
    "name" : "__unittestL594_1809",
    "kind" : "function",
    "line" : 594,
    "endline" : 747
   },
   {
    "name" : "__unittestL747_1810",
    "kind" : "function",
    "line" : 747,
    "endline" : 839
   },
   {
    "kind" : "template",
    "comment" : "\nReturns a $(D Tuple) object instantiated and initialized according to\nthe arguments.\n\nExample:\n----\nauto value = tuple(5, 6.7, \"hello\");\nassert(value[0] == 5);\nassert(value[1] == 6.7);\nassert(value[2] == \"hello\");\n----\n",
    "line" : 839,
    "name" : "tuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "tuple",
      "kind" : "function",
      "comment" : "\nReturns a $(D Tuple) object instantiated and initialized according to\nthe arguments.\n\nExample:\n----\nauto value = tuple(5, 6.7, \"hello\");\nassert(value[0] == 5);\nassert(value[1] == 6.7);\nassert(value[2] == \"hello\");\n----\n",
      "line" : 839,
      "type" : "Tuple!(T)(T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 842
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nReturns $(D true) if and only if $(D T) is an instance of the\n$(D Tuple) struct template.\n \n",
    "line" : 848,
    "name" : "isTuple",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL860_1811",
    "kind" : "function",
    "line" : 860,
    "endline" : 913
   },
   {
    "kind" : "template",
    "comment" : "\n$(D Rebindable!(T)) is a simple, efficient wrapper that behaves just\nlike an object of type $(D T), except that you can reassign it to\nrefer to another object. For completeness, $(D Rebindable!(T)) aliases\nitself away to $(D T) if $(D T) is a non-const object type. However,\n$(D Rebindable!(T)) does not compile if $(D T) is a non-class type.\n\nRegular $(D const) object references cannot be reassigned:\n\n----\nclass Widget { int x; int y() const { return a; } }\nconst a = new Widget;\na.y();          // fine\na.x = 5;        // error! can't modify const a\na = new Widget; // error! can't modify const a\n----\n\nHowever, $(D Rebindable!(Widget)) does allow reassignment, while\notherwise behaving exactly like a $(D const Widget):\n\n----\nauto a = Rebindable!(const Widget)(new Widget);\na.y();          // fine\na.x = 5;        // error! can't modify const a\na = new Widget; // fine\n----\n\nYou may want to use $(D Rebindable) when you want to have mutable\nstorage referring to $(D const) objects, for example an array of\nreferences that must be sorted in place. $(D Rebindable) does not\nbreak the soundness of D's type system and does not incur any of the\nrisks usually associated with $(D cast).\n\n \n",
    "line" : 913,
    "name" : "Rebindable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nConvenience function for creating a $(D Rebindable) using automatic type\ninference.\n",
    "line" : 968,
    "name" : "rebindable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "rebindable",
      "kind" : "function",
      "comment" : "\nConvenience function for creating a $(D Rebindable) using automatic type\ninference.\n",
      "line" : 968,
      "type" : "Rebindable!(T)(T obj)",
      "parameters" : [
       {
        "name" : "obj",
        "type" : "T"
       }
      ],
      "endline" : 974
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nThis function simply returns the $(D Rebindable) object passed in.  It's useful\nin generic programming cases when a given object may be either a regular\n$(D class) or a $(D Rebindable).\n",
    "line" : 981,
    "name" : "rebindable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "rebindable",
      "kind" : "function",
      "comment" : "\nThis function simply returns the $(D Rebindable) object passed in.  It's useful\nin generic programming cases when a given object may be either a regular\n$(D class) or a $(D Rebindable).\n",
      "line" : 981,
      "type" : "Rebindable!(T)(Rebindable!(T) obj)",
      "parameters" : [
       {
        "name" : "obj",
        "type" : "Rebindable!(T)"
       }
      ],
      "endline" : 984
     }
    ]
   },
   {
    "name" : "__unittestL986_1812",
    "kind" : "function",
    "line" : 986,
    "endline" : 1068
   },
   {
    "kind" : "template",
    "comment" : "\n  Order the provided members to minimize size while preserving alignment.\n  Returns a declaration to be mixed in.\n\nExample:\n---\nstruct Banner {\n  mixin(alignForSize!(byte[6], double)([\"name\", \"height\"]));\n}\n---\n\n  Alignment is not always optimal for 80-bit reals, nor for structs declared\n  as align(1).\n",
    "line" : 1068,
    "name" : "alignForSize",
    "parameters" : [
     {
      "name" : "E",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "alignForSize",
      "kind" : "function",
      "comment" : "\n  Order the provided members to minimize size while preserving alignment.\n  Returns a declaration to be mixed in.\n\nExample:\n---\nstruct Banner {\n  mixin(alignForSize!(byte[6], double)([\"name\", \"height\"]));\n}\n---\n\n  Alignment is not always optimal for 80-bit reals, nor for structs declared\n  as align(1).\n",
      "line" : 1068,
      "type" : "string(string[] names...)",
      "parameters" : [
       {
        "name" : "names",
        "type" : "string[]"
       }
      ],
      "endline" : 1093
     }
    ]
   },
   {
    "name" : "__unittestL1095_1813",
    "kind" : "function",
    "line" : 1095,
    "endline" : 1122
   },
   {
    "kind" : "template",
    "line" : 1123,
    "name" : "Ref",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Ref",
      "kind" : "struct",
      "line" : 1123,
      "members" : [
       {
        "name" : "_p",
        "kind" : "variable",
        "line" : 1124,
        "type" : "T*"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 1125,
        "type" : "(ref T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T",
          "storageClass" : [
           "ref"
          ]
         }
        ],
        "endline" : 1125
       },
       {
        "name" : "opDot",
        "kind" : "function",
        "line" : 1126,
        "type" : "T()",
        "endline" : 1126
       },
       {
        "name" : "opImplicitCastTo",
        "kind" : "function",
        "line" : 1127,
        "type" : "T()",
        "endline" : 1127
       },
       {
        "name" : "value",
        "kind" : "function",
        "line" : 1128,
        "type" : "T()",
        "endline" : 1128
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "line" : 1130,
        "type" : "void(T value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T"
         }
        ],
        "endline" : 1133
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "line" : 1134,
        "type" : "void(T* value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T*"
         }
        ],
        "endline" : 1137
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1140_1814",
    "kind" : "function",
    "line" : 1140,
    "endline" : 1168
   },
   {
    "kind" : "template",
    "comment" : "\nDefines a value paired with a distinctive \"null\" state that denotes\nthe absence of a value. If default constructed, a $(D\nNullable!T) object starts in the null state. Assigning it renders it\nnon-null. Calling $(D nullify) can nullify it again.\n\nExample:\n----\nNullable!int a;\nassert(a.isNull);\na = 5;\nassert(!a.isNull);\nassert(a == 5);\n----\n\nPractically $(D Nullable!T) stores a $(D T) and a $(D bool).\n \n",
    "line" : 1169,
    "name" : "Nullable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Nullable",
      "kind" : "struct",
      "line" : 1169,
      "members" : [
       {
        "name" : "_value",
        "kind" : "variable",
        "line" : 1170,
        "type" : "T"
       },
       {
        "name" : "_isNull",
        "kind" : "variable",
        "line" : 1171,
        "deco" : "b",
        "init" : "true"
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor initializing $(D this) with $(D value).\n \n",
        "line" : 1176,
        "name" : "this",
        "parameters" : [],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1176,
          "type" : "inout (T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 1180
         }
        ]
       },
       {
        "name" : "isNull",
        "kind" : "function",
        "comment" : "\nReturns $(D true) if and only if $(D this) is in the null state.\n \n",
        "line" : 1185,
        "type" : "const pure nothrow @safe bool()",
        "endline" : 1188
       },
       {
        "kind" : "template",
        "comment" : "\nForces $(D this) to the null state.\n \n",
        "line" : 1193,
        "name" : "nullify",
        "parameters" : [],
        "members" : [
         {
          "name" : "nullify",
          "kind" : "function",
          "comment" : "\nForces $(D this) to the null state.\n \n",
          "line" : 1193,
          "type" : "void()",
          "endline" : 1197
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAssigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null.\n \n",
        "line" : 1203,
        "name" : "opAssign",
        "parameters" : [],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : "\nAssigns $(D value) to the internally-held state. If the assignment\nsucceeds, $(D this) becomes non-null.\n \n",
          "line" : 1203,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 1207
         }
        ]
       },
       {
        "name" : "get",
        "kind" : "function",
        "comment" : "\nGets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n \n",
        "line" : 1213,
        "type" : "inout pure nothrow @safe inout(T)()",
        "endline" : 1218
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1227_1815",
    "kind" : "function",
    "line" : 1227,
    "endline" : 1248
   },
   {
    "name" : "__unittestL1248_1816",
    "kind" : "function",
    "line" : 1248,
    "endline" : 1255
   },
   {
    "name" : "__unittestL1255_1817",
    "kind" : "function",
    "line" : 1255,
    "endline" : 1267
   },
   {
    "name" : "__unittestL1267_1818",
    "kind" : "function",
    "line" : 1267,
    "endline" : 1281
   },
   {
    "name" : "__unittestL1281_1820",
    "kind" : "function",
    "line" : 1281,
    "endline" : 1295
   },
   {
    "name" : "__unittestL1295_1821",
    "kind" : "function",
    "line" : 1295,
    "endline" : 1312
   },
   {
    "name" : "__unittestL1312_1822",
    "kind" : "function",
    "line" : 1312,
    "endline" : 1325
   },
   {
    "name" : "__unittestL1325_1823",
    "kind" : "function",
    "line" : 1325,
    "endline" : 1340
   },
   {
    "name" : "__unittestL1340_1824",
    "kind" : "function",
    "line" : 1340,
    "endline" : 1383
   },
   {
    "name" : "__unittestL1383_1825",
    "kind" : "function",
    "line" : 1383,
    "endline" : 1418
   },
   {
    "kind" : "template",
    "comment" : "\nJust like $(D Nullable!T), except that the null state is defined as a\nparticular value. For example, $(D Nullable!(uint, uint.max)) is an\n$(D uint) that sets aside the value $(D uint.max) to denote a null\nstate. $(D Nullable!(T, nullValue)) is more storage-efficient than $(D\nNullable!T) because it does not need to store an extra $(D bool).\n \n",
    "line" : 1419,
    "name" : "Nullable",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "nullValue",
      "kind" : "value",
      "type" : "T"
     }
    ],
    "members" : [
     {
      "name" : "Nullable",
      "kind" : "struct",
      "line" : 1419,
      "members" : [
       {
        "name" : "_value",
        "kind" : "variable",
        "line" : 1420,
        "type" : "T",
        "init" : "nullValue"
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor initializing $(D this) with $(D value).\n \n",
        "line" : 1425,
        "name" : "this",
        "parameters" : [],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 1425,
          "type" : "(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 1428
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nReturns $(D true) if and only if $(D this) is in the null state.\n \n",
        "line" : 1433,
        "name" : "isNull",
        "parameters" : [],
        "members" : [
         {
          "name" : "isNull",
          "kind" : "function",
          "line" : 1433,
          "type" : "const bool()",
          "endline" : 1436
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nForces $(D this) to the null state.\n \n",
        "line" : 1441,
        "name" : "nullify",
        "parameters" : [],
        "members" : [
         {
          "name" : "nullify",
          "kind" : "function",
          "comment" : "\nForces $(D this) to the null state.\n \n",
          "line" : 1441,
          "type" : "void()",
          "endline" : 1444
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nAssigns $(D value) to the internally-held state. No null checks are\nmade. Note that the assignment may leave $(D this) in the null state.\n \n",
        "line" : 1450,
        "name" : "opAssign",
        "parameters" : [],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : "\nAssigns $(D value) to the internally-held state. No null checks are\nmade. Note that the assignment may leave $(D this) in the null state.\n \n",
          "line" : 1450,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 1453
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\nGets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n \n",
        "line" : 1459,
        "name" : "get",
        "parameters" : [],
        "members" : [
         {
          "name" : "get",
          "kind" : "function",
          "line" : 1459,
          "type" : "inout inout(T)()",
          "endline" : 1466
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1475_1826",
    "kind" : "function",
    "line" : 1475,
    "endline" : 1485
   },
   {
    "name" : "__unittestL1485_1827",
    "kind" : "function",
    "line" : 1485,
    "endline" : 1492
   },
   {
    "name" : "__unittestL1492_1828",
    "kind" : "function",
    "line" : 1492,
    "endline" : 1504
   },
   {
    "name" : "__unittestL1504_1830",
    "kind" : "function",
    "line" : 1504,
    "endline" : 1518
   },
   {
    "name" : "__unittestL1518_1831",
    "kind" : "function",
    "line" : 1518,
    "endline" : 1535
   },
   {
    "name" : "__unittestL1535_1832",
    "kind" : "function",
    "line" : 1535,
    "endline" : 1569
   },
   {
    "kind" : "template",
    "comment" : "\nJust like $(D Nullable!T), except that the object refers to a value\nsitting elsewhere in memory. This makes assignments overwrite the\ninitially assigned value. Internally $(D NullableRef!T) only stores a\npointer to $(D T) (i.e., $(D Nullable!T.sizeof == (T*).sizeof)).\n \n",
    "line" : 1570,
    "name" : "NullableRef",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "NullableRef",
      "kind" : "struct",
      "line" : 1570,
      "members" : [
       {
        "name" : "_value",
        "kind" : "variable",
        "line" : 1571,
        "type" : "T*"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "comment" : "\nConstructor binding $(D this) with $(D value).\n \n",
        "line" : 1576,
        "type" : "pure nothrow @safe (T* value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T*"
         }
        ],
        "endline" : 1579
       },
       {
        "name" : "bind",
        "kind" : "function",
        "comment" : "\nBinds the internal state to $(D value).\n \n",
        "line" : 1584,
        "type" : "pure nothrow @safe void(T* value)",
        "parameters" : [
         {
          "name" : "value",
          "type" : "T*"
         }
        ],
        "endline" : 1587
       },
       {
        "name" : "isNull",
        "kind" : "function",
        "comment" : "\nReturns $(D true) if and only if $(D this) is in the null state.\n \n",
        "line" : 1592,
        "type" : "const pure nothrow @safe bool()",
        "endline" : 1595
       },
       {
        "name" : "nullify",
        "kind" : "function",
        "comment" : "\nForces $(D this) to the null state.\n \n",
        "line" : 1600,
        "type" : "pure nothrow @safe void()",
        "endline" : 1603
       },
       {
        "kind" : "template",
        "comment" : "\nAssigns $(D value) to the internally-held state.\n \n",
        "line" : 1608,
        "name" : "opAssign",
        "parameters" : [],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : "\nAssigns $(D value) to the internally-held state.\n \n",
          "line" : 1608,
          "type" : "void(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 1614
         }
        ]
       },
       {
        "name" : "get",
        "kind" : "function",
        "comment" : "\nGets the value. $(D this) must not be in the null state.\nThis function is also called for the implicit conversion to $(D T).\n \n",
        "line" : 1620,
        "type" : "inout pure nothrow @safe inout(T)()",
        "endline" : 1625
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1634_1833",
    "kind" : "function",
    "line" : 1634,
    "endline" : 1655
   },
   {
    "name" : "__unittestL1655_1834",
    "kind" : "function",
    "line" : 1655,
    "endline" : 1666
   },
   {
    "name" : "__unittestL1666_1836",
    "kind" : "function",
    "line" : 1666,
    "endline" : 1685
   },
   {
    "name" : "__unittestL1685_1837",
    "kind" : "function",
    "line" : 1685,
    "endline" : 1705
   },
   {
    "name" : "__unittestL1705_1838",
    "kind" : "function",
    "line" : 1705,
    "endline" : 1769
   },
   {
    "kind" : "template",
    "comment" : "\n$(D BlackHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions in $(D Base) as do-nothing functions.  Each\nauto-implemented function just returns the default value of the return type\nwithout doing anything.\n\nThe name came from\n$(WEB search.cpan.org/~sburke/Class-_BlackHole-0.04/lib/Class/_BlackHole.pm, Class::_BlackHole)\nPerl module by Sean M. Burke.\n\nExample:\n--------------------\nabstract class C\n{\n    int m_value;\n    this(int v) { m_value = v; }\n    int value() @property { return m_value; }\n\n    abstract real realValue() @property;\n    abstract void doSomething();\n}\n\nvoid main()\n{\n    auto c = new BlackHole!C(42);\n    writeln(c.value);     // prints \"42\"\n\n    // Abstract functions are implemented as do-nothing:\n    writeln(c.realValue); // prints \"NaN\"\n    c.doSomething();      // does nothing\n}\n--------------------\n\nSee_Also:\n  AutoImplement, generateEmptyFunction\n \n",
    "line" : 1769,
    "name" : "BlackHole",
    "parameters" : [
     {
      "name" : "Base",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "BlackHole",
      "kind" : "alias",
      "line" : 1772,
      "type" : "AutoImplement!(Base, generateEmptyFunction, isAbstractFunction)"
     }
    ]
   },
   {
    "name" : "__unittestL1775_1839",
    "kind" : "function",
    "line" : 1775,
    "endline" : 1835
   },
   {
    "kind" : "template",
    "comment" : "\n$(D WhiteHole!Base) is a subclass of $(D Base) which automatically implements\nall abstract member functions as throw-always functions.  Each auto-implemented\nfunction fails with throwing an $(D Error) and does never return.  Useful for\ntrapping use of not-yet-implemented functions.\n\nThe name came from\n$(WEB search.cpan.org/~mschwern/Class-_WhiteHole-0.04/lib/Class/_WhiteHole.pm, Class::_WhiteHole)\nPerl module by Michael G Schwern.\n\nExample:\n--------------------\nclass C\n{\n    abstract void notYetImplemented();\n}\n\nvoid main()\n{\n    auto c = new WhiteHole!C;\n    c.notYetImplemented(); // throws an Error\n}\n--------------------\n\nBUGS:\n  Nothrow functions cause program to abort in release mode because the trap is\n  implemented with $(D assert(0)) for nothrow functions.\n\nSee_Also:\n  AutoImplement, generateAssertTrap\n \n",
    "line" : 1835,
    "name" : "WhiteHole",
    "parameters" : [
     {
      "name" : "Base",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "WhiteHole",
      "kind" : "alias",
      "line" : 1838,
      "type" : "AutoImplement!(Base, generateAssertTrap, isAbstractFunction)"
     }
    ]
   },
   {
    "name" : "NotImplementedError",
    "kind" : "class",
    "line" : 1842,
    "base" : "Error",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1844,
      "deco" : "FAyaZC3std8typecons19NotImplementedError",
      "originalType" : "(string method)",
      "parameters" : [
       {
        "name" : "method",
        "deco" : "Aya"
       }
      ],
      "endline" : 1847
     }
    ]
   },
   {
    "name" : "__unittestL1850_1840",
    "kind" : "function",
    "line" : 1850,
    "endline" : 1970
   },
   {
    "kind" : "template",
    "comment" : "\n$(D AutoImplement) automatically implements (by default) all abstract member\nfunctions in the class or interface $(D Base) in specified way.\n\nParams:\n  how  = template which specifies _how functions will be implemented/overridden.\n\n         Two arguments are passed to $(D how): the type $(D Base) and an alias\n         to an implemented function.  Then $(D how) must return an implemented\n         function body as a string.\n\n         The generated function body can use these keywords:\n         $(UL\n            $(LI $(D a0), $(D a1), &hellip;: arguments passed to the function;)\n            $(LI $(D args): a tuple of the arguments;)\n            $(LI $(D self): an alias to the function itself;)\n            $(LI $(D parent): an alias to the overridden function (if any).)\n         )\n\n        You may want to use templated property functions (instead of Implicit\n        Template Properties) to generate complex functions:\n--------------------\n// Prints log messages for each call to overridden functions.\nstring generateLogger(C, alias fun)() @property\n{\n    enum qname = C.stringof ~ \".\" ~ __traits(identifier, fun);\n    string stmt;\n\n    stmt ~= q{ struct Importer { import std.stdio; } };\n    stmt ~= `Importer.writeln$(LPAREN)\"Log: ` ~ qname ~ `(\", args, \")\"$(RPAREN);`;\n    static if (!__traits(isAbstractFunction, fun))\n    {\n        static if (is(typeof(return) == void))\n            stmt ~= q{ parent(args); };\n        else\n            stmt ~= q{\n                auto r = parent(args);\n                Importer.writeln(\"--> \", r);\n                return r;\n            };\n    }\n    return stmt;\n}\n--------------------\n\n  what = template which determines _what functions should be\n         implemented/overridden.\n\n         An argument is passed to $(D what): an alias to a non-final member\n         function in $(D Base).  Then $(D what) must return a boolean value.\n         Return $(D true) to indicate that the passed function should be\n         implemented/overridden.\n\n--------------------\n// Sees if fun returns something.\ntemplate hasValue(alias fun)\n{\n    enum bool hasValue = !is(ReturnType!(fun) == void);\n}\n--------------------\n\n\nNote:\n\nGenerated code is inserted in the scope of $(D std.typecons) module.  Thus,\nany useful functions outside $(D std.typecons) cannot be used in the generated\ncode.  To workaround this problem, you may $(D import) necessary things in a\nlocal struct, as done in the $(D generateLogger()) template in the above\nexample.\n\n\nBUGS:\n\n$(UL\n $(LI Variadic arguments to constructors are not forwarded to super.)\n $(LI Deep interface inheritance causes compile error with messages like\n      \"Error: function std.typecons._AutoImplement!(Foo)._AutoImplement.bar\n      does not override any function\".  [$(BUGZILLA 2525), $(BUGZILLA 3525)] )\n $(LI The $(D parent) keyword is actually a delegate to the super class'\n      corresponding member function.  [$(BUGZILLA 2540)] )\n $(LI Using alias template parameter in $(D how) and/or $(D what) may cause\n     strange compile error.  Use template tuple parameter instead to workaround\n     this problem.  [$(BUGZILLA 4217)] )\n)\n \n",
    "line" : 1970,
    "name" : "AutoImplement",
    "parameters" : [
     {
      "name" : "Base",
      "kind" : "type"
     },
     {
      "name" : "how",
      "kind" : "alias"
     },
     {
      "name" : "what",
      "kind" : "alias",
      "defaultAlias" : "isAbstractFunction"
     }
    ],
    "members" : [
     {
      "name" : "AutoImplement",
      "kind" : "class",
      "line" : 1970,
      "members" : [
       {
        "name" : "autoImplement_helper_",
        "kind" : "alias",
        "line" : 1974,
        "type" : "AutoImplement_Helper!(\"autoImplement_helper_\", \"Base\", Base, how, what)"
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1983,
    "name" : "AutoImplement_Helper",
    "parameters" : [
     {
      "name" : "myName",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "baseName",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "Base",
      "kind" : "type"
     },
     {
      "name" : "generateMethodBody",
      "kind" : "alias"
     },
     {
      "name" : "cherrypickMethod",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1992,
      "name" : "staticFilter",
      "parameters" : [
       {
        "name" : "pred",
        "kind" : "alias"
       },
       {
        "name" : "lst",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "kind" : "template",
      "line" : 2008,
      "name" : "enumerateOverloads",
      "parameters" : [
       {
        "name" : "C",
        "kind" : "type"
       },
       {
        "name" : "pred",
        "kind" : "alias"
       }
      ],
      "members" : [
       {
        "kind" : "template",
        "line" : 2010,
        "name" : "Impl",
        "parameters" : [
         {
          "name" : "names",
          "kind" : "tuple"
         }
        ],
        "members" : []
       },
       {
        "name" : "enumerateOverloads",
        "kind" : "alias",
        "line" : 2026,
        "type" : "Impl!(__traits(allMembers, C))"
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2034,
      "name" : "canonicalPicker",
      "parameters" : [
       {
        "name" : "fun",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "canonicalPicker",
        "kind" : "variable",
        "line" : 2036,
        "storageClass" : [
         "enum"
        ],
        "deco" : "b",
        "init" : "!__traits(isFinalFunction, fun[0]) && cherrypickMethod!(fun)"
       }
      ]
     },
     {
      "name" : "targetOverloadSets",
      "kind" : "alias",
      "line" : 2044,
      "type" : "enumerateOverloads!(Base, canonicalPicker)"
     },
     {
      "kind" : "template",
      "line" : 2073,
      "name" : "INTERNAL_FUNCINFO_ID",
      "parameters" : [
       {
        "name" : "name",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "i",
        "kind" : "value",
        "type" : "size_t"
       }
      ],
      "members" : [
       {
        "name" : "INTERNAL_FUNCINFO_ID",
        "kind" : "variable",
        "line" : 2075,
        "storageClass" : [
         "enum"
        ],
        "type" : "string",
        "init" : "format(\"F_%s_%s\", name, i)"
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2083,
      "name" : "populate",
      "parameters" : [
       {
        "name" : "overloads",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "kind" : "template",
      "line" : 2091,
      "name" : "populate",
      "parameters" : [
       {
        "name" : "name",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "methods",
        "kind" : "tuple"
       }
      ],
      "members" : []
     },
     {
      "name" : "populate!(targetOverloadSets)",
      "kind" : "mixin",
      "line" : 2104
     },
     {
      "name" : "populate!(ctorOverloadSet)",
      "kind" : "mixin",
      "line" : 2105
     },
     {
      "kind" : "template",
      "line" : 2113,
      "name" : "CommonGeneratingPolicy",
      "parameters" : [],
      "members" : [
       {
        "name" : "BASE_CLASS_ID",
        "kind" : "variable",
        "line" : 2116,
        "storageClass" : [
         "enum"
        ],
        "type" : "string",
        "init" : "baseName"
       },
       {
        "kind" : "template",
        "line" : 2119,
        "name" : "FUNCINFO_ID",
        "parameters" : [
         {
          "name" : "name",
          "kind" : "value",
          "type" : "string"
         },
         {
          "name" : "i",
          "kind" : "value",
          "type" : "size_t"
         }
        ],
        "members" : [
         {
          "name" : "FUNCINFO_ID",
          "kind" : "variable",
          "line" : 2121,
          "storageClass" : [
           "enum"
          ],
          "type" : "string",
          "init" : "myName ~ \".\" ~ INTERNAL_FUNCINFO_ID!(name, i)"
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2127,
      "name" : "ConstructorGeneratingPolicy",
      "parameters" : [],
      "members" : [
       {
        "name" : "CommonGeneratingPolicy!()",
        "kind" : "mixin",
        "line" : 2129
       },
       {
        "kind" : "template",
        "line" : 2132,
        "name" : "generateFunctionBody",
        "parameters" : [
         {
          "name" : "ctor",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "generateFunctionBody",
          "kind" : "function",
          "line" : 2132,
          "type" : "@property string()",
          "endline" : 2144
         }
        ]
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2148,
      "name" : "MethodGeneratingPolicy",
      "parameters" : [],
      "members" : [
       {
        "name" : "CommonGeneratingPolicy!()",
        "kind" : "mixin",
        "line" : 2150
       },
       {
        "kind" : "template",
        "line" : 2153,
        "name" : "generateFunctionBody",
        "parameters" : [
         {
          "name" : "func",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "generateFunctionBody",
          "kind" : "function",
          "line" : 2153,
          "type" : "@property string()",
          "endline" : 2156
         }
        ]
       }
      ]
     },
     {
      "name" : "ConstructorGenerator",
      "kind" : "alias",
      "line" : 2165,
      "type" : "MemberFunctionGenerator!(ConstructorGeneratingPolicy!())"
     },
     {
      "name" : "MethodGenerator",
      "kind" : "alias",
      "line" : 2167,
      "type" : "MemberFunctionGenerator!(MethodGeneratingPolicy!())"
     },
     {
      "name" : "code",
      "kind" : "variable",
      "line" : 2169,
      "storageClass" : [
       "enum"
      ],
      "type" : "string",
      "init" : "ConstructorGenerator.generateCode!(ctorOverloadSet) ~ \"\\x0a\" ~ MethodGenerator.generateCode!(targetOverloadSets)"
     }
    ]
   },
   {
    "name" : "__unittestL2183_1841",
    "kind" : "function",
    "line" : 2183,
    "endline" : 2265
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 2265,
    "name" : "OverloadSet",
    "parameters" : [
     {
      "name" : "nam",
      "kind" : "value",
      "deco" : "Aya"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "name",
      "kind" : "variable",
      "line" : 2267,
      "storageClass" : [
       "enum"
      ],
      "type" : "string",
      "init" : "nam"
     },
     {
      "name" : "contents",
      "kind" : "alias",
      "line" : 2268,
      "type" : "T"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 2274,
    "name" : "FuncInfo",
    "parameters" : [
     {
      "name" : "func",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "type",
      "default" : "typeof(&func)"
     }
    ],
    "members" : [
     {
      "name" : "RT",
      "kind" : "alias",
      "line" : 2276,
      "type" : "ReturnType!(T)"
     },
     {
      "name" : "PT",
      "kind" : "alias",
      "line" : 2277,
      "type" : "ParameterTypeTuple!(T)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 2279,
    "name" : "FuncInfo",
    "parameters" : [
     {
      "name" : "Func",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "RT",
      "kind" : "alias",
      "line" : 2281,
      "type" : "ReturnType!(Func)"
     },
     {
      "name" : "PT",
      "kind" : "alias",
      "line" : 2282,
      "type" : "ParameterTypeTuple!(Func)"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 2311,
    "name" : "MemberFunctionGenerator",
    "parameters" : [
     {
      "name" : "Policy",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "CONSTRUCTOR_NAME",
      "kind" : "variable",
      "line" : 2318,
      "storageClass" : [
       "enum"
      ],
      "init" : "\"__ctor\""
     },
     {
      "name" : "WITH_BASE_CLASS",
      "kind" : "variable",
      "line" : 2321,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(hasMember, Policy, \"BASE_CLASS_ID\")"
     },
     {
      "name" : "WITHOUT_SYMBOL",
      "kind" : "variable",
      "line" : 2324,
      "storageClass" : [
       "enum"
      ],
      "init" : "__traits(hasMember, Policy, \"WITHOUT_SYMBOL\")"
     },
     {
      "kind" : "template",
      "line" : 2341,
      "name" : "CountUp",
      "parameters" : [
       {
        "name" : "n",
        "kind" : "value",
        "type" : "size_t"
       }
      ],
      "members" : []
     },
     {
      "kind" : "template",
      "line" : 2358,
      "name" : "generateCode",
      "parameters" : [
       {
        "name" : "overloads",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "generateCode",
        "kind" : "function",
        "line" : 2358,
        "type" : "@property string()",
        "endline" : 2381
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2384,
      "name" : "generateCodeForOverloadSet",
      "parameters" : [
       {
        "name" : "oset",
        "kind" : "alias"
       }
      ],
      "members" : [
       {
        "name" : "generateCodeForOverloadSet",
        "kind" : "function",
        "line" : 2384,
        "type" : "@property string()",
        "endline" : 2396
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2403,
      "name" : "generateFunction",
      "parameters" : [
       {
        "name" : "myFuncInfo",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "name",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "func",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "generateFunction",
        "kind" : "function",
        "line" : 2403,
        "type" : "@property string()",
        "endline" : 2499
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2505,
      "name" : "generateParameters",
      "parameters" : [
       {
        "name" : "myFuncInfo",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "func",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "generateParameters",
        "kind" : "function",
        "line" : 2505,
        "type" : "string()",
        "endline" : 2547
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2551,
      "name" : "enumerateParameters",
      "parameters" : [
       {
        "name" : "n",
        "kind" : "value",
        "type" : "size_t"
       }
      ],
      "members" : [
       {
        "name" : "enumerateParameters",
        "kind" : "function",
        "line" : 2551,
        "type" : "@property string()",
        "endline" : 2562
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nPredefined how-policies for $(D AutoImplement).  These templates are used by\n$(D BlackHole) and $(D WhiteHole), respectively.\n \n",
    "line" : 2570,
    "name" : "generateEmptyFunction",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     },
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 2587,
    "name" : "generateAssertTrap",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     },
     {
      "name" : "func",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "RefCountedAutoInitialize",
    "kind" : "enum",
    "comment" : "\nOptions regarding auto-initialization of a $(D RefCounted) object (see\nthe definition of $(D RefCounted) below).\n \n",
    "line" : 2609,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "no",
      "kind" : "enum member",
      "comment" : " Do not auto-initialize the object\n",
      "line" : 2611
     },
     {
      "name" : "yes",
      "kind" : "enum member",
      "comment" : " Auto-initialize the object\n",
      "line" : 2613
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\nDefines a reference-counted object containing a $(D T) value as\npayload. $(D RefCounted) keeps track of all references of an object,\nand when the reference count goes down to zero, frees the underlying\nstore. $(D RefCounted) uses $(D malloc) and $(D free) for operation.\n\n$(D RefCounted) is unsafe and should be used with care. No references\nto the payload should be escaped outside the $(D RefCounted) object.\n\nThe $(D autoInit) option makes the object ensure the store is\nautomatically initialized. Leaving $(D autoInit ==\nRefCountedAutoInitialize.yes) (the default option) is convenient but\nhas the cost of a test whenever the payload is accessed. If $(D\nautoInit == RefCountedAutoInitialize.no), user code must call either\n$(D refCountedIsInitialized) or $(D refCountedEnsureInitialized)\nbefore attempting to access the payload. Not doing so results in null\npointer dereference.\n\nExample:\n----\n// A pair of an $(D int) and a $(D size_t) - the latter being the\n// reference count - will be dynamically allocated\nauto rc1 = RefCounted!int(5);\nassert(rc1 == 5);\n// No more allocation, add just one extra reference count\nauto rc2 = rc1;\n// Reference semantics\nrc2 = 42;\nassert(rc1 == 42);\n// the pair will be freed when rc1 and rc2 go out of scope\n----\n \n",
    "line" : 2651,
    "name" : "RefCounted",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "autoInit",
      "kind" : "value",
      "deco" : "E3std8typecons24RefCountedAutoInitialize",
      "defaultValue" : "RefCountedAutoInitialize.yes"
     }
    ],
    "members" : [
     {
      "name" : "RefCounted",
      "kind" : "struct",
      "line" : 2651,
      "members" : [
       {
        "name" : "RefCountedStore",
        "kind" : "struct",
        "comment" : " $(D RefCounted) storage implementation.\n",
        "line" : 2654,
        "members" : [
         {
          "name" : "Impl",
          "kind" : "struct",
          "line" : 2656,
          "members" : [
           {
            "name" : "_payload",
            "kind" : "variable",
            "line" : 2657,
            "type" : "T"
           },
           {
            "name" : "_count",
            "kind" : "variable",
            "line" : 2658,
            "type" : "size_t"
           }
          ]
         },
         {
          "name" : "_store",
          "kind" : "variable",
          "line" : 2661,
          "type" : "Impl*"
         },
         {
          "kind" : "template",
          "line" : 2663,
          "name" : "initialize",
          "parameters" : [
           {
            "name" : "A",
            "kind" : "tuple"
           }
          ],
          "members" : [
           {
            "name" : "initialize",
            "kind" : "function",
            "line" : 2663,
            "type" : "void(auto ref A args)",
            "parameters" : [
             {
              "name" : "args",
              "type" : "A",
              "storageClass" : [
               "auto",
               "ref"
              ]
             }
            ],
            "endline" : 2670
           }
          ]
         },
         {
          "name" : "isInitialized",
          "kind" : "function",
          "comment" : "\n           Returns $(D true) if and only if the underlying store has been\n           allocated and initialized.\n        \n",
          "line" : 2677,
          "type" : "const bool()",
          "endline" : 2680
         },
         {
          "name" : "refCount",
          "kind" : "function",
          "comment" : "\n           Returns underlying reference count if it is allocated and initialized\n           (a positive integer), and $(D 0) otherwise.\n        \n",
          "line" : 2687,
          "type" : "const size_t()",
          "endline" : 2690
         },
         {
          "name" : "ensureInitialized",
          "kind" : "function",
          "comment" : "\n           Makes sure the payload was properly initialized. Such a\n           call is typically inserted before using the payload.\n        \n",
          "line" : 2696,
          "type" : "void()",
          "endline" : 2699
         }
        ]
       },
       {
        "name" : "_refCounted",
        "kind" : "variable",
        "line" : 2702,
        "type" : "RefCountedStore"
       },
       {
        "name" : "refCountedStore",
        "kind" : "function",
        "comment" : " Returns storage implementation struct.\n",
        "line" : 2706,
        "type" : "inout inout(RefCountedStore)()",
        "endline" : 2709
       },
       {
        "kind" : "template",
        "comment" : "\nConstructor that initializes the payload.\n\nPostcondition: $(D refCountedIsInitialized)\n \n",
        "line" : 2716,
        "name" : "this",
        "parameters" : [
         {
          "name" : "A",
          "kind" : "tuple"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 2716,
          "type" : "(auto ref A args)",
          "parameters" : [
           {
            "name" : "args",
            "type" : "A",
            "storageClass" : [
             "auto",
             "ref"
            ]
           }
          ],
          "endline" : 2719
         }
        ]
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "comment" : "\nDestructor that tracks the reference count appropriately. If $(D\n!refCountedIsInitialized), does nothing. When the reference count goes\ndown to zero, calls $(D destroy) agaist the payload and calls $(D free)\nto deallocate the corresponding resource.\n \n",
        "line" : 2737,
        "endline" : 2749
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : "\nAssignment operators\n \n",
        "line" : 2754,
        "type" : "void(typeof(this) rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "typeof(this)"
         }
        ],
        "endline" : 2757
       },
       {
        "name" : "opAssign",
        "kind" : "function",
        "comment" : " Ditto\n",
        "line" : 2760,
        "type" : "void(T rhs)",
        "parameters" : [
         {
          "name" : "rhs",
          "type" : "T"
         }
        ],
        "endline" : 2771
       },
       {
        "name" : "refCountedPayload",
        "kind" : "function",
        "line" : 2811,
        "type" : "inout inout(T)()",
        "endline" : 2815
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL2827_1842",
    "kind" : "function",
    "line" : 2827,
    "endline" : 2866
   },
   {
    "name" : "__unittestL2866_1843",
    "kind" : "function",
    "line" : 2866,
    "endline" : 2873
   },
   {
    "name" : "__unittestL2873_1844",
    "kind" : "function",
    "line" : 2873,
    "endline" : 2888
   },
   {
    "name" : "__unittestL2888_1845",
    "kind" : "function",
    "line" : 2888,
    "endline" : 2897
   },
   {
    "name" : "__unittestL2897_1846",
    "kind" : "function",
    "line" : 2897,
    "endline" : 2935
   },
   {
    "kind" : "template",
    "comment" : "\nMake proxy for $(D a).\n\nExample:\n----\nstruct MyInt\n{\n    private int value;\n    mixin Proxy!value;\n\n    this(int n){ value = n; }\n}\n\nMyInt n = 10;\n\n// Enable operations that original type has.\n++n;\nassert(n == 11);\nassert(n * 2 == 22);\n\nvoid func(int n) { }\n\n// Disable implicit conversions to original type.\n//int x = n;\n//func(n);\n----\n \n",
    "line" : 2935,
    "name" : "Proxy",
    "parameters" : [
     {
      "name" : "a",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 2937,
      "name" : "opEquals",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "B",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opEquals",
        "kind" : "function",
        "line" : 2937,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref B b)",
        "parameters" : [
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2947
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2949,
      "name" : "opCmp",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "B",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opCmp",
        "kind" : "function",
        "line" : 2949,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref B b)",
        "parameters" : [
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2958
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2960,
      "name" : "opCall",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "opCall",
        "kind" : "function",
        "line" : 2960,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref Args args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "Args",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2960
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2962,
      "name" : "opCast",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       },
       {
        "name" : "X",
        "kind" : "this"
       }
      ],
      "members" : [
       {
        "name" : "opCast",
        "kind" : "function",
        "line" : 2962,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref ()",
        "endline" : 2962
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2964,
      "name" : "opIndex",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "D",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "opIndex",
        "kind" : "function",
        "line" : 2964,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref D i)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "D",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2964
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2965,
      "name" : "opSlice",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       }
      ],
      "members" : [
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 2965,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref ()",
        "endline" : 2965
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2966,
      "name" : "opSlice",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "B",
        "kind" : "type"
       },
       {
        "name" : "E",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opSlice",
        "kind" : "function",
        "line" : 2966,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref B b, auto ref E e)",
        "parameters" : [
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "e",
          "type" : "E",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2966
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2968,
      "name" : "opUnary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       }
      ],
      "members" : [
       {
        "name" : "opUnary",
        "kind" : "function",
        "line" : 2968,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref ()",
        "endline" : 2968
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2969,
      "name" : "opIndexUnary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "D",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "opIndexUnary",
        "kind" : "function",
        "line" : 2969,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref D i)",
        "parameters" : [
         {
          "name" : "i",
          "type" : "D",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2969
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2970,
      "name" : "opSliceUnary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       }
      ],
      "members" : [
       {
        "name" : "opSliceUnary",
        "kind" : "function",
        "line" : 2970,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref ()",
        "endline" : 2970
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2971,
      "name" : "opSliceUnary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "B",
        "kind" : "type"
       },
       {
        "name" : "E",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opSliceUnary",
        "kind" : "function",
        "line" : 2971,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref B b, auto ref E e)",
        "parameters" : [
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "e",
          "type" : "E",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2971
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2973,
      "name" : "opBinary",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "B",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinary",
        "kind" : "function",
        "line" : 2973,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref B b)",
        "parameters" : [
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2977
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2978,
      "name" : "opBinaryRight",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "B",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opBinaryRight",
        "kind" : "function",
        "line" : 2978,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref B b)",
        "parameters" : [
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2978
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2997,
      "name" : "opAssign",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opAssign",
        "kind" : "function",
        "line" : 2997,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2997
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2998,
      "name" : "opIndexAssign",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       },
       {
        "name" : "D",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "opIndexAssign",
        "kind" : "function",
        "line" : 2998,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v, auto ref D i)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "i",
          "type" : "D",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2998
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 2999,
      "name" : "opSliceAssign",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opSliceAssign",
        "kind" : "function",
        "line" : 2999,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 2999
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3000,
      "name" : "opSliceAssign",
      "parameters" : [
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       },
       {
        "name" : "B",
        "kind" : "type"
       },
       {
        "name" : "E",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opSliceAssign",
        "kind" : "function",
        "line" : 3000,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v, auto ref B b, auto ref E e)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "e",
          "type" : "E",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 3000
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3002,
      "name" : "opOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opOpAssign",
        "kind" : "function",
        "line" : 3002,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 3002
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3003,
      "name" : "opIndexOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       },
       {
        "name" : "D",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "opIndexOpAssign",
        "kind" : "function",
        "line" : 3003,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v, auto ref D i)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "i",
          "type" : "D",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 3003
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3004,
      "name" : "opSliceOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opSliceOpAssign",
        "kind" : "function",
        "line" : 3004,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 3004
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3005,
      "name" : "opSliceOpAssign",
      "parameters" : [
       {
        "name" : "op",
        "kind" : "value",
        "type" : "string"
       },
       {
        "name" : "X",
        "kind" : "this"
       },
       {
        "name" : "V",
        "kind" : "type"
       },
       {
        "name" : "B",
        "kind" : "type"
       },
       {
        "name" : "E",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "opSliceOpAssign",
        "kind" : "function",
        "line" : 3005,
        "storageClass" : [
         "auto"
        ],
        "type" : "ref (auto ref V v, auto ref B b, auto ref E e)",
        "parameters" : [
         {
          "name" : "v",
          "type" : "V",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "b",
          "type" : "B",
          "storageClass" : [
           "auto",
           "ref"
          ]
         },
         {
          "name" : "e",
          "type" : "E",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 3005
       }
      ]
     },
     {
      "kind" : "template",
      "line" : 3007,
      "name" : "opDispatch",
      "parameters" : [
       {
        "name" : "name",
        "kind" : "value",
        "type" : "string"
       }
      ],
      "members" : []
     }
    ]
   },
   {
    "name" : "__unittestL3035_1850",
    "kind" : "function",
    "line" : 3035,
    "endline" : 3082
   },
   {
    "name" : "__unittestL3082_1852",
    "kind" : "function",
    "line" : 3082,
    "endline" : 3122
   },
   {
    "name" : "__unittestL3122_1854",
    "kind" : "function",
    "line" : 3122,
    "endline" : 3188
   },
   {
    "name" : "__unittestL3188_1855",
    "kind" : "function",
    "line" : 3188,
    "endline" : 3225
   },
   {
    "name" : "__unittestL3225_1856",
    "kind" : "function",
    "line" : 3225,
    "endline" : 3243
   },
   {
    "kind" : "template",
    "comment" : "\nLibrary typedef.\n \n",
    "line" : 3243,
    "name" : "Typedef",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "Typedef",
      "kind" : "alias",
      "line" : 3245,
      "type" : ".Typedef!(T, T.init)"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " ditto\n",
    "line" : 3250,
    "name" : "Typedef",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "init",
      "kind" : "value",
      "type" : "T"
     },
     {
      "name" : "cookie",
      "kind" : "value",
      "deco" : "Aya",
      "defaultValue" : "null"
     }
    ],
    "members" : [
     {
      "name" : "Typedef",
      "kind" : "struct",
      "line" : 3250,
      "members" : [
       {
        "name" : "Typedef_payload",
        "kind" : "variable",
        "line" : 3251,
        "type" : "T",
        "init" : "init"
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3253,
        "type" : "(T init)",
        "parameters" : [
         {
          "name" : "init",
          "type" : "T"
         }
        ],
        "endline" : 3256
       },
       {
        "name" : "Proxy!(Typedef_payload)",
        "kind" : "mixin",
        "line" : 3258
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL3261_1859",
    "kind" : "function",
    "line" : 3261,
    "endline" : 3286
   },
   {
    "name" : "__unittestL3286_1860",
    "kind" : "function",
    "line" : 3286,
    "endline" : 3314
   },
   {
    "kind" : "template",
    "comment" : "\nAllocates a $(D class) object right inside the current scope,\ntherefore avoiding the overhead of $(D new). This facility is unsafe;\nit is the responsibility of the user to not escape a reference to the\nobject outside the scope.\n\nNote: it's illegal to move a class reference even if you are sure there\nare no pointers to it. As such, it is illegal to move a scoped object.\n \n",
    "line" : 3314,
    "name" : "scoped",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "alignment",
      "kind" : "alias",
      "line" : 3319,
      "type" : "classInstanceAlignment!(T)"
     },
     {
      "name" : "aligned",
      "kind" : "alias",
      "line" : 3320,
      "type" : "_alignUp!(alignment)"
     },
     {
      "name" : "Scoped",
      "kind" : "struct",
      "line" : 3323,
      "members" : [
       {
        "name" : "Scoped_store",
        "kind" : "variable",
        "line" : 3325,
        "type" : "void[aligned(__traits(classInstanceSize, T) + size_t.sizeof) + alignment]",
        "init" : "void"
       },
       {
        "name" : "Scoped_payload",
        "kind" : "function",
        "line" : 3327,
        "type" : "inout inout(T)()",
        "endline" : 3340
       },
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 3343,
        "type" : "()"
       },
       {
        "name" : "~this",
        "kind" : "destructor",
        "line" : 3346,
        "endline" : 3351
       }
      ]
     },
     {
      "kind" : "template",
      "comment" : " Returns the scoped object\n",
      "line" : 3355,
      "name" : "scoped",
      "parameters" : [
       {
        "name" : "Args",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "scoped",
        "kind" : "function",
        "comment" : " Returns the scoped object\n",
        "line" : 3355,
        "storageClass" : [
         "auto"
        ],
        "type" : "@system (auto ref Args args)",
        "parameters" : [
         {
          "name" : "args",
          "type" : "Args",
          "storageClass" : [
           "auto",
           "ref"
          ]
         }
        ],
        "endline" : 3363
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL3366_1862",
    "kind" : "function",
    "comment" : "\n",
    "line" : 3366,
    "endline" : 3397
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 3397,
    "name" : "_alignUp",
    "parameters" : [
     {
      "name" : "alignment",
      "kind" : "value",
      "deco" : "m"
     }
    ],
    "members" : [
     {
      "name" : "_alignUp",
      "kind" : "function",
      "line" : 3397,
      "type" : "size_t(size_t n)",
      "parameters" : [
       {
        "name" : "n",
        "type" : "size_t"
       }
      ],
      "endline" : 3402
     }
    ]
   },
   {
    "name" : "__unittestL3404_1863",
    "kind" : "function",
    "line" : 3404,
    "endline" : 3467
   },
   {
    "name" : "__unittestL3467_1864",
    "kind" : "function",
    "line" : 3467,
    "endline" : 3476
   },
   {
    "name" : "__unittestL3476_1865",
    "kind" : "function",
    "line" : 3476,
    "endline" : 3487
   },
   {
    "name" : "__unittestL3487_1866",
    "kind" : "function",
    "line" : 3487,
    "endline" : 3498
   },
   {
    "name" : "__unittestL3498_1867",
    "kind" : "function",
    "line" : 3498,
    "endline" : 3509
   },
   {
    "name" : "__unittestL3509_1868",
    "kind" : "function",
    "line" : 3509,
    "endline" : 3520
   },
   {
    "name" : "__unittestL3520_1869",
    "kind" : "function",
    "line" : 3520,
    "endline" : 3543
   },
   {
    "name" : "__unittestL3543_1870",
    "kind" : "function",
    "line" : 3543,
    "endline" : 3564
   },
   {
    "name" : "__unittestL3564_1871",
    "kind" : "function",
    "line" : 3564,
    "endline" : 3587
   },
   {
    "name" : "__unittestL3587_1872",
    "kind" : "function",
    "line" : 3587,
    "endline" : 3593
   },
   {
    "name" : "__unittestL3593_1873",
    "kind" : "function",
    "line" : 3593,
    "endline" : 3622
   },
   {
    "name" : "__unittestL3622_1874",
    "kind" : "function",
    "line" : 3622,
    "endline" : 3631
   },
   {
    "name" : "__unittestL3631_1875",
    "kind" : "function",
    "line" : 3631,
    "endline" : 3698
   },
   {
    "kind" : "template",
    "comment" : "\nDefines a simple, self-documenting yes/no flag. This makes it easy for\nAPIs to define functions accepting flags without resorting to $(D\nbool), which is opaque in calls, and without needing to define an\nenumerated type separately. Using $(D Flag!\"Name\") instead of $(D\nbool) makes the flag's meaning visible in calls. Each yes/no flag has\nits own type, which makes confusions and mix-ups impossible.\n\nExample:\n----\n// Before\nstring getLine(bool keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\n// Code calling getLine (usually far away from its definition) can't\n// be understood without looking at the documentation, even by users\n// familiar with the API. Assuming the reverse meaning\n// (i.e. \"ignoreTerminator\") and inserting the wrong code compiles and\n// runs with erroneous results.\nauto line = getLine(false);\n\n// After\nstring getLine(Flag!\"KeepTerminator\" keepTerminator)\n{\n    ...\n    if (keepTerminator) ...\n    ...\n}\n...\n// Code calling getLine can be easily read and understood even by\n// people not fluent with the API.\nauto line = getLine(Flag!\"KeepTerminator\".yes);\n----\n\nPassing categorical data by means of unstructured $(D bool)\nparameters is classified under \"simple-data coupling\" by Steve\nMcConnell in the $(LUCKY Code Complete) book, along with three other\nkinds of coupling. The author argues citing several studies that\ncoupling has a negative effect on code quality. $(D Flag) offers a\nsimple structuring method for passing yes/no flags to APIs.\n\nAs a perk, the flag's name may be any string and as such can include\ncharacters not normally allowed in identifiers, such as\nspaces and dashes.\n \n",
    "line" : 3698,
    "name" : "Flag",
    "parameters" : [
     {
      "name" : "name",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "Flag",
      "kind" : "enum",
      "comment" : "\n",
      "line" : 3700,
      "baseDeco" : "b",
      "members" : [
       {
        "name" : "no",
        "kind" : "enum member",
        "comment" : "\n         When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".no) for the negative option. When using a value\n         of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".no) or just $(D false) or $(D 0).  \n",
        "line" : 3707
       },
       {
        "name" : "yes",
        "kind" : "enum member",
        "comment" : " When creating a value of type $(D Flag!\"Name\"), use $(D\n         Flag!\"Name\".yes) for the affirmative option. When using a\n         value of type $(D Flag!\"Name\"), compare it against $(D\n         Flag!\"Name\".yes).\n        \n",
        "line" : 3714
       }
      ]
     }
    ]
   },
   {
    "name" : "Yes",
    "kind" : "struct",
    "comment" : "\nConvenience names that allow using e.g. $(D Yes.encryption) instead of\n$(D Flag!\"encryption\".yes) and $(D No.encryption) instead of $(D\nFlag!\"encryption\".no).\n",
    "line" : 3724,
    "members" : [
     {
      "kind" : "template",
      "line" : 3725,
      "name" : "opDispatch",
      "parameters" : [
       {
        "name" : "name",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opDispatch",
        "kind" : "variable",
        "line" : 3727,
        "storageClass" : [
         "enum"
        ],
        "init" : "Flag!(name).yes"
       }
      ]
     }
    ]
   },
   {
    "name" : "No",
    "kind" : "struct",
    "comment" : " Ditto\n",
    "line" : 3734,
    "members" : [
     {
      "kind" : "template",
      "line" : 3735,
      "name" : "opDispatch",
      "parameters" : [
       {
        "name" : "name",
        "kind" : "value",
        "deco" : "Aya"
       }
      ],
      "members" : [
       {
        "name" : "opDispatch",
        "kind" : "variable",
        "line" : 3737,
        "storageClass" : [
         "enum"
        ],
        "init" : "Flag!(name).no"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL3742_1876",
    "kind" : "function",
    "line" : 3742,
    "endline" : 3756
   }
  ]
 },
 {
  "name" : "std.typetuple",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/typetuple.d",
  "comment" : "\n Templates with which to manipulate type tuples (also known as type lists).\n\n Some operations on type tuples are built in to the language,\n such as TL[$(I n)] which gets the $(I n)th type from the\n type tuple. TL[$(I lwr) .. $(I upr)] returns a new type\n list that is a slice of the old one.\n\n Several templates in this module use or operate on eponymous templates that\n take a single argument and evaluate to a boolean constant. Such templates\n are referred to as $(I template predicates).\n\n References:\n  Based on ideas in Table 3.1 from\n  $(LINK2 http://amazon.com/exec/obidos/ASIN/0201704315/ref=ase_classicempire/102-2957199-2585768,\n      Modern C++ Design),\n   Andrei Alexandrescu (Addison-Wesley Professional, 2001)\n Macros:\n  WIKI = Phobos/StdTypeTuple\n\n Copyright: Copyright Digital Mars 2005 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:\n     $(WEB digitalmars.com, Walter Bright),\n     $(WEB klickverbot.at, David Nadlinger)\n Source:    $(PHOBOSSRC std/_typetuple.d)\n \n",
  "members" : [
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 37,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\n Creates a typetuple out of a sequence of zero or more types.\n Example:\n ---\n import std.typetuple;\n alias TypeTuple!(int, double) TL;\n\n int foo(TL td)  // same as int foo(int, double);\n {\n    return td[0] + cast(int)td[1];\n }\n ---\n\n Example:\n ---\n TypeTuple!(TL, char)\n // is equivalent to:\n TypeTuple!(int, double, char)\n ---\n \n",
    "line" : 59,
    "name" : "TypeTuple",
    "parameters" : [
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "TypeTuple",
      "kind" : "alias",
      "line" : 61,
      "type" : "TList"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the index of the first occurrence of type T in the\n sequence of zero or more types TList.\n If not found, -1 is returned.\n Example:\n ---\n import std.typetuple;\n import std.stdio;\n\n void foo()\n {\n    writefln(\"The index of long is %s\",\n          staticIndexOf!(long, TypeTuple!(int, long, double)));\n    // prints: The index of long is 1\n }\n ---\n \n",
    "line" : 81,
    "name" : "staticIndexOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "staticIndexOf",
      "kind" : "variable",
      "line" : 83,
      "storageClass" : [
       "enum"
      ],
      "init" : "genericIndexOf!(T, TList).index"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 87,
    "name" : "staticIndexOf",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "staticIndexOf",
      "kind" : "variable",
      "line" : 89,
      "storageClass" : [
       "enum"
      ],
      "init" : "genericIndexOf!(T, TList).index"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 93,
    "name" : "genericIndexOf",
    "parameters" : [
     {
      "name" : "args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "e",
      "kind" : "alias",
      "line" : 96,
      "type" : "Alias!(args[0])"
     },
     {
      "name" : "tuple",
      "kind" : "alias",
      "line" : 97,
      "type" : "args[1 .. __dollar]"
     }
    ]
   },
   {
    "name" : "__unittestL120_1877",
    "kind" : "function",
    "line" : 120,
    "endline" : 143
   },
   {
    "name" : "IndexOf",
    "kind" : "alias",
    "comment" : " Kept for backwards compatibility\n",
    "line" : 143
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a typetuple created from TList with the first occurrence,\n if any, of T removed.\n Example:\n ---\n Erase!(long, int, long, double, char)\n // is the same as:\n TypeTuple!(int, double, char)\n ---\n \n",
    "line" : 164,
    "name" : "Erase",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Erase",
      "kind" : "alias",
      "line" : 166,
      "type" : "GenericErase!(T, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 170,
    "name" : "Erase",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Erase",
      "kind" : "alias",
      "line" : 172,
      "type" : "GenericErase!(T, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 176,
    "name" : "GenericErase",
    "parameters" : [
     {
      "name" : "args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "e",
      "kind" : "alias",
      "line" : 179,
      "type" : "Alias!(args[0])"
     },
     {
      "name" : "tuple",
      "kind" : "alias",
      "line" : 180,
      "type" : "args[1 .. __dollar]"
     }
    ]
   },
   {
    "name" : "__unittestL198_1878",
    "kind" : "function",
    "line" : 198,
    "endline" : 222
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a typetuple created from TList with the all occurrences,\n if any, of T removed.\n Example:\n ---\n alias TypeTuple!(int, long, long, int) TL;\n\n EraseAll!(long, TL)\n // is the same as:\n TypeTuple!(int, int)\n ---\n \n",
    "line" : 222,
    "name" : "EraseAll",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "EraseAll",
      "kind" : "alias",
      "line" : 224,
      "type" : "GenericEraseAll!(T, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 228,
    "name" : "EraseAll",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "EraseAll",
      "kind" : "alias",
      "line" : 230,
      "type" : "GenericEraseAll!(T, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 234,
    "name" : "GenericEraseAll",
    "parameters" : [
     {
      "name" : "args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "e",
      "kind" : "alias",
      "line" : 237,
      "type" : "Alias!(args[0])"
     },
     {
      "name" : "tuple",
      "kind" : "alias",
      "line" : 238,
      "type" : "args[1 .. __dollar]"
     }
    ]
   },
   {
    "name" : "__unittestL257_1879",
    "kind" : "function",
    "line" : 257,
    "endline" : 281
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a typetuple created from TList with the all duplicate\n types removed.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n NoDuplicates!(TL)\n // is the same as:\n TypeTuple!(int, long, float)\n ---\n \n",
    "line" : 281,
    "name" : "NoDuplicates",
    "parameters" : [
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL289_1880",
    "kind" : "function",
    "line" : 289,
    "endline" : 310
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a typetuple created from TList with the first occurrence\n of type T, if found, replaced with type U.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n Replace!(long, char, TL)\n // is the same as:\n TypeTuple!(int, char, long, int, float)\n ---\n \n",
    "line" : 310,
    "name" : "Replace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Replace",
      "kind" : "alias",
      "line" : 312,
      "type" : "GenericReplace!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 316,
    "name" : "Replace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "U",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Replace",
      "kind" : "alias",
      "line" : 318,
      "type" : "GenericReplace!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 322,
    "name" : "Replace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Replace",
      "kind" : "alias",
      "line" : 324,
      "type" : "GenericReplace!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 328,
    "name" : "Replace",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "U",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Replace",
      "kind" : "alias",
      "line" : 330,
      "type" : "GenericReplace!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 334,
    "name" : "GenericReplace",
    "parameters" : [
     {
      "name" : "args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "from",
      "kind" : "alias",
      "line" : 337,
      "type" : "Alias!(args[0])"
     },
     {
      "name" : "to",
      "kind" : "alias",
      "line" : 338,
      "type" : "Alias!(args[1])"
     },
     {
      "name" : "tuple",
      "kind" : "alias",
      "line" : 339,
      "type" : "args[2 .. __dollar]"
     }
    ]
   },
   {
    "name" : "__unittestL358_1881",
    "kind" : "function",
    "line" : 358,
    "endline" : 389
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a typetuple created from TList with all occurrences\n of type T, if found, replaced with type U.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n ReplaceAll!(long, char, TL)\n // is the same as:\n TypeTuple!(int, char, char, int, float)\n ---\n \n",
    "line" : 389,
    "name" : "ReplaceAll",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "ReplaceAll",
      "kind" : "alias",
      "line" : 391,
      "type" : "GenericReplaceAll!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 395,
    "name" : "ReplaceAll",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "U",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "ReplaceAll",
      "kind" : "alias",
      "line" : 397,
      "type" : "GenericReplaceAll!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 401,
    "name" : "ReplaceAll",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "U",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "ReplaceAll",
      "kind" : "alias",
      "line" : 403,
      "type" : "GenericReplaceAll!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 407,
    "name" : "ReplaceAll",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "alias"
     },
     {
      "name" : "U",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "ReplaceAll",
      "kind" : "alias",
      "line" : 409,
      "type" : "GenericReplaceAll!(T, U, TList).result"
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 413,
    "name" : "GenericReplaceAll",
    "parameters" : [
     {
      "name" : "args",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "from",
      "kind" : "alias",
      "line" : 416,
      "type" : "Alias!(args[0])"
     },
     {
      "name" : "to",
      "kind" : "alias",
      "line" : 417,
      "type" : "Alias!(args[1])"
     },
     {
      "name" : "tuple",
      "kind" : "alias",
      "line" : 418,
      "type" : "args[2 .. __dollar]"
     }
    ]
   },
   {
    "name" : "__unittestL437_1882",
    "kind" : "function",
    "line" : 437,
    "endline" : 467
   },
   {
    "kind" : "template",
    "comment" : "\n Returns a typetuple created from TList with the order reversed.\n Example:\n ---\n alias TypeTuple!(int, long, long, int, float) TL;\n\n Reverse!(TL)\n // is the same as:\n TypeTuple!(float, int, long, long, int)\n ---\n \n",
    "line" : 467,
    "name" : "Reverse",
    "parameters" : [
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the type from TList that is the most derived from type T.\n If none are found, T is returned.\n Example:\n ---\n class A { }\n class B : A { }\n class C : B { }\n alias TypeTuple!(A, C, B) TL;\n\n MostDerived!(Object, TL) x;  // x is declared as type C\n ---\n \n",
    "line" : 488,
    "name" : "MostDerived",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n Returns the typetuple TList with the types sorted so that the most\n derived types come first.\n Example:\n ---\n class A { }\n class B : A { }\n class C : B { }\n alias TypeTuple!(A, C, B) TL;\n\n DerivedToFront!(TL)\n // is the same as:\n TypeTuple!(C, B, A)\n ---\n \n",
    "line" : 513,
    "name" : "DerivedToFront",
    "parameters" : [
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\nEvaluates to $(D TypeTuple!(F!(T[0]), F!(T[1]), ..., F!(T[$ - 1]))).\n\nExample:\n----\nalias staticMap!(Unqual, int, const int, immutable int) T;\nstatic assert(is(T == TypeTuple!(int, int, int)));\n----\n \n",
    "line" : 534,
    "name" : "staticMap",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL553_1883",
    "kind" : "function",
    "line" : 553,
    "endline" : 580
   },
   {
    "kind" : "template",
    "comment" : "\nTests whether all given items satisfy a template predicate, i.e. evaluates to\n$(D F!(T[0]) && F!(T[1]) && ... && F!(T[$ - 1])).\n\nEvaluation is $(I not) short-circuited if a false result is encountered; the\ntemplate predicate must be instantiable with all the given items.\n\nExample:\n----\nstatic assert(!allSatisfy!(isIntegral, int, double));\nstatic assert(allSatisfy!(isIntegral, int, long));\n----\n \n",
    "line" : 580,
    "name" : "allSatisfy",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL598_1884",
    "kind" : "function",
    "line" : 598,
    "endline" : 617
   },
   {
    "kind" : "template",
    "comment" : "\nTests whether all given items satisfy a template predicate, i.e. evaluates to\n$(D F!(T[0]) || F!(T[1]) || ... || F!(T[$ - 1])).\n\nEvaluation is $(I not) short-circuited if a true result is encountered; the\ntemplate predicate must be instantiable with all the given items.\n\nExample:\n----\nstatic assert(!anySatisfy!(isIntegral, string, double));\nstatic assert(anySatisfy!(isIntegral, int, double));\n----\n \n",
    "line" : 617,
    "name" : "anySatisfy",
    "parameters" : [
     {
      "name" : "F",
      "kind" : "alias"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL635_1885",
    "kind" : "function",
    "line" : 635,
    "endline" : 656
   },
   {
    "kind" : "template",
    "comment" : "\n    Filters a $(D TypeTuple) using a template predicate. Returns a\n    $(D TypeTuple) of the elements which satisfy the predicate.\n\n    Examples:\n--------------------\nstatic assert(is(Filter!(isNarrowString, string, wstring,\n                         dchar[], char[], dstring, int) ==\n                 TypeTuple!(string, wstring, char[])));\nstatic assert(is(Filter!(isUnsigned, int, byte, ubyte,\n                         dstring, dchar, uint, ulong) ==\n                 TypeTuple!(ubyte, uint, ulong)));\n--------------------\n  \n",
    "line" : 656,
    "name" : "Filter",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     },
     {
      "name" : "TList",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL679_1886",
    "kind" : "function",
    "line" : 679,
    "endline" : 689
   },
   {
    "name" : "__unittestL689_1887",
    "kind" : "function",
    "line" : 689,
    "endline" : 697
   },
   {
    "kind" : "template",
    "comment" : "\n Negates the passed template predicate.\n\n Examples:\n ---\n alias templateNot!isPointer isNoPointer;\n static assert(!isNoPointer!(int*));\n static assert(allSatisfy!(isNoPointer, string, char, float));\n ---\n \n",
    "line" : 726,
    "name" : "templateNot",
    "parameters" : [
     {
      "name" : "pred",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 728,
      "name" : "templateNot",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : [
       {
        "name" : "templateNot",
        "kind" : "variable",
        "line" : 730,
        "storageClass" : [
         "enum"
        ],
        "init" : "!pred!(T)"
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL735_1888",
    "kind" : "function",
    "line" : 735,
    "endline" : 744
   },
   {
    "name" : "__unittestL744_1889",
    "kind" : "function",
    "line" : 744,
    "endline" : 774
   },
   {
    "kind" : "template",
    "comment" : "\n Combines several template predicates using logical AND, i.e. constructs a new\n predicate which evaluates to true for a given input T if and only if all of\n the passed predicates are true for T.\n\n The predicates are evaluated from left to right, aborting evaluation in a\n short-cut manner if a false result is encountered, in which case the latter\n instantiations do not need to compile.\n\n Examples:\n ---\n alias templateAnd!(isNumeric, templateNot!isUnsigned) storesNegativeNumbers;\n static assert(storesNegativeNumbers!int);\n static assert(!storesNegativeNumbers!string && !storesNegativeNumbers!uint);\n\n // An empty list of predicates always yields true.\n alias templateAnd!() alwaysTrue;\n static assert(alwaysTrue!int);\n ---\n \n",
    "line" : 774,
    "name" : "templateAnd",
    "parameters" : [
     {
      "name" : "Preds",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 776,
      "name" : "templateAnd",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     }
    ]
   },
   {
    "name" : "__unittestL793_1890",
    "kind" : "function",
    "line" : 793,
    "endline" : 804
   },
   {
    "name" : "__unittestL804_1891",
    "kind" : "function",
    "line" : 804,
    "endline" : 841
   },
   {
    "kind" : "template",
    "comment" : "\n Combines several template predicates using logical OR, i.e. constructs a new\n predicate which evaluates to true for a given input T if and only at least\n one of the passed predicates is true for T.\n\n The predicates are evaluated from left to right, aborting evaluation in a\n short-cut manner if a true result is encountered, in which case the latter\n instantiations do not need to compile.\n\n Examples:\n ---\n alias templateOr!(isPointer, isUnsigned) isPtrOrUnsigned;\n static assert(isPtrOrUnsigned!uint && isPtrOrUnsigned!(short*));\n static assert(!isPtrOrUnsigned!int && !isPtrOrUnsigned!string);\n\n // An empty list of predicates never yields true.\n alias templateOr!() alwaysFalse;\n static assert(!alwaysFalse!int);\n ---\n \n",
    "line" : 841,
    "name" : "templateOr",
    "parameters" : [
     {
      "name" : "Preds",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 843,
      "name" : "templateOr",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "tuple"
       }
      ],
      "members" : []
     }
    ]
   },
   {
    "name" : "__unittestL860_1892",
    "kind" : "function",
    "line" : 860,
    "endline" : 871
   },
   {
    "name" : "__unittestL871_1893",
    "kind" : "function",
    "line" : 871,
    "endline" : 893
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 901,
    "name" : "Alias",
    "parameters" : [
     {
      "name" : "a",
      "kind" : "alias"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "package",
    "line" : 911,
    "name" : "Alias",
    "parameters" : [
     {
      "name" : "a",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Alias",
      "kind" : "alias",
      "line" : 913,
      "type" : "a"
     }
    ]
   },
   {
    "name" : "__unittestL916_1900",
    "kind" : "function",
    "protection" : "package",
    "line" : 916,
    "endline" : 927
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 939,
    "name" : "isSame",
    "parameters" : [
     {
      "name" : "ab",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 962,
    "name" : "expectType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 963,
    "name" : "expectBool",
    "parameters" : [
     {
      "name" : "b",
      "kind" : "value",
      "deco" : "b"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL965_1901",
    "kind" : "function",
    "protection" : "private",
    "line" : 965,
    "endline" : 1014
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1014,
    "name" : "Pack",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "tuple",
      "kind" : "alias",
      "line" : 1016,
      "type" : "T"
     },
     {
      "kind" : "template",
      "line" : 1019,
      "name" : "equals",
      "parameters" : [
       {
        "name" : "U",
        "kind" : "tuple"
       }
      ],
      "members" : []
     }
    ]
   },
   {
    "name" : "__unittestL1036_1902",
    "kind" : "function",
    "protection" : "private",
    "line" : 1036,
    "endline" : 1051
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1051,
    "name" : "Instantiate",
    "parameters" : [
     {
      "name" : "Template",
      "kind" : "alias"
     },
     {
      "name" : "Params",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Instantiate",
      "kind" : "alias",
      "line" : 1053,
      "type" : "Template!(Params)"
     }
    ]
   }
  ]
 },
 {
  "name" : "std.uni",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/uni.d",
  "comment" : "\n    Functions which operate on Unicode characters.\n\n    For functions which operate on ASCII characters and ignore Unicode\n    characters, see $(LINK2 std_ascii.html, std.ascii).\n\n    References:\n        $(WEB www.digitalmars.com/d/ascii-table.html, ASCII Table),\n        $(WEB en.wikipedia.org/wiki/Unicode, Wikipedia),\n        $(WEB www.unicode.org, The Unicode Consortium)\n\n    Trademarks:\n        Unicode(tm) is a trademark of Unicode, Inc.\n\n    Macros:\n        WIKI=Phobos/StdUni\n\n    Copyright: Copyright 2000 -\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright), Jonathan M Davis, and Kenji Hara\n    Source:    $(PHOBOSSRC std/_uni.d)\n  \n",
  "members" : [
   {
    "name" : "std.ascii",
    "kind" : "static import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "lineSep",
    "kind" : "variable",
    "comment" : " UTF line separator\n",
    "line" : 29,
    "storageClass" : [
     "enum"
    ],
    "deco" : "w",
    "init" : "'\\U00002028'"
   },
   {
    "name" : "paraSep",
    "kind" : "variable",
    "comment" : " UTF paragraph separator\n",
    "line" : 30,
    "storageClass" : [
     "enum"
    ],
    "deco" : "w",
    "init" : "'\\U00002029'"
   },
   {
    "name" : "isWhite",
    "kind" : "function",
    "comment" : "\n    Whether or not $(D c) is a Unicode whitespace character.\n    (general Unicode category: Part of C0(tab, vertical tab, form feed,\n    carriage return, and linefeed characters), Zs, Zl, Zp, and NEL(U+0085))\n  \n",
    "line" : 37,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 44
   },
   {
    "name" : "isLower",
    "kind" : "function",
    "comment" : "\n    Return whether $(D c) is a Unicode lowercase character.\n  \n",
    "line" : 50,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 56
   },
   {
    "name" : "isUpper",
    "kind" : "function",
    "comment" : "\n    Return whether $(D c) is a Unicode uppercase character.\n  \n",
    "line" : 62,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 68
   },
   {
    "name" : "toLower",
    "kind" : "function",
    "comment" : "\n    If $(D c) is a Unicode uppercase character, then its lowercase equivalent\n    is returned. Otherwise $(D c) is returned.\n  \n",
    "line" : 75,
    "deco" : "FNaNbNfwZw",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 128
   },
   {
    "name" : "toUpper",
    "kind" : "function",
    "comment" : "\n    If $(D c) is a Unicode lowercase character, then its uppercase equivalent\n    is returned. Otherwise $(D c) is returned.\n  \n",
    "line" : 135,
    "deco" : "FNaNbNfwZw",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 188
   },
   {
    "name" : "isAlpha",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode alpha character\n    (general Unicode category: Lu, Ll, Lt, Lm, and Lo).\n\n    Standards: Unicode 5.0.0.\n  \n",
    "line" : 197,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 575
   },
   {
    "name" : "__unittestL577_1903",
    "kind" : "function",
    "line" : 577,
    "endline" : 598
   },
   {
    "name" : "isMark",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode mark\n    (general Unicode category: Mn, Me, Mc).\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 598,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 933
   },
   {
    "name" : "__unittestL935_1904",
    "kind" : "function",
    "line" : 935,
    "endline" : 950
   },
   {
    "name" : "isNumber",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode numerical character\n    (general Unicode category: Nd, Nl, No).\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 950,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1058
   },
   {
    "name" : "__unittestL1060_1905",
    "kind" : "function",
    "line" : 1060,
    "endline" : 1076
   },
   {
    "name" : "isPunctuation",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode punctuation character\n    (general Unicode category: Pd, Ps, Pe, Pc, Po, Pi, Pf).\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1076,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1425
   },
   {
    "name" : "__unittestL1427_1906",
    "kind" : "function",
    "line" : 1427,
    "endline" : 1445
   },
   {
    "name" : "isSymbol",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode symbol character\n    (general Unicode category: Sm, Sc, Sk, So)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1445,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1740
   },
   {
    "name" : "__unittestL1742_1907",
    "kind" : "function",
    "line" : 1742,
    "endline" : 1757
   },
   {
    "name" : "isSpace",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode whitespace character\n    (general Unicode category: Zs)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1757,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1763
   },
   {
    "name" : "__unittestL1765_1908",
    "kind" : "function",
    "line" : 1765,
    "endline" : 1778
   },
   {
    "name" : "isGraphical",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode graphical character\n    (general Unicode category: L, M, N, P, S, Zs).\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1778,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1782
   },
   {
    "name" : "__unittestL1784_1909",
    "kind" : "function",
    "line" : 1784,
    "endline" : 1796
   },
   {
    "name" : "isControl",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode control character\n    (general Unicode category: Cc)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1796,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1799
   },
   {
    "name" : "__unittestL1801_1910",
    "kind" : "function",
    "line" : 1801,
    "endline" : 1813
   },
   {
    "name" : "isFormat",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode formatting character\n    (general Unicode category: Cf)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1813,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1835
   },
   {
    "name" : "__unittestL1837_1911",
    "kind" : "function",
    "line" : 1837,
    "endline" : 1849
   },
   {
    "name" : "isPrivateUse",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode Private Use character\n    (general Unicode category: Co)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1849,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1854
   },
   {
    "name" : "__unittestL1857_1912",
    "kind" : "function",
    "line" : 1857,
    "endline" : 1868
   },
   {
    "name" : "isSurrogate",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode surrogate character\n    (general Unicode category: Cs)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1868,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1871
   },
   {
    "name" : "isSurrogateHi",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode high surrogate (lead surrogate).\n\n    Standards: Unicode 2.0.\n  \n",
    "line" : 1878,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1881
   },
   {
    "name" : "isSurrogateLo",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode low surrogate (trail surrogate).\n\n    Standards: Unicode 2.0.\n  \n",
    "line" : 1888,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1891
   },
   {
    "name" : "__unittestL1893_1913",
    "kind" : "function",
    "line" : 1893,
    "endline" : 1904
   },
   {
    "name" : "isNonCharacter",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a Unicode non-character\n    (general Unicode category: Cn)\n\n    Standards: Unicode 6.0.0.\n  \n",
    "line" : 1904,
    "deco" : "FNaNbNfwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 2412
   },
   {
    "name" : "__unittestL2414_1914",
    "kind" : "function",
    "line" : 2414,
    "endline" : 2422
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2424,
    "name" : "binarySearch",
    "parameters" : [
     {
      "name" : "table",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "binarySearch",
      "kind" : "function",
      "line" : 2424,
      "type" : "pure nothrow @safe bool(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 2439
     }
    ]
   },
   {
    "name" : "binarySearch2",
    "kind" : "function",
    "protection" : "private",
    "line" : 2441,
    "deco" : "FNaNbNfwyAG2wZb",
    "originalType" : "pure nothrow @safe bool(dchar c, immutable dchar[2][] table)",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     },
     {
      "name" : "table",
      "deco" : "yAG2w"
     }
    ],
    "endline" : 2484
   }
  ]
 },
 {
  "name" : "std.uri",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/uri.d",
  "comment" : "\n Encode and decode Uniform Resource Identifiers (URIs).\n URIs are used in internet transfer protocols.\n Valid URI characters consist of letters, digits,\n and the characters $(B ;/?:@&amp;=+$,-_.!~*'())\n Reserved URI characters are $(B ;/?:@&amp;=+$,)\n Escape sequences consist of $(B %) followed by two hex digits.\n\n See_Also:\n  $(LINK2 http://www.ietf.org/rfc/rfc3986.txt, RFC 3986)<br>\n  $(LINK2 http://en.wikipedia.org/wiki/Uniform_resource_identifier, Wikipedia)\n Macros:\n  WIKI = Phobos/StdUri\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_uri.d)\n \n",
  "members" : [
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 33,
    "protection" : "private"
   },
   {
    "name" : "std.c.stdlib",
    "kind" : "import",
    "line" : 34,
    "protection" : "private"
   },
   {
    "name" : "std.utf",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 37,
    "protection" : "private"
   },
   {
    "name" : "URIerror",
    "kind" : "class",
    "line" : 39,
    "base" : "Error",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 41,
      "deco" : "FZC3std3uri8URIerror",
      "originalType" : "()",
      "endline" : 44
     }
    ]
   },
   {
    "name" : "URI_Alpha",
    "kind" : "enum member",
    "line" : 49
   },
   {
    "name" : "URI_Reserved",
    "kind" : "enum member",
    "line" : 50
   },
   {
    "name" : "URI_Mark",
    "kind" : "enum member",
    "line" : 51
   },
   {
    "name" : "URI_Digit",
    "kind" : "enum member",
    "line" : 52
   },
   {
    "name" : "URI_Hash",
    "kind" : "enum member",
    "line" : 53
   },
   {
    "name" : "hex2ascii",
    "kind" : "variable",
    "line" : 56,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yG16a",
    "originalType" : "char[16]",
    "init" : "\"0123456789ABCDEF\""
   },
   {
    "name" : "uri_flags",
    "kind" : "variable",
    "line" : 58,
    "storageClass" : [
     "__gshared"
    ],
    "deco" : "G128h",
    "originalType" : "ubyte[128]"
   },
   {
    "name" : "_sharedStaticCtor28",
    "kind" : "function",
    "line" : 60,
    "storageClass" : [
     "static"
    ],
    "deco" : "FZv",
    "endline" : 80
   },
   {
    "name" : "URI_Encode",
    "kind" : "function",
    "protection" : "private",
    "line" : 83,
    "deco" : "FAywkZAya",
    "originalType" : "string(dstring string, uint unescapedSet)",
    "parameters" : [
     {
      "name" : "string",
      "deco" : "Ayw"
     },
     {
      "name" : "unescapedSet",
      "deco" : "k"
     }
    ],
    "endline" : 213
   },
   {
    "name" : "ascii2hex",
    "kind" : "function",
    "line" : 215,
    "deco" : "FwZk",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 220
   },
   {
    "name" : "URI_Decode",
    "kind" : "function",
    "protection" : "private",
    "line" : 222,
    "deco" : "FAyakZAyw",
    "originalType" : "dstring(string string, uint reservedSet)",
    "parameters" : [
     {
      "name" : "string",
      "deco" : "Aya"
     },
     {
      "name" : "reservedSet",
      "deco" : "k"
     }
    ],
    "endline" : 329
   },
   {
    "name" : "decode",
    "kind" : "function",
    "comment" : "\n Decodes the URI string encodedURI into a UTF-8 string and returns it.\n Escape sequences that resolve to reserved URI characters are not replaced.\n Escape sequences that resolve to the '#' character are not replaced.\n \n",
    "line" : 337,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "encodedURI",
      "deco" : "Aya"
     }
    ],
    "endline" : 341
   },
   {
    "name" : "decodeComponent",
    "kind" : "function",
    "comment" : "\n Decodes the URI string encodedURI into a UTF-8 string and returns it. All\n escape sequences are decoded.\n \n",
    "line" : 348,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "encodedURIComponent",
      "deco" : "Aya"
     }
    ],
    "endline" : 352
   },
   {
    "name" : "encode",
    "kind" : "function",
    "comment" : "\n Encodes the UTF-8 string uri into a URI and returns that URI. Any character\n not a valid URI character is escaped. The '#' character is not escaped.\n \n",
    "line" : 359,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "uri",
      "deco" : "Aya"
     }
    ],
    "endline" : 363
   },
   {
    "name" : "encodeComponent",
    "kind" : "function",
    "comment" : "\n Encodes the UTF-8 string uriComponent into a URI and returns that URI.\n Any character not a letter, digit, or one of -_.!~*'() is escaped.\n \n",
    "line" : 370,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "uriComponent",
      "deco" : "Aya"
     }
    ],
    "endline" : 374
   },
   {
    "name" : "uriLength",
    "kind" : "function",
    "comment" : "\n Does string s[] start with a URL?\n Returns:\n  -1    it does not\n  len  it does, and s[0..len] is the slice of s[] that is that URL\n \n",
    "line" : 383,
    "deco" : "FAyaZm",
    "originalType" : "size_t(string s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     }
    ],
    "endline" : 432
   },
   {
    "name" : "emailLength",
    "kind" : "function",
    "comment" : "\n Does string s[] start with an email address?\n Returns:\n  -1    it does not\n  len   it does, and s[0..i] is the slice of s[] that is that email address\n References:\n  RFC2822\n \n",
    "line" : 442,
    "deco" : "FAyaZm",
    "originalType" : "size_t(string s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     }
    ],
    "endline" : 488
   },
   {
    "name" : "__unittestL491_1915",
    "kind" : "function",
    "line" : 491,
    "endline" : 521
   }
  ]
 },
 {
  "name" : "std.utf",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/utf.d",
  "comment" : "\n    Encode and decode UTF-8, UTF-16 and UTF-32 strings.\n\n    UTF character support is restricted to\n    $(D '\\u0000' &lt;= character &lt;= '\\U0010FFFF').\n\n    See_Also:\n        $(LINK2 http://en.wikipedia.org/wiki/Unicode, Wikipedia)<br>\n        $(LINK http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8)<br>\n        $(LINK http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335)\n    Macros:\n        WIKI = Phobos/StdUtf\n\n    Copyright: Copyright Digital Mars 2000 - 2012.\n    License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    Authors:   $(WEB digitalmars.com, Walter Bright) and Jonathan M Davis\n    Source:    $(PHOBOSSRC std/_utf.d)\n   \n",
  "members" : [
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 23,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 24,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 25,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 27,
    "protection" : "private"
   },
   {
    "name" : "UTFException",
    "kind" : "class",
    "comment" : "\n    Exception thrown on errors in std.utf functions.\n  \n",
    "line" : 43,
    "base" : "Exception",
    "members" : [
     {
      "name" : "sequence",
      "kind" : "variable",
      "line" : 45,
      "deco" : "G4k",
      "originalType" : "uint[4]",
      "offset" : 72
     },
     {
      "name" : "len",
      "kind" : "variable",
      "line" : 46,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 88
     },
     {
      "name" : "setSequence",
      "kind" : "function",
      "line" : 49,
      "deco" : "FNaNbNfAkXC3std3utf12UTFException",
      "parameters" : [
       {
        "name" : "data",
        "deco" : "Ak"
       }
      ],
      "endline" : 59
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 62,
      "deco" : "FAyaAyamC6object9ThrowableZC3std3utf12UTFException",
      "originalType" : "(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 65
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 68,
      "deco" : "FAyamAyamC6object9ThrowableZC3std3utf12UTFException",
      "originalType" : "(string msg, size_t index, string file = __FILE__, size_t line = __LINE__, Throwable next = null)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "index",
        "deco" : "m"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       }
      ],
      "endline" : 72
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 75,
      "storageClass" : [
       "override"
      ],
      "deco" : "FZAya",
      "endline" : 93,
      "overrides" : [
       "object.Throwable.toString"
      ]
     }
    ]
   },
   {
    "name" : "UtfException",
    "kind" : "alias",
    "line" : 98,
    "storageClass" : [
     "deprecated"
    ],
    "deco" : "C3std3utf12UTFException"
   },
   {
    "name" : "isValidDchar",
    "kind" : "function",
    "comment" : "\n    Returns whether $(D c) is a valid UTF-32 character.\n\n    $(D '\\uFFFE') and $(D '\\uFFFF') are considered valid by $(D isValidDchar),\n    as they are permitted for internal use by an application, but they are\n    not allowed for interchange by the Unicode standard.\n  \n",
    "line" : 109,
    "storageClass" : [
     "nothrow",
     "pure",
     "@safe"
    ],
    "deco" : "FNaNbNfwZb",
    "originalType" : "bool(dchar c)",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 119
   },
   {
    "name" : "__unittestL121_1916",
    "kind" : "function",
    "line" : 121,
    "endline" : 162
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D stride) returns the length of the UTF-8 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-8 strings and ranges of $(D char). If no\n    index is passed, then an input range will work, but if an index is passed,\n    then a random-access range is required.\n\n    $(D index) defaults to $(D 0) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF-8 sequence.\n\n    Notes:\n        $(D stride) will only analize the first $(D str[index]) element. It\n        will not fully verify the validity of UTF-8 sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n  \n",
    "line" : 162,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "comment" : "\n    $(D stride) returns the length of the UTF-8 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-8 strings and ranges of $(D char). If no\n    index is passed, then an input range will work, but if an index is passed,\n    then a random-access range is required.\n\n    $(D index) defaults to $(D 0) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF-8 sequence.\n\n    Notes:\n        $(D stride) will only analize the first $(D str[index]) element. It\n        will not fully verify the validity of UTF-8 sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n  \n",
      "line" : 162,
      "type" : "uint(auto ref S str, size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 174
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 177,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 177,
      "type" : "uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 190
     }
    ]
   },
   {
    "name" : "strideImpl",
    "kind" : "function",
    "protection" : "private",
    "line" : 192,
    "deco" : "FNaNeamZk",
    "originalType" : "pure @trusted uint(char c, size_t index)",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "a"
     },
     {
      "name" : "index",
      "deco" : "m"
     }
    ],
    "endline" : 201
   },
   {
    "name" : "__unittestL203_1921",
    "kind" : "function",
    "line" : 203,
    "endline" : 286
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D strideBack) returns the length of the UTF-8 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-8 strings and bidirectional ranges of\n    $(D char). If no index is passed, then a bidirectional range will work, but\n    if an index is passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF-8 sequence.\n\n    Notes:\n        $(D strideBack) will not fully verify the validity of the UTF-8\n        sequence. It will, however, guarantee that\n        $(D index - stride(str, index)) is a valid index.\n  \n",
    "line" : 286,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "comment" : "\n    $(D strideBack) returns the length of the UTF-8 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-8 strings and bidirectional ranges of\n    $(D char). If no index is passed, then a bidirectional range will work, but\n    if an index is passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-8 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF-8 sequence.\n\n    Notes:\n        $(D strideBack) will not fully verify the validity of the UTF-8\n        sequence. It will, however, guarantee that\n        $(D index - stride(str, index)) is a valid index.\n  \n",
      "line" : 286,
      "type" : "uint(auto ref S str, size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 314
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 317,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 317,
      "type" : "uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 322
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 324,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "line" : 324,
      "type" : "uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 336
     }
    ]
   },
   {
    "name" : "__unittestL338_1926",
    "kind" : "function",
    "line" : 338,
    "endline" : 422
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D stride) returns the length of the UTF-16 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-16 strings and ranges of $(D wchar). If no\n    index is passed, then an input range will work, but if an index is passed,\n    then a random-access range is required.\n\n    $(D index) defaults to $(D 0) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF-16 sequence.\n\n    Notes:\n        $(D stride) will only analize the first $(D str[index]) element. It\n        will not fully verify the validity of UTF-16 sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n  \n",
    "line" : 422,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "comment" : "\n    $(D stride) returns the length of the UTF-16 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-16 strings and ranges of $(D wchar). If no\n    index is passed, then an input range will work, but if an index is passed,\n    then a random-access range is required.\n\n    $(D index) defaults to $(D 0) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not the start of a\n        valid UTF-16 sequence.\n\n    Notes:\n        $(D stride) will only analize the first $(D str[index]) element. It\n        will not fully verify the validity of UTF-16 sequence, nor even verify\n        the presence of the sequence: it will not actually guarantee that\n        $(D index + stride(str, index) <= str.length).\n  \n",
      "line" : 422,
      "type" : "uint(auto ref S str, size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 430
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 433,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 433,
      "type" : "pure @safe uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 437
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 439,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "line" : 439,
      "type" : "uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 445
     }
    ]
   },
   {
    "name" : "__unittestL447_1931",
    "kind" : "function",
    "line" : 447,
    "endline" : 533
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D strideBack) returns the length of the UTF-16 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-16 strings and ranges of $(D wchar). If\n    no index is passed, then a bidirectional range will work, but if an index is\n    passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF-16 sequence.\n\n    Notes:\n        $(D stride) will only analize the element at $(D str[index - 1])\n        element. It will not fully verify the validity of UTF-16 sequence, nor\n        even verify the presence of the sequence: it will not actually\n        guarantee that $(D stride(str, index) <= index).\n  \n",
    "line" : 533,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "comment" : "\n    $(D strideBack) returns the length of the UTF-16 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-16 strings and ranges of $(D wchar). If\n    no index is passed, then a bidirectional range will work, but if an index is\n    passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-16 sequence.\n\n    Throws:\n        May throw a $(D UTFException) if $(D str[index]) is not one past the\n        end of a valid UTF-16 sequence.\n\n    Notes:\n        $(D stride) will only analize the element at $(D str[index - 1])\n        element. It will not fully verify the validity of UTF-16 sequence, nor\n        even verify the presence of the sequence: it will not actually\n        guarantee that $(D stride(str, index) <= index).\n  \n",
      "line" : 533,
      "type" : "uint(auto ref S str, size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 543
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 546,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 546,
      "type" : "uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 558
     }
    ]
   },
   {
    "name" : "__unittestL560_1936",
    "kind" : "function",
    "line" : 560,
    "endline" : 633
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D stride) returns the length of the UTF-32 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-32 strings and ranges of $(D dchar).\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n\n    Throws:\n        Never.\n  \n",
    "line" : 633,
    "name" : "stride",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "stride",
      "kind" : "function",
      "comment" : "\n    $(D stride) returns the length of the UTF-32 sequence starting at $(D index)\n    in $(D str).\n\n    $(D stride) works with both UTF-32 strings and ranges of $(D dchar).\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n\n    Throws:\n        Never.\n  \n",
      "line" : 633,
      "type" : "uint(auto ref S str, size_t index = 0)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "default" : "0"
       }
      ],
      "endline" : 642
     }
    ]
   },
   {
    "name" : "__unittestL644_1941",
    "kind" : "function",
    "line" : 644,
    "endline" : 721
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D strideBack) returns the length of the UTF-32 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-32 strings and ranges of $(D dchar). If\n    no index is passed, then a bidirectional range will work, but if an index is\n    passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n\n    Throws:\n        Never.\n  \n",
    "line" : 721,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "comment" : "\n    $(D strideBack) returns the length of the UTF-32 sequence ending one code\n    unit before $(D index) in $(D str).\n\n    $(D strideBack) works with both UTF-32 strings and ranges of $(D dchar). If\n    no index is passed, then a bidirectional range will work, but if an index is\n    passed, then a random-access range is required.\n\n    $(D index) defaults to $(D str.length) if none is passed.\n\n    Returns:\n        The number of bytes in the UTF-32 sequence (always $(D 1)).\n\n    Throws:\n        Never.\n  \n",
      "line" : 721,
      "type" : "uint(auto ref S str, size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 728
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto\n",
    "line" : 731,
    "name" : "strideBack",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "strideBack",
      "kind" : "function",
      "comment" : " Ditto\n",
      "line" : 731,
      "type" : "uint(auto ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       }
      ],
      "endline" : 736
     }
    ]
   },
   {
    "name" : "__unittestL738_1946",
    "kind" : "function",
    "line" : 738,
    "endline" : 821
   },
   {
    "kind" : "template",
    "comment" : "\n    Given $(D index) into $(D str) and assuming that $(D index) is at the start\n    of a UTF sequence, $(D toUCSindex) determines the number of UCS characters\n    up to $(D index). So, $(D index) is the index of a code unit at the\n    beginning of a code point, and the return value is how many code points into\n    the string that that code point is.\n\nExamples:\n--------------------\nassert(toUCSindex(`hello world`, 7) == 7);\nassert(toUCSindex(`hello world`w, 7) == 7);\nassert(toUCSindex(`hello world`d, 7) == 7);\n\nassert(toUCSindex(`Ma Chérie`, 7) == 6);\nassert(toUCSindex(`Ma Chérie`w, 7) == 7);\nassert(toUCSindex(`Ma Chérie`d, 7) == 7);\n\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`, 9) == 3);\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`w, 9) == 9);\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`d, 9) == 9);\n--------------------\n  \n",
    "line" : 821,
    "name" : "toUCSindex",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUCSindex",
      "kind" : "function",
      "comment" : "\n    Given $(D index) into $(D str) and assuming that $(D index) is at the start\n    of a UTF sequence, $(D toUCSindex) determines the number of UCS characters\n    up to $(D index). So, $(D index) is the index of a code unit at the\n    beginning of a code point, and the return value is how many code points into\n    the string that that code point is.\n\nExamples:\n--------------------\nassert(toUCSindex(`hello world`, 7) == 7);\nassert(toUCSindex(`hello world`w, 7) == 7);\nassert(toUCSindex(`hello world`d, 7) == 7);\n\nassert(toUCSindex(`Ma Chérie`, 7) == 6);\nassert(toUCSindex(`Ma Chérie`w, 7) == 7);\nassert(toUCSindex(`Ma Chérie`d, 7) == 7);\n\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`, 9) == 3);\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`w, 9) == 9);\nassert(toUCSindex(`さいごの果実 / ミツバチと科学者`d, 9) == 9);\n--------------------\n  \n",
      "line" : 821,
      "type" : "pure @safe size_t(const(C)[] str, size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "const(C)[]"
       },
       {
        "name" : "index",
        "type" : "size_t"
       }
      ],
      "endline" : 844
     }
    ]
   },
   {
    "name" : "__unittestL846_1947",
    "kind" : "function",
    "line" : 846,
    "endline" : 882
   },
   {
    "name" : "toUTFindex",
    "kind" : "function",
    "comment" : "\n    Given a UCS index $(D n) into $(D str), returns the UTF index.\n    So, $(D n) is how many code points into the string the code point is, and\n    the array index of the code unit is returned.\n\nExamples:\n--------------------\nassert(toUTFindex(`hello world`, 7) == 7);\nassert(toUTFindex(`hello world`w, 7) == 7);\nassert(toUTFindex(`hello world`d, 7) == 7);\n\nassert(toUTFindex(`Ma Chérie`, 6) == 7);\nassert(toUTFindex(`Ma Chérie`w, 7) == 7);\nassert(toUTFindex(`Ma Chérie`d, 7) == 7);\n\nassert(toUTFindex(`さいごの果実 / ミツバチと科学者`, 3) == 9);\nassert(toUTFindex(`さいごの果実 / ミツバチと科学者`w, 9) == 9);\nassert(toUTFindex(`さいごの果実 / ミツバチと科学者`d, 9) == 9);\n--------------------\n  \n",
    "line" : 882,
    "deco" : "FNaNfxAamZm",
    "originalType" : "pure @safe size_t(in char[] str, size_t n)",
    "parameters" : [
     {
      "name" : "str",
      "deco" : "xAa"
     },
     {
      "name" : "n",
      "deco" : "m"
     }
    ],
    "endline" : 888
   },
   {
    "name" : "toUTFindex",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 891,
    "deco" : "FNaNbNfxAumZm",
    "originalType" : "pure nothrow @safe size_t(in wchar[] str, size_t n)",
    "parameters" : [
     {
      "name" : "str",
      "deco" : "xAu"
     },
     {
      "name" : "n",
      "deco" : "m"
     }
    ],
    "endline" : 903
   },
   {
    "name" : "toUTFindex",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 906,
    "deco" : "FNaNbNfxAwmZm",
    "originalType" : "pure nothrow @safe size_t(in dchar[] str, size_t n)",
    "parameters" : [
     {
      "name" : "str",
      "deco" : "xAw"
     },
     {
      "name" : "n",
      "deco" : "m"
     }
    ],
    "endline" : 909
   },
   {
    "kind" : "template",
    "comment" : "\n    Decodes and returns the code point starting at $(D str[index]). $(D index)\n    is advanced to one past the decoded code point. If the code point is not\n    well-formed, then a $(D UTFException) is thrown and $(D index) remains\n    unchanged.\n\n    decode will only work with strings and random access ranges of code units\n    with length and slicing, whereas $(LREF decodeFront) will work with any\n    input range of code units.\n\n    Throws:\n        $(LREF UTFException) if $(D str[index]) is not the start of a valid UTF\n        sequence.\n  \n",
    "line" : 928,
    "name" : "decode",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decode",
      "kind" : "function",
      "comment" : "\n    Decodes and returns the code point starting at $(D str[index]). $(D index)\n    is advanced to one past the decoded code point. If the code point is not\n    well-formed, then a $(D UTFException) is thrown and $(D index) remains\n    unchanged.\n\n    decode will only work with strings and random access ranges of code units\n    with length and slicing, whereas $(LREF decodeFront) will work with any\n    input range of code units.\n\n    Throws:\n        $(LREF UTFException) if $(D str[index]) is not the start of a valid UTF\n        sequence.\n  \n",
      "line" : 928,
      "type" : "dchar(auto ref S str, ref size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 944
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 946,
    "name" : "decode",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decode",
      "kind" : "function",
      "line" : 946,
      "type" : "pure @trusted dchar(auto ref S str, ref size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 961
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D decodeFront) is a variant of $(LREF decode) which specifically decodes\n    the first code point. Unlike $(LREF decode), $(D decodeFront) accepts any\n    input range of code units (rather than just a string or random access\n    range). It also takes the range by $(D ref) and pops off the elements as it\n    decodes them. If $(D numCodeUnits) is passed in, it gets set to the number\n    of code units which were in the code point which was decoded.\n\n    Throws:\n        $(LREF UTFException) if $(D str.front) is not the start of a valid UTF\n        sequence. If an exception is thrown, then there is no guarantee as to\n        the number of code units which were popped off, as it depends on the\n        type of range being used and how many code units had to be popped off\n        before the code point was determined to be invalid.\n  \n",
    "line" : 978,
    "name" : "decodeFront",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeFront",
      "kind" : "function",
      "comment" : "\n    $(D decodeFront) is a variant of $(LREF decode) which specifically decodes\n    the first code point. Unlike $(LREF decode), $(D decodeFront) accepts any\n    input range of code units (rather than just a string or random access\n    range). It also takes the range by $(D ref) and pops off the elements as it\n    decodes them. If $(D numCodeUnits) is passed in, it gets set to the number\n    of code units which were in the code point which was decoded.\n\n    Throws:\n        $(LREF UTFException) if $(D str.front) is not the start of a valid UTF\n        sequence. If an exception is thrown, then there is no guarantee as to\n        the number of code units which were popped off, as it depends on the\n        type of range being used and how many code units had to be popped off\n        before the code point was determined to be invalid.\n  \n",
      "line" : 978,
      "type" : "dchar(ref S str, out size_t numCodeUnits)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "numCodeUnits",
        "type" : "size_t",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 1010
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 1012,
    "name" : "decodeFront",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeFront",
      "kind" : "function",
      "line" : 1012,
      "type" : "pure @trusted dchar(ref S str, out size_t numCodeUnits)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "numCodeUnits",
        "type" : "size_t",
        "storageClass" : [
         "out"
        ]
       }
      ],
      "endline" : 1035
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 1038,
    "name" : "decodeFront",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeFront",
      "kind" : "function",
      "comment" : " Ditto \n",
      "line" : 1038,
      "type" : "dchar(ref S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1043
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1046,
    "name" : "codeUnitLimit",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1063,
    "name" : "decodeImpl",
    "parameters" : [
     {
      "name" : "canIndex",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeImpl",
      "kind" : "function",
      "line" : 1063,
      "type" : "dchar(auto ref S str, ref size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1196
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1198,
    "name" : "decodeImpl",
    "parameters" : [
     {
      "name" : "canIndex",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeImpl",
      "kind" : "function",
      "line" : 1198,
      "type" : "dchar(auto ref S str, ref size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1266
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1268,
    "name" : "decodeImpl",
    "parameters" : [
     {
      "name" : "canIndex",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "decodeImpl",
      "kind" : "function",
      "line" : 1268,
      "type" : "dchar(auto ref S str, ref size_t index)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "auto",
         "ref"
        ]
       },
       {
        "name" : "index",
        "type" : "size_t",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1291
     }
    ]
   },
   {
    "name" : "__unittestL1373_1950",
    "kind" : "function",
    "line" : 1373,
    "endline" : 1431
   },
   {
    "name" : "__unittestL1431_1954",
    "kind" : "function",
    "line" : 1431,
    "endline" : 1468
   },
   {
    "name" : "__unittestL1468_1958",
    "kind" : "function",
    "line" : 1468,
    "endline" : 1504
   },
   {
    "name" : "__unittestL1504_1965",
    "kind" : "function",
    "line" : 1504,
    "endline" : 1532
   },
   {
    "name" : "encode",
    "kind" : "function",
    "comment" : "\n    Encodes $(D c) into the static array, $(D buf), and returns the actual\n    length of the encoded character (a number between $(D 1) and $(D 4) for\n    $(D char[4]) buffers and a number between $(D 1) and $(D 2) for\n    $(D wchar[2]) buffers).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n  \n",
    "line" : 1532,
    "deco" : "FNaNfKG4awZm",
    "originalType" : "pure @safe size_t(ref char[4] buf, dchar c)",
    "parameters" : [
     {
      "name" : "buf",
      "deco" : "G4a",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1570
   },
   {
    "name" : "__unittestL1572_1966",
    "kind" : "function",
    "line" : 1572,
    "endline" : 1597
   },
   {
    "name" : "encode",
    "kind" : "function",
    "comment" : " Ditto\n",
    "line" : 1597,
    "deco" : "FNaNfKG2uwZm",
    "originalType" : "pure @safe size_t(ref wchar[2] buf, dchar c)",
    "parameters" : [
     {
      "name" : "buf",
      "deco" : "G2u",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1618
   },
   {
    "name" : "__unittestL1620_1967",
    "kind" : "function",
    "line" : 1620,
    "endline" : 1646
   },
   {
    "name" : "encode",
    "kind" : "function",
    "comment" : "\n    Encodes $(D c) in $(D str)'s encoding and appends it to $(D str).\n\n    Throws:\n        $(D UTFException) if $(D c) is not a valid UTF code point.\n  \n",
    "line" : 1646,
    "deco" : "FNaNfKAawZv",
    "parameters" : [
     {
      "name" : "str",
      "deco" : "Aa",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1695
   },
   {
    "name" : "__unittestL1697_1968",
    "kind" : "function",
    "line" : 1697,
    "endline" : 1716
   },
   {
    "name" : "__unittestL1716_1969",
    "kind" : "function",
    "line" : 1716,
    "endline" : 1740
   },
   {
    "name" : "encode",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1740,
    "deco" : "FNaNfKAuwZv",
    "parameters" : [
     {
      "name" : "str",
      "deco" : "Au",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1768
   },
   {
    "name" : "__unittestL1770_1970",
    "kind" : "function",
    "line" : 1770,
    "endline" : 1790
   },
   {
    "name" : "encode",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 1790,
    "deco" : "FNaNfKAwwZv",
    "parameters" : [
     {
      "name" : "str",
      "deco" : "Aw",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 1797
   },
   {
    "name" : "__unittestL1799_1971",
    "kind" : "function",
    "line" : 1799,
    "endline" : 1833
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the number of code units that are required to encode the code point\n    $(D c) when $(D C) is the character type used to encode it.\n\nExamples:\n------\nassert(codeLength!char('a') == 1);\nassert(codeLength!wchar('a') == 1);\nassert(codeLength!dchar('a') == 1);\n\nassert(codeLength!char('\\U0010FFFF') == 4);\nassert(codeLength!wchar('\\U0010FFFF') == 2);\nassert(codeLength!dchar('\\U0010FFFF') == 1);\n------\n  \n",
    "line" : 1833,
    "name" : "codeLength",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "codeLength",
      "kind" : "function",
      "comment" : "\n    Returns the number of code units that are required to encode the code point\n    $(D c) when $(D C) is the character type used to encode it.\n\nExamples:\n------\nassert(codeLength!char('a') == 1);\nassert(codeLength!wchar('a') == 1);\nassert(codeLength!dchar('a') == 1);\n\nassert(codeLength!char('\\U0010FFFF') == 4);\nassert(codeLength!wchar('\\U0010FFFF') == 2);\nassert(codeLength!dchar('\\U0010FFFF') == 1);\n------\n  \n",
      "line" : 1833,
      "type" : "pure nothrow @safe ubyte(dchar c)",
      "parameters" : [
       {
        "name" : "c",
        "deco" : "w"
       }
      ],
      "endline" : 1854
     }
    ]
   },
   {
    "name" : "__unittestL1857_1972",
    "kind" : "function",
    "line" : 1857,
    "endline" : 1897
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the number of code units that are required to encode $(D str)\n    in a string whose character type is $(D C). This is particularly useful\n    when slicing one string with the length of another and the two string\n    types use different character types.\n\nExamples:\n------\nassert(codeLength!char(\"hello world\") ==\n       to!string(\"hello world\").length);\nassert(codeLength!wchar(\"hello world\") ==\n       to!wstring(\"hello world\").length);\nassert(codeLength!dchar(\"hello world\") ==\n       to!dstring(\"hello world\").length);\n\nassert(codeLength!char(`プログラミング`) ==\n       to!string(`プログラミング`).length);\nassert(codeLength!wchar(`プログラミング`) ==\n       to!wstring(`プログラミング`).length);\nassert(codeLength!dchar(`プログラミング`) ==\n       to!dstring(`プログラミング`).length);\n\nstring haystack = `Être sans la verité, ça, ce ne serait pas bien.`;\nwstring needle = `Être sans la verité`;\nassert(haystack[codeLength!char(needle) .. $] ==\n       `, ça, ce ne serait pas bien.`);\n------\n  \n",
    "line" : 1897,
    "name" : "codeLength",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     },
     {
      "name" : "InputRange",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "codeLength",
      "kind" : "function",
      "comment" : "\n    Returns the number of code units that are required to encode $(D str)\n    in a string whose character type is $(D C). This is particularly useful\n    when slicing one string with the length of another and the two string\n    types use different character types.\n\nExamples:\n------\nassert(codeLength!char(\"hello world\") ==\n       to!string(\"hello world\").length);\nassert(codeLength!wchar(\"hello world\") ==\n       to!wstring(\"hello world\").length);\nassert(codeLength!dchar(\"hello world\") ==\n       to!dstring(\"hello world\").length);\n\nassert(codeLength!char(`プログラミング`) ==\n       to!string(`プログラミング`).length);\nassert(codeLength!wchar(`プログラミング`) ==\n       to!wstring(`プログラミング`).length);\nassert(codeLength!dchar(`プログラミング`) ==\n       to!dstring(`プログラミング`).length);\n\nstring haystack = `Être sans la verité, ça, ce ne serait pas bien.`;\nwstring needle = `Être sans la verité`;\nassert(haystack[codeLength!char(needle) .. $] ==\n       `, ça, ce ne serait pas bien.`);\n------\n  \n",
      "line" : 1897,
      "type" : "size_t(InputRange input)",
      "parameters" : [
       {
        "name" : "input",
        "type" : "InputRange"
       }
      ],
      "endline" : 1912
     }
    ]
   },
   {
    "name" : "__unittestL1916_1973",
    "kind" : "function",
    "line" : 1916,
    "endline" : 1938
   },
   {
    "name" : "__unittestL1938_1976",
    "kind" : "function",
    "line" : 1938,
    "endline" : 1965
   },
   {
    "kind" : "template",
    "comment" : "\n    Checks to see if $(D str) is well-formed unicode or not.\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
    "line" : 1965,
    "name" : "validate",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "validate",
      "kind" : "function",
      "comment" : "\n    Checks to see if $(D str) is well-formed unicode or not.\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
      "line" : 1965,
      "type" : "pure @safe void(in S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S",
        "storageClass" : [
         "in"
        ]
       }
      ],
      "endline" : 1973
     }
    ]
   },
   {
    "name" : "toUTF8",
    "kind" : "function",
    "line" : 1981,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNbNfJG4awZAa",
    "originalType" : "nothrow @safe char[](out char[4] buf, dchar c)",
    "parameters" : [
     {
      "name" : "buf",
      "deco" : "G4a",
      "storageClass" : [
       "out"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 2016
   },
   {
    "name" : "toUTF8",
    "kind" : "function",
    "comment" : "\n Encodes string $(D_PARAM s) into UTF-8 and returns the encoded string.\n \n",
    "line" : 2022,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNfxAaZAya",
    "originalType" : "@safe string(in char[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAa"
     }
    ],
    "endline" : 2026
   },
   {
    "name" : "toUTF8",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2029,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNexAuZAya",
    "originalType" : "@trusted string(in wchar[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAu"
     }
    ],
    "endline" : 2052
   },
   {
    "name" : "toUTF8",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2055,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNexAwZAya",
    "originalType" : "@trusted string(in dchar[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAw"
     }
    ],
    "endline" : 2080
   },
   {
    "name" : "toUTF16",
    "kind" : "function",
    "line" : 2085,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNbNfKG2uwZAu",
    "originalType" : "nothrow @safe wchar[](ref wchar[2] buf, dchar c)",
    "parameters" : [
     {
      "name" : "buf",
      "deco" : "G2u",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 2103
   },
   {
    "name" : "toUTF16",
    "kind" : "function",
    "comment" : "\n Encodes string $(D s) into UTF-16 and returns the encoded string.\n \n",
    "line" : 2108,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNexAaZAyu",
    "originalType" : "@trusted wstring(in char[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAa"
     }
    ],
    "endline" : 2131
   },
   {
    "name" : "toUTF16",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2134,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNfxAuZAyu",
    "originalType" : "@safe wstring(in wchar[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAu"
     }
    ],
    "endline" : 2138
   },
   {
    "name" : "toUTF16",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2141,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNexAwZAyu",
    "originalType" : "@trusted wstring(in dchar[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAw"
     }
    ],
    "endline" : 2154
   },
   {
    "name" : "toUTF32",
    "kind" : "function",
    "comment" : "\n Encodes string $(D_PARAM s) into UTF-32 and returns the encoded string.\n \n",
    "line" : 2162,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNexAaZAyw",
    "originalType" : "@trusted dstring(in char[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAa"
     }
    ],
    "endline" : 2180
   },
   {
    "name" : "toUTF32",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2183,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNexAuZAyw",
    "originalType" : "@trusted dstring(in wchar[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAu"
     }
    ],
    "endline" : 2201
   },
   {
    "name" : "toUTF32",
    "kind" : "function",
    "comment" : " ditto\n",
    "line" : 2204,
    "storageClass" : [
     "pure"
    ],
    "deco" : "FNaNfxAwZAyw",
    "originalType" : "@safe dstring(in dchar[] s)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "xAw"
     }
    ],
    "endline" : 2208
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns a C-style zero-terminated string equivalent to $(D str). $(D str)\n    must not contain embedded $(D '\\0')'s as any C function will treat the first\n    $(D '\\0') that it sees as the end of the string. If $(D str.empty) is\n    $(D true), then a string containing only $(D '\\0') is returned.\n\n    $(D toUTFz) accepts any type of string and is templated on the type of\n    character pointer that you wish to convert to. It will avoid allocating a\n    new string if it can, but there's a decent chance that it will end up having\n    to allocate a new string - particularly when dealing with character types\n    other than $(D char).\n\n    $(RED Warning 1:) If the result of $(D toUTFz) equals $(D str.ptr), then if\n    anything alters the character one past the end of $(D str) (which is the\n    $(D '\\0') character terminating the string), then the string won't be\n    zero-terminated anymore. The most likely scenarios for that are if you\n    append to $(D str) and no reallocation takes place or when $(D str) is a\n    slice of a larger array, and you alter the character in the larger array\n    which is one character past the end of $(D str). Another case where it could\n    occur would be if you had a mutable character array immediately after\n    $(D str) in memory (for example, if they're member variables in a\n    user-defined type with one declared right after the other) and that\n    character array happened to start with $(D '\\0'). Such scenarios will never\n    occur if you immediately use the zero-terminated string after calling\n    $(D toUTFz) and the C function using it doesn't keep a reference to it.\n    Also, they are unlikely to occur even if you save the zero-terminated string\n    (the cases above would be among the few examples of where it could happen).\n    However, if you save the zero-terminate string and want to be absolutely\n    certain that the string stays zero-terminated, then simply append a\n    $(D '\\0') to the string and use its $(D ptr) property rather than calling\n    $(D toUTFz).\n\n    $(RED Warning 2:) When passing a character pointer to a C function, and the\n    C function keeps it around for any reason, make sure that you keep a\n    reference to it in your D code. Otherwise, it may go away during a garbage\n    collection cycle and cause a nasty bug when the C code tries to use it.\n\n    Examples:\n--------------------\nauto p1 = toUTFz!(char*)(\"hello world\");\nauto p2 = toUTFz!(const(char)*)(\"hello world\");\nauto p3 = toUTFz!(immutable(char)*)(\"hello world\");\nauto p4 = toUTFz!(char*)(\"hello world\"d);\nauto p5 = toUTFz!(const(wchar)*)(\"hello world\");\nauto p6 = toUTFz!(immutable(dchar)*)(\"hello world\"w);\n--------------------\n  \n",
    "line" : 2262,
    "name" : "toUTFz",
    "parameters" : [
     {
      "name" : "P",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 2264,
      "name" : "toUTFz",
      "parameters" : [
       {
        "name" : "S",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "toUTFz",
        "kind" : "function",
        "line" : 2264,
        "type" : "@system P(S str)",
        "parameters" : [
         {
          "name" : "str",
          "type" : "S"
         }
        ],
        "endline" : 2267
       }
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : " Ditto \n",
    "line" : 2271,
    "name" : "toUTFz",
    "parameters" : [
     {
      "name" : "P",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUTFz",
      "kind" : "function",
      "line" : 2273,
      "type" : "@system P(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 2276
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2279,
    "name" : "toUTFzImpl",
    "parameters" : [
     {
      "name" : "P",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUTFzImpl",
      "kind" : "function",
      "line" : 2279,
      "type" : "@system P(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 2315
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2317,
    "name" : "toUTFzImpl",
    "parameters" : [
     {
      "name" : "P",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUTFzImpl",
      "kind" : "function",
      "line" : 2317,
      "type" : "@system P(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 2349
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2351,
    "name" : "toUTFzImpl",
    "parameters" : [
     {
      "name" : "P",
      "kind" : "type"
     },
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUTFzImpl",
      "kind" : "function",
      "line" : 2351,
      "type" : "P(S str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "S"
       }
      ],
      "endline" : 2363
     }
    ]
   },
   {
    "name" : "__unittestL2366_1977",
    "kind" : "function",
    "line" : 2366,
    "endline" : 2376
   },
   {
    "name" : "__unittestL2376_1978",
    "kind" : "function",
    "line" : 2376,
    "endline" : 2468
   },
   {
    "kind" : "template",
    "comment" : "\n    $(D toUTF16z) is a convenience function for $(D toUTFz!(const(wchar)*)).\n\n    Encodes string $(D s) into UTF-16 and returns the encoded string.\n    $(D toUTF16z) is suitable for calling the 'W' functions in the Win32 API\n    that take an $(D LPWSTR) or $(D LPCWSTR) argument.\n  \n",
    "line" : 2468,
    "name" : "toUTF16z",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toUTF16z",
      "kind" : "function",
      "comment" : "\n    $(D toUTF16z) is a convenience function for $(D toUTFz!(const(wchar)*)).\n\n    Encodes string $(D s) into UTF-16 and returns the encoded string.\n    $(D toUTF16z) is suitable for calling the 'W' functions in the Win32 API\n    that take an $(D LPWSTR) or $(D LPCWSTR) argument.\n  \n",
      "line" : 2468,
      "type" : "const(wchar)*(const(C)[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "const(C)[]"
       }
      ],
      "endline" : 2472
     }
    ]
   },
   {
    "name" : "__unittestL2474_1979",
    "kind" : "function",
    "line" : 2474,
    "endline" : 2487
   },
   {
    "name" : "__unittestL2487_1980",
    "kind" : "function",
    "line" : 2487,
    "endline" : 2558
   },
   {
    "kind" : "template",
    "comment" : "\n    Returns the total number of code points encoded in $(D str).\n\n    Supercedes: This function supercedes $(LREF toUCSindex).\n\n    Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
    "line" : 2558,
    "name" : "count",
    "parameters" : [
     {
      "name" : "C",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "count",
      "kind" : "function",
      "comment" : "\n    Returns the total number of code points encoded in $(D str).\n\n    Supercedes: This function supercedes $(LREF toUCSindex).\n\n    Standards: Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252\n\n    Throws:\n        $(D UTFException) if $(D str) is not well-formed.\n  \n",
      "line" : 2558,
      "type" : "pure @trusted size_t(const(C)[] str)",
      "parameters" : [
       {
        "name" : "str",
        "type" : "const(C)[]"
       }
      ],
      "endline" : 2562
     }
    ]
   },
   {
    "name" : "__unittestL2564_1981",
    "kind" : "function",
    "line" : 2564,
    "endline" : 2574
   }
  ]
 },
 {
  "name" : "std.uuid",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/uuid.d",
  "comment" : "\n<script type=\"text/javascript\">inhibitQuickIndex = 1</script>\n\n$(BOOKTABLE ,\n$(TR $(TH Category) $(TH Functions)\n)\n$(TR $(TDNW Parsing UUIDs) $(TD $(MYREF parseUUID) $(MYREF\nUUID(string)) $(MYREF UUIDParsingException) $(MYREF uuidRegex) )\n)\n$(TR $(TDNW Generating UUIDs) $(TD $(MYREF sha1UUID) $(MYREF randomUUID) $(MYREF\nmd5UUID))\n)\n$(TR $(TDNW Using UUIDs) $(TD $(MYREF2 UUID.uuidVersion, uuidVersion) $(MYREF2 UUID.variant, variant)\n$(MYREF2 UUID.toString, toString) $(MYREF2 UUID.data, data) $(MYREF2 UUID.swap, swap)\n$(MYREF2 UUID.opEquals, opEquals) $(MYREF2 UUID.opCmp, opCmp) $(MYREF2 UUID.toHash, toHash) )\n)\n$(TR $(TDNW UUID namespaces) $(TD $(MYREF dnsNamespace) $(MYREF urlNamespace)\n$(MYREF oidNamespace) $(MYREF x500Namespace) )\n)\n)\n\n A $(LINK2 http://en.wikipedia.org/wiki/Universally_unique_identifier, UUID), or\n $(LINK2 http://en.wikipedia.org/wiki/Universally_unique_identifier, Universally unique identifier),\n is intended to uniquely identify information in a distributed environment\n without significant central coordination. It can be\n used to tag objects with very short lifetimes, or to reliably identify very\n persistent objects across a network.\n\n UUIDs have many applications. Some examples follow: Databases may use UUIDs to identify\n rows or records in order to ensure that they are unique across different\n databases, or for publication/subscription services. Network messages may be\n identified with a UUID to ensure that different parts of a message are put back together\n again. Distributed computing may use UUIDs to identify a remote procedure call.\n Transactions and classes involved in serialization may be identified by UUIDs.\n Microsoft's component object model (COM) uses UUIDs to distinguish different software\n component interfaces. UUIDs are inserted into documents from Microsoft Office programs.\n UUIDs identify audio or video streams in the Advanced Systems Format (ASF). UUIDs are\n also a basis for OIDs (object identifiers), and URNs (uniform resource name).\n\n An attractive feature of UUIDs when compared to alternatives is their relative small size,\n of 128 bits, or 16 bytes. Another is that the creation of UUIDs does not require\n a centralized authority.\n\n When UUIDs are generated by one of the defined mechanisms, they are either guaranteed\n to be unique, different from all other generated UUIDs (that is, it has never been\n generated before and it will never be generated again), or it is extremely likely\n to be unique (depending on the mechanism).\n\n For efficiency, UUID is implemented as a struct. UUIDs are therefore empty if not explicitly\n initialized. An UUID is empty if $(MYREF3 UUID.empty, empty) is true. Empty UUIDs are equal to\n $(D UUID.init), which is a UUID with all 16 bytes set to 0.\n Use UUID's constructors or the UUID generator functions to get an initialized UUID.\n\n This is a port of $(LINK2 http://www.boost.org/doc/libs/1_42_0/libs/uuid/uuid.html,\n boost._uuid) from the Boost project with some minor additions and API\n changes for a more D-like API.\n\n Examples:\n ------------------------\n UUID[] ids;\n ids ~= randomUUID();\n ids ~= md5UUID(\"test.name.123\");\n ids ~= sha1UUID(\"test.name.123\");\n\n foreach(entry; ids)\n {\n     assert(entry.variant == UUID.Variant.rfc4122);\n }\n\n assert(ids[0].uuidVersion == UUID.Version.randomNumberBased);\n assert(ids[1].toString() == \"22390768-cced-325f-8f0f-cfeaa19d0ccd\");\n assert(ids[1].data == [34, 57, 7, 104, 204, 237, 50, 95, 143, 15, 207,\n     234, 161, 157, 12, 205]);\n\n UUID id;\n assert(id.empty);\n\n ------------------------\n Standards:\n $(LINK2 http://www.ietf.org/rfc/rfc4122.txt, RFC 4122)\n\n See_Also:\n $(LINK http://en.wikipedia.org/wiki/Universally_unique_identifier)\n\n Copyright: Copyright Johannes Pfau 2011 - .\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>\n Authors:   Johannes Pfau\n Source:    $(PHOBOSSRC std/_uuid.d)\n\n Macros:\n MYREF = <font face='Consolas, \"Bitstream Vera Sans Mono\", \"Andale Mono\", Monaco, \"DejaVu Sans Mono\", \"Lucida Console\", monospace'><a href=\"#$1\">$1</a>&nbsp;</font>\n MYREF2 = <font face='Consolas, \"Bitstream Vera Sans Mono\", \"Andale Mono\", Monaco, \"DejaVu Sans Mono\", \"Lucida Console\", monospace'><a href=\"#$2\">$1</a>&nbsp;</font>\n MYREF3 = <a href=\"#$2\">$(D $1)</a>\n \n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 102,
    "protection" : "private"
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 102,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 102,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.digest.md",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.digest.sha",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.random",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.range",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 103,
    "protection" : "private"
   },
   {
    "name" : "UUID",
    "kind" : "struct",
    "comment" : "\n\n \n",
    "line" : 109,
    "members" : [
     {
      "name" : "toChar",
      "kind" : "function",
      "protection" : "private",
      "line" : 111,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfmZa",
      "originalType" : "const char(size_t i)",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "m"
       }
      ],
      "endline" : 117
     },
     {
      "name" : "_toString",
      "kind" : "function",
      "protection" : "private",
      "line" : 119,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfZG36a",
      "originalType" : "const char[36]()",
      "endline" : 139
     },
     {
      "name" : "__unittestL141_1982",
      "kind" : "function",
      "protection" : "private",
      "line" : 141,
      "endline" : 148
     },
     {
      "name" : "Variant",
      "kind" : "enum",
      "comment" : "\n RFC 4122 defines different internal data layouts for UUIDs. These are\n the UUID formats supported by this module. It's\n possible to read, compare and use all these Variants, but\n UUIDs generated by this module will always be in rfc4122 format.\n\n Note: Do not confuse this with $(XREF _variant, _Variant). This has nothing\n to do with $(XREF _variant, _Variant).\n         \n",
      "line" : 159,
      "baseDeco" : "i",
      "members" : [
       {
        "name" : "ncs",
        "kind" : "enum member",
        "comment" : " NCS backward compatibility\n",
        "line" : 160
       },
       {
        "name" : "rfc4122",
        "kind" : "enum member",
        "comment" : " Defined in RFC 4122 document\n",
        "line" : 161
       },
       {
        "name" : "microsoft",
        "kind" : "enum member",
        "comment" : " Microsoft Corporation backward compatibility\n",
        "line" : 162
       },
       {
        "name" : "future",
        "kind" : "enum member",
        "comment" : "Reserved for future use\n",
        "line" : 163
       }
      ]
     },
     {
      "name" : "Version",
      "kind" : "enum",
      "comment" : "\n RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n\n Note:\n All of these UUID versions can be read and processed by\n $(D std.uuid), but only version 3, 4 and 5 UUIDs can be generated.\n         \n",
      "line" : 176,
      "baseDeco" : "i",
      "members" : [
       {
        "name" : "unknown",
        "kind" : "enum member",
        "comment" : "Unknown version\n",
        "line" : 178
       },
       {
        "name" : "timeBased",
        "kind" : "enum member",
        "comment" : "Version 1\n",
        "line" : 180
       },
       {
        "name" : "dceSecurity",
        "kind" : "enum member",
        "comment" : "Version 2\n",
        "line" : 182
       },
       {
        "name" : "nameBasedMD5",
        "kind" : "enum member",
        "comment" : "Version 3 (Name based + MD5)\n",
        "line" : 184
       },
       {
        "name" : "randomNumberBased",
        "kind" : "enum member",
        "comment" : "Version 4 (Random)\n",
        "line" : 186
       },
       {
        "name" : "nameBasedSHA1",
        "kind" : "enum member",
        "comment" : "Version 5 (Name based + SHA-1)\n",
        "line" : 188
       }
      ]
     },
     {
      "name" : "data",
      "kind" : "variable",
      "comment" : "\n It is sometimes useful to get or set the 16 bytes of a UUID\n directly.\n\n Note:\n UUID uses a 16-ubyte representation for the UUID data.\n RFC 4122 defines a UUID as a special structure in big-endian\n format. These 16-ubytes always equal the big-endian structure\n defined in RFC 4122.\n\n Examples:\n -----------------------------------------------\n auto rawData = uuid.data; //get data\n rawData[0] = 1; //modify\n uuid.data = rawData; //set data\n uuid.data[1] = 2; //modify directly\n -----------------------------------------------\n         \n",
      "line" : 209,
      "deco" : "G16h",
      "originalType" : "ubyte[16]",
      "offset" : 0
     },
     {
      "name" : "__unittestL218_1983",
      "kind" : "function",
      "line" : 218,
      "endline" : 245
     },
     {
      "kind" : "template",
      "comment" : "\n Construct a UUID struct from the 16 byte representation\n of a UUID.\n\n Examples:\n -------------------------\n ubyte[16] data = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];\n auto tmp = UUID(data);\n assert(tmp.data == data);\n -------------------------\n         \n",
      "line" : 245,
      "name" : "this",
      "parameters" : [],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 245,
        "type" : "(ubyte[16] uuidData)",
        "parameters" : [
         {
          "name" : "uuidData",
          "type" : "ubyte[16]"
         }
        ],
        "endline" : 248
       }
      ]
     },
     {
      "name" : "__unittestL250_1984",
      "kind" : "function",
      "line" : 250,
      "endline" : 336
     },
     {
      "kind" : "template",
      "comment" : "\n <a name=\"UUID(string)\"></a>\n Parse a UUID from its canonical string form. An UUID in its\n canonical form looks like this: 8ab3060e-2cba-4f23-b74c-b52db3bdfb46\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at\n compile time.\n\n Note:\n This is a strict parser. It only accepts the pattern above.\n It doesn't support any leading or trailing characters. It only\n accepts characters used for hex numbers and the string must have\n hyphens exactly like above.\n\n For a less strict parser, see $(LREF parseUUID)\n\n Examples:\n -------------------------\n id = UUID(\"8AB3060E-2cba-4f23-b74c-b52db3bdfb46\");\n assert(id.data == [138, 179, 6, 14, 44, 186, 79, 35, 183, 76,\n    181, 45, 179, 189, 251, 70]);\n assert(id.toString() == \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n\n //Can also be used in CTFE, for example as UUID literals:\n enum ctfeID = UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n //here parsing is done at compile time, no runtime overhead!\n -------------------------\n\n BUGS: Could be pure, but this depends on parse!(string, 16).\n         \n",
      "line" : 336,
      "name" : "this",
      "parameters" : [
       {
        "name" : "T",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "this",
        "kind" : "constructor",
        "line" : 336,
        "type" : "(T[] uuid)",
        "parameters" : [
         {
          "name" : "uuid",
          "type" : "T[]"
         }
        ],
        "endline" : 392
       }
      ]
     },
     {
      "name" : "__unittestL394_1985",
      "kind" : "function",
      "line" : 394,
      "endline" : 463
     },
     {
      "name" : "empty",
      "kind" : "function",
      "comment" : "\n Returns true if and only if the UUID is equal\n to {00000000-0000-0000-0000-000000000000}\n\n Examples:\n -------------------------\n UUID id;\n assert(id.empty);\n id = UUID(\"00000000-0000-0000-0000-000000000001\");\n assert(!id.empty);\n -------------------------\n         \n",
      "line" : 463,
      "storageClass" : [
       "nothrow",
       "pure",
       "@property",
       "@trusted"
      ],
      "deco" : "xFNaNbNdNeZb",
      "originalType" : "const bool()",
      "endline" : 475
     },
     {
      "name" : "__unittestL477_1986",
      "kind" : "function",
      "line" : 477,
      "endline" : 526
     },
     {
      "name" : "variant",
      "kind" : "function",
      "comment" : "\n RFC 4122 defines different internal data layouts for UUIDs.\n Returns the format used by this UUID.\n\n Note: Do not confuse this with $(XREF _variant, _Variant). This has nothing\n to do with $(XREF _variant, _Variant). The type of this property is\n $(MYREF3 std.uuid.UUID.Variant, _Variant).\n\n See_Also:\n $(MYREF3 UUID.Variant, Variant)\n\n Examples:\n ------------------------\n assert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").variant\n     == UUID.Variant.rfc4122);\n ------------------------\n         \n",
      "line" : 526,
      "storageClass" : [
       "nothrow",
       "pure",
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZE3std4uuid4UUID7Variant",
      "originalType" : "const Variant()",
      "endline" : 543
     },
     {
      "name" : "__unittestL546_1987",
      "kind" : "function",
      "line" : 546,
      "endline" : 551
     },
     {
      "name" : "__unittestL551_1988",
      "kind" : "function",
      "line" : 551,
      "endline" : 592
     },
     {
      "name" : "uuidVersion",
      "kind" : "function",
      "comment" : "\n RFC 4122 defines different UUID versions. The version shows\n how a UUID was generated, e.g. a version 4 UUID was generated\n from a random number, a version 3 UUID from an MD5 hash of a name.\n Returns the version used by this UUID.\n\n See_Also:\n $(MYREF3 UUID.Version, Version)\n\n Examples:\n ----------------------------\n  assert(UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\").uuidVersion\n      == UUID.Version.randomNumberBased);\n ----------------------------\n         \n",
      "line" : 592,
      "storageClass" : [
       "nothrow",
       "pure",
       "@property",
       "@safe"
      ],
      "deco" : "xFNaNbNdNfZE3std4uuid4UUID7Version",
      "originalType" : "const Version()",
      "endline" : 609
     },
     {
      "name" : "__unittestL612_1989",
      "kind" : "function",
      "line" : 612,
      "endline" : 617
     },
     {
      "name" : "__unittestL617_1990",
      "kind" : "function",
      "line" : 617,
      "endline" : 659
     },
     {
      "name" : "swap",
      "kind" : "function",
      "comment" : "\n Swap the data of this UUID with the data of rhs.\n\n Note: linear complexity\n\n Examples:\n ----------------------------\n UUID u1;\n auto u2 = UUID(cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);\n u1.swap(u2);\n\n assert(u1.data == cast(ubyte[16])[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]);\n assert(u2.data == cast(ubyte[16])[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);\n ----------------------------\n         \n",
      "line" : 659,
      "storageClass" : [
       "nothrow",
       "@safe"
      ],
      "deco" : "FNbNfKS3std4uuid4UUIDZv",
      "originalType" : "void(ref UUID rhs)",
      "parameters" : [
       {
        "name" : "rhs",
        "deco" : "S3std4uuid4UUID",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 662
     },
     {
      "name" : "__unittestL664_1991",
      "kind" : "function",
      "line" : 664,
      "endline" : 704
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n All of the standard numeric operators are defined for\n the UUID struct.\n\n Examples:\n -------------------------\n //compare UUIDs\n assert(UUID(\"00000000-0000-0000-0000-000000000000\") == UUID.init);\n\n //UUIDs in associative arrays:\n int[UUID] test = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\") : 1,\n     UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\") : 2,\n     UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\") : 3];\n\n assert(test[UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")] == 3);\n\n //UUIDS can be sorted:\n import std.algorithm;\n UUID[] ids = [UUID(\"8a94f585-d180-44f7-8929-6fca0189c7d0\"),\n               UUID(\"7c351fd4-b860-4ee3-bbdc-7f79f3dfb00a\"),\n               UUID(\"9ac0a4e5-10ee-493a-86fc-d29eeb82ecc1\")];\n sort(ids);\n -------------------------\n         \n",
      "line" : 704,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfxS3std4uuid4UUIDZb",
      "originalType" : "const bool(const UUID s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "xS3std4uuid4UUID"
       }
      ],
      "endline" : 707
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n ditto\n         \n",
      "line" : 712,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfKxS3std4uuid4UUIDZb",
      "originalType" : "const bool(ref const UUID s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "xS3std4uuid4UUID",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 715
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n ditto\n         \n",
      "line" : 720,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfKxS3std4uuid4UUIDZi",
      "originalType" : "const int(ref const UUID s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "xS3std4uuid4UUID",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 723
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n ditto\n         \n",
      "line" : 728,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfxS3std4uuid4UUIDZi",
      "originalType" : "const int(const UUID s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "xS3std4uuid4UUID"
       }
      ],
      "endline" : 731
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n ditto\n         \n",
      "line" : 736,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfZm",
      "originalType" : "const size_t()",
      "endline" : 743
     },
     {
      "name" : "__unittestL745_1992",
      "kind" : "function",
      "line" : 745,
      "endline" : 806
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Return the UUID as a string in the canonical form.\n\n Examples:\n ----------------------------------\n auto id = UUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n assert(id.toString() == \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n ----------------------------------\n         \n",
      "line" : 806,
      "deco" : "xFMDFAxaZvZv",
      "parameters" : [
       {
        "name" : "sink",
        "deco" : "DFAxaZv",
        "storageClass" : [
         "scope"
        ]
       }
      ],
      "endline" : 809
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 812,
      "storageClass" : [
       "nothrow",
       "pure",
       "@safe"
      ],
      "deco" : "xFNaNbNfZAya",
      "originalType" : "const string()",
      "endline" : 819
     },
     {
      "name" : "__unittestL821_1993",
      "kind" : "function",
      "line" : 821,
      "endline" : 837
     },
     {
      "name" : "__xopEquals",
      "kind" : "function",
      "storageClass" : [
       "static"
      ],
      "deco" : "FKxS3std4uuid4UUIDKxS3std4uuid4UUIDZb",
      "parameters" : [
       {
        "name" : "p",
        "deco" : "xS3std4uuid4UUID",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "q",
        "deco" : "xS3std4uuid4UUID",
        "storageClass" : [
         "ref"
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL839_1994",
    "kind" : "function",
    "line" : 839,
    "endline" : 886
   },
   {
    "name" : "md5UUID",
    "kind" : "function",
    "comment" : "\n This function generates a name based (Version 3) UUID from a namespace UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n RFC 4122 recommends to use Version 5 UUIDs (SHA-1) instead of Version 3\n UUIDs (MD5) for new applications.\n\n CTFE:\n CTFE is not supported.\n\n Examples:\n ---------------------------------------\n //Use default UUID.init namespace\n auto simpleID = md5UUID(\"test.uuid.any.string\");\n\n //use a name-based id as namespace\n auto namespace = md5UUID(\"my.app\");\n auto id = md5UUID(\"some-description\", namespace);\n ---------------------------------------\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\n \n",
    "line" : 886,
    "storageClass" : [
     "pure",
     "@safe"
    ],
    "deco" : "FNaNfxAaxS3std4uuid4UUIDZS3std4uuid4UUID",
    "originalType" : "UUID(const(char[]) name, const UUID namespace = UUID.init)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "namespace",
      "deco" : "xS3std4uuid4UUID",
      "default" : "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
     }
    ],
    "endline" : 889
   },
   {
    "name" : "md5UUID",
    "kind" : "function",
    "comment" : "\n ditto\n \n",
    "line" : 894,
    "storageClass" : [
     "pure",
     "@trusted"
    ],
    "deco" : "FNaNexAhxS3std4uuid4UUIDZS3std4uuid4UUID",
    "originalType" : "UUID(const(ubyte[]) data, const UUID namespace = UUID.init)",
    "parameters" : [
     {
      "name" : "data",
      "deco" : "xAh"
     },
     {
      "name" : "namespace",
      "deco" : "xS3std4uuid4UUID",
      "default" : "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
     }
    ],
    "endline" : 921
   },
   {
    "name" : "__unittestL923_1995",
    "kind" : "function",
    "line" : 923,
    "endline" : 996
   },
   {
    "name" : "sha1UUID",
    "kind" : "function",
    "comment" : "\n This function generates a name based (Version 5) UUID from a namespace\n UUID and a name.\n If no namespace UUID was passed, the empty UUID $(D UUID.init) is used.\n\n Note:\n The default namespaces ($(LREF dnsNamespace), ...) defined by\n this module should be used when appropriate.\n\n CTFE:\n CTFE is not supported.\n\n Examples:\n ---------------------------------------\n //Use default UUID.init namespace\n auto simpleID = sha1UUID(\"test.uuid.any.string\");\n\n //use a name-based id as namespace\n auto namespace = sha1UUID(\"my.app\");\n auto id = sha1UUID(\"some-description\", namespace);\n ---------------------------------------\n\n Note:\n RFC 4122 isn't very clear on how UUIDs should be generated from names.\n It is possible that different implementations return different UUIDs\n for the same input, so be warned. The implementation for UTF-8 strings\n and byte arrays used by $(D std.uuid) is compatible with Boost's implementation.\n $(D std.uuid) guarantees that the same input to this function will generate\n the same output at any time, on any system (this especially means endianness\n doesn't matter).\n\n Note:\n This function does not provide overloads for wstring and dstring, as\n there's no clear answer on how that should be implemented. It could be\n argued, that string, wstring and dstring input should have the same output,\n but that wouldn't be compatible with Boost, which generates different output\n for strings and wstrings. It's always possible to pass wstrings and dstrings\n by using the ubyte[] function overload (but be aware of endianness issues!).\n \n",
    "line" : 996,
    "storageClass" : [
     "pure",
     "@trusted"
    ],
    "deco" : "FNaNexAaxS3std4uuid4UUIDZS3std4uuid4UUID",
    "originalType" : "UUID(const(char[]) name, const UUID namespace = UUID.init)",
    "parameters" : [
     {
      "name" : "name",
      "deco" : "xAa"
     },
     {
      "name" : "namespace",
      "deco" : "xS3std4uuid4UUID",
      "default" : "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
     }
    ],
    "endline" : 999
   },
   {
    "name" : "sha1UUID",
    "kind" : "function",
    "comment" : "\n ditto\n \n",
    "line" : 1004,
    "storageClass" : [
     "pure",
     "@trusted"
    ],
    "deco" : "FNaNexAhxS3std4uuid4UUIDZS3std4uuid4UUID",
    "originalType" : "UUID(const(ubyte[]) data, const UUID namespace = UUID.init)",
    "parameters" : [
     {
      "name" : "data",
      "deco" : "xAh"
     },
     {
      "name" : "namespace",
      "deco" : "xS3std4uuid4UUID",
      "default" : "UUID([cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u, cast(ubyte)0u])"
     }
    ],
    "endline" : 1032
   },
   {
    "name" : "__unittestL1034_1996",
    "kind" : "function",
    "line" : 1034,
    "endline" : 1082
   },
   {
    "kind" : "template",
    "comment" : "\n This function generates a random number based UUID from a random\n number generator.\n\n CTFE:\n This function is not supported at compile time.\n\n Examples:\n ------------------------------------------\n //simple call\n auto uuid = randomUUID();\n\n //provide a custom RNG. Must be seeded manually.\n Xorshift192 gen;\n\n gen.seed(unpredictableSeed);\n auto uuid3 = randomUUID(gen);\n ------------------------------------------\n \n",
    "line" : 1082,
    "name" : "randomUUID",
    "parameters" : [],
    "members" : [
     {
      "name" : "randomUUID",
      "kind" : "function",
      "line" : 1082,
      "type" : "UUID()",
      "endline" : 1085
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "\n ditto\n \n",
    "line" : 1097,
    "name" : "randomUUID",
    "parameters" : [
     {
      "name" : "RNG",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "randomUUID",
      "kind" : "function",
      "comment" : "\n ditto\n \n",
      "line" : 1097,
      "type" : "UUID(ref RNG randomGen)",
      "parameters" : [
       {
        "name" : "randomGen",
        "type" : "RNG",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1121
     }
    ]
   },
   {
    "name" : "__unittestL1123_1997",
    "kind" : "function",
    "line" : 1123,
    "endline" : 1183
   },
   {
    "kind" : "template",
    "comment" : "\n This is a less strict parser compared to the parser used in the\n UUID constructor. It enforces the following rules:\n\n $(UL\n   $(LI hex numbers are always two hexdigits([0-9a-fA-F]))\n   $(LI there must be exactly 16 such pairs in the input, not less, not more)\n   $(LI there can be exactly one dash between two hex-pairs, but not more)\n   $(LI there can be multiple characters enclosing the 16 hex pairs,\n     as long as these characters do not contain [0-9a-fA-F])\n )\n\n Throws:\n $(LREF UUIDParsingException) if the input is invalid\n\n CTFE:\n This function is supported in CTFE code. Note that error messages\n caused by a malformed UUID parsed at compile time can be cryptic,\n but errors are detected and reported at compile time.\n\n Examples:\n -------------------------\n auto id = parseUUID(\"8AB3060E-2CBA-4F23-b74c-B52Db3BDFB46\");\n //no dashes\n id = parseUUID(\"8ab3060e2cba4f23b74cb52db3bdfb46\");\n //dashes at different positions\n id = parseUUID(\"8a-b3-06-0e2cba4f23b74c-b52db3bdfb-46\");\n //leading / trailing characters\n id = parseUUID(\"{8ab3060e-2cba-4f23-b74c-b52db3bdfb46}\");\n //unicode\n id = parseUUID(\"ü8ab3060e2cba4f23b74cb52db3bdfb46ü\");\n //multiple trailing/leading characters\n id = parseUUID(\"///8ab3060e2cba4f23b74cb52db3bdfb46||\");\n\n //Can also be used in CTFE, for example as UUID literals:\n enum ctfeID = parseUUID(\"8ab3060e-2cba-4f23-b74c-b52db3bdfb46\");\n //here parsing is done at compile time, no runtime overhead!\n -------------------------\n\n BUGS: Could be pure, but this depends on parse!(string, 16).\n \n",
    "line" : 1183,
    "name" : "parseUUID",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseUUID",
      "kind" : "function",
      "line" : 1183,
      "type" : "UUID(T uuidString)",
      "parameters" : [
       {
        "name" : "uuidString",
        "type" : "T"
       }
      ],
      "endline" : 1186
     }
    ]
   },
   {
    "kind" : "template",
    "comment" : "ditto\n",
    "line" : 1189,
    "name" : "parseUUID",
    "parameters" : [
     {
      "name" : "Range",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "parseUUID",
      "kind" : "function",
      "comment" : "ditto\n",
      "line" : 1189,
      "type" : "UUID(ref Range uuidRange)",
      "parameters" : [
       {
        "name" : "uuidRange",
        "type" : "Range",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 1324
     }
    ]
   },
   {
    "name" : "__unittestL1326_1998",
    "kind" : "function",
    "line" : 1326,
    "endline" : 1468
   },
   {
    "name" : "dnsNamespace",
    "kind" : "variable",
    "comment" : "\n Default namespace from RFC 4122\n\n Name string is a fully-qualified domain name\n \n",
    "line" : 1468,
    "storageClass" : [
     "enum"
    ],
    "deco" : "S3std4uuid4UUID",
    "init" : "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)16u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])"
   },
   {
    "name" : "urlNamespace",
    "kind" : "variable",
    "comment" : "\n Default namespace from RFC 4122\n\n Name string is a URL\n \n",
    "line" : 1475,
    "storageClass" : [
     "enum"
    ],
    "deco" : "S3std4uuid4UUID",
    "init" : "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)17u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])"
   },
   {
    "name" : "oidNamespace",
    "kind" : "variable",
    "comment" : "\n Default namespace from RFC 4122\n\n Name string is an ISO OID\n \n",
    "line" : 1482,
    "storageClass" : [
     "enum"
    ],
    "deco" : "S3std4uuid4UUID",
    "init" : "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)18u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])"
   },
   {
    "name" : "x500Namespace",
    "kind" : "variable",
    "comment" : "\n Default namespace from RFC 4122\n\n Name string is an X.500 DN (in DER or a text output format)\n \n",
    "line" : 1489,
    "storageClass" : [
     "enum"
    ],
    "deco" : "S3std4uuid4UUID",
    "init" : "UUID([cast(ubyte)107u, cast(ubyte)167u, cast(ubyte)184u, cast(ubyte)20u, cast(ubyte)157u, cast(ubyte)173u, cast(ubyte)17u, cast(ubyte)209u, cast(ubyte)128u, cast(ubyte)180u, cast(ubyte)0u, cast(ubyte)192u, cast(ubyte)79u, cast(ubyte)212u, cast(ubyte)48u, cast(ubyte)200u])"
   },
   {
    "name" : "uuidRegex",
    "kind" : "variable",
    "comment" : "\n Regex string to extract UUIDs from text.\n\n Examples:\n -------------------\n import std.algorithm;\n import std.regex;\n\n string test = \"Lorem ipsum dolor sit amet, consetetur \"\n     \"6ba7b814-9dad-11d1-80b4-00c04fd430c8 sadipscing \\n\"\n     \"elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore \\r\\n\"\n     \"magna aliquyam erat, sed diam voluptua. \"\n     \"8ab3060e-2cba-4f23-b74c-b52db3bdfb46 At vero eos et accusam et \"\n     \"justo duo dolores et ea rebum.\";\n\n auto r = regex(uuidRegex, \"g\");\n\n UUID[] found;\n foreach(c; match(test, r))\n {\n     found ~= UUID(c.hit);\n }\n\n writeln(found);\n -------------------\n \n",
    "line" : 1518,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\""
   },
   {
    "name" : "__unittestL1520_1999",
    "kind" : "function",
    "line" : 1520,
    "endline" : 1547
   },
   {
    "name" : "UUIDParsingException",
    "kind" : "class",
    "comment" : "\n This exception is thrown if an error occurs when parsing a UUID\n from a string.\n \n",
    "line" : 1547,
    "base" : "Exception",
    "members" : [
     {
      "name" : "Reason",
      "kind" : "enum",
      "comment" : "\n The reason why parsing the UUID string failed (if known)\n         \n",
      "line" : 1554,
      "baseDeco" : "i",
      "members" : [
       {
        "name" : "unknown",
        "kind" : "enum member",
        "comment" : "\n",
        "line" : 1555
       },
       {
        "name" : "tooLittle",
        "kind" : "enum member",
        "comment" : "The passed in input was correct, but more input was expected.\n",
        "line" : 1556
       },
       {
        "name" : "tooMuch",
        "kind" : "enum member",
        "comment" : "The input data is too long (There's no guarantee the first part of the data is valid)\n",
        "line" : 1557
       },
       {
        "name" : "invalidChar",
        "kind" : "enum member",
        "comment" : "Encountered an invalid character\n",
        "line" : 1558
       }
      ]
     },
     {
      "name" : "reason",
      "kind" : "variable",
      "comment" : "ditto\n",
      "line" : 1562,
      "deco" : "E3std4uuid20UUIDParsingException6Reason",
      "offset" : 72
     },
     {
      "name" : "input",
      "kind" : "variable",
      "comment" : "The original input string which should have been parsed.\n",
      "line" : 1564,
      "deco" : "Aya",
      "offset" : 80
     },
     {
      "name" : "position",
      "kind" : "variable",
      "comment" : "The position in the input string where the error occurred.\n",
      "line" : 1566,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 96
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 1568,
      "deco" : "FAyamE3std4uuid20UUIDParsingException6ReasonAyaC6object9ThrowableAyamZC3std4uuid20UUIDParsingException",
      "originalType" : "(string input, size_t pos, Reason why = Reason.unknown, string msg = \"\", Throwable next = null, string file = __FILE__, size_t line = __LINE__)",
      "parameters" : [
       {
        "name" : "input",
        "deco" : "Aya"
       },
       {
        "name" : "pos",
        "deco" : "m"
       },
       {
        "name" : "why",
        "deco" : "E3std4uuid20UUIDParsingException6Reason",
        "default" : "cast(Reason)0"
       },
       {
        "name" : "msg",
        "deco" : "Aya",
        "default" : "\"\""
       },
       {
        "name" : "next",
        "deco" : "C6object9Throwable",
        "default" : "null"
       },
       {
        "name" : "file",
        "deco" : "Aya",
        "default" : "__FILE__"
       },
       {
        "name" : "line",
        "deco" : "m",
        "default" : "cast(ulong)__LINE__"
       }
      ],
      "endline" : 1578
     }
    ]
   }
  ]
 },
 {
  "name" : "std.variant",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/variant.d",
  "comment" : "\n This module implements a\n $(LINK2 http://erdani.org/publications/cuj-04-2002.html,discriminated union)\n type (a.k.a.\n $(LINK2 http://en.wikipedia.org/wiki/Tagged_union,tagged union),\n $(LINK2 http://en.wikipedia.org/wiki/Algebraic_data_type,algebraic type)).\n Such types are useful\n for type-uniform binary interfaces, interfacing with scripting\n languages, and comfortable exploratory programming.\n\n Macros:\n  WIKI = Phobos/StdVariant\n\n Synopsis:\n\n ----\n Variant a; // Must assign before use, otherwise exception ensues\n // Initialize with an integer; make the type int\n Variant b = 42;\n assert(b.type == typeid(int));\n // Peek at the value\n assert(b.peek!(int) !is null && *b.peek!(int) == 42);\n // Automatically convert per language rules\n auto x = b.get!(real);\n // Assign any other type, including other variants\n a = b;\n a = 3.14;\n assert(a.type == typeid(double));\n // Implicit conversions work just as with built-in types\n assert(a < b);\n // Check for convertibility\n assert(!a.convertsTo!(int)); // double not convertible to int\n // Strings and all other arrays are supported\n a = \"now I'm a string\";\n assert(a == \"now I'm a string\");\n a = new int[42]; // can also assign arrays\n assert(a.length == 42);\n a[5] = 7;\n assert(a[5] == 7);\n // Can also assign class values\n class Foo {}\n auto foo = new Foo;\n a = foo;\n assert(*a.peek!(Foo) == foo); // and full type information is preserved\n ----\n\n Credits:\n\n Reviewed by Brad Roberts. Daniel Keep provided a detailed code\n review prompting the following improvements: (1) better support for\n arrays; (2) support for associative arrays; (3) friendlier behavior\n towards the garbage collector.\n\n Copyright: Copyright Andrei Alexandrescu 2007 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB erdani.org, Andrei Alexandrescu)\n Source:    $(PHOBOSSRC std/_variant.d)\n \n",
  "members" : [
   {
    "name" : "std.traits",
    "kind" : "import",
    "line" : 68,
    "protection" : "private"
   },
   {
    "name" : "std.c.string",
    "kind" : "import",
    "line" : 68,
    "protection" : "private"
   },
   {
    "name" : "std.typetuple",
    "kind" : "import",
    "line" : 68,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 68,
    "protection" : "private"
   },
   {
    "name" : "std.exception",
    "kind" : "import",
    "line" : 68,
    "protection" : "private"
   },
   {
    "kind" : "template",
    "comment" : "\n    Gives the $(D sizeof) the largest type given.\n  \n",
    "line" : 75,
    "name" : "maxSize",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "name" : "This",
    "kind" : "struct",
    "line" : 88
   },
   {
    "kind" : "template",
    "line" : 90,
    "name" : "AssociativeArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "valid",
      "kind" : "variable",
      "line" : 92,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "false"
     },
     {
      "name" : "Key",
      "kind" : "alias",
      "line" : 93,
      "deco" : "v"
     },
     {
      "name" : "Value",
      "kind" : "alias",
      "line" : 94,
      "deco" : "v"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 97,
    "name" : "AssociativeArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type",
      "type" : "V[K]"
     },
     {
      "name" : "K",
      "kind" : "type"
     },
     {
      "name" : "V",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "valid",
      "kind" : "variable",
      "line" : 99,
      "storageClass" : [
       "enum"
      ],
      "deco" : "b",
      "init" : "true"
     },
     {
      "name" : "Key",
      "kind" : "alias",
      "line" : 100,
      "type" : "K"
     },
     {
      "name" : "Value",
      "kind" : "alias",
      "line" : 101,
      "type" : "V"
     }
    ]
   },
   {
    "kind" : "template",
    "line" : 104,
    "name" : "This2Variant",
    "parameters" : [
     {
      "name" : "V",
      "kind" : "type"
     },
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : []
   },
   {
    "kind" : "template",
    "comment" : "\n $(D_PARAM VariantN) is a back-end type seldom used directly by user\n code. Two commonly-used types using $(D_PARAM VariantN) as\n back-end are:\n\n $(OL $(LI $(B Algebraic): A closed discriminated union with a\n limited type universe (e.g., $(D_PARAM Algebraic!(int, double,\n string)) only accepts these three types and rejects anything\n else).) $(LI $(B Variant): An open discriminated union allowing an\n unbounded set of types. The restriction is that the size of the\n stored type cannot be larger than the largest built-in type. This\n means that $(D_PARAM Variant) can accommodate all primitive types\n and all user-defined types except for large $(D_PARAM struct)s.) )\n\n Both $(D_PARAM Algebraic) and $(D_PARAM Variant) share $(D_PARAM\n VariantN)'s interface. (See their respective documentations below.)\n\n $(D_PARAM VariantN) is a discriminated union type parameterized\n with the largest size of the types stored ($(D_PARAM maxDataSize))\n and with the list of allowed types ($(D_PARAM AllowedTypes)). If\n the list is empty, then any type up of size up to $(D_PARAM\n maxDataSize) (rounded up for alignment) can be stored in a\n $(D_PARAM VariantN) object.\n\n \n",
    "line" : 154,
    "name" : "VariantN",
    "parameters" : [
     {
      "name" : "maxDataSize",
      "kind" : "value",
      "deco" : "m"
     },
     {
      "name" : "AllowedTypesX",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "VariantN",
      "kind" : "struct",
      "line" : 154,
      "members" : [
       {
        "name" : "AllowedTypes",
        "kind" : "alias",
        "line" : 155,
        "type" : "This2Variant!(VariantN, AllowedTypesX)"
       },
       {
        "name" : "SizeChecker",
        "kind" : "struct",
        "line" : 160,
        "members" : [
         {
          "name" : "fptr",
          "kind" : "variable",
          "line" : 161,
          "type" : "int function()"
         },
         {
          "name" : "data",
          "kind" : "variable",
          "line" : 162,
          "type" : "ubyte[maxDataSize]"
         }
        ]
       },
       {
        "name" : "size",
        "kind" : "variable",
        "line" : 164,
        "storageClass" : [
         "enum"
        ],
        "init" : "SizeChecker.sizeof - (int function()).sizeof"
       },
       {
        "kind" : "template",
        "comment" : " Tells whether a type $(D_PARAM T) is statically allowed for\n storage inside a $(D_PARAM VariantN) object by looking\n $(D_PARAM T) up in $(D_PARAM AllowedTypes). If $(D_PARAM\n AllowedTypes) is empty, all types of size up to $(D_PARAM\n maxSize) are allowed.\n     \n",
        "line" : 173,
        "name" : "allowed",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "allowed",
          "kind" : "variable",
          "line" : 175,
          "storageClass" : [
           "enum"
          ],
          "deco" : "b",
          "init" : "is(T == VariantN) || (AllowedTypes.length == 0 || staticIndexOf!(T, AllowedTypes) >= 0)"
         }
        ]
       },
       {
        "name" : "OpID",
        "kind" : "enum",
        "line" : 184,
        "members" : [
         {
          "name" : "getTypeInfo",
          "kind" : "enum member",
          "line" : 184
         },
         {
          "name" : "get",
          "kind" : "enum member",
          "line" : 184
         },
         {
          "name" : "compare",
          "kind" : "enum member",
          "line" : 184
         },
         {
          "name" : "testConversion",
          "kind" : "enum member",
          "line" : 184
         },
         {
          "name" : "toString",
          "kind" : "enum member",
          "line" : 184
         },
         {
          "name" : "index",
          "kind" : "enum member",
          "line" : 185
         },
         {
          "name" : "indexAssign",
          "kind" : "enum member",
          "line" : 185
         },
         {
          "name" : "catAssign",
          "kind" : "enum member",
          "line" : 185
         },
         {
          "name" : "copyOut",
          "kind" : "enum member",
          "line" : 185
         },
         {
          "name" : "length",
          "kind" : "enum member",
          "line" : 185
         },
         {
          "name" : "apply",
          "kind" : "enum member",
          "line" : 186
         }
        ]
       },
       {
        "name" : "fptr",
        "kind" : "variable",
        "line" : 189,
        "type" : "ptrdiff_t function(OpID selector, ubyte[size]* store, void* data)",
        "init" : "&handler!(void)"
       },
       {
        "name" : "store",
        "kind" : "variable",
        "line" : 193,
        "type" : "ubyte[size]"
       },
       {
        "kind" : "template",
        "line" : 201,
        "name" : "handler",
        "parameters" : [
         {
          "name" : "A",
          "kind" : "type",
          "deco" : "v"
         }
        ],
        "members" : [
         {
          "name" : "handler",
          "kind" : "function",
          "line" : 201,
          "type" : "ptrdiff_t(OpID selector, ubyte[size]*, void* parm)",
          "parameters" : [
           {
            "name" : "selector",
            "type" : "OpID"
           },
           {
            "type" : "ubyte[size]*"
           },
           {
            "name" : "parm",
            "type" : "void*"
           }
          ],
          "endline" : 233
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 236,
        "name" : "handler",
        "parameters" : [
         {
          "name" : "A",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "handler",
          "kind" : "function",
          "line" : 236,
          "type" : "ptrdiff_t(OpID selector, ubyte[size]* pStore, void* parm)",
          "parameters" : [
           {
            "name" : "selector",
            "type" : "OpID"
           },
           {
            "name" : "pStore",
            "type" : "ubyte[size]*"
           },
           {
            "name" : "parm",
            "type" : "void*"
           }
          ],
          "endline" : 495
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Constructs a $(D_PARAM VariantN) value given an argument of a\n generic type. Statically rejects disallowed types.\n     \n",
        "line" : 502,
        "name" : "this",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "this",
          "kind" : "constructor",
          "line" : 502,
          "type" : "(T value)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           }
          ],
          "endline" : 507
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : " Assigns a $(D_PARAM VariantN) from a generic\n argument. Statically rejects disallowed types. \n",
        "line" : 512,
        "name" : "opAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAssign",
          "kind" : "function",
          "comment" : " Assigns a $(D_PARAM VariantN) from a generic\n argument. Statically rejects disallowed types. \n",
          "line" : 512,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 559
         }
        ]
       },
       {
        "name" : "hasValue",
        "kind" : "function",
        "comment" : " Returns true if and only if the $(D_PARAM VariantN) object\n holds a valid value (has been initialized with, or assigned\n from, a valid value).\n Example:\n ----\n Variant a;\n assert(!a.hasValue);\n Variant b;\n a = b;\n assert(!a.hasValue); // still no value\n a = 5;\n assert(a.hasValue);\n ----\n     \n",
        "line" : 576,
        "type" : "const pure nothrow bool()",
        "endline" : 580
       },
       {
        "kind" : "template",
        "comment" : "\n If the $(D_PARAM VariantN) object holds a value of the\n $(I exact) type $(D_PARAM T), returns a pointer to that\n value. Otherwise, returns $(D_PARAM null). In cases\n where $(D_PARAM T) is statically disallowed, $(D_PARAM\n peek) will not compile.\n\n Example:\n ----\n Variant a = 5;\n auto b = a.peek!(int);\n assert(b !is null);\n *b = 6;\n assert(a == 6);\n ----\n     \n",
        "line" : 598,
        "name" : "peek",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "peek",
          "kind" : "function",
          "line" : 598,
          "type" : "inout T*()",
          "endline" : 604
         }
        ]
       },
       {
        "name" : "type",
        "kind" : "function",
        "comment" : "\n Returns the $(D_PARAM typeid) of the currently held value.\n     \n",
        "line" : 610,
        "type" : "const TypeInfo()",
        "endline" : 615
       },
       {
        "kind" : "template",
        "comment" : "\n Returns $(D_PARAM true) if and only if the $(D_PARAM VariantN)\n object holds an object implicitly convertible to type $(D_PARAM\n U). Implicit convertibility is defined as per\n $(LINK2 std_traits.html#ImplicitConversionTargets,ImplicitConversionTargets).\n     \n",
        "line" : 624,
        "name" : "convertsTo",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "convertsTo",
          "kind" : "function",
          "line" : 624,
          "type" : "const bool()",
          "endline" : 628
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n Returns the value stored in the $(D_PARAM VariantN) object,\n implicitly converted to the requested type $(D_PARAM T), in\n fact $(D_PARAM DecayStaticToDynamicArray!(T)). If an implicit\n conversion is not possible, throws a $(D_PARAM\n VariantException).\n     \n",
        "line" : 664,
        "name" : "get",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "get",
          "kind" : "function",
          "line" : 664,
          "type" : "T()",
          "endline" : 678
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 680,
        "name" : "get",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "get",
          "kind" : "function",
          "line" : 680,
          "type" : "const T()",
          "endline" : 694
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n Returns the value stored in the $(D_PARAM VariantN) object,\n explicitly converted (coerced) to the requested type $(D_PARAM\n T). If $(D_PARAM T) is a string type, the value is formatted as\n a string. If the $(D_PARAM VariantN) object is a string, a\n parse of the string to type $(D_PARAM T) is attempted. If a\n conversion is not possible, throws a $(D_PARAM\n VariantException).\n     \n",
        "line" : 706,
        "name" : "coerce",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "coerce",
          "kind" : "function",
          "line" : 706,
          "type" : "T()",
          "endline" : 749
         }
        ]
       },
       {
        "name" : "__unittestL752_2002",
        "kind" : "function",
        "line" : 752,
        "endline" : 762
       },
       {
        "name" : "toString",
        "kind" : "function",
        "comment" : "\n Formats the stored value as a string.\n     \n",
        "line" : 762,
        "type" : "string()",
        "endline" : 767
       },
       {
        "kind" : "template",
        "comment" : "\n Comparison for equality used by the \"==\" and \"!=\"  operators.\n     \n",
        "line" : 774,
        "name" : "opEquals",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opEquals",
          "kind" : "function",
          "comment" : "\n Comparison for equality used by the \"==\" and \"!=\"  operators.\n     \n",
          "line" : 774,
          "type" : "const bool(auto ref T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T",
            "storageClass" : [
             "auto",
             "ref"
            ]
           }
          ],
          "endline" : 782
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n Ordering comparison used by the \"<\", \"<=\", \">\", and \">=\"\n operators. In case comparison is not sensible between the held\n value and $(D_PARAM rhs), an exception is thrown.\n     \n",
        "line" : 790,
        "name" : "opCmp",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCmp",
          "kind" : "function",
          "comment" : "\n Ordering comparison used by the \"<\", \"<=\", \">\", and \">=\"\n operators. In case comparison is not sensible between the held\n value and $(D_PARAM rhs), an exception is thrown.\n     \n",
          "line" : 790,
          "type" : "int(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 804
         }
        ]
       },
       {
        "name" : "toHash",
        "kind" : "function",
        "comment" : "\n Computes the hash of the held value.\n     \n",
        "line" : 810,
        "type" : "size_t()",
        "endline" : 813
       },
       {
        "kind" : "template",
        "line" : 815,
        "name" : "opArithmetic",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opArithmetic",
          "kind" : "function",
          "line" : 815,
          "type" : "VariantN(T other)",
          "parameters" : [
           {
            "name" : "other",
            "type" : "T"
           }
          ],
          "endline" : 854
         }
        ]
       },
       {
        "kind" : "template",
        "line" : 856,
        "name" : "opLogic",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "op",
          "kind" : "value",
          "type" : "string"
         }
        ],
        "members" : [
         {
          "name" : "opLogic",
          "kind" : "function",
          "line" : 856,
          "type" : "VariantN(T other)",
          "parameters" : [
           {
            "name" : "other",
            "type" : "T"
           }
          ],
          "endline" : 883
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n Arithmetic between $(D_PARAM VariantN) objects and numeric\n values. All arithmetic operations return a $(D_PARAM VariantN)\n object typed depending on the types of both values\n involved. The conversion rules mimic D's built-in rules for\n arithmetic conversions.\n     \n",
        "line" : 895,
        "name" : "opAdd",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAdd",
          "kind" : "function",
          "comment" : "\n Arithmetic between $(D_PARAM VariantN) objects and numeric\n values. All arithmetic operations return a $(D_PARAM VariantN)\n object typed depending on the types of both values\n involved. The conversion rules mimic D's built-in rules for\n arithmetic conversions.\n     \n",
          "line" : 895,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 895
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 897,
        "name" : "opSub",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opSub",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 897,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 897
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 908,
        "name" : "opMul",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opMul",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 908,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 908
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 910,
        "name" : "opDiv",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opDiv",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 910,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 910
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 917,
        "name" : "opMod",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opMod",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 917,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 917
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 924,
        "name" : "opAnd",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAnd",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 924,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 924
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 926,
        "name" : "opOr",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOr",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 926,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 926
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 928,
        "name" : "opXor",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opXor",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 928,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 928
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 930,
        "name" : "opShl",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opShl",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 930,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 930
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 937,
        "name" : "opShr",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opShr",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 937,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 937
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 944,
        "name" : "opUShr",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opUShr",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 944,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 944
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 951,
        "name" : "opCat",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCat",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 951,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 956
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 966,
        "name" : "opAddAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAddAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 966,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 966
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 968,
        "name" : "opSubAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opSubAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 968,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 968
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 970,
        "name" : "opMulAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opMulAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 970,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 970
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 972,
        "name" : "opDivAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opDivAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 972,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 972
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 974,
        "name" : "opModAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opModAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 974,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 974
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 976,
        "name" : "opAndAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opAndAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 976,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 976
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 978,
        "name" : "opOrAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opOrAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 978,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 978
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 980,
        "name" : "opXorAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opXorAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 980,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 980
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 982,
        "name" : "opShlAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opShlAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 982,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 982
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 984,
        "name" : "opShrAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opShrAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 984,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 984
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 986,
        "name" : "opUShrAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opUShrAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 986,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 986
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "ditto\n",
        "line" : 988,
        "name" : "opCatAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opCatAssign",
          "kind" : "function",
          "comment" : "ditto\n",
          "line" : 988,
          "type" : "VariantN(T rhs)",
          "parameters" : [
           {
            "name" : "rhs",
            "type" : "T"
           }
          ],
          "endline" : 993
         }
        ]
       },
       {
        "kind" : "template",
        "comment" : "\n Array and associative array operations. If a $(D_PARAM\n VariantN) contains an (associative) array, it can be indexed\n into. Otherwise, an exception is thrown.\n\n Example:\n ----\n auto a = Variant(new int[10]);\n a[5] = 42;\n assert(a[5] == 42);\n int[int] hash = [ 42:24 ];\n a = hash;\n assert(a[42] == 24);\n ----\n\n Caveat:\n\n Due to limitations in current language, read-modify-write\n operations $(D_PARAM op=) will not work properly:\n\n ----\n Variant a = new int[10];\n a[5] = 42;\n a[5] += 8;\n assert(a[5] == 50); // fails, a[5] is still 42\n ----\n     \n",
        "line" : 1022,
        "name" : "opIndex",
        "parameters" : [
         {
          "name" : "K",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opIndex",
          "kind" : "function",
          "comment" : "\n Array and associative array operations. If a $(D_PARAM\n VariantN) contains an (associative) array, it can be indexed\n into. Otherwise, an exception is thrown.\n\n Example:\n ----\n auto a = Variant(new int[10]);\n a[5] = 42;\n assert(a[5] == 42);\n int[int] hash = [ 42:24 ];\n a = hash;\n assert(a[42] == 24);\n ----\n\n Caveat:\n\n Due to limitations in current language, read-modify-write\n operations $(D_PARAM op=) will not work properly:\n\n ----\n Variant a = new int[10];\n a[5] = 42;\n a[5] += 8;\n assert(a[5] == 50); // fails, a[5] is still 42\n ----\n     \n",
          "line" : 1022,
          "type" : "VariantN(K i)",
          "parameters" : [
           {
            "name" : "i",
            "type" : "K"
           }
          ],
          "endline" : 1027
         }
        ]
       },
       {
        "name" : "__unittestL1029_2003",
        "kind" : "function",
        "line" : 1029,
        "endline" : 1039
       },
       {
        "kind" : "template",
        "comment" : " ditto\n",
        "line" : 1039,
        "name" : "opIndexAssign",
        "parameters" : [
         {
          "name" : "T",
          "kind" : "type"
         },
         {
          "name" : "N",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opIndexAssign",
          "kind" : "function",
          "comment" : " ditto\n",
          "line" : 1039,
          "type" : "VariantN(T value, N i)",
          "parameters" : [
           {
            "name" : "value",
            "type" : "T"
           },
           {
            "name" : "i",
            "type" : "N"
           }
          ],
          "endline" : 1044
         }
        ]
       },
       {
        "name" : "length",
        "kind" : "function",
        "comment" : " If the $(D_PARAM VariantN) contains an (associative) array,\n returns the length of that array. Otherwise, throws an\n exception.\n     \n",
        "line" : 1050,
        "type" : "size_t()",
        "endline" : 1053
       },
       {
        "kind" : "template",
        "comment" : "\n       If the $(D VariantN) contains an array, applies $(D dg) to each\n       element of the array in turn. Otherwise, throws an exception.\n     \n",
        "line" : 1059,
        "name" : "opApply",
        "parameters" : [
         {
          "name" : "Delegate",
          "kind" : "type"
         }
        ],
        "members" : [
         {
          "name" : "opApply",
          "kind" : "function",
          "comment" : "\n       If the $(D VariantN) contains an array, applies $(D dg) to each\n       element of the array in turn. Otherwise, throws an exception.\n     \n",
          "line" : 1059,
          "type" : "int(scope Delegate dg)",
          "parameters" : [
           {
            "name" : "dg",
            "type" : "Delegate",
            "storageClass" : [
             "scope"
            ]
           }
          ],
          "endline" : 1089
         }
        ]
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1093_2004",
    "kind" : "function",
    "line" : 1093,
    "endline" : 1141
   },
   {
    "kind" : "template",
    "comment" : "\n Algebraic data type restricted to a closed set of possible\n types. It's an alias for a $(D_PARAM VariantN) with an\n appropriately-constructed maximum size. $(D_PARAM Algebraic) is\n useful when it is desirable to restrict what a discriminated type\n could hold to the end of defining simpler and more efficient\n manipulation.\n\n Future additions to $(D_PARAM Algebraic) will allow compile-time\n checking that all possible types are handled by user code,\n eliminating a large class of errors.\n\n Bugs:\n\n Currently, $(D_PARAM Algebraic) does not allow recursive data\n types. They will be allowed in a future iteration of the\n implementation.\n\n Example:\n ----\n auto v = Algebraic!(int, double, string)(5);\n assert(v.peek!(int));\n v = 3.14;\n assert(v.peek!(double));\n // auto x = v.peek!(long); // won't compile, type long not allowed\n // v = '1'; // won't compile, type char not allowed\n ----\n \n",
    "line" : 1141,
    "name" : "Algebraic",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "Algebraic",
      "kind" : "alias",
      "line" : 1143,
      "type" : "VariantN!(maxSize!(T), T)"
     }
    ]
   },
   {
    "name" : "Variant",
    "kind" : "alias",
    "comment" : "\n$(D_PARAM Variant) is an alias for $(D_PARAM VariantN) instantiated\nwith the largest of $(D_PARAM creal), $(D_PARAM char[]), and $(D_PARAM\nvoid delegate()). This ensures that $(D_PARAM Variant) is large enough\nto hold all of D's predefined types, including all numeric types,\npointers, delegates, and class references.  You may want to use\n$(D_PARAM VariantN) directly with a different maximum size either for\nstoring larger types, or for saving memory.\n \n",
    "line" : 1156,
    "deco" : "S3std7variant17__T8VariantNVm32Z8VariantN"
   },
   {
    "kind" : "template",
    "comment" : "\n Returns an array of variants constructed from $(D_PARAM args).\n Example:\n ----\n auto a = variantArray(1, 3.14, \"Hi!\");\n assert(a[1] == 3.14);\n auto b = Variant(a); // variant array as variant\n assert(b[1] == 3.14);\n ----\n\n Code that needs functionality similar to the $(D_PARAM boxArray)\n function in the $(D_PARAM std.boxer) module can achieve it like this:\n\n ----\n // old\n Box[] fun(...)\n {\n     ...\n     return boxArray(_arguments, _argptr);\n }\n // new\n Variant[] fun(T...)(T args)\n {\n     ...\n     return variantArray(args);\n }\n ----\n\n This is by design. During construction the $(D_PARAM Variant) needs\n static type information about the type being held, so as to store a\n pointer to function for fast retrieval.\n \n",
    "line" : 1191,
    "name" : "variantArray",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "variantArray",
      "kind" : "function",
      "comment" : "\n Returns an array of variants constructed from $(D_PARAM args).\n Example:\n ----\n auto a = variantArray(1, 3.14, \"Hi!\");\n assert(a[1] == 3.14);\n auto b = Variant(a); // variant array as variant\n assert(b[1] == 3.14);\n ----\n\n Code that needs functionality similar to the $(D_PARAM boxArray)\n function in the $(D_PARAM std.boxer) module can achieve it like this:\n\n ----\n // old\n Box[] fun(...)\n {\n     ...\n     return boxArray(_arguments, _argptr);\n }\n // new\n Variant[] fun(T...)(T args)\n {\n     ...\n     return variantArray(args);\n }\n ----\n\n This is by design. During construction the $(D_PARAM Variant) needs\n static type information about the type being held, so as to store a\n pointer to function for fast retrieval.\n \n",
      "line" : 1191,
      "type" : "Variant[](T args)",
      "parameters" : [
       {
        "name" : "args",
        "type" : "T"
       }
      ],
      "endline" : 1199
     }
    ]
   },
   {
    "name" : "VariantException",
    "kind" : "class",
    "comment" : "\n Thrown in three cases:\n\n $(OL $(LI An uninitialized Variant is used in any way except\n assignment and $(D_PARAM hasValue);) $(LI A $(D_PARAM get) or\n $(D_PARAM coerce) is attempted with an incompatible target type;)\n $(LI A comparison between $(D_PARAM Variant) objects of\n incompatible types is attempted.))\n\n \n",
    "line" : 1213,
    "base" : "Exception",
    "members" : [
     {
      "name" : "source",
      "kind" : "variable",
      "comment" : " The source type in the conversion or comparison\n",
      "line" : 1216,
      "storageClass" : [
       "@trusted"
      ],
      "deco" : "C8TypeInfo",
      "originalType" : "TypeInfo",
      "offset" : 72
     },
     {
      "name" : "target",
      "kind" : "variable",
      "comment" : " The target type in the conversion or comparison\n",
      "line" : 1218,
      "storageClass" : [
       "@trusted"
      ],
      "deco" : "C8TypeInfo",
      "originalType" : "TypeInfo",
      "offset" : 80
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1219,
      "storageClass" : [
       "@trusted"
      ],
      "deco" : "FNeAyaZC3std7variant16VariantException",
      "originalType" : "(string s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aya"
       }
      ],
      "endline" : 1222
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 1223,
      "storageClass" : [
       "@trusted"
      ],
      "deco" : "FNeC8TypeInfoC8TypeInfoZC3std7variant16VariantException",
      "originalType" : "(TypeInfo source, TypeInfo target)",
      "parameters" : [
       {
        "name" : "source",
        "deco" : "C8TypeInfo"
       },
       {
        "name" : "target",
        "deco" : "C8TypeInfo"
       }
      ],
      "endline" : 1230
     }
    ]
   },
   {
    "name" : "__unittestL1233_2005",
    "kind" : "function",
    "line" : 1233,
    "endline" : 1243
   },
   {
    "name" : "__unittestL1243_2006",
    "kind" : "function",
    "line" : 1243,
    "endline" : 1259
   },
   {
    "name" : "__unittestL1259_2007",
    "kind" : "function",
    "line" : 1259,
    "endline" : 1335
   },
   {
    "name" : "__unittestL1335_2008",
    "kind" : "function",
    "line" : 1335,
    "endline" : 1461
   },
   {
    "name" : "__unittestL1461_2009",
    "kind" : "function",
    "line" : 1461,
    "endline" : 1470
   },
   {
    "name" : "__unittestL1470_2010",
    "kind" : "function",
    "line" : 1470,
    "endline" : 1481
   },
   {
    "name" : "__unittestL1481_2011",
    "kind" : "function",
    "line" : 1481,
    "endline" : 1488
   },
   {
    "name" : "__unittestL1488_2012",
    "kind" : "function",
    "line" : 1488,
    "endline" : 1501
   },
   {
    "name" : "__unittestL1501_2013",
    "kind" : "function",
    "line" : 1501,
    "endline" : 1510
   },
   {
    "name" : "__unittestL1510_2014",
    "kind" : "function",
    "line" : 1510,
    "endline" : 1522
   },
   {
    "name" : "__unittestL1522_2015",
    "kind" : "function",
    "line" : 1522,
    "endline" : 1529
   },
   {
    "name" : "__unittestL1529_2016",
    "kind" : "function",
    "line" : 1529,
    "endline" : 1544
   },
   {
    "name" : "__unittestL1544_2017",
    "kind" : "function",
    "line" : 1544,
    "endline" : 1552
   },
   {
    "name" : "__unittestL1552_2018",
    "kind" : "function",
    "line" : 1552,
    "endline" : 1563
   },
   {
    "name" : "__unittestL1563_2019",
    "kind" : "function",
    "line" : 1563,
    "endline" : 1617
   },
   {
    "kind" : "template",
    "comment" : "\n Applies a delegate or function to the given Algebraic depending on the held type,\n ensuring that all types are handled by the visiting functions.\n\n The delegate or function having the currently held value as parameter is called\n with $(D_PARM variant)'s current value. Visiting handlers are passed\n in the template parameter list.\n It is statically ensured that all types of\n $(D_PARAM variant) are handled accross all handlers.\n $(D_PARAM visit) allows delegates and static functions to be passed\n as parameters.\n\n If a function without parameters is specified, this function is called\n when variant doesn't hold a value. Exactly one parameter-less function\n is allowed.\n\n Duplicate overloads matching the same type in one of the visitors are disallowed.\n\n Example:\n -----------------------\n   Algebraic!(int, string) variant;\n\n   variant = 10;\n   assert(variant.visit!((string s) => cast(int)s.length,\n                         (int i)    => i)()\n                         == 10);\n   variant = \"string\";\n   assert(variant.visit!((int i) => return i,\n                         (string s) => cast(int)s.length)()\n                         == 6);\n\n   // Error function usage\n   Algebraic!(int, string) emptyVar;\n   assert(variant.visit!((string s) => cast(int)s.length,\n                         (int i)    => i,\n                         () => -1)()\n                         == -1);\n ----------------------\n Returns: The return type of visit is deduced from the visiting functions and must be\n the same accross all overloads.\n Throws: If no parameter-less, error function is specified:\n $(D_PARAM VariantException) if $(D_PARAM variant) doesn't hold a value.\n \n",
    "line" : 1617,
    "name" : "visit",
    "parameters" : [
     {
      "name" : "Handler",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1620,
      "name" : "visit",
      "parameters" : [
       {
        "name" : "VariantType",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "visit",
        "kind" : "function",
        "line" : 1620,
        "storageClass" : [
         "auto"
        ],
        "type" : "(VariantType variant)",
        "parameters" : [
         {
          "name" : "variant",
          "type" : "VariantType"
         }
        ],
        "endline" : 1624
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1627_2036",
    "kind" : "function",
    "line" : 1627,
    "endline" : 1717
   },
   {
    "kind" : "template",
    "comment" : "\n Behaves as $(D_PARAM visit) but doesn't enforce that all types are handled\n by the visiting functions.\n\n If a parameter-less function is specified it is called when\n either $(D_PARAM variant) doesn't hold a value or holds a type\n which isn't handled by the visiting functions.\n\n Example:\n -----------------------\n   Algebraic!(int, string) variant;\n\n   variant = 10;\n   auto which = -1;\n   variant.tryVisit!((int i) { which = 0; })();\n   assert(which = 0);\n\n   // Error function usage\n   variant = \"test\";\n   variant.tryVisit!((int i) { which = 0; },\n                     ()      { which = -100; })();\n   assert(which == -100);\n ----------------------\n\n Returns: The return type of tryVisit is deduced from the visiting functions and must be\n the same accross all overloads.\n Throws: If no parameter-less, error function is specified: $(D_PARAM VariantException) if\n         $(D_PARAM variant) doesn't hold a value or\n         if $(D_PARAM variant) holds a value which isn't handled by the visiting\n         functions.\n \n",
    "line" : 1717,
    "name" : "tryVisit",
    "parameters" : [
     {
      "name" : "Handler",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "kind" : "template",
      "line" : 1720,
      "name" : "tryVisit",
      "parameters" : [
       {
        "name" : "VariantType",
        "kind" : "type"
       }
      ],
      "members" : [
       {
        "name" : "tryVisit",
        "kind" : "function",
        "line" : 1720,
        "storageClass" : [
         "auto"
        ],
        "type" : "(VariantType variant)",
        "parameters" : [
         {
          "name" : "variant",
          "type" : "VariantType"
         }
        ],
        "endline" : 1724
       }
      ]
     }
    ]
   },
   {
    "name" : "__unittestL1727_2040",
    "kind" : "function",
    "line" : 1727,
    "endline" : 1751
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1751,
    "name" : "isAlgebraic",
    "parameters" : [
     {
      "name" : "Type",
      "kind" : "type"
     }
    ],
    "members" : []
   },
   {
    "name" : "__unittestL1759_2041",
    "kind" : "function",
    "line" : 1759,
    "endline" : 1766
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 1766,
    "name" : "visitImpl",
    "parameters" : [
     {
      "name" : "Strict",
      "kind" : "value",
      "deco" : "b"
     },
     {
      "name" : "VariantType",
      "kind" : "type"
     },
     {
      "name" : "Handler",
      "kind" : "tuple"
     }
    ],
    "members" : [
     {
      "name" : "visitImpl",
      "kind" : "function",
      "line" : 1766,
      "storageClass" : [
       "auto"
      ],
      "type" : "(VariantType variant)",
      "parameters" : [
       {
        "name" : "variant",
        "type" : "VariantType"
       }
      ],
      "endline" : 1873
     }
    ]
   },
   {
    "name" : "__unittestL1875_2042",
    "kind" : "function",
    "line" : 1875,
    "endline" : 1884
   }
  ]
 },
 {
  "name" : "std.xml",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/xml.d",
  "comment" : "\n$(RED Warning: This module is considered out-dated and not up to Phobos'\n      current standards. It will remain until we have a suitable replacement,\n      but be aware that it will not remain long term.)\n\nClasses and functions for creating and parsing XML\n\nThe basic architecture of this module is that there are standalone functions,\nclasses for constructing an XML document from scratch (Tag, Element and\nDocument), and also classes for parsing a pre-existing XML file (ElementParser\nand DocumentParser). The parsing classes <i>may</i> be used to build a\nDocument, but that is not their primary purpose. The handling capabilities of\nDocumentParser and ElementParser are sufficiently customizable that you can\nmake them do pretty much whatever you want.\n\nExample: This example creates a DOM (Document Object Model) tree\n    from an XML file.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\nimport std.file;\n\n// books.xml is used in various samples throughout the Microsoft XML Core\n// Services (MSXML) SDK.\n//\n// See http://msdn2.microsoft.com/en-us/library/ms762271(VS.85).aspx\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    // Check for well-formedness\n    check(s);\n\n    // Make a DOM tree\n    auto doc = new Document(s);\n\n    // Plain-print it\n    writeln(doc);\n}\n------------------------------------------------------------------------------\n\nExample: This example does much the same thing, except that the file is\n    deconstructed and reconstructed by hand. This is more work, but the\n    techniques involved offer vastly more power.\n------------------------------------------------------------------------------\nimport std.xml;\nimport std.stdio;\nimport std.string;\n\nstruct Book\n{\n    string id;\n    string author;\n    string title;\n    string genre;\n    string price;\n    string pubDate;\n    string description;\n}\n\nvoid main()\n{\n    string s = cast(string)std.file.read(\"books.xml\");\n\n    // Check for well-formedness\n    check(s);\n\n    // Take it apart\n    Book[] books;\n\n    auto xml = new DocumentParser(s);\n    xml.onStartTag[\"book\"] = (ElementParser xml)\n    {\n        Book book;\n        book.id = xml.tag.attr[\"id\"];\n\n        xml.onEndTag[\"author\"]       = (in Element e) { book.author      = e.text(); };\n        xml.onEndTag[\"title\"]        = (in Element e) { book.title       = e.text(); };\n        xml.onEndTag[\"genre\"]        = (in Element e) { book.genre       = e.text(); };\n        xml.onEndTag[\"price\"]        = (in Element e) { book.price       = e.text(); };\n        xml.onEndTag[\"publish-date\"] = (in Element e) { book.pubDate     = e.text(); };\n        xml.onEndTag[\"description\"]  = (in Element e) { book.description = e.text(); };\n\n        xml.parse();\n\n        books ~= book;\n    };\n    xml.parse();\n\n    // Put it back together again;\n    auto doc = new Document(new Tag(\"catalog\"));\n    foreach(book;books)\n    {\n        auto element = new Element(\"book\");\n        element.tag.attr[\"id\"] = book.id;\n\n        element ~= new Element(\"author\",      book.author);\n        element ~= new Element(\"title\",       book.title);\n        element ~= new Element(\"genre\",       book.genre);\n        element ~= new Element(\"price\",       book.price);\n        element ~= new Element(\"publish-date\",book.pubDate);\n        element ~= new Element(\"description\", book.description);\n\n        doc ~= element;\n    }\n\n    // Pretty-print it\n    writefln(join(doc.pretty(3),\"\\n\"));\n}\n-------------------------------------------------------------------------------\nMacros:\n    WIKI=Phobos/StdXml\n\nCopyright: Copyright Janice Caron 2008 - 2009.\nLicense:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\nAuthors:   Janice Caron\nSource:    $(PHOBOSSRC std/_xml.d)\n",
  "members" : [
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 131,
    "protection" : "private",
    "selective" : [
     "count",
     "startsWith"
    ]
   },
   {
    "name" : "std.array",
    "kind" : "import",
    "line" : 132,
    "protection" : "private"
   },
   {
    "name" : "std.ascii",
    "kind" : "import",
    "line" : 133,
    "protection" : "private"
   },
   {
    "name" : "std.string",
    "kind" : "import",
    "line" : 134,
    "protection" : "private"
   },
   {
    "name" : "std.encoding",
    "kind" : "import",
    "line" : 135,
    "protection" : "private"
   },
   {
    "name" : "cdata",
    "kind" : "variable",
    "line" : 137,
    "storageClass" : [
     "enum"
    ],
    "deco" : "Aya",
    "init" : "\"<![CDATA[\""
   },
   {
    "name" : "isChar",
    "kind" : "function",
    "comment" : "\n Returns true if the character is a character according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 147,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 169
   },
   {
    "name" : "__unittestL171_2043",
    "kind" : "function",
    "line" : 171,
    "endline" : 214
   },
   {
    "name" : "isSpace",
    "kind" : "function",
    "comment" : "\n Returns true if the character is whitespace according to the XML standard\n\n Only the following characters are considered whitespace in XML - space, tab,\n carriage return and linefeed\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 214,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 217
   },
   {
    "name" : "isDigit",
    "kind" : "function",
    "comment" : "\n Returns true if the character is a digit according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 227,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 233
   },
   {
    "name" : "__unittestL235_2044",
    "kind" : "function",
    "line" : 235,
    "endline" : 252
   },
   {
    "name" : "isLetter",
    "kind" : "function",
    "comment" : "\n Returns true if the character is a letter according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 252,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 255
   },
   {
    "name" : "isIdeographic",
    "kind" : "function",
    "comment" : "\n Returns true if the character is an ideographic character according to the\n XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 266,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 275
   },
   {
    "name" : "__unittestL277_2045",
    "kind" : "function",
    "line" : 277,
    "endline" : 301
   },
   {
    "name" : "isBaseChar",
    "kind" : "function",
    "comment" : "\n Returns true if the character is a base character according to the XML\n standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 301,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 304
   },
   {
    "name" : "isCombiningChar",
    "kind" : "function",
    "comment" : "\n Returns true if the character is a combining character according to the\n XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 315,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 318
   },
   {
    "name" : "isExtender",
    "kind" : "function",
    "comment" : "\n Returns true if the character is an extender according to the XML standard\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n    c = the character to be tested\n \n",
    "line" : 328,
    "deco" : "FwZb",
    "parameters" : [
     {
      "name" : "c",
      "deco" : "w"
     }
    ],
    "endline" : 331
   },
   {
    "kind" : "template",
    "comment" : "\n Encodes a string by replacing all characters which need to be escaped with\n appropriate predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n If the string is not modified, the original will be returned.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be encoded\n\n Returns: The encoded string\n\n Examples:\n --------------\n writefln(encode(\"a > b\")); // writes \"a &gt; b\"\n --------------\n \n",
    "line" : 357,
    "name" : "encode",
    "parameters" : [
     {
      "name" : "S",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "encode",
      "kind" : "function",
      "comment" : "\n Encodes a string by replacing all characters which need to be escaped with\n appropriate predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n If the string is not modified, the original will be returned.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be encoded\n\n Returns: The encoded string\n\n Examples:\n --------------\n writefln(encode(\"a > b\")); // writes \"a &gt; b\"\n --------------\n \n",
      "line" : 357,
      "type" : "S(S s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "S"
       }
      ],
      "endline" : 383
     }
    ]
   },
   {
    "name" : "__unittestL385_2046",
    "kind" : "function",
    "line" : 385,
    "endline" : 403
   },
   {
    "name" : "DecodeMode",
    "kind" : "enum",
    "comment" : "\n Mode to use for decoding.\n\n $(DDOC_ENUM_MEMBERS NONE) Do not decode\n $(DDOC_ENUM_MEMBERS LOOSE) Decode, but ignore errors\n $(DDOC_ENUM_MEMBERS STRICT) Decode, and throw exception on error\n \n",
    "line" : 404,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "NONE",
      "kind" : "enum member",
      "line" : 405
     },
     {
      "name" : "LOOSE",
      "kind" : "enum member",
      "line" : 405
     },
     {
      "name" : "STRICT",
      "kind" : "enum member",
      "line" : 405
     }
    ]
   },
   {
    "name" : "decode",
    "kind" : "function",
    "comment" : "\n Decodes a string by unescaping all predefined XML entities.\n\n encode() escapes certain characters (ampersand, quote, apostrophe, less-than\n and greater-than), and similarly, decode() unescapes them. These functions\n are provided for convenience only. You do not need to use them when using\n the std.xml classes, because then all the encoding and decoding will be done\n for you automatically.\n\n This function decodes the entities &amp;amp;, &amp;quot;, &amp;apos;,\n &amp;lt; and &amp;gt,\n as well as decimal and hexadecimal entities such as &amp;#x20AC;\n\n If the string does not contain an ampersand, the original will be returned.\n\n Note that the \"mode\" parameter can be one of DecodeMode.NONE (do not\n decode), DecodeMode.LOOSE (decode, but ignore errors), or DecodeMode.STRICT\n (decode, and throw a DecodeException in the event of an error).\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Params:\n      s = The string to be decoded\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if mode == DecodeMode.STRICT and decode fails\n\n Returns: The decoded string\n\n Examples:\n --------------\n writefln(decode(\"a &gt; b\")); // writes \"a > b\"\n --------------\n \n",
    "line" : 442,
    "deco" : "FAyaE3std3xml10DecodeModeZAya",
    "originalType" : "string(string s, DecodeMode mode = DecodeMode.LOOSE)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     },
     {
      "name" : "mode",
      "deco" : "E3std3xml10DecodeMode",
      "default" : "cast(DecodeMode)1"
     }
    ],
    "endline" : 492
   },
   {
    "name" : "__unittestL494_2047",
    "kind" : "function",
    "line" : 494,
    "endline" : 536
   },
   {
    "name" : "Document",
    "kind" : "class",
    "comment" : "\n Class representing an XML document.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n \n",
    "line" : 536,
    "base" : "Element",
    "members" : [
     {
      "name" : "prolog",
      "kind" : "variable",
      "comment" : "\n Contains all text which occurs before the root element.\n Defaults to &lt;?xml version=\"1.0\"?&gt;\n     \n",
      "line" : 542,
      "deco" : "Aya",
      "init" : "\"<?xml version=\\\"1.0\\\"?>\"",
      "offset" : 120
     },
     {
      "name" : "epilog",
      "kind" : "variable",
      "comment" : "\n Contains all text which occurs after the root element.\n Defaults to the empty string\n     \n",
      "line" : 547,
      "deco" : "Aya",
      "offset" : 136
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs a Document by parsing XML text.\n\n This function creates a complete DOM (Document Object Model) tree.\n\n The input to this function MUST be valid XML.\n This is enforced by DocumentParser's in contract.\n\n Params:\n      s = the complete XML text.\n     \n",
      "line" : 560,
      "deco" : "FAyaZC3std3xml8Document",
      "originalType" : "(string s)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aya"
       }
      ],
      "endline" : 574
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs a Document from a Tag.\n\n Params:\n      tag = the start tag of the document.\n     \n",
      "line" : 582,
      "deco" : "FxC3std3xml3TagZC3std3xml8Document",
      "originalType" : "(const(Tag) tag)",
      "parameters" : [
       {
        "name" : "tag",
        "deco" : "xC3std3xml3Tag"
       }
      ],
      "endline" : 585
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two Documents for equality\n\n Examples:\n --------------\n Document d1,d2;\n if (d1 == d2) { }\n --------------\n         \n",
      "line" : 598,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFC6ObjectZb",
      "originalType" : "bool(Object o)",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 606,
      "overrides" : [
       "std.xml.Element.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two Documents\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n\n Examples:\n --------------\n Document d1,d2;\n if (d1 < d2) { }\n --------------\n         \n",
      "line" : 620,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFC6ObjectZi",
      "originalType" : "int(Object o)",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 631,
      "overrides" : [
       "std.xml.Element.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of a Document\n\n You should rarely need to call this function. It exists so that\n Documents can be used as associative array keys.\n         \n",
      "line" : 639,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNeZm",
      "originalType" : "@trusted size_t()",
      "endline" : 642,
      "overrides" : [
       "std.xml.Element.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns the string representation of a Document. (That is, the\n complete XML of a document).\n         \n",
      "line" : 648,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 651,
      "overrides" : [
       "std.xml.Element.toString"
      ]
     }
    ]
   },
   {
    "name" : "Element",
    "kind" : "class",
    "comment" : "\n Class representing an XML element.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n \n",
    "line" : 660,
    "base" : "Item",
    "members" : [
     {
      "name" : "tag",
      "kind" : "variable",
      "comment" : " The start tag of the element\n",
      "line" : 662,
      "deco" : "C3std3xml3Tag",
      "originalType" : "Tag",
      "offset" : 16
     },
     {
      "name" : "items",
      "kind" : "variable",
      "comment" : " The element's items\n",
      "line" : 663,
      "deco" : "AC3std3xml4Item",
      "offset" : 24
     },
     {
      "name" : "texts",
      "kind" : "variable",
      "comment" : " The element's text items\n",
      "line" : 664,
      "deco" : "AC3std3xml4Text",
      "offset" : 40
     },
     {
      "name" : "cdatas",
      "kind" : "variable",
      "comment" : " The element's CData items\n",
      "line" : 665,
      "deco" : "AC3std3xml5CData",
      "offset" : 56
     },
     {
      "name" : "comments",
      "kind" : "variable",
      "comment" : " The element's comments\n",
      "line" : 666,
      "deco" : "AC3std3xml7Comment",
      "offset" : 72
     },
     {
      "name" : "pis",
      "kind" : "variable",
      "comment" : " The element's processing instructions\n",
      "line" : 667,
      "deco" : "AC3std3xml21ProcessingInstruction",
      "offset" : 88
     },
     {
      "name" : "elements",
      "kind" : "variable",
      "comment" : " The element's child elements\n",
      "line" : 668,
      "deco" : "AC3std3xml7Element",
      "offset" : 104
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs an Element given a name and a string to be used as a Text\n interior.\n\n Params:\n      name = the name of the element.\n      interior = (optional) the string interior.\n\n Examples:\n -------------------------------------------------------\n auto element = new Element(\"title\",\"Serenity\")\n     // constructs the element <title>Serenity</title>\n -------------------------------------------------------\n     \n",
      "line" : 684,
      "deco" : "FAyaAyaZC3std3xml7Element",
      "originalType" : "(string name, string interior = null)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "interior",
        "deco" : "Aya",
        "default" : "null"
       }
      ],
      "endline" : 688
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs an Element from a Tag.\n\n Params:\n      tag = the start or empty tag of the element.\n     \n",
      "line" : 696,
      "deco" : "FxC3std3xml3TagZC3std3xml7Element",
      "originalType" : "(const(Tag) tag_)",
      "parameters" : [
       {
        "name" : "tag_",
        "deco" : "xC3std3xml3Tag"
       }
      ],
      "endline" : 702
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n Append a text item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new Text(\"hello\");\n --------------\n     \n",
      "line" : 716,
      "deco" : "FC3std3xml4TextZv",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "C3std3xml4Text"
       }
      ],
      "endline" : 720
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n Append a CData item to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new CData(\"hello\");\n --------------\n     \n",
      "line" : 734,
      "deco" : "FC3std3xml5CDataZv",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "C3std3xml5CData"
       }
      ],
      "endline" : 738
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n Append a comment to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new Comment(\"hello\");\n --------------\n     \n",
      "line" : 752,
      "deco" : "FC3std3xml7CommentZv",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "C3std3xml7Comment"
       }
      ],
      "endline" : 756
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n Append a processing instruction to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n element ~= new ProcessingInstruction(\"hello\");\n --------------\n     \n",
      "line" : 770,
      "deco" : "FC3std3xml21ProcessingInstructionZv",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "C3std3xml21ProcessingInstruction"
       }
      ],
      "endline" : 774
     },
     {
      "name" : "opCatAssign",
      "kind" : "function",
      "comment" : "\n Append a complete element to the interior of this element\n\n Params:\n      item = the item you wish to append.\n\n Examples:\n --------------\n Element element;\n Element other = new Element(\"br\");\n element ~= other;\n    // appends element representing <br />\n --------------\n     \n",
      "line" : 790,
      "deco" : "FC3std3xml7ElementZv",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "C3std3xml7Element"
       }
      ],
      "endline" : 794
     },
     {
      "name" : "appendItem",
      "kind" : "function",
      "protection" : "private",
      "line" : 796,
      "deco" : "FC3std3xml4ItemZv",
      "parameters" : [
       {
        "name" : "item",
        "deco" : "C3std3xml4Item"
       }
      ],
      "endline" : 801
     },
     {
      "name" : "parse",
      "kind" : "function",
      "protection" : "private",
      "line" : 803,
      "deco" : "FC3std3xml13ElementParserZv",
      "parameters" : [
       {
        "name" : "xml",
        "deco" : "C3std3xml13ElementParser"
       }
      ],
      "endline" : 818
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two Elements for equality\n\n Examples:\n --------------\n Element e1,e2;\n if (e1 == e2) { }\n --------------\n     \n",
      "line" : 829,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 839,
      "overrides" : [
       "std.xml.Item.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two Elements\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n\n Examples:\n --------------\n Element e1,e2;\n if (e1 < e2) { }\n --------------\n     \n",
      "line" : 853,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 864,
      "overrides" : [
       "std.xml.Item.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of an Element\n\n You should rarely need to call this function. It exists so that Elements\n can be used as associative array keys.\n     \n",
      "line" : 872,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 877,
      "overrides" : [
       "std.xml.Item.toHash"
      ]
     },
     {
      "name" : "text",
      "kind" : "function",
      "comment" : "\n Returns the decoded interior of an element.\n\n The element is assumed to containt text <i>only</i>. So, for\n example, given XML such as \"&lt;title&gt;Good &amp;amp;\n Bad&lt;/title&gt;\", will return \"Good &amp; Bad\".\n\n Params:\n      mode = (optional) Mode to use for decoding. (Defaults to LOOSE).\n\n Throws: DecodeException if decode fails\n         \n",
      "line" : 893,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFE3std3xml10DecodeModeZAya",
      "originalType" : "string(DecodeMode mode = DecodeMode.LOOSE)",
      "parameters" : [
       {
        "name" : "mode",
        "deco" : "E3std3xml10DecodeMode",
        "default" : "cast(DecodeMode)1"
       }
      ],
      "endline" : 903
     },
     {
      "name" : "pretty",
      "kind" : "function",
      "comment" : "\n Returns an indented string representation of this item\n\n Params:\n      indent = (optional) number of spaces by which to indent this\n          element. Defaults to 2.\n         \n",
      "line" : 912,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFkZAAya",
      "originalType" : "string[](uint indent = 2)",
      "parameters" : [
       {
        "name" : "indent",
        "deco" : "k",
        "default" : "2u"
       }
      ],
      "endline" : 937,
      "overrides" : [
       "std.xml.Item.pretty"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns the string representation of an Element\n\n Examples:\n --------------\n auto element = new Element(\"br\");\n writefln(element.toString()); // writes \"<br />\"\n --------------\n         \n",
      "line" : 948,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 956,
      "overrides" : [
       "std.xml.Item.toString"
      ]
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "line" : 958,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 958,
      "overrides" : [
       "std.xml.Item.isEmptyXML"
      ]
     }
    ]
   },
   {
    "name" : "TagType",
    "kind" : "enum",
    "comment" : "\n Tag types.\n\n $(DDOC_ENUM_MEMBERS START) Used for start tags\n $(DDOC_ENUM_MEMBERS END) Used for end tags\n $(DDOC_ENUM_MEMBERS EMPTY) Used for empty tags\n\n \n",
    "line" : 970,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "START",
      "kind" : "enum member",
      "line" : 970
     },
     {
      "name" : "END",
      "kind" : "enum member",
      "line" : 970
     },
     {
      "name" : "EMPTY",
      "kind" : "enum member",
      "line" : 970
     }
    ]
   },
   {
    "name" : "Tag",
    "kind" : "class",
    "comment" : "\n Class representing an XML tag.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n The class invariant guarantees\n <ul>\n <li> that $(B type) is a valid enum TagType value</li>\n <li> that $(B name) consists of valid characters</li>\n <li> that each attribute name consists of valid characters</li>\n </ul>\n \n",
    "line" : 985,
    "members" : [
     {
      "name" : "type",
      "kind" : "variable",
      "comment" : " Type of tag\n",
      "line" : 986,
      "deco" : "E3std3xml7TagType",
      "init" : "cast(TagType)0",
      "offset" : 16
     },
     {
      "name" : "name",
      "kind" : "variable",
      "comment" : " Tag name\n",
      "line" : 987,
      "deco" : "Aya",
      "offset" : 24
     },
     {
      "name" : "attr",
      "kind" : "variable",
      "comment" : " Associative array of attributes\n",
      "line" : 988,
      "deco" : "HAyaAya",
      "offset" : 40
     },
     {
      "name" : "tagString",
      "kind" : "variable",
      "protection" : "private",
      "line" : 989,
      "deco" : "Aya",
      "offset" : 48
     },
     {
      "name" : "__invariant29",
      "kind" : "function",
      "line" : 991,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs an instance of Tag with a specified name and type\n\n The constructor does not initialize the attributes. To initialize the\n attributes, you access the $(B attr) member variable.\n\n Params:\n      name = the Tag's name\n      type = (optional) the Tag's type. If omitted, defaults to\n          TagType.START.\n\n Examples:\n --------------\n auto tag = new Tag(\"img\",Tag.EMPTY);\n tag.attr[\"src\"] = \"http://example.com/example.jpg\";\n --------------\n     \n",
      "line" : 1030,
      "deco" : "FAyaE3std3xml7TagTypeZC3std3xml3Tag",
      "originalType" : "(string name, TagType type = TagType.START)",
      "parameters" : [
       {
        "name" : "name",
        "deco" : "Aya"
       },
       {
        "name" : "type",
        "deco" : "E3std3xml7TagType",
        "default" : "cast(TagType)0"
       }
      ],
      "endline" : 1034
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 1046,
      "deco" : "FKAyabZC3std3xml3Tag",
      "originalType" : "(ref string s, bool dummy)",
      "parameters" : [
       {
        "name" : "s",
        "deco" : "Aya",
        "storageClass" : [
         "ref"
        ]
       },
       {
        "name" : "dummy",
        "deco" : "b"
       }
      ],
      "endline" : 1080
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two Tags for equality\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n\n Examples:\n --------------\n Tag tag1,tag2\n if (tag1 == tag2) { }\n --------------\n         \n",
      "line" : 1096,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFC6ObjectZb",
      "originalType" : "bool(Object o)",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1104,
      "overrides" : [
       "object.Object.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two Tags\n\n Examples:\n --------------\n Tag tag1,tag2\n if (tag1 < tag2) { }\n --------------\n         \n",
      "line" : 1115,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFC6ObjectZi",
      "originalType" : "int(Object o)",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1123,
      "overrides" : [
       "object.Object.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of a Tag\n\n You should rarely need to call this function. It exists so that Tags\n can be used as associative array keys.\n         \n",
      "line" : 1131,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 1134,
      "overrides" : [
       "object.Object.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns the string representation of a Tag\n\n Examples:\n --------------\n auto tag = new Tag(\"book\",TagType.START);\n writefln(tag.toString()); // writes \"<book>\"\n --------------\n         \n",
      "line" : 1145,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1149,
      "overrides" : [
       "object.Object.toString"
      ]
     },
     {
      "name" : "toNonEndString",
      "kind" : "function",
      "protection" : "private",
      "line" : 1153,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1159
     },
     {
      "name" : "toStartString",
      "kind" : "function",
      "protection" : "private",
      "line" : 1161,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1161
     },
     {
      "name" : "toEndString",
      "kind" : "function",
      "protection" : "private",
      "line" : 1163,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1163
     },
     {
      "name" : "toEmptyString",
      "kind" : "function",
      "protection" : "private",
      "line" : 1165,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1165
     },
     {
      "name" : "isStart",
      "kind" : "function",
      "comment" : "\n Returns true if the Tag is a start tag\n\n Examples:\n --------------\n if (tag.isStart) { }\n --------------\n         \n",
      "line" : 1176,
      "storageClass" : [
       "const",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1176
     },
     {
      "name" : "isEnd",
      "kind" : "function",
      "comment" : "\n Returns true if the Tag is an end tag\n\n Examples:\n --------------\n if (tag.isEnd) { }\n --------------\n         \n",
      "line" : 1186,
      "storageClass" : [
       "const",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1186
     },
     {
      "name" : "isEmpty",
      "kind" : "function",
      "comment" : "\n Returns true if the Tag is an empty tag\n\n Examples:\n --------------\n if (tag.isEmpty) { }\n --------------\n         \n",
      "line" : 1196,
      "storageClass" : [
       "const",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1196
     },
     {
      "name" : "__invariant",
      "kind" : "function",
      "line" : 985,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFZv",
      "originalType" : "void()"
     }
    ]
   },
   {
    "name" : "Comment",
    "kind" : "class",
    "comment" : "\n Class representing a comment\n \n",
    "line" : 1203,
    "base" : "Item",
    "members" : [
     {
      "name" : "content",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1205,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a comment\n\n Params:\n      content = the body of the comment\n\n Throws: CommentException if the comment body is illegal (contains \"--\"\n or exactly equals \"-\")\n\n Examples:\n --------------\n auto item = new Comment(\"This is a comment\");\n    // constructs <!--This is a comment-->\n --------------\n     \n",
      "line" : 1222,
      "deco" : "FAyaZC3std3xml7Comment",
      "originalType" : "(string content)",
      "parameters" : [
       {
        "name" : "content",
        "deco" : "Aya"
       }
      ],
      "endline" : 1227
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two comments for equality\n\n Examples:\n --------------\n Comment item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
      "line" : 1238,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1243,
      "overrides" : [
       "std.xml.Item.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two comments\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n\n Examples:\n --------------\n Comment item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
      "line" : 1257,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1263,
      "overrides" : [
       "std.xml.Item.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of a Comment\n\n You should rarely need to call this function. It exists so that Comments\n can be used as associative array keys.\n     \n",
      "line" : 1271,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 1271,
      "overrides" : [
       "std.xml.Item.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns a string representation of this comment\n     \n",
      "line" : 1276,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1276,
      "overrides" : [
       "std.xml.Item.toString"
      ]
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "comment" : " Returns false always\n",
      "line" : 1278,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1278,
      "overrides" : [
       "std.xml.Item.isEmptyXML"
      ]
     }
    ]
   },
   {
    "name" : "CData",
    "kind" : "class",
    "comment" : "\n Class representing a Character Data section\n \n",
    "line" : 1284,
    "base" : "Item",
    "members" : [
     {
      "name" : "content",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1286,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a chraracter data section\n\n Params:\n      content = the body of the character data segment\n\n Throws: CDataException if the segment body is illegal (contains \"]]>\")\n\n Examples:\n --------------\n auto item = new CData(\"<b>hello</b>\");\n    // constructs <![CDATA[<b>hello</b>]]>\n --------------\n     \n",
      "line" : 1302,
      "deco" : "FAyaZC3std3xml5CData",
      "originalType" : "(string content)",
      "parameters" : [
       {
        "name" : "content",
        "deco" : "Aya"
       }
      ],
      "endline" : 1306
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two CDatas for equality\n\n Examples:\n --------------\n CData item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
      "line" : 1317,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1322,
      "overrides" : [
       "std.xml.Item.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two CDatas\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n\n Examples:\n --------------\n CData item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
      "line" : 1336,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1342,
      "overrides" : [
       "std.xml.Item.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of a CData\n\n You should rarely need to call this function. It exists so that CDatas\n can be used as associative array keys.\n     \n",
      "line" : 1350,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 1350,
      "overrides" : [
       "std.xml.Item.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns a string representation of this CData section\n     \n",
      "line" : 1355,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1355,
      "overrides" : [
       "std.xml.Item.toString"
      ]
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "comment" : " Returns false always\n",
      "line" : 1357,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1357,
      "overrides" : [
       "std.xml.Item.isEmptyXML"
      ]
     }
    ]
   },
   {
    "name" : "Text",
    "kind" : "class",
    "comment" : "\n Class representing a text (aka Parsed Character Data) section\n \n",
    "line" : 1363,
    "base" : "Item",
    "members" : [
     {
      "name" : "content",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1365,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a text (aka PCData) section\n\n Params:\n      content = the text. This function encodes the text before\n      insertion, so it is safe to insert any text\n\n Examples:\n --------------\n auto Text = new CData(\"a < b\");\n    // constructs a &lt; b\n --------------\n     \n",
      "line" : 1380,
      "deco" : "FAyaZC3std3xml4Text",
      "originalType" : "(string content)",
      "parameters" : [
       {
        "name" : "content",
        "deco" : "Aya"
       }
      ],
      "endline" : 1383
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two text sections for equality\n\n Examples:\n --------------\n Text item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
      "line" : 1394,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1399,
      "overrides" : [
       "std.xml.Item.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two text sections\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n\n Examples:\n --------------\n Text item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
      "line" : 1413,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1419,
      "overrides" : [
       "std.xml.Item.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of a text section\n\n You should rarely need to call this function. It exists so that Texts\n can be used as associative array keys.\n     \n",
      "line" : 1427,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 1427,
      "overrides" : [
       "std.xml.Item.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns a string representation of this Text section\n     \n",
      "line" : 1432,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1432,
      "overrides" : [
       "std.xml.Item.toString"
      ]
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "comment" : "\n Returns true if the content is the empty string\n     \n",
      "line" : 1437,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1437,
      "overrides" : [
       "std.xml.Item.isEmptyXML"
      ]
     }
    ]
   },
   {
    "name" : "XMLInstruction",
    "kind" : "class",
    "comment" : "\n Class representing an XML Instruction section\n \n",
    "line" : 1443,
    "base" : "Item",
    "members" : [
     {
      "name" : "content",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1445,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct an XML Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: XIException if the segment body is illegal (contains \">\")\n\n Examples:\n --------------\n auto item = new XMLInstruction(\"ATTLIST\");\n    // constructs <!ATTLIST>\n --------------\n     \n",
      "line" : 1461,
      "deco" : "FAyaZC3std3xml14XMLInstruction",
      "originalType" : "(string content)",
      "parameters" : [
       {
        "name" : "content",
        "deco" : "Aya"
       }
      ],
      "endline" : 1465
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two XML instructions for equality\n\n Examples:\n --------------\n XMLInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
      "line" : 1476,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1481,
      "overrides" : [
       "std.xml.Item.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two XML instructions\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n\n Examples:\n --------------\n XMLInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
      "line" : 1495,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1501,
      "overrides" : [
       "std.xml.Item.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of an XMLInstruction\n\n You should rarely need to call this function. It exists so that\n XmlInstructions can be used as associative array keys.\n     \n",
      "line" : 1509,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 1509,
      "overrides" : [
       "std.xml.Item.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns a string representation of this XmlInstruction\n     \n",
      "line" : 1514,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1514,
      "overrides" : [
       "std.xml.Item.toString"
      ]
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "comment" : " Returns false always\n",
      "line" : 1516,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1516,
      "overrides" : [
       "std.xml.Item.isEmptyXML"
      ]
     }
    ]
   },
   {
    "name" : "ProcessingInstruction",
    "kind" : "class",
    "comment" : "\n Class representing a Processing Instruction section\n \n",
    "line" : 1522,
    "base" : "Item",
    "members" : [
     {
      "name" : "content",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1524,
      "deco" : "Aya",
      "offset" : 16
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct a Processing Instruction section\n\n Params:\n      content = the body of the instruction segment\n\n Throws: PIException if the segment body is illegal (contains \"?>\")\n\n Examples:\n --------------\n auto item = new ProcessingInstruction(\"php\");\n    // constructs <?php?>\n --------------\n     \n",
      "line" : 1540,
      "deco" : "FAyaZC3std3xml21ProcessingInstruction",
      "originalType" : "(string content)",
      "parameters" : [
       {
        "name" : "content",
        "deco" : "Aya"
       }
      ],
      "endline" : 1544
     },
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : "\n Compares two processing instructions for equality\n\n Examples:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 == item2) { }\n --------------\n     \n",
      "line" : 1555,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1560,
      "overrides" : [
       "std.xml.Item.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : "\n Compares two processing instructions\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n\n Examples:\n --------------\n ProcessingInstruction item1,item2;\n if (item1 < item2) { }\n --------------\n     \n",
      "line" : 1574,
      "storageClass" : [
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "endline" : 1580,
      "overrides" : [
       "std.xml.Item.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : "\n Returns the hash of a ProcessingInstruction\n\n You should rarely need to call this function. It exists so that\n ProcessingInstructions can be used as associative array keys.\n     \n",
      "line" : 1588,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "endline" : 1588,
      "overrides" : [
       "std.xml.Item.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns a string representation of this ProcessingInstruction\n     \n",
      "line" : 1593,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 1593,
      "overrides" : [
       "std.xml.Item.toString"
      ]
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "comment" : " Returns false always\n",
      "line" : 1595,
      "storageClass" : [
       "const",
       "override",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()",
      "endline" : 1595,
      "overrides" : [
       "std.xml.Item.isEmptyXML"
      ]
     }
    ]
   },
   {
    "name" : "Item",
    "kind" : "class",
    "comment" : "\n Abstract base class for XML items\n \n",
    "line" : 1602,
    "members" : [
     {
      "name" : "opEquals",
      "kind" : "function",
      "comment" : " Compares with another Item of same type for equality\n",
      "line" : 1604,
      "storageClass" : [
       "abstract",
       "override"
      ],
      "deco" : "FC6ObjectZb",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "overrides" : [
       "object.Object.opEquals"
      ]
     },
     {
      "name" : "opCmp",
      "kind" : "function",
      "comment" : " Compares with another Item of same type\n",
      "line" : 1607,
      "storageClass" : [
       "abstract",
       "override"
      ],
      "deco" : "FC6ObjectZi",
      "parameters" : [
       {
        "name" : "o",
        "deco" : "C6Object"
       }
      ],
      "overrides" : [
       "object.Object.opCmp"
      ]
     },
     {
      "name" : "toHash",
      "kind" : "function",
      "comment" : " Returns the hash of this item\n",
      "line" : 1610,
      "storageClass" : [
       "const",
       "abstract",
       "override"
      ],
      "deco" : "xFNbNfZm",
      "originalType" : "size_t()",
      "overrides" : [
       "object.Object.toHash"
      ]
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : " Returns a string representation of this item\n",
      "line" : 1613,
      "storageClass" : [
       "const",
       "abstract",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "overrides" : [
       "object.Object.toString"
      ]
     },
     {
      "name" : "pretty",
      "kind" : "function",
      "comment" : "\n Returns an indented string representation of this item\n\n Params:\n      indent = number of spaces by which to indent child elements\n     \n",
      "line" : 1621,
      "storageClass" : [
       "const"
      ],
      "deco" : "xFkZAAya",
      "originalType" : "string[](uint indent)",
      "parameters" : [
       {
        "name" : "indent",
        "deco" : "k"
       }
      ],
      "endline" : 1625
     },
     {
      "name" : "isEmptyXML",
      "kind" : "function",
      "comment" : " Returns true if the item represents empty XML text\n",
      "line" : 1628,
      "storageClass" : [
       "const",
       "abstract",
       "@property"
      ],
      "deco" : "xFNdZb",
      "originalType" : "bool()"
     }
    ]
   },
   {
    "name" : "DocumentParser",
    "kind" : "class",
    "comment" : "\n Class for parsing an XML Document.\n\n This is a subclass of ElementParser. Most of the useful functions are\n documented there.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Bugs:\n      Currently only supports UTF documents.\n\n      If there is an encoding attribute in the prolog, it is ignored.\n\n \n",
    "line" : 1645,
    "base" : "ElementParser",
    "members" : [
     {
      "name" : "xmlText",
      "kind" : "variable",
      "line" : 1647,
      "deco" : "Aya",
      "offset" : 160
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructs a DocumentParser.\n\n The input to this function MUST be valid XML.\n This is enforced by the function's in contract.\n\n Params:\n      xmltext = the entire XML document as text\n\n     \n",
      "line" : 1659,
      "deco" : "FAyaZC3std3xml14DocumentParser",
      "originalType" : "(string xmlText_)",
      "parameters" : [
       {
        "name" : "xmlText_",
        "deco" : "Aya"
       }
      ],
      "endline" : 1680
     }
    ]
   },
   {
    "name" : "ElementParser",
    "kind" : "class",
    "comment" : "\n Class for parsing an XML element.\n\n Standards: $(LINK2 http://www.w3.org/TR/1998/REC-xml-19980210, XML 1.0)\n\n Note that you cannot construct instances of this class directly. You can\n construct a DocumentParser (which is a subclass of ElementParser), but\n otherwise, Instances of ElementParser will be created for you by the\n library, and passed your way via onStartTag handlers.\n\n \n",
    "line" : 1695,
    "members" : [
     {
      "name" : "Handler",
      "kind" : "alias",
      "line" : 1696,
      "deco" : "DFAyaZv"
     },
     {
      "name" : "ElementHandler",
      "kind" : "alias",
      "line" : 1697,
      "deco" : "DFxC3std3xml7ElementZv"
     },
     {
      "name" : "ParserHandler",
      "kind" : "alias",
      "line" : 1698,
      "deco" : "DFC3std3xml13ElementParserZv"
     },
     {
      "name" : "tag_",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1702,
      "deco" : "C3std3xml3Tag",
      "originalType" : "Tag",
      "offset" : 16
     },
     {
      "name" : "elementStart",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1703,
      "deco" : "Aya",
      "offset" : 24
     },
     {
      "name" : "s",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1704,
      "deco" : "PAya",
      "offset" : 40
     },
     {
      "name" : "commentHandler",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1706,
      "deco" : "DFAyaZv",
      "originalType" : "Handler",
      "init" : "null",
      "offset" : 48
     },
     {
      "name" : "cdataHandler",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1707,
      "deco" : "DFAyaZv",
      "originalType" : "Handler",
      "init" : "null",
      "offset" : 64
     },
     {
      "name" : "xiHandler",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1708,
      "deco" : "DFAyaZv",
      "originalType" : "Handler",
      "init" : "null",
      "offset" : 80
     },
     {
      "name" : "piHandler",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1709,
      "deco" : "DFAyaZv",
      "originalType" : "Handler",
      "init" : "null",
      "offset" : 96
     },
     {
      "name" : "rawTextHandler",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1710,
      "deco" : "DFAyaZv",
      "originalType" : "Handler",
      "init" : "null",
      "offset" : 112
     },
     {
      "name" : "textHandler",
      "kind" : "variable",
      "protection" : "private",
      "line" : 1711,
      "deco" : "DFAyaZv",
      "originalType" : "Handler",
      "init" : "null",
      "offset" : 128
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 1714,
      "deco" : "FC3std3xml13ElementParserZC3std3xml13ElementParser",
      "originalType" : "(ElementParser parent)",
      "parameters" : [
       {
        "name" : "parent",
        "deco" : "C3std3xml13ElementParser"
       }
      ],
      "endline" : 1719
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 1722,
      "deco" : "FC3std3xml3TagPAyaZC3std3xml13ElementParser",
      "originalType" : "(Tag tag, string* t)",
      "parameters" : [
       {
        "name" : "tag",
        "deco" : "C3std3xml3Tag"
       },
       {
        "name" : "t",
        "deco" : "PAya"
       }
      ],
      "endline" : 1727
     },
     {
      "name" : "tag",
      "kind" : "function",
      "comment" : "\n The Tag at the start of the element being parsed. You can read this to\n determine the tag's name and attributes.\n     \n",
      "line" : 1734,
      "storageClass" : [
       "const",
       "@property"
      ],
      "deco" : "xFNdZxC3std3xml3Tag",
      "originalType" : "const(Tag)()",
      "endline" : 1734
     },
     {
      "name" : "onStartTag",
      "kind" : "variable",
      "comment" : "\n Register a handler which will be called whenever a start tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n start tag.\n\n Examples:\n --------------\n // Call this function whenever a <podcast> start tag is encountered\n onStartTag[\"podcast\"] = (ElementParser xml)\n {\n     // Your code here\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n\n // call myEpisodeStartHandler (defined elsewhere) whenever an <episode>\n // start tag is encountered\n onStartTag[\"episode\"] = &myEpisodeStartHandler;\n\n // call delegate dg for all other start tags\n onStartTag[null] = dg;\n --------------\n\n This library will supply your function with a new instance of\n ElementHandler, which may be used to parse inside the element whose\n start tag was just found, or to identify the tag attributes of the\n element, etc.\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt;\n and &lt;br/&gt;.\n     \n",
      "line" : 1770,
      "deco" : "HAyaDFC3std3xml13ElementParserZv",
      "originalType" : "ParserHandler[string]",
      "offset" : 144
     },
     {
      "name" : "onEndTag",
      "kind" : "variable",
      "comment" : "\n Register a handler which will be called whenever an end tag is\n encountered which matches the specified name. You can also pass null as\n the name, in which case the handler will be called for any unmatched\n end tag.\n\n Examples:\n --------------\n // Call this function whenever a </podcast> end tag is encountered\n onEndTag[\"podcast\"] = (in Element e)\n {\n     // Your code here\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n\n // call myEpisodeEndHandler (defined elsewhere) whenever an </episode>\n // end tag is encountered\n onEndTag[\"episode\"] = &myEpisodeEndHandler;\n\n // call delegate dg for all other end tags\n onEndTag[null] = dg;\n --------------\n\n Note that your function will be called for both start tags and empty\n tags. That is, we make no distinction between &lt;br&gt;&lt;/br&gt;\n and &lt;br/&gt;.\n     \n",
      "line" : 1801,
      "deco" : "HAyaDFxC3std3xml7ElementZv",
      "originalType" : "ElementHandler[string]",
      "offset" : 152
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "protected",
      "line" : 1803,
      "deco" : "FZC3std3xml13ElementParser",
      "originalType" : "()",
      "endline" : 1806
     },
     {
      "name" : "onText",
      "kind" : "function",
      "comment" : "\n Register a handler which will be called whenever text is encountered.\n\n Examples:\n --------------\n // Call this function whenever text is encountered\n onText = (string s)\n {\n     // Your code here\n\n     // The passed parameter s will have been decoded by the time you see\n     // it, and so may contain any character.\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n     \n",
      "line" : 1826,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdDFAyaZvZv",
      "originalType" : "void(Handler handler)",
      "parameters" : [
       {
        "name" : "handler",
        "deco" : "DFAyaZv"
       }
      ],
      "endline" : 1826
     },
     {
      "name" : "onTextRaw",
      "kind" : "function",
      "comment" : "\n Register an alternative handler which will be called whenever text\n is encountered. This differs from onText in that onText will decode\n the text, wheras onTextRaw will not. This allows you to make design\n choices, since onText will be more accurate, but slower, while\n onTextRaw will be faster, but less accurate. Of course, you can\n still call decode() within your handler, if you want, but you'd\n probably want to use onTextRaw only in circumstances where you\n know that decoding is unnecessary.\n\n Examples:\n --------------\n // Call this function whenever text is encountered\n onText = (string s)\n {\n     // Your code here\n\n     // The passed parameter s will NOT have been decoded.\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n     \n",
      "line" : 1852,
      "deco" : "FDFAyaZvZv",
      "originalType" : "void(Handler handler)",
      "parameters" : [
       {
        "name" : "handler",
        "deco" : "DFAyaZv"
       }
      ],
      "endline" : 1852
     },
     {
      "name" : "onCData",
      "kind" : "function",
      "comment" : "\n Register a handler which will be called whenever a character data\n segement is encountered.\n\n Examples:\n --------------\n // Call this function whenever a CData section is encountered\n onCData = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <![CDATA[\n     // nor closing ]]>\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n     \n",
      "line" : 1873,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdDFAyaZvZv",
      "originalType" : "void(Handler handler)",
      "parameters" : [
       {
        "name" : "handler",
        "deco" : "DFAyaZv"
       }
      ],
      "endline" : 1873
     },
     {
      "name" : "onComment",
      "kind" : "function",
      "comment" : "\n Register a handler which will be called whenever a comment is\n encountered.\n\n Examples:\n --------------\n // Call this function whenever a comment is encountered\n onComment = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <!-- nor\n     // closing -->\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n     \n",
      "line" : 1894,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdDFAyaZvZv",
      "originalType" : "void(Handler handler)",
      "parameters" : [
       {
        "name" : "handler",
        "deco" : "DFAyaZv"
       }
      ],
      "endline" : 1894
     },
     {
      "name" : "onPI",
      "kind" : "function",
      "comment" : "\n Register a handler which will be called whenever a processing\n instruction is encountered.\n\n Examples:\n --------------\n // Call this function whenever a processing instruction is encountered\n onPI = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <? nor\n     // closing ?>\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n     \n",
      "line" : 1915,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdDFAyaZvZv",
      "originalType" : "void(Handler handler)",
      "parameters" : [
       {
        "name" : "handler",
        "deco" : "DFAyaZv"
       }
      ],
      "endline" : 1915
     },
     {
      "name" : "onXI",
      "kind" : "function",
      "comment" : "\n Register a handler which will be called whenever an XML instruction is\n encountered.\n\n Examples:\n --------------\n // Call this function whenever an XML instruction is encountered\n // (Note: XML instructions may only occur preceeding the root tag of a\n // document).\n onPI = (string s)\n {\n     // Your code here\n\n     // The passed parameter s does not include the opening <! nor\n     // closing >\n     //\n     // This is a a closure, so code here may reference\n     // variables which are outside of this scope\n };\n --------------\n     \n",
      "line" : 1938,
      "storageClass" : [
       "@property"
      ],
      "deco" : "FNdDFAyaZvZv",
      "originalType" : "void(Handler handler)",
      "parameters" : [
       {
        "name" : "handler",
        "deco" : "DFAyaZv"
       }
      ],
      "endline" : 1938
     },
     {
      "name" : "parse",
      "kind" : "function",
      "comment" : "\n Parse an XML element.\n\n Parsing will continue until the end of the current element. Any items\n encountered for which a handler has been registered will invoke that\n handler.\n\n Throws: various kinds of XMLException\n     \n",
      "line" : 1949,
      "deco" : "FZv",
      "endline" : 2070
     },
     {
      "name" : "toString",
      "kind" : "function",
      "comment" : "\n Returns that part of the element which has already been parsed\n     \n",
      "line" : 2075,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2079,
      "overrides" : [
       "object.Object.toString"
      ]
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2085,
    "name" : "Check",
    "parameters" : [
     {
      "name" : "msg",
      "kind" : "value",
      "deco" : "Aya"
     }
    ],
    "members" : [
     {
      "name" : "old",
      "kind" : "variable",
      "line" : 2087,
      "type" : "string",
      "init" : "s"
     },
     {
      "name" : "fail",
      "kind" : "function",
      "line" : 2089,
      "type" : "void()",
      "endline" : 2093
     },
     {
      "name" : "fail",
      "kind" : "function",
      "line" : 2095,
      "type" : "void(Err e)",
      "parameters" : [
       {
        "name" : "e",
        "type" : "Err"
       }
      ],
      "endline" : 2099
     },
     {
      "name" : "fail",
      "kind" : "function",
      "line" : 2101,
      "type" : "void(string msg2)",
      "parameters" : [
       {
        "name" : "msg2",
        "type" : "string"
       }
      ],
      "endline" : 2104
     }
    ]
   },
   {
    "name" : "checkMisc",
    "kind" : "function",
    "protection" : "private",
    "line" : 2107,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2118
   },
   {
    "name" : "checkDocument",
    "kind" : "function",
    "protection" : "private",
    "line" : 2120,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2130
   },
   {
    "name" : "checkChars",
    "kind" : "function",
    "protection" : "private",
    "line" : 2132,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2155
   },
   {
    "name" : "checkSpace",
    "kind" : "function",
    "protection" : "private",
    "line" : 2157,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2162
   },
   {
    "name" : "checkName",
    "kind" : "function",
    "protection" : "private",
    "line" : 2164,
    "deco" : "FKAyaJAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "name",
      "deco" : "Aya",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 2181
   },
   {
    "name" : "checkAttValue",
    "kind" : "function",
    "protection" : "private",
    "line" : 2183,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2201
   },
   {
    "name" : "checkCharData",
    "kind" : "function",
    "protection" : "private",
    "line" : 2203,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2214
   },
   {
    "name" : "checkComment",
    "kind" : "function",
    "protection" : "private",
    "line" : 2216,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2225
   },
   {
    "name" : "checkPI",
    "kind" : "function",
    "protection" : "private",
    "line" : 2227,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2237
   },
   {
    "name" : "checkCDSect",
    "kind" : "function",
    "protection" : "private",
    "line" : 2239,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2249
   },
   {
    "name" : "checkProlog",
    "kind" : "function",
    "protection" : "private",
    "line" : 2251,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2266
   },
   {
    "name" : "checkXMLDecl",
    "kind" : "function",
    "protection" : "private",
    "line" : 2268,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2282
   },
   {
    "name" : "checkVersionInfo",
    "kind" : "function",
    "protection" : "private",
    "line" : 2284,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2296
   },
   {
    "name" : "checkEq",
    "kind" : "function",
    "protection" : "private",
    "line" : 2298,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2309
   },
   {
    "name" : "checkVersionNum",
    "kind" : "function",
    "protection" : "private",
    "line" : 2311,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2317
   },
   {
    "name" : "checkDocTypeDecl",
    "kind" : "function",
    "protection" : "private",
    "line" : 2319,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2333
   },
   {
    "name" : "checkSDDecl",
    "kind" : "function",
    "protection" : "private",
    "line" : 2335,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2353
   },
   {
    "name" : "checkElement",
    "kind" : "function",
    "protection" : "private",
    "line" : 2355,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2379
   },
   {
    "name" : "checkTag",
    "kind" : "function",
    "protection" : "private",
    "line" : 2382,
    "deco" : "FKAyaJAyaJAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "type",
      "deco" : "Aya",
      "storageClass" : [
       "out"
      ]
     },
     {
      "name" : "name",
      "deco" : "Aya",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 2401
   },
   {
    "name" : "checkAttribute",
    "kind" : "function",
    "protection" : "private",
    "line" : 2403,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2415
   },
   {
    "name" : "checkETag",
    "kind" : "function",
    "protection" : "private",
    "line" : 2417,
    "deco" : "FKAyaJAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "name",
      "deco" : "Aya",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 2429
   },
   {
    "name" : "checkContent",
    "kind" : "function",
    "protection" : "private",
    "line" : 2431,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2450
   },
   {
    "name" : "checkCharRef",
    "kind" : "function",
    "protection" : "private",
    "line" : 2452,
    "deco" : "FKAyaJwZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "w",
      "storageClass" : [
       "out"
      ]
     }
    ],
    "endline" : 2499
   },
   {
    "name" : "checkReference",
    "kind" : "function",
    "protection" : "private",
    "line" : 2501,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2512
   },
   {
    "name" : "checkEntityRef",
    "kind" : "function",
    "protection" : "private",
    "line" : 2514,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2526
   },
   {
    "name" : "checkEncName",
    "kind" : "function",
    "protection" : "private",
    "line" : 2528,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2535
   },
   {
    "name" : "checkEncodingDecl",
    "kind" : "function",
    "protection" : "private",
    "line" : 2537,
    "deco" : "FKAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2549
   },
   {
    "name" : "checkLiteral",
    "kind" : "function",
    "protection" : "private",
    "line" : 2553,
    "deco" : "FAyaKAyaZv",
    "parameters" : [
     {
      "name" : "literal",
      "deco" : "Aya"
     },
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2559
   },
   {
    "name" : "checkEnd",
    "kind" : "function",
    "protection" : "private",
    "line" : 2561,
    "deco" : "FAyaKAyaZv",
    "parameters" : [
     {
      "name" : "end",
      "deco" : "Aya"
     },
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     }
    ],
    "endline" : 2569
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2573,
    "name" : "opt",
    "parameters" : [
     {
      "name" : "f",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "opt",
      "kind" : "function",
      "line" : 2573,
      "type" : "void(ref string s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "string",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2576
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2578,
    "name" : "plus",
    "parameters" : [
     {
      "name" : "f",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "plus",
      "kind" : "function",
      "line" : 2578,
      "type" : "void(ref string s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "string",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2582
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2584,
    "name" : "star",
    "parameters" : [
     {
      "name" : "f",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "star",
      "kind" : "function",
      "line" : 2584,
      "type" : "void(ref string s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "string",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2591
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2593,
    "name" : "quoted",
    "parameters" : [
     {
      "name" : "f",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "quoted",
      "kind" : "function",
      "line" : 2593,
      "type" : "void(ref string s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "string",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2607
     }
    ]
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2609,
    "name" : "seq",
    "parameters" : [
     {
      "name" : "f",
      "kind" : "alias"
     },
     {
      "name" : "g",
      "kind" : "alias"
     }
    ],
    "members" : [
     {
      "name" : "seq",
      "kind" : "function",
      "line" : 2609,
      "type" : "void(ref string s)",
      "parameters" : [
       {
        "name" : "s",
        "type" : "string",
        "storageClass" : [
         "ref"
        ]
       }
      ],
      "endline" : 2613
     }
    ]
   },
   {
    "name" : "check",
    "kind" : "function",
    "comment" : "\n Check an entire XML document for well-formedness\n\n Params:\n      s = the document to be checked, passed as a string\n\n Throws: CheckException if the document is not well formed\n\n CheckException's toString() method will yield the complete heirarchy of\n parse failure (the XML equivalent of a stack trace), giving the line and\n column number of every failure at every level.\n \n",
    "line" : 2628,
    "deco" : "FAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     }
    ],
    "endline" : 2641
   },
   {
    "name" : "__unittestL2643_2053",
    "kind" : "function",
    "line" : 2643,
    "endline" : 2693
   },
   {
    "name" : "__unittestL2693_2054",
    "kind" : "function",
    "line" : 2693,
    "endline" : 2713
   },
   {
    "name" : "__unittestL2713_2057",
    "kind" : "function",
    "line" : 2713,
    "endline" : 2733
   },
   {
    "name" : "XMLException",
    "kind" : "class",
    "comment" : " The base class for exceptions thrown by this module \n",
    "line" : 2733,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 2733,
      "deco" : "FAyaZC3std3xml12XMLException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2733
     }
    ]
   },
   {
    "name" : "CommentException",
    "kind" : "class",
    "comment" : " Thrown during Comment constructor\n",
    "line" : 2738,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2739,
      "deco" : "FAyaZC3std3xml16CommentException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2739
     }
    ]
   },
   {
    "name" : "CDataException",
    "kind" : "class",
    "comment" : " Thrown during CData constructor\n",
    "line" : 2742,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2743,
      "deco" : "FAyaZC3std3xml14CDataException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2743
     }
    ]
   },
   {
    "name" : "XIException",
    "kind" : "class",
    "comment" : " Thrown during XMLInstruction constructor\n",
    "line" : 2746,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2747,
      "deco" : "FAyaZC3std3xml11XIException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2747
     }
    ]
   },
   {
    "name" : "PIException",
    "kind" : "class",
    "comment" : " Thrown during ProcessingInstruction constructor\n",
    "line" : 2750,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2751,
      "deco" : "FAyaZC3std3xml11PIException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2751
     }
    ]
   },
   {
    "name" : "TextException",
    "kind" : "class",
    "comment" : " Thrown during Text constructor\n",
    "line" : 2754,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2755,
      "deco" : "FAyaZC3std3xml13TextException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2755
     }
    ]
   },
   {
    "name" : "DecodeException",
    "kind" : "class",
    "comment" : " Thrown during decode()\n",
    "line" : 2758,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2759,
      "deco" : "FAyaZC3std3xml15DecodeException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2759
     }
    ]
   },
   {
    "name" : "InvalidTypeException",
    "kind" : "class",
    "comment" : " Thrown if comparing with wrong type\n",
    "line" : 2762,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2763,
      "deco" : "FAyaZC3std3xml20InvalidTypeException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2763
     }
    ]
   },
   {
    "name" : "TagException",
    "kind" : "class",
    "comment" : " Thrown when parsing for Tags\n",
    "line" : 2766,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2767,
      "deco" : "FAyaZC3std3xml12TagException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 2767
     }
    ]
   },
   {
    "name" : "CheckException",
    "kind" : "class",
    "comment" : "\n Thrown during check()\n \n",
    "line" : 2772,
    "base" : "XMLException",
    "members" : [
     {
      "name" : "err",
      "kind" : "variable",
      "comment" : " Parent in heirarchy\n",
      "line" : 2774,
      "deco" : "C3std3xml14CheckException",
      "originalType" : "CheckException",
      "offset" : 72
     },
     {
      "name" : "tail",
      "kind" : "variable",
      "protection" : "private",
      "line" : 2775,
      "deco" : "Aya",
      "offset" : 80
     },
     {
      "name" : "msg",
      "kind" : "variable",
      "comment" : "\n Name of production rule which failed to parse,\n or specific error message\n     \n",
      "line" : 2780,
      "deco" : "Aya",
      "offset" : 96
     },
     {
      "name" : "line",
      "kind" : "variable",
      "comment" : " Line number at which parse failure occurred\n",
      "line" : 2781,
      "deco" : "m",
      "originalType" : "size_t",
      "init" : "0LU",
      "offset" : 112
     },
     {
      "name" : "column",
      "kind" : "variable",
      "comment" : " Column number at which parse failure occurred\n",
      "line" : 2782,
      "deco" : "m",
      "originalType" : "size_t",
      "init" : "0LU",
      "offset" : 120
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "protection" : "private",
      "line" : 2784,
      "deco" : "FAyaAyaC3std3xml14CheckExceptionZC3std3xml14CheckException",
      "originalType" : "(string tail, string msg, Err err = null)",
      "parameters" : [
       {
        "name" : "tail",
        "deco" : "Aya"
       },
       {
        "name" : "msg",
        "deco" : "Aya"
       },
       {
        "name" : "err",
        "deco" : "C3std3xml14CheckException",
        "default" : "null"
       }
      ],
      "endline" : 2790
     },
     {
      "name" : "complete",
      "kind" : "function",
      "protection" : "private",
      "line" : 2792,
      "deco" : "FAyaZv",
      "parameters" : [
       {
        "name" : "entire",
        "deco" : "Aya"
       }
      ],
      "endline" : 2801
     },
     {
      "name" : "toString",
      "kind" : "function",
      "line" : 2803,
      "storageClass" : [
       "const",
       "override"
      ],
      "deco" : "xFZAya",
      "originalType" : "string()",
      "endline" : 2811,
      "overrides" : [
       "object.Throwable.toString"
      ]
     }
    ]
   },
   {
    "name" : "Err",
    "kind" : "alias",
    "protection" : "private",
    "line" : 2814
   },
   {
    "kind" : "template",
    "protection" : "private",
    "line" : 2820,
    "name" : "toType",
    "parameters" : [
     {
      "name" : "T",
      "kind" : "type"
     }
    ],
    "members" : [
     {
      "name" : "toType",
      "kind" : "function",
      "line" : 2820,
      "type" : "T(Object o)",
      "parameters" : [
       {
        "name" : "o",
        "type" : "Object"
       }
      ],
      "endline" : 2829
     }
    ]
   },
   {
    "name" : "chop",
    "kind" : "function",
    "protection" : "private",
    "line" : 2831,
    "deco" : "FKAyamZAya",
    "originalType" : "string(ref string s, size_t n)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "n",
      "deco" : "m"
     }
    ],
    "endline" : 2837
   },
   {
    "name" : "optc",
    "kind" : "function",
    "protection" : "private",
    "line" : 2839,
    "deco" : "FKAyaaZb",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "a"
     }
    ],
    "endline" : 2844
   },
   {
    "name" : "reqc",
    "kind" : "function",
    "protection" : "private",
    "line" : 2846,
    "deco" : "FKAyaaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "storageClass" : [
       "ref"
      ]
     },
     {
      "name" : "c",
      "deco" : "a"
     }
    ],
    "endline" : 2850
   },
   {
    "name" : "hash",
    "kind" : "function",
    "protection" : "private",
    "line" : 2852,
    "deco" : "FNbNeAyamZm",
    "originalType" : "nothrow @trusted size_t(string s, size_t h = 0)",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     },
     {
      "name" : "h",
      "deco" : "m",
      "default" : "0LU"
     }
    ],
    "endline" : 2855
   },
   {
    "name" : "CharTable",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2859,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAi",
    "originalType" : "int[]",
    "init" : "[9, 9, 10, 10, 13, 13, 32, 55295, 57344, 65533, 65536, 1114111]"
   },
   {
    "name" : "BaseCharTable",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2900,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAi",
    "originalType" : "int[]",
    "init" : "[65, 90, 97, 122, 192, 214, 216, 246, 248, 255, 256, 305, 308, 318, 321, 328, 330, 382, 384, 451, 461, 496, 500, 501, 506, 535, 592, 680, 699, 705, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 982, 986, 986, 988, 988, 990, 990, 992, 992, 994, 1011, 1025, 1036, 1038, 1103, 1105, 1116, 1118, 1153, 1168, 1220, 1223, 1224, 1227, 1228, 1232, 1259, 1262, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1414, 1488, 1514, 1520, 1522, 1569, 1594, 1601, 1610, 1649, 1719, 1722, 1726, 1728, 1742, 1744, 1747, 1749, 1749, 1765, 1766, 2309, 2361, 2365, 2365, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3585, 3630, 3632, 3632, 3634, 3635, 3648, 3653, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3758, 3760, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3904, 3911, 3913, 3945, 4256, 4293, 4304, 4342, 4352, 4352, 4354, 4355, 4357, 4359, 4361, 4361, 4363, 4364, 4366, 4370, 4412, 4412, 4414, 4414, 4416, 4416, 4428, 4428, 4430, 4430, 4432, 4432, 4436, 4437, 4441, 4441, 4447, 4449, 4451, 4451, 4453, 4453, 4455, 4455, 4457, 4457, 4461, 4462, 4466, 4467, 4469, 4469, 4510, 4510, 4520, 4520, 4523, 4523, 4526, 4527, 4535, 4536, 4538, 4538, 4540, 4546, 4587, 4587, 4592, 4592, 4601, 4601, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8486, 8486, 8490, 8491, 8494, 8494, 8576, 8578, 12353, 12436, 12449, 12538, 12549, 12588, 44032, 55203]"
   },
   {
    "name" : "IdeographicTable",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2901,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAi",
    "originalType" : "int[]",
    "init" : "[12295, 12295, 12321, 12329, 19968, 40869]"
   },
   {
    "name" : "CombiningCharTable",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2921,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAi",
    "originalType" : "int[]",
    "init" : "[768, 837, 864, 865, 1155, 1158, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1611, 1618, 1648, 1648, 1750, 1756, 1757, 1759, 1760, 1764, 1767, 1768, 1770, 1773, 2305, 2307, 2364, 2364, 2366, 2380, 2381, 2381, 2385, 2388, 2402, 2403, 2433, 2435, 2492, 2492, 2494, 2494, 2495, 2495, 2496, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2530, 2531, 2562, 2562, 2620, 2620, 2622, 2622, 2623, 2623, 2624, 2626, 2631, 2632, 2635, 2637, 2672, 2673, 2689, 2691, 2748, 2748, 2750, 2757, 2759, 2761, 2763, 2765, 2817, 2819, 2876, 2876, 2878, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2946, 2947, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3073, 3075, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3202, 3203, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3330, 3331, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3633, 3633, 3636, 3642, 3655, 3662, 3761, 3761, 3764, 3769, 3771, 3772, 3784, 3789, 3864, 3865, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3902, 3903, 3903, 3953, 3972, 3974, 3979, 3984, 3989, 3991, 3991, 3993, 4013, 4017, 4023, 4025, 4025, 8400, 8412, 8417, 8417, 12330, 12335, 12441, 12441, 12442, 12442]"
   },
   {
    "name" : "DigitTable",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2925,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAi",
    "originalType" : "int[]",
    "init" : "[48, 57, 1632, 1641, 1776, 1785, 2406, 2415, 2534, 2543, 2662, 2671, 2790, 2799, 2918, 2927, 3047, 3055, 3174, 3183, 3302, 3311, 3430, 3439, 3664, 3673, 3792, 3801, 3872, 3881]"
   },
   {
    "name" : "ExtenderTable",
    "kind" : "variable",
    "protection" : "private",
    "line" : 2928,
    "storageClass" : [
     "immutable"
    ],
    "deco" : "yAi",
    "originalType" : "int[]",
    "init" : "[183, 183, 720, 720, 721, 721, 903, 903, 1600, 1600, 3654, 3654, 3782, 3782, 12293, 12293, 12337, 12341, 12445, 12446, 12540, 12542]"
   },
   {
    "name" : "lookup",
    "kind" : "function",
    "protection" : "private",
    "line" : 2930,
    "deco" : "FAxiiZb",
    "parameters" : [
     {
      "name" : "table",
      "deco" : "Axi"
     },
     {
      "name" : "c",
      "deco" : "i"
     }
    ],
    "endline" : 2946
   },
   {
    "name" : "startOf",
    "kind" : "function",
    "protection" : "private",
    "line" : 2948,
    "deco" : "FAyaZAya",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya"
     }
    ],
    "endline" : 2957
   },
   {
    "name" : "exit",
    "kind" : "function",
    "protection" : "private",
    "line" : 2959,
    "deco" : "FAyaZv",
    "parameters" : [
     {
      "name" : "s",
      "deco" : "Aya",
      "default" : "null"
     }
    ],
    "endline" : 2962
   }
  ]
 },
 {
  "name" : "std.zip",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/zip.d",
  "comment" : "\n Read/write data in the $(LINK2 http://www.info-_zip.org, zip archive) format.\n Makes use of the etc.c.zlib compression library.\n\n Bugs:\n      $(UL\n      $(LI Multi-disk zips not supported.)\n      $(LI Only Zip version 20 formats are supported.)\n      $(LI Only supports compression modes 0 (no compression) and 8 (deflate).)\n      $(LI Does not support encryption.)\n      $(LI $(BUGZILLA 592))\n      $(LI $(BUGZILLA 1832))\n      $(LI $(BUGZILLA 2137))\n      $(LI $(BUGZILLA 2138))\n      )\n\n Macros:\n      WIKI = Phobos/StdZip\n\n Copyright: Copyright Digital Mars 2000 - 2009.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_zip.d)\n \n",
  "members" : [
   {
    "name" : "std.zlib",
    "kind" : "import",
    "line" : 35,
    "protection" : "private"
   },
   {
    "name" : "std.datetime",
    "kind" : "import",
    "line" : 36,
    "protection" : "private"
   },
   {
    "name" : "core.bitop",
    "kind" : "import",
    "line" : 37,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 38,
    "protection" : "private"
   },
   {
    "name" : "std.algorithm",
    "kind" : "import",
    "line" : 39,
    "protection" : "private"
   },
   {
    "name" : "ZipException",
    "kind" : "class",
    "comment" : " Thrown on error.\n \n",
    "line" : 45,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 47,
      "deco" : "FAyaZC3std3zip12ZipException",
      "originalType" : "(string msg)",
      "parameters" : [
       {
        "name" : "msg",
        "deco" : "Aya"
       }
      ],
      "endline" : 50
     }
    ]
   },
   {
    "name" : "ArchiveMember",
    "kind" : "class",
    "comment" : "\n A member of the ZipArchive.\n \n",
    "line" : 57,
    "members" : [
     {
      "name" : "madeVersion",
      "kind" : "variable",
      "comment" : " Read Only\n",
      "line" : 58,
      "deco" : "t",
      "init" : "cast(ushort)20u",
      "offset" : 16
     },
     {
      "name" : "extractVersion",
      "kind" : "variable",
      "comment" : " Read Only\n",
      "line" : 59,
      "deco" : "t",
      "init" : "cast(ushort)20u",
      "offset" : 18
     },
     {
      "name" : "flags",
      "kind" : "variable",
      "comment" : " Read/Write: normally set to 0\n",
      "line" : 60,
      "deco" : "t",
      "offset" : 20
     },
     {
      "name" : "compressionMethod",
      "kind" : "variable",
      "comment" : " Read/Write: 0 for compression, 8 for deflate\n",
      "line" : 61,
      "deco" : "t",
      "offset" : 22
     },
     {
      "name" : "time",
      "kind" : "variable",
      "comment" : " Read/Write: Last modified time of the member. It's in the DOS date/time format.\n",
      "line" : 62,
      "deco" : "k",
      "originalType" : "std.datetime.DosFileTime",
      "offset" : 24
     },
     {
      "name" : "crc32",
      "kind" : "variable",
      "comment" : " Read Only: cyclic redundancy check (CRC) value\n",
      "line" : 63,
      "deco" : "k",
      "offset" : 28
     },
     {
      "name" : "compressedSize",
      "kind" : "variable",
      "comment" : " Read Only: size of data of member in compressed form.\n",
      "line" : 64,
      "deco" : "k",
      "offset" : 32
     },
     {
      "name" : "expandedSize",
      "kind" : "variable",
      "comment" : " Read Only: size of data of member in expanded form.\n",
      "line" : 65,
      "deco" : "k",
      "offset" : 36
     },
     {
      "name" : "diskNumber",
      "kind" : "variable",
      "comment" : " Read Only: should be 0.\n",
      "line" : 66,
      "deco" : "t",
      "offset" : 40
     },
     {
      "name" : "internalAttributes",
      "kind" : "variable",
      "comment" : " Read/Write\n",
      "line" : 67,
      "deco" : "t",
      "offset" : 42
     },
     {
      "name" : "externalAttributes",
      "kind" : "variable",
      "comment" : " Read/Write\n",
      "line" : 68,
      "deco" : "k",
      "offset" : 44
     },
     {
      "name" : "offset",
      "kind" : "variable",
      "protection" : "private",
      "line" : 70,
      "deco" : "k",
      "offset" : 48
     },
     {
      "name" : "name",
      "kind" : "variable",
      "comment" : "\n Read/Write: Usually the file name of the archive member; it is used to\n index the archive directory for the member. Each member must have a unique\n name[]. Do not change without removing member from the directory first.\n     \n",
      "line" : 77,
      "deco" : "Aya",
      "offset" : 56
     },
     {
      "name" : "extra",
      "kind" : "variable",
      "comment" : " Read/Write: extra data for this member.\n",
      "line" : 79,
      "deco" : "Ah",
      "offset" : 72
     },
     {
      "name" : "comment",
      "kind" : "variable",
      "comment" : " Read/Write: comment associated with this member.\n",
      "line" : 80,
      "deco" : "Aya",
      "offset" : 88
     },
     {
      "name" : "compressedData",
      "kind" : "variable",
      "comment" : " Read Only: data of member in compressed form.\n",
      "line" : 81,
      "deco" : "Ah",
      "offset" : 104
     },
     {
      "name" : "expandedData",
      "kind" : "variable",
      "comment" : " Read/Write: data of member in uncompressed form.\n",
      "line" : 82,
      "deco" : "Ah",
      "offset" : 120
     }
    ]
   },
   {
    "name" : "ZipArchive",
    "kind" : "class",
    "comment" : "\n Object representing the entire archive.\n ZipArchives are collections of ArchiveMembers.\n \n",
    "line" : 109,
    "members" : [
     {
      "name" : "data",
      "kind" : "variable",
      "comment" : " Read Only: array representing the entire contents of the archive.\n",
      "line" : 110,
      "deco" : "Ah",
      "offset" : 16
     },
     {
      "name" : "endrecOffset",
      "kind" : "variable",
      "line" : 111,
      "deco" : "k",
      "offset" : 32
     },
     {
      "name" : "diskNumber",
      "kind" : "variable",
      "comment" : " Read Only: 0 since multi-disk zip archives are not supported.\n",
      "line" : 113,
      "deco" : "k",
      "offset" : 36
     },
     {
      "name" : "diskStartDir",
      "kind" : "variable",
      "comment" : " Read Only: 0 since multi-disk zip archives are not supported.\n",
      "line" : 114,
      "deco" : "k",
      "offset" : 40
     },
     {
      "name" : "numEntries",
      "kind" : "variable",
      "comment" : " Read Only: number of ArchiveMembers in the directory.\n",
      "line" : 115,
      "deco" : "k",
      "offset" : 44
     },
     {
      "name" : "totalEntries",
      "kind" : "variable",
      "comment" : " Read Only: same as totalEntries.\n",
      "line" : 116,
      "deco" : "k",
      "offset" : 48
     },
     {
      "name" : "comment",
      "kind" : "variable",
      "comment" : " Read/Write: the archive comment. Must be less than 65536 bytes in length.\n",
      "line" : 117,
      "deco" : "Aya",
      "offset" : 56
     },
     {
      "name" : "directory",
      "kind" : "variable",
      "comment" : "\n Read Only: array indexed by the name of each member of the archive.\n Example:\n  All the members of the archive can be accessed with a foreach loop:\n --------------------\n ZipArchive archive = new ZipArchive(data);\n foreach (ArchiveMember am; archive.directory)\n {\n     writefln(\"member name is '%s'\", am.name);\n }\n --------------------\n     \n",
      "line" : 131,
      "deco" : "HAyaC3std3zip13ArchiveMember",
      "offset" : 72
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " Constructor to use when creating a new archive.\n     \n",
      "line" : 149,
      "deco" : "FZC3std3zip10ZipArchive",
      "originalType" : "()",
      "endline" : 151
     },
     {
      "name" : "addMember",
      "kind" : "function",
      "comment" : " Add de to the archive.\n     \n",
      "line" : 155,
      "deco" : "FC3std3zip13ArchiveMemberZv",
      "parameters" : [
       {
        "name" : "de",
        "deco" : "C3std3zip13ArchiveMember"
       }
      ],
      "endline" : 158
     },
     {
      "name" : "deleteMember",
      "kind" : "function",
      "comment" : " Delete de from the archive.\n     \n",
      "line" : 162,
      "deco" : "FC3std3zip13ArchiveMemberZv",
      "parameters" : [
       {
        "name" : "de",
        "deco" : "C3std3zip13ArchiveMember"
       }
      ],
      "endline" : 165
     },
     {
      "name" : "build",
      "kind" : "function",
      "comment" : "\n Construct an archive out of the current members of the archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, and directory[].\n For each ArchiveMember, fills in properties crc32, compressedSize,\n compressedData[].\n\n Returns: array representing the entire archive.\n     \n",
      "line" : 177,
      "deco" : "FZAv",
      "endline" : 294
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Constructor to use when reading an existing archive.\n\n Fills in the properties data[], diskNumber, diskStartDir, numEntries,\n totalEntries, comment[], and directory[].\n For each ArchiveMember, fills in\n properties madeVersion, extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, compressedData[], diskNumber,\n internalAttributes, externalAttributes, name[], extra[], comment[].\n Use expand() to get the expanded data for each ArchiveMember.\n\n Params:\n  buffer = the entire contents of the archive.\n     \n",
      "line" : 313,
      "deco" : "FAvZC3std3zip10ZipArchive",
      "originalType" : "(void[] buffer)",
      "parameters" : [
       {
        "name" : "buffer",
        "deco" : "Av"
       }
      ],
      "endline" : 408
     },
     {
      "name" : "expand",
      "kind" : "function",
      "comment" : "\n Decompress the contents of archive member de and return the expanded\n data.\n\n Fills in properties extractVersion, flags, compressionMethod, time,\n crc32, compressedSize, expandedSize, expandedData[], name[], extra[].\n     \n",
      "line" : 417,
      "deco" : "FC3std3zip13ArchiveMemberZAh",
      "parameters" : [
       {
        "name" : "de",
        "deco" : "C3std3zip13ArchiveMember"
       }
      ],
      "endline" : 470
     },
     {
      "name" : "getUshort",
      "kind" : "function",
      "line" : 474,
      "deco" : "FiZt",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "i"
       }
      ],
      "endline" : 486
     },
     {
      "name" : "getUint",
      "kind" : "function",
      "line" : 488,
      "deco" : "FiZk",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "i"
       }
      ],
      "endline" : 498
     },
     {
      "name" : "putUshort",
      "kind" : "function",
      "line" : 500,
      "deco" : "FitZv",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "i"
       },
       {
        "name" : "us",
        "deco" : "t"
       }
      ],
      "endline" : 511
     },
     {
      "name" : "putUint",
      "kind" : "function",
      "line" : 513,
      "deco" : "FikZv",
      "parameters" : [
       {
        "name" : "i",
        "deco" : "i"
       },
       {
        "name" : "ui",
        "deco" : "k"
       }
      ],
      "endline" : 520
     }
    ]
   }
  ]
 },
 {
  "name" : "std.zlib",
  "kind" : "module",
  "file" : "/usr/include/dmd/phobos/std/zlib.d",
  "comment" : "\n Compress/decompress data using the $(LINK2 http://www._zlib.net, zlib library).\n\n References:\n  $(LINK2 http://en.wikipedia.org/wiki/Zlib, Wikipedia)\n\n Macros:\n  WIKI = Phobos/StdZlib\n\n Copyright: Copyright Digital Mars 2000 - 2011.\n License:   <a href=\"http://www.boost.org/LICENSE_1_0.txt\">Boost License 1.0</a>.\n Authors:   $(WEB digitalmars.com, Walter Bright)\n Source:    $(PHOBOSSRC std/_zlib.d)\n \n",
  "members" : [
   {
    "name" : "etc.c.zlib",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "std.conv",
    "kind" : "import",
    "line" : 26,
    "protection" : "private"
   },
   {
    "name" : "Z_NO_FLUSH",
    "kind" : "enum member",
    "line" : 32
   },
   {
    "name" : "Z_SYNC_FLUSH",
    "kind" : "enum member",
    "line" : 33
   },
   {
    "name" : "Z_FULL_FLUSH",
    "kind" : "enum member",
    "line" : 34
   },
   {
    "name" : "Z_FINISH",
    "kind" : "enum member",
    "line" : 35
   },
   {
    "name" : "ZlibException",
    "kind" : "class",
    "comment" : "\n Errors throw a ZlibException.\n \n",
    "line" : 42,
    "base" : "Exception",
    "members" : [
     {
      "name" : "this",
      "kind" : "constructor",
      "line" : 44,
      "deco" : "FiZC3std4zlib13ZlibException",
      "originalType" : "(int errnum)",
      "parameters" : [
       {
        "name" : "errnum",
        "deco" : "i"
       }
      ],
      "endline" : 60
     }
    ]
   },
   {
    "name" : "adler32",
    "kind" : "function",
    "comment" : "\n Compute the Adler32 checksum of the data in buf[]. adler is the starting\n value when computing a cumulative checksum.\n \n",
    "line" : 68,
    "deco" : "FkAxvZk",
    "parameters" : [
     {
      "name" : "adler",
      "deco" : "k"
     },
     {
      "name" : "buf",
      "deco" : "Axv"
     }
    ],
    "endline" : 72
   },
   {
    "name" : "__unittestL74_2058",
    "kind" : "function",
    "line" : 74,
    "endline" : 91
   },
   {
    "name" : "crc32",
    "kind" : "function",
    "comment" : "\n Compute the CRC32 checksum of the data in buf[]. crc is the starting value\n when computing a cumulative checksum.\n \n",
    "line" : 91,
    "deco" : "FkAxvZk",
    "parameters" : [
     {
      "name" : "crc",
      "deco" : "k"
     },
     {
      "name" : "buf",
      "deco" : "Axv"
     }
    ],
    "endline" : 94
   },
   {
    "name" : "__unittestL96_2059",
    "kind" : "function",
    "line" : 96,
    "endline" : 116
   },
   {
    "name" : "compress",
    "kind" : "function",
    "comment" : "\n Compresses the data in srcbuf[] using compression _level level.\n The default value\n for level is 6, legal values are 1..9, with 1 being the least compression\n and 9 being the most.\n Returns the compressed data.\n \n",
    "line" : 116,
    "deco" : "FAxviZAxv",
    "parameters" : [
     {
      "name" : "srcbuf",
      "deco" : "Axv"
     },
     {
      "name" : "level",
      "deco" : "i"
     }
    ],
    "endline" : 133
   },
   {
    "name" : "compress",
    "kind" : "function",
    "comment" : "\n ditto\n \n",
    "line" : 139,
    "deco" : "FAxvZAxv",
    "parameters" : [
     {
      "name" : "buf",
      "deco" : "Axv"
     }
    ],
    "endline" : 142
   },
   {
    "name" : "uncompress",
    "kind" : "function",
    "comment" : "\n Decompresses the data in srcbuf[].\n Params: destlen = size of the uncompressed data.\n It need not be accurate, but the decompression will be faster if the exact\n size is supplied.\n Returns: the decompressed data.\n \n",
    "line" : 152,
    "deco" : "FAvmiZAv",
    "originalType" : "void[](void[] srcbuf, size_t destlen = 0u, int winbits = 15)",
    "parameters" : [
     {
      "name" : "srcbuf",
      "deco" : "Av"
     },
     {
      "name" : "destlen",
      "deco" : "m",
      "default" : "0LU"
     },
     {
      "name" : "winbits",
      "deco" : "i",
      "default" : "15"
     }
    ],
    "endline" : 199
   },
   {
    "name" : "__unittestL201_2060",
    "kind" : "function",
    "line" : 201,
    "endline" : 218
   },
   {
    "name" : "__unittestL218_2061",
    "kind" : "function",
    "line" : 218,
    "endline" : 246
   },
   {
    "name" : "HeaderFormat",
    "kind" : "enum",
    "comment" : " the header format the compressed stream is wrapped in\n",
    "line" : 246,
    "baseDeco" : "i",
    "members" : [
     {
      "name" : "deflate",
      "kind" : "enum member",
      "comment" : " a standard zlib header\n",
      "line" : 247
     },
     {
      "name" : "gzip",
      "kind" : "enum member",
      "comment" : " a gzip file format header\n",
      "line" : 248
     },
     {
      "name" : "determineFromData",
      "kind" : "enum member",
      "comment" : " used when decompressing. Try to automatically detect the stream format by looking at the data\n",
      "line" : 249
     }
    ]
   },
   {
    "name" : "Compress",
    "kind" : "class",
    "comment" : "\n Used when the data to be compressed is not all in one buffer.\n \n",
    "line" : 257,
    "members" : [
     {
      "name" : "zs",
      "kind" : "variable",
      "protection" : "private",
      "line" : 259,
      "deco" : "S3etc1c4zlib8z_stream",
      "offset" : 16
     },
     {
      "name" : "level",
      "kind" : "variable",
      "protection" : "private",
      "line" : 260,
      "deco" : "i",
      "init" : "-1",
      "offset" : 128
     },
     {
      "name" : "inited",
      "kind" : "variable",
      "protection" : "private",
      "line" : 261,
      "deco" : "i",
      "offset" : 132
     },
     {
      "name" : "gzip",
      "kind" : "variable",
      "protection" : "private",
      "line" : 262,
      "storageClass" : [
       "immutable"
      ],
      "deco" : "yb",
      "originalType" : "bool",
      "offset" : 136
     },
     {
      "name" : "error",
      "kind" : "function",
      "protection" : "private",
      "line" : 264,
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "err",
        "deco" : "i"
       }
      ],
      "endline" : 271
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct. level is the same as for D.zlib.compress(). header can be used to make a gzip compatible stream.\n     \n",
      "line" : 278,
      "deco" : "FiE3std4zlib12HeaderFormatZC3std4zlib8Compress",
      "originalType" : "(int level, HeaderFormat header = HeaderFormat.deflate)",
      "parameters" : [
       {
        "name" : "level",
        "deco" : "i"
       },
       {
        "name" : "header",
        "deco" : "E3std4zlib12HeaderFormat",
        "default" : "cast(HeaderFormat)0"
       }
      ],
      "endline" : 287
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto\n",
      "line" : 290,
      "deco" : "FE3std4zlib12HeaderFormatZC3std4zlib8Compress",
      "originalType" : "(HeaderFormat header = HeaderFormat.deflate)",
      "parameters" : [
       {
        "name" : "header",
        "deco" : "E3std4zlib12HeaderFormat",
        "default" : "cast(HeaderFormat)0"
       }
      ],
      "endline" : 293
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 295,
      "deco" : "FZv",
      "endline" : 303
     },
     {
      "name" : "compress",
      "kind" : "function",
      "comment" : "\n Compress the data in buf and return the compressed data.\n The buffers\n returned from successive calls to this should be concatenated together.\n     \n",
      "line" : 310,
      "deco" : "FAxvZAxv",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       }
      ],
      "endline" : 342
     },
     {
      "name" : "flush",
      "kind" : "function",
      "comment" : "\n Compress and return any remaining data.\n The returned data should be appended to that returned by compress().\n Params:\n  mode = one of the following:\n          $(DL\n                    $(DT Z_SYNC_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on.)\n                    $(DT Z_FULL_FLUSH )\n                    $(DD Syncs up flushing to the next byte boundary.\n                        Used when more data is to be compressed later on,\n                        and the decompressor needs to be restartable at this\n                        point.)\n                    $(DT Z_FINISH)\n                    $(DD (default) Used when finished compressing the data. )\n                )\n     \n",
      "line" : 362,
      "deco" : "FiZAv",
      "originalType" : "void[](int mode = Z_FINISH)",
      "parameters" : [
       {
        "name" : "mode",
        "deco" : "i",
        "default" : "4"
       }
      ],
      "endline" : 411,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 364,
       "deco" : "FZv",
       "endline" : 364
      }
     }
    ]
   },
   {
    "name" : "UnCompress",
    "kind" : "class",
    "comment" : "\n Used when the data to be decompressed is not all in one buffer.\n \n",
    "line" : 419,
    "members" : [
     {
      "name" : "zs",
      "kind" : "variable",
      "protection" : "private",
      "line" : 421,
      "deco" : "S3etc1c4zlib8z_stream",
      "offset" : 16
     },
     {
      "name" : "inited",
      "kind" : "variable",
      "protection" : "private",
      "line" : 422,
      "deco" : "i",
      "offset" : 128
     },
     {
      "name" : "done",
      "kind" : "variable",
      "protection" : "private",
      "line" : 423,
      "deco" : "i",
      "offset" : 132
     },
     {
      "name" : "destbufsize",
      "kind" : "variable",
      "protection" : "private",
      "line" : 424,
      "deco" : "m",
      "originalType" : "size_t",
      "offset" : 136
     },
     {
      "name" : "format",
      "kind" : "variable",
      "protection" : "private",
      "line" : 426,
      "deco" : "E3std4zlib12HeaderFormat",
      "offset" : 144
     },
     {
      "name" : "error",
      "kind" : "function",
      "protection" : "private",
      "line" : 428,
      "deco" : "FiZv",
      "parameters" : [
       {
        "name" : "err",
        "deco" : "i"
       }
      ],
      "endline" : 435
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : "\n Construct. destbufsize is the same as for D.zlib.uncompress().\n     \n",
      "line" : 442,
      "deco" : "FkZC3std4zlib10UnCompress",
      "originalType" : "(uint destbufsize)",
      "parameters" : [
       {
        "name" : "destbufsize",
        "deco" : "k"
       }
      ],
      "endline" : 445
     },
     {
      "name" : "this",
      "kind" : "constructor",
      "comment" : " ditto \n",
      "line" : 448,
      "deco" : "FE3std4zlib12HeaderFormatZC3std4zlib10UnCompress",
      "originalType" : "(HeaderFormat format = HeaderFormat.determineFromData)",
      "parameters" : [
       {
        "name" : "format",
        "deco" : "E3std4zlib12HeaderFormat",
        "default" : "cast(HeaderFormat)2"
       }
      ],
      "endline" : 451
     },
     {
      "name" : "~this",
      "kind" : "destructor",
      "line" : 453,
      "deco" : "FZv",
      "endline" : 462
     },
     {
      "name" : "uncompress",
      "kind" : "function",
      "comment" : "\n Decompress the data in buf and return the decompressed data.\n The buffers returned from successive calls to this should be concatenated\n together.\n     \n",
      "line" : 469,
      "deco" : "FAxvZAxv",
      "parameters" : [
       {
        "name" : "buf",
        "deco" : "Axv"
       }
      ],
      "endline" : 514,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 471,
       "deco" : "FZv",
       "endline" : 471
      }
     },
     {
      "name" : "flush",
      "kind" : "function",
      "comment" : "\n Decompress and return any remaining data.\n The returned data should be appended to that returned by uncompress().\n The UnCompress object cannot be used further.\n     \n",
      "line" : 521,
      "deco" : "FZAv",
      "endline" : 566,
      "in" : {
       "name" : "__require",
       "kind" : "function",
       "line" : 523,
       "deco" : "FZv",
       "endline" : 523
      },
      "out" : {
       "name" : "__ensure",
       "kind" : "function",
       "line" : 527,
       "deco" : "FKxAvZv",
       "originalType" : "void(ref const void[] __result)",
       "parameters" : [
        {
         "name" : "__result",
         "deco" : "xAv",
         "storageClass" : [
          "ref"
         ]
        }
       ],
       "endline" : 527
      }
     }
    ]
   },
   {
    "name" : "std.stdio",
    "kind" : "import",
    "line" : 571,
    "protection" : "private"
   },
   {
    "name" : "std.random",
    "kind" : "import",
    "line" : 572,
    "protection" : "private"
   },
   {
    "name" : "__unittestL574_2062",
    "kind" : "function",
    "line" : 574,
    "endline" : 631
   },
   {
    "name" : "__unittestL631_2063",
    "kind" : "function",
    "line" : 631,
    "endline" : 648
   }
  ]
 }
]