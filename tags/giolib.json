[
{
"name" : "gio.AppInfo",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AppInfo.d",
"members" : [
{
"name" : "AppInfo",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"AppInfoIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "AppInfo(GAppInfo* gAppInfo)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.AppInfoIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AppInfoIF.d",
"members" : [
{
"name" : "AppInfoIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GAppInfo and GAppLaunchContext are used for describing and launching\n applications installed on the system.\n As of GLib 2.20, URIs will always be converted to POSIX paths\n (using g_file_get_path()) when using g_app_info_launch() even if\n the application requested an URI and not a POSIX path. For example\n for an desktop-file based application with Exec key totem\n %U and a single URI,\n sftp:\/\/foo\/file.avi, then\n \/home\/user\/.gvfs\/sftp on foo\/file.avi will be\n passed. This will only work if a set of suitable GIO extensions\n (such as gvfs 2.26 compiled with FUSE support), is available and\n operational; if this is not the case, the URI will be passed\n unmodified to the application. Some URIs, such as\n mailto:, of course cannot be mapped to a POSIX\n path (in gvfs there's no FUSE mount for it); such URIs will be\n passed unmodified to the application.\n Specifically for gvfs 2.26 and later, the POSIX URI will be mapped\n back to the GIO URI in the GFile constructors (since gvfs\n implements the GVfs extension point). As such, if the application\n needs to examine the URI, it needs to use g_file_get_uri() or\n similar on GFile. In other words, an application cannot assume\n that the URI passed to e.g. g_file_new_for_commandline_arg() is\n equal to the result of g_file_get_uri(). The following snippet\n illustrates this:\n GFile *f;\n char *uri;\n file = g_file_new_for_commandline_arg (uri_from_commandline);\n uri = g_file_get_uri (file);\n strcmp (uri, uri_from_commandline) == 0; \/\/ FALSE\n g_free (uri);\n if (g_file_has_uri_scheme (file, \"cdda\"))\n  {\n  \/\/ do something special with uri\n  }\n g_object_unref (file);\n This code will work when both cdda:\/\/sr0\/Track\n 1.wav and \/home\/user\/.gvfs\/cdda on sr0\/Track\n 1.wav is passed to the application. It should be noted\n that it's generally not safe for applications to rely on the format\n of a particular URIs. Different launcher applications (e.g. file\n managers) may have different ideas of what a given URI means.\n \n",
"line" : 129,
"members" : [
{
"name" : "getAppInfoTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GAppInfo*()",
"line" : 132}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 135}
,
{
"name" : "createFromCommandline",
"kind" : "function",
"protection" : "public",
"type" : "AppInfoIF(string commandline, string applicationName, GAppInfoCreateFlags flags)",
"comment" : "\n\t \n\n Creates a new GAppInfo from the given information.\n Params:\n commandline = the commandline to use\n applicationName = the application name, or NULL to use commandline. [allow-none]\n flags = flags that can specify details of the created GAppInfo\n Returns: new GAppInfo for given command.\n Throws: GException on failure.\n\t \n",
"line" : 150}
,
{
"name" : "dup",
"kind" : "function",
"protection" : "public",
"type" : "AppInfoIF()",
"comment" : "\n Creates a duplicate of a GAppInfo.\n Returns: a duplicate of appinfo.\n\t \n",
"line" : 156}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(AppInfoIF appinfo2)",
"comment" : "\n Checks if two GAppInfos are equal.\n Params:\n appinfo2 = the second GAppInfo.\n Returns: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.\n\t \n",
"line" : 164}
,
{
"name" : "getId",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the ID of an application. An id is a string that\n identifies the application. The exact format of the id is\n platform dependent. For instance, on Unix this is the\n desktop file id from the xdg menu specification.\n Note that the returned ID may be NULL, depending on how\n the appinfo has been constructed.\n Returns: a string containing the application's ID.\n\t \n",
"line" : 175}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the installed name of the application.\n Returns: the name of the application for appinfo.\n\t \n",
"line" : 181}
,
{
"name" : "getDisplayName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the display name of the application. The display name is often more\n descriptive to the user than the name itself.\n Since 2.24\n Returns: the display name of the application for appinfo, or the name if no display name is available.\n\t \n",
"line" : 189}
,
{
"name" : "getDescription",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets a human-readable description of an installed application.\n Returns: a string containing a description of the application appinfo, or NULL if none.\n\t \n",
"line" : 195}
,
{
"name" : "getExecutable",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the executable's name for the installed application.\n Returns: a string containing the appinfo's application binaries name\n\t \n",
"line" : 201}
,
{
"name" : "getCommandline",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the commandline with which the application will be\n started.\n Since 2.20\n Returns: a string containing the appinfo's commandline, or NULL if this information is not available\n\t \n",
"line" : 209}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gets the icon for the application.\n Returns: the default GIcon for appinfo. [transfer none]\n\t \n",
"line" : 215}
,
{
"name" : "launch",
"kind" : "function",
"protection" : "public",
"type" : "int(ListG files, AppLaunchContext launchContext)",
"comment" : "\n Launches the application. Passes files to the launched application\n as arguments, using the optional launch_context to get information\n about the details of the launcher (like what screen it is on).\n On error, error will be set accordingly.\n To launch the application without arguments pass a NULL files list.\n Note that even if the launch is successful the application launched\n can fail to start if it runs into problems during startup. There is\n no way to detect this.\n Some URIs can be changed when passed through a GFile (for instance\n unsupported uris with strange formats like mailto:), so if you have\n a textual uri you want to pass in as argument, consider using\n g_app_info_launch_uris() instead.\n On UNIX, this function sets the <envvar>GIO_LAUNCHED_DESKTOP_FILE<\/envvar>\n environment variable with the path of the launched desktop file and\n <envvar>GIO_LAUNCHED_DESKTOP_FILE_PID<\/envvar> to the process\n id of the launched process. This can be used to ignore\n <envvar>GIO_LAUNCHED_DESKTOP_FILE<\/envvar>, should it be inherited\n by further processes. The <envvar>DISPLAY<\/envvar> and\n <envvar>DESKTOP_STARTUP_ID<\/envvar> environment variables are also\n set, based on information provided in launch_context.\n Params:\n files = a GList of GFile objects. [element-type GFile]\n launchContext = a GAppLaunchContext or NULL. [allow-none]\n Returns: TRUE on successful launch, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 244}
,
{
"name" : "supportsFiles",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the application accepts files as arguments.\n Returns: TRUE if the appinfo supports files.\n\t \n",
"line" : 250}
,
{
"name" : "supportsUris",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the application supports reading files and directories from URIs.\n Returns: TRUE if the appinfo supports URIs.\n\t \n",
"line" : 256}
,
{
"name" : "launchUris",
"kind" : "function",
"protection" : "public",
"type" : "int(ListG uris, AppLaunchContext launchContext)",
"comment" : "\n Launches the application. Passes uris to the launched application\n as arguments, using the optional launch_context to get information\n about the details of the launcher (like what screen it is on).\n On error, error will be set accordingly.\n To lauch the application without arguments pass a NULL uris list.\n Note that even if the launch is successful the application launched\n can fail to start if it runs into problems during startup. There is\n no way to detect this.\n Params:\n uris = a GList containing URIs to launch. [element-type char*]\n launchContext = a GAppLaunchContext or NULL. [allow-none]\n Returns: TRUE on successful launch, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 273}
,
{
"name" : "shouldShow",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the application info should be shown in menus that\n list available applications.\n Returns: TRUE if the appinfo should be shown, FALSE otherwise.\n\t \n",
"line" : 280}
,
{
"name" : "canDelete",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Obtains the information whether the GAppInfo can be deleted.\n See g_app_info_delete().\n Since 2.20\n Returns: TRUE if appinfo can be deleted\n\t \n",
"line" : 288}
,
{
"name" : "delet",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tries to delete a GAppInfo.\n On some platforms, there may be a difference between user-defined\n GAppInfos which can be deleted, and system-wide ones which\n cannot. See g_app_info_can_delete().\n Since 2.20\n Returns: TRUE if appinfo has been deleted\n\t \n",
"line" : 298}
,
{
"name" : "resetTypeAssociations",
"kind" : "function",
"protection" : "public",
"type" : "void(string contentType)",
"comment" : "\n Removes all changes to the type associations done by\n g_app_info_set_as_default_for_type(),\n g_app_info_set_as_default_for_extension(),\n g_app_info_add_supports_type() or g_app_info_remove_supports_type().\n Since 2.20\n Params:\n contentType = a content type\n\t \n",
"line" : 309}
,
{
"name" : "setAsDefaultForType",
"kind" : "function",
"protection" : "public",
"type" : "int(string contentType)",
"comment" : "\n Sets the application as the default handler for a given type.\n Params:\n contentType = the content type.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 318}
,
{
"name" : "setAsDefaultForExtension",
"kind" : "function",
"protection" : "public",
"type" : "int(string extension)",
"comment" : "\n Sets the application as the default handler for the given file extension.\n Params:\n extension = a string containing the file extension (without the dot).\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 327}
,
{
"name" : "addSupportsType",
"kind" : "function",
"protection" : "public",
"type" : "int(string contentType)",
"comment" : "\n Adds a content type to the application information to indicate the\n application is capable of opening files with the given content type.\n Params:\n contentType = a string.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 337}
,
{
"name" : "canRemoveSupportsType",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a supported content type can be removed from an application.\n Returns: TRUE if it is possible to remove supported content types from a given appinfo, FALSE if not.\n\t \n",
"line" : 343}
,
{
"name" : "removeSupportsType",
"kind" : "function",
"protection" : "public",
"type" : "int(string contentType)",
"comment" : "\n Removes a supported type from an application, if possible.\n Params:\n contentType = a string.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 352}
,
{
"name" : "getAll",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets a list of all of the applications currently registered\n on this system.\n For desktop files, this includes applications that have\n NoDisplay=true set or are excluded from\n display by means of OnlyShowIn or\n NotShowIn. See g_app_info_should_show().\n The returned list does not include applications which have\n the Hidden key set.\n Returns: a newly allocated GList of references to GAppInfos. [element-type GAppInfo][transfer full GAppInfo]\n\t \n",
"line" : 365}
,
{
"name" : "getAllForType",
"kind" : "function",
"protection" : "public",
"type" : "ListG(string contentType)",
"comment" : "\n Gets a list of all GAppInfos for a given content type.\n Params:\n contentType = the content type to find a GAppInfo for\n Returns: GList of GAppInfos for given content_type or NULL on error. [element-type GAppInfo][transfer full GAppInfo]\n\t \n",
"line" : 373}
,
{
"name" : "getDefaultForType",
"kind" : "function",
"protection" : "public",
"type" : "AppInfoIF(string contentType, int mustSupportUris)",
"comment" : "\n Gets the GAppInfo that corresponds to a given content type.\n Params:\n contentType = the content type to find a GAppInfo for\n mustSupportUris = if TRUE, the GAppInfo is expected to\n  support URIs\n Returns: GAppInfo for given content_type or NULL on error.\n\t \n",
"line" : 383}
,
{
"name" : "getDefaultForUriScheme",
"kind" : "function",
"protection" : "public",
"type" : "AppInfoIF(string uriScheme)",
"comment" : "\n Gets the default application for launching applications\n using this URI scheme. A URI scheme is the initial part\n of the URI, up to but not including the ':', e.g. \"http\",\n \"ftp\" or \"sip\".\n Params:\n uriScheme = a string containing a URI scheme.\n Returns: GAppInfo for given uri_scheme or NULL on error.\n\t \n",
"line" : 394}
,
{
"name" : "launchDefaultForUri",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, AppLaunchContext launchContext)",
"comment" : "\n Utility function that launches the default application\n registered to handle the specified uri. Synchronous I\/O\n is done on the uri to detect the type of the file if\n required.\n Params:\n uri = the uri to show\n launchContext = an optional GAppLaunchContext.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 407}
]
}
]
}
,
{
"name" : "gio.AppInfoT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AppInfoT.d",
"members" : [
{
"name" : "AppInfoT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GAppInfo and GAppLaunchContext are used for describing and launching\n applications installed on the system.\n As of GLib 2.20, URIs will always be converted to POSIX paths\n (using g_file_get_path()) when using g_app_info_launch() even if\n the application requested an URI and not a POSIX path. For example\n for an desktop-file based application with Exec key totem\n %U and a single URI,\n sftp:\/\/foo\/file.avi, then\n \/home\/user\/.gvfs\/sftp on foo\/file.avi will be\n passed. This will only work if a set of suitable GIO extensions\n (such as gvfs 2.26 compiled with FUSE support), is available and\n operational; if this is not the case, the URI will be passed\n unmodified to the application. Some URIs, such as\n mailto:, of course cannot be mapped to a POSIX\n path (in gvfs there's no FUSE mount for it); such URIs will be\n passed unmodified to the application.\n Specifically for gvfs 2.26 and later, the POSIX URI will be mapped\n back to the GIO URI in the GFile constructors (since gvfs\n implements the GVfs extension point). As such, if the application\n needs to examine the URI, it needs to use g_file_get_uri() or\n similar on GFile. In other words, an application cannot assume\n that the URI passed to e.g. g_file_new_for_commandline_arg() is\n equal to the result of g_file_get_uri(). The following snippet\n illustrates this:\n GFile *f;\n char *uri;\n file = g_file_new_for_commandline_arg (uri_from_commandline);\n uri = g_file_get_uri (file);\n strcmp (uri, uri_from_commandline) == 0; \/\/ FALSE\n g_free (uri);\n if (g_file_has_uri_scheme (file, \"cdda\"))\n  {\n  \/\/ do something special with uri\n  }\n g_object_unref (file);\n This code will work when both cdda:\/\/sr0\/Track\n 1.wav and \/home\/user\/.gvfs\/cdda on sr0\/Track\n 1.wav is passed to the application. It should be noted\n that it's generally not safe for applications to rely on the format\n of a particular URIs. Different launcher applications (e.g. file\n managers) may have different ideas of what a given URI means.\n \n",
"line" : 129,
"members" : [
{
"name" : "gAppInfo",
"kind" : "variable",
"type" : "GAppInfo*",
"comment" : " the main Gtk struct \n",
"line" : 133}
,
{
"name" : "getAppInfoTStruct",
"kind" : "function",
"type" : "GAppInfo*()",
"line" : 136}
,
{
"name" : "createFromCommandline",
"kind" : "function",
"type" : "AppInfoIF(string commandline, string applicationName, GAppInfoCreateFlags flags)",
"comment" : "\n\t \n\n Creates a new GAppInfo from the given information.\n Params:\n commandline = the commandline to use\n applicationName = the application name, or NULL to use commandline. [allow-none]\n flags = flags that can specify details of the created GAppInfo\n Returns: new GAppInfo for given command.\n Throws: GException on failure.\n\t \n",
"line" : 154}
,
{
"name" : "dup",
"kind" : "function",
"type" : "AppInfoIF()",
"comment" : "\n Creates a duplicate of a GAppInfo.\n Returns: a duplicate of appinfo.\n\t \n",
"line" : 177}
,
{
"name" : "equal",
"kind" : "function",
"type" : "int(AppInfoIF appinfo2)",
"comment" : "\n Checks if two GAppInfos are equal.\n Params:\n appinfo2 = the second GAppInfo.\n Returns: TRUE if appinfo1 is equal to appinfo2. FALSE otherwise.\n\t \n",
"line" : 194}
,
{
"name" : "getId",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the ID of an application. An id is a string that\n identifies the application. The exact format of the id is\n platform dependent. For instance, on Unix this is the\n desktop file id from the xdg menu specification.\n Note that the returned ID may be NULL, depending on how\n the appinfo has been constructed.\n Returns: a string containing the application's ID.\n\t \n",
"line" : 209}
,
{
"name" : "getName",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the installed name of the application.\n Returns: the name of the application for appinfo.\n\t \n",
"line" : 219}
,
{
"name" : "getDisplayName",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the display name of the application. The display name is often more\n descriptive to the user than the name itself.\n Since 2.24\n Returns: the display name of the application for appinfo, or the name if no display name is available.\n\t \n",
"line" : 231}
,
{
"name" : "getDescription",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets a human-readable description of an installed application.\n Returns: a string containing a description of the application appinfo, or NULL if none.\n\t \n",
"line" : 241}
,
{
"name" : "getExecutable",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the executable's name for the installed application.\n Returns: a string containing the appinfo's application binaries name\n\t \n",
"line" : 251}
,
{
"name" : "getCommandline",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the commandline with which the application will be\n started.\n Since 2.20\n Returns: a string containing the appinfo's commandline, or NULL if this information is not available\n\t \n",
"line" : 263}
,
{
"name" : "getIcon",
"kind" : "function",
"type" : "IconIF()",
"comment" : "\n Gets the icon for the application.\n Returns: the default GIcon for appinfo. [transfer none]\n\t \n",
"line" : 273}
,
{
"name" : "launch",
"kind" : "function",
"type" : "int(ListG files, AppLaunchContext launchContext)",
"comment" : "\n Launches the application. Passes files to the launched application\n as arguments, using the optional launch_context to get information\n about the details of the launcher (like what screen it is on).\n On error, error will be set accordingly.\n To launch the application without arguments pass a NULL files list.\n Note that even if the launch is successful the application launched\n can fail to start if it runs into problems during startup. There is\n no way to detect this.\n Some URIs can be changed when passed through a GFile (for instance\n unsupported uris with strange formats like mailto:), so if you have\n a textual uri you want to pass in as argument, consider using\n g_app_info_launch_uris() instead.\n On UNIX, this function sets the <envvar>GIO_LAUNCHED_DESKTOP_FILE<\/envvar>\n environment variable with the path of the launched desktop file and\n <envvar>GIO_LAUNCHED_DESKTOP_FILE_PID<\/envvar> to the process\n id of the launched process. This can be used to ignore\n <envvar>GIO_LAUNCHED_DESKTOP_FILE<\/envvar>, should it be inherited\n by further processes. The <envvar>DISPLAY<\/envvar> and\n <envvar>DESKTOP_STARTUP_ID<\/envvar> environment variables are also\n set, based on information provided in launch_context.\n Params:\n files = a GList of GFile objects. [element-type GFile]\n launchContext = a GAppLaunchContext or NULL. [allow-none]\n Returns: TRUE on successful launch, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 311}
,
{
"name" : "supportsFiles",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if the application accepts files as arguments.\n Returns: TRUE if the appinfo supports files.\n\t \n",
"line" : 330}
,
{
"name" : "supportsUris",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if the application supports reading files and directories from URIs.\n Returns: TRUE if the appinfo supports URIs.\n\t \n",
"line" : 340}
,
{
"name" : "launchUris",
"kind" : "function",
"type" : "int(ListG uris, AppLaunchContext launchContext)",
"comment" : "\n Launches the application. Passes uris to the launched application\n as arguments, using the optional launch_context to get information\n about the details of the launcher (like what screen it is on).\n On error, error will be set accordingly.\n To lauch the application without arguments pass a NULL uris list.\n Note that even if the launch is successful the application launched\n can fail to start if it runs into problems during startup. There is\n no way to detect this.\n Params:\n uris = a GList containing URIs to launch. [element-type char*]\n launchContext = a GAppLaunchContext or NULL. [allow-none]\n Returns: TRUE on successful launch, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 361}
,
{
"name" : "shouldShow",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if the application info should be shown in menus that\n list available applications.\n Returns: TRUE if the appinfo should be shown, FALSE otherwise.\n\t \n",
"line" : 381}
,
{
"name" : "canDelete",
"kind" : "function",
"type" : "int()",
"comment" : "\n Obtains the information whether the GAppInfo can be deleted.\n See g_app_info_delete().\n Since 2.20\n Returns: TRUE if appinfo can be deleted\n\t \n",
"line" : 393}
,
{
"name" : "delet",
"kind" : "function",
"type" : "int()",
"comment" : "\n Tries to delete a GAppInfo.\n On some platforms, there may be a difference between user-defined\n GAppInfos which can be deleted, and system-wide ones which\n cannot. See g_app_info_can_delete().\n Since 2.20\n Returns: TRUE if appinfo has been deleted\n\t \n",
"line" : 407}
,
{
"name" : "resetTypeAssociations",
"kind" : "function",
"type" : "void(string contentType)",
"comment" : "\n Removes all changes to the type associations done by\n g_app_info_set_as_default_for_type(),\n g_app_info_set_as_default_for_extension(),\n g_app_info_add_supports_type() or g_app_info_remove_supports_type().\n Since 2.20\n Params:\n contentType = a content type\n\t \n",
"line" : 422}
,
{
"name" : "setAsDefaultForType",
"kind" : "function",
"type" : "int(string contentType)",
"comment" : "\n Sets the application as the default handler for a given type.\n Params:\n contentType = the content type.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 435}
,
{
"name" : "setAsDefaultForExtension",
"kind" : "function",
"type" : "int(string extension)",
"comment" : "\n Sets the application as the default handler for the given file extension.\n Params:\n extension = a string containing the file extension (without the dot).\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 457}
,
{
"name" : "addSupportsType",
"kind" : "function",
"type" : "int(string contentType)",
"comment" : "\n Adds a content type to the application information to indicate the\n application is capable of opening files with the given content type.\n Params:\n contentType = a string.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 480}
,
{
"name" : "canRemoveSupportsType",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a supported content type can be removed from an application.\n Returns: TRUE if it is possible to remove supported content types from a given appinfo, FALSE if not.\n\t \n",
"line" : 499}
,
{
"name" : "removeSupportsType",
"kind" : "function",
"type" : "int(string contentType)",
"comment" : "\n Removes a supported type from an application, if possible.\n Params:\n contentType = a string.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 512}
,
{
"name" : "getAll",
"kind" : "function",
"type" : "ListG()",
"comment" : "\n Gets a list of all of the applications currently registered\n on this system.\n For desktop files, this includes applications that have\n NoDisplay=true set or are excluded from\n display by means of OnlyShowIn or\n NotShowIn. See g_app_info_should_show().\n The returned list does not include applications which have\n the Hidden key set.\n Returns: a newly allocated GList of references to GAppInfos. [element-type GAppInfo][transfer full GAppInfo]\n\t \n",
"line" : 538}
,
{
"name" : "getAllForType",
"kind" : "function",
"type" : "ListG(string contentType)",
"comment" : "\n Gets a list of all GAppInfos for a given content type.\n Params:\n contentType = the content type to find a GAppInfo for\n Returns: GList of GAppInfos for given content_type or NULL on error. [element-type GAppInfo][transfer full GAppInfo]\n\t \n",
"line" : 555}
,
{
"name" : "getDefaultForType",
"kind" : "function",
"type" : "AppInfoIF(string contentType, int mustSupportUris)",
"comment" : "\n Gets the GAppInfo that corresponds to a given content type.\n Params:\n contentType = the content type to find a GAppInfo for\n mustSupportUris = if TRUE, the GAppInfo is expected to\n  support URIs\n Returns: GAppInfo for given content_type or NULL on error.\n\t \n",
"line" : 574}
,
{
"name" : "getDefaultForUriScheme",
"kind" : "function",
"type" : "AppInfoIF(string uriScheme)",
"comment" : "\n Gets the default application for launching applications\n using this URI scheme. A URI scheme is the initial part\n of the URI, up to but not including the ':', e.g. \"http\",\n \"ftp\" or \"sip\".\n Params:\n uriScheme = a string containing a URI scheme.\n Returns: GAppInfo for given uri_scheme or NULL on error.\n\t \n",
"line" : 594}
,
{
"name" : "launchDefaultForUri",
"kind" : "function",
"type" : "int(string uri, AppLaunchContext launchContext)",
"comment" : "\n Utility function that launches the default application\n registered to handle the specified uri. Synchronous I\/O\n is done on the uri to detect the type of the file if\n required.\n Params:\n uri = the uri to show\n launchContext = an optional GAppLaunchContext.\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 616}
]
}
]
}
,
{
"name" : "gio.AppLaunchContext",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AppLaunchContext.d",
"members" : [
{
"name" : "AppLaunchContext",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 74,
"base" : "Object",
"members" : [
{
"name" : "gAppLaunchContext",
"kind" : "variable",
"protection" : "protected",
"type" : "GAppLaunchContext*",
"comment" : " the main Gtk struct \n",
"line" : 77}
,
{
"name" : "getAppLaunchContextStruct",
"kind" : "function",
"protection" : "public",
"type" : "GAppLaunchContext*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 87}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "AppLaunchContext(GAppLaunchContext* gAppLaunchContext)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 95}
]
}
]
}
,
{
"name" : "gio.AsyncInitableIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AsyncInitableIF.d",
"members" : [
{
"name" : "AsyncInitableIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n This is the asynchronous version of GInitable; it behaves the same\n in all ways except that initialization is asynchronous. For more details\n see the descriptions on GInitable.\n A class may implement both the GInitable and GAsyncInitable interfaces.\n Users of objects implementing this are not intended to use the interface\n method directly; instead it will be used automatically in various ways.\n For C applications you generally just call g_async_initable_new_async()\n directly, or indirectly via a foo_thing_new_async() wrapper. This will call\n g_async_initable_init_async() under the cover, calling back with NULL and\n a set GError on failure.\n A typical implementation might look something like this:\n $(DDOC_COMMENT example)\n \n",
"line" : 94,
"members" : [
{
"name" : "getAsyncInitableTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GAsyncInitable*()",
"line" : 97}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 100}
,
{
"name" : "gAsyncInitableInitAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n\t \n\n Starts asynchronous initialization of the object implementing the\n interface. This must be done before any real use of the object after\n initial construction. If the object also implements GInitable you can\n optionally call g_initable_init() instead.\n When the initialization is finished, callback will be called. You can\n then call g_async_initable_init_finish() to get the result of the\n initialization.\n Implementations may also support cancellation. If cancellable is not\n NULL, then initialization can be cancelled by triggering the cancellable\n object from another thread. If the operation was cancelled, the error\n G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL, and\n the object doesn't support cancellable initialization, the error\n G_IO_ERROR_NOT_SUPPORTED will be returned.\n If this function is not called, or returns with an error, then all\n operations on the object should fail, generally returning the\n error G_IO_ERROR_NOT_INITIALIZED.\n Implementations of this method must be idempotent: i.e. multiple calls\n to this function with the same argument should return the same results.\n Only the first call initializes the object; further calls return the result\n of the first call. This is so that it's safe to implement the singleton\n pattern in the GObject constructor function.\n For classes that also support the GInitable interface, the default\n implementation of this method will run the g_initable_init() function\n in a thread, so if you want to support asynchronous initialization via\n threads, just implement the GAsyncInitable interface without overriding\n any interface methods.\n Since 2.22\n Params:\n ioPriority = the I\/O priority\n  of the operation.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 141}
,
{
"name" : "gAsyncInitableInitFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res)",
"comment" : "\n Finishes asynchronous initialization and returns the result.\n See g_async_initable_init_async().\n Since 2.22\n Params:\n res = a GAsyncResult.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 152}
,
{
"name" : "gAsyncInitableNewFinish",
"kind" : "function",
"protection" : "public",
"type" : "ObjectG(AsyncResultIF res)",
"comment" : "\n Finishes the async construction for the various g_async_initable_new calls,\n returning the created object or NULL on error.\n Since 2.22\n Params:\n res = the GAsyncResult.from the callback\n Returns: a newly created GObject, or NULL on error. Free with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 163}
,
{
"name" : "gAsyncInitableNewValistAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(GType objectType, string firstPropertyName, void* varArgs, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Helper function for constructing GAsyncInitiable object. This is\n similar to g_object_new_valist() but also initializes the object\n asynchronously.\n When the initialization is finished, callback will be called. You can\n then call g_async_initable_new_finish() to get the new object and check\n for any errors.\n Since 2.22\n Params:\n objectType = a GType supporting GAsyncInitable.\n firstPropertyName = the name of the first property, followed by\n the value, and other property value pairs, and ended by NULL.\n varArgs = The var args list generated from first_property_name.\n ioPriority = the I\/O priority\n  of the operation.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the initialization is\n  finished\n userData = the data to pass to callback function\n\t \n",
"line" : 185}
,
{
"name" : "gAsyncInitableNewvAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(GType objectType, GParameter[] parameters, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Helper function for constructing GAsyncInitiable object. This is\n similar to g_object_newv() but also initializes the object asynchronously.\n When the initialization is finished, callback will be called. You can\n then call g_async_initable_new_finish() to get the new object and check\n for any errors.\n Since 2.22\n Params:\n objectType = a GType supporting GAsyncInitable.\n parameters = the parameters to use to construct the object\n ioPriority = the I\/O priority\n  of the operation.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the initialization is\n  finished\n userData = the data to pass to callback function\n\t \n",
"line" : 204}
]
}
]
}
,
{
"name" : "gio.AsyncInitableT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AsyncInitableT.d",
"members" : [
{
"name" : "AsyncInitableT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n This is the asynchronous version of GInitable; it behaves the same\n in all ways except that initialization is asynchronous. For more details\n see the descriptions on GInitable.\n A class may implement both the GInitable and GAsyncInitable interfaces.\n Users of objects implementing this are not intended to use the interface\n method directly; instead it will be used automatically in various ways.\n For C applications you generally just call g_async_initable_new_async()\n directly, or indirectly via a foo_thing_new_async() wrapper. This will call\n g_async_initable_init_async() under the cover, calling back with NULL and\n a set GError on failure.\n A typical implementation might look something like this:\n $(DDOC_COMMENT example)\n \n",
"line" : 94,
"members" : [
{
"name" : "gAsyncInitable",
"kind" : "variable",
"type" : "GAsyncInitable*",
"comment" : " the main Gtk struct \n",
"line" : 98}
,
{
"name" : "getAsyncInitableTStruct",
"kind" : "function",
"type" : "GAsyncInitable*()",
"line" : 101}
,
{
"name" : "gAsyncInitableInitAsync",
"kind" : "function",
"type" : "void(int ioPriority, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n\t \n\n Starts asynchronous initialization of the object implementing the\n interface. This must be done before any real use of the object after\n initial construction. If the object also implements GInitable you can\n optionally call g_initable_init() instead.\n When the initialization is finished, callback will be called. You can\n then call g_async_initable_init_finish() to get the result of the\n initialization.\n Implementations may also support cancellation. If cancellable is not\n NULL, then initialization can be cancelled by triggering the cancellable\n object from another thread. If the operation was cancelled, the error\n G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL, and\n the object doesn't support cancellable initialization, the error\n G_IO_ERROR_NOT_SUPPORTED will be returned.\n If this function is not called, or returns with an error, then all\n operations on the object should fail, generally returning the\n error G_IO_ERROR_NOT_INITIALIZED.\n Implementations of this method must be idempotent: i.e. multiple calls\n to this function with the same argument should return the same results.\n Only the first call initializes the object; further calls return the result\n of the first call. This is so that it's safe to implement the singleton\n pattern in the GObject constructor function.\n For classes that also support the GInitable interface, the default\n implementation of this method will run the g_initable_init() function\n in a thread, so if you want to support asynchronous initialization via\n threads, just implement the GAsyncInitable interface without overriding\n any interface methods.\n Since 2.22\n Params:\n ioPriority = the I\/O priority\n  of the operation.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 145}
,
{
"name" : "gAsyncInitableInitFinish",
"kind" : "function",
"type" : "int(AsyncResultIF res)",
"comment" : "\n Finishes asynchronous initialization and returns the result.\n See g_async_initable_init_async().\n Since 2.22\n Params:\n res = a GAsyncResult.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 160}
,
{
"name" : "gAsyncInitableNewFinish",
"kind" : "function",
"type" : "ObjectG(AsyncResultIF res)",
"comment" : "\n Finishes the async construction for the various g_async_initable_new calls,\n returning the created object or NULL on error.\n Since 2.22\n Params:\n res = the GAsyncResult.from the callback\n Returns: a newly created GObject, or NULL on error. Free with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 184}
,
{
"name" : "gAsyncInitableNewValistAsync",
"kind" : "function",
"type" : "void(GType objectType, string firstPropertyName, void* varArgs, int ioPriority, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Helper function for constructing GAsyncInitiable object. This is\n similar to g_object_new_valist() but also initializes the object\n asynchronously.\n When the initialization is finished, callback will be called. You can\n then call g_async_initable_new_finish() to get the new object and check\n for any errors.\n Since 2.22\n Params:\n objectType = a GType supporting GAsyncInitable.\n firstPropertyName = the name of the first property, followed by\n the value, and other property value pairs, and ended by NULL.\n varArgs = The var args list generated from first_property_name.\n ioPriority = the I\/O priority\n  of the operation.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the initialization is\n  finished\n userData = the data to pass to callback function\n\t \n",
"line" : 223}
,
{
"name" : "gAsyncInitableNewvAsync",
"kind" : "function",
"type" : "void(GType objectType, GParameter[] parameters, int ioPriority, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Helper function for constructing GAsyncInitiable object. This is\n similar to g_object_newv() but also initializes the object asynchronously.\n When the initialization is finished, callback will be called. You can\n then call g_async_initable_new_finish() to get the new object and check\n for any errors.\n Since 2.22\n Params:\n objectType = a GType supporting GAsyncInitable.\n parameters = the parameters to use to construct the object\n ioPriority = the I\/O priority\n  of the operation.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the initialization is\n  finished\n userData = the data to pass to callback function\n\t \n",
"line" : 246}
]
}
]
}
,
{
"name" : "gio.AsyncResultIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AsyncResultIF.d",
"members" : [
{
"name" : "AsyncResultIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n Provides a base class for implementing asynchronous function results.\n Asynchronous operations are broken up into two separate operations\n which are chained together by a GAsyncReadyCallback. To begin\n an asynchronous operation, provide a GAsyncReadyCallback to the\n asynchronous function. This callback will be triggered when the\n operation has completed, and will be passed a GAsyncResult instance\n filled with the details of the operation's success or failure, the\n object the asynchronous function was started for and any error codes\n returned. The asynchronous callback function is then expected to call\n the corresponding \"_finish()\" function, passing the object the\n function was called for, the GAsyncResult instance, and (optionally)\n an error to grab any error conditions that may have occurred.\n The \"_finish()\" function for an operation takes the generic result\n (of type GAsyncResult) and returns the specific result that the\n operation in question yields (e.g. a GFileEnumerator for a\n \"enumerate children\" operation). If the result or error status of the\n operation is not needed, there is no need to call the \"_finish()\"\n function; GIO will take care of cleaning up the result and error\n information after the GAsyncReadyCallback returns. Applications may\n also take a reference to the GAsyncResult and call \"_finish()\"\n later; however, the \"_finish()\" function may be called at most once.\n Example of a typical asynchronous operation flow:\n $(DDOC_COMMENT example)\n The callback for an asynchronous operation is called only once, and is\n always called, even in the case of a cancelled operation. On cancellation\n the result is a G_IO_ERROR_CANCELLED error.\n Some asynchronous operations are implemented using synchronous calls.\n These are run in a separate thread, if GThread has been initialized, but\n otherwise they are sent to the Main Event Loop and processed in an idle\n function. So, if you truly need asynchronous operations, make sure to\n initialize GThread.\n \n",
"line" : 101,
"members" : [
{
"name" : "getAsyncResultTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GAsyncResult*()",
"line" : 104}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 107}
,
{
"name" : "getUserData",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n\t \n\n Gets the user data from a GAsyncResult.\n Returns: the user data for res.\n\t \n",
"line" : 117}
,
{
"name" : "getSourceObject",
"kind" : "function",
"protection" : "public",
"type" : "ObjectG()",
"comment" : "\n Gets the source object from a GAsyncResult.\n Returns: a new reference to the source object for the res, or NULL if there is none.\n\t \n",
"line" : 123}
]
}
]
}
,
{
"name" : "gio.AsyncResultT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/AsyncResultT.d",
"members" : [
{
"name" : "AsyncResultT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n Provides a base class for implementing asynchronous function results.\n Asynchronous operations are broken up into two separate operations\n which are chained together by a GAsyncReadyCallback. To begin\n an asynchronous operation, provide a GAsyncReadyCallback to the\n asynchronous function. This callback will be triggered when the\n operation has completed, and will be passed a GAsyncResult instance\n filled with the details of the operation's success or failure, the\n object the asynchronous function was started for and any error codes\n returned. The asynchronous callback function is then expected to call\n the corresponding \"_finish()\" function, passing the object the\n function was called for, the GAsyncResult instance, and (optionally)\n an error to grab any error conditions that may have occurred.\n The \"_finish()\" function for an operation takes the generic result\n (of type GAsyncResult) and returns the specific result that the\n operation in question yields (e.g. a GFileEnumerator for a\n \"enumerate children\" operation). If the result or error status of the\n operation is not needed, there is no need to call the \"_finish()\"\n function; GIO will take care of cleaning up the result and error\n information after the GAsyncReadyCallback returns. Applications may\n also take a reference to the GAsyncResult and call \"_finish()\"\n later; however, the \"_finish()\" function may be called at most once.\n Example of a typical asynchronous operation flow:\n $(DDOC_COMMENT example)\n The callback for an asynchronous operation is called only once, and is\n always called, even in the case of a cancelled operation. On cancellation\n the result is a G_IO_ERROR_CANCELLED error.\n Some asynchronous operations are implemented using synchronous calls.\n These are run in a separate thread, if GThread has been initialized, but\n otherwise they are sent to the Main Event Loop and processed in an idle\n function. So, if you truly need asynchronous operations, make sure to\n initialize GThread.\n \n",
"line" : 101,
"members" : [
{
"name" : "gAsyncResult",
"kind" : "variable",
"type" : "GAsyncResult*",
"comment" : " the main Gtk struct \n",
"line" : 105}
,
{
"name" : "getAsyncResultTStruct",
"kind" : "function",
"type" : "GAsyncResult*()",
"line" : 108}
,
{
"name" : "getUserData",
"kind" : "function",
"type" : "void*()",
"comment" : "\n\t \n\n Gets the user data from a GAsyncResult.\n Returns: the user data for res.\n\t \n",
"line" : 121}
,
{
"name" : "getSourceObject",
"kind" : "function",
"type" : "ObjectG()",
"comment" : "\n Gets the source object from a GAsyncResult.\n Returns: a new reference to the source object for the res, or NULL if there is none.\n\t \n",
"line" : 131}
]
}
]
}
,
{
"name" : "gio.BufferedInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/BufferedInputStream.d",
"members" : [
{
"name" : "BufferedInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Buffered input stream implements GFilterInputStream and provides\n for buffered reads.\n By default, GBufferedInputStream's buffer size is set at 4 kilobytes.\n To create a buffered input stream, use g_buffered_input_stream_new(),\n or g_buffered_input_stream_new_sized() to specify the buffer's size at\n construction.\n To get the size of a buffer within a buffered input stream, use\n g_buffered_input_stream_get_buffer_size(). To change the size of a\n buffered input stream's buffer, use\n g_buffered_input_stream_set_buffer_size(). Note that the buffer's size\n cannot be reduced below the size of the data within the buffer.\n \n",
"line" : 91,
"base" : "FilterInputStream",
"members" : [
{
"name" : "gBufferedInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GBufferedInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 95}
,
{
"name" : "getBufferedInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GBufferedInputStream*()",
"line" : 98}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedInputStream(GBufferedInputStream* gBufferedInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 113}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 131}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedInputStream(InputStream baseStream)",
"comment" : "\n\t \n\n Creates a new GInputStream from the given base_stream, with\n a buffer set to the default size (4 kilobytes).\n Params:\n baseStream = a GInputStream\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 147}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedInputStream(InputStream baseStream, ulong size)",
"comment" : "\n Creates a new GBufferedInputStream from the given base_stream,\n with a buffer set to size.\n Params:\n baseStream = a GInputStream\n size = a gsize\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 166}
,
{
"name" : "getBufferSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the size of the input buffer.\n Returns: the current buffer size.\n\t \n",
"line" : 181}
,
{
"name" : "setBufferSize",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong size)",
"comment" : "\n Sets the size of the internal buffer of stream to size, or to the\n size of the contents of the buffer. The buffer can never be resized\n smaller than its current contents.\n Params:\n size = a gsize\n\t \n",
"line" : 194}
,
{
"name" : "getAvailable",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the size of the available data within the stream.\n Returns: size of the available stream.\n\t \n",
"line" : 204}
,
{
"name" : "peekBuffer",
"kind" : "function",
"protection" : "public",
"type" : "void*(out ulong count)",
"comment" : "\n Returns the buffer with the currently available bytes. The returned\n buffer must not be modified and will become invalid when reading from\n the stream or filling the buffer.\n Params:\n count = a gsize to get the number of bytes available in the buffer\n Returns: read-only buffer\n\t \n",
"line" : 218}
,
{
"name" : "peek",
"kind" : "function",
"protection" : "public",
"type" : "ulong(void* buffer, ulong offset, ulong count)",
"comment" : "\n Peeks in the buffer, copying data of size count into buffer,\n offset offset bytes.\n Params:\n buffer = a pointer to an allocated chunk of memory\n offset = a gsize\n count = a gsize\n Returns: a gsize of the number of bytes peeked, or -1 on error.\n\t \n",
"line" : 233}
,
{
"name" : "fill",
"kind" : "function",
"protection" : "public",
"type" : "long(long count, Cancellable cancellable)",
"comment" : "\n Tries to read count bytes from the stream into the buffer.\n Will block during this read.\n If count is zero, returns zero and does nothing. A value of count\n larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.\n On success, the number of bytes read into the buffer is returned.\n It is not an error if this is not the same as the requested size, as it\n can happen e.g. near the end of a file. Zero is returned on end of file\n (or if count is zero), but never otherwise.\n If count is -1 then the attempted read size is equal to the number of\n bytes that are required to fill the buffer.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n On error -1 is returned and error is set accordingly.\n For the asynchronous, non-blocking, version of this function, see\n g_buffered_input_stream_fill_async().\n Params:\n count = the number of bytes that will be read from the stream\n cancellable = optional GCancellable object, NULL to ignore\n Returns: the number of bytes read into stream's buffer, up to count, or -1 on error.\n Throws: GException on failure.\n\t \n",
"line" : 264}
,
{
"name" : "fillAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(long count, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Reads data into stream's buffer asynchronously, up to count size.\n io_priority can be used to prioritize reads. For the synchronous\n version of this function, see g_buffered_input_stream_fill().\n If count is -1 then the attempted read size is equal to the number\n of bytes that are required to fill the buffer.\n Params:\n count = the number of bytes that will be read from the stream\n ioPriority = the I\/O priority\n  of the request\n cancellable = optional GCancellable object\n callback = a GAsyncReadyCallback\n userData = a gpointer\n\t \n",
"line" : 293}
,
{
"name" : "fillFinish",
"kind" : "function",
"protection" : "public",
"type" : "long(AsyncResultIF result)",
"comment" : "\n Finishes an asynchronous read.\n Params:\n result = a GAsyncResult\n Returns: a gssize of the read stream, or -1 on an error.\n Throws: GException on failure.\n\t \n",
"line" : 306}
,
{
"name" : "readByte",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Tries to read a single byte from the stream or the buffer. Will block\n during this read.\n On success, the byte read from the stream is returned. On end of stream\n -1 is returned but it's not an exceptional error and error is not set.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n On error -1 is returned and error is set accordingly.\n Params:\n cancellable = optional GCancellable object, NULL to ignore\n Returns: the byte read from the stream, or -1 on end of stream or error.\n Throws: GException on failure.\n\t \n",
"line" : 337}
]
}
]
}
,
{
"name" : "gio.BufferedOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/BufferedOutputStream.d",
"members" : [
{
"name" : "BufferedOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Buffered output stream implements GFilterOutputStream and provides\n for buffered writes.\n By default, GBufferedOutputStream's buffer size is set at 4 kilobytes.\n To create a buffered output stream, use g_buffered_output_stream_new(),\n or g_buffered_output_stream_new_sized() to specify the buffer's size\n at construction.\n To get the size of a buffer within a buffered input stream, use\n g_buffered_output_stream_get_buffer_size(). To change the size of a\n buffered output stream's buffer, use\n g_buffered_output_stream_set_buffer_size(). Note that the buffer's\n size cannot be reduced below the size of the data within the buffer.\n \n",
"line" : 81,
"base" : "FilterOutputStream",
"members" : [
{
"name" : "gBufferedOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GBufferedOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 85}
,
{
"name" : "getBufferedOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GBufferedOutputStream*()",
"line" : 88}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 95}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedOutputStream(GBufferedOutputStream* gBufferedOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 103}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 121}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedOutputStream(OutputStream baseStream)",
"comment" : "\n\t \n\n Creates a new buffered output stream for a base stream.\n Params:\n baseStream = a GOutputStream.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 136}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BufferedOutputStream(OutputStream baseStream, ulong size)",
"comment" : "\n Creates a new buffered output stream with a given buffer size.\n Params:\n baseStream = a GOutputStream.\n size = a gsize.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 154}
,
{
"name" : "getBufferSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the size of the buffer in the stream.\n Returns: the current size of the buffer.\n\t \n",
"line" : 169}
,
{
"name" : "setBufferSize",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong size)",
"comment" : "\n Sets the size of the internal buffer to size.\n Params:\n size = a gsize.\n\t \n",
"line" : 180}
,
{
"name" : "getAutoGrow",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the buffer automatically grows as data is added.\n Returns: TRUE if the stream's buffer automatically grows, FALSE otherwise.\n\t \n",
"line" : 190}
,
{
"name" : "setAutoGrow",
"kind" : "function",
"protection" : "public",
"type" : "void(int autoGrow)",
"comment" : "\n Sets whether or not the stream's buffer should automatically grow.\n If auto_grow is true, then each write will just make the buffer\n larger, and you must manually flush the buffer to actually write out\n the data to the underlying stream.\n Params:\n autoGrow = a gboolean.\n\t \n",
"line" : 204}
]
}
]
}
,
{
"name" : "gio.Cancellable",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Cancellable.d",
"members" : [
{
"name" : "Cancellable",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GCancellable is a thread-safe operation cancellation stack used\n throughout GIO to allow for cancellation of synchronous and\n asynchronous operations.\n \n",
"line" : 77,
"base" : "ObjectG",
"members" : [
{
"name" : "gCancellable",
"kind" : "variable",
"protection" : "protected",
"type" : "GCancellable*",
"comment" : " the main Gtk struct \n",
"line" : 81}
,
{
"name" : "getCancellableStruct",
"kind" : "function",
"protection" : "public",
"type" : "GCancellable*()",
"line" : 84}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 91}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Cancellable(GCancellable* gCancellable)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 99}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 117}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 125}
,
{
"name" : "onCancelledListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(Cancellable)[]",
"line" : 127}
,
{
"name" : "addOnCancelled",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(Cancellable) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the operation has been cancelled.\n Can be used by implementations of cancellable operations. If the\n operation is cancelled from another thread, the signal will be\n emitted in the thread that cancelled the operation, not the\n thread that is running the operation.\n Note that disconnecting from this signal (or any signal) in a\n multi-threaded program is prone to race conditions. For instance\n it is possible that a signal handler may be invoked even\n after a call to\n g_signal_handler_disconnect() for that handler has already\n returned.\n There is also a problem when cancellation happen\n right before connecting to the signal. If this happens the\n signal will unexpectedly not be emitted, and checking before\n connecting to the signal leaves a race condition where this is\n still happening.\n In order to make it safe and easy to connect handlers there\n are two helper functions: g_cancellable_connect() and\n g_cancellable_disconnect() which protect against problems\n like this.\n $(DDOC_COMMENT example)\n Note that the cancelled signal is emitted in the thread that\n the user cancelled from, which may be the main thread. So, the\n cancellable signal should not do something that can block.\n\t \n",
"line" : 154}
,
{
"name" : "callBackCancelled",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GCancellable* cancellableStruct, Cancellable cancellable)",
"line" : 169}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Cancellable()",
"comment" : "\n Creates a new GCancellable object.\n Applications that want to start one or more operations\n that should be cancellable should create a GCancellable\n and pass it to the operations.\n One GCancellable can be used in multiple consecutive\n operations, but not in multiple concurrent operations.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 187}
,
{
"name" : "isCancelled",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a cancellable job has been cancelled.\n Returns: TRUE if cancellable is cancelled, FALSE if called with NULL or if item is not cancelled.\n\t \n",
"line" : 202}
,
{
"name" : "setErrorIfCancelled",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n If the cancellable is cancelled, sets the error to notify\n that the operation was cancelled.\n Returns: TRUE if cancellable was cancelled, FALSE if it was not.\n\t \n",
"line" : 213}
,
{
"name" : "getFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the file descriptor for a cancellable job. This can be used to\n implement cancellable operations on Unix systems. The returned fd will\n turn readable when cancellable is cancelled.\n You are not supposed to read from the fd yourself, just check for\n readable status. Reading to unset the readable status is done\n with g_cancellable_reset().\n After a successful return from this function, you should use\n g_cancellable_release_fd() to free up resources allocated for\n the returned file descriptor.\n See also g_cancellable_make_pollfd().\n Returns: A valid file descriptor. -1 if the file descriptor is not supported, or on errors.\n\t \n",
"line" : 241}
,
{
"name" : "makePollfd",
"kind" : "function",
"protection" : "public",
"type" : "int(GPollFD* pollfd)",
"comment" : "\n Creates a GPollFD corresponding to cancellable; this can be passed\n to g_poll() and used to poll for cancellation. This is useful both\n for unix systems without a native poll and for portability to\n windows.\n When this function returns TRUE, you should use\n g_cancellable_release_fd() to free up resources allocated for the\n pollfd. After a FALSE return, do not call g_cancellable_release_fd().\n If this function returns FALSE, either no cancellable was given or\n resource limits prevent this function from allocating the necessary\n structures for polling. (On Linux, you will likely have reached\n the maximum number of file descriptors.) The suggested way to handle\n these cases is to ignore the cancellable.\n You are not supposed to read from the fd yourself, just check for\n readable status. Reading to unset the readable status is done\n with g_cancellable_reset().\n Since 2.22\n Params:\n pollfd = a pointer to a GPollFD\n Returns: TRUE if pollfd was successfully initialized, FALSE on failure to prepare the cancellable.\n\t \n",
"line" : 268}
,
{
"name" : "releaseFd",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Releases a resources previously allocated by g_cancellable_get_fd()\n or g_cancellable_make_pollfd().\n For compatibility reasons with older releases, calling this function\n is not strictly required, the resources will be automatically freed\n when the cancellable is finalized. However, the cancellable will\n block scarce file descriptors until it is finalized if this function\n is not called. This can cause the application to run out of file\n descriptors when many GCancellables are used at the same time.\n Since 2.22\n\t \n",
"line" : 285}
,
{
"name" : "getCurrent",
"kind" : "function",
"protection" : "public",
"type" : "Cancellable()",
"comment" : "\n Gets the top cancellable from the stack.\n Returns: a GCancellable from the top of the stack, or NULL if the stack is empty.\n\t \n",
"line" : 295}
,
{
"name" : "popCurrent",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Pops cancellable off the cancellable stack (verifying that cancellable\n is on the top of the stack).\n\t \n",
"line" : 310}
,
{
"name" : "pushCurrent",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Pushes cancellable onto the cancellable stack. The current\n cancllable can then be recieved using g_cancellable_get_current().\n This is useful when implementing cancellable operations in\n code that does not allow you to pass down the cancellable object.\n This is typically called automatically by e.g. GFile operations,\n so you rarely have to call this yourself.\n\t \n",
"line" : 324}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Resets cancellable to its uncancelled state.\n\t \n",
"line" : 333}
,
{
"name" : "connect",
"kind" : "function",
"protection" : "public",
"type" : "ulong(extern (C) void function() callback, void* data, extern (C) void function(void* cbData) dataDestroyFunc)",
"comment" : "\n Convenience function to connect to the \"cancelled\"\n signal. Also handles the race condition that may happen\n if the cancellable is cancelled right before connecting.\n callback is called at most once, either directly at the\n time of the connect if cancellable is already cancelled,\n or when cancellable is cancelled in some thread.\n data_destroy_func will be called when the handler is\n disconnected, or immediately if the cancellable is already\n cancelled.\n See \"cancelled\" for details on how to use this.\n Since 2.22\n Params:\n callback = The GCallback to connect.\n data = Data to pass to callback.\n dataDestroyFunc = Free function for data or NULL.\n Returns: The id of the signal handler or 0 if cancellable has already been cancelled.\n\t \n",
"line" : 357}
,
{
"name" : "disconnect",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong handlerId)",
"comment" : "\n Disconnects a handler from a cancellable instance similar to\n g_signal_handler_disconnect(). Additionally, in the event that a\n signal handler is currently running, this call will block until the\n handler has finished. Calling this function from a\n \"cancelled\" signal handler will therefore result in a\n deadlock.\n This avoids a race condition where a thread cancels at the\n same time as the cancellable operation is finished and the\n signal handler is removed. See \"cancelled\" for\n details on how to use this.\n If cancellable is NULL or handler_id is 0 this function does\n nothing.\n Since 2.22\n Params:\n handlerId = Handler id of the handler to be disconnected, or 0.\n\t \n",
"line" : 380}
,
{
"name" : "cancel",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Will set cancellable to cancelled, and will emit the\n \"cancelled\" signal. (However, see the warning about\n race conditions in the documentation for that signal if you are\n planning to connect to it.)\n This function is thread-safe. In other words, you can safely call\n it from a thread other than the one running the operation that was\n passed the cancellable.\n The convention within gio is that cancelling an asynchronous\n operation causes it to complete asynchronously. That is, if you\n cancel the operation from the same thread in which it is running,\n then the operation's GAsyncReadyCallback will not be invoked until\n the application returns to the main loop.\n\t \n",
"line" : 400}
]
}
]
}
,
{
"name" : "gio.CharsetConverter",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/CharsetConverter.d",
"members" : [
{
"name" : "CharsetConverter",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GCharsetConverter is an implementation of GConverter based on\n GIConv.\n \n",
"line" : 80,
"base" : "ObjectG",
"interfaces" : [
"ConverterIF"],
"members" : [
{
"name" : "gCharsetConverter",
"kind" : "variable",
"protection" : "protected",
"type" : "GCharsetConverter*",
"comment" : " the main Gtk struct \n",
"line" : 84}
,
{
"name" : "getCharsetConverterStruct",
"kind" : "function",
"protection" : "public",
"type" : "GCharsetConverter*()",
"line" : 87}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 94}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CharsetConverter(GCharsetConverter* gCharsetConverter)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 102}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 120}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "CharsetConverter(string toCharset, string fromCharset)",
"comment" : "\n\t \n\n Creates a new GCharsetConverter.\n Since 2.24\n Params:\n toCharset = destination charset\n fromCharset = source charset\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 141}
,
{
"name" : "setUseFallback",
"kind" : "function",
"protection" : "public",
"type" : "void(int useFallback)",
"comment" : "\n Sets the \"use-fallback\" property.\n Since 2.24\n Params:\n useFallback = TRUE to use fallbacks\n\t \n",
"line" : 166}
,
{
"name" : "getUseFallback",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the \"use-fallback\" property.\n Since 2.24\n Returns: TRUE if fallbacks are used by converter\n\t \n",
"line" : 177}
,
{
"name" : "getNumFallbacks",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the number of fallbacks that converter has applied so far.\n Since 2.24\n Returns: the number of fallbacks that converter has applied\n\t \n",
"line" : 188}
]
}
]
}
,
{
"name" : "gio.ContentType",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ContentType.d",
"members" : [
{
"name" : "ContentType",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A content type is a platform specific string that defines the type\n of a file. On unix it is a mime type, on win32 it is an extension string\n like \".doc\", \".txt\" or a percieved string like \"audio\". Such strings\n can be looked up in the registry at HKEY_CLASSES_ROOT.\n \n",
"line" : 84,
"base" : "Object",
"members" : [
{
"name" : "equals",
"kind" : "function",
"protection" : "public",
"type" : "int(string type1, string type2)",
"comment" : "\n\t \n\n Compares two content types for equality.\n Params:\n type1 = a content type string\n type2 = a content type string\n Returns: TRUE if the two strings are identical or equivalent, FALSE otherwise.\n\t \n",
"line" : 96}
,
{
"name" : "isA",
"kind" : "function",
"protection" : "public",
"type" : "int(string type, string supertype)",
"comment" : "\n Determines if type is a subset of supertype.\n Params:\n type = a content type string\n supertype = a content type string\n Returns: TRUE if type is a kind of supertype, FALSE otherwise.\n\t \n",
"line" : 109}
,
{
"name" : "isUnknown",
"kind" : "function",
"protection" : "public",
"type" : "int(string type)",
"comment" : "\n Checks if the content type is the generic \"unknown\" type.\n On UNIX this is the \"application\/octet-stream\" mimetype,\n while on win32 it is \"*\".\n Params:\n type = a content type string\n Returns: TRUE if the type is the unknown type.\n\t \n",
"line" : 123}
,
{
"name" : "getDescription",
"kind" : "function",
"protection" : "public",
"type" : "string(string type)",
"comment" : "\n Gets the human readable description of the content type.\n Params:\n type = a content type string\n Returns: a short description of the content type type. Free the returned string with g_free()\n\t \n",
"line" : 135}
,
{
"name" : "getMimeType",
"kind" : "function",
"protection" : "public",
"type" : "string(string type)",
"comment" : "\n Gets the mime type for the content type, if one is registered.\n Params:\n type = a content type string\n Returns: the registered mime type for the given type, or NULL if unknown. [allow-none]\n\t \n",
"line" : 147}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF(string type)",
"comment" : "\n Gets the icon for a content type.\n Params:\n type = a content type string\n Returns: GIcon corresponding to the content type. Free the returned object with g_object_unref()\n\t \n",
"line" : 159}
,
{
"name" : "canBeExecutable",
"kind" : "function",
"protection" : "public",
"type" : "int(string type)",
"comment" : "\n Checks if a content type can be executable. Note that for instance\n things like text files can be executables (i.e. scripts and batch files).\n Params:\n type = a content type string\n Returns: TRUE if the file type corresponds to a type that can be executable, FALSE otherwise.\n\t \n",
"line" : 177}
,
{
"name" : "fromMimeType",
"kind" : "function",
"protection" : "public",
"type" : "string(string mimeType)",
"comment" : "\n Tries to find a content type based on the mime type name.\n Since 2.18\n Params:\n mimeType = a mime type string\n Returns: Newly allocated string with content type or NULL. Free with g_free(). [allow-none]\n\t \n",
"line" : 190}
,
{
"name" : "guess",
"kind" : "function",
"protection" : "public",
"type" : "string(string filename, char[] data, out int resultUncertain)",
"comment" : "\n Guesses the content type based on example data. If the function is\n uncertain, result_uncertain will be set to TRUE. Either filename\n or data may be NULL, in which case the guess will be based solely\n on the other argument.\n Params:\n filename = a string, or NULL. [allow-none]\n data = a stream of data, or NULL. [allow-none][array length=data_size]\n resultUncertain = return location for the certainty\n  of the result, or NULL. [allow-none][out]\n Returns: a string indicating a guessed content type for the given data. Free with g_free()\n\t \n",
"line" : 208}
,
{
"name" : "guessForTree",
"kind" : "function",
"protection" : "public",
"type" : "string[](File root)",
"comment" : "\n Tries to guess the type of the tree with root root, by\n looking at the files it contains. The result is an array\n of content types, with the best guess coming first.\n The types returned all have the form x-content\/foo, e.g.\n x-content\/audio-cdda (for audio CDs) or x-content\/image-dcf\n (for a camera memory card). See the shared-mime-info\n specification for more on x-content types.\n This function is useful in the implementation of\n g_mount_guess_content_type().\n Since 2.18\n Params:\n root = the root of the tree to guess a type for\n Returns: an NULL-terminated array of zero or more content types, or NULL. Free with g_strfreev()\n\t \n",
"line" : 229}
,
{
"name" : "gContentTypesGetRegistered",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets a list of strings containing all the registered content types\n known to the system. The list and its data should be freed using\n g_list_foreach (list, g_free, NULL);\n g_list_free (list);\n Returns: GList of the registered content types\n\t \n",
"line" : 242}
]
}
]
}
,
{
"name" : "gio.Converter",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Converter.d",
"members" : [
{
"name" : "Converter",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"ConverterIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Converter(GConverter* gConverter)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.ConverterIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ConverterIF.d",
"members" : [
{
"name" : "ConverterIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GConverter is implemented by objects that convert\n binary data in various ways. The conversion can be\n stateful and may fail at any place.\n Some example conversions are: character set conversion,\n compression, decompression and regular expression\n replace.\n \n",
"line" : 77,
"members" : [
{
"name" : "getConverterTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GConverter*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 83}
,
{
"name" : "convert",
"kind" : "function",
"protection" : "public",
"type" : "GConverterResult(void[] inbuf, void[] outbuf, GConverterFlags flags, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n\t \n\n This is the main operation used when converting data. It is to be called\n multiple times in a loop, and each time it will do some work, i.e.\n producing some output (in outbuf) or consuming some input (from inbuf) or\n both. If its not possible to do any work an error is returned.\n Note that a single call may not consume all input (or any input at all).\n Also a call may produce output even if given no input, due to state stored\n in the converter producing output.\n If any data was either produced or consumed, and then an error happens, then\n only the successful conversion is reported and the error is returned on the\n next call.\n A full conversion loop involves calling this method repeatedly, each time\n giving it new input and space output space. When there is no more input\n data after the data in inbuf, the flag G_CONVERTER_INPUT_AT_END must be set.\n The loop will be (unless some error happens) returning G_CONVERTER_CONVERTED\n each time until all data is consumed and all output is produced, then\n G_CONVERTER_FINISHED is returned instead. Note, that G_CONVERTER_FINISHED\n may be returned even if G_CONVERTER_INPUT_AT_END is not set, for instance\n in a decompression converter where the end of data is detectable from the\n data (and there might even be other data after the end of the compressed data).\n When some data has successfully been converted bytes_read and is set to\n the number of bytes read from inbuf, and bytes_written is set to indicate\n how many bytes was written to outbuf. If there are more data to output\n or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then\n G_CONVERTER_CONVERTED is returned, and if no more data is to be output\n then G_CONVERTER_FINISHED is returned.\n On error G_CONVERTER_ERROR is returned and error is set accordingly.\n Since 2.24\n Params:\n inbuf = the buffer containing the data to convert.\n outbuf = a buffer to write converted data in.\n flags = a GConvertFlags controlling the conversion details\n bytesRead = will be set to the number of bytes read from inbuf on success\n bytesWritten = will be set to the number of bytes written to outbuf on success\n Returns: a GConverterResult, G_CONVERTER_ERROR on error.\n Throws: GException on failure.\n\t \n",
"line" : 126}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Resets all internal state in the converter, making it behave\n as if it was just created. If the converter has any internal\n state that would produce output then that output is lost.\n Since 2.24\n\t \n",
"line" : 134}
]
}
]
}
,
{
"name" : "gio.ConverterInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ConverterInputStream.d",
"members" : [
{
"name" : "ConverterInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Converter input stream implements GInputStream and allows\n conversion of data of various types during reading.\n \n",
"line" : 74,
"base" : "FilterInputStream",
"members" : [
{
"name" : "gConverterInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GConverterInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getConverterInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GConverterInputStream*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConverterInputStream(GConverterInputStream* gConverterInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConverterInputStream(GInputStream* baseStream, ConverterIF converter)",
"comment" : "\n\t \n\n Creates a new converter input stream for the base_stream.\n Params:\n baseStream = a GInputStream\n converter = a GConverter\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 130}
,
{
"name" : "getConverter",
"kind" : "function",
"protection" : "public",
"type" : "ConverterIF()",
"comment" : "\n Gets the GConverter that is used by converter_stream.\n Since 2.24\n Returns: the converter of the converter input stream\n\t \n",
"line" : 146}
]
}
]
}
,
{
"name" : "gio.ConverterOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ConverterOutputStream.d",
"members" : [
{
"name" : "ConverterOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Converter output stream implements GOutputStream and allows\n conversion of data of various types during reading.\n \n",
"line" : 74,
"base" : "FilterOutputStream",
"members" : [
{
"name" : "gConverterOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GConverterOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getConverterOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GConverterOutputStream*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConverterOutputStream(GConverterOutputStream* gConverterOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConverterOutputStream(GOutputStream* baseStream, ConverterIF converter)",
"comment" : "\n\t \n\n Creates a new converter output stream for the base_stream.\n Params:\n baseStream = a GOutputStream\n converter = a GConverter\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 130}
,
{
"name" : "getConverter",
"kind" : "function",
"protection" : "public",
"type" : "ConverterIF()",
"comment" : "\n Gets the GConverter that is used by converter_stream.\n Since 2.24\n Returns: the converter of the converter output stream\n\t \n",
"line" : 146}
]
}
]
}
,
{
"name" : "gio.ConverterT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ConverterT.d",
"members" : [
{
"name" : "ConverterT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GConverter is implemented by objects that convert\n binary data in various ways. The conversion can be\n stateful and may fail at any place.\n Some example conversions are: character set conversion,\n compression, decompression and regular expression\n replace.\n \n",
"line" : 77,
"members" : [
{
"name" : "gConverter",
"kind" : "variable",
"type" : "GConverter*",
"comment" : " the main Gtk struct \n",
"line" : 81}
,
{
"name" : "getConverterTStruct",
"kind" : "function",
"type" : "GConverter*()",
"line" : 84}
,
{
"name" : "convert",
"kind" : "function",
"type" : "GConverterResult(void[] inbuf, void[] outbuf, GConverterFlags flags, out gsize bytesRead, out gsize bytesWritten)",
"comment" : "\n\t \n\n This is the main operation used when converting data. It is to be called\n multiple times in a loop, and each time it will do some work, i.e.\n producing some output (in outbuf) or consuming some input (from inbuf) or\n both. If its not possible to do any work an error is returned.\n Note that a single call may not consume all input (or any input at all).\n Also a call may produce output even if given no input, due to state stored\n in the converter producing output.\n If any data was either produced or consumed, and then an error happens, then\n only the successful conversion is reported and the error is returned on the\n next call.\n A full conversion loop involves calling this method repeatedly, each time\n giving it new input and space output space. When there is no more input\n data after the data in inbuf, the flag G_CONVERTER_INPUT_AT_END must be set.\n The loop will be (unless some error happens) returning G_CONVERTER_CONVERTED\n each time until all data is consumed and all output is produced, then\n G_CONVERTER_FINISHED is returned instead. Note, that G_CONVERTER_FINISHED\n may be returned even if G_CONVERTER_INPUT_AT_END is not set, for instance\n in a decompression converter where the end of data is detectable from the\n data (and there might even be other data after the end of the compressed data).\n When some data has successfully been converted bytes_read and is set to\n the number of bytes read from inbuf, and bytes_written is set to indicate\n how many bytes was written to outbuf. If there are more data to output\n or consume (i.e. unless the G_CONVERTER_INPUT_AT_END is specified) then\n G_CONVERTER_CONVERTED is returned, and if no more data is to be output\n then G_CONVERTER_FINISHED is returned.\n On error G_CONVERTER_ERROR is returned and error is set accordingly.\n Since 2.24\n Params:\n inbuf = the buffer containing the data to convert.\n outbuf = a buffer to write converted data in.\n flags = a GConvertFlags controlling the conversion details\n bytesRead = will be set to the number of bytes read from inbuf on success\n bytesWritten = will be set to the number of bytes written to outbuf on success\n Returns: a GConverterResult, G_CONVERTER_ERROR on error.\n Throws: GException on failure.\n\t \n",
"line" : 130}
,
{
"name" : "reset",
"kind" : "function",
"type" : "void()",
"comment" : "\n Resets all internal state in the converter, making it behave\n as if it was just created. If the converter has any internal\n state that would produce output then that output is lost.\n Since 2.24\n\t \n",
"line" : 151}
]
}
]
}
,
{
"name" : "gio.Credentials",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Credentials.d",
"members" : [
{
"name" : "Credentials",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GCredentials type is a reference-counted wrapper for native\n credentials. This information is typically used for identifying,\n authenticating and authorizing other processes.\n Some operating systems supports looking up the credentials of the\n remote peer of a communication endpoint - see e.g.\n g_socket_get_credentials().\n Some operating systems supports securely sending and receiving\n credentials over a Unix Domain Socket, see\n GUnixCredentialsMessage, g_unix_connection_send_credentials() and\n g_unix_connection_receive_credentials() for details.\n On Linux, the native credential type is a struct ucred\n - see the\n unix(7)\n man page for details. This corresponds to\n G_CREDENTIALS_TYPE_LINUX_UCRED.\n On FreeBSD, the native credential type is a struct cmsgcred.\n This corresponds to G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED.\n \n",
"line" : 92,
"base" : "ObjectG",
"members" : [
{
"name" : "gCredentials",
"kind" : "variable",
"protection" : "protected",
"type" : "GCredentials*",
"comment" : " the main Gtk struct \n",
"line" : 96}
,
{
"name" : "getCredentialsStruct",
"kind" : "function",
"protection" : "public",
"type" : "GCredentials*()",
"line" : 99}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 106}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Credentials(GCredentials* gCredentials)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 114}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 132}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Credentials()",
"comment" : "\n\t \n\n Creates a new GCredentials object with credentials matching the\n the current process.\n Since 2.26\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 147}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Creates a human-readable textual representation of credentials\n that can be used in logging and debug messages. The format of the\n returned string may change in future GLib release.\n Since 2.26\n Returns: A string that should be freed with g_free().\n\t \n",
"line" : 165}
,
{
"name" : "getNative",
"kind" : "function",
"protection" : "public",
"type" : "void*(GCredentialsType nativeType)",
"comment" : "\n Gets a pointer to native credentials of type native_type from\n credentials.\n It is a programming error (which will cause an warning to be\n logged) to use this method if there is no GCredentials support for\n the OS or if native_type isn't supported by the OS.\n Since 2.26\n Params:\n nativeType = The type of native credentials to get.\n Returns: The pointer to native credentials or NULL if the operation there is no GCredentials support for the OS or if native_type isn't supported by the OS. Do not free the returned data, it is owned by credentials.\n\t \n",
"line" : 182}
,
{
"name" : "setNative",
"kind" : "function",
"protection" : "public",
"type" : "void(GCredentialsType nativeType, void* native)",
"comment" : "\n Copies the native credentials of type native_type from native\n into credentials.\n It is a programming error (which will cause an warning to be\n logged) to use this method if there is no GCredentials support for\n the OS or if native_type isn't supported by the OS.\n Since 2.26\n Params:\n nativeType = The type of native credentials to set.\n native = A pointer to native credentials.\n\t \n",
"line" : 199}
,
{
"name" : "isSameUser",
"kind" : "function",
"protection" : "public",
"type" : "int(Credentials otherCredentials)",
"comment" : "\n Checks if credentials and other_credentials is the same user.\n This operation can fail if GCredentials is not supported on the\n the OS.\n Since 2.26\n Params:\n otherCredentials = A GCredentials.\n Returns: TRUE if credentials and other_credentials has the same user, FALSE otherwise or if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 215}
,
{
"name" : "getUnixUser",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Tries to get the UNIX user identifier from credentials. This\n method is only available on UNIX platforms.\n This operation can fail if GCredentials is not supported on the\n OS or if the native credentials type does not contain information\n about the UNIX user.\n Since 2.26\n Returns: The UNIX user identifier or -1 if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 240}
,
{
"name" : "setUnixUser",
"kind" : "function",
"protection" : "public",
"type" : "int(uint uid)",
"comment" : "\n Tries to set the UNIX user identifier on credentials. This method\n is only available on UNIX platforms.\n This operation can fail if GCredentials is not supported on the\n OS or if the native credentials type does not contain information\n about the UNIX user.\n Since 2.26\n Params:\n uid = The UNIX user identifier to set.\n Returns: TRUE if uid was set, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 267}
]
}
]
}
,
{
"name" : "gio.DataInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DataInputStream.d",
"members" : [
{
"name" : "DataInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Data input stream implements GInputStream and includes functions for\n reading structured data directly from a binary input stream.\n \n",
"line" : 82,
"base" : "BufferedInputStream",
"members" : [
{
"name" : "gDataInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GDataInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 86}
,
{
"name" : "getDataInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDataInputStream*()",
"line" : 89}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DataInputStream(GDataInputStream* gDataInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 104}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 122}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DataInputStream(InputStream baseStream)",
"comment" : "\n\t \n\n Creates a new data input stream for the base_stream.\n Params:\n baseStream = a GInputStream.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 137}
,
{
"name" : "setByteOrder",
"kind" : "function",
"protection" : "public",
"type" : "void(GDataStreamByteOrder order)",
"comment" : "\n This function sets the byte order for the given stream. All subsequent\n reads from the stream will be read in the given order.\n Params:\n order = a GDataStreamByteOrder to set.\n\t \n",
"line" : 154}
,
{
"name" : "getByteOrder",
"kind" : "function",
"protection" : "public",
"type" : "GDataStreamByteOrder()",
"comment" : "\n Gets the byte order for the data input stream.\n Returns: the stream's current GDataStreamByteOrder.\n\t \n",
"line" : 164}
,
{
"name" : "setNewlineType",
"kind" : "function",
"protection" : "public",
"type" : "void(GDataStreamNewlineType type)",
"comment" : "\n Sets the newline type for the stream.\n Note that using G_DATA_STREAM_NEWLINE_TYPE_ANY is slightly unsafe. If a read\n chunk ends in \"CR\" we must read an additional byte to know if this is \"CR\" or\n \"CR LF\", and this might block if there is no more data availible.\n Params:\n type = the type of new line return as GDataStreamNewlineType.\n\t \n",
"line" : 178}
,
{
"name" : "getNewlineType",
"kind" : "function",
"protection" : "public",
"type" : "GDataStreamNewlineType()",
"comment" : "\n Gets the current newline type for the stream.\n Returns: GDataStreamNewlineType for the given stream.\n\t \n",
"line" : 188}
,
{
"name" : "readInt16",
"kind" : "function",
"protection" : "public",
"type" : "short(Cancellable cancellable)",
"comment" : "\n Reads a 16-bit\/2-byte value from stream.\n In order to get the correct byte order for this read operation,\n see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a signed 16-bit\/2-byte value read from stream or 0 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 203}
,
{
"name" : "readUint16",
"kind" : "function",
"protection" : "public",
"type" : "ushort(Cancellable cancellable)",
"comment" : "\n Reads an unsigned 16-bit\/2-byte value from stream.\n In order to get the correct byte order for this read operation,\n see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: an unsigned 16-bit\/2-byte value read from the stream or 0 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 227}
,
{
"name" : "readInt32",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Reads a signed 32-bit\/4-byte value from stream.\n In order to get the correct byte order for this read operation,\n see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a signed 32-bit\/4-byte value read from the stream or 0 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 254}
,
{
"name" : "readUint32",
"kind" : "function",
"protection" : "public",
"type" : "uint(Cancellable cancellable)",
"comment" : "\n Reads an unsigned 32-bit\/4-byte value from stream.\n In order to get the correct byte order for this read operation,\n see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: an unsigned 32-bit\/4-byte value read from the stream or 0 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 281}
,
{
"name" : "readInt64",
"kind" : "function",
"protection" : "public",
"type" : "long(Cancellable cancellable)",
"comment" : "\n Reads a 64-bit\/8-byte value from stream.\n In order to get the correct byte order for this read operation,\n see g_data_input_stream_get_byte_order() and g_data_input_stream_set_byte_order().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a signed 64-bit\/8-byte value read from stream or 0 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 308}
,
{
"name" : "readUint64",
"kind" : "function",
"protection" : "public",
"type" : "ulong(Cancellable cancellable)",
"comment" : "\n Reads an unsigned 64-bit\/8-byte value from stream.\n In order to get the correct byte order for this read operation,\n see g_data_input_stream_get_byte_order().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: an unsigned 64-bit\/8-byte read from stream or 0 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 335}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "string(Cancellable cancellable)",
"comment" : "\n Reads a line from the data input stream.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a string with the line that was read in (without the newlines). Set length to a gsize to get the length of the read line. On an error, it will return NULL and error will be set. If there's no content to read, it will still return NULL, but error won't be set.\n Throws: GException on failure.\n\t \n",
"line" : 360}
,
{
"name" : "readLineAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n The asynchronous version of g_data_input_stream_read_line(). It is\n an error to have two outstanding calls to this function.\n When the operation is finished, callback will be called. You\n can then call g_data_input_stream_read_line_finish() to get\n the result of the operation.\n Since 2.20\n Params:\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied.\n userData = the data to pass to callback function.\n\t \n",
"line" : 390}
,
{
"name" : "readLineFinish",
"kind" : "function",
"protection" : "public",
"type" : "string(out GAsyncResult result)",
"comment" : "\n Finish an asynchronous call started by\n g_data_input_stream_read_line_async().\n Since 2.20\n Params:\n result = the GAsyncResult that was provided to the callback.\n Returns: a string with the line that was read in (without the newlines). Set length to a gsize to get the length of the read line. On an error, it will return NULL and error will be set. If there's no content to read, it will still return NULL, but error won't be set.\n Throws: GException on failure.\n\t \n",
"line" : 405}
,
{
"name" : "readUpto",
"kind" : "function",
"protection" : "public",
"type" : "string(char[] stopChars, Cancellable cancellable)",
"comment" : "\n Reads a string from the data input stream, up to the first\n occurrence of any of the stop characters.\n In contrast to g_data_input_stream_read_until(), this function\n does not consume the stop character. You have\n to use g_data_input_stream_read_byte() to get it before calling\n g_data_input_stream_read_upto() again.\n Note that stop_chars may contain '\\0' if stop_chars_len is\n specified.\n Since 2.24\n Params:\n stopChars = characters to terminate the read\n cancellable = optional GCancellable object, NULL to ignore\n Returns: a string with the data that was read before encountering any of the stop characters. Set length to a gsize to get the length of the string. This function will return NULL on an error\n Throws: GException on failure.\n\t \n",
"line" : 437}
,
{
"name" : "readUptoAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(char[] stopChars, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n The asynchronous version of g_data_input_stream_read_upto().\n It is an error to have two outstanding calls to this function.\n In contrast to g_data_input_stream_read_until(), this function\n does not consume the stop character. You have\n to use g_data_input_stream_read_byte() to get it before calling\n g_data_input_stream_read_upto() again.\n Note that stop_chars may contain '\\0' if stop_chars_len is\n specified.\n When the operation is finished, callback will be called. You\n can then call g_data_input_stream_read_upto_finish() to get\n the result of the operation.\n Since 2.24\n Params:\n stopChars = characters to terminate the read\n cancellable = optional GCancellable object, NULL to ignore\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 472}
,
{
"name" : "readUptoFinish",
"kind" : "function",
"protection" : "public",
"type" : "string(out GAsyncResult result)",
"comment" : "\n Finish an asynchronous call started by\n g_data_input_stream_read_upto_async().\n Note that this function does not consume the\n stop character. You have to use g_data_input_stream_read_byte() to\n get it before calling g_data_input_stream_read_upto_async() again.\n Since 2.24\n Params:\n result = the GAsyncResult that was provided to the callback\n Returns: a string with the data that was read before encountering any of the stop characters. Set length to a gsize to get the length of the string. This function will return NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 490}
,
{
"name" : "readUntil",
"kind" : "function",
"protection" : "public",
"type" : "string(string stopChars, Cancellable cancellable)",
"comment" : "\n Reads a string from the data input stream, up to the first\n occurrence of any of the stop characters.\n Note that, in contrast to g_data_input_stream_read_until_async(),\n this function consumes the stop character that it finds.\n Don't use this function in new code. Its functionality is\n inconsistent with g_data_input_stream_read_until_async(). Both\n functions will be marked as deprecated in a future release. Use\n g_data_input_stream_read_upto() instead, but note that that function\n does not consume the stop character.\n Params:\n stopChars = characters to terminate the read.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a string with the data that was read before encountering any of the stop characters. Set length to a gsize to get the length of the string. This function will return NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 522}
,
{
"name" : "readUntilAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string stopChars, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n The asynchronous version of g_data_input_stream_read_until().\n It is an error to have two outstanding calls to this function.\n Note that, in contrast to g_data_input_stream_read_until(),\n this function does not consume the stop character that it finds. You\n must read it for yourself.\n When the operation is finished, callback will be called. You\n can then call g_data_input_stream_read_until_finish() to get\n the result of the operation.\n Don't use this function in new code. Its functionality is\n inconsistent with g_data_input_stream_read_until(). Both functions\n will be marked as deprecated in a future release. Use\n g_data_input_stream_read_upto_async() instead.\n Since 2.20\n Params:\n stopChars = characters to terminate the read.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied.\n userData = the data to pass to callback function.\n\t \n",
"line" : 560}
,
{
"name" : "readUntilFinish",
"kind" : "function",
"protection" : "public",
"type" : "string(out GAsyncResult result)",
"comment" : "\n Finish an asynchronous call started by\n g_data_input_stream_read_until_async().\n Since 2.20\n Params:\n result = the GAsyncResult that was provided to the callback.\n Returns: a string with the data that was read before encountering any of the stop characters. Set length to a gsize to get the length of the string. This function will return NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 575}
]
}
]
}
,
{
"name" : "gio.DataOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DataOutputStream.d",
"members" : [
{
"name" : "DataOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Data output stream implements GOutputStream and includes functions for\n writing data directly to an output stream.\n \n",
"line" : 81,
"base" : "FilterOutputStream",
"members" : [
{
"name" : "gDataOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GDataOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 85}
,
{
"name" : "getDataOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDataOutputStream*()",
"line" : 88}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 95}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DataOutputStream(GDataOutputStream* gDataOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 103}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 121}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DataOutputStream(OutputStream baseStream)",
"comment" : "\n\t \n\n Creates a new data output stream for base_stream.\n Params:\n baseStream = a GOutputStream.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 136}
,
{
"name" : "setByteOrder",
"kind" : "function",
"protection" : "public",
"type" : "void(GDataStreamByteOrder order)",
"comment" : "\n Sets the byte order of the data output stream to order.\n Params:\n order = a GDataStreamByteOrder.\n\t \n",
"line" : 152}
,
{
"name" : "getByteOrder",
"kind" : "function",
"protection" : "public",
"type" : "GDataStreamByteOrder()",
"comment" : "\n Gets the byte order for the stream.\n Returns: the GDataStreamByteOrder for the stream.\n\t \n",
"line" : 162}
,
{
"name" : "putByte",
"kind" : "function",
"protection" : "public",
"type" : "int(char data, Cancellable cancellable)",
"comment" : "\n Puts a byte into the output stream.\n Params:\n data = a guchar.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 176}
,
{
"name" : "putInt16",
"kind" : "function",
"protection" : "public",
"type" : "int(short data, Cancellable cancellable)",
"comment" : "\n Puts a signed 16-bit integer into the output stream.\n Params:\n data = a gint16.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 199}
,
{
"name" : "putUint16",
"kind" : "function",
"protection" : "public",
"type" : "int(ushort data, Cancellable cancellable)",
"comment" : "\n Puts an unsigned 16-bit integer into the output stream.\n Params:\n data = a guint16.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 222}
,
{
"name" : "putInt32",
"kind" : "function",
"protection" : "public",
"type" : "int(int data, Cancellable cancellable)",
"comment" : "\n Puts a signed 32-bit integer into the output stream.\n Params:\n data = a gint32.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 245}
,
{
"name" : "putUint32",
"kind" : "function",
"protection" : "public",
"type" : "int(uint data, Cancellable cancellable)",
"comment" : "\n Puts an unsigned 32-bit integer into the stream.\n Params:\n data = a guint32.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 268}
,
{
"name" : "putInt64",
"kind" : "function",
"protection" : "public",
"type" : "int(long data, Cancellable cancellable)",
"comment" : "\n Puts a signed 64-bit integer into the stream.\n Params:\n data = a gint64.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 291}
,
{
"name" : "putUint64",
"kind" : "function",
"protection" : "public",
"type" : "int(ulong data, Cancellable cancellable)",
"comment" : "\n Puts an unsigned 64-bit integer into the stream.\n Params:\n data = a guint64.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if data was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 314}
,
{
"name" : "putString",
"kind" : "function",
"protection" : "public",
"type" : "int(string str, Cancellable cancellable)",
"comment" : "\n Puts a string into the output stream.\n Params:\n str = a string.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if string was successfully added to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 337}
]
}
]
}
,
{
"name" : "gio.DBusAuthObserver",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusAuthObserver.d",
"members" : [
{
"name" : "DBusAuthObserver",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GDBusAuthObserver type provides a mechanism for participating\n in how a GDBusServer (or a GDBusConnection) authenticates remote\n peers. Simply instantiate a GDBusAuthObserver and connect to the\n signals you are interested in. Note that new signals may be added\n in the future\n For example, if you only want to allow D-Bus connections from\n processes owned by the same uid as the server, you would use a\n signal handler like the following:\n $(DDOC_COMMENT example)\n \n",
"line" : 84,
"base" : "ObjectG",
"members" : [
{
"name" : "gDBusAuthObserver",
"kind" : "variable",
"protection" : "protected",
"type" : "GDBusAuthObserver*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getDBusAuthObserverStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDBusAuthObserver*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusAuthObserver(GDBusAuthObserver* gDBusAuthObserver)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 124}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 132}
,
{
"name" : "onAuthorizeAuthenticatedPeerListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(IOStream, Credentials, DBusAuthObserver)[]",
"line" : 134}
,
{
"name" : "addOnAuthorizeAuthenticatedPeer",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(IOStream, Credentials, DBusAuthObserver) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted to check if a peer that is successfully authenticated\n is authorized.\n Since 2.26\n\t \n",
"line" : 140}
,
{
"name" : "callBackAuthorizeAuthenticatedPeer",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(GDBusAuthObserver* observerStruct, GIOStream* stream, GCredentials* credentials, DBusAuthObserver dBusAuthObserver)",
"line" : 155}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusAuthObserver()",
"comment" : "\n Creates a new GDBusAuthObserver object.\n Since 2.26\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 174}
,
{
"name" : "authorizeAuthenticatedPeer",
"kind" : "function",
"protection" : "public",
"type" : "int(IOStream stream, Credentials credentials)",
"comment" : "\n Emits the \"authorize-authenticated-peer\" signal on observer.\n Since 2.26\n Signal Details\n The \"authorize-authenticated-peer\" signal\n gboolean user_function (GDBusAuthObserver *observer,\n  GIOStream *stream,\n  GCredentials *credentials,\n  gpointer user_data) : Run Last\n Emitted to check if a peer that is successfully authenticated\n is authorized.\n Since 2.26\n Params:\n stream = A GIOStream for the GDBusConnection.\n credentials = Credentials received from the peer or NULL.\n stream = A GIOStream for the GDBusConnection.\n credentials = Credentials received from the peer or NULL.\n Returns: TRUE if the peer is authorized, FALSE if not.Returns: TRUE if the peer is authorized, FALSE if not.\n\t \n",
"line" : 204}
]
}
]
}
,
{
"name" : "gio.DBusConnection",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusConnection.d",
"members" : [
{
"name" : "DBusConnection",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GDBusConnection type is used for D-Bus connections to remote\n peers such as a message buses. It is a low-level API that offers a\n lot of flexibility. For instance, it lets you establish a connection\n over any transport that can by represented as an GIOStream.\n This class is rarely used directly in D-Bus clients. If you are writing\n an D-Bus client, it is often easier to use the g_bus_own_name(),\n g_bus_watch_name() or g_dbus_proxy_new_for_bus() APIs.\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n \n",
"line" : 127,
"base" : "ObjectG",
"interfaces" : [
"InitableIF",
"AsyncInitableIF"],
"members" : [
{
"name" : "gDBusConnection",
"kind" : "variable",
"protection" : "protected",
"type" : "GDBusConnection*",
"comment" : " the main Gtk struct \n",
"line" : 131}
,
{
"name" : "getDBusConnectionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDBusConnection*()",
"line" : 134}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 141}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusConnection(GDBusConnection* gDBusConnection)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 149}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 167}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusConnection(AsyncResultIF res, bool address = false)",
"comment" : "\n Finishes an operation started with g_dbus_connection_new().\n Since 2.26\n Params:\n      res    = A GAsyncResult obtained from the GAsyncReadyCallback\n               passed to g_dbus_connection_new().\n     address = If true finish an address.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 189}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 218}
,
{
"name" : "onClosedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(int, GError*, DBusConnection)[]",
"line" : 220}
,
{
"name" : "addOnClosed",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(int, GError*, DBusConnection) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the connection is closed.\n The cause of this event can be\n  If g_dbus_connection_close() is called. In this case\n  remote_peer_vanished is set to FALSE and error is NULL.\n  If the remote peer closes the connection. In this case\n  remote_peer_vanished is set to TRUE and error is set.\n  If the remote peer sends invalid or malformed data. In this\n  case remote_peer_vanished is set to FALSE and error\n  is set.\n Upon receiving this signal, you should give up your reference to\n connection. You are guaranteed that this signal is emitted only\n once.\n TRUE if connection is closed because the\n remote peer closed its end of the connection.\n Since 2.26\n\t \n",
"line" : 238}
,
{
"name" : "callBackClosed",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GDBusConnection* connectionStruct, int remotePeerVanished, GError* error, DBusConnection dBusConnection)",
"line" : 253}
,
{
"name" : "gBusGet",
"kind" : "function",
"protection" : "public",
"type" : "void(GBusType busType, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously connects to the message bus specified by bus_type.\n When the operation is finished, callback will be invoked. You can\n then call g_bus_get_finish() to get the result of the operation.\n This is a asynchronous failable function. See g_bus_get_sync() for\n the synchronous version.\n Since 2.26\n Params:\n busType = A GBusType.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied.\n userData = The data to pass to callback.\n\t \n",
"line" : 275}
,
{
"name" : "gBusGetFinish",
"kind" : "function",
"protection" : "public",
"type" : "DBusConnection(AsyncResultIF res)",
"comment" : "\n Finishes an operation started with g_bus_get().\n The returned object is a singleton, that is, shared with other\n callers of g_bus_get() and g_bus_get_sync() for bus_type. In the\n event that you need a private message bus connection, use\n g_dbus_address_get_for_bus() and\n g_dbus_connection_new_for_address().\n Note that the returned GDBusConnection object will (usually) have\n the \"exit-on-close\" property set to TRUE.\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_bus_get().\n Returns: A GDBusConnection or NULL if error is set. Free with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 296}
,
{
"name" : "gBusGetSync",
"kind" : "function",
"protection" : "public",
"type" : "DBusConnection(GBusType busType, Cancellable cancellable)",
"comment" : "\n Synchronously connects to the message bus specified by bus_type.\n Note that the returned object may shared with other callers,\n e.g. if two separate parts of a process calls this function with\n the same bus_type, they will share the same object.\n This is a synchronous failable function. See g_bus_get() and\n g_bus_get_finish() for the asynchronous version.\n The returned object is a singleton, that is, shared with other\n callers of g_bus_get() and g_bus_get_sync() for bus_type. In the\n event that you need a private message bus connection, use\n g_dbus_address_get_for_bus_sync() and\n g_dbus_connection_new_for_address().\n Note that the returned GDBusConnection object will (usually) have\n the \"exit-on-close\" property set to TRUE.\n Since 2.26\n Params:\n busType = A GBusType.\n cancellable = A GCancellable or NULL.\n Returns: A GDBusConnection or NULL if error is set. Free with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 336}
,
{
"name" : "newDBusConnection",
"kind" : "function",
"protection" : "public",
"type" : "void(IOStream stream, string guid, GDBusConnectionFlags flags, DBusAuthObserver observer, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously sets up a D-Bus connection for exchanging D-Bus messages\n with the end represented by stream.\n If observer is not NULL it may be used to control the\n authentication process.\n When the operation is finished, callback will be invoked. You can\n then call g_dbus_connection_new_finish() to get the result of the\n operation.\n This is a asynchronous failable constructor. See\n g_dbus_connection_new_sync() for the synchronous\n version.\n Since 2.26\n Params:\n stream = A GIOStream.\n guid = The GUID to use if a authenticating as a server or NULL.\n flags = Flags describing how to make the connection.\n observer = A GDBusAuthObserver or NULL.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied.\n userData = The data to pass to callback.\n\t \n",
"line" : 376}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusConnection(IOStream stream, string guid, GDBusConnectionFlags flags, DBusAuthObserver observer, Cancellable cancellable)",
"comment" : "\n Synchronously sets up a D-Bus connection for exchanging D-Bus messages\n with the end represented by stream.\n If observer is not NULL it may be used to control the\n authentication process.\n This is a synchronous failable constructor. See\n g_dbus_connection_new() for the asynchronous version.\n Since 2.26\n Params:\n stream = A GIOStream.\n guid = The GUID to use if a authenticating as a server or NULL.\n flags = Flags describing how to make the connection.\n observer = A GDBusAuthObserver or NULL.\n cancellable = A GCancellable or NULL.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 399}
,
{
"name" : "newForAddress",
"kind" : "function",
"protection" : "public",
"type" : "void(string address, GDBusConnectionFlags flags, DBusAuthObserver observer, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously connects and sets up a D-Bus client connection for\n exchanging D-Bus messages with an endpoint specified by address\n which must be in the D-Bus address format.\n This constructor can only be used to initiate client-side\n connections - use g_dbus_connection_new() if you need to act as the\n server. In particular, flags cannot contain the\n G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or\n G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.\n When the operation is finished, callback will be invoked. You can\n then call g_dbus_connection_new_finish() to get the result of the\n operation.\n If observer is not NULL it may be used to control the\n authentication process.\n This is a asynchronous failable constructor. See\n g_dbus_connection_new_for_address_sync() for the synchronous\n version.\n Since 2.26\n Params:\n address = A D-Bus address.\n flags = Flags describing how to make the connection.\n observer = A GDBusAuthObserver or NULL.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied.\n userData = The data to pass to callback.\n\t \n",
"line" : 444}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusConnection(string address, GDBusConnectionFlags flags, DBusAuthObserver observer, Cancellable cancellable)",
"comment" : "\n Synchronously connects and sets up a D-Bus client connection for\n exchanging D-Bus messages with an endpoint specified by address\n which must be in the D-Bus address format.\n This constructor can only be used to initiate client-side\n connections - use g_dbus_connection_new_sync() if you need to act\n as the server. In particular, flags cannot contain the\n G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER or\n G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS flags.\n This is a synchronous failable constructor. See\n g_dbus_connection_new_for_address() for the asynchronous version.\n If observer is not NULL it may be used to control the\n authentication process.\n Since 2.26\n Params:\n address = A D-Bus address.\n flags = Flags describing how to make the connection.\n observer = A GDBusAuthObserver or NULL.\n cancellable = A GCancellable or NULL.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 472}
,
{
"name" : "startMessageProcessing",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n If connection was created with\n G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING, this method\n starts processing messages. Does nothing on if connection wasn't\n created with this flag or if the method has already been called.\n Since 2.26\n\t \n",
"line" : 498}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Closes connection. Note that this never causes the process to\n exit (this might only happen if the other end of a shared message\n bus connection disconnects, see \"exit-on-close\").\n Once the connection is closed, operations such as sending a message\n will return with the error G_IO_ERROR_CLOSED. Closing a connection\n will not automatically flush the connection so queued messages may\n be lost. Use g_dbus_connection_flush() if you need such guarantees.\n If connection is already closed, this method fails with\n G_IO_ERROR_CLOSED.\n When connection has been closed, the \"closed\"\n signal is emitted in the thread-default main\n loop of the thread that connection was constructed in.\n This is an asynchronous method. When the operation is finished,\n callback will be invoked in the thread-default main\n loop of the thread you are calling this method from. You can\n then call g_dbus_connection_close_finish() to get the result of the\n operation. See g_dbus_connection_close_sync() for the synchronous\n version.\n Since 2.26\n Params:\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied or NULL if you don't\n care about the result.\n userData = The data to pass to callback.\n\t \n",
"line" : 530}
,
{
"name" : "closeFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res)",
"comment" : "\n Finishes an operation started with g_dbus_connection_close().\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_connection_close().\n Returns: TRUE if the operation succeeded, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 544}
,
{
"name" : "closeSync",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Synchronously closees connection. The calling thread is blocked\n until this is done. See g_dbus_connection_close() for the\n asynchronous version of this method and more details about what it\n does.\n Since 2.26\n Params:\n cancellable = A GCancellable or NULL.\n Returns: TRUE if the operation succeeded, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 570}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets whether connection is closed.\n Since 2.26\n Returns: TRUE if the connection is closed, FALSE otherwise.\n\t \n",
"line" : 590}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously flushes connection, that is, writes all queued\n outgoing message to the transport and then flushes the transport\n (using g_output_stream_flush_async()). This is useful in programs\n that wants to emit a D-Bus signal and then exit\n immediately. Without flushing the connection, there is no guarantee\n that the message has been sent to the networking buffers in the OS\n kernel.\n This is an asynchronous method. When the operation is finished,\n callback will be invoked in the thread-default main\n loop of the thread you are calling this method from. You can\n then call g_dbus_connection_flush_finish() to get the result of the\n operation. See g_dbus_connection_flush_sync() for the synchronous\n version.\n Since 2.26\n Params:\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied or NULL if you don't\n care about the result.\n userData = The data to pass to callback.\n\t \n",
"line" : 617}
,
{
"name" : "flushFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res)",
"comment" : "\n Finishes an operation started with g_dbus_connection_flush().\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_connection_flush().\n Returns: TRUE if the operation succeeded, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 631}
,
{
"name" : "flushSync",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Synchronously flushes connection. The calling thread is blocked\n until this is done. See g_dbus_connection_flush() for the\n asynchronous version of this method and more details about what it\n does.\n Since 2.26\n Params:\n cancellable = A GCancellable or NULL.\n Returns: TRUE if the operation succeeded, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 657}
,
{
"name" : "getExitOnClose",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets whether the process is terminated when connection is\n closed by the remote peer. See\n \"exit-on-close\" for more details.\n Since 2.26\n Returns: Whether the process is terminated when connection is closed by the remote peer.\n\t \n",
"line" : 679}
,
{
"name" : "setExitOnClose",
"kind" : "function",
"protection" : "public",
"type" : "void(int exitOnClose)",
"comment" : "\n Sets whether the process should be terminated when connection is\n closed by the remote peer. See \"exit-on-close\" for\n more details.\n Since 2.26\n Params:\n exitOnClose = Whether the process should be terminated\n when connection is closed by the remote peer.\n\t \n",
"line" : 694}
,
{
"name" : "getStream",
"kind" : "function",
"protection" : "public",
"type" : "IOStream()",
"comment" : "\n Gets the underlying stream used for IO.\n Since 2.26\n Returns: the stream used for IO\n\t \n",
"line" : 705}
,
{
"name" : "getGuid",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n The GUID of the peer performing the role of server when\n authenticating. See \"guid\" for more details.\n Since 2.26\n Returns: The GUID. Do not free this string, it is owned by connection.\n\t \n",
"line" : 722}
,
{
"name" : "getUniqueName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the unique name of connection as assigned by the message\n bus. This can also be used to figure out if connection is a\n message bus connection.\n Since 2.26\n Returns: The unique name or NULL if connection is not a message bus connection. Do not free this string, it is owned by connection.\n\t \n",
"line" : 735}
,
{
"name" : "getCapabilities",
"kind" : "function",
"protection" : "public",
"type" : "GDBusCapabilityFlags()",
"comment" : "\n Gets the capabilities negotiated with the remote peer\n Since 2.26\n Returns: Zero or more flags from the GDBusCapabilityFlags enumeration.\n\t \n",
"line" : 746}
,
{
"name" : "getPeerCredentials",
"kind" : "function",
"protection" : "public",
"type" : "Credentials()",
"comment" : "\n Gets the credentials of the authenticated peer. This will always\n return NULL unless connection acted as a server\n (e.g. G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER was passed)\n when set up and the client passed credentials as part of the\n authentication process.\n In a message bus setup, the message bus is always the server and\n each application is a client. So this method will always return\n NULL for message bus clients.\n Since 2.26\n Returns: A GCredentials or NULL if not available. Do not free this object, it is owned by connection.\n\t \n",
"line" : 764}
,
{
"name" : "call",
"kind" : "function",
"protection" : "public",
"type" : "void(string busName, string objectPath, string interfaceName, string methodName, Variant parameters, VariantType replyType, GDBusCallFlags flags, int timeoutMsec, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously invokes the method_name method on the\n interface_name D-Bus interface on the remote object at\n object_path owned by bus_name.\n If connection is closed then the operation will fail with\n G_IO_ERROR_CLOSED. If cancellable is canceled, the operation will\n fail with G_IO_ERROR_CANCELLED. If parameters contains a value\n not compatible with the D-Bus protocol, the operation fails with\n G_IO_ERROR_INVALID_ARGUMENT.\n If reply_type is non-NULL then the reply will be checked for having this type and an\n error will be raised if it does not match. Said another way, if you give a reply_type\n then any non-NULL return value will be of this type.\n If the parameters GVariant is floating, it is consumed. This allows\n Since 2.26\n Params:\n busName = A unique or well-known bus name or NULL if connection is not a message bus connection.\n objectPath = Path of remote object.\n interfaceName = D-Bus interface to invoke method on.\n methodName = The name of the method to invoke.\n parameters = A GVariant tuple with parameters for the method or NULL if not passing parameters.\n replyType = The expected type of the reply, or NULL.\n flags = Flags from the GDBusCallFlags enumeration.\n timeoutMsec = The timeout in milliseconds or -1 to use the default timeout.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied or NULL if you don't\n care about the result of the method invocation.\n userData = The data to pass to callback.\n\t \n",
"line" : 803}
,
{
"name" : "callFinish",
"kind" : "function",
"protection" : "public",
"type" : "Variant(AsyncResultIF res)",
"comment" : "\n Finishes an operation started with g_dbus_connection_call().\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_connection_call().\n Returns: NULL if error is set. Otherwise a GVariant tuple with return values. Free with g_variant_unref().\n Throws: GException on failure.\n\t \n",
"line" : 817}
,
{
"name" : "callSync",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string busName, string objectPath, string interfaceName, string methodName, Variant parameters, VariantType replyType, GDBusCallFlags flags, int timeoutMsec, Cancellable cancellable)",
"comment" : "\n Synchronously invokes the method_name method on the\n interface_name D-Bus interface on the remote object at\n object_path owned by bus_name.\n If connection is closed then the operation will fail with\n G_IO_ERROR_CLOSED. If cancellable is canceled, the\n operation will fail with G_IO_ERROR_CANCELLED. If parameters\n contains a value not compatible with the D-Bus protocol, the operation\n fails with G_IO_ERROR_INVALID_ARGUMENT.\n If reply_type is non-NULL then the reply will be checked for having\n this type and an error will be raised if it does not match. Said\n another way, if you give a reply_type then any non-NULL return\n value will be of this type.\n If the parameters GVariant is floating, it is consumed.\n Since 2.26\n Params:\n busName = A unique or well-known bus name.\n objectPath = Path of remote object.\n interfaceName = D-Bus interface to invoke method on.\n methodName = The name of the method to invoke.\n parameters = A GVariant tuple with parameters for the method or NULL if not passing parameters.\n replyType = The expected type of the reply, or NULL.\n flags = Flags from the GDBusCallFlags enumeration.\n timeoutMsec = The timeout in milliseconds or -1 to use the default timeout.\n cancellable = A GCancellable or NULL.\n Returns: NULL if error is set. Otherwise a GVariant tuple with return values. Free with g_variant_unref().\n Throws: GException on failure.\n\t \n",
"line" : 864}
,
{
"name" : "emitSignal",
"kind" : "function",
"protection" : "public",
"type" : "int(string destinationBusName, string objectPath, string interfaceName, string signalName, Variant parameters)",
"comment" : "\n Emits a signal.\n If the parameters GVariant is floating, it is consumed.\n This can only fail if parameters is not compatible with the D-Bus protocol.\n Since 2.26\n Params:\n destinationBusName = The unique bus name for the destination for the signal or NULL to emit to all listeners.\n objectPath = Path of remote object.\n interfaceName = D-Bus interface to emit a signal on.\n signalName = The name of the signal to emit.\n parameters = A GVariant tuple with parameters for the signal or NULL if not passing parameters.\n Returns: TRUE unless error is set.\n Throws: GException on failure.\n\t \n",
"line" : 897}
,
{
"name" : "signalSubscribe",
"kind" : "function",
"protection" : "public",
"type" : "uint(string sender, string interfaceName, string member, string objectPath, string arg0, GDBusSignalFlags flags, extern (C) void function(GDBusConnection*, char*, char*, char*, char*, GVariant*, void*) callback, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Subscribes to signals on connection and invokes callback with a\n whenever the signal is received. Note that callback\n will be invoked in the thread-default main\n loop of the thread you are calling this method from.\n If connection is not a message bus connection, sender must be\n NULL.\n If sender is a well-known name note that callback is invoked with\n the unique name for the owner of sender, not the well-known name\n as one would expect. This is because the message bus rewrites the\n name. As such, to avoid certain race conditions, users should be\n tracking the name owner of the well-known name and use that when\n processing the received signal.\n Since 2.26\n Params:\n sender = Sender name to match on (unique or well-known name) or NULL to listen from all senders.\n interfaceName = D-Bus interface name to match on or NULL to match on all interfaces.\n member = D-Bus signal name to match on or NULL to match on all signals.\n objectPath = Object path to match on or NULL to match on all object paths.\n arg0 = Contents of first string argument to match on or NULL to match on all kinds of arguments.\n flags = Flags describing how to subscribe to the signal (currently unused).\n callback = Callback to invoke when there is a signal matching the requested data.\n userData = User data to pass to callback.\n userDataFreeFunc = Function to free user_data with when subscription is removed or NULL.\n Returns: A subscription identifier that can be used with g_dbus_connection_signal_unsubscribe().\n\t \n",
"line" : 938}
,
{
"name" : "signalUnsubscribe",
"kind" : "function",
"protection" : "public",
"type" : "void(uint subscriptionId)",
"comment" : "\n Unsubscribes from signals.\n Since 2.26\n Params:\n subscriptionId = A subscription id obtained from g_dbus_connection_signal_subscribe().\n\t \n",
"line" : 950}
,
{
"name" : "sendMessage",
"kind" : "function",
"protection" : "public",
"type" : "int(DBusMessage message, GDBusSendMessageFlags flags, out uint outSerial)",
"comment" : "\n Asynchronously sends message to the peer represented by connection.\n Unless flags contain the\n G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n will be assigned by connection and set on message via\n g_dbus_message_set_serial(). If out_serial is not NULL, then the\n serial number used will be written to this location prior to\n submitting the message to the underlying transport.\n If connection is closed then the operation will fail with\n G_IO_ERROR_CLOSED. If message is not well-formed,\n the operation fails with G_IO_ERROR_INVALID_ARGUMENT.\n See Example  2, “D-Bus server example” and Example  4, “D-Bus UNIX File Descriptor example” for an example of how to use this\n low-level API to send and receive UNIX file descriptors.\n Note that message must be unlocked, unless flags contain the\n G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n Since 2.26\n Params:\n message = A GDBusMessage\n flags = Flags affecting how the message is sent.\n outSerial = Return location for serial number assigned to message when sending it or NULL.\n Returns: TRUE if the message was well-formed and queued for transmission, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 979}
,
{
"name" : "sendMessageWithReply",
"kind" : "function",
"protection" : "public",
"type" : "void(DBusMessage message, GDBusSendMessageFlags flags, int timeoutMsec, out uint outSerial, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously sends message to the peer represented by connection.\n Unless flags contain the\n G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n will be assigned by connection and set on message via\n g_dbus_message_set_serial(). If out_serial is not NULL, then the\n serial number used will be written to this location prior to\n submitting the message to the underlying transport.\n If connection is closed then the operation will fail with\n G_IO_ERROR_CLOSED. If cancellable is canceled, the operation will\n fail with G_IO_ERROR_CANCELLED. If message is not well-formed,\n the operation fails with G_IO_ERROR_INVALID_ARGUMENT.\n This is an asynchronous method. When the operation is finished, callback will be invoked\n in the thread-default main loop\n of the thread you are calling this method from. You can then call\n g_dbus_connection_send_message_with_reply_finish() to get the result of the operation.\n See g_dbus_connection_send_message_with_reply_sync() for the synchronous version.\n Note that message must be unlocked, unless flags contain the\n G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n See Example  2, “D-Bus server example” and Example  4, “D-Bus UNIX File Descriptor example” for an example of how to use this\n low-level API to send and receive UNIX file descriptors.\n Since 2.26\n Params:\n message = A GDBusMessage.\n flags = Flags affecting how the message is sent.\n timeoutMsec = The timeout in milliseconds or -1 to use the default timeout.\n outSerial = Return location for serial number assigned to message when sending it or NULL.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied or NULL if you don't\n care about the result.\n userData = The data to pass to callback.\n\t \n",
"line" : 1026}
,
{
"name" : "sendMessageWithReplyFinish",
"kind" : "function",
"protection" : "public",
"type" : "DBusMessage(AsyncResultIF res)",
"comment" : "\n Finishes an operation started with g_dbus_connection_send_message_with_reply().\n Note that error is only set if a local in-process error\n occured. That is to say that the returned GDBusMessage object may\n be of type G_DBUS_MESSAGE_TYPE_ERROR. Use\n g_dbus_message_to_gerror() to transcode this to a GError.\n See Example  2, “D-Bus server example” and Example  4, “D-Bus UNIX File Descriptor example” for an example of how to use this\n low-level API to send and receive UNIX file descriptors.\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_connection_send_message_with_reply().\n Returns: A locked GDBusMessage or NULL if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 1046}
,
{
"name" : "sendMessageWithReplySync",
"kind" : "function",
"protection" : "public",
"type" : "DBusMessage(DBusMessage message, GDBusSendMessageFlags flags, int timeoutMsec, out uint outSerial, Cancellable cancellable)",
"comment" : "\n Synchronously sends message to the peer represented by connection\n and blocks the calling thread until a reply is received or the\n timeout is reached. See g_dbus_connection_send_message_with_reply()\n for the asynchronous version of this method.\n Unless flags contain the\n G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag, the serial number\n will be assigned by connection and set on message via\n g_dbus_message_set_serial(). If out_serial is not NULL, then the\n serial number used will be written to this location prior to\n submitting the message to the underlying transport.\n If connection is closed then the operation will fail with\n G_IO_ERROR_CLOSED. If cancellable is canceled, the operation will\n fail with G_IO_ERROR_CANCELLED. If message is not well-formed,\n the operation fails with G_IO_ERROR_INVALID_ARGUMENT.\n Note that error is only set if a local in-process error\n occured. That is to say that the returned GDBusMessage object may\n be of type G_DBUS_MESSAGE_TYPE_ERROR. Use\n g_dbus_message_to_gerror() to transcode this to a GError.\n See Example  2, “D-Bus server example” and Example  4, “D-Bus UNIX File Descriptor example” for an example of how to use this\n low-level API to send and receive UNIX file descriptors.\n Note that message must be unlocked, unless flags contain the\n G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL flag.\n Since 2.26\n Params:\n message = A GDBusMessage.\n flags = Flags affecting how the message is sent.\n timeoutMsec = The timeout in milliseconds or -1 to use the default timeout.\n outSerial = Return location for serial number assigned to message when sending it or NULL.\n cancellable = A GCancellable or NULL.\n Returns: A locked GDBusMessage that is the reply to message or NULL if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 1098}
,
{
"name" : "addFilter",
"kind" : "function",
"protection" : "public",
"type" : "uint(extern (C) GDBusMessage* function(GDBusConnection*, GDBusMessage*, int, void*) filterFunction, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Adds a message filter. Filters are handlers that are run on all\n incoming and outgoing messages, prior to standard dispatch. Filters\n are run in the order that they were added. The same handler can be\n added as a filter more than once, in which case it will be run more\n than once. Filters added during a filter callback won't be run on\n the message being processed. Filter functions are allowed to modify\n and even drop messages - see the GDBusMessageFilterResult\n enumeration for details.\n Note that filters are run in a dedicated message handling thread so\n they can't block and, generally, can't do anything but signal a\n worker thread. Also note that filters are rarely needed - use API\n such as g_dbus_connection_send_message_with_reply(),\n g_dbus_connection_signal_subscribe() or\n g_dbus_connection_call() instead.\n If a filter consumes an incoming message the message is not\n dispatched anywhere else - not even the standard dispatch machinery\n (that API such as g_dbus_connection_signal_subscribe() and\n g_dbus_connection_send_message_with_reply() relies on) will see the\n message. Similary, if a filter consumes an outgoing message, the\n message will not be sent to the other peer.\n Since 2.26\n Params:\n filterFunction = A filter function.\n userData = User data to pass to filter_function.\n userDataFreeFunc = Function to free user_data with when filter\n is removed or NULL.\n Returns: A filter identifier that can be used with g_dbus_connection_remove_filter().\n\t \n",
"line" : 1146}
,
{
"name" : "removeFilter",
"kind" : "function",
"protection" : "public",
"type" : "void(uint filterId)",
"comment" : "\n Removes a filter.\n Since 2.26\n Params:\n filterId = an identifier obtained from g_dbus_connection_add_filter()\n\t \n",
"line" : 1158}
,
{
"name" : "registerObject",
"kind" : "function",
"protection" : "public",
"type" : "uint(string objectPath, GDBusInterfaceInfo* interfaceInfo, GDBusInterfaceVTable* vtable, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Registers callbacks for exported objects at object_path with the\n D-Bus interface that is described in interface_info.\n Calls to functions in vtable (and user_data_free_func) will\n happen in the thread-default main\n loop of the thread you are calling this method from.\n Note that all GVariant values passed to functions in vtable will match\n the signature given in interface_info - if a remote caller passes\n incorrect values, the org.freedesktop.DBus.Error.InvalidArgs\n is returned to the remote caller.\n Additionally, if the remote caller attempts to invoke methods or\n access properties not mentioned in interface_info the\n org.freedesktop.DBus.Error.UnknownMethod resp.\n org.freedesktop.DBus.Error.InvalidArgs errors\n are returned to the caller.\n It is considered a programming error if the\n GDBusInterfaceGetPropertyFunc function in vtable returns a\n GVariant of incorrect type.\n If an existing callback is already registered at object_path and\n interface_name, then error is set to G_IO_ERROR_EXISTS.\n GDBus automatically implements the standard D-Bus interfaces\n org.freedesktop.DBus.Properties, org.freedesktop.DBus.Introspectable\n and org.freedesktop.Peer, so you don't have to implement those for\n the objects you export. You can implement\n org.freedesktop.DBus.Properties yourself, e.g. to handle getting\n and setting of properties asynchronously.\n Note that the reference count on interface_info will be\n incremented by 1 (unless allocated statically, e.g. if the\n reference count is -1, see g_dbus_interface_info_ref()) for as long\n as the object is exported. Also note that vtable will be copied.\n See Example  2, “D-Bus server example” for an example of how to use this method.\n Since 2.26\n Params:\n objectPath = The object path to register at.\n interfaceInfo = Introspection data for the interface.\n vtable = A GDBusInterfaceVTable to call into or NULL.\n userData = Data to pass to functions in vtable.\n userDataFreeFunc = Function to call when the object path is unregistered.\n Returns: 0 if error is set, otherwise a registration id (never 0) that can be used with g_dbus_connection_unregister_object() .\n Throws: GException on failure.\n\t \n",
"line" : 1205}
,
{
"name" : "unregisterObject",
"kind" : "function",
"protection" : "public",
"type" : "int(uint registrationId)",
"comment" : "\n Unregisters an object.\n Since 2.26\n Params:\n registrationId = A registration id obtained from g_dbus_connection_register_object().\n Returns: TRUE if the object was unregistered, FALSE otherwise.\n\t \n",
"line" : 1227}
,
{
"name" : "registerSubtree",
"kind" : "function",
"protection" : "public",
"type" : "uint(string objectPath, GDBusSubtreeVTable* vtable, GDBusSubtreeFlags flags, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Registers a whole subtree of “dynamic” objects.\n The enumerate and introspection functions in vtable are used to\n convey, to remote callers, what nodes exist in the subtree rooted\n by object_path.\n When handling remote calls into any node in the subtree, first the\n enumerate function is used to check if the node exists. If the node exists\n or the G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is set\n the introspection function is used to check if the node supports the\n requested method. If so, the dispatch function is used to determine\n where to dispatch the call. The collected GDBusInterfaceVTable and\n gpointer will be used to call into the interface vtable for processing\n the request.\n All calls into user-provided code will be invoked in the thread-default main\n loop of the thread you are calling this method from.\n If an existing subtree is already registered at object_path or\n then error is set to G_IO_ERROR_EXISTS.\n Note that it is valid to register regular objects (using\n g_dbus_connection_register_object()) in a subtree registered with\n g_dbus_connection_register_subtree() - if so, the subtree handler\n is tried as the last resort. One way to think about a subtree\n handler is to consider it a “fallback handler”\n for object paths not registered via g_dbus_connection_register_object()\n or other bindings.\n Note that vtable will be copied so you cannot change it after\n registration.\n See Example  3, “D-Bus subtree example” for an example of how to use this method.\n Since 2.26\n Params:\n objectPath = The object path to register the subtree at.\n vtable = A GDBusSubtreeVTable to enumerate, introspect and dispatch nodes in the subtree.\n flags = Flags used to fine tune the behavior of the subtree.\n userData = Data to pass to functions in vtable.\n userDataFreeFunc = Function to call when the subtree is unregistered.\n Returns: 0 if error is set, otherwise a subtree registration id (never 0) that can be used with g_dbus_connection_unregister_subtree() .\n Throws: GException on failure.\n\t \n",
"line" : 1270}
,
{
"name" : "unregisterSubtree",
"kind" : "function",
"protection" : "public",
"type" : "int(uint registrationId)",
"comment" : "\n Unregisters a subtree.\n Since 2.26\n Params:\n registrationId = A subtree registration id obtained from g_dbus_connection_register_subtree().\n Returns: TRUE if the subtree was unregistered, FALSE otherwise.\n\t \n",
"line" : 1292}
]
}
]
}
,
{
"name" : "gio.DBusError",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusError.d",
"members" : [
{
"name" : "DBusError",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n All facilities that return errors from remote methods (such as\n g_dbus_connection_call_sync()) use GError to represent both D-Bus\n errors (e.g. errors returned from the other peer) and locally\n in-process generated errors.\n To check if a returned GError is an error from a remote peer, use\n g_dbus_error_is_remote_error(). To get the actual D-Bus error name,\n use g_dbus_error_get_remote_error(). Before presenting an error,\n always use g_dbus_error_strip_remote_error().\n In addition, facilities used to return errors to a remote peer also\n use GError. See g_dbus_method_invocation_return_error() for\n discussion about how the D-Bus error name is set.\n Applications can associate a GError error domain with a set of D-Bus errors in order to\n automatically map from D-Bus errors to GError and back. This\n is typically done in the function returning the GQuark for the\n error domain:\n $(DDOC_COMMENT example)\n With this setup, a D-Bus peer can transparently pass e.g. FOO_BAR_ERROR_ANOTHER_ERROR and\n other peers will see the D-Bus error name org.project.Foo.Bar.Error.AnotherError.\n If the other peer is using GDBus, the peer will see also FOO_BAR_ERROR_ANOTHER_ERROR instead\n of G_IO_ERROR_DBUS_ERROR. Note that GDBus clients can still recover\n org.project.Foo.Bar.Error.AnotherError using g_dbus_error_get_remote_error().\n Note that errors in the G_DBUS_ERROR error domain is intended only\n for returning errors from a remote message bus process. Errors\n generated locally in-process by e.g. GDBusConnection is from the\n G_IO_ERROR domain.\n \n",
"line" : 97,
"base" : "Object",
"members" : [
{
"name" : "gError",
"kind" : "variable",
"protection" : "protected",
"type" : "GError*",
"comment" : " the main Gtk struct \n",
"line" : 100}
,
{
"name" : "getDBusErrorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GError*()",
"line" : 103}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 110}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusError(GError* gError)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 118}
,
{
"name" : "isRemoteError",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n\t \n\n Checks if error represents an error received via D-Bus from a remote peer. If so,\n use g_dbus_error_get_remote_error() to get the name of the error.\n Since 2.26\n Returns: TRUE if error represents an error from a remote peer, FALSE otherwise.\n\t \n",
"line" : 137}
,
{
"name" : "getRemoteError",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the D-Bus error name used for error, if any.\n This function is guaranteed to return a D-Bus error name for all\n GErrors returned from functions handling remote method\n calls (e.g. g_dbus_connection_call_finish()) unless\n g_dbus_error_strip_remote_error() has been used on error.\n Since 2.26\n Returns: An allocated string or NULL if the D-Bus error name could not be found. Free with g_free().\n\t \n",
"line" : 152}
,
{
"name" : "stripRemoteError",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Looks for extra information in the error message used to recover\n the D-Bus error name and strips it if found. If stripped, the\n message field in error will correspond exactly to what was\n received on the wire.\n This is typically used when presenting errors to the end user.\n Since 2.26\n Returns: TRUE if information was stripped, FALSE otherwise.\n\t \n",
"line" : 167}
,
{
"name" : "registerErrorDomain",
"kind" : "function",
"protection" : "public",
"type" : "void(string errorDomainQuarkName, out ulong quarkVolatile, GDBusErrorEntry[] entries)",
"comment" : "\n Helper function for associating a GError error domain with D-Bus error names.\n Since 2.26\n Params:\n errorDomainQuarkName = The error domain name.\n quarkVolatile = A pointer where to store the GQuark.\n entries = A pointer to num_entries GDBusErrorEntry struct items.\n\t \n",
"line" : 181}
,
{
"name" : "registerError",
"kind" : "function",
"protection" : "public",
"type" : "int(uint errorDomain, int errorCode, string dbusErrorName)",
"comment" : "\n Creates an association to map between dbus_error_name and\n GErrors specified by error_domain and error_code.\n This is typically done in the routine that returns the GQuark for\n an error domain.\n Since 2.26\n Params:\n errorDomain = A GQuark for a error domain.\n errorCode = An error code.\n dbusErrorName = A D-Bus error name.\n Returns: TRUE if the association was created, FALSE if it already exists.\n\t \n",
"line" : 199}
,
{
"name" : "unregisterError",
"kind" : "function",
"protection" : "public",
"type" : "int(uint errorDomain, int errorCode, string dbusErrorName)",
"comment" : "\n Destroys an association previously set up with g_dbus_error_register_error().\n Since 2.26\n Params:\n errorDomain = A GQuark for a error domain.\n errorCode = An error code.\n dbusErrorName = A D-Bus error name.\n Returns: TRUE if the association was destroyed, FALSE if it wasn't found.\n\t \n",
"line" : 214}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusError(string dbusErrorName, string dbusErrorMessage)",
"comment" : "\n Creates a GError based on the contents of dbus_error_name and\n dbus_error_message.\n Errors registered with g_dbus_error_register_error() will be looked\n up using dbus_error_name and if a match is found, the error domain\n and code is used. Applications can use g_dbus_error_get_remote_error()\n to recover dbus_error_name.\n If a match against a registered error is not found and the D-Bus\n error name is in a form as returned by g_dbus_error_encode_gerror()\n the error domain and code encoded in the name is used to\n create the GError. Also, dbus_error_name is added to the error message\n such that it can be recovered with g_dbus_error_get_remote_error().\n Otherwise, a GError with the error code G_IO_ERROR_DBUS_ERROR\n in the G_IO_ERROR error domain is returned. Also, dbus_error_name is\n added to the error message such that it can be recovered with\n g_dbus_error_get_remote_error().\n In all three cases, dbus_error_name can always be recovered from the\n returned GError using the g_dbus_error_get_remote_error() function\n (unless g_dbus_error_strip_remote_error() hasn't been used on the returned error).\n This function is typically only used in object mappings to prepare\n GError instances for applications. Regular applications should not use\n it.\n Since 2.26\n Params:\n dbusErrorName = D-Bus error name.\n dbusErrorMessage = D-Bus error message.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 248}
,
{
"name" : "setDbusErrorValist",
"kind" : "function",
"protection" : "public",
"type" : "void(out ErrorG error, string dbusErrorName, string dbusErrorMessage, string format, void* varArgs)",
"comment" : "\n Like g_dbus_error_set_dbus_error() but intended for language bindings.\n Since 2.26\n Params:\n error = A pointer to a GError or NULL.\n dbusErrorName = D-Bus error name.\n dbusErrorMessage = D-Bus error message.\n format = printf()-style format to prepend to dbus_error_message or NULL.\n varArgs = Arguments for format.\n\t \n",
"line" : 269}
,
{
"name" : "encodeGerror",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Creates a D-Bus error name to use for error. If error matches\n a registered error (cf. g_dbus_error_register_error()), the corresponding\n D-Bus error name will be returned.\n Otherwise the a name of the form\n org.gtk.GDBus.UnmappedGError.Quark._ESCAPED_QUARK_NAME.Code_ERROR_CODE\n will be used. This allows other GDBus applications to map the error\n on the wire back to a GError using g_dbus_error_new_for_dbus_error().\n This function is typically only used in object mappings to put a\n GError on the wire. Regular applications should not use it.\n Since 2.26\n Params:\n error = A GError.\n Returns: A D-Bus error name (never NULL). Free with g_free().\n\t \n",
"line" : 294}
]
}
]
}
,
{
"name" : "gio.DBusMessage",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusMessage.d",
"members" : [
{
"name" : "DBusMessage",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A type for representing D-Bus messages that can be sent or received\n on a GDBusConnection.\n \n",
"line" : 84,
"base" : "ObjectG",
"members" : [
{
"name" : "gDBusMessage",
"kind" : "variable",
"protection" : "protected",
"type" : "GDBusMessage*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getDBusMessageStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMessage*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(GDBusMessage* gDBusMessage)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 124}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage()",
"comment" : "\n\t \n\n Creates a new empty GDBusMessage.\n Since 2.26\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 138}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(string path, string intrface, string signal)",
"comment" : "\n Creates a new GDBusMessage for a signal emission.\n Since 2.26\n Params:\n path = A valid object path.\n signal = A valid signal name.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 157}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(string name, string path, string intrface, string method)",
"comment" : "\n Creates a new GDBusMessage for a method call.\n Since 2.26\n Params:\n name = A valid D-Bus name or NULL.\n path = A valid object path.\n method = A valid method name.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 177}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(DBusMessage methodCallMessage)",
"comment" : "\n Creates a new GDBusMessage that is a reply to method_call_message.\n Since 2.26\n Params:\n methodCallMessage = A message of type G_DBUS_MESSAGE_TYPE_METHOD_CALL to\n create a reply message to.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 196}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(DBusMessage methodCallMessage, string errorName, string errorMessageFormat, void* varArgs)",
"comment" : "\n Like g_dbus_message_new_method_error() but intended for language bindings.\n Since 2.26\n Params:\n methodCallMessage = A message of type G_DBUS_MESSAGE_TYPE_METHOD_CALL to\n create a reply message to.\n errorName = A valid D-Bus error name.\n errorMessageFormat = The D-Bus error message in a printf() format.\n varArgs = Arguments for error_message_format.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 218}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(DBusMessage methodCallMessage, string errorName, string errorMessage)",
"comment" : "\n Creates a new GDBusMessage that is an error reply to method_call_message.\n Since 2.26\n Params:\n methodCallMessage = A message of type G_DBUS_MESSAGE_TYPE_METHOD_CALL to\n create a reply message to.\n errorName = A valid D-Bus error name.\n errorMessage = The D-Bus error message.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 239}
,
{
"name" : "print",
"kind" : "function",
"protection" : "public",
"type" : "string(uint indent)",
"comment" : "\n Produces a human-readable multi-line description of message.\n The contents of the description has no ABI guarantees, the contents\n and formatting is subject to change at any time. Typical output\n Since 2.26\n Params:\n indent = Indentation level.\n Returns: A string that should be freed with g_free().\n\t \n",
"line" : 259}
,
{
"name" : "getLocked",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks whether message is locked. To monitor changes to this\n value, conncet to the \"notify\" signal to listen for changes\n on the \"locked\" property.\n Since 2.26\n Returns: TRUE if message is locked, FALSE otherwise.\n\t \n",
"line" : 272}
,
{
"name" : "lock",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n If message is locked, does nothing. Otherwise locks the message.\n Since 2.26\n\t \n",
"line" : 282}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "DBusMessage()",
"comment" : "\n Copies message. The copy is a deep copy and the returned\n GDBusMessage is completely identical except that it is guaranteed\n to not be locked.\n This operation can fail if e.g. message contains file descriptors\n and the per-process or system-wide open files limit is reached.\n Since 2.26\n Returns: A new GDBusMessage or NULL if error is set. Free with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 298}
,
{
"name" : "getByteOrder",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMessageByteOrder()",
"comment" : "\n Gets the byte order of message.\n Returns: The byte order.\n\t \n",
"line" : 321}
,
{
"name" : "setByteOrder",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusMessageByteOrder byteOrder)",
"comment" : "\n Sets the byte order of message.\n Params:\n byteOrder = The byte order.\n\t \n",
"line" : 332}
,
{
"name" : "getMessageType",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMessageType()",
"comment" : "\n Gets the type of message.\n Since 2.26\n Returns: A 8-bit unsigned integer (typically a value from the GDBusMessageType enumeration).\n\t \n",
"line" : 343}
,
{
"name" : "setMessageType",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusMessageType type)",
"comment" : "\n Sets message to be of type.\n Since 2.26\n Params:\n type = A 8-bit unsigned integer (typically a value from the GDBusMessageType enumeration).\n\t \n",
"line" : 355}
,
{
"name" : "getSerial",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the serial for message.\n Since 2.26\n Returns: A guint32.\n\t \n",
"line" : 366}
,
{
"name" : "setSerial",
"kind" : "function",
"protection" : "public",
"type" : "void(uint serial)",
"comment" : "\n Sets the serial for message.\n Since 2.26\n Params:\n serial = A guint32.\n\t \n",
"line" : 378}
,
{
"name" : "getFlags",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMessageFlags()",
"comment" : "\n Gets the flags for message.\n Since 2.26\n Returns: Flags that are set (typically values from the GDBusMessageFlags enumeration bitwise ORed together).\n\t \n",
"line" : 389}
,
{
"name" : "setFlags",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusMessageFlags flags)",
"comment" : "\n Sets the flags to set on message.\n Since 2.26\n Params:\n flags = Flags for message that are set (typically values from the GDBusMessageFlags\n enumeration bitwise ORed together).\n\t \n",
"line" : 402}
,
{
"name" : "getBody",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Gets the body of a message.\n Since 2.26\n Returns: A GVariant or NULL if the body is empty. Do not free, it is owned by message.\n\t \n",
"line" : 413}
,
{
"name" : "setBody",
"kind" : "function",
"protection" : "public",
"type" : "void(Variant bod)",
"comment" : "\n Sets the body message. As a side-effect the\n G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field is set to the\n type string of body (or cleared if body is NULL).\n If body is floating, message assumes ownership of body.\n Since 2.26\n\t \n",
"line" : 431}
,
{
"name" : "getUnixFdList",
"kind" : "function",
"protection" : "public",
"type" : "UnixFDList()",
"comment" : "\n Gets the UNIX file descriptors associated with message, if any.\n This method is only available on UNIX.\n Since 2.26\n Returns: A GUnixFDList or NULL if no file descriptors are associated. Do not free, this object is owned by message.\n\t \n",
"line" : 443}
,
{
"name" : "setUnixFdList",
"kind" : "function",
"protection" : "public",
"type" : "void(UnixFDList fdList)",
"comment" : "\n Sets the UNIX file descriptors associated with message. As a\n side-effect the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header\n field is set to the number of fds in fd_list (or cleared if\n fd_list is NULL).\n This method is only available on UNIX.\n Since 2.26\n Params:\n fdList = A GUnixFDList or NULL. [allow-none]\n\t \n",
"line" : 464}
,
{
"name" : "getNumUnixFds",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 475}
,
{
"name" : "setNumUnixFds",
"kind" : "function",
"protection" : "public",
"type" : "void(uint value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 487}
,
{
"name" : "getHeaderFields",
"kind" : "function",
"protection" : "public",
"type" : "char*()",
"comment" : "\n Gets an array of all header fields on message that are set.\n Since 2.26\n Returns: An array of header fields terminated by G_DBUS_MESSAGE_HEADER_FIELD_INVALID. Each element is a guchar. Free with g_free().\n\t \n",
"line" : 498}
,
{
"name" : "getHeader",
"kind" : "function",
"protection" : "public",
"type" : "Variant(GDBusMessageHeaderField headerField)",
"comment" : "\n Gets a header field on message.\n Since 2.26\n Params:\n headerField = A 8-bit unsigned integer (typically a value from the GDBusMessageHeaderField enumeration)\n Returns: A GVariant with the value if the header was found, NULL otherwise. Do not free, it is owned by message.\n\t \n",
"line" : 511}
,
{
"name" : "setHeader",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusMessageHeaderField headerField, Variant value)",
"comment" : "\n Sets a header field on message.\n If value is floating, message assumes ownership of value.\n Since 2.26\n Params:\n headerField = A 8-bit unsigned integer (typically a value from the GDBusMessageHeaderField enumeration)\n value = A GVariant to set the header field or NULL to clear the header field.\n\t \n",
"line" : 530}
,
{
"name" : "getDestination",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 541}
,
{
"name" : "setDestination",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 553}
,
{
"name" : "getErrorName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 564}
,
{
"name" : "setErrorName",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 576}
,
{
"name" : "getInterface",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 587}
,
{
"name" : "setInterface",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 599}
,
{
"name" : "getMember",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 610}
,
{
"name" : "setMember",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_MEMBER header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 622}
,
{
"name" : "getPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 633}
,
{
"name" : "setPath",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_PATH header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 645}
,
{
"name" : "getReplySerial",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 656}
,
{
"name" : "setReplySerial",
"kind" : "function",
"protection" : "public",
"type" : "void(uint value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 668}
,
{
"name" : "getSender",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 679}
,
{
"name" : "setSender",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SENDER header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 691}
,
{
"name" : "getSignature",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience getter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.\n Since 2.26\n Returns: The value.\n\t \n",
"line" : 702}
,
{
"name" : "setSignature",
"kind" : "function",
"protection" : "public",
"type" : "void(string value)",
"comment" : "\n Convenience setter for the G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE header field.\n Since 2.26\n Params:\n value = The value to set.\n\t \n",
"line" : 714}
,
{
"name" : "getArg0",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Convenience to get the first item in the body of message.\n Since 2.26\n Returns: The string item or NULL if the first item in the body of message is not a string.\n\t \n",
"line" : 725}
,
{
"name" : "toBlob",
"kind" : "function",
"protection" : "public",
"type" : "char[](GDBusCapabilityFlags capabilities)",
"comment" : "\n Serializes message to a blob. The byte order returned by\n g_dbus_message_get_byte_order() will be used.\n Since 2.26\n Params:\n capabilities = A GDBusCapabilityFlags describing what protocol features are supported.\n Returns: A pointer to a valid binary D-Bus message of out_size bytes generated by message or NULL if error is set. Free with g_free().\n Throws: GException on failure.\n\t \n",
"line" : 740}
,
{
"name" : "bytesNeeded",
"kind" : "function",
"protection" : "public",
"type" : "long(char[] blob)",
"comment" : "\n Utility function to calculate how many bytes are needed to\n completely deserialize the D-Bus message stored at blob.\n Since 2.26\n Params:\n blob = A blob represent a binary D-Bus message.\n Returns: Number of bytes needed or -1 if error is set (e.g. if blob contains invalid data or not enough data is available to determine the size).\n Throws: GException on failure.\n\t \n",
"line" : 765}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMessage(char[] blob, GDBusCapabilityFlags capabilities)",
"comment" : "\n Creates a new GDBusMessage from the data stored at blob. The byte\n order that the message was in can be retrieved using\n g_dbus_message_get_byte_order().\n Since 2.26\n Params:\n blob = A blob represent a binary D-Bus message.\n capabilities = A GDBusCapabilityFlags describing what protocol features are supported.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 791}
,
{
"name" : "toGerror",
"kind" : "function",
"protection" : "public",
"type" : "int(out ErrorG error)",
"comment" : "\n If message is not of type G_DBUS_MESSAGE_TYPE_ERROR does\n nothing and returns FALSE.\n Otherwise this method encodes the error in message as a GError\n using g_dbus_error_set_dbus_error() using the information in the\n G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME header field of message as\n well as the first string item in message's body.\n Since 2.26\n Params:\n error = The GError to set.\n Returns: TRUE if error was set, FALSE otherwise.\n\t \n",
"line" : 822}
]
}
]
}
,
{
"name" : "gio.DBusMethodInvocation",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusMethodInvocation.d",
"members" : [
{
"name" : "DBusMethodInvocation",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Instances of the GDBusMethodInvocation class are used when\n handling D-Bus method calls. It provides a way to asynchronously\n return results and errors.\n The normal way to obtain a GDBusMethodInvocation object is to receive\n it as an argument to the handle_method_call() function in a\n GDBusInterfaceVTable that was passed to g_dbus_connection_register_object().\n \n",
"line" : 87,
"base" : "ObjectG",
"members" : [
{
"name" : "gDBusMethodInvocation",
"kind" : "variable",
"protection" : "protected",
"type" : "GDBusMethodInvocation*",
"comment" : " the main Gtk struct \n",
"line" : 91}
,
{
"name" : "getDBusMethodInvocationStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMethodInvocation*()",
"line" : 94}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 101}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusMethodInvocation(GDBusMethodInvocation* gDBusMethodInvocation)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 109}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 127}
,
{
"name" : "getSender",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n\t \n\n Gets the bus name that invoked the method.\n Since 2.26\n Returns: A string. Do not free, it is owned by invocation.\n\t \n",
"line" : 141}
,
{
"name" : "getObjectPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the object path the method was invoked on.\n Since 2.26\n Returns: A string. Do not free, it is owned by invocation.\n\t \n",
"line" : 152}
,
{
"name" : "getInterfaceName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name of the D-Bus interface the method was invoked on.\n Since 2.26\n Returns: A string. Do not free, it is owned by invocation.\n\t \n",
"line" : 163}
,
{
"name" : "getMethodName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name of the method that was invoked.\n Since 2.26\n Returns: A string. Do not free, it is owned by invocation.\n\t \n",
"line" : 174}
,
{
"name" : "getMethodInfo",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMethodInfo*()",
"comment" : "\n Gets information about the method call, if any.\n Since 2.26\n Returns: A GDBusMethodInfo or NULL. Do not free, it is owned by invocation.\n\t \n",
"line" : 185}
,
{
"name" : "getConnection",
"kind" : "function",
"protection" : "public",
"type" : "DBusConnection()",
"comment" : "\n Gets the GDBusConnection the method was invoked on.\n Since 2.26\n Returns: A GDBusConnection. Do not free, it is owned by invocation.\n\t \n",
"line" : 196}
,
{
"name" : "getMessage",
"kind" : "function",
"protection" : "public",
"type" : "DBusMessage()",
"comment" : "\n Gets the GDBusMessage for the method invocation. This is useful if\n you need to use low-level protocol features, such as UNIX file\n descriptor passing, that cannot be properly expressed in the\n GVariant API.\n See Example  2, “D-Bus server example” and Example  4, “D-Bus UNIX File Descriptor example” for an example of how to use this\n low-level API to send and receive UNIX file descriptors.\n Since 2.26\n Returns: A GDBusMessage. Do not free, it is owned by invocation.\n\t \n",
"line" : 217}
,
{
"name" : "getParameters",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Gets the parameters of the method invocation.\n Since 2.26\n Returns: A GVariant. Do not free, it is owned by invocation.\n\t \n",
"line" : 233}
,
{
"name" : "getUserData",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Gets the user_data gpointer passed to g_dbus_connection_register_object().\n Since 2.26\n Returns: A gpointer.\n\t \n",
"line" : 249}
,
{
"name" : "returnValue",
"kind" : "function",
"protection" : "public",
"type" : "void(Variant parameters)",
"comment" : "\n Finishes handling a D-Bus method call by returning parameters.\n If the parameters GVariant is floating, it is consumed.\n It is an error if parameters is not of the right format.\n This method will free invocation, you cannot use it afterwards.\n Since 2.26\n Params:\n parameters = A GVariant tuple with out parameters for the method or NULL if not passing any parameters.\n\t \n",
"line" : 264}
,
{
"name" : "returnErrorValist",
"kind" : "function",
"protection" : "public",
"type" : "void(uint domain, int code, string format, void* varArgs)",
"comment" : "\n Like g_dbus_method_invocation_return_error() but intended for\n language bindings.\n This method will free invocation, you cannot use it afterwards.\n Since 2.26\n Params:\n domain = A GQuark for the GError error domain.\n code = The error code.\n format = printf()-style format.\n varArgs = va_list of parameters for format.\n\t \n",
"line" : 281}
,
{
"name" : "returnErrorLiteral",
"kind" : "function",
"protection" : "public",
"type" : "void(uint domain, int code, string message)",
"comment" : "\n Like g_dbus_method_invocation_return_error() but without printf()-style formatting.\n This method will free invocation, you cannot use it afterwards.\n Since 2.26\n Params:\n domain = A GQuark for the GError error domain.\n code = The error code.\n message = The error message.\n\t \n",
"line" : 296}
,
{
"name" : "returnGerror",
"kind" : "function",
"protection" : "public",
"type" : "void(ErrorG error)",
"comment" : "\n Like g_dbus_method_invocation_return_error() but takes a GError\n instead of the error domain, error code and message.\n This method will free invocation, you cannot use it afterwards.\n Since 2.26\n Params:\n error = A GError.\n\t \n",
"line" : 310}
,
{
"name" : "returnDbusError",
"kind" : "function",
"protection" : "public",
"type" : "void(string errorName, string errorMessage)",
"comment" : "\n Finishes handling a D-Bus method call by returning an error.\n This method will free invocation, you cannot use it afterwards.\n Since 2.26\n Params:\n errorName = A valid D-Bus error name.\n errorMessage = A valid D-Bus error message.\n\t \n",
"line" : 324}
]
}
]
}
,
{
"name" : "gio.DBusNames",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusNames.d",
"members" : [
{
"name" : "DBusNames",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Convenience API for owning bus names.\n $(DDOC_COMMENT example)\n \n",
"line" : 77,
"base" : "Object",
"members" : [
{
"name" : "ownName",
"kind" : "function",
"protection" : "public",
"type" : "uint(GBusType busType, string name, GBusNameOwnerFlags flags, extern (C) void function(GDBusConnection*, char*, void*) busAcquiredHandler, extern (C) void function(GDBusConnection*, char*, void*) nameAcquiredHandler, extern (C) void function(GDBusConnection*, char*, void*) nameLostHandler, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Description\n Convenience API for watching bus names.\n $(DDOC_COMMENT example)\n\t \n\n Starts acquiring name on the bus specified by bus_type and calls\n name_acquired_handler and name_lost_handler when the name is\n acquired respectively lost. Callbacks will be invoked in the thread-default main\n loop of the thread you are calling this function from.\n You are guaranteed that one of the name_acquired_handler and name_lost_handler\n callbacks will be invoked after calling this function - there are three\n Since 2.26\n Params:\n busType = The type of bus to own a name on.\n name = The well-known name to own.\n flags = A set of flags from the GBusNameOwnerFlags enumeration.\n busAcquiredHandler = Handler to invoke when connected to the bus of type bus_type or NULL.\n nameAcquiredHandler = Handler to invoke when name is acquired or NULL.\n nameLostHandler = Handler to invoke when name is lost or NULL.\n userData = User data to pass to handlers.\n userDataFreeFunc = Function for freeing user_data or NULL.\n Returns: An identifier (never 0) that an be used with g_bus_unown_name() to stop owning the name.\n\t \n",
"line" : 104}
,
{
"name" : "ownNameOnConnection",
"kind" : "function",
"protection" : "public",
"type" : "uint(DBusConnection connection, string name, GBusNameOwnerFlags flags, extern (C) void function(GDBusConnection*, char*, void*) nameAcquiredHandler, extern (C) void function(GDBusConnection*, char*, void*) nameLostHandler, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Like g_bus_own_name() but takes a GDBusConnection instead of a\n GBusType.\n Since 2.26\n Params:\n connection = A GDBusConnection.\n name = The well-known name to own.\n flags = A set of flags from the GBusNameOwnerFlags enumeration.\n nameAcquiredHandler = Handler to invoke when name is acquired or NULL.\n nameLostHandler = Handler to invoke when name is lost or NULL.\n userData = User data to pass to handlers.\n userDataFreeFunc = Function for freeing user_data or NULL.\n Returns: An identifier (never 0) that an be used with g_bus_unown_name() to stop owning the name.\n\t \n",
"line" : 124}
,
{
"name" : "unownName",
"kind" : "function",
"protection" : "public",
"type" : "void(uint ownerId)",
"comment" : "\n Stops owning a name.\n Since 2.26\n Params:\n ownerId = An identifier obtained from g_bus_own_name()\n\t \n",
"line" : 136}
,
{
"name" : "ownNameWithClosures",
"kind" : "function",
"protection" : "public",
"type" : "uint(GBusType busType, string name, GBusNameOwnerFlags flags, Closure busAcquiredClosure, Closure nameAcquiredClosure, Closure nameLostClosure)",
"comment" : "\n Version of g_bus_own_name() using closures instead of callbacks for\n easier binding in other languages.\n Since 2.26\n Params:\n busType = The type of bus to own a name on.\n name = The well-known name to own.\n flags = A set of flags from the GBusNameOwnerFlags enumeration.\n busAcquiredClosure = GClosure to invoke when connected to\n the bus of type bus_type or NULL. [allow-none]\n nameAcquiredClosure = GClosure to invoke when name is\n acquired or NULL. [allow-none]\n nameLostClosure = GClosure to invoke when name is lost or\n NULL. [allow-none]\n Returns: An identifier (never 0) that an be used with g_bus_unown_name() to stop owning the name. Rename to: g_bus_own_name\n\t \n",
"line" : 158}
,
{
"name" : "ownNameOnConnectionWithClosures",
"kind" : "function",
"protection" : "public",
"type" : "uint(DBusConnection connection, string name, GBusNameOwnerFlags flags, Closure nameAcquiredClosure, Closure nameLostClosure)",
"comment" : "\n Version of g_bus_own_name_on_connection() using closures instead of callbacks for\n easier binding in other languages.\n Since 2.26\n Params:\n connection = A GDBusConnection.\n name = The well-known name to own.\n flags = A set of flags from the GBusNameOwnerFlags enumeration.\n nameAcquiredClosure = GClosure to invoke when name is\n acquired or NULL. [allow-none]\n nameLostClosure = GClosure to invoke when name is lost or\n NULL. [allow-none]\n Returns: An identifier (never 0) that an be used with g_bus_unown_name() to stop owning the name. Rename to: g_bus_own_name_on_connection\n\t \n",
"line" : 178}
,
{
"name" : "watchName",
"kind" : "function",
"protection" : "public",
"type" : "uint(GBusType busType, string name, GBusNameWatcherFlags flags, extern (C) void function(GDBusConnection*, char*, char*, void*) nameAppearedHandler, extern (C) void function(GDBusConnection*, char*, void*) nameVanishedHandler, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Starts watching name on the bus specified by bus_type and calls\n name_appeared_handler and name_vanished_handler when the name is\n known to have a owner respectively known to lose its\n owner. Callbacks will be invoked in the thread-default main\n loop of the thread you are calling this function from.\n You are guaranteed that one of the handlers will be invoked after\n calling this function. When you are done watching the name, just\n call g_bus_unwatch_name() with the watcher id this function\n returns.\n If the name vanishes or appears (for example the application owning\n the name could restart), the handlers are also invoked. If the\n GDBusConnection that is used for watching the name disconnects, then\n name_vanished_handler is invoked since it is no longer\n possible to access the name.\n Another guarantee is that invocations of name_appeared_handler\n and name_vanished_handler are guaranteed to alternate; that\n is, if name_appeared_handler is invoked then you are\n guaranteed that the next time one of the handlers is invoked, it\n will be name_vanished_handler. The reverse is also true.\n This behavior makes it very simple to write applications that wants\n to take action when a certain name exists, see Example  9, “Simple application watching a name”. Basically, the application\n should create object proxies in name_appeared_handler and destroy\n them again (if any) in name_vanished_handler.\n Since 2.26\n Params:\n busType = The type of bus to watch a name on.\n name = The name (well-known or unique) to watch.\n flags = Flags from the GBusNameWatcherFlags enumeration.\n nameAppearedHandler = Handler to invoke when name is known to exist or NULL.\n nameVanishedHandler = Handler to invoke when name is known to not exist or NULL.\n userData = User data to pass to handlers.\n userDataFreeFunc = Function for freeing user_data or NULL.\n Returns: An identifier (never 0) that an be used with g_bus_unwatch_name() to stop watching the name.\n\t \n",
"line" : 219}
,
{
"name" : "watchNameOnConnection",
"kind" : "function",
"protection" : "public",
"type" : "uint(DBusConnection connection, string name, GBusNameWatcherFlags flags, extern (C) void function(GDBusConnection*, char*, char*, void*) nameAppearedHandler, extern (C) void function(GDBusConnection*, char*, void*) nameVanishedHandler, void* userData, extern (C) void function(void* cbData) userDataFreeFunc)",
"comment" : "\n Like g_bus_watch_name() but takes a GDBusConnection instead of a\n GBusType.\n Since 2.26\n Params:\n connection = A GDBusConnection.\n name = The name (well-known or unique) to watch.\n flags = Flags from the GBusNameWatcherFlags enumeration.\n nameAppearedHandler = Handler to invoke when name is known to exist or NULL.\n nameVanishedHandler = Handler to invoke when name is known to not exist or NULL.\n userData = User data to pass to handlers.\n userDataFreeFunc = Function for freeing user_data or NULL.\n Returns: An identifier (never 0) that an be used with g_bus_unwatch_name() to stop watching the name.\n\t \n",
"line" : 239}
,
{
"name" : "unwatchName",
"kind" : "function",
"protection" : "public",
"type" : "void(uint watcherId)",
"comment" : "\n Stops watching a name.\n Since 2.26\n Params:\n watcherId = An identifier obtained from g_bus_watch_name()\n\t \n",
"line" : 251}
,
{
"name" : "watchNameWithClosures",
"kind" : "function",
"protection" : "public",
"type" : "uint(GBusType busType, string name, GBusNameWatcherFlags flags, Closure nameAppearedClosure, Closure nameVanishedClosure)",
"comment" : "\n Version of g_bus_watch_name() using closures instead of callbacks for\n easier binding in other languages.\n Since 2.26\n Params:\n busType = The type of bus to watch a name on.\n name = The name (well-known or unique) to watch.\n flags = Flags from the GBusNameWatcherFlags enumeration.\n nameAppearedClosure = GClosure to invoke when name is known\n to exist or NULL. [allow-none]\n nameVanishedClosure = GClosure to invoke when name is known\n to not exist or NULL. [allow-none]\n Returns: An identifier (never 0) that an be used with g_bus_unwatch_name() to stop watching the name. Rename to: g_bus_watch_name\n\t \n",
"line" : 271}
,
{
"name" : "watchNameOnConnectionWithClosures",
"kind" : "function",
"protection" : "public",
"type" : "uint(DBusConnection connection, string name, GBusNameWatcherFlags flags, Closure nameAppearedClosure, Closure nameVanishedClosure)",
"comment" : "\n Version of g_bus_watch_name_on_connection() using closures instead of callbacks for\n easier binding in other languages.\n Since 2.26\n Params:\n connection = A GDBusConnection.\n name = The name (well-known or unique) to watch.\n flags = Flags from the GBusNameWatcherFlags enumeration.\n nameAppearedClosure = GClosure to invoke when name is known\n to exist or NULL. [allow-none]\n nameVanishedClosure = GClosure to invoke when name is known\n to not exist or NULL. [allow-none]\n Returns: An identifier (never 0) that an be used with g_bus_unwatch_name() to stop watching the name. Rename to: g_bus_watch_name_on_connection\n\t \n",
"line" : 291}
]
}
]
}
,
{
"name" : "gio.DBusProxy",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusProxy.d",
"members" : [
{
"name" : "DBusProxy",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GDBusProxy is a base class used for proxies to access a D-Bus\n interface on a remote object. A GDBusProxy can be constructed for\n both well-known and unique names.\n By default, GDBusProxy will cache all properties (and listen to\n changes) of the remote object, and proxy all signals that gets\n emitted. This behaviour can be changed by passing suitable\n GDBusProxyFlags when the proxy is created. If the proxy is for a\n well-known name, the property cache is flushed when the name owner\n vanishes and reloaded when a name owner appears.\n If a GDBusProxy is used for a well-known name, the owner of the\n name is tracked and can be read from\n \"g-name-owner\". Connect to the \"notify\" signal to\n get notified of changes. Additionally, only signals and property\n changes emitted from the current name owner are considered and\n calls are always sent to the current name owner. This avoids a\n number of race conditions when the name is lost by one owner and\n claimed by another. However, if no name owner currently exists,\n then calls will be sent to the well-known name which may result in\n the message bus launching an owner (unless\n G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is set).\n The generic \"g-properties-changed\" and \"g-signal\"\n signals are not very convenient to work with. Therefore, the recommended\n way of working with proxies is to subclass GDBusProxy, and have\n more natural properties and signals in your derived class.\n See Example  14, “GDBusProxy subclass example” for an example.\n $(DDOC_COMMENT example)\n \n",
"line" : 115,
"base" : "ObjectG",
"members" : [
{
"name" : "gDBusProxy",
"kind" : "variable",
"protection" : "protected",
"type" : "GDBusProxy*",
"comment" : " the main Gtk struct \n",
"line" : 119}
,
{
"name" : "getDBusProxyStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDBusProxy*()",
"line" : 122}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 129}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusProxy(GDBusProxy* gDBusProxy)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 137}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 155}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusProxy(AsyncResultIF res, bool forBus = false)",
"comment" : "\n Finishes creating a GDBusProxy.\n Since 2.26\n Params:\n     res    = A GAsyncResult obtained from the GAsyncReadyCallback\n              function passed to g_dbus_proxy_new().\n     forBus = If true finish an address.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 171}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 200}
,
{
"name" : "onGPropertiesChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(GVariant, char***, DBusProxy)[]",
"line" : 202}
,
{
"name" : "addOnGPropertiesChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(GVariant, char***, DBusProxy) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when one or more D-Bus properties on proxy changes. The\n local cache has already been updated when this signal fires. Note\n that both changed_properties and invalidated_properties are\n guaranteed to never be NULL (either may be empty though).\n This signal corresponds to the\n PropertiesChanged D-Bus signal on the\n org.freedesktop.DBus.Properties interface.\n Since 2.26\n\t \n",
"line" : 213}
,
{
"name" : "callBackGPropertiesChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GDBusProxy* proxyStruct, GVariant changedProperties, char*** invalidatedProperties, DBusProxy dBusProxy)",
"line" : 228}
,
{
"name" : "onGSignalListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(string, string, GVariant, DBusProxy)[]",
"line" : 236}
,
{
"name" : "addOnGSignal",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string, string, GVariant, DBusProxy) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a signal from the remote object and interface that proxy is for, has been received.\n Since 2.26\n\t \n",
"line" : 241}
,
{
"name" : "callBackGSignal",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GDBusProxy* proxyStruct, char* senderName, char* signalName, GVariant parameters, DBusProxy dBusProxy)",
"line" : 256}
,
{
"name" : "newDBusProxy",
"kind" : "function",
"protection" : "public",
"type" : "void(DBusConnection connection, GDBusProxyFlags flags, GDBusInterfaceInfo* info, string name, string objectPath, string interfaceName, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Creates a proxy for accessing interface_name on the remote object\n at object_path owned by name at connection and asynchronously\n loads D-Bus properties unless the\n G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used. Connect to\n the \"g-properties-changed\" signal to get notified about\n property changes.\n If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up\n match rules for signals. Connect to the \"g-signal\" signal\n to handle signals from the remote object.\n If name is a well-known name and the\n G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag isn't set and no name\n owner currently exists, the message bus will be requested to launch\n a name owner for the name.\n This is a failable asynchronous constructor - when the proxy is\n ready, callback will be invoked and you can use\n g_dbus_proxy_new_finish() to get the result.\n See g_dbus_proxy_new_sync() and for a synchronous version of this constructor.\n See Example  10, “GDBusProxy for a well-known-name” for an example of how GDBusProxy can be used.\n Since 2.26\n Params:\n connection = A GDBusConnection.\n flags = Flags used when constructing the proxy.\n info = A GDBusInterfaceInfo specifying the minimal interface that proxy conforms to or NULL.\n name = A bus name (well-known or unique) or NULL if connection is not a message bus connection.\n objectPath = An object path.\n interfaceName = A D-Bus interface name.\n cancellable = A GCancellable or NULL.\n callback = Callback function to invoke when the proxy is ready.\n userData = User data to pass to callback.\n\t \n",
"line" : 296}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusProxy(DBusConnection connection, GDBusProxyFlags flags, GDBusInterfaceInfo* info, string name, string objectPath, string interfaceName, Cancellable cancellable)",
"comment" : "\n Creates a proxy for accessing interface_name on the remote object\n at object_path owned by name at connection and synchronously\n loads D-Bus properties unless the\n G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES flag is used.\n If the G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS flag is not set, also sets up\n match rules for signals. Connect to the \"g-signal\" signal\n to handle signals from the remote object.\n If name is a well-known name and the\n G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START flag isn't set and no name\n owner currently exists, the message bus will be requested to launch\n a name owner for the name.\n This is a synchronous failable constructor. See g_dbus_proxy_new()\n and g_dbus_proxy_new_finish() for the asynchronous version.\n See Example  10, “GDBusProxy for a well-known-name” for an example of how GDBusProxy can be used.\n Since 2.26\n Params:\n connection = A GDBusConnection.\n flags = Flags used when constructing the proxy.\n info = A GDBusInterfaceInfo specifying the minimal interface that proxy conforms to or NULL. [allow-none]\n name = A bus name (well-known or unique) or NULL if connection is not a message bus connection. [allow-none]\n objectPath = An object path.\n interfaceName = A D-Bus interface name.\n cancellable = A GCancellable or NULL. [allow-none]\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 329}
,
{
"name" : "newForBus",
"kind" : "function",
"protection" : "public",
"type" : "void(GBusType busType, GDBusProxyFlags flags, GDBusInterfaceInfo* info, string name, string objectPath, string interfaceName, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Like g_dbus_proxy_new() but takes a GBusType instead of a GDBusConnection.\n See Example  10, “GDBusProxy for a well-known-name” for an example of how GDBusProxy can be used.\n Since 2.26\n Params:\n busType = A GBusType.\n flags = Flags used when constructing the proxy.\n info = A GDBusInterfaceInfo specifying the minimal interface that proxy conforms to or NULL.\n name = A bus name (well-known or unique).\n objectPath = An object path.\n interfaceName = A D-Bus interface name.\n cancellable = A GCancellable or NULL.\n callback = Callback function to invoke when the proxy is ready.\n userData = User data to pass to callback.\n\t \n",
"line" : 363}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusProxy(GBusType busType, GDBusProxyFlags flags, GDBusInterfaceInfo* info, string name, string objectPath, string interfaceName, Cancellable cancellable)",
"comment" : "\n Like g_dbus_proxy_new_sync() but takes a GBusType instead of a GDBusConnection.\n See Example  10, “GDBusProxy for a well-known-name” for an example of how GDBusProxy can be used.\n Since 2.26\n Params:\n busType = A GBusType.\n flags = Flags used when constructing the proxy.\n info = A GDBusInterfaceInfo specifying the minimal interface that proxy conforms to or NULL.\n name = A bus name (well-known or unique).\n objectPath = An object path.\n interfaceName = A D-Bus interface name.\n cancellable = A GCancellable or NULL.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 384}
,
{
"name" : "getFlags",
"kind" : "function",
"protection" : "public",
"type" : "GDBusProxyFlags()",
"comment" : "\n Gets the flags that proxy was constructed with.\n Since 2.26\n Returns: Flags from the GDBusProxyFlags enumeration.\n\t \n",
"line" : 408}
,
{
"name" : "getConnection",
"kind" : "function",
"protection" : "public",
"type" : "DBusConnection()",
"comment" : "\n Gets the connection proxy is for.\n Since 2.26\n Returns: A GDBusConnection owned by proxy. Do not free.\n\t \n",
"line" : 419}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name that proxy was constructed for.\n Since 2.26\n Returns: A string owned by proxy. Do not free.\n\t \n",
"line" : 435}
,
{
"name" : "getNameOwner",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n The unique name that owns the name that proxy is for or NULL if\n no-one currently owns that name. You may connect to the\n \"notify\" signal to track changes to the\n \"g-name-owner\" property.\n Since 2.26\n Returns: The name owner or NULL if no name owner exists. Free with g_free().\n\t \n",
"line" : 449}
,
{
"name" : "getObjectPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the object path proxy is for.\n Since 2.26\n Returns: A string owned by proxy. Do not free.\n\t \n",
"line" : 460}
,
{
"name" : "getInterfaceName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the D-Bus interface name proxy is for.\n Since 2.26\n Returns: A string owned by proxy. Do not free.\n\t \n",
"line" : 471}
,
{
"name" : "getDefaultTimeout",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the timeout to use if -1 (specifying default timeout) is\n passed as timeout_msec in the g_dbus_proxy_call() and\n g_dbus_proxy_call_sync() functions.\n See the \"g-default-timeout\" property for more details.\n Since 2.26\n Returns: Timeout to use for proxy.\n\t \n",
"line" : 485}
,
{
"name" : "setDefaultTimeout",
"kind" : "function",
"protection" : "public",
"type" : "void(int timeoutMsec)",
"comment" : "\n Sets the timeout to use if -1 (specifying default timeout) is\n passed as timeout_msec in the g_dbus_proxy_call() and\n g_dbus_proxy_call_sync() functions.\n See the \"g-default-timeout\" property for more details.\n Since 2.26\n Params:\n timeoutMsec = Timeout in milliseconds.\n\t \n",
"line" : 500}
,
{
"name" : "getCachedProperty",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string propertyName)",
"comment" : "\n Looks up the value for a property from the cache. This call does no\n blocking IO.\n If proxy has an expected interface (see\n \"g-interface-info\"), then property_name (for existence)\n is checked against it.\n Since 2.26\n Params:\n propertyName = Property name.\n Returns: A reference to the GVariant instance that holds the value for property_name or NULL if the value is not in the cache. The returned reference must be freed with g_variant_unref().\n\t \n",
"line" : 517}
,
{
"name" : "setCachedProperty",
"kind" : "function",
"protection" : "public",
"type" : "void(string propertyName, Variant value)",
"comment" : "\n If value is not NULL, sets the cached value for the property with\n name property_name to the value in value.\n If value is NULL, then the cached value is removed from the\n property cache.\n If proxy has an expected interface (see\n \"g-interface-info\"), then property_name (for existence)\n and value (for the type) is checked against it.\n If the value GVariant is floating, it is consumed. This allows\n convenient 'inline' use of g_variant_new(), e.g.\n $(DDOC_COMMENT example)\n Normally you will not need to use this method since proxy is\n tracking changes using the\n org.freedesktop.DBus.Properties.PropertiesChanged\n D-Bus signal. However, for performance reasons an object may decide\n to not use this signal for some properties and instead use a\n proprietary out-of-band mechanism to transmit changes.\n As a concrete example, consider an object with a property\n ChatroomParticipants which is an array of\n strings. Instead of transmitting the same (long) array every time\n the property changes, it is more efficient to only transmit the\n delta using e.g. signals ChatroomParticipantJoined(String\n name) and ChatroomParticipantParted(String\n name).\n Since 2.26\n Params:\n propertyName = Property name.\n value = Value for the property or NULL to remove it from the cache.\n\t \n",
"line" : 557}
,
{
"name" : "getCachedPropertyNames",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the names of all cached properties on proxy.\n Since 2.26\n Returns: A NULL-terminated array of strings or NULL if proxy has no cached properties. Free the returned array with g_strfreev().\n\t \n",
"line" : 568}
,
{
"name" : "setInterfaceInfo",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusInterfaceInfo* info)",
"comment" : "\n Ensure that interactions with proxy conform to the given\n interface. For example, when completing a method call, if the type\n signature of the message isn't what's expected, the given GError\n is set. Signals that have a type signature mismatch are simply\n dropped.\n See the \"g-interface-info\" property for more details.\n Since 2.26\n Params:\n info = Minimum interface this proxy conforms to or NULL to unset.\n\t \n",
"line" : 585}
,
{
"name" : "getInterfaceInfo",
"kind" : "function",
"protection" : "public",
"type" : "GDBusInterfaceInfo*()",
"comment" : "\n Returns the GDBusInterfaceInfo, if any, specifying the minimal\n interface that proxy conforms to.\n See the \"g-interface-info\" property for more details.\n Since 2.26\n Returns: A GDBusInterfaceInfo or NULL. Do not unref the returned object, it is owned by proxy.\n\t \n",
"line" : 598}
,
{
"name" : "call",
"kind" : "function",
"protection" : "public",
"type" : "void(string methodName, Variant parameters, GDBusCallFlags flags, int timeoutMsec, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously invokes the method_name method on proxy.\n If method_name contains any dots, then name is split into interface and\n method name parts. This allows using proxy for invoking methods on\n other interfaces.\n If the GDBusConnection associated with proxy is closed then\n the operation will fail with G_IO_ERROR_CLOSED. If\n cancellable is canceled, the operation will fail with\n G_IO_ERROR_CANCELLED. If parameters contains a value not\n compatible with the D-Bus protocol, the operation fails with\n G_IO_ERROR_INVALID_ARGUMENT.\n If the parameters GVariant is floating, it is consumed. This allows\n Since 2.26\n Params:\n methodName = Name of method to invoke.\n parameters = A GVariant tuple with parameters for the signal or NULL if not passing parameters.\n flags = Flags from the GDBusCallFlags enumeration.\n timeoutMsec = The timeout in milliseconds or -1 to use the proxy default timeout.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied or NULL if you don't\n care about the result of the method invocation.\n userData = The data to pass to callback.\n\t \n",
"line" : 627}
,
{
"name" : "callFinish",
"kind" : "function",
"protection" : "public",
"type" : "Variant(AsyncResultIF res)",
"comment" : "\n Finishes an operation started with g_dbus_proxy_call().\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_proxy_call().\n Returns: NULL if error is set. Otherwise a GVariant tuple with return values. Free with g_variant_unref().\n Throws: GException on failure.\n\t \n",
"line" : 641}
,
{
"name" : "callSync",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string methodName, Variant parameters, GDBusCallFlags flags, int timeoutMsec, Cancellable cancellable)",
"comment" : "\n Synchronously invokes the method_name method on proxy.\n If method_name contains any dots, then name is split into interface and\n method name parts. This allows using proxy for invoking methods on\n other interfaces.\n If the GDBusConnection associated with proxy is disconnected then\n the operation will fail with G_IO_ERROR_CLOSED. If\n cancellable is canceled, the operation will fail with\n G_IO_ERROR_CANCELLED. If parameters contains a value not\n compatible with the D-Bus protocol, the operation fails with\n G_IO_ERROR_INVALID_ARGUMENT.\n If the parameters GVariant is floating, it is consumed. This allows\n Since 2.26\n Params:\n methodName = Name of method to invoke.\n parameters = A GVariant tuple with parameters for the signal or NULL if not passing parameters.\n flags = Flags from the GDBusCallFlags enumeration.\n timeoutMsec = The timeout in milliseconds or -1 to use the proxy default timeout.\n cancellable = A GCancellable or NULL.\n Returns: NULL if error is set. Otherwise a GVariant tuple with return values. Free with g_variant_unref().\n Throws: GException on failure.\n\t \n",
"line" : 682}
]
}
]
}
,
{
"name" : "gio.DBusServer",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusServer.d",
"members" : [
{
"name" : "DBusServer",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GDBusServer is a helper for listening to and accepting D-Bus\n connections.\n $(DDOC_COMMENT example)\n \n",
"line" : 89,
"base" : "ObjectG",
"interfaces" : [
"InitableIF"],
"members" : [
{
"name" : "gDBusServer",
"kind" : "variable",
"protection" : "protected",
"type" : "GDBusServer*",
"comment" : " the main Gtk struct \n",
"line" : 93}
,
{
"name" : "getDBusServerStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDBusServer*()",
"line" : 96}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 103}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusServer(GDBusServer* gDBusServer)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 111}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 129}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 140}
,
{
"name" : "onNewConnectionListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(GDBusConnection*, DBusServer)[]",
"line" : 142}
,
{
"name" : "addOnNewConnection",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(GDBusConnection*, DBusServer) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a new authenticated connection has been made. Use\n g_dbus_connection_get_peer_credentials() to figure out what\n identity (if any), was authenticated.\n If you want to accept the connection, take a reference to the\n connection object and return TRUE. When you are done with the\n connection call g_dbus_connection_close() and give up your\n reference. Note that the other peer may disconnect at any time -\n a typical thing to do when accepting a connection is to listen to\n the \"closed\" signal.\n If \"flags\" contains G_DBUS_SERVER_FLAGS_RUN_IN_THREAD\n then the signal is emitted in a new thread dedicated to the\n connection. Otherwise the signal is emitted in the thread-default main\n loop of the thread that server was constructed in.\n You are guaranteed that signal handlers for this signal runs\n before incoming messages on connection are processed. This means\n that it's suitable to call g_dbus_connection_register_object() or\n similar from the signal handler.\n Since 2.26\n\t \n",
"line" : 163}
,
{
"name" : "callBackNewConnection",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(GDBusServer* serverStruct, GDBusConnection* connection, DBusServer dBusServer)",
"line" : 178}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DBusServer(string address, GDBusServerFlags flags, string guid, DBusAuthObserver observer, Cancellable cancellable)",
"comment" : "\n Creates a new D-Bus server that listens on the first address in\n address that works.\n Once constructed, you can use g_dbus_server_get_client_address() to\n get a D-Bus address string that clients can use to connect.\n Connect to the \"new-connection\" signal to handle\n incoming connections.\n The returned GDBusServer isn't active - you have to start it with\n g_dbus_server_start().\n See Example  6, “D-Bus peer-to-peer example” for how GDBusServer can\n be used.\n This is a synchronous failable constructor. See\n g_dbus_server_new() for the asynchronous version.\n Since 2.26\n Params:\n address = A D-Bus address.\n flags = Flags from the GDBusServerFlags enumeration.\n guid = A D-Bus GUID.\n observer = A GDBusAuthObserver or NULL.\n cancellable = A GCancellable or NULL.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 215}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Starts server.\n Since 2.26\n\t \n",
"line" : 238}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Stops server.\n Since 2.26\n\t \n",
"line" : 248}
,
{
"name" : "isActive",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets whether server is active.\n Since 2.26\n Returns: TRUE if server is active, FALSE otherwise.\n\t \n",
"line" : 259}
,
{
"name" : "getGuid",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the GUID for server.\n Since 2.26\n Returns: A D-Bus GUID. Do not free this string, it is owned by server.\n\t \n",
"line" : 270}
,
{
"name" : "getFlags",
"kind" : "function",
"protection" : "public",
"type" : "GDBusServerFlags()",
"comment" : "\n Gets the flags for server.\n Since 2.26\n Returns: A set of flags from the GDBusServerFlags enumeration.\n\t \n",
"line" : 281}
,
{
"name" : "getClientAddress",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets a D-Bus address string that can be used by clients to connect\n to server.\n Since 2.26\n Returns: A D-Bus address string. Do not free, the string is owned by server.\n\t \n",
"line" : 293}
]
}
]
}
,
{
"name" : "gio.DBusUtilities",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DBusUtilities.d",
"members" : [
{
"name" : "DBusUtilities",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Various utility routines related to D-Bus.\n \n",
"line" : 82,
"base" : "Object",
"members" : [
{
"name" : "generateGuid",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Description\n Routines for working with D-Bus addresses. A D-Bus address is a string\n like \"unix:tmpdir=\/tmp\/my-app-name\". The exact format of addresses\n is explained in detail in the D-Bus specification.\n\t \n\n Description\n Various data structures and convenience routines to parse and\n generate D-Bus introspection XML. Introspection information is\n used when registering objects with g_dbus_connection_register_object().\n The format of D-Bus introspection XML is specified in the\n D-Bus specification.\n\t \n\n Generate a D-Bus GUID that can be used with\n e.g. g_dbus_connection_new().\n See the D-Bus specification regarding what strings are valid D-Bus\n GUID (for example, D-Bus GUIDs are not RFC-4122 compliant).\n Since 2.26\n Returns: A valid D-Bus GUID. Free with g_free().\n\t \n",
"line" : 108}
,
{
"name" : "isGuid",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Checks if string is a D-Bus GUID.\n See the D-Bus specification regarding what strings are valid D-Bus\n GUID (for example, D-Bus GUIDs are not RFC-4122 compliant).\n Since 2.26\n Params:\n string = The string to check.\n Returns: TRUE if string is a guid, FALSE otherwise.\n\t \n",
"line" : 123}
,
{
"name" : "isName",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Checks if string is a valid D-Bus bus name (either unique or well-known).\n Since 2.26\n Params:\n string = The string to check.\n Returns: TRUE if valid, FALSE otherwise.\n\t \n",
"line" : 136}
,
{
"name" : "isUniqueName",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Checks if string is a valid D-Bus unique bus name.\n Since 2.26\n Params:\n string = The string to check.\n Returns: TRUE if valid, FALSE otherwise.\n\t \n",
"line" : 149}
,
{
"name" : "isMemberName",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Checks if string is a valid D-Bus member (e.g. signal or method) name.\n Since 2.26\n Params:\n string = The string to check.\n Returns: TRUE if valid, FALSE otherwise.\n\t \n",
"line" : 162}
,
{
"name" : "isInterfaceName",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Checks if string is a valid D-Bus interface name.\n Since 2.26\n Params:\n string = The string to check.\n Returns: TRUE if valid, FALSE otherwise.\n\t \n",
"line" : 175}
,
{
"name" : "isAddress",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Checks if string is a D-Bus address.\n This doesn't check if string is actually supported by GDBusServer\n or GDBusConnection - use g_dbus_is_supported_address() to do more\n checks.\n Since 2.26\n Params:\n string = A string.\n Returns: TRUE if string is a valid D-Bus address, FALSE otherwise.\n\t \n",
"line" : 191}
,
{
"name" : "isSupportedAddress",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Like g_dbus_is_address() but also checks if the library suppors the\n transports in string and that key\/value pairs for each transport\n are valid.\n Since 2.26\n Params:\n string = A string.\n Returns: TRUE if string is a valid D-Bus address that is supported by this library, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 207}
,
{
"name" : "addressGetStream",
"kind" : "function",
"protection" : "public",
"type" : "void(string address, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously connects to an endpoint specified by address and\n sets up the connection so it is in a state to run the client-side\n of the D-Bus authentication conversation.\n When the operation is finished, callback will be invoked. You can\n then call g_dbus_address_get_stream_finish() to get the result of\n the operation.\n This is an asynchronous failable function. See\n g_dbus_address_get_stream_sync() for the synchronous version.\n Since 2.26\n Params:\n address = A valid D-Bus address.\n cancellable = A GCancellable or NULL.\n callback = A GAsyncReadyCallback to call when the request is satisfied.\n userData = Data to pass to callback.\n\t \n",
"line" : 238}
,
{
"name" : "addressGetStreamFinish",
"kind" : "function",
"protection" : "public",
"type" : "IOStream(AsyncResultIF res, out string outGuid)",
"comment" : "\n Finishes an operation started with g_dbus_address_get_stream().\n Since 2.26\n Params:\n res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_address_get_stream().\n outGuid = NULL or return location to store the GUID extracted from address, if any.\n Returns: A GIOStream or NULL if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 253}
,
{
"name" : "addressGetStreamSync",
"kind" : "function",
"protection" : "public",
"type" : "IOStream(string address, out string outGuid, Cancellable cancellable)",
"comment" : "\n Synchronously connects to an endpoint specified by address and\n sets up the connection so it is in a state to run the client-side\n of the D-Bus authentication conversation.\n This is a synchronous failable function. See\n g_dbus_address_get_stream() for the asynchronous version.\n Since 2.26\n Params:\n address = A valid D-Bus address.\n outGuid = NULL or return location to store the GUID extracted from address, if any.\n cancellable = A GCancellable or NULL.\n Returns: A GIOStream or NULL if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 288}
,
{
"name" : "addressGetForBusSync",
"kind" : "function",
"protection" : "public",
"type" : "string(GBusType busType, Cancellable cancellable)",
"comment" : "\n Synchronously looks up the D-Bus address for the well-known message\n bus instance specified by bus_type. This may involve using various\n platform specific mechanisms.\n Since 2.26\n Params:\n busType = A GBusType.\n cancellable = A GCancellable or NULL.\n Returns: A valid D-Bus address string for bus_type or NULL if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 320}
,
{
"name" : "annotationInfoLookup",
"kind" : "function",
"protection" : "public",
"type" : "string(GDBusAnnotationInfo** annotations, string name)",
"comment" : "\n Looks up the value of an annotation.\n This cost of this function is O(n) in number of annotations.\n Since 2.26\n Params:\n annotations = A NULL-terminated array of annotations or NULL.\n name = The name of the annotation to look up.\n Returns: The value or NULL if not found. Do not free, it is owned by annotations.\n\t \n",
"line" : 344}
,
{
"name" : "interfaceInfoLookupMethod",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMethodInfo*(GDBusInterfaceInfo* info, string name)",
"comment" : "\n Looks up information about a method.\n This cost of this function is O(n) in number of methods.\n Since 2.26\n Params:\n info = A GDBusInterfaceInfo.\n name = A D-Bus method name (typically in CamelCase)\n Returns: A GDBusMethodInfo or NULL if not found. Do not free, it is owned by info.\n\t \n",
"line" : 359}
,
{
"name" : "interfaceInfoLookupSignal",
"kind" : "function",
"protection" : "public",
"type" : "GDBusSignalInfo*(GDBusInterfaceInfo* info, string name)",
"comment" : "\n Looks up information about a signal.\n This cost of this function is O(n) in number of signals.\n Since 2.26\n Params:\n info = A GDBusInterfaceInfo.\n name = A D-Bus signal name (typically in CamelCase)\n Returns: A GDBusSignalInfo or NULL if not found. Do not free, it is owned by info.\n\t \n",
"line" : 374}
,
{
"name" : "interfaceInfoLookupProperty",
"kind" : "function",
"protection" : "public",
"type" : "GDBusPropertyInfo*(GDBusInterfaceInfo* info, string name)",
"comment" : "\n Looks up information about a property.\n This cost of this function is O(n) in number of properties.\n Since 2.26\n Params:\n info = A GDBusInterfaceInfo.\n name = A D-Bus property name (typically in CamelCase).\n Returns: A GDBusPropertyInfo or NULL if not found. Do not free, it is owned by info.\n\t \n",
"line" : 389}
,
{
"name" : "interfaceInfoGenerateXml",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusInterfaceInfo* info, uint indent, StringG stringBuilder)",
"comment" : "\n Appends an XML representation of info (and its children) to string_builder.\n This function is typically used for generating introspection XML\n documents at run-time for handling the\n org.freedesktop.DBus.Introspectable.Introspect\n method.\n Since 2.26\n Params:\n info = A GDBusNodeInfo\n indent = Indentation level.\n stringBuilder = A GString to to append XML data to.\n\t \n",
"line" : 407}
,
{
"name" : "nodeInfoNewForXml",
"kind" : "function",
"protection" : "public",
"type" : "GDBusNodeInfo*(string xmlData)",
"comment" : "\n Parses xml_data and returns a GDBusNodeInfo representing the data.\n Since 2.26\n Params:\n xmlData = Valid D-Bus introspection XML.\n Returns: A GDBusNodeInfo structure or NULL if error is set. Free with g_dbus_node_info_unref().\n Throws: GException on failure.\n\t \n",
"line" : 421}
,
{
"name" : "nodeInfoLookupInterface",
"kind" : "function",
"protection" : "public",
"type" : "GDBusInterfaceInfo*(GDBusNodeInfo* info, string name)",
"comment" : "\n Looks up information about an interface.\n This cost of this function is O(n) in number of interfaces.\n Since 2.26\n Params:\n info = A GDBusNodeInfo.\n name = A D-Bus interface name.\n Returns: A GDBusInterfaceInfo or NULL if not found. Do not free, it is owned by info.\n\t \n",
"line" : 445}
,
{
"name" : "nodeInfoGenerateXml",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusNodeInfo* info, uint indent, StringG stringBuilder)",
"comment" : "\n Appends an XML representation of info (and its children) to string_builder.\n This function is typically used for generating introspection XML documents at run-time for\n handling the org.freedesktop.DBus.Introspectable.Introspect method.\n Since 2.26\n Params:\n info = A GDBusNodeInfo.\n indent = Indentation level.\n stringBuilder = A GString to to append XML data to.\n\t \n",
"line" : 461}
,
{
"name" : "nodeInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusNodeInfo*(GDBusNodeInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusNodeInfo\n Returns: The same info.\n\t \n",
"line" : 475}
,
{
"name" : "interfaceInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusInterfaceInfo*(GDBusInterfaceInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusInterfaceInfo\n Returns: The same info.\n\t \n",
"line" : 489}
,
{
"name" : "methodInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusMethodInfo*(GDBusMethodInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusMethodInfo\n Returns: The same info.\n\t \n",
"line" : 503}
,
{
"name" : "signalInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusSignalInfo*(GDBusSignalInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusSignalInfo\n Returns: The same info.\n\t \n",
"line" : 517}
,
{
"name" : "propertyInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusPropertyInfo*(GDBusPropertyInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusPropertyInfo\n Returns: The same info.\n\t \n",
"line" : 531}
,
{
"name" : "argInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusArgInfo*(GDBusArgInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusArgInfo\n Returns: The same info.\n\t \n",
"line" : 545}
,
{
"name" : "annotationInfoRef",
"kind" : "function",
"protection" : "public",
"type" : "GDBusAnnotationInfo*(GDBusAnnotationInfo* info)",
"comment" : "\n If info is statically allocated does nothing. Otherwise increases\n the reference count.\n Since 2.26\n Params:\n info = A GDBusNodeInfo\n Returns: The same info.\n\t \n",
"line" : 559}
,
{
"name" : "nodeInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusNodeInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusNodeInfo.\n\t \n",
"line" : 573}
,
{
"name" : "interfaceInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusInterfaceInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusInterfaceInfo.\n\t \n",
"line" : 587}
,
{
"name" : "methodInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusMethodInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusMethodInfo.\n\t \n",
"line" : 601}
,
{
"name" : "signalInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusSignalInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusSignalInfo.\n\t \n",
"line" : 615}
,
{
"name" : "propertyInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusPropertyInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusPropertyInfo.\n\t \n",
"line" : 629}
,
{
"name" : "argInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusArgInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusArgInfo.\n\t \n",
"line" : 643}
,
{
"name" : "annotationInfoUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(GDBusAnnotationInfo* info)",
"comment" : "\n If info is statically allocated, does nothing. Otherwise decreases\n the reference count of info. When its reference count drops to 0,\n the memory used is freed.\n Since 2.26\n Params:\n info = A GDBusAnnotationInfo.\n\t \n",
"line" : 657}
]
}
]
}
,
{
"name" : "gio.DesktopAppInfo",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DesktopAppInfo.d",
"members" : [
{
"name" : "DesktopAppInfo",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GDesktopAppInfo is an implementation of GAppInfo based on\n desktop files.\n Note that <gio\/gdesktopappinfo.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 86,
"base" : "ObjectG",
"interfaces" : [
"AppInfoIF"],
"members" : [
{
"name" : "gDesktopAppInfo",
"kind" : "variable",
"protection" : "protected",
"type" : "GDesktopAppInfo*",
"comment" : " the main Gtk struct \n",
"line" : 90}
,
{
"name" : "getDesktopAppInfoStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDesktopAppInfo*()",
"line" : 93}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 100}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DesktopAppInfo(GDesktopAppInfo* gDesktopAppInfo)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 108}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 126}
,
{
"name" : "createFromFilename",
"kind" : "function",
"protection" : "public",
"type" : "DesktopAppInfo(string filename)",
"line" : 135}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DesktopAppInfo(KeyFile keyFile)",
"comment" : "\n\t \n\n Creates a new GDesktopAppInfo.\n Since 2.18\n Params:\n keyFile = an opened GKeyFile\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 150}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DesktopAppInfo(string desktopId)",
"comment" : "\n Creates a new GDesktopAppInfo based on a desktop file id.\n A desktop file id is the basename of the desktop file, including the\n .desktop extension. GIO is looking for a desktop file with this name\n in the applications subdirectories of the XDG data\n directories (i.e. the directories specified in the\n XDG_DATA_HOME and XDG_DATA_DIRS environment\n variables). GIO also supports the prefix-to-subdirectory mapping that is\n described in the Menu Spec\n (i.e. a desktop id of kde-foo.desktop will match\n \/usr\/share\/applications\/kde\/foo.desktop).\n Params:\n desktopId = the desktop file id\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 176}
,
{
"name" : "getFilename",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n When info was created from a known filename, return it. In some\n situations such as the GDesktopAppInfo returned from\n g_desktop_app_info_new_from_keyfile(), this function will return NULL.\n Since 2.24\n Returns: The full path to the file for info, or NULL if not known.\n\t \n",
"line" : 194}
,
{
"name" : "getIsHidden",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n A desktop file is hidden if the Hidden key in it is\n set to True.\n Returns: TRUE if hidden, FALSE otherwise.\n\t \n",
"line" : 205}
,
{
"name" : "setDesktopEnv",
"kind" : "function",
"protection" : "public",
"type" : "void(string desktopEnv)",
"comment" : "\n Sets the name of the desktop that the application is running in.\n This is used by g_app_info_should_show() to evaluate the\n OnlyShowIn and NotShowIn\n desktop entry fields.\n The Desktop\n Params:\n desktopEnv = a string specifying what desktop this is\n\t \n",
"line" : 220}
,
{
"name" : "lookupGetDefaultForUriScheme",
"kind" : "function",
"protection" : "public",
"type" : "AppInfoIF(GDesktopAppInfoLookup* lookup, string uriScheme)",
"comment" : "\n Gets the default application for launching applications\n using this URI scheme for a particular GDesktopAppInfoLookup\n implementation.\n The GDesktopAppInfoLookup interface and this function is used\n to implement g_app_info_get_default_for_uri_scheme() backends\n in a GIO module. There is no reason for applications to use it\n directly. Applications should use g_app_info_get_default_for_uri_scheme().\n Params:\n lookup = a GDesktopAppInfoLookup\n uriScheme = a string containing a URI scheme.\n Returns: GAppInfo for given uri_scheme or NULL on error.\n\t \n",
"line" : 239}
]
}
]
}
,
{
"name" : "gio.Drive",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Drive.d",
"members" : [
{
"name" : "Drive",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"DriveIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Drive(GDrive* gDrive)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.DriveIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DriveIF.d",
"members" : [
{
"name" : "DriveIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GDrive - this represent a piece of hardware connected to the machine.\n It's generally only created for removable hardware or hardware with\n removable media.\n GDrive is a container class for GVolume objects that stem from\n the same piece of media. As such, GDrive abstracts a drive with\n (or without) removable media and provides operations for querying\n whether media is available, determing whether media change is\n automatically detected and ejecting the media.\n If the GDrive reports that media isn't automatically detected, one\n can poll for media; typically one should not do this periodically\n as a poll for media operation is potententially expensive and may\n spin up the drive creating noise.\n GDrive supports starting and stopping drives with authentication\n support for the former. This can be used to support a diverse set\n of use cases including connecting\/disconnecting iSCSI devices,\n powering down external disk enclosures and starting\/stopping\n multi-disk devices such as RAID devices. Note that the actual\n semantics and side-effects of starting\/stopping a GDrive may vary\n according to implementation. To choose the correct verbs in e.g. a\n file manager, use g_drive_get_start_stop_type().\n For porting from GnomeVFS note that there is no equivalent of\n GDrive in that API.\n \n",
"line" : 116,
"members" : [
{
"name" : "getDriveTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDrive*()",
"line" : 119}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 122}
,
{
"name" : "onChangedListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(DriveIF)[]()",
"comment" : "\n\t \n",
"line" : 128}
,
{
"name" : "addOnChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the drive's state has changed.\n\t \n",
"line" : 132}
,
{
"name" : "onDisconnectedListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(DriveIF)[]()",
"line" : 133}
,
{
"name" : "addOnDisconnected",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n This signal is emitted when the GDrive have been\n disconnected. If the recipient is holding references to the\n object they should release them so the object can be\n finalized.\n\t \n",
"line" : 140}
,
{
"name" : "onEjectButtonListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(DriveIF)[]()",
"line" : 141}
,
{
"name" : "addOnEjectButton",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the physical eject button (if any) of a drive has\n been pressed.\n\t \n",
"line" : 146}
,
{
"name" : "onStopButtonListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(DriveIF)[]()",
"line" : 147}
,
{
"name" : "addOnStopButton",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the physical stop button (if any) of a drive has\n been pressed.\n Since 2.22\n\t \n",
"line" : 153}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name of drive.\n Returns: a string containing drive's name. The returned string should be freed when no longer needed.\n\t \n",
"line" : 159}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gets the icon for drive.\n Returns: GIcon for the drive. Free the returned object with g_object_unref().\n\t \n",
"line" : 165}
,
{
"name" : "hasVolumes",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Check if drive has any mountable volumes.\n Returns: TRUE if the drive contains volumes, FALSE otherwise.\n\t \n",
"line" : 171}
,
{
"name" : "getVolumes",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Get a list of mountable volumes for drive.\n The returned list should be freed with g_list_free(), after\n its elements have been unreffed with g_object_unref().\n Returns: GList containing any GVolume objects on the given drive. [element-type GVolume][transfer full GVolume]\n\t \n",
"line" : 179}
,
{
"name" : "canEject",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a drive can be ejected.\n Returns: TRUE if the drive can be ejected, FALSE otherwise.\n\t \n",
"line" : 185}
,
{
"name" : "getStartStopType",
"kind" : "function",
"protection" : "public",
"type" : "GDriveStartStopType()",
"comment" : "\n Gets a hint about how a drive can be started\/stopped.\n Since 2.22\n Returns: A value from the GDriveStartStopType enumeration.\n\t \n",
"line" : 192}
,
{
"name" : "canStart",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a drive can be started.\n Since 2.22\n Returns: TRUE if the drive can be started, FALSE otherwise.\n\t \n",
"line" : 199}
,
{
"name" : "canStartDegraded",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a drive can be started degraded.\n Since 2.22\n Returns: TRUE if the drive can be started degraded, FALSE otherwise.\n\t \n",
"line" : 206}
,
{
"name" : "canStop",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a drive can be stopped.\n Since 2.22\n Returns: TRUE if the drive can be stopped, FALSE otherwise.\n\t \n",
"line" : 213}
,
{
"name" : "canPollForMedia",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a drive can be polled for media changes.\n Returns: TRUE if the drive can be polled for media changes, FALSE otherwise.\n\t \n",
"line" : 219}
,
{
"name" : "pollForMedia",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously polls drive to see if media has been inserted or removed.\n When the operation is finished, callback will be called.\n You can then call g_drive_poll_for_media_finish() to obtain the\n result of the operation.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 231}
,
{
"name" : "pollForMediaFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes an operation started with g_drive_poll_for_media() on a drive.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been poll_for_mediaed successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 240}
,
{
"name" : "hasMedia",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the drive has media. Note that the OS may not be polling\n the drive for media changes; see g_drive_is_media_check_automatic()\n for more details.\n Returns: TRUE if drive has media, FALSE otherwise.\n\t \n",
"line" : 248}
,
{
"name" : "isMediaCheckAutomatic",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if drive is capabable of automatically detecting media changes.\n Returns: TRUE if the drive is capabable of automatically detecting media changes, FALSE otherwise.\n\t \n",
"line" : 254}
,
{
"name" : "isMediaRemovable",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the drive supports removable media.\n Returns: TRUE if drive supports removable media, FALSE otherwise.\n\t \n",
"line" : 260}
,
{
"name" : "eject",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Warning\n g_drive_eject has been deprecated since version 2.22 and should not be used in newly-written code. Use g_drive_eject_with_operation() instead.\n Asynchronously ejects a drive.\n When the operation is finished, callback will be called.\n You can then call g_drive_eject_finish() to obtain the\n result of the operation.\n Params:\n flags = flags affecting the unmount if required for eject\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 275}
,
{
"name" : "ejectFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_drive_eject_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_drive_eject_with_operation_finish() instead.\n Finishes ejecting a drive.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been ejected successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 286}
,
{
"name" : "ejectWithOperation",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Ejects a drive. This is an asynchronous operation, and is\n finished by calling g_drive_eject_with_operation_finish() with the drive\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n flags = flags affecting the unmount if required for eject\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 300}
,
{
"name" : "ejectWithOperationFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes ejecting a drive. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 311}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "void(GDriveStartFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously starts a drive.\n When the operation is finished, callback will be called.\n You can then call g_drive_start_finish() to obtain the\n result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the start operation.\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 326}
,
{
"name" : "startFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes starting a drive.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been started successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 336}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously stops a drive.\n When the operation is finished, callback will be called.\n You can then call g_drive_stop_finish() to obtain the\n result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the unmount if required for stopping.\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 351}
,
{
"name" : "stopFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes stopping a drive.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been stopped successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 361}
,
{
"name" : "enumerateIdentifiers",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the kinds of identifiers that drive has.\n Use g_drive_get_identifer() to obtain the identifiers\n themselves.\n Returns: a NULL-terminated array of strings containing kinds of identifiers. Use g_strfreev() to free.\n\t \n",
"line" : 369}
,
{
"name" : "getIdentifier",
"kind" : "function",
"protection" : "public",
"type" : "string(string kind)",
"comment" : "\n Gets the identifier of the given kind for drive.\n Params:\n kind = the kind of identifier to return\n Returns: a newly allocated string containing the requested identfier, or NULL if the GDrive doesn't have this kind of identifier. Signal Details The \"changed\" signal void user_function (GDrive *drive, gpointer user_data) : Run Last Emitted when the drive's state has changed.\n\t \n",
"line" : 377}
]
}
]
}
,
{
"name" : "gio.DriveT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/DriveT.d",
"members" : [
{
"name" : "DriveT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GDrive - this represent a piece of hardware connected to the machine.\n It's generally only created for removable hardware or hardware with\n removable media.\n GDrive is a container class for GVolume objects that stem from\n the same piece of media. As such, GDrive abstracts a drive with\n (or without) removable media and provides operations for querying\n whether media is available, determing whether media change is\n automatically detected and ejecting the media.\n If the GDrive reports that media isn't automatically detected, one\n can poll for media; typically one should not do this periodically\n as a poll for media operation is potententially expensive and may\n spin up the drive creating noise.\n GDrive supports starting and stopping drives with authentication\n support for the former. This can be used to support a diverse set\n of use cases including connecting\/disconnecting iSCSI devices,\n powering down external disk enclosures and starting\/stopping\n multi-disk devices such as RAID devices. Note that the actual\n semantics and side-effects of starting\/stopping a GDrive may vary\n according to implementation. To choose the correct verbs in e.g. a\n file manager, use g_drive_get_start_stop_type().\n For porting from GnomeVFS note that there is no equivalent of\n GDrive in that API.\n \n",
"line" : 116,
"members" : [
{
"name" : "gDrive",
"kind" : "variable",
"type" : "GDrive*",
"comment" : " the main Gtk struct \n",
"line" : 120}
,
{
"name" : "getDriveTStruct",
"kind" : "function",
"type" : "GDrive*()",
"line" : 123}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 131}
,
{
"name" : "_onChangedListeners",
"kind" : "variable",
"type" : "void delegate(DriveIF)[]",
"line" : 133}
,
{
"name" : "onChangedListeners",
"kind" : "function",
"type" : "void delegate(DriveIF)[]()",
"line" : 134}
,
{
"name" : "addOnChanged",
"kind" : "function",
"type" : "void(void delegate(DriveIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n Emitted when the drive's state has changed.\n\t \n",
"line" : 141}
,
{
"name" : "callBackChanged",
"kind" : "function",
"type" : "extern (C) void(GDrive* driveStruct, DriveIF driveIF)",
"line" : 156}
,
{
"name" : "_onDisconnectedListeners",
"kind" : "variable",
"type" : "void delegate(DriveIF)[]",
"line" : 164}
,
{
"name" : "onDisconnectedListeners",
"kind" : "function",
"type" : "void delegate(DriveIF)[]()",
"line" : 165}
,
{
"name" : "addOnDisconnected",
"kind" : "function",
"type" : "void(void delegate(DriveIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n This signal is emitted when the GDrive have been\n disconnected. If the recipient is holding references to the\n object they should release them so the object can be\n finalized.\n\t \n",
"line" : 175}
,
{
"name" : "callBackDisconnected",
"kind" : "function",
"type" : "extern (C) void(GDrive* driveStruct, DriveIF driveIF)",
"line" : 190}
,
{
"name" : "_onEjectButtonListeners",
"kind" : "variable",
"type" : "void delegate(DriveIF)[]",
"line" : 198}
,
{
"name" : "onEjectButtonListeners",
"kind" : "function",
"type" : "void delegate(DriveIF)[]()",
"line" : 199}
,
{
"name" : "addOnEjectButton",
"kind" : "function",
"type" : "void(void delegate(DriveIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n Emitted when the physical eject button (if any) of a drive has\n been pressed.\n\t \n",
"line" : 207}
,
{
"name" : "callBackEjectButton",
"kind" : "function",
"type" : "extern (C) void(GDrive* driveStruct, DriveIF driveIF)",
"line" : 222}
,
{
"name" : "_onStopButtonListeners",
"kind" : "variable",
"type" : "void delegate(DriveIF)[]",
"line" : 230}
,
{
"name" : "onStopButtonListeners",
"kind" : "function",
"type" : "void delegate(DriveIF)[]()",
"line" : 231}
,
{
"name" : "addOnStopButton",
"kind" : "function",
"type" : "void(void delegate(DriveIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n Emitted when the physical stop button (if any) of a drive has\n been pressed.\n Since 2.22\n\t \n",
"line" : 240}
,
{
"name" : "callBackStopButton",
"kind" : "function",
"type" : "extern (C) void(GDrive* driveStruct, DriveIF driveIF)",
"line" : 255}
,
{
"name" : "getName",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the name of drive.\n Returns: a string containing drive's name. The returned string should be freed when no longer needed.\n\t \n",
"line" : 268}
,
{
"name" : "getIcon",
"kind" : "function",
"type" : "IconIF()",
"comment" : "\n Gets the icon for drive.\n Returns: GIcon for the drive. Free the returned object with g_object_unref().\n\t \n",
"line" : 278}
,
{
"name" : "hasVolumes",
"kind" : "function",
"type" : "int()",
"comment" : "\n Check if drive has any mountable volumes.\n Returns: TRUE if the drive contains volumes, FALSE otherwise.\n\t \n",
"line" : 293}
,
{
"name" : "getVolumes",
"kind" : "function",
"type" : "ListG()",
"comment" : "\n Get a list of mountable volumes for drive.\n The returned list should be freed with g_list_free(), after\n its elements have been unreffed with g_object_unref().\n Returns: GList containing any GVolume objects on the given drive. [element-type GVolume][transfer full GVolume]\n\t \n",
"line" : 305}
,
{
"name" : "canEject",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a drive can be ejected.\n Returns: TRUE if the drive can be ejected, FALSE otherwise.\n\t \n",
"line" : 320}
,
{
"name" : "getStartStopType",
"kind" : "function",
"type" : "GDriveStartStopType()",
"comment" : "\n Gets a hint about how a drive can be started\/stopped.\n Since 2.22\n Returns: A value from the GDriveStartStopType enumeration.\n\t \n",
"line" : 331}
,
{
"name" : "canStart",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a drive can be started.\n Since 2.22\n Returns: TRUE if the drive can be started, FALSE otherwise.\n\t \n",
"line" : 342}
,
{
"name" : "canStartDegraded",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a drive can be started degraded.\n Since 2.22\n Returns: TRUE if the drive can be started degraded, FALSE otherwise.\n\t \n",
"line" : 353}
,
{
"name" : "canStop",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a drive can be stopped.\n Since 2.22\n Returns: TRUE if the drive can be stopped, FALSE otherwise.\n\t \n",
"line" : 364}
,
{
"name" : "canPollForMedia",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a drive can be polled for media changes.\n Returns: TRUE if the drive can be polled for media changes, FALSE otherwise.\n\t \n",
"line" : 374}
,
{
"name" : "pollForMedia",
"kind" : "function",
"type" : "void(Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Asynchronously polls drive to see if media has been inserted or removed.\n When the operation is finished, callback will be called.\n You can then call g_drive_poll_for_media_finish() to obtain the\n result of the operation.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 390}
,
{
"name" : "pollForMediaFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes an operation started with g_drive_poll_for_media() on a drive.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been poll_for_mediaed successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 403}
,
{
"name" : "hasMedia",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if the drive has media. Note that the OS may not be polling\n the drive for media changes; see g_drive_is_media_check_automatic()\n for more details.\n Returns: TRUE if drive has media, FALSE otherwise.\n\t \n",
"line" : 424}
,
{
"name" : "isMediaCheckAutomatic",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if drive is capabable of automatically detecting media changes.\n Returns: TRUE if the drive is capabable of automatically detecting media changes, FALSE otherwise.\n\t \n",
"line" : 434}
,
{
"name" : "isMediaRemovable",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if the drive supports removable media.\n Returns: TRUE if drive supports removable media, FALSE otherwise.\n\t \n",
"line" : 444}
,
{
"name" : "eject",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Warning\n g_drive_eject has been deprecated since version 2.22 and should not be used in newly-written code. Use g_drive_eject_with_operation() instead.\n Asynchronously ejects a drive.\n When the operation is finished, callback will be called.\n You can then call g_drive_eject_finish() to obtain the\n result of the operation.\n Params:\n flags = flags affecting the unmount if required for eject\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 463}
,
{
"name" : "ejectFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_drive_eject_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_drive_eject_with_operation_finish() instead.\n Finishes ejecting a drive.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been ejected successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 478}
,
{
"name" : "ejectWithOperation",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Ejects a drive. This is an asynchronous operation, and is\n finished by calling g_drive_eject_with_operation_finish() with the drive\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n flags = flags affecting the unmount if required for eject\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 505}
,
{
"name" : "ejectWithOperationFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes ejecting a drive. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 520}
,
{
"name" : "start",
"kind" : "function",
"type" : "void(GDriveStartFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Asynchronously starts a drive.\n When the operation is finished, callback will be called.\n You can then call g_drive_start_finish() to obtain the\n result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the start operation.\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 548}
,
{
"name" : "startFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes starting a drive.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been started successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 562}
,
{
"name" : "stop",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Asynchronously stops a drive.\n When the operation is finished, callback will be called.\n You can then call g_drive_stop_finish() to obtain the\n result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the unmount if required for stopping.\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data to pass to callback\n\t \n",
"line" : 590}
,
{
"name" : "stopFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes stopping a drive.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the drive has been stopped successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 604}
,
{
"name" : "enumerateIdentifiers",
"kind" : "function",
"type" : "string[]()",
"comment" : "\n Gets the kinds of identifiers that drive has.\n Use g_drive_get_identifer() to obtain the identifiers\n themselves.\n Returns: a NULL-terminated array of strings containing kinds of identifiers. Use g_strfreev() to free.\n\t \n",
"line" : 625}
,
{
"name" : "getIdentifier",
"kind" : "function",
"type" : "string(string kind)",
"comment" : "\n Gets the identifier of the given kind for drive.\n Params:\n kind = the kind of identifier to return\n Returns: a newly allocated string containing the requested identfier, or NULL if the GDrive doesn't have this kind of identifier. Signal Details The \"changed\" signal void user_function (GDrive *drive, gpointer user_data) : Run Last Emitted when the drive's state has changed.\n\t \n",
"line" : 637}
]
}
]
}
,
{
"name" : "gio.Emblem",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Emblem.d",
"members" : [
{
"name" : "Emblem",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GEmblem is an implementation of GIcon that supports\n having an emblem, which is an icon with additional properties.\n It can than be added to a GEmblemedIcon.\n Currently, only metainformation about the emblem's origin is\n supported. More may be added in the future.\n \n",
"line" : 80,
"base" : "ObjectG",
"interfaces" : [
"IconIF"],
"members" : [
{
"name" : "gEmblem",
"kind" : "variable",
"protection" : "protected",
"type" : "GEmblem*",
"comment" : " the main Gtk struct \n",
"line" : 84}
,
{
"name" : "getEmblemStruct",
"kind" : "function",
"protection" : "public",
"type" : "GEmblem*()",
"line" : 87}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 94}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Emblem(GEmblem* gEmblem)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 102}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 120}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Emblem(IconIF icon)",
"comment" : "\n\t \n\n Creates a new emblem for icon.\n Since 2.18\n Params:\n icon = a GIcon containing the icon.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 139}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Emblem(IconIF icon, GEmblemOrigin origin)",
"comment" : "\n Creates a new emblem for icon.\n Since 2.18\n Params:\n icon = a GIcon containing the icon.\n origin = a GEmblemOrigin enum defining the emblem's origin\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 158}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gives back the icon from emblem.\n Since 2.18\n Returns: a GIcon. The returned object belongs to the emblem and should not be modified or freed.\n\t \n",
"line" : 174}
,
{
"name" : "getOrigin",
"kind" : "function",
"protection" : "public",
"type" : "GEmblemOrigin()",
"comment" : "\n Gets the origin of the emblem.\n Since 2.18\n Returns: the origin of the emblem\n\t \n",
"line" : 190}
]
}
]
}
,
{
"name" : "gio.EmblemedIcon",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/EmblemedIcon.d",
"members" : [
{
"name" : "EmblemedIcon",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GEmblemedIcon is an implementation of GIcon that supports\n adding an emblem to an icon. Adding multiple emblems to an\n icon is ensured via g_emblemed_icon_add_emblem().\n Note that GEmblemedIcon allows no control over the position\n of the emblems. See also GEmblem for more information.\n \n",
"line" : 86,
"base" : "ObjectG",
"interfaces" : [
"IconIF"],
"members" : [
{
"name" : "gEmblemedIcon",
"kind" : "variable",
"protection" : "protected",
"type" : "GEmblemedIcon*",
"comment" : " the main Gtk struct \n",
"line" : 90}
,
{
"name" : "getEmblemedIconStruct",
"kind" : "function",
"protection" : "public",
"type" : "GEmblemedIcon*()",
"line" : 93}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 100}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "EmblemedIcon(GEmblemedIcon* gEmblemedIcon)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 108}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 126}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "EmblemedIcon(IconIF icon, Emblem emblem)",
"comment" : "\n\t \n\n Creates a new emblemed icon for icon with the emblem emblem.\n Since 2.18\n Params:\n icon = a GIcon\n emblem = a GEmblem\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 146}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gets the main icon for emblemed.\n Since 2.18\n Returns: a GIcon that is owned by emblemed\n\t \n",
"line" : 162}
,
{
"name" : "getEmblems",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets the list of emblems for the icon.\n Since 2.18\n Returns: a GList of GEmblem s that is owned by emblemed\n\t \n",
"line" : 178}
,
{
"name" : "addEmblem",
"kind" : "function",
"protection" : "public",
"type" : "void(Emblem emblem)",
"comment" : "\n Adds emblem to the GList of GEmblem s.\n Since 2.18\n Params:\n emblem = a GEmblem\n\t \n",
"line" : 195}
]
}
]
}
,
{
"name" : "gio.ErrorGIO",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ErrorGIO.d",
"members" : [
{
"name" : "ErrorGIO",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Contains helper functions for reporting errors to the user.\n \n",
"line" : 68,
"base" : "Object",
"members" : [
{
"name" : "fromErrno",
"kind" : "function",
"protection" : "public",
"type" : "GIOErrorEnum(int errNo)",
"comment" : "\n\t \n\n Converts errno.h error codes into GIO error codes.\n Params:\n errNo = Error number as defined in errno.h.\n Returns: GIOErrorEnum value for the given errno.h error number.\n\t \n",
"line" : 79}
,
{
"name" : "fromWin32_Error",
"kind" : "function",
"protection" : "public",
"type" : "GIOErrorEnum(int errorCode)",
"comment" : "\n Converts some common error codes into GIO error codes. The\n fallback value G_IO_ERROR_FAILED is returned for error codes not\n handled.\n Since 2.26\n Params:\n errorCode = Windows error number.\n Returns: GIOErrorEnum value for the given error number.\n\t \n",
"line" : 94}
]
}
]
}
,
{
"name" : "gio.FileAttributeInfoList",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileAttributeInfoList.d",
"members" : [
{
"name" : "FileAttributeInfoList",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n File attributes in GIO consist of a list of key-value pairs.\n Keys are strings that contain a key namespace and a key name, separated\n by a colon, e.g. \"namespace:keyname\". Namespaces are included to sort\n key-value pairs by namespaces for relevance. Keys can be retrived\n using wildcards, e.g. \"standard::*\" will return all of the keys in the\n \"standard\" namespace.\n Values are stored within the list in GFileAttributeValue structures.\n Values can store different types, listed in the enum GFileAttributeType.\n Upon creation of a GFileAttributeValue, the type will be set to\n G_FILE_ATTRIBUTE_TYPE_INVALID.\n The list of possible attributes for a filesystem (pointed to by a GFile) is\n availible as a GFileAttributeInfoList. This list is queryable by key names\n as indicated earlier.\n Classes that implement GFileIface will create a GFileAttributeInfoList and\n install default keys and values for their given file system, architecture,\n and other possible implementation details (e.g., on a UNIX system, a file\n attribute key will be registered for the user id for a given file).\n Table  1.  GFileAttributes Default Namespaces\n Namspace\n Description\n \"standard\"\n The \"Standard\" namespace. General file\n information that any application may need should be put in this namespace.\n Examples include the file's name, type, and size.\n \"etag\"\n The \"Entity Tag\"\n namespace. Currently, the only key in this namespace is \"value\", which contains\n the value of the current entity tag.\n \"id\"\n The \"Identification\" namespace. This\n namespace is used by file managers and applications that list directories\n to check for loops and to uniquely identify files.\n \"access\"\n The \"Access\" namespace. Used to check\n if a user has the proper privilidges to access files and perform\n file operations. Keys in this namespace are made to be generic\n and easily understood, e.g. the \"can_read\" key is TRUE if\n the current user has permission to read the file. UNIX permissions and\n NTFS ACLs in Windows should be mapped to these values.\n \"mountable\"\n The \"Mountable\" namespace. Includes\n simple boolean keys for checking if a file or path supports mount operations, e.g.\n mount, unmount, eject. These are used for files of type G_FILE_TYPE_MOUNTABLE.\n \"time\"\n The \"Time\" namespace. Includes file\n access, changed, created times.\n \"unix\"\n The \"Unix\" namespace. Includes UNIX-specific\n information and may not be available for all files. Examples include\n the UNIX \"UID\", \"GID\", etc.\n \"dos\"\n The \"DOS\" namespace. Includes DOS-specific\n information and may not be available for all files. Examples include\n \"is_system\" for checking if a file is marked as a system file, and \"is_archive\"\n for checking if a file is marked as an archive file.\n \"owner\"\n The \"Owner\" namespace. Includes information\n about who owns a file. May not be available for all file systems. Examples include\n \"user\" for getting the user name of the file owner. This information is often mapped from\n some backend specific data such as a unix UID.\n \"thumbnail\"\n The \"Thumbnail\" namespace. Includes\n information about file thumbnails and their location within the file system. Exaples of\n keys in this namespace include \"path\" to get the location of a thumbnail, and \"failed\"\n to check if thumbnailing of the file failed.\n \"filesystem\"\n The \"Filesystem\" namespace. Gets information\n about the file system where a file is located, such as its type, how much\n space is left available, and the overall size of the file system.\n \"gvfs\"\n The \"GVFS\" namespace. Keys in this namespace\n contain information about the current GVFS backend in use.\n \"xattr\"\n The \"xattr\" namespace. Gets information\n about extended user attributes. See attr(5). The \"user.\" prefix of the\n extended user attribute name is stripped away when constructing keys in\n this namespace, e.g. \"xattr::mime_type\" for the extended attribute with\n the name \"user.mime_type\". Note that this information is only available\n if GLib has been built with extended attribute support.\n \"xattr-sys\"\n The \"xattr-sys\" namespace.\n Gets information about extended attributes which are not user-specific.\n See attr(5). Note that this information is only available if GLib\n has been built with extended attribute support.\n \"selinux\"\n The \"SELinux\" namespace. Includes\n information about the SELinux context of files. Note that this information\n is only available if GLib has been built with SELinux support.\n Please note that these are not all of the possible namespaces.\n More namespaces can be added from GIO modules or by individual applications.\n For more information about writing GIO modules, see GIOModule.\n Table  2.  GFileAttributes Built-in Keys and Value Types\n Enum Value\n Namespace:Key\n Value Type\n G_FILE_ATTRIBUTE_STANDARD_TYPE\n standard::type\n uint32 (GFileType)\n G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN\n standard::is-hidden\n boolean\n G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP\n standard::is-backup\n boolean\n G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK\n standard::is-symlink\n boolean\n G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL\n standard::is-virtual\n boolean\n G_FILE_ATTRIBUTE_STANDARD_NAME\n standard::name\n byte string\n G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME\n standard::display-name\n string\n G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME\n standard::edit-name\n string\n G_FILE_ATTRIBUTE_STANDARD_ICON\n standard::icon\n object (GIcon)\n G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE\n standard::content-type\n string\n G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE\n standard::fast-content-type\n string\n G_FILE_ATTRIBUTE_STANDARD_SIZE\n standard::size\n uint64\n G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE\n standard::allocated-size\n uint64\n G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET\n standard::symlink-target\n byte string\n G_FILE_ATTRIBUTE_STANDARD_TARGET_URI\n standard::target-uri\n string\n G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER\n standard::sort-order\n int32\n G_FILE_ATTRIBUTE_ETAG_VALUE\n etag::value\n string\n G_FILE_ATTRIBUTE_ID_FILE\n id::file\n string\n G_FILE_ATTRIBUTE_ID_FILESYSTEM\n id::filesystem\n string\n G_FILE_ATTRIBUTE_ACCESS_CAN_READ\n access::can-read\n boolean\n G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE\n access::can-write\n boolean\n G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE\n access::can-execute\n boolean\n G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE\n access::can-delete\n boolean\n G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH\n access::can-trash\n boolean\n G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME\n access::can-rename\n boolean\n G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT\n mountable::can-mount\n boolean\n G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT\n mountable::can-unmount\n boolean\n G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT\n mountable::can-eject\n boolean\n G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE\n mountable::unix-device\n uint32\n G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE\n mountable::unix-device-file\n string\n G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI\n mountable::hal-udi\n string\n G_FILE_ATTRIBUTE_TIME_MODIFIED\n time::modified\n uint64\n G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC\n time::modified-usec\n uint32\n G_FILE_ATTRIBUTE_TIME_ACCESS\n time::access\n uint64\n G_FILE_ATTRIBUTE_TIME_ACCESS_USEC\n time::access-usec\n uint32\n G_FILE_ATTRIBUTE_TIME_CHANGED\n time::changed\n uint64\n G_FILE_ATTRIBUTE_TIME_CHANGED_USEC\n time::changed-usec\n uint32\n G_FILE_ATTRIBUTE_TIME_CREATED\n time::created\n uint64\n G_FILE_ATTRIBUTE_TIME_CREATED_USEC\n time::created-usec\n uint32\n G_FILE_ATTRIBUTE_UNIX_DEVICE\n unix::device\n uint32\n G_FILE_ATTRIBUTE_UNIX_INODE\n unix::inode\n uint64\n G_FILE_ATTRIBUTE_UNIX_MODE\n unix::mode\n uint32\n G_FILE_ATTRIBUTE_UNIX_NLINK\n unix::nlink\n uint32\n G_FILE_ATTRIBUTE_UNIX_UID\n unix::uid\n uint32\n G_FILE_ATTRIBUTE_UNIX_GID\n unix::gid\n uint32\n G_FILE_ATTRIBUTE_UNIX_RDEV\n unix::rdev\n uint32\n G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE\n unix::block-size\n uint32\n G_FILE_ATTRIBUTE_UNIX_BLOCKS\n unix::blocks\n uint64\n G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT\n unix::is-mountpoint\n boolean\n G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE\n dos::is-archive\n boolean\n G_FILE_ATTRIBUTE_DOS_IS_SYSTEM\n dos::is-system\n boolean\n G_FILE_ATTRIBUTE_OWNER_USER\n owner::user\n string\n G_FILE_ATTRIBUTE_OWNER_USER_REAL\n owner::user-real\n string\n G_FILE_ATTRIBUTE_OWNER_GROUP\n owner::group\n string\n G_FILE_ATTRIBUTE_THUMBNAIL_PATH\n thumbnail::path\n bytestring\n G_FILE_ATTRIBUTE_THUMBNAILING_FAILED\n thumbnail::failed\n boolean\n G_FILE_ATTRIBUTE_PREVIEW_ICON\n preview::icon\n object (GIcon)\n G_FILE_ATTRIBUTE_FILESYSTEM_SIZE\n filesystem::size\n uint64\n G_FILE_ATTRIBUTE_FILESYSTEM_FREE\n filesystem::free\n uint64\n G_FILE_ATTRIBUTE_FILESYSTEM_TYPE\n filesystem::type\n string\n G_FILE_ATTRIBUTE_FILESYSTEM_READONLY\n filesystem::readonly\n boolean\n G_FILE_ATTRIBUTE_GVFS_BACKEND\n gvfs::backend\n string\n G_FILE_ATTRIBUTE_SELINUX_CONTEXT\n selinux::context\n string\n Note that there are no predefined keys in the \"xattr\" and \"xattr-sys\"\n namespaces. Keys for the \"xattr\" namespace are constructed by stripping\n away the \"user.\" prefix from the extended user attribute, and prepending\n \"xattr::\". Keys for the \"xattr-sys\" namespace are constructed by\n concatenating \"xattr-sys::\" with the extended attribute name. All extended\n attribute values are returned as hex-encoded strings in which bytes outside\n the ASCII range are encoded as hexadecimal escape sequences of the form\n \\xnn.\n \n",
"line" : 362,
"base" : "Object",
"members" : [
{
"name" : "gFileAttributeInfoList",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileAttributeInfoList*",
"comment" : " the main Gtk struct \n",
"line" : 365}
,
{
"name" : "getFileAttributeInfoListStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileAttributeInfoList*()",
"line" : 368}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 375}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileAttributeInfoList(GFileAttributeInfoList* gFileAttributeInfoList)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 383}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileAttributeInfoList()",
"comment" : "\n\t \n\n Creates a new file attribute info list.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 400}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "FileAttributeInfoList()",
"comment" : "\n References a file attribute info list.\n Returns: GFileAttributeInfoList or NULL on error.\n\t \n",
"line" : 415}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes a reference from the given list. If the reference count\n falls to zero, the list is deleted.\n\t \n",
"line" : 430}
,
{
"name" : "dup",
"kind" : "function",
"protection" : "public",
"type" : "FileAttributeInfoList()",
"comment" : "\n Makes a duplicate of a file attribute info list.\n Returns: a copy of the given list.\n\t \n",
"line" : 440}
,
{
"name" : "lookup",
"kind" : "function",
"protection" : "public",
"type" : "GFileAttributeInfo*(string name)",
"comment" : "\n Gets the file attribute with the name name from list.\n Params:\n name = the name of the attribute to lookup.\n Returns: a GFileAttributeInfo for the name, or NULL if an attribute isn't found.\n\t \n",
"line" : 457}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "void(string name, GFileAttributeType type, GFileAttributeInfoFlags flags)",
"comment" : "\n Adds a new attribute with name to the list, setting\n its type and flags.\n Params:\n name = the name of the attribute to add.\n type = the GFileAttributeType for the attribute.\n flags = GFileAttributeInfoFlags for the attribute.\n\t \n",
"line" : 471}
]
}
]
}
,
{
"name" : "gio.FileAttributeMatcher",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileAttributeMatcher.d",
"members" : [
{
"name" : "FileAttributeMatcher",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Functionality for manipulating basic metadata for files. GFileInfo\n implements methods for getting information that all files should\n contain, and allows for manipulation of extended attributes.\n See GFileAttribute for more\n information on how GIO handles file attributes.\n To obtain a GFileInfo for a GFile, use g_file_query_info() (or its\n async variant). To obtain a GFileInfo for a file input or output\n stream, use g_file_input_stream_query_info() or\n g_file_output_stream_query_info() (or their async variants).\n To change the actual attributes of a file, you should then set the\n attribute in the GFileInfo and call g_file_set_attributes_from_info()\n or g_file_set_attributes_async() on a GFile.\n However, not all attributes can be changed in the file. For instance,\n the actual size of a file cannot be changed via g_file_info_set_size().\n You may call g_file_query_settable_attributes() and\n g_file_query_writable_namespaces() to discover the settable attributes\n of a particular file at runtime.\n GFileAttributeMatcher allows for searching through a GFileInfo for\n attributes.\n \n",
"line" : 89,
"base" : "Object",
"members" : [
{
"name" : "gFileAttributeMatcher",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileAttributeMatcher*",
"comment" : " the main Gtk struct \n",
"line" : 92}
,
{
"name" : "getFileAttributeMatcherStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileAttributeMatcher*()",
"line" : 95}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 102}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileAttributeMatcher(GFileAttributeMatcher* gFileAttributeMatcher)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 110}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileAttributeMatcher(string attributes)",
"comment" : "\n\t \n\n Creates a new file attribute matcher, which matches attributes\n against a given string. GFileAttributeMatchers are reference\n counted structures, and are created with a reference count of 1. If\n the number of references falls to 0, the GFileAttributeMatcher is\n automatically destroyed.\n The attribute string should be formatted with specific keys separated\n from namespaces with a double colon. Several \"namespace::key\" strings may be\n concatenated with a single comma (e.g. \"standard::type,standard::is-hidden\").\n The wildcard \"*\" may be used to match all keys and namespaces, or\n \"namespace::*\" will match all keys in a given namespace.\n Params:\n attributes = an attribute string to match.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 138}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "FileAttributeMatcher()",
"comment" : "\n References a file attribute matcher.\n Returns: a GFileAttributeMatcher.\n\t \n",
"line" : 153}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Unreferences matcher. If the reference count falls below 1,\n the matcher is automatically freed.\n\t \n",
"line" : 168}
,
{
"name" : "matches",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute)",
"comment" : "\n Checks if an attribute will be matched by an attribute matcher. If\n the matcher was created with the \"*\" matching string, this function\n will always return TRUE.\n Params:\n attribute = a file attribute key.\n Returns: TRUE if attribute matches matcher. FALSE otherwise.\n\t \n",
"line" : 182}
,
{
"name" : "matchesOnly",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute)",
"comment" : "\n Checks if a attribute matcher only matches a given attribute. Always\n returns FALSE if \"*\" was used when creating the matcher.\n Params:\n attribute = a file attribute key.\n Returns: TRUE if the matcher only matches attribute. FALSE otherwise.\n\t \n",
"line" : 195}
,
{
"name" : "enumerateNamespace",
"kind" : "function",
"protection" : "public",
"type" : "int(string ns)",
"comment" : "\n Checks if the matcher will match all of the keys in a given namespace.\n This will always return TRUE if a wildcard character is in use (e.g. if\n matcher was created with \"standard::*\" and ns is \"standard\", or if matcher was created\n using \"*\" and namespace is anything.)\n TODO: this is awkwardly worded.\n Params:\n ns = a string containing a file attribute namespace.\n Returns: TRUE if the matcher matches all of the entries in the given ns, FALSE otherwise.\n\t \n",
"line" : 211}
,
{
"name" : "enumerateNext",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the next matched attribute from a GFileAttributeMatcher.\n Returns: a string containing the next attribute or NULL if no more attribute exist.\n\t \n",
"line" : 221}
]
}
]
}
,
{
"name" : "gio.File",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/File.d",
"members" : [
{
"name" : "File",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GFile is a high level abstraction for manipulating files on a\n virtual file system. GFiles are lightweight, immutable\n objects that do no I\/O upon creation. It is necessary to understand that\n GFile objects do not represent files, merely an identifier for a file. All\n file content I\/O is implemented as streaming operations (see GInputStream and\n GOutputStream).\n To construct a GFile, you can use:\n g_file_new_for_path() if you have a path.\n g_file_new_for_uri() if you have a URI.\n g_file_new_for_commandline_arg() for a command line argument.\n g_file_parse_name() from a utf8 string gotten from g_file_get_parse_name().\n One way to think of a GFile is as an abstraction of a pathname. For normal\n files the system pathname is what is stored internally, but as GFiles\n are extensible it could also be something else that corresponds to a pathname\n in a userspace implementation of a filesystem.\n GFiles make up hierarchies of directories and files that correspond to the\n files on a filesystem. You can move through the file system with GFile using\n g_file_get_parent() to get an identifier for the parent directory, g_file_get_child()\n to get a child within a directory, g_file_resolve_relative_path() to resolve a relative\n path between two GFiles. There can be multiple hierarchies, so you may not\n end up at the same root if you repeatedly call g_file_get_parent() on two different\n files.\n All GFiles have a basename (get with g_file_get_basename()). These names\n are byte strings that are used to identify the file on the filesystem (relative to\n its parent directory) and there is no guarantees that they have any particular charset\n encoding or even make any sense at all. If you want to use filenames in a user\n interface you should use the display name that you can get by requesting the\n G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().\n This is guaranteed to be in utf8 and can be used in a user interface. But always\n store the real basename or the GFile to use to actually access the file, because\n there is no way to go from a display name to the actual name.\n Using GFile as an identifier has the same weaknesses as using a path in that\n there may be multiple aliases for the same file. For instance, hard or\n soft links may cause two different GFiles to refer to the same file.\n Other possible causes for aliases are: case insensitive filesystems, short\n and long names on Fat\/NTFS, or bind mounts in Linux. If you want to check if\n two GFiles point to the same file you can query for the\n G_FILE_ATTRIBUTE_ID_FILE attribute. Note that GFile does some trivial\n canonicalization of pathnames passed in, so that trivial differences in the\n path string used at creation (duplicated slashes, slash at end of path, \".\"\n or \"..\" path segments, etc) does not create different GFiles.\n Many GFile operations have both synchronous and asynchronous versions\n to suit your application. Asynchronous versions of synchronous functions\n simply have _async() appended to their function names. The asynchronous\n I\/O functions call a GAsyncReadyCallback which is then used to finalize\n the operation, producing a GAsyncResult which is then passed to the\n function's matching _finish() operation.\n Some GFile operations do not have synchronous analogs, as they may\n take a very long time to finish, and blocking may leave an application\n unusable. Notable cases include:\n g_file_mount_mountable() to mount a mountable file.\n g_file_unmount_mountable_with_operation() to unmount a mountable file.\n g_file_eject_mountable_with_operation() to eject a mountable file.\n One notable feature of GFiles are entity tags, or \"etags\" for\n short. Entity tags are somewhat like a more abstract version of the\n traditional mtime, and can be used to quickly determine if the file has\n been modified from the version on the file system. See the HTTP 1.1\n specification\n for HTTP Etag headers, which are a very similar concept.\n \n",
"line" : 175,
"base" : "ObjectG",
"members" : [
{
"name" : "gFile",
"kind" : "variable",
"protection" : "protected",
"type" : "GFile*",
"comment" : " the main Gtk struct \n",
"line" : 179}
,
{
"name" : "getFileStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFile*()",
"line" : 182}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 189}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "File(GFile* gFile)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 197}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 215}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "File(string arg)",
"comment" : "\n\t \n\n Creates a GFile with the given argument from the command line. The value of\n arg can be either a URI, an absolute path or a relative path resolved\n relative to the current working directory.\n This operation never fails, but the returned object might not support any\n I\/O operation if arg points to a malformed path.\n Params:\n arg = a command line string.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 234}
,
{
"name" : "parseName",
"kind" : "function",
"protection" : "public",
"type" : "File(string parseName)",
"comment" : "\n Constructs a GFile with the given parse_name (i.e. something given by g_file_get_parse_name()).\n This operation never fails, but the returned object might not support any I\/O\n operation if the parse_name cannot be parsed.\n Params:\n parseName = a file name or path to be parsed.\n Returns: a new GFile.\n\t \n",
"line" : 253}
,
{
"name" : "dup",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Duplicates a GFile handle. This operation does not duplicate\n the actual file or directory represented by the GFile; see\n g_file_copy() if attempting to copy a file.\n This call does no blocking i\/o.\n Returns: a new GFile that is a duplicate of the given GFile.\n\t \n",
"line" : 271}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* file)",
"comment" : "\n Creates a hash value for a GFile.\n This call does no blocking i\/o.\n Params:\n file = gconstpointer to a GFile.\n Returns: 0 if file is not a valid GFile, otherwise an integer that can be used as hash value for the GFile. This function is intended for easily hashing a GFile to add to a GHashTable or similar data structure.\n\t \n",
"line" : 289}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(File file2)",
"comment" : "\n Checks equality of two given GFiles. Note that two\n GFiles that differ can still refer to the same\n file on the filesystem due to various forms of filename\n aliasing.\n This call does no blocking i\/o.\n Params:\n file2 = the second GFile.\n Returns: TRUE if file1 and file2 are equal. FALSE if either is not a GFile.\n\t \n",
"line" : 305}
,
{
"name" : "getBasename",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the base name (the last component of the path) for a given GFile.\n If called for the top level of a system (such as the filesystem root\n or a uri like sftp:\/\/host\/) it will return a single directory separator\n (and on Windows, possibly a drive letter).\n The base name is a byte string (*not* UTF-8). It has no defined encoding\n or rules other than it may not contain zero bytes. If you want to use\n filenames in a user interface you should use the display name that you\n can get by requesting the G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME\n attribute with g_file_query_info().\n This call does no blocking i\/o.\n Returns: string containing the GFile's base name, or NULL if given GFile is invalid. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 324}
,
{
"name" : "getPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the local pathname for GFile, if one exists.\n This call does no blocking i\/o.\n Returns: string containing the GFile's path, or NULL if no such path exists. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 335}
,
{
"name" : "getUri",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the URI for the file.\n This call does no blocking i\/o.\n Returns: a string containing the GFile's URI. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 346}
,
{
"name" : "getParseName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the parse name of the file.\n A parse name is a UTF-8 string that describes the\n file such that one can get the GFile back using\n g_file_parse_name().\n This is generally used to show the GFile as a nice\n full-pathname kind of string in a user interface,\n like in a location entry.\n For local files with names that can safely be converted\n to UTF8 the pathname is used, otherwise the IRI is used\n (a form of URI that allows UTF8 characters unescaped).\n This call does no blocking i\/o.\n Returns: a string containing the GFile's parse name. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 366}
,
{
"name" : "getParent",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Gets the parent directory for the file.\n If the file represents the root directory of the\n file system, then NULL will be returned.\n This call does no blocking i\/o.\n Returns: a GFile structure to the parent of the given GFile or NULL if there is no parent. Free the returned object with g_object_unref().\n\t \n",
"line" : 379}
,
{
"name" : "hasParent",
"kind" : "function",
"protection" : "public",
"type" : "int(File parent)",
"comment" : "\n Checks if file has a parent, and optionally, if it is parent.\n If parent is NULL then this function returns TRUE if file has any\n parent at all. If parent is non-NULL then TRUE is only returned\n if file is a child of parent.\n Since 2.24\n Params:\n parent = the parent to check for, or NULL\n Returns: TRUE if file is a child of parent (or any parent in the case that parent is NULL).\n\t \n",
"line" : 400}
,
{
"name" : "getChild",
"kind" : "function",
"protection" : "public",
"type" : "File(string name)",
"comment" : "\n Gets a child of file with basename equal to name.\n Note that the file with that specific name might not exist, but\n you can still have a GFile that points to it. You can use this\n for instance to create that file.\n This call does no blocking i\/o.\n Params:\n name = string containing the child's basename.\n Returns: a GFile to a child specified by name. Free the returned object with g_object_unref().\n\t \n",
"line" : 416}
,
{
"name" : "getChildForDisplayName",
"kind" : "function",
"protection" : "public",
"type" : "File(string displayName)",
"comment" : "\n Gets the child of file for a given display_name (i.e. a UTF8\n version of the name). If this function fails, it returns NULL and error will be\n set. This is very useful when constructing a GFile for a new file\n and the user entered the filename in the user interface, for instance\n when you select a directory and type a filename in the file selector.\n This call does no blocking i\/o.\n Params:\n displayName = string to a possible child.\n Returns: a GFile to the specified child, or NULL if the display name couldn't be converted. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 439}
,
{
"name" : "hasPrefix",
"kind" : "function",
"protection" : "public",
"type" : "int(File prefix)",
"comment" : "\n Checks whether file has the prefix specified by prefix. In other word,\n if the names of inital elements of files pathname match prefix.\n Only full pathname elements are matched, so a path like \/foo is not\n considered a prefix of \/foobar, only of \/foo\/bar.\n This call does no i\/o, as it works purely on names. As such it can\n sometimes return FALSE even if file is inside a prefix (from a\n filesystem point of view), because the prefix of file is an alias\n of prefix.\n Params:\n prefix = input GFile.\n Returns: TRUE if the files's parent, grandparent, etc is prefix. FALSE otherwise.\n\t \n",
"line" : 471}
,
{
"name" : "getRelativePath",
"kind" : "function",
"protection" : "public",
"type" : "string(File descendant)",
"comment" : "\n Gets the path for descendant relative to parent.\n This call does no blocking i\/o.\n Params:\n descendant = input GFile.\n Returns: string with the relative path from descendant to parent, or NULL if descendant doesn't have parent as prefix. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 484}
,
{
"name" : "resolveRelativePath",
"kind" : "function",
"protection" : "public",
"type" : "File(string relativePath)",
"comment" : "\n Resolves a relative path for file to an absolute path.\n This call does no blocking i\/o.\n Params:\n relativePath = a given relative path string.\n Returns: GFile to the resolved path. NULL if relative_path is NULL or if file is invalid. Free the returned object with g_object_unref().\n\t \n",
"line" : 497}
,
{
"name" : "isNative",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks to see if a file is native to the platform.\n A native file s one expressed in the platform-native filename format,\n e.g. \"C:\\Windows\" or \"\/usr\/bin\/\". This does not mean the file is local,\n as it might be on a locally mounted remote filesystem.\n On some systems non-native files may be available using\n the native filesystem via a userspace filesystem (FUSE), in\n these cases this call will return FALSE, but g_file_get_path()\n will still return a native path.\n This call does no blocking i\/o.\n Returns: TRUE if file is native.\n\t \n",
"line" : 520}
,
{
"name" : "hasUriScheme",
"kind" : "function",
"protection" : "public",
"type" : "int(string uriScheme)",
"comment" : "\n Checks to see if a GFile has a given URI scheme.\n This call does no blocking i\/o.\n Params:\n uriScheme = a string containing a URI scheme.\n Returns: TRUE if GFile's backend supports the given URI scheme, FALSE if URI scheme is NULL, not supported, or GFile is invalid.\n\t \n",
"line" : 533}
,
{
"name" : "getUriScheme",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the URI scheme for a GFile.\n Returns: a string containing the URI scheme for the given GFile. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 543}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "FileInputStream(Cancellable cancellable)",
"comment" : "\n Opens a file for reading. The result is a GFileInputStream that\n can be used to read the contents of the file.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.\n If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned.\n Other errors are possible too, and depend on what kind of filesystem the file is on.\n Params:\n cancellable = a GCancellable\n Returns: GFileInputStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 563}
,
{
"name" : "readAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously opens file for reading.\n For more details, see g_file_read() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_read_finish() to get the result of the operation.\n Params:\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 595}
,
{
"name" : "readFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileInputStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file read operation started with\n g_file_read_async().\n Params:\n res = a GAsyncResult.\n Returns: a GFileInputStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 609}
,
{
"name" : "appendTo",
"kind" : "function",
"protection" : "public",
"type" : "FileOutputStream(GFileCreateFlags flags, Cancellable cancellable)",
"comment" : "\n Gets an output stream for appending data to the file. If\n the file doesn't already exist it is created.\n By default files created are generally readable by everyone,\n but if you pass G_FILE_CREATE_PRIVATE in flags the file\n will be made readable only to the current user, to the level that\n is supported on the target filesystem.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Some file systems don't allow all file names, and may\n return an G_IO_ERROR_INVALID_FILENAME error.\n If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be\n returned. Other errors are possible too, and depend on what kind of\n filesystem the file is on.\n Params:\n flags = a set of GFileCreateFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileOutputStream, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 649}
,
{
"name" : "create",
"kind" : "function",
"protection" : "public",
"type" : "FileOutputStream(GFileCreateFlags flags, Cancellable cancellable)",
"comment" : "\n Creates a new file and returns an output stream for writing to it.\n The file must not already exist.\n By default files created are generally readable by everyone,\n but if you pass G_FILE_CREATE_PRIVATE in flags the file\n will be made readable only to the current user, to the level that\n is supported on the target filesystem.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If a file or directory with this name already exists the G_IO_ERROR_EXISTS\n error will be returned.\n Some file systems don't allow all file names, and may\n return an G_IO_ERROR_INVALID_FILENAME error, and if the name\n is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.\n Other errors are possible too, and depend on what kind of\n filesystem the file is on.\n Params:\n flags = a set of GFileCreateFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileOutputStream for the newly created file, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 691}
,
{
"name" : "replace",
"kind" : "function",
"protection" : "public",
"type" : "FileOutputStream(string etag, int makeBackup, GFileCreateFlags flags, Cancellable cancellable)",
"comment" : "\n Returns an output stream for overwriting the file, possibly\n creating a backup copy of the file first. If the file doesn't exist,\n it will be created.\n This will try to replace the file in the safest way possible so\n that any errors during the writing will not affect an already\n existing copy of the file. For instance, for local files it\n may write to a temporary file and then atomically rename over\n the destination when the stream is closed.\n By default files created are generally readable by everyone,\n but if you pass G_FILE_CREATE_PRIVATE in flags the file\n will be made readable only to the current user, to the level that\n is supported on the target filesystem.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If you pass in a non-NULL etag value, then this value is\n compared to the current entity tag of the file, and if they differ\n an G_IO_ERROR_WRONG_ETAG error is returned. This generally means\n that the file has been changed since you last read it. You can get\n the new etag from g_file_output_stream_get_etag() after you've\n finished writing and closed the GFileOutputStream. When you load\n a new file you can use g_file_input_stream_query_info() to get\n the etag of the file.\n If make_backup is TRUE, this function will attempt to make a backup\n of the current file before overwriting it. If this fails a G_IO_ERROR_CANT_CREATE_BACKUP\n error will be returned. If you want to replace anyway, try again with\n make_backup set to FALSE.\n If the file is a directory the G_IO_ERROR_IS_DIRECTORY error will be returned,\n and if the file is some other form of non-regular file then a\n G_IO_ERROR_NOT_REGULAR_FILE error will be returned.\n Some file systems don't allow all file names, and may\n return an G_IO_ERROR_INVALID_FILENAME error, and if the name\n is to long G_IO_ERROR_FILENAME_TOO_LONG will be returned.\n Other errors are possible too, and depend on what kind of\n filesystem the file is on.\n Params:\n etag = an optional entity tag for the\n  current GFile, or NULL to ignore. [allow-none]\n makeBackup = TRUE if a backup should be created.\n flags = a set of GFileCreateFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileOutputStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 755}
,
{
"name" : "appendToAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(GFileCreateFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously opens file for appending.\n For more details, see g_file_append_to() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_append_to_finish() to get the result of the operation.\n Params:\n flags = a set of GFileCreateFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 788}
,
{
"name" : "appendToFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileOutputStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file append operation started with\n g_file_append_to_async().\n Params:\n res = GAsyncResult\n Returns: a valid GFileOutputStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 802}
,
{
"name" : "createAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(GFileCreateFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously creates a new file and returns an output stream for writing to it.\n The file must not already exist.\n For more details, see g_file_create() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_create_finish() to get the result of the operation.\n Params:\n flags = a set of GFileCreateFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 836}
,
{
"name" : "createFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileOutputStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file create operation started with\n g_file_create_async().\n Params:\n res = a GAsyncResult.\n Returns: a GFileOutputStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 850}
,
{
"name" : "replaceAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string etag, int makeBackup, GFileCreateFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously overwrites the file, replacing the contents, possibly\n creating a backup copy of the file first.\n For more details, see g_file_replace() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_replace_finish() to get the result of the operation.\n Params:\n etag = an entity tag for the\n  current GFile, or NULL to ignore. [allow-none]\n makeBackup = TRUE if a backup should be created.\n flags = a set of GFileCreateFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 887}
,
{
"name" : "replaceFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileOutputStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file replace operation started with\n g_file_replace_async().\n Params:\n res = a GAsyncResult.\n Returns: a GFileOutputStream, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 901}
,
{
"name" : "queryInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(string attributes, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Gets the requested information about specified file. The result\n is a GFileInfo object that contains key-value attributes (such as\n the type or size of the file).\n The attributes value is a string that specifies the file attributes that\n should be gathered. It is not an error if it's not possible to read a particular\n requested attribute from a file - it just won't be set. attributes should\n be a comma-separated list of attributes or attribute wildcards. The wildcard \"*\"\n means all attributes, and a wildcard like \"standard::*\" means all attributes in the standard\n namespace. An example attribute query be \"standard::*,owner::user\".\n The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n For symlinks, normally the information about the target of the\n symlink is returned, rather than information about the symlink itself.\n However if you pass G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in flags the\n information about the symlink itself will be returned. Also, for symlinks\n that point to non-existing files the information about the symlink itself\n will be returned.\n If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.\n Other errors are possible too, and depend on what kind of filesystem the file is on.\n Params:\n attributes = an attribute query string.\n flags = a set of GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileInfo for the given file, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 949}
,
{
"name" : "queryInfoAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string attributes, GFileQueryInfoFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously gets the requested information about specified file. The result\n is a GFileInfo object that contains key-value attributes (such as type or size\n for the file).\n For more details, see g_file_query_info() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_query_info_finish() to get the result of the operation.\n Params:\n attributes = an attribute query string.\n flags = a set of GFileQueryInfoFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 985}
,
{
"name" : "queryInfoFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file info query.\n See g_file_query_info_async().\n Params:\n res = a GAsyncResult.\n Returns: GFileInfo for given file or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 999}
,
{
"name" : "queryExists",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Utility function to check if a particular file exists. This is\n implemented using g_file_query_info() and as such does blocking I\/O.\n Note that in many cases it is racy to first check for file existence\n and then execute something based on the outcome of that, because the\n file might have been created or removed in between the operations. The\n general approach to handling that is to not check, but just do the\n operation and handle the errors as they come.\n As an example of race-free checking, take the case of reading a file, and\n if it doesn't exist, creating it. There are two racy versions: read it, and\n on error create it; and: check if it exists, if not create it. These\n can both result in two processes creating the file (with perhaps a partially\n written file as the result). The correct approach is to always try to create\n the file with g_file_create() which will either atomically create the file\n or fail with a G_IO_ERROR_EXISTS error.\n However, in many cases an existence check is useful in a user\n interface, for instance to make a menu item sensitive\/insensitive, so that\n you don't have to fool users that something is possible and then just show\n and error dialog. If you do this, you should make sure to also handle the\n errors that can happen due to races when you execute the operation.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the file exists (and can be detected without error), FALSE otherwise (or if cancelled).\n\t \n",
"line" : 1042}
,
{
"name" : "queryFileType",
"kind" : "function",
"protection" : "public",
"type" : "GFileType(GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Utility function to inspect the GFileType of a file. This is\n implemented using g_file_query_info() and as such does blocking I\/O.\n The primary use case of this method is to check if a file is a regular file,\n directory, or symlink.\n Since 2.18\n Params:\n flags = a set of GFileQueryInfoFlags passed to g_file_query_info().\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: The GFileType of the file and G_FILE_TYPE_UNKNOWN if the file does not exist\n\t \n",
"line" : 1059}
,
{
"name" : "queryFilesystemInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(string attributes, Cancellable cancellable)",
"comment" : "\n Similar to g_file_query_info(), but obtains information\n about the filesystem the file is on, rather than the file itself.\n For instance the amount of space available and the type of\n the filesystem.\n The attributes value is a string that specifies the file attributes that\n should be gathered. It is not an error if it's not possible to read a particular\n requested attribute from a file - it just won't be set. attributes should\n be a comma-separated list of attributes or attribute wildcards. The wildcard \"*\"\n means all attributes, and a wildcard like \"fs:*\" means all attributes in the fs\n namespace. The standard namespace for filesystem attributes is \"fs\".\n Common attributes of interest are G_FILE_ATTRIBUTE_FILESYSTEM_SIZE\n (the total size of the filesystem in bytes), G_FILE_ATTRIBUTE_FILESYSTEM_FREE (number of\n bytes available), and G_FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.\n Other errors are possible too, and depend on what kind of filesystem the file is on.\n Params:\n attributes = an attribute query string.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileInfo or NULL if there was an error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1090}
,
{
"name" : "queryFilesystemInfoAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string attributes, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously gets the requested information about the filesystem\n that the specified file is on. The result is a GFileInfo object\n that contains key-value attributes (such as type or size for the\n file).\n For more details, see g_file_query_filesystem_info() which is the\n synchronous version of this call.\n When the operation is finished, callback will be called. You can\n then call g_file_query_info_finish() to get the result of the\n operation.\n Params:\n attributes = an attribute query string.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 1127}
,
{
"name" : "queryFilesystemInfoFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous filesystem info query. See\n g_file_query_filesystem_info_async().\n Params:\n res = a GAsyncResult.\n Returns: GFileInfo for given file or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1141}
,
{
"name" : "queryDefaultHandler",
"kind" : "function",
"protection" : "public",
"type" : "AppInfoIF(Cancellable cancellable)",
"comment" : "\n Returns the GAppInfo that is registered as the default\n application to handle the file specified by file.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GAppInfo if the handle was found, NULL if there were errors. When you are done with it, release it with g_object_unref()\n Throws: GException on failure.\n\t \n",
"line" : 1171}
,
{
"name" : "findEnclosingMount",
"kind" : "function",
"protection" : "public",
"type" : "MountIF(Cancellable cancellable)",
"comment" : "\n Gets a GMount for the GFile.\n If the GFileIface for file does not have a mount (e.g. possibly a\n remote share), error will be set to G_IO_ERROR_NOT_FOUND and NULL\n will be returned.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GMount where the file is located or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1203}
,
{
"name" : "findEnclosingMountAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously gets the mount for the file.\n For more details, see g_file_find_enclosing_mount() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_find_enclosing_mount_finish() to get the result of the operation.\n Params:\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 1235}
,
{
"name" : "findEnclosingMountFinish",
"kind" : "function",
"protection" : "public",
"type" : "MountIF(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous find mount request.\n See g_file_find_enclosing_mount_async().\n Params:\n res = a GAsyncResult\n Returns: GMount for given file or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1249}
,
{
"name" : "enumerateChildren",
"kind" : "function",
"protection" : "public",
"type" : "FileEnumerator(string attributes, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Gets the requested information about the files in a directory. The result\n is a GFileEnumerator object that will give out GFileInfo objects for\n all the files in the directory.\n The attributes value is a string that specifies the file attributes that\n should be gathered. It is not an error if it's not possible to read a particular\n requested attribute from a file - it just won't be set. attributes should\n be a comma-separated list of attributes or attribute wildcards. The wildcard \"*\"\n means all attributes, and a wildcard like \"standard::*\" means all attributes in the standard\n namespace. An example attribute query be \"standard::*,owner::user\".\n The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.\n If the file is not a directory, the G_FILE_ERROR_NOTDIR error will be returned.\n Other errors are possible too.\n Params:\n attributes = an attribute query string.\n flags = a set of GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: A GFileEnumerator if successful, NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1292}
,
{
"name" : "enumerateChildrenAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string attributes, GFileQueryInfoFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously gets the requested information about the files in a directory. The result\n is a GFileEnumerator object that will give out GFileInfo objects for\n all the files in the directory.\n For more details, see g_file_enumerate_children() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_enumerate_children_finish() to get the result of the operation.\n Params:\n attributes = an attribute query string.\n flags = a set of GFileQueryInfoFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 1328}
,
{
"name" : "enumerateChildrenFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileEnumerator(AsyncResultIF res)",
"comment" : "\n Finishes an async enumerate children operation.\n See g_file_enumerate_children_async().\n Params:\n res = a GAsyncResult.\n Returns: a GFileEnumerator or NULL if an error occurred. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1342}
,
{
"name" : "setDisplayName",
"kind" : "function",
"protection" : "public",
"type" : "File(string displayName, Cancellable cancellable)",
"comment" : "\n Renames file to the specified display name.\n The display name is converted from UTF8 to the correct encoding for the target\n filesystem if possible and the file is renamed to this.\n If you want to implement a rename operation in the user interface the edit name\n (G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename\n widget, and then the result after editing should be passed to g_file_set_display_name().\n On success the resulting converted filename is returned.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n displayName = a string.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFile specifying what file was renamed to, or NULL if there was an error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1378}
,
{
"name" : "setDisplayNameAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string displayName, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously sets the display name for a given GFile.\n For more details, see g_file_set_display_name() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_set_display_name_finish() to get the result of the operation.\n Params:\n displayName = a string.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 1411}
,
{
"name" : "setDisplayNameFinish",
"kind" : "function",
"protection" : "public",
"type" : "File(AsyncResultIF res)",
"comment" : "\n Finishes setting a display name started with\n g_file_set_display_name_async().\n Params:\n res = a GAsyncResult.\n Returns: a GFile or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1425}
,
{
"name" : "delet",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Deletes a file. If the file is a directory, it will only be deleted if it\n is empty.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the file was deleted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1455}
,
{
"name" : "trash",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Sends file to the \"Trashcan\", if possible. This is similar to\n deleting it, but the user can recover it before emptying the trashcan.\n Not all file systems support trashing, so this call can return the\n G_IO_ERROR_NOT_SUPPORTED error.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on successful trash, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1483}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "int(File destination, GFileCopyFlags flags, Cancellable cancellable, extern (C) void function(long, long, void*) progressCallback, void* progressCallbackData)",
"comment" : "\n Copies the file source to the location specified by destination.\n Can not handle recursive copies of directories.\n If the flag G_FILE_COPY_OVERWRITE is specified an already\n existing destination file is overwritten.\n If the flag G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks\n will be copied as symlinks, otherwise the target of the\n source symlink will be copied.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If progress_callback is not NULL, then the operation can be monitored by\n setting this to a GFileProgressCallback function. progress_callback_data\n will be passed to this function. It is guaranteed that this callback will\n be called after all data has been transferred with the total number of bytes\n copied during the operation.\n If the source file does not exist then the G_IO_ERROR_NOT_FOUND\n error is returned, independent on the status of the destination.\n If G_FILE_COPY_OVERWRITE is not specified and the target exists, then the\n error G_IO_ERROR_EXISTS is returned.\n If trying to overwrite a file over a directory the G_IO_ERROR_IS_DIRECTORY\n error is returned. If trying to overwrite a directory with a directory the\n G_IO_ERROR_WOULD_MERGE error is returned.\n If the source is a directory and the target does not exist, or G_FILE_COPY_OVERWRITE is\n specified and the target is a file, then the G_IO_ERROR_WOULD_RECURSE error\n is returned.\n If you are interested in copying the GFile object itself (not the on-disk\n file), see g_file_dup().\n Params:\n destination = destination GFile\n flags = set of GFileCopyFlags\n cancellable = optional GCancellable object, NULL to ignore.\n progressCallback = function to callback with progress information\n progressCallbackData = user data to pass to progress_callback\n Returns: TRUE on success, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1535}
,
{
"name" : "copyAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(File destination, GFileCopyFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(long, long, void*) progressCallback, void* progressCallbackData, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Copies the file source to the location specified by destination\n asynchronously. For details of the behaviour, see g_file_copy().\n If progress_callback is not NULL, then that function that will be called\n just like in g_file_copy(), however the callback will run in the main loop,\n not in the thread that is doing the I\/O operation.\n When the operation is finished, callback will be called. You can then call\n g_file_copy_finish() to get the result of the operation.\n Params:\n destination = destination GFile\n flags = set of GFileCopyFlags\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n progressCallback = function to callback with progress information\n progressCallbackData = user data to pass to progress_callback\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 1569}
,
{
"name" : "copyFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res)",
"comment" : "\n Finishes copying the file started with\n g_file_copy_async().\n Params:\n res = a GAsyncResult.\n Returns: a TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 1583}
,
{
"name" : "move",
"kind" : "function",
"protection" : "public",
"type" : "int(File destination, GFileCopyFlags flags, Cancellable cancellable, extern (C) void function(long, long, void*) progressCallback, void* progressCallbackData)",
"comment" : "\n Tries to move the file or directory source to the location specified by destination.\n If native move operations are supported then this is used, otherwise a copy + delete\n fallback is used. The native implementation may support moving directories (for instance\n on moves inside the same filesystem), but the fallback code does not.\n If the flag G_FILE_COPY_OVERWRITE is specified an already\n existing destination file is overwritten.\n If the flag G_FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks\n will be copied as symlinks, otherwise the target of the\n source symlink will be copied.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If progress_callback is not NULL, then the operation can be monitored by\n setting this to a GFileProgressCallback function. progress_callback_data\n will be passed to this function. It is guaranteed that this callback will\n be called after all data has been transferred with the total number of bytes\n copied during the operation.\n If the source file does not exist then the G_IO_ERROR_NOT_FOUND\n error is returned, independent on the status of the destination.\n If G_FILE_COPY_OVERWRITE is not specified and the target exists, then the\n error G_IO_ERROR_EXISTS is returned.\n If trying to overwrite a file over a directory the G_IO_ERROR_IS_DIRECTORY\n error is returned. If trying to overwrite a directory with a directory the\n G_IO_ERROR_WOULD_MERGE error is returned.\n If the source is a directory and the target does not exist, or G_FILE_COPY_OVERWRITE is\n specified and the target is a file, then the G_IO_ERROR_WOULD_RECURSE error\n may be returned (if the native move operation isn't available).\n Params:\n destination = GFile pointing to the destination location.\n flags = set of GFileCopyFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n progressCallback = GFileProgressCallback function for updates.\n progressCallbackData = gpointer to user data for the callback function.\n Returns: TRUE on successful move, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1635}
,
{
"name" : "makeDirectory",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Creates a directory. Note that this will only create a child directory of\n the immediate parent directory of the path or URI given by the GFile. To\n recursively create directories, see g_file_make_directory_with_parents().\n This function will fail if the parent directory does not exist, setting\n error to G_IO_ERROR_NOT_FOUND. If the file system doesn't support creating\n directories, this function will fail, setting error to\n G_IO_ERROR_NOT_SUPPORTED.\n For a local GFile the newly created directory will have the default\n (current) ownership and permissions of the current process.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on successful creation, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1668}
,
{
"name" : "makeDirectoryWithParents",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Creates a directory and any parent directories that may not exist similar to\n 'mkdir -p'. If the file system does not support creating directories, this\n function will fail, setting error to G_IO_ERROR_NOT_SUPPORTED.\n For a local GFile the newly created directories will have the default\n (current) ownership and permissions of the current process.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Since 2.18\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if all directories have been successfully created, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1698}
,
{
"name" : "makeSymbolicLink",
"kind" : "function",
"protection" : "public",
"type" : "int(string symlinkValue, Cancellable cancellable)",
"comment" : "\n Creates a symbolic link named file which contains the string\n symlink_value.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n symlinkValue = a string with the path for the target of the new symlink\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on the creation of a new symlink, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1725}
,
{
"name" : "querySettableAttributes",
"kind" : "function",
"protection" : "public",
"type" : "FileAttributeInfoList(Cancellable cancellable)",
"comment" : "\n Obtain the list of settable attributes for the file.\n Returns the type and full attribute name of all the attributes\n that can be set on this file. This doesn't mean setting it will always\n succeed though, you might get an access failure, or some specific\n file may not support a specific attribute.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileAttributeInfoList describing the settable attributes. When you are done with it, release it with g_file_attribute_info_list_unref()\n Throws: GException on failure.\n\t \n",
"line" : 1754}
,
{
"name" : "queryWritableNamespaces",
"kind" : "function",
"protection" : "public",
"type" : "FileAttributeInfoList(Cancellable cancellable)",
"comment" : "\n Obtain the list of attribute namespaces where new attributes\n can be created by a user. An example of this is extended\n attributes (in the \"xattr\" namespace).\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileAttributeInfoList describing the writable namespaces. When you are done with it, release it with g_file_attribute_info_list_unref()\n Throws: GException on failure.\n\t \n",
"line" : 1785}
,
{
"name" : "setAttribute",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, GFileAttributeType type, void* valueP, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets an attribute in the file with attribute name attribute to value.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n type = The type of the attribute\n valueP = a pointer to the value (or the pointer itself if the type is a pointer type)\n flags = a set of GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was set, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1818}
,
{
"name" : "setAttributesFromInfo",
"kind" : "function",
"protection" : "public",
"type" : "int(FileInfo info, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Tries to set all attributes in the GFileInfo on the target values,\n not stopping on the first error.\n If there is any error during this operation then error will be set to\n the first error. Error on particular fields are flagged by setting\n the \"status\" field in the attribute value to\n G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect\n further errors.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n info = a GFileInfo.\n flags = GFileQueryInfoFlags\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if there was any error, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1851}
,
{
"name" : "setAttributesAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(FileInfo info, GFileQueryInfoFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously sets the attributes of file with info.\n For more details, see g_file_set_attributes_from_info() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_set_attributes_finish() to get the result of the operation.\n Params:\n info = a GFileInfo.\n flags = a GFileQueryInfoFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback.\n userData = a gpointer.\n\t \n",
"line" : 1881}
,
{
"name" : "setAttributesFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result, out FileInfo info)",
"comment" : "\n Finishes setting an attribute started in g_file_set_attributes_async().\n Params:\n result = a GAsyncResult.\n info = a GFileInfo. [out][transfer full]\n Returns: TRUE if the attributes were set correctly, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1895}
,
{
"name" : "setAttributeString",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, string value, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets attribute of type G_FILE_ATTRIBUTE_TYPE_STRING to value.\n If attribute is of a different type, this operation will fail.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n value = a string containing the attribute's value.\n flags = GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was successfully set, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1926}
,
{
"name" : "setAttributeByteString",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, string value, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets attribute of type G_FILE_ATTRIBUTE_TYPE_BYTE_STRING to value.\n If attribute is of a different type, this operation will fail,\n returning FALSE.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n value = a string containing the attribute's new value.\n flags = a GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was successfully set to value in the file, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1956}
,
{
"name" : "setAttributeUint32",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, uint value, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT32 to value.\n If attribute is of a different type, this operation will fail.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n value = a guint32 containing the attribute's new value.\n flags = a GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was successfully set to value in the file, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 1985}
,
{
"name" : "setAttributeInt32",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, int value, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT32 to value.\n If attribute is of a different type, this operation will fail.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n value = a gint32 containing the attribute's new value.\n flags = a GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was successfully set to value in the file, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2014}
,
{
"name" : "setAttributeUint64",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, ulong value, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets attribute of type G_FILE_ATTRIBUTE_TYPE_UINT64 to value.\n If attribute is of a different type, this operation will fail.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n value = a guint64 containing the attribute's new value.\n flags = a GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was successfully set to value in the file, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2043}
,
{
"name" : "setAttributeInt64",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, long value, GFileQueryInfoFlags flags, Cancellable cancellable)",
"comment" : "\n Sets attribute of type G_FILE_ATTRIBUTE_TYPE_INT64 to value.\n If attribute is of a different type, this operation will fail.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n attribute = a string containing the attribute's name.\n value = a guint64 containing the attribute's new value.\n flags = a GFileQueryInfoFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attribute was successfully set, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2072}
,
{
"name" : "mountMountable",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountMountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Mounts a file of type G_FILE_TYPE_MOUNTABLE.\n Using mount_operation, you can request callbacks when, for instance,\n passwords are needed during authentication.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n When the operation is finished, callback will be called. You can then call\n g_file_mount_mountable_finish() to get the result of the operation.\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation, or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2103}
,
{
"name" : "mountMountableFinish",
"kind" : "function",
"protection" : "public",
"type" : "File(AsyncResultIF result)",
"comment" : "\n Finishes a mount operation. See g_file_mount_mountable() for details.\n Finish an asynchronous mount operation that was started\n with g_file_mount_mountable().\n Params:\n result = a GAsyncResult.\n Returns: a GFile or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2118}
,
{
"name" : "unmountMountable",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Warning\n g_file_unmount_mountable has been deprecated since version 2.22 and should not be used in newly-written code. Use g_file_unmount_mountable_with_operation() instead.\n Unmounts a file of type G_FILE_TYPE_MOUNTABLE.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n When the operation is finished, callback will be called. You can then call\n g_file_unmount_mountable_finish() to get the result of the operation.\n Params:\n flags = flags affecting the operation\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2152}
,
{
"name" : "unmountMountableFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_file_unmount_mountable_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_file_unmount_mountable_with_operation_finish() instead.\n Finishes an unmount operation, see g_file_unmount_mountable() for details.\n Finish an asynchronous unmount operation that was started\n with g_file_unmount_mountable().\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the operation finished successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2169}
,
{
"name" : "unmountMountableWithOperation",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Unmounts a file of type G_FILE_TYPE_MOUNTABLE.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n When the operation is finished, callback will be called. You can then call\n g_file_unmount_mountable_finish() to get the result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation, or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2199}
,
{
"name" : "unmountMountableWithOperationFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.\n Finish an asynchronous unmount operation that was started\n with g_file_unmount_mountable_with_operation().\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the operation finished successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2215}
,
{
"name" : "ejectMountable",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Warning\n g_file_eject_mountable has been deprecated since version 2.22 and should not be used in newly-written code. Use g_file_eject_mountable_with_operation() instead.\n Starts an asynchronous eject on a mountable.\n When this operation has completed, callback will be called with\n user_user data, and the operation can be finalized with\n g_file_eject_mountable_finish().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n flags = flags affecting the operation\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2246}
,
{
"name" : "ejectMountableFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_file_eject_mountable_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_file_eject_mountable_with_operation_finish() instead.\n Finishes an asynchronous eject operation started by\n g_file_eject_mountable().\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the file was ejected successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2262}
,
{
"name" : "ejectMountableWithOperation",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Starts an asynchronous eject on a mountable.\n When this operation has completed, callback will be called with\n user_user data, and the operation can be finalized with\n g_file_eject_mountable_with_operation_finish().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Since 2.22\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation, or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2293}
,
{
"name" : "ejectMountableWithOperationFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes an asynchronous eject operation started by\n g_file_eject_mountable_with_operation().\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the file was ejected successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2308}
,
{
"name" : "startMountable",
"kind" : "function",
"protection" : "public",
"type" : "void(GDriveStartFlags flags, MountOperation startOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Starts a file of type G_FILE_TYPE_MOUNTABLE.\n Using start_operation, you can request callbacks when, for instance,\n passwords are needed during authentication.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n When the operation is finished, callback will be called. You can then call\n g_file_mount_mountable_finish() to get the result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the operation\n startOperation = a GMountOperation, or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2340}
,
{
"name" : "startMountableFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes a start operation. See g_file_start_mountable() for details.\n Finish an asynchronous start operation that was started\n with g_file_start_mountable().\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the operation finished successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2356}
,
{
"name" : "stopMountable",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Stops a file of type G_FILE_TYPE_MOUNTABLE.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n When the operation is finished, callback will be called. You can then call\n g_file_stop_mountable_finish() to get the result of the operation.\n Since 2.22\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation, or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2386}
,
{
"name" : "stopMountableFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes an stop operation, see g_file_stop_mountable() for details.\n Finish an asynchronous stop operation that was started\n with g_file_stop_mountable().\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the operation finished successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2402}
,
{
"name" : "pollMountable",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Polls a file of type G_FILE_TYPE_MOUNTABLE.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n When the operation is finished, callback will be called. You can then call\n g_file_mount_mountable_finish() to get the result of the operation.\n Since 2.22\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2430}
,
{
"name" : "pollMountableFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes a poll operation. See g_file_poll_mountable() for details.\n Finish an asynchronous poll operation that was polled\n with g_file_poll_mountable().\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the operation finished successfully. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2446}
,
{
"name" : "mountEnclosingVolume",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountMountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Starts a mount_operation, mounting the volume that contains the file location.\n When this operation has completed, callback will be called with\n user_user data, and the operation can be finalized with\n g_file_mount_enclosing_volume_finish().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied, or NULL.\n userData = the data to pass to callback function\n\t \n",
"line" : 2476}
,
{
"name" : "mountEnclosingVolumeFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes a mount operation started by g_file_mount_enclosing_volume().\n Params:\n result = a GAsyncResult.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 2489}
,
{
"name" : "monitorDirectory",
"kind" : "function",
"protection" : "public",
"type" : "FileMonitor(GFileMonitorFlags flags, Cancellable cancellable)",
"comment" : "\n Obtains a directory monitor for the given file.\n This may fail if directory monitoring is not supported.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n flags = a set of GFileMonitorFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileMonitor for the given file, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2516}
,
{
"name" : "monitorFile",
"kind" : "function",
"protection" : "public",
"type" : "FileMonitor(GFileMonitorFlags flags, Cancellable cancellable)",
"comment" : "\n Obtains a file monitor for the given file. If no file notification\n mechanism exists, then regular polling of the file is used.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n flags = a set of GFileMonitorFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileMonitor for the given file, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2547}
,
{
"name" : "monitor",
"kind" : "function",
"protection" : "public",
"type" : "FileMonitor(GFileMonitorFlags flags, Cancellable cancellable)",
"comment" : "\n Obtains a file or directory monitor for the given file, depending\n on the type of the file.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Since 2.18\n Params:\n flags = a set of GFileMonitorFlags\n cancellable = optional GCancellable object, NULL to ignore\n Returns: a GFileMonitor for the given file, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2579}
,
{
"name" : "loadContents",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable, out string contents, out ulong length, out string etagOut)",
"comment" : "\n Loads the content of the file into memory. The data is always\n zero-terminated, but this is not included in the resultant length.\n The returned content should be freed with g_free() when no longer\n needed.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n contents = a location to place the contents of the file. [out][transfer full]\n length = a location to place the length of the contents of the file,\n  or NULL if the length is not needed. [out][allow-none]\n etagOut = a location to place the current entity tag for the file,\n  or NULL if the entity tag is not needed. [out][allow-none]\n Returns: TRUE if the file's contents were successfully loaded. FALSE if there were errors.\n Throws: GException on failure.\n\t \n",
"line" : 2616}
,
{
"name" : "loadContentsAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Starts an asynchronous load of the file's contents.\n For more details, see g_file_load_contents() which is\n the synchronous version of this call.\n When the load operation has completed, callback will be called\n with user data. To finish the operation, call\n g_file_load_contents_finish() with the GAsyncResult returned by\n the callback.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 2651}
,
{
"name" : "loadContentsFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res, out string contents, out ulong length, out string etagOut)",
"comment" : "\n Finishes an asynchronous load of the file's contents.\n The contents are placed in contents, and length is set to the\n size of the contents string. The content should be freed with\n g_free() when no longer needed. If etag_out is present, it will be\n set to the new entity tag for the file.\n Params:\n res = a GAsyncResult.\n contents = a location to place the contents of the file. [out][transfer full]\n length = a location to place the length of the contents of the file,\n  or NULL if the length is not needed. [out][allow-none]\n etagOut = a location to place the current entity tag for the file,\n  or NULL if the entity tag is not needed. [out][allow-none]\n Returns: TRUE if the load was successful. If FALSE and error is present, it will be set appropriately.\n Throws: GException on failure.\n\t \n",
"line" : 2673}
,
{
"name" : "loadPartialContentsAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) int function(char*, long, void*) readMoreCallback, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Reads the partial contents of a file. A GFileReadMoreCallback should be\n used to stop reading from the file when appropriate, else this function\n will behave exactly as g_file_load_contents_async(). This operation\n can be finished by g_file_load_partial_contents_finish().\n Users of this function should be aware that user_data is passed to\n both the read_more_callback and the callback.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n readMoreCallback = a GFileReadMoreCallback to receive partial data and to specify whether further data should be read.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to the callback functions.\n\t \n",
"line" : 2708}
,
{
"name" : "loadPartialContentsFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res, out string contents, out ulong length, out string etagOut)",
"comment" : "\n Finishes an asynchronous partial load operation that was started\n with g_file_load_partial_contents_async(). The data is always\n zero-terminated, but this is not included in the resultant length.\n The returned content should be freed with g_free() when no longer\n needed.\n Params:\n res = a GAsyncResult.\n contents = a location to place the contents of the file. [out][transfer full]\n length = a location to place the length of the contents of the file,\n  or NULL if the length is not needed. [out][allow-none]\n etagOut = a location to place the current entity tag for the file,\n  or NULL if the entity tag is not needed. [out][allow-none]\n Returns: TRUE if the load was successful. If FALSE and error is present, it will be set appropriately.\n Throws: GException on failure.\n\t \n",
"line" : 2730}
,
{
"name" : "replaceContents",
"kind" : "function",
"protection" : "public",
"type" : "int(string contents, ulong length, string etag, int makeBackup, GFileCreateFlags flags, out string newEtag, Cancellable cancellable)",
"comment" : "\n Replaces the contents of file with contents of length bytes.\n If etag is specified (not NULL) any existing file must have that etag, or\n the error G_IO_ERROR_WRONG_ETAG will be returned.\n If make_backup is TRUE, this function will attempt to make a backup of file.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n The returned new_etag can be used to verify that the file hasn't changed the\n next time it is saved over.\n Params:\n contents = a string containing the new contents for file.\n length = the length of contents in bytes.\n etag = the old entity tag\n  for the document, or NULL. [allow-none]\n makeBackup = TRUE if a backup should be created.\n flags = a set of GFileCreateFlags.\n newEtag = a location to a new entity tag\n  for the document. This should be freed with g_free() when no longer\n  needed, or NULL\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 2773}
,
{
"name" : "replaceContentsAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string contents, ulong length, string etag, int makeBackup, GFileCreateFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Starts an asynchronous replacement of file with the given\n contents of length bytes. etag will replace the document's\n current entity tag.\n When this operation has completed, callback will be called with\n user_user data, and the operation can be finalized with\n g_file_replace_contents_finish().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If make_backup is TRUE, this function will attempt to\n make a backup of file.\n Params:\n contents = string of contents to replace the file with.\n length = the length of contents in bytes.\n etag = a new entity tag for the file, or NULL. [allow-none]\n makeBackup = TRUE if a backup should be created.\n flags = a set of GFileCreateFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 2812}
,
{
"name" : "replaceContentsFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF res, out string newEtag)",
"comment" : "\n Finishes an asynchronous replace of the given file. See\n g_file_replace_contents_async(). Sets new_etag to the new entity\n tag for the document, if present.\n Params:\n res = a GAsyncResult.\n newEtag = a location of a new entity tag\n  for the document. This should be freed with g_free() when it is no\n  longer needed, or NULL. [out][allow-none]\n Returns: TRUE on success, FALSE on failure.\n Throws: GException on failure.\n\t \n",
"line" : 2830}
,
{
"name" : "copyAttributes",
"kind" : "function",
"protection" : "public",
"type" : "int(File destination, GFileCopyFlags flags, Cancellable cancellable)",
"comment" : "\n Copies the file attributes from source to destination.\n Normally only a subset of the file attributes are copied,\n those that are copies in a normal file copy operation\n (which for instance does not include e.g. owner). However\n if G_FILE_COPY_ALL_METADATA is specified in flags, then\n all the metadata that is possible to copy is copied. This\n is useful when implementing move by copy + delete source.\n Params:\n destination = a GFile to copy attributes to.\n flags = a set of GFileCopyFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if the attributes were copied successfully, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 2862}
,
{
"name" : "createReadwrite",
"kind" : "function",
"protection" : "public",
"type" : "FileIOStream(GFileCreateFlags flags, Cancellable cancellable)",
"comment" : "\n Creates a new file and returns a stream for reading and writing to it.\n The file must not already exist.\n By default files created are generally readable by everyone,\n but if you pass G_FILE_CREATE_PRIVATE in flags the file\n will be made readable only to the current user, to the level that\n is supported on the target filesystem.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If a file or directory with this name already exists the G_IO_ERROR_EXISTS\n error will be returned. Some file systems don't allow all file names,\n and may return an G_IO_ERROR_INVALID_FILENAME error, and if the name\n is too long, G_IO_ERROR_FILENAME_TOO_LONG will be returned. Other errors\n are possible too, and depend on what kind of filesystem the file is on.\n Note that in many non-local file cases read and write streams are not\n supported, so make sure you really need to do read and write streaming,\n rather than just opening for reading or writing.\n Since 2.22\n Params:\n flags = a set of GFileCreateFlags\n cancellable = optional GCancellable object, NULL to ignore\n Returns: a GFileIOStream for the newly created file, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2902}
,
{
"name" : "createReadwriteAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(GFileCreateFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously creates a new file and returns a stream for reading and\n writing to it. The file must not already exist.\n For more details, see g_file_create_readwrite() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then\n call g_file_create_readwrite_finish() to get the result of the operation.\n Since 2.22\n Params:\n flags = a set of GFileCreateFlags\n ioPriority = the I\/O priority\n  of the request\n cancellable = optional GCancellable object, NULL to ignore\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 2937}
,
{
"name" : "createReadwriteFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileIOStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file create operation started with\n g_file_create_readwrite_async().\n Since 2.22\n Params:\n res = a GAsyncResult\n Returns: a GFileIOStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2952}
,
{
"name" : "openReadwrite",
"kind" : "function",
"protection" : "public",
"type" : "FileIOStream(Cancellable cancellable)",
"comment" : "\n Opens an existing file for reading and writing. The result is\n a GFileIOStream that can be used to read and write the contents of the file.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n If the file does not exist, the G_IO_ERROR_NOT_FOUND error will be returned.\n If the file is a directory, the G_IO_ERROR_IS_DIRECTORY error will be returned.\n Other errors are possible too, and depend on what kind of filesystem the file is on.\n Note that in many non-local file cases read and write streams are not supported,\n so make sure you really need to do read and write streaming, rather than\n just opening for reading or writing.\n Since 2.22\n Params:\n cancellable = a GCancellable\n Returns: GFileIOStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 2989}
,
{
"name" : "openReadwriteAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously opens file for reading and writing.\n For more details, see g_file_open_readwrite() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then call\n g_file_open_readwrite_finish() to get the result of the operation.\n Since 2.22\n Params:\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 3022}
,
{
"name" : "openReadwriteFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileIOStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file read operation started with\n g_file_open_readwrite_async().\n Since 2.22\n Params:\n res = a GAsyncResult.\n Returns: a GFileIOStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 3037}
,
{
"name" : "replaceReadwrite",
"kind" : "function",
"protection" : "public",
"type" : "FileIOStream(string etag, int makeBackup, GFileCreateFlags flags, Cancellable cancellable)",
"comment" : "\n Returns an output stream for overwriting the file in readwrite mode,\n possibly creating a backup copy of the file first. If the file doesn't\n exist, it will be created.\n For details about the behaviour, see g_file_replace() which does the same\n thing but returns an output stream only.\n Note that in many non-local file cases read and write streams are not\n supported, so make sure you really need to do read and write streaming,\n rather than just opening for reading or writing.\n Since 2.22\n Params:\n etag = an optional entity tag for the\n  current GFile, or NULL to ignore. [allow-none]\n makeBackup = TRUE if a backup should be created\n flags = a set of GFileCreateFlags\n cancellable = optional GCancellable object, NULL to ignore\n Returns: a GFileIOStream or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 3075}
,
{
"name" : "replaceReadwriteAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string etag, int makeBackup, GFileCreateFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously overwrites the file in read-write mode, replacing the\n contents, possibly creating a backup copy of the file first.\n For more details, see g_file_replace_readwrite() which is\n the synchronous version of this call.\n When the operation is finished, callback will be called. You can then\n call g_file_replace_readwrite_finish() to get the result of the operation.\n Since 2.22\n Params:\n etag = an entity tag for the\n  current GFile, or NULL to ignore. [allow-none]\n makeBackup = TRUE if a backup should be created.\n flags = a set of GFileCreateFlags.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 3113}
,
{
"name" : "replaceReadwriteFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileIOStream(AsyncResultIF res)",
"comment" : "\n Finishes an asynchronous file replace operation started with\n g_file_replace_readwrite_async().\n Since 2.22\n Params:\n res = a GAsyncResult.\n Returns: a GFileIOStream, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 3128}
,
{
"name" : "supportsThreadContexts",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if file supports thread-default\n contexts. If this returns FALSE, you cannot perform\n asynchronous operations on file in a thread that has a\n thread-default context.\n Since 2.22\n Returns: Whether or not file supports thread-default contexts.\n\t \n",
"line" : 3155}
]
}
]
}
,
{
"name" : "gio.FileDescriptorBasedIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileDescriptorBasedIF.d",
"members" : [
{
"name" : "FileDescriptorBasedIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GFileDescriptorBased is implemented by streams (implementations of\n GInputStream or GOutputStream) that are based on file descriptors.\n Note that <gio\/gfiledescriptorbased.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 72,
"members" : [
{
"name" : "getFileDescriptorBasedTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileDescriptorBased*()",
"line" : 75}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "getFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n\t \n\n Gets the underlying file descriptor.\n Since 2.24\n Returns: The file descriptor\n\t \n",
"line" : 89}
]
}
]
}
,
{
"name" : "gio.FileDescriptorBasedT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileDescriptorBasedT.d",
"members" : [
{
"name" : "FileDescriptorBasedT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GFileDescriptorBased is implemented by streams (implementations of\n GInputStream or GOutputStream) that are based on file descriptors.\n Note that <gio\/gfiledescriptorbased.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 72,
"members" : [
{
"name" : "gFileDescriptorBased",
"kind" : "variable",
"type" : "GFileDescriptorBased*",
"comment" : " the main Gtk struct \n",
"line" : 76}
,
{
"name" : "getFileDescriptorBasedTStruct",
"kind" : "function",
"type" : "GFileDescriptorBased*()",
"line" : 79}
,
{
"name" : "getFd",
"kind" : "function",
"type" : "int()",
"comment" : "\n\t \n\n Gets the underlying file descriptor.\n Since 2.24\n Returns: The file descriptor\n\t \n",
"line" : 93}
]
}
]
}
,
{
"name" : "gio.FileEnumerator",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileEnumerator.d",
"members" : [
{
"name" : "FileEnumerator",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GFileEnumerator allows you to operate on a set of GFiles,\n returning a GFileInfo structure for each file enumerated (e.g.\n g_file_enumerate_children() will return a GFileEnumerator for each\n of the children within a directory).\n To get the next file's information from a GFileEnumerator, use\n g_file_enumerator_next_file() or its asynchronous version,\n g_file_enumerator_next_files_async(). Note that the asynchronous\n version will return a list of GFileInfos, whereas the\n synchronous will only return the next file in the enumerator.\n To close a GFileEnumerator, use g_file_enumerator_close(), or\n its asynchronous version, g_file_enumerator_close_async(). Once\n a GFileEnumerator is closed, no further actions may be performed\n on it, and it should be freed with g_object_unref().\n \n",
"line" : 98,
"base" : "ObjectG",
"members" : [
{
"name" : "gFileEnumerator",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileEnumerator*",
"comment" : " the main Gtk struct \n",
"line" : 102}
,
{
"name" : "getFileEnumeratorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileEnumerator*()",
"line" : 105}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 112}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileEnumerator(GFileEnumerator* gFileEnumerator)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 120}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 138}
,
{
"name" : "nextFile",
"kind" : "function",
"protection" : "public",
"type" : "GFileInfo*(Cancellable cancellable)",
"comment" : "\n\t \n\n Returns information for the next file in the enumerated object.\n Will block until the information is available. The GFileInfo\n returned from this function will contain attributes that match the\n attribute string that was passed when the GFileEnumerator was created.\n On error, returns NULL and sets error to the error. If the\n enumerator is at the end, NULL will be returned and error will\n be unset.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: A GFileInfo or NULL on error or end of enumerator. Free the returned object with g_object_unref() when no longer needed.\n Throws: GException on failure.\n\t \n",
"line" : 160}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Releases all resources used by this enumerator, making the\n enumerator return G_IO_ERROR_CLOSED on all calls.\n This will be automatically called when the last reference\n is dropped, but you might want to call this function to make\n sure resources are released as early as possible.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on success or FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 186}
,
{
"name" : "nextFilesAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int numFiles, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Request information for a number of files from the enumerator asynchronously.\n When all i\/o for the operation is finished the callback will be called with\n the requested information.\n The callback can be called with less than num_files files in case of error\n or at the end of the enumerator. In case of a partial error the callback will\n be called with any succeeding items and no error, and on the next request the\n error will be reported. If a request is cancelled the callback will be called\n with G_IO_ERROR_CANCELLED.\n During an async request no other sync and async calls are allowed, and will\n result in G_IO_ERROR_PENDING errors.\n Any outstanding i\/o request with higher priority (lower numerical value) will\n be executed before an outstanding request with lower priority. Default\n priority is G_PRIORITY_DEFAULT.\n Params:\n numFiles = the number of file info objects to request\n ioPriority = the io priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 223}
,
{
"name" : "nextFilesFinish",
"kind" : "function",
"protection" : "public",
"type" : "ListG(AsyncResultIF result)",
"comment" : "\n Finishes the asynchronous operation started with g_file_enumerator_next_files_async().\n Params:\n result = a GAsyncResult.\n Returns: a GList of GFileInfos. You must free the list with g_list_free() and unref the infos with g_object_unref() when you're done with them. [transfer full][element-type FileInfo]\n Throws: GException on failure.\n\t \n",
"line" : 236}
,
{
"name" : "closeAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously closes the file enumerator.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned in\n g_file_enumerator_close_finish().\n Params:\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 268}
,
{
"name" : "closeFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes closing a file enumerator, started from g_file_enumerator_close_async().\n If the file enumerator was already closed when g_file_enumerator_close_async()\n was called, then this function will report G_IO_ERROR_CLOSED in error, and\n return FALSE. If the file enumerator had pending operation when the close\n operation was started, then this function will report G_IO_ERROR_PENDING, and\n return FALSE. If cancellable was not NULL, then the operation may have been\n cancelled by triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be set, and FALSE will be\n returned.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the close operation has finished successfully.\n Throws: GException on failure.\n\t \n",
"line" : 289}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the file enumerator has been closed.\n Returns: TRUE if the enumerator is closed.\n\t \n",
"line" : 308}
,
{
"name" : "hasPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the file enumerator has pending operations.\n Returns: TRUE if the enumerator has pending operations.\n\t \n",
"line" : 318}
,
{
"name" : "setPending",
"kind" : "function",
"protection" : "public",
"type" : "void(int pending)",
"comment" : "\n Sets the file enumerator as having pending operations.\n Params:\n pending = a boolean value.\n\t \n",
"line" : 329}
,
{
"name" : "getContainer",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Get the GFile container which is being enumerated.\n Since 2.18\n Returns: the GFile which is being enumerated.\n\t \n",
"line" : 340}
]
}
]
}
,
{
"name" : "gio.FileIcon",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileIcon.d",
"members" : [
{
"name" : "FileIcon",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GFileIcon specifies an icon by pointing to an image file\n to be used as icon.\n \n",
"line" : 79,
"base" : "ObjectG",
"interfaces" : [
"IconIF",
"LoadableIconIF"],
"members" : [
{
"name" : "gFileIcon",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileIcon*",
"comment" : " the main Gtk struct \n",
"line" : 83}
,
{
"name" : "getFileIconStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileIcon*()",
"line" : 86}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 93}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileIcon(GFileIcon* gFileIcon)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 101}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 119}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileIcon(GFile* file)",
"comment" : "\n\t \n\n Creates a new icon for a file.\n Params:\n file = a GFile.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 140}
,
{
"name" : "getFile",
"kind" : "function",
"protection" : "public",
"type" : "GFile*()",
"comment" : "\n Gets the GFile associated with the given icon.\n Returns: a GFile, or NULL.\n\t \n",
"line" : 155}
]
}
]
}
,
{
"name" : "gio.FileInfo",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileInfo.d",
"members" : [
{
"name" : "FileInfo",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Functionality for manipulating basic metadata for files. GFileInfo\n implements methods for getting information that all files should\n contain, and allows for manipulation of extended attributes.\n See GFileAttribute for more\n information on how GIO handles file attributes.\n To obtain a GFileInfo for a GFile, use g_file_query_info() (or its\n async variant). To obtain a GFileInfo for a file input or output\n stream, use g_file_input_stream_query_info() or\n g_file_output_stream_query_info() (or their async variants).\n To change the actual attributes of a file, you should then set the\n attribute in the GFileInfo and call g_file_set_attributes_from_info()\n or g_file_set_attributes_async() on a GFile.\n However, not all attributes can be changed in the file. For instance,\n the actual size of a file cannot be changed via g_file_info_set_size().\n You may call g_file_query_settable_attributes() and\n g_file_query_writable_namespaces() to discover the settable attributes\n of a particular file at runtime.\n GFileAttributeMatcher allows for searching through a GFileInfo for\n attributes.\n \n",
"line" : 104,
"base" : "ObjectG",
"members" : [
{
"name" : "gFileInfo",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileInfo*",
"comment" : " the main Gtk struct \n",
"line" : 108}
,
{
"name" : "getFileInfoStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileInfo*()",
"line" : 111}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 118}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileInfo(GFileInfo* gFileInfo)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 126}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 144}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileInfo()",
"comment" : "\n\t \n\n Creates a new file info structure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 157}
,
{
"name" : "dup",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo()",
"comment" : "\n Duplicates a file info structure.\n Returns: a duplicate GFileInfo of other.\n\t \n",
"line" : 172}
,
{
"name" : "copyInto",
"kind" : "function",
"protection" : "public",
"type" : "void(FileInfo destInfo)",
"comment" : "\n Copies all of the GFileAttributes from src_info to dest_info.\n Params:\n destInfo = destination to copy attributes to.\n\t \n",
"line" : 188}
,
{
"name" : "hasAttribute",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute)",
"comment" : "\n Checks if a file info structure has an attribute named attribute.\n Params:\n attribute = a file attribute key.\n Returns: TRUE if Ginfo has an attribute named attribute, FALSE otherwise.\n\t \n",
"line" : 200}
,
{
"name" : "hasNamespace",
"kind" : "function",
"protection" : "public",
"type" : "int(string nameSpace)",
"comment" : "\n Checks if a file info structure has an attribute in the\n specified name_space.\n Since 2.22\n Params:\n nameSpace = a file attribute namespace.\n Returns: TRUE if Ginfo has an attribute in name_space, FALSE otherwise.\n\t \n",
"line" : 214}
,
{
"name" : "listAttributes",
"kind" : "function",
"protection" : "public",
"type" : "string[](string nameSpace)",
"comment" : "\n Lists the file info structure's attributes.\n Params:\n nameSpace = a file attribute key's namespace.\n Returns: a null-terminated array of strings of all of the possible attribute types for the given name_space, or NULL on error. [array zero-terminated=1][transfer full zero-terminated=1]\n\t \n",
"line" : 226}
,
{
"name" : "getAttributeType",
"kind" : "function",
"protection" : "public",
"type" : "GFileAttributeType(string attribute)",
"comment" : "\n Gets the attribute type for an attribute key.\n Params:\n attribute = a file attribute key.\n Returns: a GFileAttributeType for the given attribute, or G_FILE_ATTRIBUTE_TYPE_INVALID if the key is not set.\n\t \n",
"line" : 238}
,
{
"name" : "removeAttribute",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute)",
"comment" : "\n Removes all cases of attribute from info if it exists.\n Params:\n attribute = a file attribute key.\n\t \n",
"line" : 249}
,
{
"name" : "getAttributeAsString",
"kind" : "function",
"protection" : "public",
"type" : "string(string attribute)",
"comment" : "\n Gets the value of a attribute, formated as a string.\n This escapes things as needed to make the string valid\n utf8.\n Params:\n attribute = a file attribute key.\n Returns: a UTF-8 string associated with the given attribute. When you're done with the string it must be freed with g_free().\n\t \n",
"line" : 263}
,
{
"name" : "getAttributeData",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, out GFileAttributeType type, out void* valuePp, out GFileAttributeStatus status)",
"comment" : "\n Gets the attribute type, value and status for an attribute key.\n Params:\n attribute = a file attribute key\n type = return location for the attribute type, or NULL. [out][allow-none]\n valuePp = return location for the attribute value, or NULL. [out][allow-none]\n status = return location for the attribute status, or NULL. [out][allow-none]\n Returns: TRUE if info has an attribute named attribute, FALSE otherwise. [transfer none]\n\t \n",
"line" : 278}
,
{
"name" : "getAttributeStatus",
"kind" : "function",
"protection" : "public",
"type" : "GFileAttributeStatus(string attribute)",
"comment" : "\n Gets the attribute status for an attribute key.\n Params:\n attribute = a file attribute key\n Returns: a GFileAttributeStatus for the given attribute, or G_FILE_ATTRIBUTE_STATUS_UNSET if the key is invalid.\n\t \n",
"line" : 290}
,
{
"name" : "getAttributeString",
"kind" : "function",
"protection" : "public",
"type" : "string(string attribute)",
"comment" : "\n Gets the value of a string attribute. If the attribute does\n not contain a string, NULL will be returned.\n Params:\n attribute = a file attribute key.\n Returns: the contents of the attribute value as a string, or NULL otherwise.\n\t \n",
"line" : 303}
,
{
"name" : "getAttributeStringv",
"kind" : "function",
"protection" : "public",
"type" : "string[](string attribute)",
"comment" : "\n Gets the value of a stringv attribute. If the attribute does\n not contain a stringv, NULL will be returned.\n Since 2.22\n Params:\n attribute = a file attribute key.\n Returns: the contents of the attribute value as a stringv, or NULL otherwise. Do not free.\n\t \n",
"line" : 317}
,
{
"name" : "getAttributeByteString",
"kind" : "function",
"protection" : "public",
"type" : "string(string attribute)",
"comment" : "\n Gets the value of a byte string attribute. If the attribute does\n not contain a byte string, NULL will be returned.\n Params:\n attribute = a file attribute key.\n Returns: the contents of the attribute value as a byte string, or NULL otherwise.\n\t \n",
"line" : 330}
,
{
"name" : "getAttributeBoolean",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute)",
"comment" : "\n Gets the value of a boolean attribute. If the attribute does not\n contain a boolean value, FALSE will be returned.\n Params:\n attribute = a file attribute key.\n Returns: the boolean value contained within the attribute.\n\t \n",
"line" : 343}
,
{
"name" : "getAttributeUint32",
"kind" : "function",
"protection" : "public",
"type" : "uint(string attribute)",
"comment" : "\n Gets an unsigned 32-bit integer contained within the attribute. If the\n attribute does not contain an unsigned 32-bit integer, or is invalid,\n 0 will be returned.\n Params:\n attribute = a file attribute key.\n Returns: an unsigned 32-bit integer from the attribute.\n\t \n",
"line" : 357}
,
{
"name" : "getAttributeInt32",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute)",
"comment" : "\n Gets a signed 32-bit integer contained within the attribute. If the\n attribute does not contain a signed 32-bit integer, or is invalid,\n 0 will be returned.\n Params:\n attribute = a file attribute key.\n Returns: a signed 32-bit integer from the attribute.\n\t \n",
"line" : 371}
,
{
"name" : "getAttributeUint64",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string attribute)",
"comment" : "\n Gets a unsigned 64-bit integer contained within the attribute. If the\n attribute does not contain an unsigned 64-bit integer, or is invalid,\n 0 will be returned.\n Params:\n attribute = a file attribute key.\n Returns: a unsigned 64-bit integer from the attribute.\n\t \n",
"line" : 385}
,
{
"name" : "getAttributeInt64",
"kind" : "function",
"protection" : "public",
"type" : "long(string attribute)",
"comment" : "\n Gets a signed 64-bit integer contained within the attribute. If the\n attribute does not contain an signed 64-bit integer, or is invalid,\n 0 will be returned.\n Params:\n attribute = a file attribute key.\n Returns: a signed 64-bit integer from the attribute.\n\t \n",
"line" : 399}
,
{
"name" : "getAttributeObject",
"kind" : "function",
"protection" : "public",
"type" : "ObjectG(string attribute)",
"comment" : "\n Gets the value of a GObject attribute. If the attribute does\n not contain a GObject, NULL will be returned.\n Params:\n attribute = a file attribute key.\n Returns: a GObject associated with the given attribute, or NULL otherwise. [transfer none]\n\t \n",
"line" : 412}
,
{
"name" : "setAttribute",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, GFileAttributeType type, void* valueP)",
"comment" : "\n Sets the attribute to contain the given value, if possible.\n Params:\n attribute = a file attribute key.\n type = a GFileAttributeType\n valueP = pointer to the value\n\t \n",
"line" : 430}
,
{
"name" : "setAttributeStatus",
"kind" : "function",
"protection" : "public",
"type" : "int(string attribute, GFileAttributeStatus status)",
"comment" : "\n Sets the attribute status for an attribute key. This is only\n needed by external code that implement g_file_set_attributes_from_info()\n or similar functions.\n The attribute must exist in info for this to work. Otherwise FALSE\n is returned and info is unchanged.\n Since 2.22\n Params:\n attribute = a file attribute key\n status = a GFileAttributeStatus\n Returns: TRUE if the status was changed, FALSE if the key was not set.\n\t \n",
"line" : 448}
,
{
"name" : "setAttributeString",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, string attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = a string.\n\t \n",
"line" : 461}
,
{
"name" : "setAttributeStringv",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, string[] attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Sinze: 2.22\n Params:\n attribute = a file attribute key.\n attrValue = a NULL terminated string array\n\t \n",
"line" : 475}
,
{
"name" : "setAttributeByteString",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, string attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = a byte string.\n\t \n",
"line" : 488}
,
{
"name" : "setAttributeBoolean",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, int attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = a boolean value.\n\t \n",
"line" : 501}
,
{
"name" : "setAttributeUint32",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, uint attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = an unsigned 32-bit integer.\n\t \n",
"line" : 514}
,
{
"name" : "setAttributeInt32",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, int attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = a signed 32-bit integer\n\t \n",
"line" : 527}
,
{
"name" : "setAttributeUint64",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, ulong attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = an unsigned 64-bit integer.\n\t \n",
"line" : 540}
,
{
"name" : "setAttributeInt64",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, long attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = attribute name to set.\n attrValue = int64 value to set attribute to.\n\t \n",
"line" : 553}
,
{
"name" : "setAttributeObject",
"kind" : "function",
"protection" : "public",
"type" : "void(string attribute, ObjectG attrValue)",
"comment" : "\n Sets the attribute to contain the given attr_value,\n if possible.\n Params:\n attribute = a file attribute key.\n attrValue = a GObject.\n\t \n",
"line" : 566}
,
{
"name" : "clearStatus",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Clears the status information from info.\n\t \n",
"line" : 575}
,
{
"name" : "getFileType",
"kind" : "function",
"protection" : "public",
"type" : "GFileType()",
"comment" : "\n Gets a file's type (whether it is a regular file, symlink, etc).\n This is different from the file's content type, see g_file_info_get_content_type().\n Returns: a GFileType for the given file.\n\t \n",
"line" : 586}
,
{
"name" : "getIsHidden",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a file is hidden.\n Returns: TRUE if the file is a hidden file, FALSE otherwise.\n\t \n",
"line" : 596}
,
{
"name" : "getIsBackup",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a file is a backup file.\n Returns: TRUE if file is a backup file, FALSE otherwise.\n\t \n",
"line" : 606}
,
{
"name" : "getIsSymlink",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a file is a symlink.\n Returns: TRUE if the given info is a symlink.\n\t \n",
"line" : 616}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name for a file.\n Returns: a string containing the file name.\n\t \n",
"line" : 626}
,
{
"name" : "getDisplayName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets a display name for a file.\n Returns: a string containing the display name.\n\t \n",
"line" : 636}
,
{
"name" : "getEditName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the edit name for a file.\n Returns: a string containing the edit name.\n\t \n",
"line" : 646}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gets the icon for a file.\n Returns: GIcon for the given info. [transfer none]\n\t \n",
"line" : 656}
,
{
"name" : "getContentType",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the file's content type.\n Returns: a string containing the file's content type.\n\t \n",
"line" : 671}
,
{
"name" : "getSize",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n Gets the file's size.\n Returns: a goffset containing the file's size.\n\t \n",
"line" : 681}
,
{
"name" : "getModificationTime",
"kind" : "function",
"protection" : "public",
"type" : "void(TimeVal result)",
"comment" : "\n Gets the modification time of the current info and sets it\n in result.\n Params:\n result = a GTimeVal.\n\t \n",
"line" : 693}
,
{
"name" : "getSymlinkTarget",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the symlink target for a given GFileInfo.\n Returns: a string containing the symlink target.\n\t \n",
"line" : 703}
,
{
"name" : "getEtag",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the entity tag for a given\n GFileInfo. See G_FILE_ATTRIBUTE_ETAG_VALUE.\n Returns: a string containing the value of the \"etag:value\" attribute.\n\t \n",
"line" : 714}
,
{
"name" : "getSortOrder",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the value of the sort_order attribute from the GFileInfo.\n See G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.\n Returns: a gint32 containing the value of the \"standard::sort_order\" attribute.\n\t \n",
"line" : 725}
,
{
"name" : "setAttributeMask",
"kind" : "function",
"protection" : "public",
"type" : "void(FileAttributeMatcher mask)",
"comment" : "\n Sets mask on info to match specific attribute types.\n Params:\n mask = a GFileAttributeMatcher.\n\t \n",
"line" : 736}
,
{
"name" : "unsetAttributeMask",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Unsets a mask set by g_file_info_set_attribute_mask(), if one\n is set.\n\t \n",
"line" : 746}
,
{
"name" : "setFileType",
"kind" : "function",
"protection" : "public",
"type" : "void(GFileType type)",
"comment" : "\n Sets the file type in a GFileInfo to type.\n See G_FILE_ATTRIBUTE_STANDARD_TYPE.\n Params:\n type = a GFileType.\n\t \n",
"line" : 758}
,
{
"name" : "setIsHidden",
"kind" : "function",
"protection" : "public",
"type" : "void(int isHidden)",
"comment" : "\n Sets the \"is_hidden\" attribute in a GFileInfo according to is_symlink.\n See G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN.\n Params:\n isHidden = a gboolean.\n\t \n",
"line" : 770}
,
{
"name" : "setIsSymlink",
"kind" : "function",
"protection" : "public",
"type" : "void(int isSymlink)",
"comment" : "\n Sets the \"is_symlink\" attribute in a GFileInfo according to is_symlink.\n See G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK.\n Params:\n isSymlink = a gboolean.\n\t \n",
"line" : 782}
,
{
"name" : "setName",
"kind" : "function",
"protection" : "public",
"type" : "void(string name)",
"comment" : "\n Sets the name attribute for the current GFileInfo.\n See G_FILE_ATTRIBUTE_STANDARD_NAME.\n Params:\n name = a string containing a name.\n\t \n",
"line" : 794}
,
{
"name" : "setDisplayName",
"kind" : "function",
"protection" : "public",
"type" : "void(string displayName)",
"comment" : "\n Sets the display name for the current GFileInfo.\n See G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME.\n Params:\n displayName = a string containing a display name.\n\t \n",
"line" : 806}
,
{
"name" : "setEditName",
"kind" : "function",
"protection" : "public",
"type" : "void(string editName)",
"comment" : "\n Sets the edit name for the current file.\n See G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME.\n Params:\n editName = a string containing an edit name.\n\t \n",
"line" : 818}
,
{
"name" : "setIcon",
"kind" : "function",
"protection" : "public",
"type" : "void(IconIF icon)",
"comment" : "\n Sets the icon for a given GFileInfo.\n See G_FILE_ATTRIBUTE_STANDARD_ICON.\n Params:\n icon = a GIcon.\n\t \n",
"line" : 830}
,
{
"name" : "setContentType",
"kind" : "function",
"protection" : "public",
"type" : "void(string contentType)",
"comment" : "\n Sets the content type attribute for a given GFileInfo.\n See G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE.\n Params:\n contentType = a content type. See GContentType.\n\t \n",
"line" : 842}
,
{
"name" : "setSize",
"kind" : "function",
"protection" : "public",
"type" : "void(long size)",
"comment" : "\n Sets the G_FILE_ATTRIBUTE_STANDARD_SIZE attribute in the file info\n to the given size.\n Params:\n size = a goffset containing the file's size.\n\t \n",
"line" : 854}
,
{
"name" : "setModificationTime",
"kind" : "function",
"protection" : "public",
"type" : "void(TimeVal mtime)",
"comment" : "\n Sets the G_FILE_ATTRIBUTE_TIME_MODIFIED attribute in the file\n info to the given time value.\n Params:\n mtime = a GTimeVal.\n\t \n",
"line" : 866}
,
{
"name" : "setSymlinkTarget",
"kind" : "function",
"protection" : "public",
"type" : "void(string symlinkTarget)",
"comment" : "\n Sets the G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET attribute in the file info\n to the given symlink target.\n Params:\n symlinkTarget = a static string containing a path to a symlink target.\n\t \n",
"line" : 878}
,
{
"name" : "setSortOrder",
"kind" : "function",
"protection" : "public",
"type" : "void(int sortOrder)",
"comment" : "\n Sets the sort order attribute in the file info structure. See\n G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER.\n Params:\n sortOrder = a sort order integer.\n\t \n",
"line" : 890}
]
}
]
}
,
{
"name" : "gio.FileInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileInputStream.d",
"members" : [
{
"name" : "FileInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GFileInputStream provides input streams that take their\n content from a file.\n GFileInputStream implements GSeekable, which allows the input\n stream to jump to arbitrary positions in the file, provided the\n filesystem of the file allows it. To find the position of a file\n input stream, use g_seekable_tell(). To find out if a file input\n stream supports seeking, use g_seekable_stream_can_seek().\n To position a file input stream, use g_seekable_seek().\n \n",
"line" : 95,
"base" : "InputStream",
"interfaces" : [
"SeekableIF"],
"members" : [
{
"name" : "gFileInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 99}
,
{
"name" : "getFileInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileInputStream*()",
"line" : 102}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 109}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileInputStream(GFileInputStream* gFileInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 117}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 135}
,
{
"name" : "queryInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(string attributes, Cancellable cancellable)",
"comment" : "\n\t \n\n Queries a file input stream the given attributes. This function blocks\n while querying the stream. For the asynchronous (non-blocking) version\n of this function, see g_file_input_stream_query_info_async(). While the\n stream is blocked, the stream will set the pending flag internally, and\n any other operations on the stream will fail with G_IO_ERROR_PENDING.\n Params:\n attributes = a file attribute query string.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileInfo, or NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 159}
,
{
"name" : "queryInfoAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string attributes, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Queries the stream information asynchronously.\n When the operation is finished callback will be called.\n You can then call g_file_input_stream_query_info_finish()\n to get the result of the operation.\n For the synchronous version of this function,\n see g_file_input_stream_query_info().\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be set\n Params:\n attributes = a file attribute query string.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 196}
,
{
"name" : "queryInfoFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(AsyncResultIF result)",
"comment" : "\n Finishes an asynchronous info query operation.\n Params:\n result = a GAsyncResult.\n Returns: GFileInfo.\n Throws: GException on failure.\n\t \n",
"line" : 209}
]
}
]
}
,
{
"name" : "gio.FileIOStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileIOStream.d",
"members" : [
{
"name" : "FileIOStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GFileIOStream provides io streams that both read and write to the same\n file handle.\n GFileIOStream implements GSeekable, which allows the io\n stream to jump to arbitrary positions in the file and to truncate\n the file, provided the filesystem of the file supports these\n operations.\n To find the position of a file io stream, use\n g_seekable_tell().\n To find out if a file io stream supports seeking, use g_seekable_can_seek().\n To position a file io stream, use g_seekable_seek().\n To find out if a file io stream supports truncating, use\n g_seekable_can_truncate(). To truncate a file io\n stream, use g_seekable_truncate().\n The default implementation of all the GFileIOStream operations\n and the implementation of GSeekable just call into the same operations\n on the output stream.\n \n",
"line" : 103,
"base" : "IOStream",
"interfaces" : [
"SeekableIF"],
"members" : [
{
"name" : "gFileIOStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileIOStream*",
"comment" : " the main Gtk struct \n",
"line" : 107}
,
{
"name" : "getFileIOStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileIOStream*()",
"line" : 110}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 117}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileIOStream(GFileIOStream* gFileIOStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 125}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 143}
,
{
"name" : "getEtag",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n\t \n\n Gets the entity tag for the file when it has been written.\n This must be called after the stream has been written\n and closed, as the etag can change while writing.\n Since 2.22\n Returns: the entity tag for the stream.\n\t \n",
"line" : 162}
,
{
"name" : "queryInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(string attributes, Cancellable cancellable)",
"comment" : "\n Queries a file io stream for the given attributes.\n This function blocks while querying the stream. For the asynchronous\n version of this function, see g_file_io_stream_query_info_async().\n While the stream is blocked, the stream will set the pending flag\n internally, and any other operations on the stream will fail with\n G_IO_ERROR_PENDING.\n Can fail if the stream was already closed (with error being set to\n G_IO_ERROR_CLOSED), the stream has pending operations (with error being\n set to G_IO_ERROR_PENDING), or if querying info is not supported for\n the stream's interface (with error being set to G_IO_ERROR_NOT_SUPPORTED). I\n all cases of failure, NULL will be returned.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be set, and NULL will\n be returned.\n Since 2.22\n Params:\n attributes = a file attribute query string.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileInfo for the stream, or NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 191}
,
{
"name" : "queryInfoAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string attributes, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously queries the stream for a GFileInfo. When completed,\n callback will be called with a GAsyncResult which can be used to\n finish the operation with g_file_io_stream_query_info_finish().\n For the synchronous version of this function, see\n g_file_io_stream_query_info().\n Since 2.22\n Params:\n attributes = a file attribute query string.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 225}
,
{
"name" : "queryInfoFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(AsyncResultIF result)",
"comment" : "\n Finalizes the asynchronous query started\n by g_file_io_stream_query_info_async().\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: A GFileInfo for the finished query.\n Throws: GException on failure.\n\t \n",
"line" : 240}
]
}
]
}
,
{
"name" : "gio.FileMonitor",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileMonitor.d",
"members" : [
{
"name" : "FileMonitor",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Monitors a file or directory for changes.\n To obtain a GFileMonitor for a file or directory, use\n g_file_monitor(), g_file_monitor_file(), or\n g_file_monitor_directory().\n To get informed about changes to the file or directory you are\n monitoring, connect to the \"changed\" signal. The\n signal will be emitted in the thread-default main\n context of the thread that the monitor was created in\n (though if the global default main context is blocked, this may\n cause notifications to be blocked even if the thread-default\n context is still running).\n \n",
"line" : 83,
"base" : "ObjectG",
"members" : [
{
"name" : "gFileMonitor",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileMonitor*",
"comment" : " the main Gtk struct \n",
"line" : 87}
,
{
"name" : "getFileMonitorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileMonitor*()",
"line" : 90}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 97}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileMonitor(GFileMonitor* gFileMonitor)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 105}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 123}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 131}
,
{
"name" : "onChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(File, File, GFileMonitorEvent, FileMonitor)[]",
"line" : 133}
,
{
"name" : "addOnChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(File, File, GFileMonitorEvent, FileMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a file has been changed.\n\t \n",
"line" : 137}
,
{
"name" : "callBackChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GFileMonitor* monitorStruct, GFile* file, GFile* otherFile, GFileMonitorEvent eventType, FileMonitor fileMonitor)",
"line" : 152}
,
{
"name" : "cancel",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Cancels a file monitor.\n Returns: TRUE if monitor was cancelled.\n\t \n",
"line" : 165}
,
{
"name" : "isCancelled",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the monitor is canceled.\n Returns: TRUE if monitor is canceled. FALSE otherwise.\n\t \n",
"line" : 175}
,
{
"name" : "setRateLimit",
"kind" : "function",
"protection" : "public",
"type" : "void(int limitMsecs)",
"comment" : "\n Sets the rate limit to which the monitor will report\n consecutive change events to the same file.\n Params:\n limitMsecs = a integer with the limit in milliseconds to\n poll for changes.\n\t \n",
"line" : 188}
,
{
"name" : "emitEvent",
"kind" : "function",
"protection" : "public",
"type" : "void(File child, File otherFile, GFileMonitorEvent eventType)",
"comment" : "\n Emits the \"changed\" signal if a change\n has taken place. Should be called from file monitor\n implementations only.\n The signal will be emitted from an idle handler (in the thread-default main\n context).\n Params:\n child = a GFile.\n otherFile = a GFile.\n eventType = a set of GFileMonitorEvent flags.\n\t \n",
"line" : 205}
]
}
]
}
,
{
"name" : "gio.FilenameCompleter",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FilenameCompleter.d",
"members" : [
{
"name" : "FilenameCompleter",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Completes partial file and directory names given a partial string by\n looking in the file system for clues. Can return a list of possible\n completion strings for widget implementations.\n \n",
"line" : 74,
"base" : "ObjectG",
"members" : [
{
"name" : "gFilenameCompleter",
"kind" : "variable",
"protection" : "protected",
"type" : "GFilenameCompleter*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getFilenameCompleterStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFilenameCompleter*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FilenameCompleter(GFilenameCompleter* gFilenameCompleter)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 122}
,
{
"name" : "onGotCompletionDataListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(FilenameCompleter)[]",
"line" : 124}
,
{
"name" : "addOnGotCompletionData",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(FilenameCompleter) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the file name completion information comes available.\n\t \n",
"line" : 128}
,
{
"name" : "callBackGotCompletionData",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GFilenameCompleter* arg0Struct, FilenameCompleter filenameCompleter)",
"line" : 143}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FilenameCompleter()",
"comment" : "\n Creates a new filename completer.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 156}
,
{
"name" : "getCompletionSuffix",
"kind" : "function",
"protection" : "public",
"type" : "string(string initialText)",
"comment" : "\n Obtains a completion for initial_text from completer.\n Params:\n initialText = text to be completed.\n Returns: a completed string, or NULL if no completion exists. This string is not owned by GIO, so remember to g_free() it when finished.\n\t \n",
"line" : 173}
,
{
"name" : "getCompletions",
"kind" : "function",
"protection" : "public",
"type" : "string[](string initialText)",
"comment" : "\n Gets an array of completion strings for a given initial text.\n Params:\n initialText = text to be completed.\n Returns: array of strings with possible completions for initial_text. This array must be freed by g_strfreev() when finished. [array zero-terminated=1][transfer full zero-terminated=1]\n\t \n",
"line" : 185}
,
{
"name" : "setDirsOnly",
"kind" : "function",
"protection" : "public",
"type" : "void(int dirsOnly)",
"comment" : "\n If dirs_only is TRUE, completer will only\n complete directory names, and not file names.\n Params:\n dirsOnly = a gboolean.\n Signal Details\n The \"got-completion-data\" signal\n void user_function (GFilenameCompleter *arg0,\n  gpointer user_data) : Run Last\n Emitted when the file name completion information comes available.\n\t \n",
"line" : 202}
]
}
]
}
,
{
"name" : "gio.FileOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FileOutputStream.d",
"members" : [
{
"name" : "FileOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GFileOutputStream provides output streams that write their\n content to a file.\n GFileOutputStream implements GSeekable, which allows the output\n stream to jump to arbitrary positions in the file and to truncate\n the file, provided the filesystem of the file supports these\n operations.\n To find the position of a file output stream, use g_seekable_tell().\n To find out if a file output stream supports seeking, use\n g_seekable_can_seek().To position a file output stream, use\n g_seekable_seek(). To find out if a file output stream supports\n truncating, use g_seekable_can_truncate(). To truncate a file output\n stream, use g_seekable_truncate().\n \n",
"line" : 99,
"base" : "OutputStream",
"interfaces" : [
"SeekableIF"],
"members" : [
{
"name" : "gFileOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GFileOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 103}
,
{
"name" : "getFileOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFileOutputStream*()",
"line" : 106}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FileOutputStream(GFileOutputStream* gFileOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 121}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 139}
,
{
"name" : "queryInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(string attributes, Cancellable cancellable)",
"comment" : "\n\t \n\n Queries a file output stream for the given attributes.\n This function blocks while querying the stream. For the asynchronous\n version of this function, see g_file_output_stream_query_info_async().\n While the stream is blocked, the stream will set the pending flag\n internally, and any other operations on the stream will fail with\n G_IO_ERROR_PENDING.\n Can fail if the stream was already closed (with error being set to\n G_IO_ERROR_CLOSED), the stream has pending operations (with error being\n set to G_IO_ERROR_PENDING), or if querying info is not supported for\n the stream's interface (with error being set to G_IO_ERROR_NOT_SUPPORTED). In\n all cases of failure, NULL will be returned.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be set, and NULL will\n be returned.\n Params:\n attributes = a file attribute query string.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GFileInfo for the stream, or NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 173}
,
{
"name" : "queryInfoAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string attributes, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronously queries the stream for a GFileInfo. When completed,\n callback will be called with a GAsyncResult which can be used to\n finish the operation with g_file_output_stream_query_info_finish().\n For the synchronous version of this function, see\n g_file_output_stream_query_info().\n Params:\n attributes = a file attribute query string.\n ioPriority = the I\/O priority\n  of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 206}
,
{
"name" : "queryInfoFinish",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo(AsyncResultIF result)",
"comment" : "\n Finalizes the asynchronous query started\n by g_file_output_stream_query_info_async().\n Params:\n result = a GAsyncResult.\n Returns: A GFileInfo for the finished query.\n Throws: GException on failure.\n\t \n",
"line" : 220}
,
{
"name" : "getEtag",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the entity tag for the file when it has been written.\n This must be called after the stream has been written\n and closed, as the etag can change while writing.\n Returns: the entity tag for the stream.\n\t \n",
"line" : 245}
]
}
]
}
,
{
"name" : "gio.FilterInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FilterInputStream.d",
"members" : [
{
"name" : "FilterInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Base class for input stream implementations that perform some\n kind of filtering operation on a base stream. Typical examples\n of filtering operations are character set conversion, compression\n and byte order flipping.\n \n",
"line" : 74,
"base" : "InputStream",
"members" : [
{
"name" : "gFilterInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GFilterInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getFilterInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFilterInputStream*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FilterInputStream(GFilterInputStream* gFilterInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "getBaseStream",
"kind" : "function",
"protection" : "public",
"type" : "InputStream()",
"comment" : "\n\t \n\n Gets the base stream for the filter stream.\n Returns: a GInputStream. [transfer none]\n\t \n",
"line" : 127}
,
{
"name" : "getCloseBaseStream",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the base stream will be closed when stream is\n closed.\n Returns: TRUE if the base stream will be closed.\n\t \n",
"line" : 143}
,
{
"name" : "setCloseBaseStream",
"kind" : "function",
"protection" : "public",
"type" : "void(int closeBase)",
"comment" : "\n Sets whether the base stream will be closed when stream is closed.\n Params:\n closeBase = TRUE to close the base stream.\n\t \n",
"line" : 154}
]
}
]
}
,
{
"name" : "gio.FilterOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/FilterOutputStream.d",
"members" : [
{
"name" : "FilterOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Base class for output stream implementations that perform some\n kind of filtering operation on a base stream. Typical examples\n of filtering operations are character set conversion, compression\n and byte order flipping.\n \n",
"line" : 74,
"base" : "OutputStream",
"members" : [
{
"name" : "gFilterOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GFilterOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getFilterOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GFilterOutputStream*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "FilterOutputStream(GFilterOutputStream* gFilterOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "getBaseStream",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream()",
"comment" : "\n\t \n\n Gets the base stream for the filter stream.\n Returns: a GOutputStream. [transfer none]\n\t \n",
"line" : 127}
,
{
"name" : "getCloseBaseStream",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the base stream will be closed when stream is\n closed.\n Returns: TRUE if the base stream will be closed.\n\t \n",
"line" : 143}
,
{
"name" : "setCloseBaseStream",
"kind" : "function",
"protection" : "public",
"type" : "void(int closeBase)",
"comment" : "\n Sets whether the base stream will be closed when stream is closed.\n Params:\n closeBase = TRUE to close the base stream.\n\t \n",
"line" : 154}
]
}
]
}
,
{
"name" : "gio.Icon",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Icon.d",
"members" : [
{
"name" : "Icon",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"IconIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Icon(GIcon* gIcon)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.IconIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IconIF.d",
"members" : [
{
"name" : "IconIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GIcon is a very minimal interface for icons. It provides functions\n for checking the equality of two icons, hashing of icons and\n serializing an icon to and from strings.\n GIcon does not provide the actual pixmap for the icon as this is out\n of GIO's scope, however implementations of GIcon may contain the name\n of an icon (see GThemedIcon), or the path to an icon (see GLoadableIcon).\n To obtain a hash of a GIcon, see g_icon_hash().\n To check if two GIcons are equal, see g_icon_equal().\n For serializing a GIcon, use g_icon_to_string() and\n g_icon_new_for_string().\n If your application or library provides one or more GIcon\n implementations you need to ensure that each GType is registered\n with the type system prior to calling g_icon_new_for_string().\n \n",
"line" : 88,
"members" : [
{
"name" : "getIconTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIcon*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 94}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* icon)",
"comment" : "\n\t \n\n Gets a hash for an icon.\n Params:\n icon = gconstpointer to an icon object.\n Returns: a guint containing a hash for the icon, suitable for use in a GHashTable or similar data structure.\n\t \n",
"line" : 106}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(GIcon* icon2)",
"comment" : "\n Checks if two icons are equal.\n Params:\n icon2 = pointer to the second GIcon.\n Returns: TRUE if icon1 is equal to icon2. FALSE otherwise.\n\t \n",
"line" : 114}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Generates a textual representation of icon that can be used for\n serialization such as when passing icon to a different process or\n saving it to persistent storage. Use g_icon_new_for_string() to\n get icon back from the returned string.\n The encoding of the returned string is proprietary to GIcon except\n in the following two cases\n  If icon is a GFileIcon, the returned string is a native path\n  (such as \/path\/to\/my icon.png) without escaping\n  if the GFile for icon is a native file. If the file is not\n  native, the returned string is the result of g_file_get_uri()\n  (such as sftp:\/\/path\/to\/my%20icon.png).\n  If icon is a GThemedIcon with exactly one name, the encoding is\n  simply the name (such as network-server).\n Since 2.20\n Returns: An allocated NUL-terminated UTF8 string or NULL if icon can't be serialized. Use g_free() to free.\n\t \n",
"line" : 133}
]
}
]
}
,
{
"name" : "gio.IconT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IconT.d",
"members" : [
{
"name" : "IconT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GIcon is a very minimal interface for icons. It provides functions\n for checking the equality of two icons, hashing of icons and\n serializing an icon to and from strings.\n GIcon does not provide the actual pixmap for the icon as this is out\n of GIO's scope, however implementations of GIcon may contain the name\n of an icon (see GThemedIcon), or the path to an icon (see GLoadableIcon).\n To obtain a hash of a GIcon, see g_icon_hash().\n To check if two GIcons are equal, see g_icon_equal().\n For serializing a GIcon, use g_icon_to_string() and\n g_icon_new_for_string().\n If your application or library provides one or more GIcon\n implementations you need to ensure that each GType is registered\n with the type system prior to calling g_icon_new_for_string().\n \n",
"line" : 88,
"members" : [
{
"name" : "gIcon",
"kind" : "variable",
"type" : "GIcon*",
"comment" : " the main Gtk struct \n",
"line" : 92}
,
{
"name" : "getIconTStruct",
"kind" : "function",
"type" : "GIcon*()",
"line" : 95}
,
{
"name" : "hash",
"kind" : "function",
"type" : "uint(void* icon)",
"comment" : "\n\t \n\n Gets a hash for an icon.\n Params:\n icon = gconstpointer to an icon object.\n Returns: a guint containing a hash for the icon, suitable for use in a GHashTable or similar data structure.\n\t \n",
"line" : 110}
,
{
"name" : "equal",
"kind" : "function",
"type" : "int(GIcon* icon2)",
"comment" : "\n Checks if two icons are equal.\n Params:\n icon2 = pointer to the second GIcon.\n Returns: TRUE if icon1 is equal to icon2. FALSE otherwise.\n\t \n",
"line" : 122}
,
{
"name" : "toString",
"kind" : "function",
"type" : "string()",
"comment" : "\n Generates a textual representation of icon that can be used for\n serialization such as when passing icon to a different process or\n saving it to persistent storage. Use g_icon_new_for_string() to\n get icon back from the returned string.\n The encoding of the returned string is proprietary to GIcon except\n in the following two cases\n  If icon is a GFileIcon, the returned string is a native path\n  (such as \/path\/to\/my icon.png) without escaping\n  if the GFile for icon is a native file. If the file is not\n  native, the returned string is the result of g_file_get_uri()\n  (such as sftp:\/\/path\/to\/my%20icon.png).\n  If icon is a GThemedIcon with exactly one name, the encoding is\n  simply the name (such as network-server).\n Since 2.20\n Returns: An allocated NUL-terminated UTF8 string or NULL if icon can't be serialized. Use g_free() to free.\n\t \n",
"line" : 145}
]
}
]
}
,
{
"name" : "gio.InetAddress",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/InetAddress.d",
"members" : [
{
"name" : "InetAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GInetAddress represents an IPv4 or IPv6 internet address. Use\n g_resolver_lookup_by_name() or g_resolver_lookup_by_name_async() to\n look up the GInetAddress for a hostname. Use\n g_resolver_lookup_by_address() or\n g_resolver_lookup_by_address_async() to look up the hostname for a\n GInetAddress.\n To actually connect to a remote host, you will need a\n GInetSocketAddress (which includes a GInetAddress as well as a\n port number).\n \n",
"line" : 81,
"base" : "ObjectG",
"members" : [
{
"name" : "gInetAddress",
"kind" : "variable",
"protection" : "protected",
"type" : "GInetAddress*",
"comment" : " the main Gtk struct \n",
"line" : 85}
,
{
"name" : "getInetAddressStruct",
"kind" : "function",
"protection" : "public",
"type" : "GInetAddress*()",
"line" : 88}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 95}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InetAddress(GInetAddress* gInetAddress)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 103}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 121}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InetAddress(GSocketFamily family, bool loopback = false)",
"comment" : "\n Creates a GInetAddress for the \"any\" address (unassigned\/\"don't\n care\") for family.\n Since 2.22\n Params:\n family = the address family\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 135}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InetAddress(string string)",
"comment" : "\n\t \n\n Parses string as an IP address and creates a new GInetAddress.\n Since 2.22\n Params:\n string = a string representation of an IP address\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 166}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InetAddress(ubyte[] bytes, GSocketFamily family)",
"comment" : "\n Creates a new GInetAddress from the given family and bytes.\n bytes should be 4 bytes for G_INET_ADDRESS_IPV4 and 16 bytes for\n G_INET_ADDRESS_IPV6.\n Since 2.22\n Params:\n bytes = raw address data\n family = the address family of bytes\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 187}
,
{
"name" : "toBytes",
"kind" : "function",
"protection" : "public",
"type" : "ubyte[]()",
"comment" : "\n Gets the raw binary address data from address.\n Since 2.22\n Returns: a pointer to an internal array of the bytes in address, which should not be modified, stored, or freed. The size of this array can be gotten with g_inet_address_get_native_size().\n\t \n",
"line" : 203}
,
{
"name" : "getNativeSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the size of the native raw binary address for address. This\n is the size of the data that you get from g_inet_address_to_bytes().\n Since 2.22\n Returns: the number of bytes used for the native version of address.\n\t \n",
"line" : 216}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Converts address to string form.\n Since 2.22\n Returns: a representation of address as a string, which should be freed after use.\n\t \n",
"line" : 227}
,
{
"name" : "getFamily",
"kind" : "function",
"protection" : "public",
"type" : "GSocketFamily()",
"comment" : "\n Gets address's family\n Since 2.22\n Returns: address's family\n\t \n",
"line" : 238}
,
{
"name" : "getIsAny",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is the \"any\" address for its family.\n Since 2.22\n Returns: TRUE if address is the \"any\" address for its family.\n\t \n",
"line" : 249}
,
{
"name" : "getIsLoopback",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is the loopback address for its family.\n Since 2.22\n Returns: TRUE if address is the loopback address for its family.\n\t \n",
"line" : 260}
,
{
"name" : "getIsLinkLocal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a link-local address (that is, if it\n identifies a host on a local network that is not connected to the\n Internet).\n Since 2.22\n Returns: TRUE if address is a link-local address.\n\t \n",
"line" : 273}
,
{
"name" : "getIsSiteLocal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a site-local address such as 10.0.0.1\n (that is, the address identifies a host on a local network that can\n not be reached directly from the Internet, but which may have\n outgoing Internet connectivity via a NAT or firewall).\n Since 2.22\n Returns: TRUE if address is a site-local address.\n\t \n",
"line" : 287}
,
{
"name" : "getIsMulticast",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a multicast address.\n Since 2.22\n Returns: TRUE if address is a multicast address.\n\t \n",
"line" : 298}
,
{
"name" : "getIsMcLinkLocal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a link-local multicast address.\n Since 2.22\n Returns: TRUE if address is a link-local multicast address.\n\t \n",
"line" : 309}
,
{
"name" : "getIsMcNodeLocal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a node-local multicast address.\n Since 2.22\n Returns: TRUE if address is a node-local multicast address.\n\t \n",
"line" : 320}
,
{
"name" : "getIsMcSiteLocal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a site-local multicast address.\n Since 2.22\n Returns: TRUE if address is a site-local multicast address.\n\t \n",
"line" : 331}
,
{
"name" : "getIsMcOrgLocal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is an organization-local multicast address.\n Since 2.22\n Returns: TRUE if address is an organization-local multicast address.\n\t \n",
"line" : 342}
,
{
"name" : "getIsMcGlobal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests whether address is a global multicast address.\n Since 2.22\n Returns: TRUE if address is a global multicast address.\n\t \n",
"line" : 353}
]
}
]
}
,
{
"name" : "gio.InetSocketAddress",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/InetSocketAddress.d",
"members" : [
{
"name" : "InetSocketAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n An IPv4 or IPv6 socket address; that is, the combination of a\n GInetAddress and a port number.\n \n",
"line" : 72,
"base" : "SocketAddress",
"members" : [
{
"name" : "gInetSocketAddress",
"kind" : "variable",
"protection" : "protected",
"type" : "GInetSocketAddress*",
"comment" : " the main Gtk struct \n",
"line" : 76}
,
{
"name" : "getInetSocketAddressStruct",
"kind" : "function",
"protection" : "public",
"type" : "GInetSocketAddress*()",
"line" : 79}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 86}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InetSocketAddress(GInetSocketAddress* gInetSocketAddress)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 94}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 112}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InetSocketAddress(InetAddress address, ushort port)",
"comment" : "\n\t \n\n Creates a new GInetSocketAddress for address and port.\n Since 2.22\n Params:\n address = a GInetAddress\n port = a port number\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 129}
,
{
"name" : "getAddress",
"kind" : "function",
"protection" : "public",
"type" : "InetAddress()",
"comment" : "\n Gets address's GInetAddress.\n Since 2.22\n Returns: the GInetAddress for address, which must be g_object_ref()'d if it will be stored\n\t \n",
"line" : 145}
,
{
"name" : "getPort",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Gets address's port.\n Since 2.22\n Returns: the port for address\n\t \n",
"line" : 161}
]
}
]
}
,
{
"name" : "gio.InitableIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/InitableIF.d",
"members" : [
{
"name" : "InitableIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GInitable is implemented by objects that can fail during\n initialization. If an object implements this interface the\n g_initable_init() function must be called as the first thing\n after construction. If g_initable_init() is not called, or if\n it returns an error, all further operations on the object\n should fail, generally with a G_IO_ERROR_NOT_INITIALIZED error.\n Users of objects implementing this are not intended to use\n the interface method directly, instead it will be used automatically\n in various ways. For C applications you generally just call\n g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.\n This will call g_initable_init() under the cover, returning NULL and\n setting a GError on failure.\n For bindings in languages where the native constructor supports\n exceptions the binding could check for objects implemention GInitable\n during normal construction and automatically initialize them, throwing\n an exception on failure.\n \n",
"line" : 95,
"members" : [
{
"name" : "getInitableTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GInitable*()",
"line" : 98}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 101}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n\t \n\n Initializes the object implementing the interface. This must be\n done before any real use of the object after initial construction.\n Implementations may also support cancellation. If cancellable is not NULL,\n then initialization can be cancelled by triggering the cancellable object\n from another thread. If the operation was cancelled, the error\n G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL and\n the object doesn't support cancellable initialization the error\n G_IO_ERROR_NOT_SUPPORTED will be returned.\n If this function is not called, or returns with an error then all\n operations on the object should fail, generally returning the\n error G_IO_ERROR_NOT_INITIALIZED.\n Implementations of this method must be idempotent, i.e. multiple calls\n to this function with the same argument should return the same results.\n Only the first call initializes the object, further calls return the result\n of the first call. This is so that its safe to implement the singleton\n pattern in the GObject constructor function.\n Since 2.22\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 130}
,
{
"name" : "newValist",
"kind" : "function",
"protection" : "public",
"type" : "ObjectG(GType objectType, string firstPropertyName, void* varArgs, Cancellable cancellable)",
"comment" : "\n Helper function for constructing GInitiable object. This is\n similar to g_object_new_valist() but also initializes the object\n and returns NULL, setting an error on failure.\n Since 2.22\n Params:\n objectType = a GType supporting GInitable.\n firstPropertyName = the name of the first property, followed by\n the value, and other property value pairs, and ended by NULL.\n varArgs = The var args list generated from first_property_name.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a newly allocated GObject, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 146}
,
{
"name" : "newv",
"kind" : "function",
"protection" : "public",
"type" : "void*(GType objectType, GParameter[] parameters, Cancellable cancellable)",
"comment" : "\n Helper function for constructing GInitiable object. This is\n similar to g_object_newv() but also initializes the object\n and returns NULL, setting an error on failure.\n Since 2.22\n Params:\n objectType = a GType supporting GInitable.\n parameters = the parameters to use to construct the object\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a newly allocated GObject, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 160}
]
}
]
}
,
{
"name" : "gio.InitableT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/InitableT.d",
"members" : [
{
"name" : "InitableT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GInitable is implemented by objects that can fail during\n initialization. If an object implements this interface the\n g_initable_init() function must be called as the first thing\n after construction. If g_initable_init() is not called, or if\n it returns an error, all further operations on the object\n should fail, generally with a G_IO_ERROR_NOT_INITIALIZED error.\n Users of objects implementing this are not intended to use\n the interface method directly, instead it will be used automatically\n in various ways. For C applications you generally just call\n g_initable_new() directly, or indirectly via a foo_thing_new() wrapper.\n This will call g_initable_init() under the cover, returning NULL and\n setting a GError on failure.\n For bindings in languages where the native constructor supports\n exceptions the binding could check for objects implemention GInitable\n during normal construction and automatically initialize them, throwing\n an exception on failure.\n \n",
"line" : 95,
"members" : [
{
"name" : "gInitable",
"kind" : "variable",
"type" : "GInitable*",
"comment" : " the main Gtk struct \n",
"line" : 99}
,
{
"name" : "getInitableTStruct",
"kind" : "function",
"type" : "GInitable*()",
"line" : 102}
,
{
"name" : "init",
"kind" : "function",
"type" : "int(Cancellable cancellable)",
"comment" : "\n\t \n\n Initializes the object implementing the interface. This must be\n done before any real use of the object after initial construction.\n Implementations may also support cancellation. If cancellable is not NULL,\n then initialization can be cancelled by triggering the cancellable object\n from another thread. If the operation was cancelled, the error\n G_IO_ERROR_CANCELLED will be returned. If cancellable is not NULL and\n the object doesn't support cancellable initialization the error\n G_IO_ERROR_NOT_SUPPORTED will be returned.\n If this function is not called, or returns with an error then all\n operations on the object should fail, generally returning the\n error G_IO_ERROR_NOT_INITIALIZED.\n Implementations of this method must be idempotent, i.e. multiple calls\n to this function with the same argument should return the same results.\n Only the first call initializes the object, further calls return the result\n of the first call. This is so that its safe to implement the singleton\n pattern in the GObject constructor function.\n Since 2.22\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 134}
,
{
"name" : "newValist",
"kind" : "function",
"type" : "ObjectG(GType objectType, string firstPropertyName, void* varArgs, Cancellable cancellable)",
"comment" : "\n Helper function for constructing GInitiable object. This is\n similar to g_object_new_valist() but also initializes the object\n and returns NULL, setting an error on failure.\n Since 2.22\n Params:\n objectType = a GType supporting GInitable.\n firstPropertyName = the name of the first property, followed by\n the value, and other property value pairs, and ended by NULL.\n varArgs = The var args list generated from first_property_name.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a newly allocated GObject, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 163}
,
{
"name" : "newv",
"kind" : "function",
"type" : "void*(GType objectType, GParameter[] parameters, Cancellable cancellable)",
"comment" : "\n Helper function for constructing GInitiable object. This is\n similar to g_object_newv() but also initializes the object\n and returns NULL, setting an error on failure.\n Since 2.22\n Params:\n objectType = a GType supporting GInitable.\n parameters = the parameters to use to construct the object\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a newly allocated GObject, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 194}
]
}
]
}
,
{
"name" : "gio.InputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/InputStream.d",
"members" : [
{
"name" : "InputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GInputStream has functions to read from a stream (g_input_stream_read()),\n to close a stream (g_input_stream_close()) and to skip some content\n (g_input_stream_skip()).\n To copy the content of an input stream to an output stream without\n manually handling the reads and writes, use g_output_stream_splice().\n All of these functions have async variants too.\n \n",
"line" : 83,
"base" : "ObjectG",
"members" : [
{
"name" : "gInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 87}
,
{
"name" : "getInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GInputStream*()",
"line" : 90}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 97}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "InputStream(GInputStream* gInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 105}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 123}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "long(void* buffer, ulong count, Cancellable cancellable)",
"comment" : "\n\t \n\n Tries to read count bytes from the stream into the buffer starting at\n buffer. Will block during this read.\n If count is zero returns zero and does nothing. A value of count\n larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.\n On success, the number of bytes read into the buffer is returned.\n It is not an error if this is not the same as the requested size, as it\n can happen e.g. near the end of a file. Zero is returned on end of file\n (or if count is zero), but never otherwise.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n On error -1 is returned and error is set accordingly.\n Params:\n buffer = a buffer to read data into (which should be at least count bytes long).\n count = the number of bytes that will be read from the stream\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: Number of bytes read, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 154}
,
{
"name" : "readAll",
"kind" : "function",
"protection" : "public",
"type" : "int(void* buffer, ulong count, out ulong bytesRead, Cancellable cancellable)",
"comment" : "\n Tries to read count bytes from the stream into the buffer starting at\n buffer. Will block during this read.\n This function is similar to g_input_stream_read(), except it tries to\n read as many bytes as requested, only stopping on an error or end of stream.\n On a successful read of count bytes, or if we reached the end of the\n stream, TRUE is returned, and bytes_read is set to the number of bytes\n read into buffer.\n If there is an error during the operation FALSE is returned and error\n is set to indicate the error status, bytes_read is updated to contain\n the number of bytes read into buffer before the error occurred.\n Params:\n buffer = a buffer to read data into (which should be at least count bytes long).\n count = the number of bytes that will be read from the stream\n bytesRead = location to store the number of bytes that was read from the stream\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on success, FALSE if there was an error\n Throws: GException on failure.\n\t \n",
"line" : 188}
,
{
"name" : "skip",
"kind" : "function",
"protection" : "public",
"type" : "long(ulong count, Cancellable cancellable)",
"comment" : "\n Tries to skip count bytes from the stream. Will block during the operation.\n This is identical to g_input_stream_read(), from a behaviour standpoint,\n but the bytes that are skipped are not returned to the user. Some\n streams have an implementation that is more efficient than reading the data.\n This function is optional for inherited classes, as the default implementation\n emulates it using read.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n Params:\n count = the number of bytes that will be skipped from the stream\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: Number of bytes skipped, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 221}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Closes the stream, releasing resources related to it.\n Once the stream is closed, all other operations will return G_IO_ERROR_CLOSED.\n Closing a stream multiple times will not return an error.\n Streams will be automatically closed when the last reference\n is dropped, but you might want to call this function to make sure\n resources are released as early as possible.\n Some streams might keep the backing store of the stream (e.g. a file descriptor)\n open after the stream is closed. See the documentation for the individual\n stream for details.\n On failure the first error that happened will be reported, but the close\n operation will finish as much as possible. A stream that failed to\n close will still return G_IO_ERROR_CLOSED for all operations. Still, it\n is important to check and report the error to the user.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Cancelling a close will still leave the stream closed, but some streams\n can use a faster close that doesn't block to e.g. check errors.\n Params:\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on success, FALSE on failure\n Throws: GException on failure.\n\t \n",
"line" : 260}
,
{
"name" : "readAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(void* buffer, ulong count, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Request an asynchronous read of count bytes from the stream into the buffer\n starting at buffer. When the operation is finished callback will be called.\n You can then call g_input_stream_read_finish() to get the result of the\n operation.\n During an async request no other sync and async calls are allowed on stream, and will\n result in G_IO_ERROR_PENDING errors.\n A value of count larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.\n On success, the number of bytes read into the buffer will be passed to the\n callback. It is not an error if this is not the same as the requested size, as it\n can happen e.g. near the end of a file, but generally we try to read\n as many bytes as requested. Zero is returned on end of file\n (or if count is zero), but never otherwise.\n Any outstanding i\/o request with higher priority (lower numerical value) will\n be executed before an outstanding request with lower priority. Default\n priority is G_PRIORITY_DEFAULT.\n The asyncronous methods have a default fallback that uses threads to implement\n asynchronicity, so they are optional for inheriting classes. However, if you\n override one you must override all.\n Params:\n buffer = a buffer to read data into (which should be at least count bytes long).\n count = the number of bytes that will be read from the stream\n ioPriority = the I\/O priority\n of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 303}
,
{
"name" : "readFinish",
"kind" : "function",
"protection" : "public",
"type" : "long(AsyncResultIF result)",
"comment" : "\n Finishes an asynchronous stream read operation.\n Params:\n result = a GAsyncResult.\n Returns: number of bytes read in, or -1 on error.\n Throws: GException on failure.\n\t \n",
"line" : 316}
,
{
"name" : "skipAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong count, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Request an asynchronous skip of count bytes from the stream.\n When the operation is finished callback will be called.\n You can then call g_input_stream_skip_finish() to get the result\n of the operation.\n During an async request no other sync and async calls are allowed,\n and will result in G_IO_ERROR_PENDING errors.\n A value of count larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.\n On success, the number of bytes skipped will be passed to the callback.\n It is not an error if this is not the same as the requested size, as it\n can happen e.g. near the end of a file, but generally we try to skip\n as many bytes as requested. Zero is returned on end of file\n (or if count is zero), but never otherwise.\n Any outstanding i\/o request with higher priority (lower numerical value)\n will be executed before an outstanding request with lower priority.\n Default priority is G_PRIORITY_DEFAULT.\n The asynchronous methods have a default fallback that uses threads to\n implement asynchronicity, so they are optional for inheriting classes.\n However, if you override one, you must override all.\n Params:\n count = the number of bytes that will be skipped from the stream\n ioPriority = the I\/O priority\n of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 358}
,
{
"name" : "skipFinish",
"kind" : "function",
"protection" : "public",
"type" : "long(AsyncResultIF result)",
"comment" : "\n Finishes a stream skip operation.\n Params:\n result = a GAsyncResult.\n Returns: the size of the bytes skipped, or -1 on error.\n Throws: GException on failure.\n\t \n",
"line" : 371}
,
{
"name" : "closeAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Requests an asynchronous closes of the stream, releasing resources related to it.\n When the operation is finished callback will be called.\n You can then call g_input_stream_close_finish() to get the result of the\n operation.\n For behaviour details see g_input_stream_close().\n The asyncronous methods have a default fallback that uses threads to implement\n asynchronicity, so they are optional for inheriting classes. However, if you\n override one you must override all.\n Params:\n ioPriority = the I\/O priority\n of the request.\n cancellable = optional cancellable object\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 402}
,
{
"name" : "closeFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes closing a stream asynchronously, started from g_input_stream_close_async().\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the stream was closed successfully.\n Throws: GException on failure.\n\t \n",
"line" : 415}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if an input stream is closed.\n Returns: TRUE if the stream is closed.\n\t \n",
"line" : 434}
,
{
"name" : "hasPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if an input stream has pending actions.\n Returns: TRUE if stream has pending actions.\n\t \n",
"line" : 444}
,
{
"name" : "setPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Sets stream to have actions pending. If the pending flag is\n already set or stream is closed, it will return FALSE and set\n error.\n Returns: TRUE if pending was previously unset and is now set.\n Throws: GException on failure.\n\t \n",
"line" : 457}
,
{
"name" : "clearPending",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Clears the pending flag on stream.\n\t \n",
"line" : 475}
]
}
]
}
,
{
"name" : "gio.IOExtension",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IOExtension.d",
"members" : [
{
"name" : "IOExtension",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GIOExtensionPoint provides a mechanism for modules to extend the\n functionality of the library or application that loaded it in an\n organized fashion.\n An extension point is identified by a name, and it may optionally\n require that any implementation must by of a certain type (or derived\n thereof). Use g_io_extension_point_register() to register an\n extension point, and g_io_extension_point_set_required_type() to\n set a required type.\n A module can implement an extension point by specifying the GType\n that implements the functionality. Additionally, each implementation\n of an extension point has a name, and a priority. Use\n g_io_extension_point_implement() to implement an extension point.\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n  It is up to the code that registered the extension point how\n  it uses the implementations that have been associated with it.\n  Depending on the use case, it may use all implementations, or\n  only the one with the highest priority, or pick a specific\n  one by name.\n  To avoid opening all modules just to find out what extension\n  points they implement, GIO makes use of a caching mechanism,\n  see gio-querymodules.\n  You are expected to run this command after installing a\n  GIO module.\n \n",
"line" : 95,
"base" : "Object",
"members" : [
{
"name" : "gIOExtension",
"kind" : "variable",
"protection" : "protected",
"type" : "GIOExtension*",
"comment" : " the main Gtk struct \n",
"line" : 98}
,
{
"name" : "getIOExtensionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIOExtension*()",
"line" : 101}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 108}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOExtension(GIOExtension* gIOExtension)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 116}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n\t \n\n Gets the name under which extension was registered.\n Note that the same type may be registered as extension\n for multiple extension points, under different names.\n Returns: the name of extension.\n\t \n",
"line" : 135}
,
{
"name" : "getPriority",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the priority with which extension was registered.\n Returns: the priority of extension\n\t \n",
"line" : 145}
,
{
"name" : "getType",
"kind" : "function",
"protection" : "public",
"type" : "GType()",
"comment" : "\n Gets the type associated with extension.\n Returns: the type of extension\n\t \n",
"line" : 155}
,
{
"name" : "refClass",
"kind" : "function",
"protection" : "public",
"type" : "GTypeClass*()",
"comment" : "\n Gets a reference to the class for the type that is\n associated with extension.\n Returns: the GTypeClass for the type of extension\n\t \n",
"line" : 166}
]
}
]
}
,
{
"name" : "gio.IOExtensionPoint",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IOExtensionPoint.d",
"members" : [
{
"name" : "IOExtensionPoint",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GIOExtensionPoint provides a mechanism for modules to extend the\n functionality of the library or application that loaded it in an\n organized fashion.\n An extension point is identified by a name, and it may optionally\n require that any implementation must by of a certain type (or derived\n thereof). Use g_io_extension_point_register() to register an\n extension point, and g_io_extension_point_set_required_type() to\n set a required type.\n A module can implement an extension point by specifying the GType\n that implements the functionality. Additionally, each implementation\n of an extension point has a name, and a priority. Use\n g_io_extension_point_implement() to implement an extension point.\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n  It is up to the code that registered the extension point how\n  it uses the implementations that have been associated with it.\n  Depending on the use case, it may use all implementations, or\n  only the one with the highest priority, or pick a specific\n  one by name.\n  To avoid opening all modules just to find out what extension\n  points they implement, GIO makes use of a caching mechanism,\n  see gio-querymodules.\n  You are expected to run this command after installing a\n  GIO module.\n \n",
"line" : 100,
"base" : "Object",
"members" : [
{
"name" : "gIOExtensionPoint",
"kind" : "variable",
"protection" : "protected",
"type" : "GIOExtensionPoint*",
"comment" : " the main Gtk struct \n",
"line" : 103}
,
{
"name" : "getIOExtensionPointStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIOExtensionPoint*()",
"line" : 106}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOExtensionPoint(GIOExtensionPoint* gIOExtensionPoint)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 121}
,
{
"name" : "getExtensionByName",
"kind" : "function",
"protection" : "public",
"type" : "IOExtension(string name)",
"comment" : "\n\t \n\n Finds a GIOExtension for an extension point by name.\n Params:\n name = the name of the extension to get\n Returns: the GIOExtension for extension_point that has the given name, or NULL if there is no extension with that name\n\t \n",
"line" : 140}
,
{
"name" : "getExtensions",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets a list of all extensions that implement this extension point.\n The list is sorted by priority, beginning with the highest priority.\n Returns: a GList of GIOExtensions. The list is owned by GIO and should not be modified. [element-type GIOExtension][transfer none GIOExtension]\n\t \n",
"line" : 156}
,
{
"name" : "getRequiredType",
"kind" : "function",
"protection" : "public",
"type" : "GType()",
"comment" : "\n Gets the required type for extension_point.\n Returns: the GType that all implementations must have, or G_TYPE_INVALID if the extension point has no required type\n\t \n",
"line" : 171}
,
{
"name" : "implement",
"kind" : "function",
"protection" : "public",
"type" : "IOExtension(string extensionPointName, GType type, string extensionName, int priority)",
"comment" : "\n Registers type as extension for the extension point with name\n extension_point_name.\n If type has already been registered as an extension for this\n extension point, the existing GIOExtension object is returned.\n Params:\n extensionPointName = the name of the extension point\n type = the GType to register as extension\n extensionName = the name for the extension\n priority = the priority for the extension\n Returns: a GIOExtension object for GType\n\t \n",
"line" : 189}
,
{
"name" : "lookup",
"kind" : "function",
"protection" : "public",
"type" : "IOExtensionPoint(string name)",
"comment" : "\n Looks up an existing extension point.\n Params:\n name = the name of the extension point\n Returns: the GIOExtensionPoint, or NULL if there is no registered extension point with the given name\n\t \n",
"line" : 206}
,
{
"name" : "register",
"kind" : "function",
"protection" : "public",
"type" : "IOExtensionPoint(string name)",
"comment" : "\n Registers an extension point.\n Params:\n name = The name of the extension point\n Returns: the new GIOExtensionPoint. This object is owned by GIO and should not be freed\n\t \n",
"line" : 223}
,
{
"name" : "setRequiredType",
"kind" : "function",
"protection" : "public",
"type" : "void(GType type)",
"comment" : "\n Sets the required type for extension_point to type.\n All implementations must henceforth have this type.\n Params:\n type = the GType to require\n\t \n",
"line" : 240}
]
}
]
}
,
{
"name" : "gio.IOModule",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IOModule.d",
"members" : [
{
"name" : "IOModule",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Provides an interface and default functions for loading and unloading\n modules. This is used internally to make GIO extensible, but can also\n be used by others to implement module loading.\n \n",
"line" : 76,
"base" : "TypeModule",
"members" : [
{
"name" : "gIOModule",
"kind" : "variable",
"protection" : "protected",
"type" : "GIOModule*",
"comment" : " the main Gtk struct \n",
"line" : 80}
,
{
"name" : "getIOModuleStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIOModule*()",
"line" : 83}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 90}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOModule(GIOModule* gIOModule)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 98}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 116}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOModule(string filename)",
"comment" : "\n\t \n\n Creates a new GIOModule that will load the specific\n shared library when in use.\n Params:\n filename = filename of the shared library module.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 132}
,
{
"name" : "modulesLoadAllInDirectory",
"kind" : "function",
"protection" : "public",
"type" : "ListG(string dirname)",
"comment" : "\n Loads all the modules in the specified directory.\n If don't require all modules to be initialized (and thus registering\n all gtypes) then you can use g_io_modules_scan_all_in_directory()\n which allows delayed\/lazy loading of modules.\n Params:\n dirname = pathname for a directory containing modules to load.\n Returns: a list of GIOModules loaded from the directory, All the modules are loaded into memory, if you want to unload them (enabling on-demand loading) you must call g_type_module_unuse() on all the modules. Free the list with g_list_free().\n\t \n",
"line" : 152}
,
{
"name" : "modulesScanAllInDirectory",
"kind" : "function",
"protection" : "public",
"type" : "void(string dirname)",
"comment" : "\n Scans all the modules in the specified directory, ensuring that\n any extension point implemented by a module is registered.\n This may not actually load and initialize all the types in each\n module, some modules may be lazily loaded and initialized when\n an extension point it implementes is used with e.g.\n g_io_extension_point_get_extensions() or\n g_io_extension_point_get_extension_by_name().\n If you need to guarantee that all types are loaded in all the modules,\n use g_io_modules_scan_all_in_directory().\n Since 2.24\n Params:\n dirname = pathname for a directory containing modules to scan.\n\t \n",
"line" : 177}
,
{
"name" : "load",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Required API for GIO modules to implement.\n This function is ran after the module has been loaded into GIO,\n to initialize the module.\n\t \n",
"line" : 188}
,
{
"name" : "unload",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Required API for GIO modules to implement.\n This function is ran when the module is being unloaded from GIO,\n to finalize the module.\n\t \n",
"line" : 199}
,
{
"name" : "query",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Optional API for GIO modules to implement.\n Should return a list of all the extension points that may be\n implemented in this module.\n This method will not be called in normal use, however it may be\n called when probing existing modules and recording which extension\n points that this modle is used for. This means we won't have to\n load and initialze this module unless its needed.\n If this function is not implemented by the module the module will\n always be loaded, initialized and then unloaded on application startup\n so that it can register its extension points during init.\n Note that a module need not actually implement all the extension points\n that g_io_module_query returns, since the exact list of extension may\n depend on runtime issues. However all extension points actually implemented\n must be returned by g_io_module_query() (if defined).\n When installing a module that implements g_io_module_query you must\n run gio-querymodules in order to build the cache files required for\n lazy loading.\n Since 2.24\n Returns: A NULL-terminated array of strings, listing the supported extension points of the module. The array must be suitable for freeing with g_strfreev().\n\t \n",
"line" : 226}
]
}
]
}
,
{
"name" : "gio.IOSchedulerJob",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IOSchedulerJob.d",
"members" : [
{
"name" : "IOSchedulerJob",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Schedules asynchronous I\/O operations. GIOScheduler integrates\n into the main event loop (GMainLoop) and may use threads if they\n are available.\n Each I\/O operation has a priority, and the scheduler uses the priorities\n to determine the order in which operations are executed. They are\n not used to determine system-wide I\/O scheduling.\n Priorities are integers, with lower numbers indicating higher priority.\n It is recommended to choose priorities between G_PRIORITY_LOW and\n G_PRIORITY_HIGH, with G_PRIORITY_DEFAULT as a default.\n \n",
"line" : 80,
"base" : "Object",
"members" : [
{
"name" : "gIOSchedulerJob",
"kind" : "variable",
"protection" : "protected",
"type" : "GIOSchedulerJob*",
"comment" : " the main Gtk struct \n",
"line" : 83}
,
{
"name" : "getIOSchedulerJobStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIOSchedulerJob*()",
"line" : 86}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 93}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOSchedulerJob(GIOSchedulerJob* gIOSchedulerJob)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 101}
,
{
"name" : "pushJob",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(GIOSchedulerJob*, GCancellable*, void*) jobFunc, void* userData, extern (C) void function(void* cbData) notify, int ioPriority, Cancellable cancellable)",
"comment" : "\n\t \n\n Schedules the I\/O job to run.\n notify will be called on user_data after job_func has returned,\n regardless whether the job was cancelled or has run to completion.\n If cancellable is not NULL, it can be used to cancel the I\/O job\n by calling g_cancellable_cancel() or by calling\n g_io_scheduler_cancel_all_jobs().\n Params:\n jobFunc = a GIOSchedulerJobFunc.\n userData = data to pass to job_func\n notify = a GDestroyNotify for user_data, or NULL\n ioPriority = the I\/O priority\n of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n\t \n",
"line" : 129}
,
{
"name" : "cancelAllJobs",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Cancels all cancellable I\/O jobs.\n A job is cancellable if a GCancellable was passed into\n g_io_scheduler_push_job().\n\t \n",
"line" : 140}
,
{
"name" : "sendToMainloop",
"kind" : "function",
"protection" : "public",
"type" : "int(extern (C) int function(void*) func, void* userData, extern (C) void function(void* cbData) notify)",
"comment" : "\n Used from an I\/O job to send a callback to be run in the thread\n that the job was started from, waiting for the result (and thus\n blocking the I\/O job).\n Params:\n func = a GSourceFunc callback that will be called in the original thread\n userData = data to pass to func\n notify = a GDestroyNotify for user_data, or NULL\n Returns: The return value of func\n\t \n",
"line" : 156}
,
{
"name" : "sendToMainloopAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*) func, void* userData, extern (C) void function(void* cbData) notify)",
"comment" : "\n Used from an I\/O job to send a callback to be run asynchronously in\n the thread that the job was started from. The callback will be run\n when the main loop is available, but at that time the I\/O job might\n have finished. The return value from the callback is ignored.\n Note that if you are passing the user_data from g_io_scheduler_push_job()\n on to this function you have to ensure that it is not freed before\n func is called, either by passing NULL as notify to\n g_io_scheduler_push_job() or by using refcounting for user_data.\n Params:\n func = a GSourceFunc callback that will be called in the original thread\n userData = data to pass to func\n notify = a GDestroyNotify for user_data, or NULL\n\t \n",
"line" : 176}
]
}
]
}
,
{
"name" : "gio.IOStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/IOStream.d",
"members" : [
{
"name" : "IOStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GIOStream represents an object that has both read and write streams.\n Generally the two streams acts as separate input and output streams,\n but they share some common resources and state. For instance, for\n seekable streams they may use the same position in both streams.\n Examples of GIOStream objects are GSocketConnection which represents\n a two-way network connection, and GFileIOStream which represent a\n file handle opened in read-write mode.\n To do the actual reading and writing you need to get the substreams\n with g_io_stream_get_input_stream() and g_io_stream_get_output_stream().\n The GIOStream object owns the input and the output streams, not the other\n way around, so keeping the substreams alive will not keep the GIOStream\n object alive. If the GIOStream object is freed it will be closed, thus\n closing the substream, so even if the substreams stay alive they will\n always just return a G_IO_ERROR_CLOSED for all operations.\n To close a stream use g_io_stream_close() which will close the common\n stream object and also the individual substreams. You can also close\n the substreams themselves. In most cases this only marks the\n substream as closed, so further I\/O on it fails. However, some streams\n may support \"half-closed\" states where one direction of the stream\n is actually shut down.\n \n",
"line" : 103,
"base" : "ObjectG",
"members" : [
{
"name" : "gIOStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GIOStream*",
"comment" : " the main Gtk struct \n",
"line" : 107}
,
{
"name" : "getIOStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIOStream*()",
"line" : 110}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 117}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOStream(GIOStream* gIOStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 125}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 143}
,
{
"name" : "getInputStream",
"kind" : "function",
"protection" : "public",
"type" : "InputStream()",
"comment" : "\n\t \n\n Gets the input stream for this object. This is used\n for reading.\n Since 2.22\n Returns: a GInputStream, owned by the GIOStream. Do not free. [transfer none]\n\t \n",
"line" : 158}
,
{
"name" : "getOutputStream",
"kind" : "function",
"protection" : "public",
"type" : "OutputStream()",
"comment" : "\n Gets the output stream for this object. This is used for\n writing.\n Since 2.22\n Returns: a GOutputStream, owned by the GIOStream. Do not free. [transfer none]\n\t \n",
"line" : 175}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Closes the stream, releasing resources related to it. This will also\n closes the individual input and output streams, if they are not already\n closed.\n Once the stream is closed, all other operations will return\n G_IO_ERROR_CLOSED. Closing a stream multiple times will not\n return an error.\n Closing a stream will automatically flush any outstanding buffers\n in the stream.\n Streams will be automatically closed when the last reference\n is dropped, but you might want to call this function to make sure\n resources are released as early as possible.\n Some streams might keep the backing store of the stream (e.g. a file\n descriptor) open after the stream is closed. See the documentation for\n the individual stream for details.\n On failure the first error that happened will be reported, but the\n close operation will finish as much as possible. A stream that failed\n to close will still return G_IO_ERROR_CLOSED for all operations.\n Still, it is important to check and report the error to the user,\n otherwise there might be a loss of data as all data might not be written.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Cancelling a close will still leave the stream closed, but some streams\n can use a faster close that doesn't block to e.g. check errors.\n The default implementation of this method just calls close on the\n individual input\/output streams.\n Since 2.22\n Params:\n cancellable = optional GCancellable object, NULL to ignore\n Returns: TRUE on success, FALSE on failure\n Throws: GException on failure.\n\t \n",
"line" : 219}
,
{
"name" : "closeAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Requests an asynchronous close of the stream, releasing resources\n related to it. When the operation is finished callback will be\n called. You can then call g_io_stream_close_finish() to get\n the result of the operation.\n For behaviour details see g_io_stream_close().\n The asynchronous methods have a default fallback that uses threads\n to implement asynchronicity, so they are optional for inheriting\n classes. However, if you override one you must override all.\n Since 2.22\n Params:\n ioPriority = the io priority of the request\n cancellable = optional cancellable object\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 250}
,
{
"name" : "closeFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Closes a stream.\n Since 2.22\n Params:\n result = a GAsyncResult\n Returns: TRUE if stream was successfully closed, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 264}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a stream is closed.\n Since 2.22\n Returns: TRUE if the stream is closed.\n\t \n",
"line" : 284}
,
{
"name" : "hasPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a stream has pending actions.\n Since 2.22\n Returns: TRUE if stream has pending actions.\n\t \n",
"line" : 295}
,
{
"name" : "setPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Sets stream to have actions pending. If the pending flag is\n already set or stream is closed, it will return FALSE and set\n error.\n Since 2.22\n Returns: TRUE if pending was previously unset and is now set.\n Throws: GException on failure.\n\t \n",
"line" : 309}
,
{
"name" : "clearPending",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Clears the pending flag on stream.\n Since 2.22\n\t \n",
"line" : 328}
]
}
]
}
,
{
"name" : "gio.LoadableIconIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/LoadableIconIF.d",
"members" : [
{
"name" : "LoadableIconIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n Extends the GIcon interface and adds the ability to\n load icons from streams.\n \n",
"line" : 84,
"members" : [
{
"name" : "getLoadableIconTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GLoadableIcon*()",
"line" : 87}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 90}
,
{
"name" : "load",
"kind" : "function",
"protection" : "public",
"type" : "InputStream(int size, out string type, Cancellable cancellable)",
"comment" : "\n\t \n\n Loads a loadable icon. For the asynchronous version of this function,\n see g_loadable_icon_load_async().\n Params:\n size = an integer.\n type = a location to store the type of the loaded icon, NULL to ignore.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GInputStream to read the icon from.\n Throws: GException on failure.\n\t \n",
"line" : 106}
,
{
"name" : "loadAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int size, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Loads an icon asynchronously. To finish this function, see\n g_loadable_icon_load_finish(). For the synchronous, blocking\n version of this function, see g_loadable_icon_load().\n Params:\n size = an integer.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 118}
,
{
"name" : "loadFinish",
"kind" : "function",
"protection" : "public",
"type" : "InputStream(AsyncResultIF res, out string type)",
"comment" : "\n Finishes an asynchronous icon load started in g_loadable_icon_load_async().\n Params:\n res = a GAsyncResult.\n type = a location to store the type of the loaded icon, NULL to ignore.\n Returns: a GInputStream to read the icon from.\n Throws: GException on failure.\n\t \n",
"line" : 128}
]
}
]
}
,
{
"name" : "gio.LoadableIconT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/LoadableIconT.d",
"members" : [
{
"name" : "LoadableIconT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n Extends the GIcon interface and adds the ability to\n load icons from streams.\n \n",
"line" : 84,
"members" : [
{
"name" : "gLoadableIcon",
"kind" : "variable",
"type" : "GLoadableIcon*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getLoadableIconTStruct",
"kind" : "function",
"type" : "GLoadableIcon*()",
"line" : 91}
,
{
"name" : "load",
"kind" : "function",
"type" : "InputStream(int size, out string type, Cancellable cancellable)",
"comment" : "\n\t \n\n Loads a loadable icon. For the asynchronous version of this function,\n see g_loadable_icon_load_async().\n Params:\n size = an integer.\n type = a location to store the type of the loaded icon, NULL to ignore.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GInputStream to read the icon from.\n Throws: GException on failure.\n\t \n",
"line" : 110}
,
{
"name" : "loadAsync",
"kind" : "function",
"type" : "void(int size, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Loads an icon asynchronously. To finish this function, see\n g_loadable_icon_load_finish(). For the synchronous, blocking\n version of this function, see g_loadable_icon_load().\n Params:\n size = an integer.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 141}
,
{
"name" : "loadFinish",
"kind" : "function",
"type" : "InputStream(AsyncResultIF res, out string type)",
"comment" : "\n Finishes an asynchronous icon load started in g_loadable_icon_load_async().\n Params:\n res = a GAsyncResult.\n type = a location to store the type of the loaded icon, NULL to ignore.\n Returns: a GInputStream to read the icon from.\n Throws: GException on failure.\n\t \n",
"line" : 155}
]
}
]
}
,
{
"name" : "gio.MemoryInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/MemoryInputStream.d",
"members" : [
{
"name" : "MemoryInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GMemoryInputStream is a class for using arbitrary\n memory chunks as input for GIO streaming input operations.\n \n",
"line" : 74,
"base" : "InputStream",
"interfaces" : [
"SeekableIF"],
"members" : [
{
"name" : "gMemoryInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GMemoryInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getMemoryInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMemoryInputStream*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryInputStream(GMemoryInputStream* gMemoryInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryInputStream()",
"comment" : "\n\t \n\n Creates a new empty GMemoryInputStream.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 130}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryInputStream(void* data, long len, extern (C) void function(void* cbData) destroy)",
"comment" : "\n Creates a new GMemoryInputStream with data in memory of a given size.\n Params:\n data = input data\n len = length of the data, may be -1 if data is a nul-terminated string\n destroy = function that is called to free data, or NULL\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 149}
,
{
"name" : "addData",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data, long len, extern (C) void function(void* cbData) destroy)",
"comment" : "\n Appends data to data that can be read from the input stream\n Params:\n data = input data\n len = length of the data, may be -1 if data is a nul-terminated string\n destroy = function that is called to free data, or NULL\n\t \n",
"line" : 167}
]
}
]
}
,
{
"name" : "gio.MemoryOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/MemoryOutputStream.d",
"members" : [
{
"name" : "MemoryOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GMemoryOutputStream is a class for using arbitrary\n memory chunks as output for GIO streaming output operations.\n \n",
"line" : 74,
"base" : "OutputStream",
"interfaces" : [
"SeekableIF"],
"members" : [
{
"name" : "gMemoryOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GMemoryOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getMemoryOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMemoryOutputStream*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryOutputStream(GMemoryOutputStream* gMemoryOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryOutputStream(void* data, ulong size, extern (C) void* function(void* mem, ulong nBytes) reallocFunction, extern (C) void function(void* cbData) destroyFunction)",
"comment" : "\n\t \n\n Creates a new GMemoryOutputStream.\n If data is non-NULL, the stream will use that for its internal storage.\n If realloc_fn is non-NULL, it will be used for resizing the internal\n storage when necessary. To construct a fixed-size output stream,\n pass NULL as realloc_fn.\n $(DDOC_COMMENT example)\n Params:\n data = pointer to a chunk of memory to use, or NULL\n size = the size of data\n reallocFunction = a function with realloc() semantics (like g_realloc())\n  to be called when data needs to be grown, or NULL\n destroyFunction = a function to be called on data when the stream is\n  finalized, or NULL\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 142}
,
{
"name" : "getData",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Gets any loaded data from the ostream.\n Note that the returned pointer may become invalid on the next\n write or truncate operation on the stream.\n Returns: pointer to the stream's data\n\t \n",
"line" : 159}
,
{
"name" : "getSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the size of the currently allocated data area (availible from\n g_memory_output_stream_get_data()). If the stream isn't\n growable (no realloc was passed to g_memory_output_stream_new()) then\n this is the maximum size of the stream and further writes\n will return G_IO_ERROR_NO_SPACE.\n Note that for growable streams the returned size may become invalid on\n the next write or truncate operation on the stream.\n If you want the number of bytes currently written to the stream, use\n g_memory_output_stream_get_data_size().\n Returns: the number of bytes allocated for the data buffer\n\t \n",
"line" : 177}
,
{
"name" : "getDataSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Returns the number of bytes from the start up\n to including the last byte written in the stream\n that has not been truncated away.\n Since 2.18\n Returns: the number of bytes written to the stream\n\t \n",
"line" : 190}
,
{
"name" : "stealData",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Gets any loaded data from the ostream. Ownership of the data\n is transferred to the caller; when no longer needed it must be\n freed using the free function set in ostream's\n \"destroy-function\" property.\n ostream must be closed before calling this function.\n Since 2.26\n Returns: the stream's data. [transfer full]\n\t \n",
"line" : 205}
]
}
]
}
,
{
"name" : "gio.Mount",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Mount.d",
"members" : [
{
"name" : "Mount",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"MountIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Mount(GMount* gMount)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.MountIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/MountIF.d",
"members" : [
{
"name" : "MountIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n The GMount interface represents user-visible mounts. Note, when\n porting from GnomeVFS, GMount is the moral equivalent of GnomeVFSVolume.\n GMount is a \"mounted\" filesystem that you can access. Mounted is in\n quotes because it's not the same as a unix mount, it might be a gvfs\n mount, but you can still access the files on it if you use GIO. Might or\n might not be related to a volume object.\n Unmounting a GMount instance is an asynchronous operation. For\n more information about asynchronous operations, see GAsyncReady\n and GSimpleAsyncReady. To unmount a GMount instance, first call\n g_mount_unmount_with_operation() with (at least) the GMount instance and a\n GAsyncReadyCallback. The callback will be fired when the\n operation has resolved (either with success or failure), and a\n GAsyncReady structure will be passed to the callback. That\n callback should then call g_mount_unmount_with_operation_finish() with the GMount\n and the GAsyncReady data to see if the operation was completed\n successfully. If an error is present when g_mount_unmount_with_operation_finish()\n is called, then it will be filled with any error information.\n \n",
"line" : 121,
"members" : [
{
"name" : "getMountTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMount*()",
"line" : 124}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 127}
,
{
"name" : "onChangedListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(MountIF)[]()",
"comment" : "\n\t \n",
"line" : 133}
,
{
"name" : "addOnChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the mount has been changed.\n\t \n",
"line" : 137}
,
{
"name" : "onPreUnmountListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(MountIF)[]()",
"line" : 138}
,
{
"name" : "addOnPreUnmount",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n This signal is emitted when the GMount is about to be\n unmounted.\n Since 2.22\n\t \n",
"line" : 144}
,
{
"name" : "onUnmountedListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(MountIF)[]()",
"line" : 145}
,
{
"name" : "addOnUnmounted",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n This signal is emitted when the GMount have been\n unmounted. If the recipient is holding references to the\n object they should release them so the object can be\n finalized.\n\t \n",
"line" : 152}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name of mount.\n Returns: the name for the given mount. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 158}
,
{
"name" : "getUuid",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the UUID for the mount. The reference is typically based on\n the file system UUID for the mount in question and should be\n considered an opaque string. Returns NULL if there is no UUID\n available.\n Returns: the UUID for mount or NULL if no UUID can be computed. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 167}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gets the icon for mount.\n Returns: a GIcon. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 173}
,
{
"name" : "getDrive",
"kind" : "function",
"protection" : "public",
"type" : "DriveIF()",
"comment" : "\n Gets the drive for the mount.\n This is a convenience method for getting the GVolume and then\n using that object to get the GDrive.\n Returns: a GDrive or NULL if mount is not associated with a volume or a drive. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 181}
,
{
"name" : "getRoot",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Gets the root directory on mount.\n Returns: a GFile. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 187}
,
{
"name" : "getVolume",
"kind" : "function",
"protection" : "public",
"type" : "VolumeIF()",
"comment" : "\n Gets the volume for the mount.\n Returns: a GVolume or NULL if mount is not associated with a volume. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 193}
,
{
"name" : "getDefaultLocation",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Gets the default location of mount. The default location of the given\n mount is a path that reflects the main entry point for the user (e.g.\n the home directory, or the root of the volume).\n Returns: a GFile. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 201}
,
{
"name" : "canUnmount",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if mount can be mounted.\n Params:\n mount = a GMount.\n Returns: TRUE if the mount can be unmounted.\n\t \n",
"line" : 209}
,
{
"name" : "unmount",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Warning\n g_mount_unmount has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_unmount_with_operation() instead.\n Unmounts a mount. This is an asynchronous operation, and is\n finished by calling g_mount_unmount_finish() with the mount\n and GAsyncResult data returned in the callback.\n Params:\n mount = a GMount.\n flags = flags affecting the operation\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 224}
,
{
"name" : "unmountFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_mount_unmount_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_unmount_with_operation_finish() instead.\n Finishes unmounting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n mount = a GMount.\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully unmounted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 237}
,
{
"name" : "unmountWithOperation",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Unmounts a mount. This is an asynchronous operation, and is\n finished by calling g_mount_unmount_with_operation_finish() with the mount\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n mount = a GMount.\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 252}
,
{
"name" : "unmountWithOperationFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes unmounting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n mount = a GMount.\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully unmounted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 264}
,
{
"name" : "remount",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountMountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Remounts a mount. This is an asynchronous operation, and is\n finished by calling g_mount_remount_finish() with the mount\n and GAsyncResults data returned in the callback.\n Remounting is useful when some setting affecting the operation\n of the volume has been changed, as these may need a remount to\n take affect. While this is semantically equivalent with unmounting\n and then remounting not all backends might need to actually be\n unmounted.\n Params:\n mount = a GMount.\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 283}
,
{
"name" : "remountFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes remounting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n mount = a GMount.\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully remounted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 294}
,
{
"name" : "canEject",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if mount can be eject.\n Returns: TRUE if the mount can be ejected.\n\t \n",
"line" : 300}
,
{
"name" : "eject",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Warning\n g_mount_eject has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_eject_with_operation() instead.\n Ejects a mount. This is an asynchronous operation, and is\n finished by calling g_mount_eject_finish() with the mount\n and GAsyncResult data returned in the callback.\n Params:\n mount = a GMount.\n flags = flags affecting the unmount if required for eject\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 315}
,
{
"name" : "ejectFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_mount_eject_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_eject_with_operation_finish() instead.\n Finishes ejecting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 327}
,
{
"name" : "ejectWithOperation",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Ejects a mount. This is an asynchronous operation, and is\n finished by calling g_mount_eject_with_operation_finish() with the mount\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n mount = a GMount.\n flags = flags affecting the unmount if required for eject\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 342}
,
{
"name" : "ejectWithOperationFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes ejecting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 353}
,
{
"name" : "guessContentType",
"kind" : "function",
"protection" : "public",
"type" : "void(int forceRescan, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Tries to guess the type of content stored on mount. Returns one or\n more textual identifiers of well-known content types (typically\n prefixed with \"x-content\/\"), e.g. x-content\/image-dcf for camera\n memory cards. See the shared-mime-info\n specification for more on x-content types.\n This is an asynchronous operation (see\n g_mount_guess_content_type_sync() for the synchronous version), and\n is finished by calling g_mount_guess_content_type_finish() with the\n mount and GAsyncResult data returned in the callback.\n Since 2.18\n Params:\n forceRescan = Whether to force a rescan of the content.\n  Otherwise a cached result will be used if available\n cancellable = optional GCancellable object, NULL to ignore\n callback = a GAsyncReadyCallback\n userData = user data passed to callback\n\t \n",
"line" : 373}
,
{
"name" : "guessContentTypeFinish",
"kind" : "function",
"protection" : "public",
"type" : "string[](AsyncResultIF result)",
"comment" : "\n Finishes guessing content types of mount. If any errors occured\n during the operation, error will be set to contain the errors and\n FALSE will be returned. In particular, you may get an\n G_IO_ERROR_NOT_SUPPORTED if the mount does not support content\n guessing.\n Since 2.18\n Params:\n result = a GAsyncResult\n Returns: a NULL-terminated array of content types or NULL on error. Caller should free this array with g_strfreev() when done with it.\n Throws: GException on failure.\n\t \n",
"line" : 387}
,
{
"name" : "guessContentTypeSync",
"kind" : "function",
"protection" : "public",
"type" : "string[](int forceRescan, Cancellable cancellable)",
"comment" : "\n Tries to guess the type of content stored on mount. Returns one or\n more textual identifiers of well-known content types (typically\n prefixed with \"x-content\/\"), e.g. x-content\/image-dcf for camera\n memory cards. See the shared-mime-info\n specification for more on x-content types.\n This is an synchronous operation and as such may block doing IO;\n see g_mount_guess_content_type() for the asynchronous version.\n Since 2.18\n Params:\n forceRescan = Whether to force a rescan of the content.\n  Otherwise a cached result will be used if available\n cancellable = optional GCancellable object, NULL to ignore\n Returns: a NULL-terminated array of content types or NULL on error. Caller should free this array with g_strfreev() when done with it.\n Throws: GException on failure.\n\t \n",
"line" : 405}
,
{
"name" : "isShadowed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if mount is shadowed. Applications or libraries should\n avoid displaying mount in the user interface if it is shadowed.\n A mount is said to be shadowed if there exists one or more user\n visible objects (currently GMount objects) with a root that is\n inside the root of mount.\n One application of shadow mounts is when exposing a single file\n system that is used to address several logical volumes. In this\n situation, a GVolumeMonitor implementation would create two\n GVolume objects (for example, one for the camera functionality of\n the device and one for a SD card reader on the device) with\n activation URIs gphoto2:\/\/[usb:001,002]\/store1\/\n and gphoto2:\/\/[usb:001,002]\/store2\/. When the\n underlying mount (with root\n gphoto2:\/\/[usb:001,002]\/) is mounted, said\n GVolumeMonitor implementation would create two GMount objects\n (each with their root matching the corresponding volume activation\n root) that would shadow the original mount.\n The proxy monitor in GVfs 2.26 and later, automatically creates and\n manage shadow mounts (and shadows the underlying mount) if the\n activation root on a GVolume is set.\n Since 2.20\n Returns: TRUE if mount is shadowed.\n\t \n",
"line" : 431}
,
{
"name" : "shadow",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Increments the shadow count on mount. Usually used by\n GVolumeMonitor implementations when creating a shadow mount for\n mount, see g_mount_is_shadowed() for more information. The caller\n will need to emit the \"changed\" signal on mount manually.\n Since 2.20\n\t \n",
"line" : 440}
,
{
"name" : "unshadow",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decrements the shadow count on mount. Usually used by\n GVolumeMonitor implementations when destroying a shadow mount for\n mount, see g_mount_is_shadowed() for more information. The caller\n will need to emit the \"changed\" signal on mount manually.\n Since 2.20\n Signal Details\n The \"changed\" signal\n void user_function (GMount *mount,\n  gpointer user_data) : Run Last\n Emitted when the mount has been changed.\n\t \n",
"line" : 454}
]
}
]
}
,
{
"name" : "gio.MountOperation",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/MountOperation.d",
"members" : [
{
"name" : "MountOperation",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GMountOperation provides a mechanism for interacting with the user.\n It can be used for authenticating mountable operations, such as loop\n mounting files, hard drive partitions or server locations. It can\n also be used to ask the user questions or show a list of applications\n preventing unmount or eject operations from completing.\n Note that GMountOperation is used for more than just GMount\n objects – for example it is also used in g_drive_start() and\n g_drive_stop().\n Users should instantiate a subclass of this that implements all the\n various callbacks to show the required dialogs, such as\n GtkMountOperation. If no user interaction is desired (for example\n when automounting filesystems at login time), usually NULL can be\n passed, see each method taking a GMountOperation for details.\n \n",
"line" : 87,
"base" : "ObjectG",
"members" : [
{
"name" : "gMountOperation",
"kind" : "variable",
"protection" : "protected",
"type" : "GMountOperation*",
"comment" : " the main Gtk struct \n",
"line" : 91}
,
{
"name" : "getMountOperationStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMountOperation*()",
"line" : 94}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 101}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MountOperation(GMountOperation* gMountOperation)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 109}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 127}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 135}
,
{
"name" : "onAbortedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(MountOperation)[]",
"line" : 137}
,
{
"name" : "addOnAborted",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountOperation) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted by the backend when e.g. a device becomes unavailable\n while a mount operation is in progress.\n Implementations of GMountOperation should handle this signal\n by dismissing open password dialogs.\n Since 2.20\n\t \n",
"line" : 145}
,
{
"name" : "callBackAborted",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GMountOperation* arg0Struct, MountOperation mountOperation)",
"line" : 160}
,
{
"name" : "onAskPasswordListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(string, string, string, GAskPasswordFlags, MountOperation)[]",
"line" : 168}
,
{
"name" : "addOnAskPassword",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string, string, string, GAskPasswordFlags, MountOperation) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mount operation asks the user for a password.\n If the message contains a line break, the first line should be\n presented as a heading. For example, it may be used as the\n primary text in a GtkMessageDialog.\n\t \n",
"line" : 175}
,
{
"name" : "callBackAskPassword",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GMountOperation* opStruct, char* message, char* defaultUser, char* defaultDomain, GAskPasswordFlags flags, MountOperation mountOperation)",
"line" : 190}
,
{
"name" : "onAskQuestionListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(string, char***, MountOperation)[]",
"line" : 198}
,
{
"name" : "addOnAskQuestion",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string, char***, MountOperation) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when asking the user a question and gives a list of\n choices for the user to choose from.\n If the message contains a line break, the first line should be\n presented as a heading. For example, it may be used as the\n primary text in a GtkMessageDialog.\n\t \n",
"line" : 206}
,
{
"name" : "callBackAskQuestion",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GMountOperation* opStruct, char* message, char*** choices, MountOperation mountOperation)",
"line" : 221}
,
{
"name" : "onReplyListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(GMountOperationResult, MountOperation)[]",
"line" : 229}
,
{
"name" : "addOnReply",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(GMountOperationResult, MountOperation) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the user has replied to the mount operation.\n\t \n",
"line" : 233}
,
{
"name" : "callBackReply",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GMountOperation* opStruct, GMountOperationResult result, MountOperation mountOperation)",
"line" : 248}
,
{
"name" : "onShowProcessesListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(string, ArrayG, char***, MountOperation)[]",
"line" : 256}
,
{
"name" : "addOnShowProcesses",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string, ArrayG, char***, MountOperation) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when one or more processes are blocking an operation\n e.g. unmounting\/ejecting a GMount or stopping a GDrive.\n Note that this signal may be emitted several times to update the\n list of blocking processes as processes close files. The\n application should only respond with g_mount_operation_reply() to\n the latest signal (setting \"choice\" to the choice\n the user made).\n If the message contains a line break, the first line should be\n presented as a heading. For example, it may be used as the\n primary text in a GtkMessageDialog.\n Since 2.22\n\t \n",
"line" : 270}
,
{
"name" : "callBackShowProcesses",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GMountOperation* opStruct, char* message, GArray* processes, char*** choices, MountOperation mountOperation)",
"line" : 285}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MountOperation()",
"comment" : "\n Creates a new mount operation.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 298}
,
{
"name" : "getUsername",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Get the user name from the mount operation.\n Returns: a string containing the user name.\n\t \n",
"line" : 313}
,
{
"name" : "setUsername",
"kind" : "function",
"protection" : "public",
"type" : "void(string username)",
"comment" : "\n Sets the user name within op to username.\n Params:\n username = input username.\n\t \n",
"line" : 324}
,
{
"name" : "getPassword",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets a password from the mount operation.\n Returns: a string containing the password within op.\n\t \n",
"line" : 334}
,
{
"name" : "setPassword",
"kind" : "function",
"protection" : "public",
"type" : "void(string password)",
"comment" : "\n Sets the mount operation's password to password.\n Params:\n password = password to set.\n\t \n",
"line" : 345}
,
{
"name" : "getAnonymous",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Check to see whether the mount operation is being used\n for an anonymous user.\n Returns: TRUE if mount operation is anonymous.\n\t \n",
"line" : 356}
,
{
"name" : "setAnonymous",
"kind" : "function",
"protection" : "public",
"type" : "void(int anonymous)",
"comment" : "\n Sets the mount operation to use an anonymous user if anonymous is TRUE.\n Params:\n anonymous = boolean value.\n\t \n",
"line" : 367}
,
{
"name" : "getDomain",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the domain of the mount operation.\n Returns: a string set to the domain.\n\t \n",
"line" : 377}
,
{
"name" : "setDomain",
"kind" : "function",
"protection" : "public",
"type" : "void(string domain)",
"comment" : "\n Sets the mount operation's domain.\n Params:\n domain = the domain to set.\n\t \n",
"line" : 388}
,
{
"name" : "getPasswordSave",
"kind" : "function",
"protection" : "public",
"type" : "GPasswordSave()",
"comment" : "\n Gets the state of saving passwords for the mount operation.\n Returns: a GPasswordSave flag.\n\t \n",
"line" : 398}
,
{
"name" : "setPasswordSave",
"kind" : "function",
"protection" : "public",
"type" : "void(GPasswordSave save)",
"comment" : "\n Sets the state of saving passwords for the mount operation.\n Params:\n save = a set of GPasswordSave flags.\n\t \n",
"line" : 409}
,
{
"name" : "getChoice",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets a choice from the mount operation.\n Returns: an integer containing an index of the user's choice from the choice's list, or 0.\n\t \n",
"line" : 419}
,
{
"name" : "setChoice",
"kind" : "function",
"protection" : "public",
"type" : "void(int choice)",
"comment" : "\n Sets a default choice for the mount operation.\n Params:\n choice = an integer.\n\t \n",
"line" : 430}
,
{
"name" : "reply",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountOperationResult result)",
"comment" : "\n Emits the \"reply\" signal.\n Params:\n result = a GMountOperationResult\n\t \n",
"line" : 441}
]
}
]
}
,
{
"name" : "gio.MountT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/MountT.d",
"members" : [
{
"name" : "MountT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n The GMount interface represents user-visible mounts. Note, when\n porting from GnomeVFS, GMount is the moral equivalent of GnomeVFSVolume.\n GMount is a \"mounted\" filesystem that you can access. Mounted is in\n quotes because it's not the same as a unix mount, it might be a gvfs\n mount, but you can still access the files on it if you use GIO. Might or\n might not be related to a volume object.\n Unmounting a GMount instance is an asynchronous operation. For\n more information about asynchronous operations, see GAsyncReady\n and GSimpleAsyncReady. To unmount a GMount instance, first call\n g_mount_unmount_with_operation() with (at least) the GMount instance and a\n GAsyncReadyCallback. The callback will be fired when the\n operation has resolved (either with success or failure), and a\n GAsyncReady structure will be passed to the callback. That\n callback should then call g_mount_unmount_with_operation_finish() with the GMount\n and the GAsyncReady data to see if the operation was completed\n successfully. If an error is present when g_mount_unmount_with_operation_finish()\n is called, then it will be filled with any error information.\n \n",
"line" : 121,
"members" : [
{
"name" : "gMount",
"kind" : "variable",
"type" : "GMount*",
"comment" : " the main Gtk struct \n",
"line" : 125}
,
{
"name" : "getMountTStruct",
"kind" : "function",
"type" : "GMount*()",
"line" : 128}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 136}
,
{
"name" : "_onChangedListeners",
"kind" : "variable",
"type" : "void delegate(MountIF)[]",
"line" : 138}
,
{
"name" : "onChangedListeners",
"kind" : "function",
"type" : "void delegate(MountIF)[]()",
"line" : 139}
,
{
"name" : "addOnChanged",
"kind" : "function",
"type" : "void(void delegate(MountIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n Emitted when the mount has been changed.\n\t \n",
"line" : 146}
,
{
"name" : "callBackChanged",
"kind" : "function",
"type" : "extern (C) void(GMount* mountStruct, MountIF mountIF)",
"line" : 161}
,
{
"name" : "_onPreUnmountListeners",
"kind" : "variable",
"type" : "void delegate(MountIF)[]",
"line" : 169}
,
{
"name" : "onPreUnmountListeners",
"kind" : "function",
"type" : "void delegate(MountIF)[]()",
"line" : 170}
,
{
"name" : "addOnPreUnmount",
"kind" : "function",
"type" : "void(void delegate(MountIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n This signal is emitted when the GMount is about to be\n unmounted.\n Since 2.22\n\t \n",
"line" : 179}
,
{
"name" : "callBackPreUnmount",
"kind" : "function",
"type" : "extern (C) void(GMount* mountStruct, MountIF mountIF)",
"line" : 194}
,
{
"name" : "_onUnmountedListeners",
"kind" : "variable",
"type" : "void delegate(MountIF)[]",
"line" : 202}
,
{
"name" : "onUnmountedListeners",
"kind" : "function",
"type" : "void delegate(MountIF)[]()",
"line" : 203}
,
{
"name" : "addOnUnmounted",
"kind" : "function",
"type" : "void(void delegate(MountIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n This signal is emitted when the GMount have been\n unmounted. If the recipient is holding references to the\n object they should release them so the object can be\n finalized.\n\t \n",
"line" : 213}
,
{
"name" : "callBackUnmounted",
"kind" : "function",
"type" : "extern (C) void(GMount* mountStruct, MountIF mountIF)",
"line" : 228}
,
{
"name" : "getName",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the name of mount.\n Returns: the name for the given mount. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 241}
,
{
"name" : "getUuid",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the UUID for the mount. The reference is typically based on\n the file system UUID for the mount in question and should be\n considered an opaque string. Returns NULL if there is no UUID\n available.\n Returns: the UUID for mount or NULL if no UUID can be computed. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 254}
,
{
"name" : "getIcon",
"kind" : "function",
"type" : "IconIF()",
"comment" : "\n Gets the icon for mount.\n Returns: a GIcon. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 264}
,
{
"name" : "getDrive",
"kind" : "function",
"type" : "DriveIF()",
"comment" : "\n Gets the drive for the mount.\n This is a convenience method for getting the GVolume and then\n using that object to get the GDrive.\n Returns: a GDrive or NULL if mount is not associated with a volume or a drive. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 281}
,
{
"name" : "getRoot",
"kind" : "function",
"type" : "File()",
"comment" : "\n Gets the root directory on mount.\n Returns: a GFile. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 296}
,
{
"name" : "getVolume",
"kind" : "function",
"type" : "VolumeIF()",
"comment" : "\n Gets the volume for the mount.\n Returns: a GVolume or NULL if mount is not associated with a volume. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 311}
,
{
"name" : "getDefaultLocation",
"kind" : "function",
"type" : "File()",
"comment" : "\n Gets the default location of mount. The default location of the given\n mount is a path that reflects the main entry point for the user (e.g.\n the home directory, or the root of the volume).\n Returns: a GFile. The returned object should be unreffed with g_object_unref() when no longer needed.\n\t \n",
"line" : 328}
,
{
"name" : "canUnmount",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if mount can be mounted.\n Params:\n mount = a GMount.\n Returns: TRUE if the mount can be unmounted.\n\t \n",
"line" : 345}
,
{
"name" : "unmount",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Warning\n g_mount_unmount has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_unmount_with_operation() instead.\n Unmounts a mount. This is an asynchronous operation, and is\n finished by calling g_mount_unmount_finish() with the mount\n and GAsyncResult data returned in the callback.\n Params:\n mount = a GMount.\n flags = flags affecting the operation\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 364}
,
{
"name" : "unmountFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_mount_unmount_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_unmount_with_operation_finish() instead.\n Finishes unmounting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n mount = a GMount.\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully unmounted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 381}
,
{
"name" : "unmountWithOperation",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Unmounts a mount. This is an asynchronous operation, and is\n finished by calling g_mount_unmount_with_operation_finish() with the mount\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n mount = a GMount.\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 409}
,
{
"name" : "unmountWithOperationFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes unmounting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n mount = a GMount.\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully unmounted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 425}
,
{
"name" : "remount",
"kind" : "function",
"type" : "void(GMountMountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Remounts a mount. This is an asynchronous operation, and is\n finished by calling g_mount_remount_finish() with the mount\n and GAsyncResults data returned in the callback.\n Remounting is useful when some setting affecting the operation\n of the volume has been changed, as these may need a remount to\n take affect. While this is semantically equivalent with unmounting\n and then remounting not all backends might need to actually be\n unmounted.\n Params:\n mount = a GMount.\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 457}
,
{
"name" : "remountFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes remounting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n mount = a GMount.\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully remounted. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 472}
,
{
"name" : "canEject",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if mount can be eject.\n Returns: TRUE if the mount can be ejected.\n\t \n",
"line" : 491}
,
{
"name" : "eject",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Warning\n g_mount_eject has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_eject_with_operation() instead.\n Ejects a mount. This is an asynchronous operation, and is\n finished by calling g_mount_eject_finish() with the mount\n and GAsyncResult data returned in the callback.\n Params:\n mount = a GMount.\n flags = flags affecting the unmount if required for eject\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 510}
,
{
"name" : "ejectFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_mount_eject_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mount_eject_with_operation_finish() instead.\n Finishes ejecting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 526}
,
{
"name" : "ejectWithOperation",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Ejects a mount. This is an asynchronous operation, and is\n finished by calling g_mount_eject_with_operation_finish() with the mount\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n mount = a GMount.\n flags = flags affecting the unmount if required for eject\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 554}
,
{
"name" : "ejectWithOperationFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes ejecting a mount. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the mount was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 569}
,
{
"name" : "guessContentType",
"kind" : "function",
"type" : "void(int forceRescan, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Tries to guess the type of content stored on mount. Returns one or\n more textual identifiers of well-known content types (typically\n prefixed with \"x-content\/\"), e.g. x-content\/image-dcf for camera\n memory cards. See the shared-mime-info\n specification for more on x-content types.\n This is an asynchronous operation (see\n g_mount_guess_content_type_sync() for the synchronous version), and\n is finished by calling g_mount_guess_content_type_finish() with the\n mount and GAsyncResult data returned in the callback.\n Since 2.18\n Params:\n forceRescan = Whether to force a rescan of the content.\n  Otherwise a cached result will be used if available\n cancellable = optional GCancellable object, NULL to ignore\n callback = a GAsyncReadyCallback\n userData = user data passed to callback\n\t \n",
"line" : 602}
,
{
"name" : "guessContentTypeFinish",
"kind" : "function",
"type" : "string[](AsyncResultIF result)",
"comment" : "\n Finishes guessing content types of mount. If any errors occured\n during the operation, error will be set to contain the errors and\n FALSE will be returned. In particular, you may get an\n G_IO_ERROR_NOT_SUPPORTED if the mount does not support content\n guessing.\n Since 2.18\n Params:\n result = a GAsyncResult\n Returns: a NULL-terminated array of content types or NULL on error. Caller should free this array with g_strfreev() when done with it.\n Throws: GException on failure.\n\t \n",
"line" : 620}
,
{
"name" : "guessContentTypeSync",
"kind" : "function",
"type" : "string[](int forceRescan, Cancellable cancellable)",
"comment" : "\n Tries to guess the type of content stored on mount. Returns one or\n more textual identifiers of well-known content types (typically\n prefixed with \"x-content\/\"), e.g. x-content\/image-dcf for camera\n memory cards. See the shared-mime-info\n specification for more on x-content types.\n This is an synchronous operation and as such may block doing IO;\n see g_mount_guess_content_type() for the asynchronous version.\n Since 2.18\n Params:\n forceRescan = Whether to force a rescan of the content.\n  Otherwise a cached result will be used if available\n cancellable = optional GCancellable object, NULL to ignore\n Returns: a NULL-terminated array of content types or NULL on error. Caller should free this array with g_strfreev() when done with it.\n Throws: GException on failure.\n\t \n",
"line" : 651}
,
{
"name" : "isShadowed",
"kind" : "function",
"type" : "int()",
"comment" : "\n Determines if mount is shadowed. Applications or libraries should\n avoid displaying mount in the user interface if it is shadowed.\n A mount is said to be shadowed if there exists one or more user\n visible objects (currently GMount objects) with a root that is\n inside the root of mount.\n One application of shadow mounts is when exposing a single file\n system that is used to address several logical volumes. In this\n situation, a GVolumeMonitor implementation would create two\n GVolume objects (for example, one for the camera functionality of\n the device and one for a SD card reader on the device) with\n activation URIs gphoto2:\/\/[usb:001,002]\/store1\/\n and gphoto2:\/\/[usb:001,002]\/store2\/. When the\n underlying mount (with root\n gphoto2:\/\/[usb:001,002]\/) is mounted, said\n GVolumeMonitor implementation would create two GMount objects\n (each with their root matching the corresponding volume activation\n root) that would shadow the original mount.\n The proxy monitor in GVfs 2.26 and later, automatically creates and\n manage shadow mounts (and shadows the underlying mount) if the\n activation root on a GVolume is set.\n Since 2.20\n Returns: TRUE if mount is shadowed.\n\t \n",
"line" : 690}
,
{
"name" : "shadow",
"kind" : "function",
"type" : "void()",
"comment" : "\n Increments the shadow count on mount. Usually used by\n GVolumeMonitor implementations when creating a shadow mount for\n mount, see g_mount_is_shadowed() for more information. The caller\n will need to emit the \"changed\" signal on mount manually.\n Since 2.20\n\t \n",
"line" : 703}
,
{
"name" : "unshadow",
"kind" : "function",
"type" : "void()",
"comment" : "\n Decrements the shadow count on mount. Usually used by\n GVolumeMonitor implementations when destroying a shadow mount for\n mount, see g_mount_is_shadowed() for more information. The caller\n will need to emit the \"changed\" signal on mount manually.\n Since 2.20\n Signal Details\n The \"changed\" signal\n void user_function (GMount *mount,\n  gpointer user_data) : Run Last\n Emitted when the mount has been changed.\n\t \n",
"line" : 721}
]
}
]
}
,
{
"name" : "gio.NetworkAddress",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/NetworkAddress.d",
"members" : [
{
"name" : "NetworkAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GNetworkAddress provides an easy way to resolve a hostname and\n then attempt to connect to that host, handling the possibility of\n multiple IP addresses and multiple address families.\n See GSocketConnectable for and example of using the connectable\n interface.\n \n",
"line" : 87,
"base" : "ObjectG",
"interfaces" : [
"SocketConnectableIF"],
"members" : [
{
"name" : "gNetworkAddress",
"kind" : "variable",
"protection" : "protected",
"type" : "GNetworkAddress*",
"comment" : " the main Gtk struct \n",
"line" : 91}
,
{
"name" : "getNetworkAddressStruct",
"kind" : "function",
"protection" : "public",
"type" : "GNetworkAddress*()",
"line" : 94}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 101}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "NetworkAddress(GNetworkAddress* gNetworkAddress)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 109}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 127}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnectableIF(string hostAndPort, ushort defaultPort)",
"comment" : "\n Creates a new GSocketConnectable for connecting to the given\n hostname and port. May fail and return NULL in case\n parsing host_and_port fails.\n host_and_port may be in any of a number of recognised formats: an IPv6\n address, an IPv4 address, or a domain name (in which case a DNS\n lookup is performed). Quoting with [] is supported for all address\n types. A port override may be specified in the usual way with a\n colon. Ports may be given as decimal numbers or symbolic names (in\n which case an \/etc\/services lookup is performed).\n If no port is specified in host_and_port then default_port will be\n used as the port number to connect to.\n In general, host_and_port is expected to be provided by the user\n (allowing them to give the hostname, and a port overide if necessary)\n and default_port is expected to be provided by the application.\n Since 2.22\n Params:\n hostAndPort =  the hostname and optionally a port\n defaultPort =  the default port if not in host_and_port\n Returns: the new GNetworkAddress, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 158}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "NetworkAddress(string hostname, ushort port)",
"comment" : "\n\t \n\n Creates a new GSocketConnectable for connecting to the given\n hostname and port.\n Since 2.22\n Params:\n hostname = the hostname\n port = the port\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 189}
,
{
"name" : "getHostname",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets addr's hostname. This might be either UTF-8 or ASCII-encoded,\n depending on what addr was created with.\n Since 2.22\n Returns: addr's hostname\n\t \n",
"line" : 206}
,
{
"name" : "getPort",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Gets addr's port number\n Since 2.22\n Returns: addr's port (which may be 0)\n\t \n",
"line" : 217}
,
{
"name" : "getScheme",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets addr's scheme\n Since 2.26\n Returns: addr's scheme (NULL if not built from URI)\n\t \n",
"line" : 228}
,
{
"name" : "parseUri",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnectableIF(string uri, ushort defaultPort)",
"comment" : "\n Creates a new GSocketConnectable for connecting to the given\n uri. May fail and return NULL in case parsing uri fails.\n Using this rather than g_network_address_new() or\n g_network_address_parse_host() allows GSocketClient to determine\n when to use application-specific proxy protocols.\n Since 2.26\n Params:\n uri = the hostname and optionally a port\n defaultPort = The default port if none is found in the URI\n Returns: the new GNetworkAddress, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 247}
]
}
]
}
,
{
"name" : "gio.NetworkService",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/NetworkService.d",
"members" : [
{
"name" : "NetworkService",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Like GNetworkAddress does with hostnames, GNetworkService\n provides an easy way to resolve a SRV record, and then attempt to\n connect to one of the hosts that implements that service, handling\n service priority\/weighting, multiple IP addresses, and multiple\n address families.\n See GSrvTarget for more information about SRV records, and see\n GSocketConnectable for and example of using the connectable\n interface.\n \n",
"line" : 82,
"base" : "ObjectG",
"interfaces" : [
"SocketConnectableIF"],
"members" : [
{
"name" : "gNetworkService",
"kind" : "variable",
"protection" : "protected",
"type" : "GNetworkService*",
"comment" : " the main Gtk struct \n",
"line" : 86}
,
{
"name" : "getNetworkServiceStruct",
"kind" : "function",
"protection" : "public",
"type" : "GNetworkService*()",
"line" : 89}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "NetworkService(GNetworkService* gNetworkService)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 104}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 122}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "NetworkService(string service, string protocol, string domain)",
"comment" : "\n\t \n\n Creates a new GNetworkService representing the given service,\n protocol, and domain. This will initially be unresolved; use the\n GSocketConnectable interface to resolve it.\n Since 2.22\n Params:\n service = the service type to look up (eg, \"ldap\")\n protocol = the networking protocol to use for service (eg, \"tcp\")\n domain = the DNS domain to look up the service in\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 145}
,
{
"name" : "getService",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets srv's service name (eg, \"ldap\").\n Since 2.22\n Returns: srv's service name\n\t \n",
"line" : 161}
,
{
"name" : "getProtocol",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets srv's protocol name (eg, \"tcp\").\n Since 2.22\n Returns: srv's protocol name\n\t \n",
"line" : 172}
,
{
"name" : "getDomain",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the domain that srv serves. This might be either UTF-8 or\n ASCII-encoded, depending on what srv was created with.\n Since 2.22\n Returns: srv's domain name\n\t \n",
"line" : 184}
,
{
"name" : "getScheme",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Get's the URI scheme used to resolve proxies. By default, the service name\n is used as scheme.\n Since 2.26\n Returns: srv's scheme name\n\t \n",
"line" : 196}
,
{
"name" : "setScheme",
"kind" : "function",
"protection" : "public",
"type" : "void(string scheme)",
"comment" : "\n Set's the URI scheme used to resolve proxies. By default, the service name\n is used as scheme.\n Since 2.26\n Params:\n scheme = a URI scheme\n\t \n",
"line" : 209}
]
}
]
}
,
{
"name" : "gio.OutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/OutputStream.d",
"members" : [
{
"name" : "OutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GOutputStream has functions to write to a stream (g_output_stream_write()),\n to close a stream (g_output_stream_close()) and to flush pending writes\n (g_output_stream_flush()).\n To copy the content of an input stream to an output stream without\n manually handling the reads and writes, use g_output_stream_splice().\n All of these functions have async variants too.\n \n",
"line" : 86,
"base" : "ObjectG",
"members" : [
{
"name" : "gOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 90}
,
{
"name" : "getOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GOutputStream*()",
"line" : 93}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 100}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OutputStream(GOutputStream* gOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 108}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 126}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "long(void* buffer, ulong count, Cancellable cancellable)",
"comment" : "\n\t \n\n Tries to write count bytes from buffer into the stream. Will block\n during the operation.\n If count is 0, returns 0 and does nothing. A value of count\n larger than G_MAXSSIZE will cause a G_IO_ERROR_INVALID_ARGUMENT error.\n On success, the number of bytes written to the stream is returned.\n It is not an error if this is not the same as the requested size, as it\n can happen e.g. on a partial I\/O error, or if there is not enough\n storage in the stream. All writes block until at least one byte\n is written or an error occurs; 0 is never returned (unless\n count is 0).\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n On error -1 is returned and error is set accordingly.\n Params:\n buffer = the buffer containing the data to write. [array length=count][element-type uint8]\n count = the number of bytes to write\n cancellable = optional cancellable object\n Returns: Number of bytes written, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 159}
,
{
"name" : "writeAll",
"kind" : "function",
"protection" : "public",
"type" : "int(void* buffer, ulong count, ulong* bytesWritten, Cancellable cancellable)",
"comment" : "\n Tries to write count bytes from buffer into the stream. Will block\n during the operation.\n This function is similar to g_output_stream_write(), except it tries to\n write as many bytes as requested, only stopping on an error.\n On a successful write of count bytes, TRUE is returned, and bytes_written\n is set to count.\n If there is an error during the operation FALSE is returned and error\n is set to indicate the error status, bytes_written is updated to contain\n the number of bytes written into the stream before the error occurred.\n Params:\n buffer = the buffer containing the data to write. [array length=count][element-type uint8]\n count = the number of bytes to write\n bytesWritten = location to store the number of bytes that was\n  written to the stream\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE on success, FALSE if there was an error\n Throws: GException on failure.\n\t \n",
"line" : 193}
,
{
"name" : "splice",
"kind" : "function",
"protection" : "public",
"type" : "long(InputStream source, GOutputStreamSpliceFlags flags, Cancellable cancellable)",
"comment" : "\n Splices an input stream into an output stream.\n Params:\n source = a GInputStream.\n flags = a set of GOutputStreamSpliceFlags.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a gssize containing the size of the data spliced, or -1 if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 217}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Flushed any outstanding buffers in the stream. Will block during\n the operation. Closing the stream will implicitly cause a flush.\n This function is optional for inherited classes.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n cancellable = optional cancellable object\n Returns: TRUE on success, FALSE on error\n Throws: GException on failure.\n\t \n",
"line" : 244}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Closes the stream, releasing resources related to it.\n Once the stream is closed, all other operations will return G_IO_ERROR_CLOSED.\n Closing a stream multiple times will not return an error.\n Closing a stream will automatically flush any outstanding buffers in the\n stream.\n Streams will be automatically closed when the last reference\n is dropped, but you might want to call this function to make sure\n resources are released as early as possible.\n Some streams might keep the backing store of the stream (e.g. a file descriptor)\n open after the stream is closed. See the documentation for the individual\n stream for details.\n On failure the first error that happened will be reported, but the close\n operation will finish as much as possible. A stream that failed to\n close will still return G_IO_ERROR_CLOSED for all operations. Still, it\n is important to check and report the error to the user, otherwise\n there might be a loss of data as all data might not be written.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Cancelling a close will still leave the stream closed, but there some streams\n can use a faster close that doesn't block to e.g. check errors. On\n cancellation (as with any error) there is no guarantee that all written\n data will reach the target.\n Params:\n cancellable = optional cancellable object\n Returns: TRUE on success, FALSE on failure\n Throws: GException on failure.\n\t \n",
"line" : 288}
,
{
"name" : "writeAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(void* buffer, ulong count, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Request an asynchronous write of count bytes from buffer into\n the stream. When the operation is finished callback will be called.\n You can then call g_output_stream_write_finish() to get the result of the\n operation.\n During an async request no other sync and async calls are allowed,\n and will result in G_IO_ERROR_PENDING errors.\n A value of count larger than G_MAXSSIZE will cause a\n G_IO_ERROR_INVALID_ARGUMENT error.\n On success, the number of bytes written will be passed to the\n callback. It is not an error if this is not the same as the\n requested size, as it can happen e.g. on a partial I\/O error,\n but generally we try to write as many bytes as requested.\n You are guaranteed that this method will never fail with\n G_IO_ERROR_WOULD_BLOCK - if stream can't accept more data, the\n method will just wait until this changes.\n Any outstanding I\/O request with higher priority (lower numerical\n value) will be executed before an outstanding request with lower\n priority. Default priority is G_PRIORITY_DEFAULT.\n The asyncronous methods have a default fallback that uses threads\n to implement asynchronicity, so they are optional for inheriting\n classes. However, if you override one you must override all.\n For the synchronous, blocking version of this function, see\n g_output_stream_write().\n Params:\n buffer = the buffer containing the data to write. [array length=count][element-type uint8]\n count = the number of bytes to write\n ioPriority = the io priority of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 335}
,
{
"name" : "writeFinish",
"kind" : "function",
"protection" : "public",
"type" : "long(AsyncResultIF result)",
"comment" : "\n Finishes a stream write operation.\n Params:\n result = a GAsyncResult.\n Returns: a gssize containing the number of bytes written to the stream.\n Throws: GException on failure.\n\t \n",
"line" : 348}
,
{
"name" : "spliceAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(InputStream source, GOutputStreamSpliceFlags flags, int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Splices a stream asynchronously.\n When the operation is finished callback will be called.\n You can then call g_output_stream_splice_finish() to get the\n result of the operation.\n For the synchronous, blocking version of this function, see\n g_output_stream_splice().\n Params:\n source = a GInputStream.\n flags = a set of GOutputStreamSpliceFlags.\n ioPriority = the io priority of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback.\n userData = user data passed to callback.\n\t \n",
"line" : 378}
,
{
"name" : "spliceFinish",
"kind" : "function",
"protection" : "public",
"type" : "long(AsyncResultIF result)",
"comment" : "\n Finishes an asynchronous stream splice operation.\n Params:\n result = a GAsyncResult.\n Returns: a gssize of the number of bytes spliced.\n Throws: GException on failure.\n\t \n",
"line" : 391}
,
{
"name" : "flushAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Flushes a stream asynchronously.\n For behaviour details see g_output_stream_flush().\n When the operation is finished callback will be\n called. You can then call g_output_stream_flush_finish() to get the\n result of the operation.\n Params:\n ioPriority = the io priority of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 418}
,
{
"name" : "flushFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes flushing an output stream.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if flush operation suceeded, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 431}
,
{
"name" : "closeAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(int ioPriority, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Requests an asynchronous close of the stream, releasing resources\n related to it. When the operation is finished callback will be\n called. You can then call g_output_stream_close_finish() to get\n the result of the operation.\n For behaviour details see g_output_stream_close().\n The asyncronous methods have a default fallback that uses threads\n to implement asynchronicity, so they are optional for inheriting\n classes. However, if you override one you must override all.\n Params:\n ioPriority = the io priority of the request.\n cancellable = optional cancellable object\n callback = callback to call when the request is satisfied\n userData = the data to pass to callback function\n\t \n",
"line" : 461}
,
{
"name" : "closeFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Closes an output stream.\n Params:\n result = a GAsyncResult.\n Returns: TRUE if stream was successfully closed, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 474}
,
{
"name" : "isClosing",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if an output stream is being closed. This can be\n used inside e.g. a flush implementation to see if the\n flush (or other i\/o operation) is called from within\n the closing operation.\n Since 2.24\n Returns: TRUE if stream is being closed. FALSE otherwise.\n\t \n",
"line" : 497}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if an output stream has already been closed.\n Returns: TRUE if stream is closed. FALSE otherwise.\n\t \n",
"line" : 507}
,
{
"name" : "hasPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if an ouput stream has pending actions.\n Returns: TRUE if stream has pending actions.\n\t \n",
"line" : 517}
,
{
"name" : "setPending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Sets stream to have actions pending. If the pending flag is\n already set or stream is closed, it will return FALSE and set\n error.\n Returns: TRUE if pending was previously unset and is now set.\n Throws: GException on failure.\n\t \n",
"line" : 530}
,
{
"name" : "clearPending",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Clears the pending flag on stream.\n\t \n",
"line" : 548}
]
}
]
}
,
{
"name" : "gio.Permission",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Permission.d",
"members" : [
{
"name" : "Permission",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GPermission represents the status of the caller's permission to\n perform a certain action.\n You can query if the action is currently allowed and if it is\n possible to acquire the permission so that the action will be allowed\n in the future.\n There is also an API to actually acquire the permission and one to\n release it.\n As an example, a GPermission might represent the ability for the\n user to write to a GSettings object. This GPermission object could\n then be used to decide if it is appropriate to show a \"Click here to\n unlock\" button in a dialog and to provide the mechanism to invoke\n when that button is clicked.\n \n",
"line" : 91,
"base" : "ObjectG",
"members" : [
{
"name" : "gPermission",
"kind" : "variable",
"protection" : "protected",
"type" : "GPermission*",
"comment" : " the main Gtk struct \n",
"line" : 95}
,
{
"name" : "getPermissionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GPermission*()",
"line" : 98}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Permission(GPermission* gPermission)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 113}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 131}
,
{
"name" : "getAllowed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n\t \n\n Gets the value of the 'allowed' property. This property is TRUE if\n the caller currently has permission to perform the action that\n permission represents the permission to perform.\n Since 2.26\n Returns: the value of the 'allowed' property\n\t \n",
"line" : 147}
,
{
"name" : "getCanAcquire",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the value of the 'can-acquire' property. This property is TRUE\n if it is generally possible to acquire the permission by calling\n g_permission_acquire().\n Since 2.26\n Returns: the value of the 'can-acquire' property\n\t \n",
"line" : 160}
,
{
"name" : "getCanRelease",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the value of the 'can-release' property. This property is TRUE\n if it is generally possible to release the permission by calling\n g_permission_release().\n Since 2.26\n Returns: the value of the 'can-release' property\n\t \n",
"line" : 173}
,
{
"name" : "acquire",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Attempts to acquire the permission represented by permission.\n The precise method by which this happens depends on the permission\n and the underlying authentication mechanism. A simple example is\n that a dialog may appear asking the user to enter their password.\n You should check with g_permission_get_can_acquire() before calling\n this function.\n If the permission is acquired then TRUE is returned. Otherwise,\n FALSE is returned and error is set appropriately.\n This call is blocking, likely for a very long time (in the case that\n user interaction is required). See g_permission_acquire_async() for\n the non-blocking version.\n Since 2.26\n Params:\n cancellable = a GCancellable, or NULL\n Returns: TRUE if the permission was successfully acquired\n Throws: GException on failure.\n\t \n",
"line" : 197}
,
{
"name" : "acquireAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Attempts to acquire the permission represented by permission.\n This is the first half of the asynchronous version of\n g_permission_acquire().\n Since 2.26\n Params:\n cancellable = a GCancellable, or NULL\n callback = the GAsyncReadyCallback to call when done\n userData = the user data to pass to callback\n\t \n",
"line" : 222}
,
{
"name" : "acquireFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Collects the result of attempting to acquire the permission\n represented by permission.\n This is the second half of the asynchronous version of\n g_permission_acquire().\n Since 2.26\n Params:\n result = the GAsyncResult given to the GAsyncReadyCallback\n Returns: TRUE if the permission was successfully acquired\n Throws: GException on failure.\n\t \n",
"line" : 239}
,
{
"name" : "release",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Attempts to release the permission represented by permission.\n The precise method by which this happens depends on the permission\n and the underlying authentication mechanism. In most cases the\n permission will be dropped immediately without further action.\n You should check with g_permission_get_can_release() before calling\n this function.\n If the permission is released then TRUE is returned. Otherwise,\n FALSE is returned and error is set appropriately.\n This call is blocking, likely for a very long time (in the case that\n user interaction is required). See g_permission_release_async() for\n the non-blocking version.\n Since 2.26\n Params:\n cancellable = a GCancellable, or NULL\n Returns: TRUE if the permission was successfully released\n Throws: GException on failure.\n\t \n",
"line" : 272}
,
{
"name" : "releaseAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Attempts to release the permission represented by permission.\n This is the first half of the asynchronous version of\n g_permission_release().\n Since 2.26\n Params:\n cancellable = a GCancellable, or NULL\n callback = the GAsyncReadyCallback to call when done\n userData = the user data to pass to callback\n\t \n",
"line" : 297}
,
{
"name" : "releaseFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Collects the result of attempting to release the permission\n represented by permission.\n This is the second half of the asynchronous version of\n g_permission_release().\n Since 2.26\n Params:\n result = the GAsyncResult given to the GAsyncReadyCallback\n Returns: TRUE if the permission was successfully released\n Throws: GException on failure.\n\t \n",
"line" : 314}
,
{
"name" : "implUpdate",
"kind" : "function",
"protection" : "public",
"type" : "void(int allowed, int canAcquire, int canRelease)",
"comment" : "\n This function is called by the GPermission implementation to update\n the properties of the permission. You should never call this\n function except from a GPermission implementation.\n GObject notify signals are generated, as appropriate.\n Since 2.26\n Params:\n allowed = the new value for the 'allowed' property\n canAcquire = the new value for the 'can-acquire' property\n canRelease = the new value for the 'can-release' property\n\t \n",
"line" : 340}
]
}
]
}
,
{
"name" : "gio.ProxyAddress",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ProxyAddress.d",
"members" : [
{
"name" : "ProxyAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Support for proxied GInetSocketAddress.\n \n",
"line" : 70,
"base" : "InetSocketAddress",
"members" : [
{
"name" : "gProxyAddress",
"kind" : "variable",
"protection" : "protected",
"type" : "GProxyAddress*",
"comment" : " the main Gtk struct \n",
"line" : 74}
,
{
"name" : "getProxyAddressStruct",
"kind" : "function",
"protection" : "public",
"type" : "GProxyAddress*()",
"line" : 77}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 84}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ProxyAddress(GProxyAddress* gProxyAddress)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 92}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 110}
,
{
"name" : "getDestinationHostname",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n\t \n\n Gets proxy's destination hostname.\n Since 2.26\n Returns: the proxy's destination hostname\n\t \n",
"line" : 124}
,
{
"name" : "getDestinationPort",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Gets proxy's destination port.\n Since 2.26\n Returns: the proxy's destination port\n\t \n",
"line" : 135}
,
{
"name" : "getPassword",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets proxy's password.\n Since 2.26\n Returns: the proxy's password\n\t \n",
"line" : 146}
,
{
"name" : "getProtocol",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets proxy's protocol.\n Since 2.26\n Returns: the proxy's protocol\n\t \n",
"line" : 157}
,
{
"name" : "getUsername",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets proxy's username.\n Since 2.26\n Returns: the proxy's username\n\t \n",
"line" : 168}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ProxyAddress(GInetAddress* inetaddr, ushort port, string protocol, string destHostname, ushort destPort, string username, string password)",
"comment" : "\n Creates a new GProxyAddress for inetaddr with protocol that should\n tunnel through dest_hostname and dest_port.\n Since 2.26\n Params:\n inetaddr = The proxy server GInetAddress.\n port = The proxy server port.\n protocol = The proxy protocol to support, in lower case (e.g. socks, http).\n destHostname = The destination hostname the the proxy should tunnel to.\n destPort = The destination port to tunnel to.\n username = The username to authenticate to the proxy server (or NULL).\n password = The password to authenticate to the proxy server (or NULL).\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 188}
]
}
]
}
,
{
"name" : "gio.Proxy",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Proxy.d",
"members" : [
{
"name" : "Proxy",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"ProxyIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Proxy(GProxy* gProxy)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.ProxyIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ProxyIF.d",
"members" : [
{
"name" : "ProxyIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n A GProxy handles connecting to a remote host via a given type of\n proxy server. It is implemented by the 'gio-proxy' extension point.\n The extensions are named after their proxy protocol name. As an\n example, a SOCKS5 proxy implementation can be retrieved with the\n name 'socks5' using the function\n g_io_extension_point_get_extension_by_name().\n \n",
"line" : 92,
"members" : [
{
"name" : "getProxyTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GProxy*()",
"line" : 95}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "gProxyConnect",
"kind" : "function",
"protection" : "public",
"type" : "IOStream(IOStream connection, ProxyAddress proxyAddress, Cancellable cancellable)",
"comment" : "\n\t \n\n Given connection to communicate with a proxy (eg, a\n GSocketConnection that is connected to the proxy server), this\n does the necessary handshake to connect to proxy_address, and if\n required, wraps the GIOStream to handle proxy payload.\n Since 2.26\n Params:\n proxy = a GProxy\n connection = a GIOStream\n proxyAddress = a GProxyAddress\n cancellable = a GCancellable\n Returns: a GIOStream that will replace connection. This might be the same as connection, in which case a reference will be added.\n Throws: GException on failure.\n\t \n",
"line" : 118}
,
{
"name" : "gProxyConnectAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(IOStream connection, ProxyAddress proxyAddress, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronous version of g_proxy_connect().\n Since 2.26\n Params:\n proxy = a GProxy\n connection = a GIOStream\n proxyAddress = a GProxyAddress\n cancellable = a GCancellable\n callback = a GAsyncReadyCallback\n userData = callback data\n\t \n",
"line" : 131}
,
{
"name" : "gProxyConnectFinish",
"kind" : "function",
"protection" : "public",
"type" : "IOStream(AsyncResultIF result)",
"comment" : "\n See g_proxy_connect().\n Since 2.26\n Params:\n result = a GAsyncRetult\n Returns: a GIOStream.\n Throws: GException on failure.\n\t \n",
"line" : 141}
,
{
"name" : "gProxyGetDefaultForProtocol",
"kind" : "function",
"protection" : "public",
"type" : "ProxyIF(string protocol)",
"comment" : "\n Lookup \"gio-proxy\" extension point for a proxy implementation that supports\n specified protocol.\n Since 2.26\n Params:\n protocol = the proxy protocol name (e.g. http, socks, etc)\n Returns: return a GProxy or NULL if protocol is not supported.\n\t \n",
"line" : 151}
,
{
"name" : "gProxySupportsHostname",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Some proxy protocols expect to be passed a hostname, which they\n will resolve to an IP address themselves. Others, like SOCKS4, do\n not allow this. This function will return FALSE if proxy is\n implementing such a protocol. When FALSE is returned, the caller\n should resolve the destination hostname first, and then pass a\n GProxyAddress containing the stringified IP address to\n g_proxy_connect() or g_proxy_connect_async().\n Since 2.26\n Returns: TRUE if hostname resolution is supported.\n\t \n",
"line" : 164}
]
}
]
}
,
{
"name" : "gio.ProxyResolver",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ProxyResolver.d",
"members" : [
{
"name" : "ProxyResolver",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"ProxyResolverIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ProxyResolver(GProxyResolver* gProxyResolver)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.ProxyResolverIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ProxyResolverIF.d",
"members" : [
{
"name" : "ProxyResolverIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GProxyResolver provides synchronous and asynchronous network proxy\n resolution. GProxyResolver is used within GClientSocket through\n the method g_socket_connectable_proxy_enumerate().\n \n",
"line" : 87,
"members" : [
{
"name" : "getProxyResolverTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GProxyResolver*()",
"line" : 90}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 93}
,
{
"name" : "getDefault",
"kind" : "function",
"protection" : "public",
"type" : "ProxyResolverIF()",
"comment" : "\n\t \n\n Gets the default GProxyResolver for the system.\n Since 2.26\n Returns: the default GProxyResolver.\n\t \n",
"line" : 104}
,
{
"name" : "isSupported",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if resolver can be used on this system. (This is used\n internally; g_proxy_resolver_get_default() will only return a proxy\n resolver that returns TRUE for this method.)\n Since 2.26\n Returns: TRUE if resolver is supported.\n\t \n",
"line" : 113}
,
{
"name" : "lookup",
"kind" : "function",
"protection" : "public",
"type" : "string[](string uri, Cancellable cancellable)",
"comment" : "\n Looks into the system proxy configuration to determine what proxy,\n if any, to use to connect to uri. The returned proxy URIs are of the\n form <protocol>:\/\/[user[:password]@]host:port\n or direct:\/\/, where <protocol> could be\n http, rtsp, socks or other proxying protocol.\n If you don't know what network protocol is being used on the\n socket, you should use none as the URI protocol.\n In this case, the resolver might still return a generic proxy type\n (such as SOCKS), but would not return protocol-specific proxy types\n (such as http).\n direct:\/\/ is used when no proxy is needed.\n Direct connection should not be attempted unless it is part of the\n returned array of proxies.\n Since 2.26\n Params:\n uri = a URI representing the destination to connect to\n cancellable = a GCancellable, or NULL\n Returns: A NULL-terminated array of proxy URIs. Must be freed with g_strfreev().\n Throws: GException on failure.\n\t \n",
"line" : 136}
,
{
"name" : "lookupAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more\n details.\n Since 2.26\n Params:\n uri = a URI representing the destination to connect to\n cancellable = a GCancellable, or NULL\n callback = callback to call after resolution completes\n userData = data for callback\n\t \n",
"line" : 148}
,
{
"name" : "lookupFinish",
"kind" : "function",
"protection" : "public",
"type" : "string[](AsyncResultIF result)",
"comment" : "\n Call this function to obtain the array of proxy URIs when\n g_proxy_resolver_lookup_async() is complete. See\n g_proxy_resolver_lookup() for more details.\n Since 2.26\n Params:\n result = the result passed to your GAsyncReadyCallback\n Returns: A NULL-terminated array of proxy URIs. Must be freed with g_strfreev().\n Throws: GException on failure.\n\t \n",
"line" : 160}
]
}
]
}
,
{
"name" : "gio.ProxyResolverT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ProxyResolverT.d",
"members" : [
{
"name" : "ProxyResolverT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GProxyResolver provides synchronous and asynchronous network proxy\n resolution. GProxyResolver is used within GClientSocket through\n the method g_socket_connectable_proxy_enumerate().\n \n",
"line" : 87,
"members" : [
{
"name" : "gProxyResolver",
"kind" : "variable",
"type" : "GProxyResolver*",
"comment" : " the main Gtk struct \n",
"line" : 91}
,
{
"name" : "getProxyResolverTStruct",
"kind" : "function",
"type" : "GProxyResolver*()",
"line" : 94}
,
{
"name" : "getDefault",
"kind" : "function",
"type" : "ProxyResolverIF()",
"comment" : "\n\t \n\n Gets the default GProxyResolver for the system.\n Since 2.26\n Returns: the default GProxyResolver.\n\t \n",
"line" : 108}
,
{
"name" : "isSupported",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if resolver can be used on this system. (This is used\n internally; g_proxy_resolver_get_default() will only return a proxy\n resolver that returns TRUE for this method.)\n Since 2.26\n Returns: TRUE if resolver is supported.\n\t \n",
"line" : 126}
,
{
"name" : "lookup",
"kind" : "function",
"type" : "string[](string uri, Cancellable cancellable)",
"comment" : "\n Looks into the system proxy configuration to determine what proxy,\n if any, to use to connect to uri. The returned proxy URIs are of the\n form <protocol>:\/\/[user[:password]@]host:port\n or direct:\/\/, where <protocol> could be\n http, rtsp, socks or other proxying protocol.\n If you don't know what network protocol is being used on the\n socket, you should use none as the URI protocol.\n In this case, the resolver might still return a generic proxy type\n (such as SOCKS), but would not return protocol-specific proxy types\n (such as http).\n direct:\/\/ is used when no proxy is needed.\n Direct connection should not be attempted unless it is part of the\n returned array of proxies.\n Since 2.26\n Params:\n uri = a URI representing the destination to connect to\n cancellable = a GCancellable, or NULL\n Returns: A NULL-terminated array of proxy URIs. Must be freed with g_strfreev().\n Throws: GException on failure.\n\t \n",
"line" : 153}
,
{
"name" : "lookupAsync",
"kind" : "function",
"type" : "void(string uri, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Asynchronous lookup of proxy. See g_proxy_resolver_lookup() for more\n details.\n Since 2.26\n Params:\n uri = a URI representing the destination to connect to\n cancellable = a GCancellable, or NULL\n callback = callback to call after resolution completes\n userData = data for callback\n\t \n",
"line" : 178}
,
{
"name" : "lookupFinish",
"kind" : "function",
"type" : "string[](AsyncResultIF result)",
"comment" : "\n Call this function to obtain the array of proxy URIs when\n g_proxy_resolver_lookup_async() is complete. See\n g_proxy_resolver_lookup() for more details.\n Since 2.26\n Params:\n result = the result passed to your GAsyncReadyCallback\n Returns: A NULL-terminated array of proxy URIs. Must be freed with g_strfreev().\n Throws: GException on failure.\n\t \n",
"line" : 194}
]
}
]
}
,
{
"name" : "gio.ProxyT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ProxyT.d",
"members" : [
{
"name" : "ProxyT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n A GProxy handles connecting to a remote host via a given type of\n proxy server. It is implemented by the 'gio-proxy' extension point.\n The extensions are named after their proxy protocol name. As an\n example, a SOCKS5 proxy implementation can be retrieved with the\n name 'socks5' using the function\n g_io_extension_point_get_extension_by_name().\n \n",
"line" : 92,
"members" : [
{
"name" : "gProxy",
"kind" : "variable",
"type" : "GProxy*",
"comment" : " the main Gtk struct \n",
"line" : 96}
,
{
"name" : "getProxyTStruct",
"kind" : "function",
"type" : "GProxy*()",
"line" : 99}
,
{
"name" : "gProxyConnect",
"kind" : "function",
"type" : "IOStream(IOStream connection, ProxyAddress proxyAddress, Cancellable cancellable)",
"comment" : "\n\t \n\n Given connection to communicate with a proxy (eg, a\n GSocketConnection that is connected to the proxy server), this\n does the necessary handshake to connect to proxy_address, and if\n required, wraps the GIOStream to handle proxy payload.\n Since 2.26\n Params:\n proxy = a GProxy\n connection = a GIOStream\n proxyAddress = a GProxyAddress\n cancellable = a GCancellable\n Returns: a GIOStream that will replace connection. This might be the same as connection, in which case a reference will be added.\n Throws: GException on failure.\n\t \n",
"line" : 122}
,
{
"name" : "gProxyConnectAsync",
"kind" : "function",
"type" : "void(IOStream connection, ProxyAddress proxyAddress, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Asynchronous version of g_proxy_connect().\n Since 2.26\n Params:\n proxy = a GProxy\n connection = a GIOStream\n proxyAddress = a GProxyAddress\n cancellable = a GCancellable\n callback = a GAsyncReadyCallback\n userData = callback data\n\t \n",
"line" : 152}
,
{
"name" : "gProxyConnectFinish",
"kind" : "function",
"type" : "IOStream(AsyncResultIF result)",
"comment" : "\n See g_proxy_connect().\n Since 2.26\n Params:\n result = a GAsyncRetult\n Returns: a GIOStream.\n Throws: GException on failure.\n\t \n",
"line" : 166}
,
{
"name" : "gProxyGetDefaultForProtocol",
"kind" : "function",
"type" : "ProxyIF(string protocol)",
"comment" : "\n Lookup \"gio-proxy\" extension point for a proxy implementation that supports\n specified protocol.\n Since 2.26\n Params:\n protocol = the proxy protocol name (e.g. http, socks, etc)\n Returns: return a GProxy or NULL if protocol is not supported.\n\t \n",
"line" : 193}
,
{
"name" : "gProxySupportsHostname",
"kind" : "function",
"type" : "int()",
"comment" : "\n Some proxy protocols expect to be passed a hostname, which they\n will resolve to an IP address themselves. Others, like SOCKS4, do\n not allow this. This function will return FALSE if proxy is\n implementing such a protocol. When FALSE is returned, the caller\n should resolve the destination hostname first, and then pass a\n GProxyAddress containing the stringified IP address to\n g_proxy_connect() or g_proxy_connect_async().\n Since 2.26\n Returns: TRUE if hostname resolution is supported.\n\t \n",
"line" : 215}
]
}
]
}
,
{
"name" : "gio.Resolver",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Resolver.d",
"members" : [
{
"name" : "Resolver",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GResolver provides cancellable synchronous and asynchronous DNS\n resolution, for hostnames (g_resolver_lookup_by_address(),\n g_resolver_lookup_by_name() and their async variants) and SRV\n (service) records (g_resolver_lookup_service()).\n GNetworkAddress and GNetworkService provide wrappers around\n GResolver functionality that also implement GSocketConnectable,\n making it easy to connect to a remote host\/service.\n \n",
"line" : 92,
"base" : "ObjectG",
"members" : [
{
"name" : "gResolver",
"kind" : "variable",
"protection" : "protected",
"type" : "GResolver*",
"comment" : " the main Gtk struct \n",
"line" : 96}
,
{
"name" : "getResolverStruct",
"kind" : "function",
"protection" : "public",
"type" : "GResolver*()",
"line" : 99}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 106}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Resolver(GResolver* gResolver)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 114}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 132}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 140}
,
{
"name" : "onReloadListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(Resolver)[]",
"line" : 142}
,
{
"name" : "addOnReload",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(Resolver) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the resolver notices that the system resolver\n configuration has changed.\n\t \n",
"line" : 147}
,
{
"name" : "callBackReload",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GResolver* resolverStruct, Resolver resolver)",
"line" : 162}
,
{
"name" : "getDefault",
"kind" : "function",
"protection" : "public",
"type" : "Resolver()",
"comment" : "\n Gets the default GResolver. You should unref it when you are done\n with it. GResolver may use its reference count as a hint about how\n many threads\/processes, etc it should allocate for concurrent DNS\n resolutions.\n Since 2.22\n Returns: the default GResolver.\n\t \n",
"line" : 179}
,
{
"name" : "setDefault",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Sets resolver to be the application's default resolver (reffing\n resolver, and unreffing the previous default resolver, if any).\n Future calls to g_resolver_get_default() will return this resolver.\n This can be used if an application wants to perform any sort of DNS\n caching or \"pinning\"; it can implement its own GResolver that\n calls the original default resolver for DNS operations, and\n implements its own cache policies on top of that, and then set\n itself as the default resolver for all later code to use.\n Since 2.22\n\t \n",
"line" : 201}
,
{
"name" : "lookupByName",
"kind" : "function",
"protection" : "public",
"type" : "ListG(string hostname, Cancellable cancellable)",
"comment" : "\n Synchronously resolves hostname to determine its associated IP\n address(es). hostname may be an ASCII-only or UTF-8 hostname, or\n the textual form of an IP address (in which case this just becomes\n a wrapper around g_inet_address_new_from_string()).\n On success, g_resolver_lookup_by_name() will return a GList of\n GInetAddress, sorted in order of preference. (That is, you should\n attempt to connect to the first address first, then the second if\n the first fails, etc.)\n If the DNS resolution fails, error (if non-NULL) will be set to a\n value from GResolverError.\n If cancellable is non-NULL, it can be used to cancel the\n operation, in which case error (if non-NULL) will be set to\n G_IO_ERROR_CANCELLED.\n If you are planning to connect to a socket on the resolved IP\n address, it may be easier to create a GNetworkAddress and use its\n GSocketConnectable interface.\n Since 2.22\n Params:\n hostname = the hostname to look up\n cancellable = a GCancellable, or NULL\n Returns: a GList of GInetAddress, or NULL on error. You must unref each of the addresses and free the list when you are done with it. (You can use g_resolver_free_addresses() to do this.)\n Throws: GException on failure.\n\t \n",
"line" : 231}
,
{
"name" : "lookupByNameAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string hostname, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Begins asynchronously resolving hostname to determine its\n associated IP address(es), and eventually calls callback, which\n must call g_resolver_lookup_by_name_finish() to get the result.\n See g_resolver_lookup_by_name() for more details.\n Since 2.22\n Params:\n hostname = the hostname to look up the address of\n cancellable = a GCancellable, or NULL\n callback = callback to call after resolution completes\n userData = data for callback\n\t \n",
"line" : 262}
,
{
"name" : "lookupByNameFinish",
"kind" : "function",
"protection" : "public",
"type" : "ListG(AsyncResultIF result)",
"comment" : "\n Retrieves the result of a call to\n g_resolver_lookup_by_name_async().\n If the DNS resolution failed, error (if non-NULL) will be set to\n a value from GResolverError. If the operation was cancelled,\n error will be set to G_IO_ERROR_CANCELLED.\n Since 2.22\n Params:\n result = the result passed to your GAsyncReadyCallback\n Returns: a GList of GInetAddress, or NULL on error. See g_resolver_lookup_by_name() for more details.\n Throws: GException on failure.\n\t \n",
"line" : 280}
,
{
"name" : "freeAddresses",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG addresses)",
"comment" : "\n Frees addresses (which should be the return value from\n g_resolver_lookup_by_name() or g_resolver_lookup_by_name_finish()).\n (This is a convenience method; you can also simply free the results\n by hand.)\n Since 2.22\n Params:\n addresses = a GList of GInetAddress\n\t \n",
"line" : 308}
,
{
"name" : "lookupByAddress",
"kind" : "function",
"protection" : "public",
"type" : "string(GInetAddress* address, Cancellable cancellable)",
"comment" : "\n Synchronously reverse-resolves address to determine its\n associated hostname.\n If the DNS resolution fails, error (if non-NULL) will be set to\n a value from GResolverError.\n If cancellable is non-NULL, it can be used to cancel the\n operation, in which case error (if non-NULL) will be set to\n G_IO_ERROR_CANCELLED.\n Since 2.22\n Params:\n address = the address to reverse-resolve\n cancellable = a GCancellable, or NULL\n Returns: a hostname (either ASCII-only, or in ASCII-encoded form), or NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 329}
,
{
"name" : "lookupByAddressAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(GInetAddress* address, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Begins asynchronously reverse-resolving address to determine its\n associated hostname, and eventually calls callback, which must\n call g_resolver_lookup_by_address_finish() to get the final result.\n Since 2.22\n Params:\n address = the address to reverse-resolve\n cancellable = a GCancellable, or NULL\n callback = callback to call after resolution completes\n userData = data for callback\n\t \n",
"line" : 355}
,
{
"name" : "lookupByAddressFinish",
"kind" : "function",
"protection" : "public",
"type" : "string(AsyncResultIF result)",
"comment" : "\n Retrieves the result of a previous call to\n g_resolver_lookup_by_address_async().\n If the DNS resolution failed, error (if non-NULL) will be set to\n a value from GResolverError. If the operation was cancelled,\n error will be set to G_IO_ERROR_CANCELLED.\n Since 2.22\n Params:\n result = the result passed to your GAsyncReadyCallback\n Returns: a hostname (either ASCII-only, or in ASCII-encoded form), or NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 373}
,
{
"name" : "lookupService",
"kind" : "function",
"protection" : "public",
"type" : "ListG(string service, string protocol, string domain, Cancellable cancellable)",
"comment" : "\n Synchronously performs a DNS SRV lookup for the given service and\n protocol in the given domain and returns an array of GSrvTarget.\n domain may be an ASCII-only or UTF-8 hostname. Note also that the\n service and protocol arguments do not\n include the leading underscore that appears in the actual DNS\n entry.\n On success, g_resolver_lookup_service() will return a GList of\n GSrvTarget, sorted in order of preference. (That is, you should\n attempt to connect to the first target first, then the second if\n the first fails, etc.)\n If the DNS resolution fails, error (if non-NULL) will be set to\n a value from GResolverError.\n If cancellable is non-NULL, it can be used to cancel the\n operation, in which case error (if non-NULL) will be set to\n G_IO_ERROR_CANCELLED.\n If you are planning to connect to the service, it is usually easier\n to create a GNetworkService and use its GSocketConnectable\n interface.\n Since 2.22\n Params:\n service = the service type to look up (eg, \"ldap\")\n protocol = the networking protocol to use for service (eg, \"tcp\")\n domain = the DNS domain to look up the service in\n cancellable = a GCancellable, or NULL\n Returns: a GList of GSrvTarget, or NULL on error. You must free each of the targets and the list when you are done with it. (You can use g_resolver_free_targets() to do this.)\n Throws: GException on failure.\n\t \n",
"line" : 416}
,
{
"name" : "lookupServiceAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string service, string protocol, string domain, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Begins asynchronously performing a DNS SRV lookup for the given\n service and protocol in the given domain, and eventually calls\n callback, which must call g_resolver_lookup_service_finish() to\n get the final result. See g_resolver_lookup_service() for more\n details.\n Since 2.22\n Params:\n service = the service type to look up (eg, \"ldap\")\n protocol = the networking protocol to use for service (eg, \"tcp\")\n domain = the DNS domain to look up the service in\n cancellable = a GCancellable, or NULL\n callback = callback to call after resolution completes\n userData = data for callback\n\t \n",
"line" : 450}
,
{
"name" : "lookupServiceFinish",
"kind" : "function",
"protection" : "public",
"type" : "ListG(AsyncResultIF result)",
"comment" : "\n Retrieves the result of a previous call to\n g_resolver_lookup_service_async().\n If the DNS resolution failed, error (if non-NULL) will be set to\n a value from GResolverError. If the operation was cancelled,\n error will be set to G_IO_ERROR_CANCELLED.\n Since 2.22\n Params:\n result = the result passed to your GAsyncReadyCallback\n Returns: a GList of GSrvTarget, or NULL on error. See g_resolver_lookup_service() for more details.\n Throws: GException on failure.\n\t \n",
"line" : 468}
,
{
"name" : "freeTargets",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG targets)",
"comment" : "\n Frees targets (which should be the return value from\n g_resolver_lookup_service() or g_resolver_lookup_service_finish()).\n (This is a convenience method; you can also simply free the\n results by hand.)\n Since 2.22\n Params:\n targets = a GList of GSrvTarget\n\t \n",
"line" : 496}
]
}
]
}
,
{
"name" : "gio.SeekableIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SeekableIF.d",
"members" : [
{
"name" : "SeekableIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n GSeekable is implemented by streams (implementations of\n GInputStream or GOutputStream) that support seeking.\n \n",
"line" : 76,
"members" : [
{
"name" : "getSeekableTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSeekable*()",
"line" : 79}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 82}
,
{
"name" : "tell",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n\t \n\n Tells the current position within the stream.\n Returns: the offset from the beginning of the buffer.\n\t \n",
"line" : 92}
,
{
"name" : "canSeek",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests if the stream supports the GSeekableIface.\n Returns: TRUE if seekable can be seeked. FALSE otherwise.\n\t \n",
"line" : 98}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "int(long offset, GSeekType type, Cancellable cancellable)",
"comment" : "\n Seeks in the stream by the given offset, modified by type.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n offset = a goffset.\n type = a GSeekType.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 112}
,
{
"name" : "canTruncate",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tests if the stream can be truncated.\n Returns: TRUE if the stream can be truncated, FALSE otherwise.\n\t \n",
"line" : 118}
,
{
"name" : "truncate",
"kind" : "function",
"protection" : "public",
"type" : "int(long offset, Cancellable cancellable)",
"comment" : "\n Truncates a stream with a given offset.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n Params:\n offset = a goffset.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 133}
]
}
]
}
,
{
"name" : "gio.SeekableT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SeekableT.d",
"members" : [
{
"name" : "SeekableT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n GSeekable is implemented by streams (implementations of\n GInputStream or GOutputStream) that support seeking.\n \n",
"line" : 76,
"members" : [
{
"name" : "gSeekable",
"kind" : "variable",
"type" : "GSeekable*",
"comment" : " the main Gtk struct \n",
"line" : 80}
,
{
"name" : "getSeekableTStruct",
"kind" : "function",
"type" : "GSeekable*()",
"line" : 83}
,
{
"name" : "tell",
"kind" : "function",
"type" : "long()",
"comment" : "\n\t \n\n Tells the current position within the stream.\n Returns: the offset from the beginning of the buffer.\n\t \n",
"line" : 96}
,
{
"name" : "canSeek",
"kind" : "function",
"type" : "int()",
"comment" : "\n Tests if the stream supports the GSeekableIface.\n Returns: TRUE if seekable can be seeked. FALSE otherwise.\n\t \n",
"line" : 106}
,
{
"name" : "seek",
"kind" : "function",
"type" : "int(long offset, GSeekType type, Cancellable cancellable)",
"comment" : "\n Seeks in the stream by the given offset, modified by type.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Params:\n offset = a goffset.\n type = a GSeekType.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 124}
,
{
"name" : "canTruncate",
"kind" : "function",
"type" : "int()",
"comment" : "\n Tests if the stream can be truncated.\n Returns: TRUE if the stream can be truncated, FALSE otherwise.\n\t \n",
"line" : 143}
,
{
"name" : "truncate",
"kind" : "function",
"type" : "int(long offset, Cancellable cancellable)",
"comment" : "\n Truncates a stream with a given offset.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned. If an\n operation was partially finished when the operation was cancelled the\n partial result will be returned, without an error.\n Params:\n offset = a goffset.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: TRUE if successful. If an error has occurred, this function will return FALSE and set error appropriately if present.\n Throws: GException on failure.\n\t \n",
"line" : 162}
]
}
]
}
,
{
"name" : "gio.SettingsBackend",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SettingsBackend.d",
"members" : [
{
"name" : "SettingsBackend",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GSettingsBackend interface defines a generic interface for\n non-strictly-typed data that is stored in a hierarchy. To implement\n an alternative storage backend for GSettings, you need to implement\n the GSettingsBackend interface and then make it implement the\n extension point G_SETTINGS_BACKEND_EXTENSION_POINT_NAME.\n The interface defines methods for reading and writing values, a\n method for determining if writing of certain values will fail\n (lockdown) and a change notification mechanism.\n The semantics of the interface are very precisely defined and\n implementations must carefully adhere to the expectations of\n callers that are documented on each of the interface methods.\n Some of the GSettingsBackend functions accept or return a GTree.\n These trees always have strings as keys and GVariant as values.\n g_settings_backend_create_tree() is a convenience function to create\n suitable trees.\n Note\n The GSettingsBackend API is exported to allow third-party\n implementations, but does not carry the same stability guarantees\n as the public GIO API. For this reason, you have to define the\n C preprocessor symbol G_SETTINGS_ENABLE_BACKEND before including\n gio\/gsettingsbackend.h\n \n",
"line" : 96,
"base" : "ObjectG",
"members" : [
{
"name" : "gSettingsBackend",
"kind" : "variable",
"protection" : "protected",
"type" : "GSettingsBackend*",
"comment" : " the main Gtk struct \n",
"line" : 100}
,
{
"name" : "getSettingsBackendStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSettingsBackend*()",
"line" : 103}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 110}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SettingsBackend(GSettingsBackend* gSettingsBackend)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 118}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 136}
,
{
"name" : "changed",
"kind" : "function",
"protection" : "public",
"type" : "void(string key, void* originTag)",
"comment" : "\n\t \n\n Signals that a single key has possibly changed. Backend\n implementations should call this if a key has possibly changed its\n value.\n key must be a valid key (ie: starting with a slash, not containing\n '\/\/', and not ending with a slash).\n The implementation must call this function during any call to\n g_settings_backend_write(), before the call returns (except in the\n case that no keys are actually changed and it cares to detect this\n fact). It may not rely on the existence of a mainloop for\n dispatching the signal later.\n The implementation may call this function at any other time it likes\n in response to other events (such as changes occuring outside of the\n program). These calls may originate from a mainloop or may originate\n in response to any other action (including from calls to\n g_settings_backend_write()).\n In the case that this call is in response to a call to\n g_settings_backend_write() then origin_tag must be set to the same\n value that was passed to that call.\n Since 2.26\n Params:\n key = the name of the key\n originTag = the origin tag\n\t \n",
"line" : 169}
,
{
"name" : "pathChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(string path, void* originTag)",
"comment" : "\n Signals that all keys below a given path may have possibly changed.\n Backend implementations should call this if an entire path of keys\n have possibly changed their values.\n path must be a valid path (ie: starting and ending with a slash and\n not containing '\/\/').\n The meaning of this signal is that any of the key which has a name\n starting with path may have changed.\n The same rules for when notifications must occur apply as per\n g_settings_backend_changed(). This call might be an appropriate\n reasponse to a 'reset' call but implementations are also free to\n explicitly list the keys that were affected by that call if they can\n easily do so.\n For efficiency reasons, the implementation should strive for path to\n be as long as possible (ie: the longest common prefix of all of the\n keys that were changed) but this is not strictly required. As an\n example, if this function is called with the path of \"\/\" then every\n single key in the application will be notified of a possible change.\n Since 2.26\n Params:\n path = the path containing the changes\n originTag = the origin tag\n\t \n",
"line" : 198}
,
{
"name" : "keysChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(string path, char** items, void* originTag)",
"comment" : "\n Signals that a list of keys have possibly changed. Backend\n implementations should call this if keys have possibly changed their\n values.\n path must be a valid path (ie: starting and ending with a slash and\n not containing '\/\/'). Each string in items must form a valid key\n name when path is prefixed to it (ie: each item must not start or\n end with '\/' and must not contain '\/\/').\n The meaning of this signal is that any of the key names resulting\n from the contatenation of path with each item in items may have\n changed.\n The same rules for when notifications must occur apply as per\n g_settings_backend_changed(). These two calls can be used\n interchangeably if exactly one item has changed (although in that\n case g_settings_backend_changed() is definitely preferred).\n For efficiency reasons, the implementation should strive for path to\n be as long as possible (ie: the longest common prefix of all of the\n keys that were changed) but this is not strictly required.\n Since 2.26\n Params:\n path = the path containing the changes\n items = the NULL-terminated list of changed keys\n originTag = the origin tag\n\t \n",
"line" : 228}
,
{
"name" : "pathWritableChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(string path)",
"comment" : "\n Signals that the writability of all keys below a given path may have\n changed.\n Since GSettings performs no locking operations for itself, this call\n will always be made in response to external events.\n Since 2.26\n Params:\n path = the name of the path\n\t \n",
"line" : 243}
,
{
"name" : "writableChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(string key)",
"comment" : "\n Signals that the writability of a single key has possibly changed.\n Since GSettings performs no locking operations for itself, this call\n will always be made in response to external events.\n Since 2.26\n Params:\n key = the name of the key\n\t \n",
"line" : 257}
,
{
"name" : "changedTree",
"kind" : "function",
"protection" : "public",
"type" : "void(BBTree tree, void* originTag)",
"comment" : "\n This call is a convenience wrapper. It gets the list of changes from\n tree, computes the longest common prefix and calls\n g_settings_backend_changed().\n Since 2.26\n Params:\n tree = a GTree containing the changes\n originTag = the origin tag\n\t \n",
"line" : 272}
,
{
"name" : "flattenTree",
"kind" : "function",
"protection" : "public",
"type" : "void(BBTree tree, out string path, out string[] keys, out Variant[] values)",
"comment" : "\n Calculate the longest common prefix of all keys in a tree and write\n out an array of the key names relative to that prefix and,\n optionally, the value to store at each of those keys.\n You must free the value returned in path, keys and values using\n g_free(). You should not attempt to free or unref the contents of\n keys or values.\n Since 2.26\n Params:\n tree = a GTree containing the changes\n path = the location to save the path\n keys = the location to save the relative keys\n values = the location to save the values, or NULL\n\t \n",
"line" : 292}
,
{
"name" : "gKeyfileSettingsBackendNew",
"kind" : "function",
"protection" : "public",
"type" : "GSettingsBackend*(string filename, string rootPath, string rootGroup)",
"comment" : "\n Creates a keyfile-backed GSettingsBackend.\n The filename of the keyfile to use is given by filename.\n All settings read to or written from the backend must fall under the\n path given in root_path (which must start and end with a slash and\n not contain two consecutive slashes). root_path may be \"\/\".\n If root_group is non-NULL then it specifies the name of the keyfile\n group used for keys that are written directly below root_path. For\n example, if root_path is \"\/apps\/example\/\" and root_group is\n \"toplevel\", then settings the key \"\/apps\/example\/enabled\" to a value\n Params:\n filename = the filename of the keyfile\n rootPath = the path under which all settings keys appear\n rootGroup = the group name corresponding to\n  root_path, or NULL. [allow-none]\n Returns: a keyfile-backed GSettingsBackend\n\t \n",
"line" : 328}
]
}
]
}
,
{
"name" : "gio.Settings",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Settings.d",
"members" : [
{
"name" : "Settings",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GSettings class provides a convenient API for storing and retrieving\n application settings.\n When creating a GSettings instance, you have to specify a schema\n that describes the keys in your settings and their types and default\n values, as well as some other information.\n Normally, a schema has as fixed path that determines where the settings\n are stored in the conceptual global tree of settings. However, schemas\n can also be 'relocatable', i.e. not equipped with a fixed path. This is\n useful e.g. when the schema describes an 'account', and you want to be\n able to store a arbitrary number of accounts.\n Unlike other configuration systems (like GConf), GSettings does not\n restrict keys to basic types like strings and numbers. GSettings stores\n values as GVariant, and allows any GVariantType for keys. Key names\n are restricted to lowercase characters, numbers and '-'. Furthermore,\n the names must begin with a lowercase character, must not end\n with a '-', and must not contain consecutive dashes. Key names can\n be up to 32 characters long.\n Similar to GConf, the default values in GSettings schemas can be\n localized, but the localized values are stored in gettext catalogs\n and looked up with the domain that is specified in the\n gettext-domain attribute of the\n <schemalist> or <schema>\n elements and the category that is specified in the l10n attribute of the\n <key> element.\n GSettings uses schemas in a compact binary form that is created\n by the glib-compile-schemas\n utility. The input is a schema description in an XML format that can be\n described by the following DTD:\n $(DDOC_COMMENT example)\n At runtime, schemas are identified by their id (as specified\n in the id attribute of the\n <schema> element). The\n convention for schema ids is to use a dotted name, similar in\n style to a DBus bus name, e.g. \"org.gnome.font-rendering\".\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n Vendor overrides\n  Default values are defined in the schemas that get installed by\n  an application. Sometimes, it is necessary for a vendor or distributor\n  to adjust these defaults. Since patching the XML source for the schema\n  is inconvenient and error-prone,\n  glib-compile-schemas reads\n  so-called 'vendor override' files. These are keyfiles in the same\n  directory as the XML schema sources which can override default values.\n  The schema id serves as the group name in the key file, and the values\n  are expected in serialized GVariant form, as in the following example:\n $(DDOC_COMMENT example)\n <hr>\n Binding\n  A very convenient feature of GSettings lets you bind GObject properties\n  directly to settings, using g_settings_bind(). Once a GObject property\n  has been bound to a setting, changes on either side are automatically\n  propagated to the other side. GSettings handles details like\n  mapping between GObject and GVariant types, and preventing infinite\n  cycles.\n  This makes it very easy to hook up a preferences dialog to the\n  underlying settings. To make this even more convenient, GSettings\n  looks for a boolean property with the name \"sensitivity\" and\n  automatically binds it to the writability of the bound setting.\n  If this 'magic' gets in the way, it can be suppressed with the\n  G_SETTINGS_BIND_NO_SENSITIVITY flag.\n \n",
"line" : 145,
"base" : "ObjectG",
"members" : [
{
"name" : "gSettings",
"kind" : "variable",
"protection" : "protected",
"type" : "GSettings*",
"comment" : " the main Gtk struct \n",
"line" : 149}
,
{
"name" : "getSettingsStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSettings*()",
"line" : 152}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 159}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Settings(GSettings* gSettings)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 167}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 185}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 193}
,
{
"name" : "onChangeListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(void*, int, Settings)[]",
"line" : 195}
,
{
"name" : "addOnChange",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(void*, int, Settings) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n The \"change-event\" signal is emitted once per change event that\n affects this settings object. You should connect to this signal\n only if you are interested in viewing groups of changes before they\n are split out into multiple emissions of the \"changed\" signal.\n For most use cases it is more appropriate to use the \"changed\" signal.\n In the event that the change event applies to one or more specified\n keys, keys will be an array of GQuark of length n_keys. In the\n event that the change event applies to the GSettings object as a\n whole (ie: potentially every key has been changed) then keys will\n be NULL and n_keys will be 0.\n The default handler for this signal invokes the \"changed\" signal\n for each affected key. If any other connected handler returns\n TRUE then this default functionality will be supressed.\n TRUE to stop other handlers from being invoked for the\n  event. FALSE to propagate the event further.\n\t \n",
"line" : 213}
,
{
"name" : "callBackChange",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(GSettings* settingsStruct, void* keys, int nKeys, Settings settings)",
"line" : 228}
,
{
"name" : "onChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(string, Settings)[]",
"line" : 241}
,
{
"name" : "addOnChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string, Settings) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n The \"changed\" signal is emitted when a key has potentially changed.\n You should call one of the g_settings_get() calls to check the new\n value.\n This signal supports detailed connections. You can connect to the\n detailed signal \"changed::x\" in order to only receive callbacks\n when key \"x\" changes.\n\t \n",
"line" : 250}
,
{
"name" : "callBackChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GSettings* settingsStruct, char* key, Settings settings)",
"line" : 265}
,
{
"name" : "onWritableChangeListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(uint, Settings)[]",
"line" : 273}
,
{
"name" : "addOnWritableChange",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(uint, Settings) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n The \"writable-change-event\" signal is emitted once per writability\n change event that affects this settings object. You should connect\n to this signal if you are interested in viewing groups of changes\n before they are split out into multiple emissions of the\n \"writable-changed\" signal. For most use cases it is more\n appropriate to use the \"writable-changed\" signal.\n In the event that the writability change applies only to a single\n key, key will be set to the GQuark for that key. In the event\n that the writability change affects the entire settings object,\n key will be 0.\n The default handler for this signal invokes the \"writable-changed\"\n and \"changed\" signals for each affected key. This is done because\n changes in writability might also imply changes in value (if for\n example, a new mandatory setting is introduced). If any other\n connected handler returns TRUE then this default functionality\n will be supressed.\n TRUE to stop other handlers from being invoked for the\n  event. FALSE to propagate the event further.\n\t \n",
"line" : 294}
,
{
"name" : "callBackWritableChange",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(GSettings* settingsStruct, uint key, Settings settings)",
"line" : 309}
,
{
"name" : "onWritableChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(string, Settings)[]",
"line" : 322}
,
{
"name" : "addOnWritableChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(string, Settings) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n The \"writable-changed\" signal is emitted when the writability of a\n key has potentially changed. You should call\n g_settings_is_writable() in order to determine the new status.\n This signal supports detailed connections. You can connect to the\n detailed signal \"writable-changed::x\" in order to only receive\n callbacks when the writability of \"x\" changes.\n\t \n",
"line" : 331}
,
{
"name" : "callBackWritableChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GSettings* settingsStruct, char* key, Settings settings)",
"line" : 346}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Settings(string schema)",
"comment" : "\n Creates a new GSettings object with a given schema.\n Signals on the newly created GSettings object will be dispatched\n via the thread-default GMainContext in effect at the time of the\n call to g_settings_new(). The new GSettings will hold a reference\n on the context. See g_main_context_push_thread_default().\n Since 2.26\n Params:\n schema = the name of the schema\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 366}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Settings(string schema, string path)",
"comment" : "\n Creates a new GSettings object with a given schema and path.\n You only need to do this if you want to directly create a settings\n object with a schema that doesn't have a specified path of its own.\n That's quite rare.\n It is a programmer error to call this function for a schema that\n has an explicitly specified path.\n Since 2.26\n Params:\n schema = the name of the schema\n path = the path to use\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 390}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Settings(string schema, SettingsBackend backend)",
"comment" : "\n Creates a new GSettings object with a given schema and backend.\n Creating settings objects with an different backend allows accessing settings\n from a database other than the usual one. For example, it may make\n sense to pass a backend corresponding to the \"defaults\" settings database on\n the system to get a settings object that modifies the system default\n settings instead of the settings for this user.\n Since 2.26\n Params:\n schema = the name of the schema\n backend = the GSettingsBackend to use\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 414}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Settings(string schema, SettingsBackend backend, string path)",
"comment" : "\n Creates a new GSettings object with a given schema, backend and\n path.\n This is a mix of g_settings_new_with_backend() and\n g_settings_new_with_path().\n Since 2.26\n Params:\n schema = the name of the schema\n backend = the GSettingsBackend to use\n path = the path to use\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 437}
,
{
"name" : "sync",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Ensures that all pending operations for the given are complete for\n the default backend.\n Writes made to a GSettings are handled asynchronously. For this\n reason, it is very unlikely that the changes have it to disk by the\n time g_settings_set() returns.\n This call will block until all of the writes have made it to the\n backend. Since the mainloop is not running, no change notifications\n will be dispatched during this call (but some may be queued by the\n time the call is done).\n\t \n",
"line" : 459}
,
{
"name" : "getValue",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string key)",
"comment" : "\n Gets the value that is stored in settings for key.\n It is a programmer error to give a key that isn't contained in the\n schema for settings.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: a new GVariant\n\t \n",
"line" : 474}
,
{
"name" : "setValue",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, Variant value)",
"comment" : "\n Sets key in settings to value.\n It is a programmer error to give a key that isn't contained in the\n schema for settings or for value to have the incorrect type, per\n the schema.\n If value is floating then this function consumes the reference.\n Since 2.26\n Params:\n key = the name of the key to set\n value = a GVariant of the correct type\n Returns: TRUE if setting the key succeeded, FALSE if the key was not writable\n\t \n",
"line" : 497}
,
{
"name" : "isWritable",
"kind" : "function",
"protection" : "public",
"type" : "int(string name)",
"comment" : "\n Finds out if a key can be written or not\n Since 2.26\n Params:\n name = the name of a key\n Returns: TRUE if the key name is writable\n\t \n",
"line" : 510}
,
{
"name" : "delay",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Changes the GSettings object into 'delay-apply' mode. In this\n mode, changes to settings are not immediately propagated to the\n backend, but kept locally until g_settings_apply() is called.\n Since 2.26\n\t \n",
"line" : 522}
,
{
"name" : "apply",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Applies any changes that have been made to the settings. This\n function does nothing unless settings is in 'delay-apply' mode;\n see g_settings_delay(). In the normal case settings are always\n applied immediately.\n\t \n",
"line" : 534}
,
{
"name" : "revert",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Reverts all non-applied changes to the settings. This function\n does nothing unless settings is in 'delay-apply' mode; see\n g_settings_delay(). In the normal case settings are always applied\n immediately.\n Change notifications will be emitted for affected keys.\n\t \n",
"line" : 547}
,
{
"name" : "getHasUnapplied",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the GSettings object has any unapplied\n changes. This can only be the case if it is in 'delayed-apply' mode.\n Since 2.26\n Returns: TRUE if settings has unapplied changes\n\t \n",
"line" : 559}
,
{
"name" : "getChild",
"kind" : "function",
"protection" : "public",
"type" : "Settings(string name)",
"comment" : "\n Creates a 'child' settings object which has a base path of\n base-path\/name\", where\n base-path is the base path of settings.\n The schema for the child settings object must have been declared\n in the schema of settings using a <child> element.\n Since 2.26\n Params:\n name = the name of the 'child' schema\n Returns: a 'child' settings object\n\t \n",
"line" : 576}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void(string key)",
"comment" : "\n Resets key to its default value.\n This call resets the key, as much as possible, to its default value.\n That might the value specified in the schema or the one set by the\n administrator.\n Params:\n key = the name of a key\n\t \n",
"line" : 595}
,
{
"name" : "getBoolean",
"kind" : "function",
"protection" : "public",
"type" : "int(string key)",
"comment" : "\n Gets the value that is stored at key in settings.\n A convenience variant of g_settings_get() for booleans.\n It is a programmer error to give a key that isn't specified as\n having a boolean type in the schema for settings.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: a boolean\n\t \n",
"line" : 611}
,
{
"name" : "setBoolean",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, int value)",
"comment" : "\n Sets key in settings to value.\n A convenience variant of g_settings_set() for booleans.\n It is a programmer error to give a key that isn't specified as\n having a boolean type in the schema for settings.\n Since 2.26\n Params:\n key = the name of the key to set\n value = the value to set it to\n Returns: TRUE if setting the key succeeded, FALSE if the key was not writable\n\t \n",
"line" : 628}
,
{
"name" : "getInt",
"kind" : "function",
"protection" : "public",
"type" : "int(string key)",
"comment" : "\n Gets the value that is stored at key in settings.\n A convenience variant of g_settings_get() for 32-bit integers.\n It is a programmer error to give a key that isn't specified as\n having a int32 type in the schema for settings.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: an integer\n\t \n",
"line" : 644}
,
{
"name" : "setInt",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, int value)",
"comment" : "\n Sets key in settings to value.\n A convenience variant of g_settings_set() for 32-bit integers.\n It is a programmer error to give a key that isn't specified as\n having a int32 type in the schema for settings.\n Since 2.26\n Params:\n key = the name of the key to set\n value = the value to set it to\n Returns: TRUE if setting the key succeeded, FALSE if the key was not writable\n\t \n",
"line" : 661}
,
{
"name" : "getDouble",
"kind" : "function",
"protection" : "public",
"type" : "double(string key)",
"comment" : "\n Gets the value that is stored at key in settings.\n A convenience variant of g_settings_get() for doubles.\n It is a programmer error to give a key that isn't specified as\n having a 'double' type in the schema for settings.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: a double\n\t \n",
"line" : 677}
,
{
"name" : "setDouble",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, double value)",
"comment" : "\n Sets key in settings to value.\n A convenience variant of g_settings_set() for doubles.\n It is a programmer error to give a key that isn't specified as\n having a 'double' type in the schema for settings.\n Since 2.26\n Params:\n key = the name of the key to set\n value = the value to set it to\n Returns: TRUE if setting the key succeeded, FALSE if the key was not writable\n\t \n",
"line" : 694}
,
{
"name" : "getString",
"kind" : "function",
"protection" : "public",
"type" : "string(string key)",
"comment" : "\n Gets the value that is stored at key in settings.\n A convenience variant of g_settings_get() for strings.\n It is a programmer error to give a key that isn't specified as\n having a string type in the schema for settings.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: a newly-allocated string\n\t \n",
"line" : 710}
,
{
"name" : "setString",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, string value)",
"comment" : "\n Sets key in settings to value.\n A convenience variant of g_settings_set() for strings.\n It is a programmer error to give a key that isn't specified as\n having a string type in the schema for settings.\n Since 2.26\n Params:\n key = the name of the key to set\n value = the value to set it to\n Returns: TRUE if setting the key succeeded, FALSE if the key was not writable\n\t \n",
"line" : 727}
,
{
"name" : "getStrv",
"kind" : "function",
"protection" : "public",
"type" : "string[](string key)",
"comment" : "\n Gets the value that is stored at key in settings.\n A convenience variant of g_settings_get() for string arrays.\n It is a programmer error to give a key that isn't specified as\n having an array of strings type in the schema for settings.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: a newly-allocated, NULL-terminated array of strings\n\t \n",
"line" : 743}
,
{
"name" : "setStrv",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, string[] value)",
"comment" : "\n Sets key in settings to value.\n A convenience variant of g_settings_set() for string arrays. If\n value is NULL, then key is set to be the empty array.\n It is a programmer error to give a key that isn't specified as\n having an array of strings type in the schema for settings.\n Since 2.26\n Params:\n key = the name of the key to set\n value = the value to set it to, or NULL. [allow-none]\n Returns: TRUE if setting the key succeeded, FALSE if the key was not writable\n\t \n",
"line" : 761}
,
{
"name" : "getEnum",
"kind" : "function",
"protection" : "public",
"type" : "int(string key)",
"comment" : "\n Gets the value that is stored in settings for key and converts it\n to the enum value that it represents.\n In order to use this function the type of the value must be a string\n and it must be marked in the schema file as an enumerated type.\n It is a programmer error to give a key that isn't contained in the\n schema for settings or is not marked as an enumerated type.\n If the value stored in the configuration database is not a valid\n value for the enumerated type then this function will return the\n default value.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: the enum value\n\t \n",
"line" : 782}
,
{
"name" : "setEnum",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, int value)",
"comment" : "\n Looks up the enumerated type nick for value and writes it to key,\n within settings.\n It is a programmer error to give a key that isn't contained in the\n schema for settings or is not marked as an enumerated type, or for\n value not to be a valid value for the named type.\n After performing the write, accessing key directly with\n g_settings_get_string() will return the 'nick' associated with\n value.\n Params:\n key = a key, within settings\n value = an enumerated value\n Returns: TRUE, if the set succeeds\n\t \n",
"line" : 802}
,
{
"name" : "getFlags",
"kind" : "function",
"protection" : "public",
"type" : "uint(string key)",
"comment" : "\n Gets the value that is stored in settings for key and converts it\n to the flags value that it represents.\n In order to use this function the type of the value must be an array\n of strings and it must be marked in the schema file as an flags type.\n It is a programmer error to give a key that isn't contained in the\n schema for settings or is not marked as a flags type.\n If the value stored in the configuration database is not a valid\n value for the flags type then this function will return the default\n value.\n Since 2.26\n Params:\n key = the key to get the value for\n Returns: the flags value\n\t \n",
"line" : 823}
,
{
"name" : "setFlags",
"kind" : "function",
"protection" : "public",
"type" : "int(string key, uint value)",
"comment" : "\n Looks up the flags type nicks for the bits specified by value, puts\n them in an array of strings and writes the array to key, withing\n settings.\n It is a programmer error to give a key that isn't contained in the\n schema for settings or is not marked as a flags type, or for value\n to contain any bits that are not value for the named type.\n After performing the write, accessing key directly with\n g_settings_get_strv() will return an array of 'nicks'; one for each\n bit in value.\n Params:\n key = a key, within settings\n value = a flags value\n Returns: TRUE, if the set succeeds\n\t \n",
"line" : 844}
,
{
"name" : "getMapped",
"kind" : "function",
"protection" : "public",
"type" : "void*(string key, extern (C) int function(GVariant*, void**, void*) mapping, void* userData)",
"comment" : "\n Gets the value that is stored at key in settings, subject to\n application-level validation\/mapping.\n You should use this function when the application needs to perform\n some processing on the value of the key (for example, parsing). The\n mapping function performs that processing. If the function\n indicates that the processing was unsuccessful (due to a parse error,\n for example) then the mapping is tried again with another value.\n This allows a robust 'fall back to defaults' behaviour to be\n implemented somewhat automatically.\n The first value that is tried is the user's setting for the key. If\n the mapping function fails to map this value, other values may be\n tried in an unspecified order (system or site defaults, translated\n schema default values, untranslated schema default values, etc).\n If the mapping function fails for all possible values, one additional\n attempt is made: the mapping function is called with a NULL value.\n If the mapping function still indicates failure at this point then\n the application will be aborted.\n The result parameter for the mapping function is pointed to a\n gpointer which is initially set to NULL. The same pointer is given\n to each invocation of mapping. The final value of that gpointer is\n what is returned by this function. NULL is valid; it is returned\n just as any other value would be.\n Params:\n key = the key to get the value for\n mapping = the function to map the value in the settings database to\n  the value used by the application\n userData = user data for mapping\n Returns: the result, which may be NULL\n\t \n",
"line" : 880}
,
{
"name" : "bind",
"kind" : "function",
"protection" : "public",
"type" : "void(string key, void* object, string property, GSettingsBindFlags flags)",
"comment" : "\n Create a binding between the key in the settings object\n and the property property of object.\n The binding uses the default GIO mapping functions to map\n between the settings and property values. These functions\n handle booleans, numeric types and string types in a\n straightforward way. Use g_settings_bind_with_mapping() if\n you need a custom mapping, or map between types that are not\n supported by the default mapping functions.\n Unless the flags include G_SETTINGS_BIND_NO_SENSITIVITY, this\n function also establishes a binding between the writability of\n key and the \"sensitive\" property of object (if object has\n a boolean property by that name). See g_settings_bind_writable()\n for more details about writable bindings.\n Note that the lifecycle of the binding is tied to the object,\n and that you can have only one binding per object property.\n If you bind the same property twice on the same object, the second\n binding overrides the first one.\n Since 2.26\n Params:\n key = the key to bind\n object = a GObject\n property = the name of the property to bind\n flags = flags for the binding\n\t \n",
"line" : 911}
,
{
"name" : "bindWithMapping",
"kind" : "function",
"protection" : "public",
"type" : "void(string key, void* object, string property, GSettingsBindFlags flags, extern (C) int function(GValue*, GVariant*, void*) getMapping, extern (C) GVariant* function(GValue*, GVariantType*, void*) setMapping, void* userData, extern (C) void function(void* cbData) destroy)",
"comment" : "\n Create a binding between the key in the settings object\n and the property property of object.\n The binding uses the provided mapping functions to map between\n settings and property values.\n Note that the lifecycle of the binding is tied to the object,\n and that you can have only one binding per object property.\n If you bind the same property twice on the same object, the second\n binding overrides the first one.\n Since 2.26\n Params:\n key = the key to bind\n object = a GObject\n property = the name of the property to bind\n flags = flags for the binding\n getMapping = a function that gets called to convert values\n  from settings to object, or NULL to use the default GIO mapping\n setMapping = a function that gets called to convert values\n  from object to settings, or NULL to use the default GIO mapping\n userData = data that gets passed to get_mapping and set_mapping\n destroy = GDestroyNotify function for user_data\n\t \n",
"line" : 939}
,
{
"name" : "bindWritable",
"kind" : "function",
"protection" : "public",
"type" : "void(string key, void* object, string property, int inverted)",
"comment" : "\n Create a binding between the writability of key in the\n settings object and the property property of object.\n The property must be boolean; \"sensitive\" or \"visible\"\n properties of widgets are the most likely candidates.\n Writable bindings are always uni-directional; changes of the\n writability of the setting will be propagated to the object\n property, not the other way.\n When the inverted argument is TRUE, the binding inverts the\n value as it passes from the setting to the object, i.e. property\n will be set to TRUE if the key is not\n writable.\n Note that the lifecycle of the binding is tied to the object,\n and that you can have only one binding per object property.\n If you bind the same property twice on the same object, the second\n binding overrides the first one.\n Since 2.26\n Params:\n key = the key to bind\n object = a GObject\n property = the name of a boolean property to bind\n inverted = whether to 'invert' the value\n\t \n",
"line" : 968}
,
{
"name" : "unbind",
"kind" : "function",
"protection" : "public",
"type" : "void(void* object, string property)",
"comment" : "\n Removes an existing binding for property on object.\n Note that bindings are automatically removed when the\n object is finalized, so it is rarely necessary to call this\n function.\n Since 2.26\n Params:\n object = the object\n property = the property whose binding is removed\n\t \n",
"line" : 984}
]
}
]
}
,
{
"name" : "gio.SimpleAsyncResult",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SimpleAsyncResult.d",
"members" : [
{
"name" : "SimpleAsyncResult",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Implements GAsyncResult for simple cases. Most of the time, this\n will be all an application needs, and will be used transparently.\n Because of this, GSimpleAsyncResult is used throughout GIO for\n handling asynchronous functions.\n GSimpleAsyncResult handles GAsyncReadyCallbacks, error\n reporting, operation cancellation and the final state of an operation,\n completely transparent to the application. Results can be returned\n as a pointer e.g. for functions that return data that is collected\n asynchronously, a boolean value for checking the success or failure\n of an operation, or a gssize for operations which return the number\n of bytes modified by the operation; all of the simple return cases\n are covered.\n Most of the time, an application will not need to know of the details\n of this API; it is handled transparently, and any necessary operations\n are handled by GAsyncResult's interface. However, if implementing a\n new GIO module, for writing language bindings, or for complex\n applications that need better control of how asynchronous operations\n are completed, it is important to understand this functionality.\n GSimpleAsyncResults are tagged with the calling function to ensure\n that asynchronous functions and their finishing functions are used\n together correctly.\n To create a new GSimpleAsyncResult, call g_simple_async_result_new().\n If the result needs to be created for a GError, use\n g_simple_async_result_new_from_error(). If a GError is not available\n (e.g. the asynchronous operation's doesn't take a GError argument),\n but the result still needs to be created for an error condition, use\n g_simple_async_result_new_error() (or g_simple_async_result_set_error_va()\n if your application or binding requires passing a variable argument list\n directly), and the error can then be propagated through the use of\n g_simple_async_result_propagate_error().\n An asynchronous operation can be made to ignore a cancellation event by\n calling g_simple_async_result_set_handle_cancellation() with a\n GSimpleAsyncResult for the operation and FALSE. This is useful for\n operations that are dangerous to cancel, such as close (which would\n cause a leak if cancelled before being run).\n GSimpleAsyncResult can integrate into GLib's event loop, GMainLoop,\n or it can use GThreads if available.\n g_simple_async_result_complete() will finish an I\/O task directly\n from the point where it is called. g_simple_async_result_complete_in_idle()\n will finish it from an idle handler in the thread-default main\n context. g_simple_async_result_run_in_thread() will run the\n job in a separate thread and then deliver the result to the\n thread-default main context.\n To set the results of an asynchronous function,\n g_simple_async_result_set_op_res_gpointer(),\n g_simple_async_result_set_op_res_gboolean(), and\n g_simple_async_result_set_op_res_gssize()\n are provided, setting the operation's result to a gpointer, gboolean, or\n gssize, respectively.\n Likewise, to get the result of an asynchronous function,\n g_simple_async_result_get_op_res_gpointer(),\n g_simple_async_result_get_op_res_gboolean(), and\n g_simple_async_result_get_op_res_gssize() are\n provided, getting the operation's result as a gpointer, gboolean, and\n gssize, respectively.\n For the details of the requirements implementations must respect, see\n GAsyncResult. A typical implementation of an asynchronous operation\n using GSimpleAsyncResult looks something like this:\n $(DDOC_COMMENT example)\n \n",
"line" : 144,
"base" : "ObjectG",
"interfaces" : [
"AsyncResultIF"],
"members" : [
{
"name" : "gSimpleAsyncResult",
"kind" : "variable",
"protection" : "protected",
"type" : "GSimpleAsyncResult*",
"comment" : " the main Gtk struct \n",
"line" : 148}
,
{
"name" : "getSimpleAsyncResultStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSimpleAsyncResult*()",
"line" : 151}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 158}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimpleAsyncResult(GSimpleAsyncResult* gSimpleAsyncResult)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 166}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 184}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimpleAsyncResult(ObjectG sourceObject, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData, void* sourceTag)",
"comment" : "\n\t \n\n Creates a GSimpleAsyncResult.\n Params:\n sourceObject = a GObject the asynchronous function was called with,\n or NULL.\n callback = a GAsyncReadyCallback.\n userData = user data passed to callback.\n sourceTag = the asynchronous function.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 206}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimpleAsyncResult(ObjectG sourceObject, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData, ErrorG error)",
"comment" : "\n Creates a GSimpleAsyncResult from an error condition.\n Params:\n sourceObject = a GObject, or NULL.\n callback = a GAsyncReadyCallback.\n userData = user data passed to callback.\n error = a GError location.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 226}
,
{
"name" : "setOpResGpointer",
"kind" : "function",
"protection" : "public",
"type" : "void(void* opRes, extern (C) void function(void* cbData) destroyOpRes)",
"comment" : "\n Sets the operation result within the asynchronous result to a pointer.\n Params:\n opRes = a pointer result from an asynchronous function.\n destroyOpRes = a GDestroyNotify function.\n\t \n",
"line" : 243}
,
{
"name" : "getOpResGpointer",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Gets a pointer result as returned by the asynchronous function.\n Returns: a pointer from the result.\n\t \n",
"line" : 253}
,
{
"name" : "setOpResGssize",
"kind" : "function",
"protection" : "public",
"type" : "void(long opRes)",
"comment" : "\n Sets the operation result within the asynchronous result to\n the given op_res.\n Params:\n opRes = a gssize.\n\t \n",
"line" : 265}
,
{
"name" : "getOpResGssize",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n Gets a gssize from the asynchronous result.\n Returns: a gssize returned from the asynchronous function.\n\t \n",
"line" : 275}
,
{
"name" : "setOpResGboolean",
"kind" : "function",
"protection" : "public",
"type" : "void(int opRes)",
"comment" : "\n Sets the operation result to a boolean within the asynchronous result.\n Params:\n opRes = a gboolean.\n\t \n",
"line" : 286}
,
{
"name" : "getOpResGboolean",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the operation result boolean from within the asynchronous result.\n Returns: TRUE if the operation's result was TRUE, FALSE if the operation's result was FALSE.\n\t \n",
"line" : 296}
,
{
"name" : "getSourceTag",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Gets the source tag for the GSimpleAsyncResult.\n Returns: a gpointer to the source object for the GSimpleAsyncResult.\n\t \n",
"line" : 306}
,
{
"name" : "isValid",
"kind" : "function",
"protection" : "public",
"type" : "int(GAsyncResult* result, ObjectG source, void* sourceTag)",
"comment" : "\n Ensures that the data passed to the _finish function of an async\n operation is consistent. Three checks are performed.\n First, result is checked to ensure that it is really a\n GSimpleAsyncResult. Second, source is checked to ensure that it\n matches the source object of result. Third, source_tag is\n checked to ensure that it is either NULL (as it is when the result was\n created by g_simple_async_report_error_in_idle() or\n g_simple_async_report_gerror_in_idle()) or equal to the\n source_tag argument given to g_simple_async_result_new() (which, by\n convention, is a pointer to the _async function corresponding to the\n _finish function from which this function is called).\n Params:\n result = the GAsyncResult passed to the _finish function.\n source = the GObject passed to the _finish function.\n sourceTag = the asynchronous function.\n Returns: TRUE if all checks passed or FALSE if any failed.\n\t \n",
"line" : 330}
,
{
"name" : "setHandleCancellation",
"kind" : "function",
"protection" : "public",
"type" : "void(int handleCancellation)",
"comment" : "\n Sets whether to handle cancellation within the asynchronous operation.\n Params:\n handleCancellation = a gboolean.\n\t \n",
"line" : 341}
,
{
"name" : "complete",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Completes an asynchronous I\/O job immediately. Must be called in\n the thread where the asynchronous result was to be delivered, as it\n invokes the callback directly. If you are in a different thread use\n g_simple_async_result_complete_in_idle().\n Calling this function takes a reference to simple for as long as\n is needed to complete the call.\n\t \n",
"line" : 355}
,
{
"name" : "completeInIdle",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Completes an asynchronous function in an idle handler in the thread-default main\n loop of the thread that simple was initially created in.\n Calling this function takes a reference to simple for as long as\n is needed to complete the call.\n\t \n",
"line" : 367}
,
{
"name" : "runInThread",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(GSimpleAsyncResult*, GObject*, GCancellable*) func, int ioPriority, Cancellable cancellable)",
"comment" : "\n Runs the asynchronous job in a separate thread and then calls\n g_simple_async_result_complete_in_idle() on simple to return\n the result to the appropriate main loop.\n Calling this function takes a reference to simple for as long as\n is needed to run the job and report its completion.\n Params:\n func = a GSimpleAsyncThreadFunc.\n ioPriority = the io priority of the request.\n cancellable = optional GCancellable object, NULL to ignore.\n\t \n",
"line" : 384}
,
{
"name" : "setFromError",
"kind" : "function",
"protection" : "public",
"type" : "void(ErrorG error)",
"comment" : "\n Sets the result from a GError.\n Params:\n error = GError.\n\t \n",
"line" : 395}
,
{
"name" : "propagateError",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Propagates an error from within the simple asynchronous result to\n a given destination.\n Returns: TRUE if the error was propagated to dest. FALSE otherwise.\n\t \n",
"line" : 406}
,
{
"name" : "setErrorVa",
"kind" : "function",
"protection" : "public",
"type" : "void(uint domain, int code, string format, void* args)",
"comment" : "\n Sets an error within the asynchronous result without a GError.\n Unless writing a binding, see g_simple_async_result_set_error().\n Params:\n domain = a GQuark (usually G_IO_ERROR).\n code = an error code.\n format = a formatted error reporting string.\n args = va_list of arguments.\n\t \n",
"line" : 430}
,
{
"name" : "gSimpleAsyncReportGerrorInIdle",
"kind" : "function",
"protection" : "public",
"type" : "void(ObjectG object, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData, ErrorG error)",
"comment" : "\n Reports an error in an idle function. Similar to\n g_simple_async_report_error_in_idle(), but takes a GError rather\n than building a new one.\n Params:\n object = a GObject.\n callback = a GAsyncReadyCallback.\n userData = user data passed to callback.\n error = the GError to report\n\t \n",
"line" : 446}
]
}
]
}
,
{
"name" : "gio.SimplePermission",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SimplePermission.d",
"members" : [
{
"name" : "SimplePermission",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GSimplePermission is a trivial implementation of GPermission that\n represents a permission that is either always or never allowed. The\n value is given at constuction and doesn't change.\n Calling request or release will result in errors.\n \n",
"line" : 71,
"base" : "Permission",
"members" : [
{
"name" : "gSimplePermission",
"kind" : "variable",
"protection" : "protected",
"type" : "GSimplePermission*",
"comment" : " the main Gtk struct \n",
"line" : 75}
,
{
"name" : "getSimplePermissionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSimplePermission*()",
"line" : 78}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 85}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimplePermission(GSimplePermission* gSimplePermission)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 93}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 111}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimplePermission(int allowed)",
"comment" : "\n\t \n\n Creates a new GPermission instance that represents an action that is\n either always or never allowed.\n Since 2.26\n Params:\n allowed = TRUE if the action is allowed\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 128}
]
}
]
}
,
{
"name" : "gio.SocketAddress",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketAddress.d",
"members" : [
{
"name" : "SocketAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GSocketAddress is the equivalent of struct sockaddr\n in the BSD sockets API. This is an abstract class; use\n GInetSocketAddress for internet sockets, or GUnixSocketAddress\n for UNIX domain sockets.\n \n",
"line" : 83,
"base" : "ObjectG",
"interfaces" : [
"SocketConnectableIF"],
"members" : [
{
"name" : "gSocketAddress",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketAddress*",
"comment" : " the main Gtk struct \n",
"line" : 87}
,
{
"name" : "getSocketAddressStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketAddress*()",
"line" : 90}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 97}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketAddress(GSocketAddress* gSocketAddress)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 105}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 123}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketAddress(void* native, ulong len)",
"comment" : "\n\t \n\n Creates a GSocketAddress subclass corresponding to the native\n struct sockaddr native.\n Since 2.22\n Params:\n native = a pointer to a struct sockaddr\n len = the size of the memory location pointed to by native\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 144}
,
{
"name" : "getFamily",
"kind" : "function",
"protection" : "public",
"type" : "GSocketFamily()",
"comment" : "\n Gets the socket family type of address.\n Since 2.22\n Returns: the socket family type of address.\n\t \n",
"line" : 160}
,
{
"name" : "toNative",
"kind" : "function",
"protection" : "public",
"type" : "int(void* dest, ulong destlen)",
"comment" : "\n Converts a GSocketAddress to a native struct\n sockaddr, which can be passed to low-level functions like\n connect() or bind().\n If not enough space is availible, a G_IO_ERROR_NO_SPACE error is\n returned. If the address type is not known on the system\n then a G_IO_ERROR_NOT_SUPPORTED error is returned.\n Since 2.22\n Params:\n dest = a pointer to a memory location that will contain the native\n struct sockaddr.\n destlen = the size of dest. Must be at least as large as\n g_socket_address_get_native_size().\n Returns: TRUE if dest was filled in, FALSE on error\n Throws: GException on failure.\n\t \n",
"line" : 182}
,
{
"name" : "getNativeSize",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n Gets the size of address's native struct sockaddr.\n You can use this to allocate memory to pass to\n g_socket_address_to_native().\n Since 2.22\n Returns: the size of the native struct sockaddr that address represents\n\t \n",
"line" : 204}
]
}
]
}
,
{
"name" : "gio.SocketAddressEnumerator",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketAddressEnumerator.d",
"members" : [
{
"name" : "SocketAddressEnumerator",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 79,
"base" : "Object",
"members" : [
{
"name" : "gSocketAddressEnumerator",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketAddressEnumerator*",
"comment" : " the main Gtk struct \n",
"line" : 82}
,
{
"name" : "getSocketAddressEnumeratorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketAddressEnumerator*()",
"line" : 85}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 92}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketAddressEnumerator(GSocketAddressEnumerator* gSocketAddressEnumerator)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 100}
]
}
]
}
,
{
"name" : "gio.SocketClient",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketClient.d",
"members" : [
{
"name" : "SocketClient",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GSocketClient is a high-level utility class for connecting to a\n network host using a connection oriented socket type.\n You create a GSocketClient object, set any options you want, then\n call a sync or async connect operation, which returns a GSocketConnection\n subclass on success.\n The type of the GSocketConnection object returned depends on the type of\n the underlying socket that is in use. For instance, for a TCP\/IP connection\n it will be a GTcpConnection.\n \n",
"line" : 96,
"base" : "ObjectG",
"members" : [
{
"name" : "gSocketClient",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketClient*",
"comment" : " the main Gtk struct \n",
"line" : 100}
,
{
"name" : "getSocketClientStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketClient*()",
"line" : 103}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 110}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketClient(GSocketClient* gSocketClient)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 118}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 136}
,
{
"name" : "addApplicationProxy",
"kind" : "function",
"protection" : "public",
"type" : "void(string protocol)",
"comment" : "\n\t \n\n Enable proxy protocols to be handled by the application. When the\n indicated proxy protocol is returned by the GProxyResolver,\n GSocketClient will consider this protocol as supported but will\n not try find a GProxy instance to handle handshaking. The\n application must check for this case by calling\n g_socket_connection_get_remote_address() on the returned\n GSocketConnection, and seeing if it's a GProxyAddress of the\n appropriate type, to determine whether or not it needs to handle\n the proxy handshaking itself.\n This should be used for proxy protocols that are dialects of\n another protocol such as HTTP proxy. It also allows cohabitation of\n proxy protocols that are reused between protocols. A good example\n is HTTP. It can be used to proxy HTTP, FTP and Gopher and can also\n be use as generic socket proxy through the HTTP CONNECT method.\n Params:\n protocol = The proxy protocol\n\t \n",
"line" : 163}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketClient()",
"comment" : "\n Creates a new GSocketClient with the default options.\n Since 2.22\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 174}
,
{
"name" : "connect",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(SocketConnectableIF connectable, Cancellable cancellable)",
"comment" : "\n Tries to resolve the connectable and make a network connection to it..\n Upon a successful connection, a new GSocketConnection is constructed\n and returned. The caller owns this new object and must drop their\n reference to it when finished with it.\n The type of the GSocketConnection object returned depends on the type of\n the underlying socket that is used. For instance, for a TCP\/IP connection\n it will be a GTcpConnection.\n The socket created will be the same family as the the address that the\n connectable resolves to, unless family is set with g_socket_client_set_family()\n or indirectly via g_socket_client_set_local_address(). The socket type\n defaults to G_SOCKET_TYPE_STREAM but can be set with\n g_socket_client_set_socket_type().\n If a local address is specified with g_socket_client_set_local_address() the\n socket will be bound to this address before connecting.\n Since 2.22\n Params:\n connectable = a GSocketConnectable specifying the remote address.\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 207}
,
{
"name" : "connectAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketConnectableIF connectable, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n This is the asynchronous version of g_socket_client_connect().\n When the operation is finished callback will be\n called. You can then call g_socket_client_connect_finish() to get\n the result of the operation.\n Since 2.22\n Params:\n connectable = a GSocketConnectable specifying the remote address.\n cancellable = a GCancellable, or NULL\n callback = a GAsyncReadyCallback\n userData = user data for the callback\n\t \n",
"line" : 238}
,
{
"name" : "connectFinish",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(AsyncResultIF result)",
"comment" : "\n Finishes an async connect operation. See g_socket_client_connect_async()\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 252}
,
{
"name" : "connectToHost",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(string hostAndPort, ushort defaultPort, Cancellable cancellable)",
"comment" : "\n This is a helper function for g_socket_client_connect().\n Attempts to create a TCP connection to the named host.\n host_and_port may be in any of a number of recognised formats: an IPv6\n address, an IPv4 address, or a domain name (in which case a DNS\n lookup is performed). Quoting with [] is supported for all address\n types. A port override may be specified in the usual way with a\n colon. Ports may be given as decimal numbers or symbolic names (in\n which case an \/etc\/services lookup is performed).\n If no port override is given in host_and_port then default_port will be\n used as the port number to connect to.\n In general, host_and_port is expected to be provided by the user (allowing\n them to give the hostname, and a port overide if necessary) and\n default_port is expected to be provided by the application.\n In the case that an IP address is given, a single connection\n attempt is made. In the case that a name is given, multiple\n connection attempts may be made, in turn and according to the\n number of address records in DNS, until a connection succeeds.\n Upon a successful connection, a new GSocketConnection is constructed\n and returned. The caller owns this new object and must drop their\n reference to it when finished with it.\n In the event of any failure (DNS error, service not found, no hosts\n connectable) NULL is returned and error (if non-NULL) is set\n accordingly.\n Since 2.22\n Params:\n hostAndPort = the name and optionally port of the host to connect to\n defaultPort = the default port to connect to\n cancellable = a GCancellable, or NULL\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 303}
,
{
"name" : "connectToHostAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string hostAndPort, ushort defaultPort, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n This is the asynchronous version of g_socket_client_connect_to_host().\n When the operation is finished callback will be\n called. You can then call g_socket_client_connect_to_host_finish() to get\n the result of the operation.\n Since 2.22\n Params:\n hostAndPort = the name and optionally the port of the host to connect to\n defaultPort = the default port to connect to\n cancellable = a GCancellable, or NULL\n callback = a GAsyncReadyCallback\n userData = user data for the callback\n\t \n",
"line" : 335}
,
{
"name" : "connectToHostFinish",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(AsyncResultIF result)",
"comment" : "\n Finishes an async connect operation. See g_socket_client_connect_to_host_async()\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 349}
,
{
"name" : "connectToService",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(string domain, string service, Cancellable cancellable)",
"comment" : "\n Attempts to create a TCP connection to a service.\n This call looks up the SRV record for service at domain for the\n \"tcp\" protocol. It then attempts to connect, in turn, to each of\n the hosts providing the service until either a connection succeeds\n or there are no hosts remaining.\n Upon a successful connection, a new GSocketConnection is constructed\n and returned. The caller owns this new object and must drop their\n reference to it when finished with it.\n In the event of any failure (DNS error, service not found, no hosts\n connectable) NULL is returned and error (if non-NULL) is set\n accordingly.\n Params:\n domain = a domain name\n service = the name of the service to connect to\n cancellable = a GCancellable, or NULL\n Returns: a GSocketConnection if successful, or NULL on error\n Throws: GException on failure.\n\t \n",
"line" : 387}
,
{
"name" : "connectToServiceAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string domain, string service, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n This is the asynchronous version of\n g_socket_client_connect_to_service().\n Since 2.22\n Params:\n domain = a domain name\n service = the name of the service to connect to\n cancellable = a GCancellable, or NULL\n callback = a GAsyncReadyCallback\n userData = user data for the callback\n\t \n",
"line" : 417}
,
{
"name" : "connectToServiceFinish",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(AsyncResultIF result)",
"comment" : "\n Finishes an async connect operation. See g_socket_client_connect_to_service_async()\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 431}
,
{
"name" : "connectToUri",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(string uri, ushort defaultPort, Cancellable cancellable)",
"comment" : "\n This is a helper function for g_socket_client_connect().\n Attempts to create a TCP connection with a network URI.\n uri may be any valid URI containing an \"authority\" (hostname\/port)\n component. If a port is not specified in the URI, default_port\n will be used.\n Using this rather than g_socket_client_connect() or\n g_socket_client_connect_to_host() allows GSocketClient to\n determine when to use application-specific proxy protocols.\n Upon a successful connection, a new GSocketConnection is constructed\n and returned. The caller owns this new object and must drop their\n reference to it when finished with it.\n In the event of any failure (DNS error, service not found, no hosts\n connectable) NULL is returned and error (if non-NULL) is set\n accordingly.\n Since 2.26\n Params:\n uri = A network URI\n defaultPort = the default port to connect to\n cancellable = a GCancellable, or NULL\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 473}
,
{
"name" : "connectToUriAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, ushort defaultPort, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n This is the asynchronous version of g_socket_client_connect_to_uri().\n When the operation is finished callback will be\n called. You can then call g_socket_client_connect_to_uri_finish() to get\n the result of the operation.\n Since 2.26\n Params:\n uri = a network uri\n defaultPort = the default port to connect to\n cancellable = a GCancellable, or NULL\n callback = a GAsyncReadyCallback\n userData = user data for the callback\n\t \n",
"line" : 505}
,
{
"name" : "connectToUriFinish",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(AsyncResultIF result)",
"comment" : "\n Finishes an async connect operation. See g_socket_client_connect_to_uri_async()\n Since 2.26\n Params:\n result = a GAsyncResult.\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 519}
,
{
"name" : "setFamily",
"kind" : "function",
"protection" : "public",
"type" : "void(GSocketFamily family)",
"comment" : "\n Sets the socket family of the socket client.\n If this is set to something other than G_SOCKET_FAMILY_INVALID\n then the sockets created by this object will be of the specified\n family.\n This might be useful for instance if you want to force the local\n connection to be an ipv4 socket, even though the address might\n be an ipv6 mapped to ipv4 address.\n Since 2.22\n Params:\n family = a GSocketFamily\n\t \n",
"line" : 550}
,
{
"name" : "setLocalAddress",
"kind" : "function",
"protection" : "public",
"type" : "void(SocketAddress address)",
"comment" : "\n Sets the local address of the socket client.\n The sockets created by this object will bound to the\n specified address (if not NULL) before connecting.\n This is useful if you want to ensure the the local\n side of the connection is on a specific port, or on\n a specific interface.\n Since 2.22\n Params:\n address = a GSocketAddress, or NULL\n\t \n",
"line" : 567}
,
{
"name" : "setProtocol",
"kind" : "function",
"protection" : "public",
"type" : "void(GSocketProtocol protocol)",
"comment" : "\n Sets the protocol of the socket client.\n The sockets created by this object will use of the specified\n protocol.\n If protocol is 0 that means to use the default\n protocol for the socket family and type.\n Since 2.22\n Params:\n protocol = a GSocketProtocol\n\t \n",
"line" : 583}
,
{
"name" : "setSocketType",
"kind" : "function",
"protection" : "public",
"type" : "void(GSocketType type)",
"comment" : "\n Sets the socket type of the socket client.\n The sockets created by this object will be of the specified\n type.\n It doesn't make sense to specify a type of G_SOCKET_TYPE_DATAGRAM,\n as GSocketClient is used for connection oriented services.\n Since 2.22\n Params:\n type = a GSocketType\n\t \n",
"line" : 599}
,
{
"name" : "setTimeout",
"kind" : "function",
"protection" : "public",
"type" : "void(uint timeout)",
"comment" : "\n Sets the I\/O timeout for sockets created by client. timeout is a\n time in seconds, or 0 for no timeout (the default).\n The timeout value affects the initial connection attempt as well,\n so setting this may cause calls to g_socket_client_connect(), etc,\n to fail with G_IO_ERROR_TIMED_OUT.\n Since 2.26\n Params:\n timeout = the timeout\n\t \n",
"line" : 615}
,
{
"name" : "getFamily",
"kind" : "function",
"protection" : "public",
"type" : "GSocketFamily()",
"comment" : "\n Gets the socket family of the socket client.\n See g_socket_client_set_family() for details.\n Since 2.22\n Returns: a GSocketFamily\n\t \n",
"line" : 627}
,
{
"name" : "getLocalAddress",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddress()",
"comment" : "\n Gets the local address of the socket client.\n See g_socket_client_set_local_address() for details.\n Since 2.22\n Returns: a GSocketAddres or NULL. don't free. [transfer none]\n\t \n",
"line" : 639}
,
{
"name" : "getProtocol",
"kind" : "function",
"protection" : "public",
"type" : "GSocketProtocol()",
"comment" : "\n Gets the protocol name type of the socket client.\n See g_socket_client_set_protocol() for details.\n Since 2.22\n Returns: a GSocketProtocol\n\t \n",
"line" : 656}
,
{
"name" : "getSocketType",
"kind" : "function",
"protection" : "public",
"type" : "GSocketType()",
"comment" : "\n Gets the socket type of the socket client.\n See g_socket_client_set_socket_type() for details.\n Since 2.22\n Returns: a GSocketFamily\n\t \n",
"line" : 668}
,
{
"name" : "getTimeout",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the I\/O timeout time for sockets created by client.\n See g_socket_client_set_timeout() for details.\n Since 2.26\n Returns: the timeout in seconds\n\t \n",
"line" : 680}
,
{
"name" : "getEnableProxy",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the proxy enable state; see g_socket_client_set_enable_proxy()\n Since 2.26\n Returns: whether proxying is enabled\n\t \n",
"line" : 691}
,
{
"name" : "setEnableProxy",
"kind" : "function",
"protection" : "public",
"type" : "void(int enable)",
"comment" : "\n Sets whether or not client attempts to make connections via a\n proxy server. When enabled (the default), GSocketClient will use a\n GProxyResolver to determine if a proxy protocol such as SOCKS is\n needed, and automatically do the necessary proxy negotiation.\n Since 2.26\n Params:\n enable = whether to enable proxies\n\t \n",
"line" : 706}
]
}
]
}
,
{
"name" : "gio.SocketConnectable",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketConnectable.d",
"members" : [
{
"name" : "SocketConnectable",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"SocketConnectableIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketConnectable(GSocketConnectable* gSocketConnectable)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.SocketConnectableIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketConnectableIF.d",
"members" : [
{
"name" : "SocketConnectableIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n Objects that describe one or more potential socket endpoints\n implement GSocketConnectable. Callers can then use\n g_socket_connectable_enumerate() to get a GSocketAddressEnumerator\n to try out each socket address in turn until one succeeds, as shown\n in the sample code below.\n $(DDOC_COMMENT example)\n \n",
"line" : 77,
"members" : [
{
"name" : "getSocketConnectableTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketConnectable*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 83}
,
{
"name" : "enumerate",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddressEnumerator()",
"comment" : "\n\t \n\n Creates a GSocketAddressEnumerator for connectable.\n Since 2.22\n Returns: a new GSocketAddressEnumerator.\n\t \n",
"line" : 94}
,
{
"name" : "proxyEnumerate",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddressEnumerator()",
"comment" : "\n Creates a GSocketAddressEnumerator for connectable that will\n return GProxyAddresses for addresses that you must connect\n to via a proxy.\n If connectable does not implement\n g_socket_connectable_proxy_enumerate(), this will fall back to\n calling g_socket_connectable_enumerate().\n Since 2.26\n Returns: a new GSocketAddressEnumerator.\n\t \n",
"line" : 106}
]
}
]
}
,
{
"name" : "gio.SocketConnectableT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketConnectableT.d",
"members" : [
{
"name" : "SocketConnectableT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n Objects that describe one or more potential socket endpoints\n implement GSocketConnectable. Callers can then use\n g_socket_connectable_enumerate() to get a GSocketAddressEnumerator\n to try out each socket address in turn until one succeeds, as shown\n in the sample code below.\n $(DDOC_COMMENT example)\n \n",
"line" : 77,
"members" : [
{
"name" : "gSocketConnectable",
"kind" : "variable",
"type" : "GSocketConnectable*",
"comment" : " the main Gtk struct \n",
"line" : 81}
,
{
"name" : "getSocketConnectableTStruct",
"kind" : "function",
"type" : "GSocketConnectable*()",
"line" : 84}
,
{
"name" : "enumerate",
"kind" : "function",
"type" : "SocketAddressEnumerator()",
"comment" : "\n\t \n\n Creates a GSocketAddressEnumerator for connectable.\n Since 2.22\n Returns: a new GSocketAddressEnumerator.\n\t \n",
"line" : 98}
,
{
"name" : "proxyEnumerate",
"kind" : "function",
"type" : "SocketAddressEnumerator()",
"comment" : "\n Creates a GSocketAddressEnumerator for connectable that will\n return GProxyAddresses for addresses that you must connect\n to via a proxy.\n If connectable does not implement\n g_socket_connectable_proxy_enumerate(), this will fall back to\n calling g_socket_connectable_enumerate().\n Since 2.26\n Returns: a new GSocketAddressEnumerator.\n\t \n",
"line" : 119}
]
}
]
}
,
{
"name" : "gio.SocketConnection",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketConnection.d",
"members" : [
{
"name" : "SocketConnection",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GSocketConnection is a GIOStream for a connected socket. They\n can be created either by GSocketClient when connecting to a host,\n or by GSocketListener when accepting a new client.\n The type of the GSocketConnection object returned from these calls\n depends on the type of the underlying socket that is in use. For\n instance, for a TCP\/IP connection it will be a GTcpConnection.\n Chosing what type of object to construct is done with the socket\n connection factory, and it is possible for 3rd parties to register\n custom socket connection types for specific combination of socket\n family\/type\/protocol using g_socket_connection_factory_register_type().\n \n",
"line" : 90,
"base" : "IOStream",
"members" : [
{
"name" : "gSocketConnection",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketConnection*",
"comment" : " the main Gtk struct \n",
"line" : 94}
,
{
"name" : "getSocketConnectionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketConnection*()",
"line" : 97}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 104}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketConnection(GSocketConnection* gSocketConnection)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 112}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 130}
,
{
"name" : "getLocalAddress",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddress()",
"comment" : "\n\t \n\n Try to get the local address of a socket connection.\n Since 2.22\n Returns: a GSocketAddress or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 145}
,
{
"name" : "getRemoteAddress",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddress()",
"comment" : "\n Try to get the remote address of a socket connection.\n Since 2.22\n Returns: a GSocketAddress or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 170}
,
{
"name" : "getSocket",
"kind" : "function",
"protection" : "public",
"type" : "Socket()",
"comment" : "\n Gets the underlying GSocket object of the connection.\n This can be useful if you want to do something unusual on it\n not supported by the GSocketConnection APIs.\n Since 2.22\n Returns: a GSocketAddress or NULL on error. [transfer none]\n\t \n",
"line" : 196}
,
{
"name" : "factoryCreateConnection",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(Socket socket)",
"comment" : "\n Creates a GSocketConnection subclass of the right type for\n socket.\n Since 2.22\n Params:\n socket = a GSocket\n Returns: a GSocketConnection\n\t \n",
"line" : 215}
,
{
"name" : "factoryLookupType",
"kind" : "function",
"protection" : "public",
"type" : "GType(GSocketFamily family, GSocketType type, int protocolId)",
"comment" : "\n Looks up the GType to be used when creating socket connections on\n sockets with the specified family,type and protocol_id.\n If no type is registered, the GSocketConnection base type is returned.\n Since 2.22\n Params:\n family = a GSocketFamily\n type = a GSocketType\n protocolId = a protocol id\n Returns: a GType\n\t \n",
"line" : 237}
,
{
"name" : "factoryRegisterType",
"kind" : "function",
"protection" : "public",
"type" : "void(GType gType, GSocketFamily family, GSocketType type, int protocol)",
"comment" : "\n Looks up the GType to be used when creating socket connections on\n sockets with the specified family,type and protocol.\n If no type is registered, the GSocketConnection base type is returned.\n Since 2.22\n Params:\n gType = a GType, inheriting from G_TYPE_SOCKET_CONNECTION\n family = a GSocketFamily\n type = a GSocketType\n protocol = a protocol id\n\t \n",
"line" : 254}
]
}
]
}
,
{
"name" : "gio.SocketControlMessage",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketControlMessage.d",
"members" : [
{
"name" : "SocketControlMessage",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GSocketControlMessage is a special-purpose utility message that\n can be sent to or received from a GSocket. These types of\n messages are often called \"ancillary data\".\n The message can represent some sort of special instruction to or\n information from the socket or can represent a special kind of\n transfer to the peer (for example, sending a file description over\n a UNIX socket).\n These messages are sent with g_socket_send_message() and received\n with g_socket_receive_message().\n To extend the set of control message that can be sent, subclass this\n class and override the get_size, get_level, get_type and serialize\n methods.\n To extend the set of control messages that can be received, subclass\n this class and implement the deserialize method. Also, make sure your\n class is registered with the GType typesystem before calling\n g_socket_receive_message() to read such a message.\n \n",
"line" : 84,
"base" : "ObjectG",
"members" : [
{
"name" : "gSocketControlMessage",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketControlMessage*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getSocketControlMessageStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketControlMessage*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketControlMessage(GSocketControlMessage* gSocketControlMessage)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 124}
,
{
"name" : "deserialize",
"kind" : "function",
"protection" : "public",
"type" : "SocketControlMessage(int level, int type, ulong size, void* data)",
"comment" : "\n\t \n\n Tries to deserialize a socket control message of a given\n level and type. This will ask all known (to GType) subclasses\n of GSocketControlMessage if they can understand this kind\n of message and if so deserialize it into a GSocketControlMessage.\n If there is no implementation for this kind of control message, NULL\n will be returned.\n Since 2.22\n Params:\n level = a socket level\n type = a socket control message type for the given level\n size = the size of the data in bytes\n data = pointer to the message data\n Returns: the deserialized message or NULL\n\t \n",
"line" : 148}
,
{
"name" : "getLevel",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the \"level\" (i.e. the originating protocol) of the control message.\n This is often SOL_SOCKET.\n Since 2.22\n Returns: an integer describing the level\n\t \n",
"line" : 165}
,
{
"name" : "getMsgType",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the protocol specific type of the control message.\n For instance, for UNIX fd passing this would be SCM_RIGHTS.\n Since 2.22\n Returns: an integer describing the type of control message\n\t \n",
"line" : 177}
,
{
"name" : "getSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Returns the space required for the control message, not including\n headers or alignment.\n Since 2.22\n Returns: The number of bytes required.\n\t \n",
"line" : 189}
,
{
"name" : "serialize",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Converts the data in the message to bytes placed in the\n message.\n data is guaranteed to have enough space to fit the size\n returned by g_socket_control_message_get_size() on this\n object.\n Since 2.22\n Params:\n data = A buffer to write data to\n\t \n",
"line" : 205}
]
}
]
}
,
{
"name" : "gio.Socket",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Socket.d",
"members" : [
{
"name" : "Socket",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GSocket is a low-level networking primitive. It is a more or less\n direct mapping of the BSD socket API in a portable GObject based API.\n It supports both the UNIX socket implementations and winsock2 on Windows.\n GSocket is the platform independent base upon which the higher level\n network primitives are based. Applications are not typically meant to\n use it directly, but rather through classes like GSocketClient,\n GSocketService and GSocketConnection. However there may be cases where\n direct use of GSocket is useful.\n GSocket implements the GInitable interface, so if it is manually constructed\n by e.g. g_object_new() you must call g_initable_init() and check the\n results before using the object. This is done automatically in\n g_socket_new() and g_socket_new_from_fd(), so these functions can return\n NULL.\n Sockets operate in two general modes, blocking or non-blocking. When\n in blocking mode all operations block until the requested operation\n is finished or there is an error. In non-blocking mode all calls that\n would block return immediately with a G_IO_ERROR_WOULD_BLOCK error.\n To know when a call would successfully run you can call g_socket_condition_check(),\n or g_socket_condition_wait(). You can also use g_socket_create_source() and\n attach it to a GMainContext to get callbacks when I\/O is possible.\n Note that all sockets are always set to non blocking mode in the system, and\n blocking mode is emulated in GSocket.\n When working in non-blocking mode applications should always be able to\n handle getting a G_IO_ERROR_WOULD_BLOCK error even when some other\n function said that I\/O was possible. This can easily happen in case\n of a race condition in the application, but it can also happen for other\n reasons. For instance, on Windows a socket is always seen as writable\n until a write returns G_IO_ERROR_WOULD_BLOCK.\n GSockets can be either connection oriented or datagram based.\n For connection oriented types you must first establish a connection by\n either connecting to an address or accepting a connection from another\n address. For connectionless socket types the target\/source address is\n specified or received in each I\/O operation.\n All socket file descriptors are set to be close-on-exec.\n Note that creating a GSocket causes the signal SIGPIPE to be\n ignored for the remainder of the program. If you are writing a\n command-line utility that uses GSocket, you may need to take into\n account the fact that your program will not automatically be killed\n if it tries to write to stdout after it has been closed.\n \n",
"line" : 135,
"base" : "ObjectG",
"interfaces" : [
"InitableIF"],
"members" : [
{
"name" : "gSocket",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocket*",
"comment" : " the main Gtk struct \n",
"line" : 139}
,
{
"name" : "getSocketStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocket*()",
"line" : 142}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 149}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(GSocket* gSocket)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 157}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 175}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(GSocketFamily family, GSocketType type, GSocketProtocol protocol)",
"comment" : "\n\t \n\n Creates a new GSocket with the defined family, type and protocol.\n If protocol is 0 (G_SOCKET_PROTOCOL_DEFAULT) the default protocol type\n for the family and type is used.\n The protocol is a family and type specific int that specifies what\n kind of protocol to use. GSocketProtocol lists several common ones.\n Many families only support one protocol, and use 0 for this, others\n support several and using 0 means to use the default protocol for\n the family and type.\n The protocol id is passed directly to the operating\n system, so you can use protocols not listed in GSocketProtocol if you\n know the protocol number used for it.\n Since 2.22\n Params:\n family = the socket family to use, e.g. G_SOCKET_FAMILY_IPV4.\n type = the socket type to use.\n protocol = the id of the protocol to use, or 0 for default.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 207}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Socket(int fd)",
"comment" : "\n Creates a new GSocket from a native file descriptor\n or winsock SOCKET handle.\n This reads all the settings from the file descriptor so that\n all properties should work. Note that the file descriptor\n will be set to non-blocking mode, independent on the blocking\n mode of the GSocket.\n Since 2.22\n Params:\n fd = a native socket file descriptor.\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 239}
,
{
"name" : "bind",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketAddress address, int allowReuse)",
"comment" : "\n When a socket is created it is attached to an address family, but it\n doesn't have an address in this family. g_socket_bind() assigns the\n address (sometimes called name) of the socket.\n It is generally required to bind to a local address before you can\n receive connections. (See g_socket_listen() and g_socket_accept() ).\n In certain situations, you may also want to bind a socket that will be\n used to initiate connections, though this is not normally required.\n allow_reuse should be TRUE for server sockets (sockets that you will\n eventually call g_socket_accept() on), and FALSE for client sockets.\n (Specifically, if it is TRUE, then g_socket_bind() will set the\n SO_REUSEADDR flag on the socket, allowing it to bind address even if\n that address was previously used by another socket that has not yet been\n fully cleaned-up by the kernel. Failing to set this flag on a server\n socket may cause the bind call to return G_IO_ERROR_ADDRESS_IN_USE if\n the server program is stopped and then immediately restarted.)\n Since 2.22\n Params:\n address = a GSocketAddress specifying the local address.\n allowReuse = whether to allow reusing this address\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 281}
,
{
"name" : "listen",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Marks the socket as a server socket, i.e. a socket that is used\n to accept incoming requests using g_socket_accept().\n Before calling this the socket must be bound to a local address using\n g_socket_bind().\n To set the maximum amount of outstanding clients, use\n g_socket_set_listen_backlog().\n Since 2.22\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 307}
,
{
"name" : "accept",
"kind" : "function",
"protection" : "public",
"type" : "GSocket*(Cancellable cancellable)",
"comment" : "\n Accept incoming connections on a connection-based socket. This removes\n the first outstanding connection request from the listening socket and\n creates a GSocket object for it.\n The socket must be bound to a local address with g_socket_bind() and\n must be listening for incoming connections (g_socket_listen()).\n If there are no outstanding connections then the operation will block\n or return G_IO_ERROR_WOULD_BLOCK if non-blocking I\/O is enabled.\n To be notified of an incoming connection, wait for the G_IO_IN condition.\n Since 2.22\n Params:\n cancellable = a GCancellable or NULL\n Returns: a new GSocket, or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 337}
,
{
"name" : "connect",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketAddress address, Cancellable cancellable)",
"comment" : "\n Connect the socket to the specified remote address.\n For connection oriented socket this generally means we attempt to make\n a connection to the address. For a connection-less socket it sets\n the default address for g_socket_send() and discards all incoming datagrams\n from other sources.\n Generally connection oriented sockets can only connect once, but\n connection-less sockets can connect multiple times to change the\n default address.\n If the connect call needs to do network I\/O it will block, unless\n non-blocking I\/O is enabled. Then G_IO_ERROR_PENDING is returned\n and the user can be notified of the connection finishing by waiting\n for the G_IO_OUT condition. The result of the connection can then be\n checked with g_socket_check_connect_result().\n Since 2.22\n Params:\n address = a GSocketAddress specifying the remote address.\n cancellable = a GCancellable or NULL\n Returns: TRUE if connected, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 373}
,
{
"name" : "checkConnectResult",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks and resets the pending connect error for the socket.\n This is used to check for errors when g_socket_connect() is\n used in non-blocking mode.\n Since 2.22\n Returns: TRUE if no error, FALSE otherwise, setting error to the error\n Throws: GException on failure.\n\t \n",
"line" : 396}
,
{
"name" : "receive",
"kind" : "function",
"protection" : "public",
"type" : "long(string buffer, ulong size, Cancellable cancellable)",
"comment" : "\n Receive data (up to size bytes) from a socket. This is mainly used by\n connection-oriented sockets; it is identical to g_socket_receive_from()\n with address set to NULL.\n For G_SOCKET_TYPE_DATAGRAM and G_SOCKET_TYPE_SEQPACKET sockets,\n g_socket_receive() will always read either 0 or 1 complete messages from\n the socket. If the received message is too large to fit in buffer, then\n the data beyond size bytes will be discarded, without any explicit\n indication that this has occurred.\n For G_SOCKET_TYPE_STREAM sockets, g_socket_receive() can return any\n number of bytes, up to size. If more than size bytes have been\n received, the additional data will be returned in future calls to\n g_socket_receive().\n If the socket is in blocking mode the call will block until there is\n some data to receive or there is an error. If there is no data available\n and the socket is in non-blocking mode, a G_IO_ERROR_WOULD_BLOCK error\n will be returned. To be notified when data is available, wait for the\n G_IO_IN condition.\n On error -1 is returned and error is set accordingly.\n Since 2.22\n Params:\n buffer = a buffer to read data into (which should be at least size\n  bytes long).\n size = the number of bytes you want to read from the socket\n cancellable = a GCancellable or NULL\n Returns: Number of bytes read, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 439}
,
{
"name" : "receiveFrom",
"kind" : "function",
"protection" : "public",
"type" : "long(ref SocketAddress address, char[] buffer, Cancellable cancellable)",
"comment" : "\n Receive data (up to size bytes) from a socket.\n If address is non-NULL then address will be set equal to the\n source address of the received packet.\n address is owned by the caller.\n See g_socket_receive() for additional information.\n Since 2.22\n Params:\n address = a pointer to a GSocketAddress pointer, or NULL\n buffer = a buffer to read data into (which should be at least size\n  bytes long).\n size = the number of bytes you want to read from the socket\n cancellable = a GCancellable or NULL\n Returns: Number of bytes read, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 470}
,
{
"name" : "receiveMessage",
"kind" : "function",
"protection" : "public",
"type" : "long(ref SocketAddress address, GInputVector[] vectors, ref SocketControlMessage[] messages, ref int flags, Cancellable cancellable)",
"comment" : "\n Receive data from a socket. This is the most complicated and\n fully-featured version of this call. For easier use, see\n g_socket_receive() and g_socket_receive_from().\n If address is non-NULL then address will be set equal to the\n source address of the received packet.\n address is owned by the caller.\n vector must point to an array of GInputVector structs and\n num_vectors must be the length of this array. These structs\n describe the buffers that received data will be scattered into.\n If num_vectors is -1, then vectors is assumed to be terminated\n by a GInputVector with a NULL buffer pointer.\n As a special case, if num_vectors is 0 (in which case, vectors\n may of course be NULL), then a single byte is received and\n discarded. This is to facilitate the common practice of sending a\n single '\\0' byte for the purposes of transferring ancillary data.\n messages, if non-NULL, will be set to point to a newly-allocated\n array of GSocketControlMessage instances or NULL if no such\n messages was received. These correspond to the control messages\n received from the kernel, one GSocketControlMessage per message\n from the kernel. This array is NULL-terminated and must be freed\n by the caller using g_free() after calling g_object_unref() on each\n element. If messages is NULL, any control messages received will\n be discarded.\n num_messages, if non-NULL, will be set to the number of control\n messages received.\n If both messages and num_messages are non-NULL, then\n num_messages gives the number of GSocketControlMessage instances\n in messages (ie: not including the NULL terminator).\n flags is an in\/out parameter. The commonly available arguments\n for this are available in the GSocketMsgFlags enum, but the\n values there are the same as the system values, and the flags\n are passed in as-is, so you can pass in system-specific flags too\n (and g_socket_receive_message() may pass system-specific flags out).\n As with g_socket_receive(), data may be discarded if socket is\n G_SOCKET_TYPE_DATAGRAM or G_SOCKET_TYPE_SEQPACKET and you do not\n provide enough buffer space to read a complete message. You can pass\n G_SOCKET_MSG_PEEK in flags to peek at the current message without\n removing it from the receive queue, but there is no portable way to find\n out the length of the message other than by reading it into a\n sufficiently-large buffer.\n If the socket is in blocking mode the call will block until there\n is some data to receive or there is an error. If there is no data\n available and the socket is in non-blocking mode, a\n G_IO_ERROR_WOULD_BLOCK error will be returned. To be notified when\n data is available, wait for the G_IO_IN condition.\n On error -1 is returned and error is set accordingly.\n Since 2.22\n Params:\n address = a pointer to a GSocketAddress pointer, or NULL\n vectors = an array of GInputVector structs\n messages = a pointer which may be filled with an array of\n  GSocketControlMessages, or NULL\n flags = a pointer to an int containing GSocketMsgFlags flags\n cancellable = a GCancellable or NULL\n Returns: Number of bytes read, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 545}
,
{
"name" : "receiveWithBlocking",
"kind" : "function",
"protection" : "public",
"type" : "long(string buffer, ulong size, int blocking, Cancellable cancellable)",
"comment" : "\n This behaves exactly the same as g_socket_receive(), except that\n the choice of blocking or non-blocking behavior is determined by\n the blocking argument rather than by socket's properties.\n Since 2.26\n Params:\n buffer = a buffer to read data into (which should be at least size\n  bytes long).\n size = the number of bytes you want to read from the socket\n blocking = whether to do blocking or non-blocking I\/O\n cancellable = a GCancellable or NULL\n Returns: Number of bytes read, or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 591}
,
{
"name" : "send",
"kind" : "function",
"protection" : "public",
"type" : "long(string buffer, ulong size, Cancellable cancellable)",
"comment" : "\n Tries to send size bytes from buffer on the socket. This is\n mainly used by connection-oriented sockets; it is identical to\n g_socket_send_to() with address set to NULL.\n If the socket is in blocking mode the call will block until there is\n space for the data in the socket queue. If there is no space available\n and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error\n will be returned. To be notified when space is available, wait for the\n G_IO_OUT condition. Note though that you may still receive\n G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously\n notified of a G_IO_OUT condition. (On Windows in particular, this is\n very common due to the way the underlying APIs work.)\n On error -1 is returned and error is set accordingly.\n Since 2.22\n Params:\n buffer = the buffer containing the data to send.\n size = the number of bytes to send\n cancellable = a GCancellable or NULL\n Returns: Number of bytes written (which may be less than size), or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 627}
,
{
"name" : "sendTo",
"kind" : "function",
"protection" : "public",
"type" : "long(SocketAddress address, string buffer, ulong size, Cancellable cancellable)",
"comment" : "\n Tries to send size bytes from buffer to address. If address is\n NULL then the message is sent to the default receiver (set by\n g_socket_connect()).\n See g_socket_send() for additional information.\n Since 2.22\n Params:\n address = a GSocketAddress, or NULL\n buffer = the buffer containing the data to send.\n size = the number of bytes to send\n cancellable = a GCancellable or NULL\n Returns: Number of bytes written (which may be less than size), or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 656}
,
{
"name" : "sendMessage",
"kind" : "function",
"protection" : "public",
"type" : "long(SocketAddress address, GOutputVector[] vectors, ref GSocketControlMessage[] messages, int flags, Cancellable cancellable)",
"comment" : "\n Send data to address on socket. This is the most complicated and\n fully-featured version of this call. For easier use, see\n g_socket_send() and g_socket_send_to().\n If address is NULL then the message is sent to the default receiver\n (set by g_socket_connect()).\n vectors must point to an array of GOutputVector structs and\n num_vectors must be the length of this array. (If num_vectors is -1,\n then vectors is assumed to be terminated by a GOutputVector with a\n NULL buffer pointer.) The GOutputVector structs describe the buffers\n that the sent data will be gathered from. Using multiple\n GOutputVectors is more memory-efficient than manually copying\n data from multiple sources into a single buffer, and more\n network-efficient than making multiple calls to g_socket_send().\n messages, if non-NULL, is taken to point to an array of num_messages\n GSocketControlMessage instances. These correspond to the control\n messages to be sent on the socket.\n If num_messages is -1 then messages is treated as a NULL-terminated\n array.\n flags modify how the message is sent. The commonly available arguments\n for this are available in the GSocketMsgFlags enum, but the\n values there are the same as the system values, and the flags\n are passed in as-is, so you can pass in system-specific flags too.\n If the socket is in blocking mode the call will block until there is\n space for the data in the socket queue. If there is no space available\n and the socket is in non-blocking mode a G_IO_ERROR_WOULD_BLOCK error\n will be returned. To be notified when space is available, wait for the\n G_IO_OUT condition. Note though that you may still receive\n G_IO_ERROR_WOULD_BLOCK from g_socket_send() even if you were previously\n notified of a G_IO_OUT condition. (On Windows in particular, this is\n very common due to the way the underlying APIs work.)\n On error -1 is returned and error is set accordingly.\n Since 2.22\n Params:\n address = a GSocketAddress, or NULL\n vectors = an array of GOutputVector structs\n messages = a pointer to an array of GSocketControlMessages, or\n  NULL.\n flags = an int containing GSocketMsgFlags flags\n cancellable = a GCancellable or NULL\n Returns: Number of bytes written (which may be less than size), or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 714}
,
{
"name" : "sendWithBlocking",
"kind" : "function",
"protection" : "public",
"type" : "long(string buffer, ulong size, int blocking, Cancellable cancellable)",
"comment" : "\n This behaves exactly the same as g_socket_send(), except that\n the choice of blocking or non-blocking behavior is determined by\n the blocking argument rather than by socket's properties.\n Since 2.26\n Params:\n buffer = the buffer containing the data to send.\n size = the number of bytes to send\n blocking = whether to do blocking or non-blocking I\/O\n cancellable = a GCancellable or NULL\n Returns: Number of bytes written (which may be less than size), or -1 on error\n Throws: GException on failure.\n\t \n",
"line" : 745}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Closes the socket, shutting down any active connection.\n Closing a socket does not wait for all outstanding I\/O operations\n to finish, so the caller should not rely on them to be guaranteed\n to complete even if the close returns with no error.\n Once the socket is closed, all other operations will return\n G_IO_ERROR_CLOSED. Closing a socket multiple times will not\n return an error.\n Sockets will be automatically closed when the last reference\n is dropped, but you might want to call this function to make sure\n resources are released as early as possible.\n Beware that due to the way that TCP works, it is possible for\n recently-sent data to be lost if either you close a socket while the\n G_IO_IN condition is set, or else if the remote connection tries to\n send something to you after you close the socket but before it has\n finished reading all of the data you sent. There is no easy generic\n way to avoid this problem; the easiest fix is to design the network\n protocol such that the client will never send data \"out of turn\".\n Another solution is for the server to half-close the connection by\n calling g_socket_shutdown() with only the shutdown_write flag set,\n and then wait for the client to notice this and close its side of the\n connection, after which the server can safely call g_socket_close().\n (This is what GTcpConnection does if you call\n g_tcp_connection_set_graceful_disconnect(). But of course, this\n only works if the client will close its connection after the server\n does.)\n Since 2.22\n Returns: TRUE on success, FALSE on error\n Throws: GException on failure.\n\t \n",
"line" : 790}
,
{
"name" : "isClosed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks whether a socket is closed.\n Since 2.22\n Returns: TRUE if socket is closed, FALSE otherwise\n\t \n",
"line" : 810}
,
{
"name" : "shutdown",
"kind" : "function",
"protection" : "public",
"type" : "int(int shutdownRead, int shutdownWrite)",
"comment" : "\n Shut down part of a full-duplex connection.\n If shutdown_read is TRUE then the recieving side of the connection\n is shut down, and further reading is disallowed.\n If shutdown_write is TRUE then the sending side of the connection\n is shut down, and further writing is disallowed.\n It is allowed for both shutdown_read and shutdown_write to be TRUE.\n One example where this is used is graceful disconnect for TCP connections\n where you close the sending side, then wait for the other side to close\n the connection, thus ensuring that the other side saw all sent data.\n Since 2.22\n Params:\n shutdownRead = whether to shut down the read side\n shutdownWrite = whether to shut down the write side\n Returns: TRUE on success, FALSE on error\n Throws: GException on failure.\n\t \n",
"line" : 833}
,
{
"name" : "isConnected",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Check whether the socket is connected. This is only useful for\n connection-oriented sockets.\n Since 2.22\n Returns: TRUE if socket is connected, FALSE otherwise.\n\t \n",
"line" : 854}
,
{
"name" : "createSource",
"kind" : "function",
"protection" : "public",
"type" : "Source(GIOCondition condition, Cancellable cancellable)",
"comment" : "\n Creates a GSource that can be attached to a GMainContext to monitor\n for the availibility of the specified condition on the socket.\n The callback on the source is of the GSocketSourceFunc type.\n It is meaningless to specify G_IO_ERR or G_IO_HUP in condition;\n these conditions will always be reported output if they are true.\n cancellable if not NULL can be used to cancel the source, which will\n cause the source to trigger, reporting the current condition (which\n is likely 0 unless cancellation happened at the same time as a\n condition change). You can check for this in the callback using\n g_cancellable_is_cancelled().\n If socket has a timeout set, and it is reached before condition\n occurs, the source will then trigger anyway, reporting G_IO_IN or\n G_IO_OUT depending on condition. However, socket will have been\n marked as having had a timeout, and so the next GSocket I\/O method\n you call will then fail with a G_IO_ERROR_TIMED_OUT.\n Since 2.22\n Params:\n condition = a GIOCondition mask to monitor\n cancellable = a GCancellable or NULL\n Returns: a newly allocated GSource, free with g_source_unref().\n\t \n",
"line" : 882}
,
{
"name" : "conditionCheck",
"kind" : "function",
"protection" : "public",
"type" : "GIOCondition(GIOCondition condition)",
"comment" : "\n Checks on the readiness of socket to perform operations.\n The operations specified in condition are checked for and masked\n against the currently-satisfied conditions on socket. The result\n is returned.\n Note that on Windows, it is possible for an operation to return\n G_IO_ERROR_WOULD_BLOCK even immediately after\n g_socket_condition_check() has claimed that the socket is ready for\n writing. Rather than calling g_socket_condition_check() and then\n writing to the socket if it succeeds, it is generally better to\n simply try writing to the socket right away, and try again later if\n the initial attempt returns G_IO_ERROR_WOULD_BLOCK.\n It is meaningless to specify G_IO_ERR or G_IO_HUP in condition;\n these conditions will always be set in the output if they are true.\n This call never blocks.\n Since 2.22\n Params:\n condition = a GIOCondition mask to check\n Returns: the GIOCondition mask of the current state\n\t \n",
"line" : 913}
,
{
"name" : "conditionWait",
"kind" : "function",
"protection" : "public",
"type" : "int(GIOCondition condition, Cancellable cancellable)",
"comment" : "\n Waits for condition to become true on socket. When the condition\n is met, TRUE is returned.\n If cancellable is cancelled before the condition is met, or if the\n socket has a timeout set and it is reached before the condition is\n met, then FALSE is returned and error, if non-NULL, is set to\n the appropriate value (G_IO_ERROR_CANCELLED or\n G_IO_ERROR_TIMED_OUT).\n Since 2.22\n Params:\n condition = a GIOCondition mask to wait for\n cancellable = a GCancellable, or NULL\n Returns: TRUE if the condition was met, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 934}
,
{
"name" : "setListenBacklog",
"kind" : "function",
"protection" : "public",
"type" : "void(int backlog)",
"comment" : "\n Sets the maximum number of outstanding connections allowed\n when listening on this socket. If more clients than this are\n connecting to the socket and the application is not handling them\n on time then the new connections will be refused.\n Note that this must be called before g_socket_listen() and has no\n effect if called after that.\n Since 2.22\n Params:\n backlog = the maximum number of pending connections.\n\t \n",
"line" : 960}
,
{
"name" : "getListenBacklog",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the listen backlog setting of the socket. For details on this,\n see g_socket_set_listen_backlog().\n Since 2.22\n Returns: the maximum number of pending connections.\n\t \n",
"line" : 972}
,
{
"name" : "getBlocking",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the blocking mode of the socket. For details on blocking I\/O,\n see g_socket_set_blocking().\n Since 2.22\n Returns: TRUE if blocking I\/O is used, FALSE otherwise.\n\t \n",
"line" : 984}
,
{
"name" : "setBlocking",
"kind" : "function",
"protection" : "public",
"type" : "void(int blocking)",
"comment" : "\n Sets the blocking mode of the socket. In blocking mode\n all operations block until they succeed or there is an error. In\n non-blocking mode all functions return results immediately or\n with a G_IO_ERROR_WOULD_BLOCK error.\n All sockets are created in blocking mode. However, note that the\n platform level socket is always non-blocking, and blocking mode\n is a GSocket level feature.\n Since 2.22\n Params:\n blocking = Whether to use blocking I\/O or not.\n\t \n",
"line" : 1002}
,
{
"name" : "getKeepalive",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the keepalive mode of the socket. For details on this,\n see g_socket_set_keepalive().\n Since 2.22\n Returns: TRUE if keepalive is active, FALSE otherwise.\n\t \n",
"line" : 1014}
,
{
"name" : "setKeepalive",
"kind" : "function",
"protection" : "public",
"type" : "void(int keepalive)",
"comment" : "\n Sets or unsets the SO_KEEPALIVE flag on the underlying socket. When\n this flag is set on a socket, the system will attempt to verify that the\n remote socket endpoint is still present if a sufficiently long period of\n time passes with no data being exchanged. If the system is unable to\n verify the presence of the remote endpoint, it will automatically close\n the connection.\n This option is only functional on certain kinds of sockets. (Notably,\n G_SOCKET_PROTOCOL_TCP sockets.)\n The exact time between pings is system- and protocol-dependent, but will\n normally be at least two hours. Most commonly, you would set this flag\n on a server socket if you want to allow clients to remain idle for long\n periods of time, but also want to ensure that connections are eventually\n garbage-collected if clients crash or become unreachable.\n Since 2.22\n Params:\n keepalive = Value for the keepalive flag\n\t \n",
"line" : 1038}
,
{
"name" : "getTimeout",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the timeout setting of the socket. For details on this, see\n g_socket_set_timeout().\n Since 2.26\n Returns: the timeout in seconds\n\t \n",
"line" : 1050}
,
{
"name" : "setTimeout",
"kind" : "function",
"protection" : "public",
"type" : "void(uint timeout)",
"comment" : "\n Sets the time in seconds after which I\/O operations on socket will\n time out if they have not yet completed.\n On a blocking socket, this means that any blocking GSocket\n operation will time out after timeout seconds of inactivity,\n returning G_IO_ERROR_TIMED_OUT.\n On a non-blocking socket, calls to g_socket_condition_wait() will\n also fail with G_IO_ERROR_TIMED_OUT after the given time. Sources\n created with g_socket_create_source() will trigger after\n timeout seconds of inactivity, with the requested condition\n set, at which point calling g_socket_receive(), g_socket_send(),\n g_socket_check_connect_result(), etc, will fail with\n G_IO_ERROR_TIMED_OUT.\n If timeout is 0 (the default), operations will never time out\n on their own.\n Note that if an I\/O operation is interrupted by a signal, this may\n cause the timeout to be reset.\n Since 2.26\n Params:\n timeout = the timeout for socket, in seconds, or 0 for none\n\t \n",
"line" : 1077}
,
{
"name" : "getFamily",
"kind" : "function",
"protection" : "public",
"type" : "GSocketFamily()",
"comment" : "\n Gets the socket family of the socket.\n Since 2.22\n Returns: a GSocketFamily\n\t \n",
"line" : 1088}
,
{
"name" : "getFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the underlying OS socket object. On unix this\n is a socket file descriptor, and on windows this is\n a Winsock2 SOCKET handle. This may be useful for\n doing platform specific or otherwise unusual operations\n on the socket.\n Since 2.22\n Returns: the file descriptor of the socket.\n\t \n",
"line" : 1103}
,
{
"name" : "getLocalAddress",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddress()",
"comment" : "\n Try to get the local address of a bound socket. This is only\n useful if the socket has been bound to a local address,\n either explicitly or implicitly when connecting.\n Since 2.22\n Returns: a GSocketAddress or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1117}
,
{
"name" : "getProtocol",
"kind" : "function",
"protection" : "public",
"type" : "GSocketProtocol()",
"comment" : "\n Gets the socket protocol id the socket was created with.\n In case the protocol is unknown, -1 is returned.\n Since 2.22\n Returns: a protocol id, or -1 if unknown\n\t \n",
"line" : 1142}
,
{
"name" : "getRemoteAddress",
"kind" : "function",
"protection" : "public",
"type" : "SocketAddress()",
"comment" : "\n Try to get the remove address of a connected socket. This is only\n useful for connection oriented sockets that have been connected.\n Since 2.22\n Returns: a GSocketAddress or NULL on error. Free the returned object with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1155}
,
{
"name" : "getSocketType",
"kind" : "function",
"protection" : "public",
"type" : "GSocketType()",
"comment" : "\n Gets the socket type of the socket.\n Since 2.22\n Returns: a GSocketType\n\t \n",
"line" : 1179}
,
{
"name" : "speaksIpv4",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a socket is capable of speaking IPv4.\n IPv4 sockets are capable of speaking IPv4. On some operating systems\n and under some combinations of circumstances IPv6 sockets are also\n capable of speaking IPv4. See RFC 3493 section 3.7 for more\n information.\n No other types of sockets are currently considered as being capable\n of speaking IPv4.\n Since 2.22\n Returns: TRUE if this socket can be used with IPv4.\n\t \n",
"line" : 1196}
,
{
"name" : "getCredentials",
"kind" : "function",
"protection" : "public",
"type" : "Credentials()",
"comment" : "\n Returns the credentials of the foreign process connected to this\n socket, if any (e.g. it is only supported for G_SOCKET_FAMILY_UNIX\n sockets).\n If this operation isn't supported on the OS, the method fails with\n the G_IO_ERROR_NOT_SUPPORTED error. On Linux this is implemented\n by reading the SO_PEERCRED option on the underlying socket.\n Other ways to obtain credentials from a foreign peer includes the\n GUnixCredentialsMessage type and\n g_unix_connection_send_credentials() \/\n g_unix_connection_receive_credentials() functions.\n Since 2.26\n Returns: NULL if error is set, otherwise a GCredentials object that must be freed with g_object_unref().\n Throws: GException on failure.\n\t \n",
"line" : 1217}
]
}
]
}
,
{
"name" : "gio.SocketListener",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketListener.d",
"members" : [
{
"name" : "SocketListener",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GSocketListener is an object that keeps track of a set\n of server sockets and helps you accept sockets from any of the\n socket, either sync or async.\n If you want to implement a network server, also look at GSocketService\n and GThreadedSocketService which are subclass of GSocketListener\n that makes this even easier.\n \n",
"line" : 93,
"base" : "ObjectG",
"members" : [
{
"name" : "gSocketListener",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketListener*",
"comment" : " the main Gtk struct \n",
"line" : 97}
,
{
"name" : "getSocketListenerStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketListener*()",
"line" : 100}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 107}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketListener(GSocketListener* gSocketListener)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 115}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 133}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketListener()",
"comment" : "\n\t \n\n Creates a new GSocketListener with no sockets to listen for.\n New listeners can be added with e.g. g_socket_listener_add_address()\n or g_socket_listener_add_inet_port().\n Since 2.22\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 149}
,
{
"name" : "addSocket",
"kind" : "function",
"protection" : "public",
"type" : "int(Socket socket, ObjectG sourceObject)",
"comment" : "\n Adds socket to the set of sockets that we try to accept\n new clients from. The socket must be bound to a local\n address and listened to.\n source_object will be passed out in the various calls\n to accept to identify this particular source, which is\n useful if you're listening on multiple addresses and do\n different things depending on what address is connected to.\n Since 2.22\n Params:\n socket = a listening GSocket\n sourceObject = Optional GObject identifying this source\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 175}
,
{
"name" : "addAddress",
"kind" : "function",
"protection" : "public",
"type" : "int(SocketAddress address, GSocketType type, GSocketProtocol protocol, ObjectG sourceObject, out SocketAddress effectiveAddress)",
"comment" : "\n Creates a socket of type type and protocol protocol, binds\n it to address and adds it to the set of sockets we're accepting\n sockets from.\n Note that adding an IPv6 address, depending on the platform,\n may or may not result in a listener that also accepts IPv4\n connections. For more determinstic behaviour, see\n g_socket_listener_add_inet_port().\n source_object will be passed out in the various calls\n to accept to identify this particular source, which is\n useful if you're listening on multiple addresses and do\n different things depending on what address is connected to.\n If successful and effective_address is non-NULL then it will\n be set to the address that the binding actually occured at. This\n is helpful for determining the port number that was used for when\n requesting a binding to port 0 (ie: \"any port\"). This address, if\n requested, belongs to the caller and must be freed.\n Since 2.22\n Params:\n address = a GSocketAddress\n type = a GSocketType\n protocol = a GSocketProtocol\n sourceObject = Optional GObject identifying this source\n effectiveAddress = location to store the address that was bound to, or NULL. [out][allow-none]\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 217}
,
{
"name" : "addInetPort",
"kind" : "function",
"protection" : "public",
"type" : "int(ushort port, ObjectG sourceObject)",
"comment" : "\n Helper function for g_socket_listener_add_address() that\n creates a TCP\/IP socket listening on IPv4 and IPv6 (if\n supported) on the specified port on all interfaces.\n source_object will be passed out in the various calls\n to accept to identify this particular source, which is\n useful if you're listening on multiple addresses and do\n different things depending on what address is connected to.\n Since 2.22\n Params:\n port = an IP port number (non-zero)\n sourceObject = Optional GObject identifying this source\n Returns: TRUE on success, FALSE on error.\n Throws: GException on failure.\n\t \n",
"line" : 249}
,
{
"name" : "addAnyInetPort",
"kind" : "function",
"protection" : "public",
"type" : "ushort(ObjectG sourceObject)",
"comment" : "\n Listens for TCP connections on any available port number for both\n IPv6 and IPv4 (if each are available).\n This is useful if you need to have a socket for incoming connections\n but don't care about the specific port number.\n source_object will be passed out in the various calls\n to accept to identify this particular source, which is\n useful if you're listening on multiple addresses and do\n different things depending on what address is connected to.\n Since 2.24\n Params:\n sourceObject = Optional GObject identifying this source\n Returns: the port number, or 0 in case of failure.\n Throws: GException on failure.\n\t \n",
"line" : 279}
,
{
"name" : "accept",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(out ObjectG sourceObject, Cancellable cancellable)",
"comment" : "\n Blocks waiting for a client to connect to any of the sockets added\n to the listener. Returns a GSocketConnection for the socket that was\n accepted.\n If source_object is not NULL it will be filled out with the source\n object specified when the corresponding socket or address was added\n to the listener.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Since 2.22\n Params:\n sourceObject = location where GObject pointer will be stored, or NULL. [out][transfer none][allow-none]\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 311}
,
{
"name" : "acceptAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n This is the asynchronous version of g_socket_listener_accept().\n When the operation is finished callback will be\n called. You can then call g_socket_listener_accept_socket()\n to get the result of the operation.\n Since 2.22\n Params:\n cancellable = a GCancellable, or NULL\n callback = a GAsyncReadyCallback\n userData = user data for the callback\n\t \n",
"line" : 343}
,
{
"name" : "acceptFinish",
"kind" : "function",
"protection" : "public",
"type" : "SocketConnection(AsyncResultIF result, ref ObjectG sourceObject)",
"comment" : "\n Finishes an async accept operation. See g_socket_listener_accept_async()\n Since 2.22\n Params:\n result = a GAsyncResult.\n sourceObject = Optional GObject identifying this source\n Returns: a GSocketConnection on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 358}
,
{
"name" : "acceptSocket",
"kind" : "function",
"protection" : "public",
"type" : "Socket(out ObjectG sourceObject, Cancellable cancellable)",
"comment" : "\n Blocks waiting for a client to connect to any of the sockets added\n to the listener. Returns the GSocket that was accepted.\n If you want to accept the high-level GSocketConnection, not a GSocket,\n which is often the case, then you should use g_socket_listener_accept()\n instead.\n If source_object is not NULL it will be filled out with the source\n object specified when the corresponding socket or address was added\n to the listener.\n If cancellable is not NULL, then the operation can be cancelled by\n triggering the cancellable object from another thread. If the operation\n was cancelled, the error G_IO_ERROR_CANCELLED will be returned.\n Since 2.22\n Params:\n sourceObject = location where GObject pointer will be stored, or NULL. [out][transfer none][allow-none]\n cancellable = optional GCancellable object, NULL to ignore.\n Returns: a GSocket on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 398}
,
{
"name" : "acceptSocketAsync",
"kind" : "function",
"protection" : "public",
"type" : "void(Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n This is the asynchronous version of g_socket_listener_accept_socket().\n When the operation is finished callback will be\n called. You can then call g_socket_listener_accept_socket_finish()\n to get the result of the operation.\n Since 2.22\n Params:\n cancellable = a GCancellable, or NULL\n callback = a GAsyncReadyCallback\n userData = user data for the callback\n\t \n",
"line" : 430}
,
{
"name" : "acceptSocketFinish",
"kind" : "function",
"protection" : "public",
"type" : "Socket(AsyncResultIF result, ref ObjectG sourceObject)",
"comment" : "\n Finishes an async accept operation. See g_socket_listener_accept_socket_async()\n Since 2.22\n Params:\n result = a GAsyncResult.\n sourceObject = Optional GObject identifying this source\n Returns: a GSocket on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 445}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Closes all the sockets in the listener.\n Since 2.22\n\t \n",
"line" : 470}
,
{
"name" : "setBacklog",
"kind" : "function",
"protection" : "public",
"type" : "void(int listenBacklog)",
"comment" : "\n Sets the listen backlog on the sockets in the listener.\n See g_socket_set_listen_backlog() for details\n Since 2.22\n Params:\n listenBacklog = an integer\n\t \n",
"line" : 483}
]
}
]
}
,
{
"name" : "gio.SocketService",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SocketService.d",
"members" : [
{
"name" : "SocketService",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GSocketService is an object that represents a service that is\n provided to the network or over local sockets. When a new\n connection is made to the service the \"incoming\"\n signal is emitted.\n A GSocketService is a subclass of GSocketListener and you need\n to add the addresses you want to accept connections on to the\n with the GSocketListener APIs.\n There are two options for implementing a network service based on\n GSocketService. The first is to create the service using\n g_socket_service_new() and to connect to the \"incoming\"\n signal. The second is to subclass GSocketService and override the\n default signal handler implementation.\n In either case, the handler must immediately return, or else it\n will block additional incoming connections from being serviced.\n If you are interested in writing connection handlers that contain\n blocking code then see GThreadedSocketService.\n The socket service runs on the main loop in the main thread, and is\n not threadsafe in general. However, the calls to start and stop\n the service are threadsafe so these can be used from threads that\n handle incoming clients.\n \n",
"line" : 89,
"base" : "SocketListener",
"members" : [
{
"name" : "gSocketService",
"kind" : "variable",
"protection" : "protected",
"type" : "GSocketService*",
"comment" : " the main Gtk struct \n",
"line" : 93}
,
{
"name" : "getSocketServiceStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSocketService*()",
"line" : 96}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 103}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketService(GSocketService* gSocketService)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 111}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 129}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 137}
,
{
"name" : "onIncomingListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(GSocketConnection*, GObject*, SocketService)[]",
"line" : 139}
,
{
"name" : "addOnIncoming",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(GSocketConnection*, GObject*, SocketService) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n The ::incoming signal is emitted when a new incoming connection\n to service needs to be handled. The handler must initiate the\n handling of connection, but may not block; in essence,\n asynchronous operations must be used.\n Since 2.22\n See Also\n GThreadedSocketService, GSocketListener.\n\t \n",
"line" : 149}
,
{
"name" : "callBackIncoming",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(GSocketService* serviceStruct, GSocketConnection* connection, GObject* sourceObject, SocketService socketService)",
"line" : 164}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SocketService()",
"comment" : "\n Creates a new GSocketService with no sockets to listen for.\n New listeners can be added with e.g. g_socket_listener_add_address()\n or g_socket_listener_add_inet_port().\n Since 2.22\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 185}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Starts the service, i.e. start accepting connections\n from the added sockets when the mainloop runs.\n This call is threadsafe, so it may be called from a thread\n handling an incomming client request.\n Since 2.22\n\t \n",
"line" : 203}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Stops the service, i.e. stops accepting connections\n from the added sockets when the mainloop runs.\n This call is threadsafe, so it may be called from a thread\n handling an incomming client request.\n Since 2.22\n\t \n",
"line" : 216}
,
{
"name" : "isActive",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Check whether the service is active or not. An active\n service will accept new clients that connect, while\n a non-active service will let connecting clients queue\n up until the service is started.\n Since 2.22\n Signal Details\n The \"incoming\" signal\n gboolean user_function (GSocketService *service,\n  GSocketConnection *connection,\n  GObject *source_object,\n  gpointer user_data) : Run Last\n The ::incoming signal is emitted when a new incoming connection\n to service needs to be handled. The handler must initiate the\n handling of connection, but may not block; in essence,\n asynchronous operations must be used.\n Since 2.22\n Returns: TRUE if the service is active, FALSE otherwiseReturns: TRUE to stop other handlers from being called\n\t \n",
"line" : 241}
]
}
]
}
,
{
"name" : "gio.SrvTarget",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/SrvTarget.d",
"members" : [
{
"name" : "SrvTarget",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n SRV (service) records are used by some network protocols to provide\n service-specific aliasing and load-balancing. For example, XMPP\n (Jabber) uses SRV records to locate the XMPP server for a domain;\n rather than connecting directly to \"example.com\" or assuming a\n specific server hostname like \"xmpp.example.com\", an XMPP client\n would look up the \"xmpp-client\" SRV record for \"example.com\", and\n then connect to whatever host was pointed to by that record.\n You can use g_resolver_lookup_service() or\n g_resolver_lookup_service_async() to find the GSrvTargets\n for a given service. However, if you are simply planning to connect\n to the remote service, you can use GNetworkService's\n GSocketConnectable interface and not need to worry about\n GSrvTarget at all.\n \n",
"line" : 86,
"base" : "Object",
"members" : [
{
"name" : "gSrvTarget",
"kind" : "variable",
"protection" : "protected",
"type" : "GSrvTarget*",
"comment" : " the main Gtk struct \n",
"line" : 89}
,
{
"name" : "getSrvTargetStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSrvTarget*()",
"line" : 92}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 99}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SrvTarget(GSrvTarget* gSrvTarget)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 107}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SrvTarget(string hostname, ushort port, ushort priority, ushort weight)",
"comment" : "\n\t \n\n Creates a new GSrvTarget with the given parameters.\n You should not need to use this; normally GSrvTargets are\n created by GResolver.\n Since 2.22\n Params:\n hostname = the host that the service is running on\n port = the port that the service is running on\n priority = the target's priority\n weight = the target's weight\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 132}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "SrvTarget()",
"comment" : "\n Copies target\n Since 2.22\n Returns: a copy of target\n\t \n",
"line" : 148}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees target\n Since 2.22\n\t \n",
"line" : 163}
,
{
"name" : "getHostname",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets target's hostname (in ASCII form; if you are going to present\n this to the user, you should use g_hostname_is_ascii_encoded() to\n check if it contains encoded Unicode segments, and use\n g_hostname_to_unicode() to convert it if it does.)\n Since 2.22\n Returns: target's hostname\n\t \n",
"line" : 177}
,
{
"name" : "getPort",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Gets target's port\n Since 2.22\n Returns: target's port\n\t \n",
"line" : 188}
,
{
"name" : "getPriority",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Gets target's priority. You should not need to look at this;\n GResolver already sorts the targets according to the algorithm in\n RFC 2782.\n Since 2.22\n Returns: target's priority\n\t \n",
"line" : 201}
,
{
"name" : "getWeight",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Gets target's weight. You should not need to look at this;\n GResolver already sorts the targets according to the algorithm in\n RFC 2782.\n Since 2.22\n Returns: target's weight\n\t \n",
"line" : 214}
,
{
"name" : "listSort",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ListG targets)",
"comment" : "\n Sorts targets in place according to the algorithm in RFC 2782.\n Since 2.22\n Params:\n targets = a GList of GSrvTarget\n Returns: the head of the sorted list.\n\t \n",
"line" : 227}
]
}
]
}
,
{
"name" : "gio.TcpConnection",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/TcpConnection.d",
"members" : [
{
"name" : "TcpConnection",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This is the subclass of GSocketConnection that is created\n for TCP\/IP sockets.\n \n",
"line" : 69,
"base" : "SocketConnection",
"members" : [
{
"name" : "gTcpConnection",
"kind" : "variable",
"protection" : "protected",
"type" : "GTcpConnection*",
"comment" : " the main Gtk struct \n",
"line" : 73}
,
{
"name" : "getTcpConnectionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTcpConnection*()",
"line" : 76}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 83}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TcpConnection(GTcpConnection* gTcpConnection)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 91}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 109}
,
{
"name" : "setGracefulDisconnect",
"kind" : "function",
"protection" : "public",
"type" : "void(int gracefulDisconnect)",
"comment" : "\n\t \n\n This enabled graceful disconnects on close. A graceful disconnect\n means that we signal the recieving end that the connection is terminated\n and wait for it to close the connection before closing the connection.\n A graceful disconnect means that we can be sure that we successfully sent\n all the outstanding data to the other end, or get an error reported.\n However, it also means we have to wait for all the data to reach the\n other side and for it to acknowledge this by closing the socket, which may\n take a while. For this reason it is disabled by default.\n Since 2.22\n Params:\n gracefulDisconnect = Whether to do graceful disconnects or not\n\t \n",
"line" : 131}
,
{
"name" : "getGracefulDisconnect",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if graceful disconnects are used. See\n g_tcp_connection_set_graceful_disconnect().\n Since 2.22\n Returns: TRUE if graceful disconnect is used on close, FALSE otherwise\n\t \n",
"line" : 143}
]
}
]
}
,
{
"name" : "gio.ThemedIcon",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ThemedIcon.d",
"members" : [
{
"name" : "ThemedIcon",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GThemedIcon is an implementation of GIcon that supports icon themes.\n GThemedIcon contains a list of all of the icons present in an icon\n theme, so that icons can be looked up quickly. GThemedIcon does\n not provide actual pixmaps for icons, just the icon names.\n Ideally something like gtk_icon_theme_choose_icon() should be used to\n resolve the list of names so that fallback icons work nicely with\n themes that inherit other themes.\n \n",
"line" : 82,
"base" : "ObjectG",
"interfaces" : [
"IconIF"],
"members" : [
{
"name" : "gThemedIcon",
"kind" : "variable",
"protection" : "protected",
"type" : "GThemedIcon*",
"comment" : " the main Gtk struct \n",
"line" : 86}
,
{
"name" : "getThemedIconStruct",
"kind" : "function",
"protection" : "public",
"type" : "GThemedIcon*()",
"line" : 89}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThemedIcon(GThemedIcon* gThemedIcon)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 104}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 122}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThemedIcon(string[] iconnames, int len)",
"comment" : "\n\t \n\n Creates a new themed icon for iconnames.\n Params:\n iconnames = an array of strings containing icon names.\n len = the length of the iconnames array, or -1 if iconnames is\n  NULL-terminated\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 142}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThemedIcon(string iconname)",
"comment" : "\n Creates a new themed icon for iconname, and all the names\n that can be created by shortening iconname at '-' characters.\n Params:\n iconname = a string containing an icon name\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 160}
,
{
"name" : "prependName",
"kind" : "function",
"protection" : "public",
"type" : "void(string iconname)",
"comment" : "\n Prepend a name to the list of icons from within icon.\n Note\n Note that doing so invalidates the hash computed by prior calls\n to g_icon_hash().\n Since 2.18\n Params:\n icon = a GThemedIcon\n iconname = name of icon to prepend to list of icons from within icon.\n\t \n",
"line" : 181}
,
{
"name" : "appendName",
"kind" : "function",
"protection" : "public",
"type" : "void(string iconname)",
"comment" : "\n Append a name to the list of icons from within icon.\n Note\n Note that doing so invalidates the hash computed by prior calls\n to g_icon_hash().\n Params:\n icon = a GThemedIcon\n iconname = name of icon to append to list of icons from within icon.\n\t \n",
"line" : 196}
,
{
"name" : "getNames",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the names of icons from within icon.\n Returns: a list of icon names.\n\t \n",
"line" : 206}
]
}
]
}
,
{
"name" : "gio.ThreadedSocketService",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ThreadedSocketService.d",
"members" : [
{
"name" : "ThreadedSocketService",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GThreadedSocketService is a simple subclass of GSocketService\n that handles incoming connections by creating a worker thread and\n dispatching the connection to it by emitting the ::run signal in\n the new thread.\n The signal handler may perform blocking IO and need not return\n until the connection is closed.\n The service is implemented using a thread pool, so there is a\n limited amount of threads availible to serve incomming requests.\n The service automatically stops the GSocketService from accepting\n new connections when all threads are busy.\n As with GSocketService, you may connect to \"run\",\n or subclass and override the default handler.\n \n",
"line" : 81,
"base" : "SocketService",
"members" : [
{
"name" : "gThreadedSocketService",
"kind" : "variable",
"protection" : "protected",
"type" : "GThreadedSocketService*",
"comment" : " the main Gtk struct \n",
"line" : 85}
,
{
"name" : "getThreadedSocketServiceStruct",
"kind" : "function",
"protection" : "public",
"type" : "GThreadedSocketService*()",
"line" : 88}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 95}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThreadedSocketService(GThreadedSocketService* gThreadedSocketService)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 103}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 121}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 129}
,
{
"name" : "onRunListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(GSocketConnection*, GObject*, ThreadedSocketService)[]",
"line" : 131}
,
{
"name" : "addOnRun",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(GSocketConnection*, GObject*, ThreadedSocketService) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n The ::run signal is emitted in a worker thread in response to an\n incoming connection. This thread is dedicated to handling\n connection and may perform blocking IO. The signal handler need\n not return until the connection is closed.\n See Also\n GSocketService.\n\t \n",
"line" : 140}
,
{
"name" : "callBackRun",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int(GThreadedSocketService* serviceStruct, GSocketConnection* connection, GObject* sourceObject, ThreadedSocketService threadedSocketService)",
"line" : 155}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThreadedSocketService(int maxThreads)",
"comment" : "\n Creates a new GThreadedSocketService with no listeners. Listeners\n must be added with g_socket_service_add_listeners().\n Since 2.22\n Params:\n maxThreads = the maximal number of threads to execute concurrently\n  handling incoming clients, -1 means no limit\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 178}
]
}
]
}
,
{
"name" : "gio.UnixConnection",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixConnection.d",
"members" : [
{
"name" : "UnixConnection",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This is the subclass of GSocketConnection that is created\n for UNIX domain sockets.\n It contains functions to do some of the UNIX socket specific\n functionality like passing file descriptors.\n Note that <gio\/gunixconnection.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 84,
"base" : "SocketConnection",
"members" : [
{
"name" : "gUnixConnection",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixConnection*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getUnixConnectionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixConnection*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixConnection(GUnixConnection* gUnixConnection)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 124}
,
{
"name" : "receiveFd",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n\t \n\n Receives a file descriptor from the sending end of the connection.\n The sending end has to call g_unix_connection_send_fd() for this\n to work.\n As well as reading the fd this also reads a single byte from the\n stream, as this is required for fd passing to work on some\n implementations.\n Since 2.22\n Params:\n cancellable = optional GCancellable object, NULL to ignore. [allow-none]\n Returns: a file descriptor on success, -1 on error.\n Throws: GException on failure.\n\t \n",
"line" : 146}
,
{
"name" : "sendFd",
"kind" : "function",
"protection" : "public",
"type" : "int(int fd, Cancellable cancellable)",
"comment" : "\n Passes a file descriptor to the recieving side of the\n connection. The recieving end has to call g_unix_connection_receive_fd()\n to accept the file descriptor.\n As well as sending the fd this also writes a single byte to the\n stream, as this is required for fd passing to work on some\n implementations.\n Since 2.22\n Params:\n fd = a file descriptor\n cancellable = optional GCancellable object, NULL to ignore. [allow-none]\n Returns: a TRUE on success, NULL on error.\n Throws: GException on failure.\n\t \n",
"line" : 175}
,
{
"name" : "receiveCredentials",
"kind" : "function",
"protection" : "public",
"type" : "Credentials(Cancellable cancellable)",
"comment" : "\n Receives credentials from the sending end of the connection. The\n sending end has to call g_unix_connection_send_credentials() (or\n similar) for this to work.\n As well as reading the credentials this also reads (and discards) a\n single byte from the stream, as this is required for credentials\n passing to work on some implementations.\n Other ways to exchange credentials with a foreign peer includes the\n GUnixCredentialsMessage type and g_socket_get_credentials() function.\n Since 2.26\n Params:\n cancellable = A GCancellable or NULL.\n Returns: Received credentials on success (free with g_object_unref()), NULL if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 205}
,
{
"name" : "sendCredentials",
"kind" : "function",
"protection" : "public",
"type" : "int(Cancellable cancellable)",
"comment" : "\n Passes the credentials of the current user the receiving side\n of the connection. The recieving end has to call\n g_unix_connection_receive_credentials() (or similar) to accept the\n credentials.\n As well as sending the credentials this also writes a single NUL\n byte to the stream, as this is required for credentials passing to\n work on some implementations.\n Other ways to exchange credentials with a foreign peer includes the\n GUnixCredentialsMessage type and g_socket_get_credentials() function.\n Since 2.26\n Params:\n cancellable = A GCancellable or NULL.\n Returns: TRUE on success, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 240}
]
}
]
}
,
{
"name" : "gio.UnixCredentialsMessage",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixCredentialsMessage.d",
"members" : [
{
"name" : "UnixCredentialsMessage",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This GSocketControlMessage contains a GCredentials instance. It\n may be sent using g_socket_send_message() and received using\n g_socket_receive_message() over UNIX sockets (ie: sockets in the\n G_SOCKET_FAMILY_UNIX family).\n For an easier way to send and receive credentials over\n stream-oriented UNIX sockets, see\n g_unix_connection_send_credentials() and\n g_unix_connection_receive_credentials(). To receive credentials of\n a foreign process connected to a socket, use\n g_socket_get_credentials().\n \n",
"line" : 80,
"base" : "SocketControlMessage",
"members" : [
{
"name" : "gUnixCredentialsMessage",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixCredentialsMessage*",
"comment" : " the main Gtk struct \n",
"line" : 84}
,
{
"name" : "getUnixCredentialsMessageStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixCredentialsMessage*()",
"line" : 87}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 94}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixCredentialsMessage(GUnixCredentialsMessage* gUnixCredentialsMessage)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 102}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 120}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixCredentialsMessage()",
"comment" : "\n\t \n\n Creates a new GUnixCredentialsMessage with credentials matching the current processes.\n Since 2.26\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 134}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixCredentialsMessage(Credentials credentials)",
"comment" : "\n Creates a new GUnixCredentialsMessage holding credentials.\n Since 2.26\n Params:\n credentials = A GCredentials object.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 152}
,
{
"name" : "getCredentials",
"kind" : "function",
"protection" : "public",
"type" : "Credentials()",
"comment" : "\n Gets the credentials stored in message.\n Since 2.26\n Returns: A GCredentials instance. Do not free, it is owned by message.\n\t \n",
"line" : 168}
,
{
"name" : "isSupported",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if passing a GCredential on a GSocket is supported on this platform.\n Since 2.26\n Returns: TRUE if supported, FALSE otherwise\n\t \n",
"line" : 184}
]
}
]
}
,
{
"name" : "gio.UnixFDList",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixFDList.d",
"members" : [
{
"name" : "UnixFDList",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GUnixFDList contains a list of file descriptors. It owns the file\n descriptors that it contains, closing them when finalized.\n It may be wrapped in a GUnixFDMessage and sent over a GSocket in\n the G_SOCKET_ADDRESS_UNIX family by using g_socket_send_message()\n and received using g_socket_receive_message().\n Note that <gio\/gunixfdlist.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 79,
"base" : "ObjectG",
"members" : [
{
"name" : "gUnixFDList",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixFDList*",
"comment" : " the main Gtk struct \n",
"line" : 83}
,
{
"name" : "getUnixFDListStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixFDList*()",
"line" : 86}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 93}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixFDList(GUnixFDList* gUnixFDList)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 101}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 119}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixFDList(int[] fds)",
"comment" : "\n\t \n\n Creates a new GUnixFDList containing the file descriptors given in\n fds. The file descriptors become the property of the new list and\n may no longer be used by the caller. The array itself is owned by\n the caller.\n Each file descriptor in the array should be set to close-on-exec.\n If n_fds is -1 then fds must be terminated with -1.\n Since 2.24\n Params:\n fds = the initial list of file descriptors\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 140}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixFDList()",
"comment" : "\n Creates a new GUnixFDList containing no file descriptors.\n Since 2.24\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 156}
,
{
"name" : "getLength",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the length of list (ie: the number of file descriptors\n contained within).\n Since 2.24\n Returns: the length of list\n\t \n",
"line" : 173}
,
{
"name" : "get",
"kind" : "function",
"protection" : "public",
"type" : "int(int index)",
"comment" : "\n Gets a file descriptor out of list.\n index_ specifies the index of the file descriptor to get. It is a\n programmer error for index_ to be out of range; see\n g_unix_fd_list_get_length().\n The file descriptor is duplicated using dup() and set as\n close-on-exec before being returned. You must call close() on it\n when you are done.\n A possible cause of failure is exceeding the per-process or\n system-wide file descriptor limit.\n Since 2.24\n Params:\n index = the index into the list\n Returns: the file descriptor, or -1 in case of error\n Throws: GException on failure.\n\t \n",
"line" : 195}
,
{
"name" : "peekFds",
"kind" : "function",
"protection" : "public",
"type" : "int[]()",
"comment" : "\n Returns the array of file descriptors that is contained in this\n object.\n After this call, the descriptors remain the property of list. The\n caller must not close them and must not free the array. The array is\n valid only until list is changed in any way.\n If length is non-NULL then it is set to the number of file\n descriptors in the returned array. The returned array is also\n terminated with -1.\n This function never returns NULL. In case there are no file\n descriptors contained in list, an empty array is returned.\n Since 2.24\n Returns: an array of file descriptors\n\t \n",
"line" : 224}
,
{
"name" : "stealFds",
"kind" : "function",
"protection" : "public",
"type" : "int[]()",
"comment" : "\n Returns the array of file descriptors that is contained in this\n object.\n After this call, the descriptors are no longer contained in\n list. Further calls will return an empty list (unless more\n descriptors have been added).\n The return result of this function must be freed with g_free().\n The caller is also responsible for closing all of the file\n descriptors. The file descriptors in the array are set to\n close-on-exec.\n If length is non-NULL then it is set to the number of file\n descriptors in the returned array. The returned array is also\n terminated with -1.\n This function never returns NULL. In case there are no file\n descriptors contained in list, an empty array is returned.\n Since 2.24\n Returns: an array of file descriptors\n\t \n",
"line" : 250}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "int(int fd)",
"comment" : "\n Adds a file descriptor to list.\n The file descriptor is duplicated using dup(). You keep your copy\n of the descriptor and the copy contained in list will be closed\n when list is finalized.\n A possible cause of failure is exceeding the per-process or\n system-wide file descriptor limit.\n The index of the file descriptor in the list is returned. If you use\n this index with g_unix_fd_list_get() then you will receive back a\n duplicated copy of the same file descriptor.\n Since 2.24\n Params:\n fd = a valid open file descriptor\n Returns: the index of the appended fd in case of success, else -1 (and error is set)\n Throws: GException on failure.\n\t \n",
"line" : 274}
]
}
]
}
,
{
"name" : "gio.UnixFDMessage",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixFDMessage.d",
"members" : [
{
"name" : "UnixFDMessage",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This GSocketControlMessage contains a GUnixFDList.\n It may be sent using g_socket_send_message() and received using\n g_socket_receive_message() over UNIX sockets (ie: sockets in the\n G_SOCKET_ADDRESS_UNIX family). The file descriptors are copied\n between processes by the kernel.\n For an easier way to send and receive file descriptors over\n stream-oriented UNIX sockets, see g_unix_connection_send_fd() and\n g_unix_connection_receive_fd().\n Note that <gio\/gunixfdmessage.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 85,
"base" : "SocketControlMessage",
"members" : [
{
"name" : "gUnixFDMessage",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixFDMessage*",
"comment" : " the main Gtk struct \n",
"line" : 89}
,
{
"name" : "getUnixFDMessageStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixFDMessage*()",
"line" : 92}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 99}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixFDMessage(GUnixFDMessage* gUnixFDMessage)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 107}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 125}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixFDMessage(UnixFDList fdList)",
"comment" : "\n\t \n\n Creates a new GUnixFDMessage containing list.\n Since 2.24\n Params:\n fdList = a GUnixFDList\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 141}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixFDMessage()",
"comment" : "\n Creates a new GUnixFDMessage containing an empty file descriptor\n list.\n Since 2.22\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 158}
,
{
"name" : "getFdList",
"kind" : "function",
"protection" : "public",
"type" : "UnixFDList()",
"comment" : "\n Gets the GUnixFDList contained in message. This function does not\n return a reference to the caller, but the returned list is valid for\n the lifetime of message.\n Since 2.24\n Returns: the GUnixFDList from message\n\t \n",
"line" : 176}
,
{
"name" : "appendFd",
"kind" : "function",
"protection" : "public",
"type" : "int(int fd)",
"comment" : "\n Adds a file descriptor to message.\n The file descriptor is duplicated using dup(). You keep your copy\n of the descriptor and the copy contained in message will be closed\n when message is finalized.\n A possible cause of failure is exceeding the per-process or\n system-wide file descriptor limit.\n Since 2.22\n Params:\n fd = a valid open file descriptor\n Returns: TRUE in case of success, else FALSE (and error is set)\n Throws: GException on failure.\n\t \n",
"line" : 200}
,
{
"name" : "stealFds",
"kind" : "function",
"protection" : "public",
"type" : "int[]()",
"comment" : "\n Returns the array of file descriptors that is contained in this\n object.\n After this call, the descriptors are no longer contained in\n message. Further calls will return an empty list (unless more\n descriptors have been added).\n The return result of this function must be freed with g_free().\n The caller is also responsible for closing all of the file\n descriptors.\n If length is non-NULL then it is set to the number of file\n descriptors in the returned array. The returned array is also\n terminated with -1.\n This function never returns NULL. In case there are no file\n descriptors contained in message, an empty array is returned.\n Since 2.22\n Returns: an array of file descriptors\n\t \n",
"line" : 232}
]
}
]
}
,
{
"name" : "gio.UnixInputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixInputStream.d",
"members" : [
{
"name" : "UnixInputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GUnixInputStream implements GInputStream for reading from a\n UNIX file descriptor, including asynchronous operations. The file\n descriptor must be selectable, so it doesn't work with opened files.\n Note that <gio\/gunixinputstream.h> belongs\n to the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 73,
"base" : "InputStream",
"members" : [
{
"name" : "gUnixInputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixInputStream*",
"comment" : " the main Gtk struct \n",
"line" : 77}
,
{
"name" : "getUnixInputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixInputStream*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 87}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixInputStream(GUnixInputStream* gUnixInputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 95}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixInputStream(int fd, int closeFd)",
"comment" : "\n\t \n\n Creates a new GUnixInputStream for the given fd.\n If close_fd is TRUE, the file descriptor will be closed\n when the stream is closed.\n Params:\n fd = a UNIX file descriptor\n closeFd = TRUE to close the file descriptor when done\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 131}
,
{
"name" : "setCloseFd",
"kind" : "function",
"protection" : "public",
"type" : "void(int closeFd)",
"comment" : "\n Sets whether the file descriptor of stream shall be closed\n when the stream is closed.\n Since 2.20\n Params:\n closeFd = TRUE to close the file descriptor when done\n\t \n",
"line" : 149}
,
{
"name" : "getCloseFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the file descriptor of stream will be\n closed when the stream is closed.\n Since 2.20\n Returns: TRUE if the file descriptor is closed when done\n\t \n",
"line" : 161}
,
{
"name" : "getFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Return the UNIX file descriptor that the stream reads from.\n Since 2.20\n Returns: The file descriptor of stream\n\t \n",
"line" : 172}
]
}
]
}
,
{
"name" : "gio.UnixMountEntry",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixMountEntry.d",
"members" : [
{
"name" : "UnixMountEntry",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Routines for managing mounted UNIX mount points and paths.\n Note that <gio\/gunixmounts.h> belongs to the\n UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 89,
"base" : "Object",
"members" : [
{
"name" : "gUnixMountEntry",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixMountEntry*",
"comment" : " the main Gtk struct \n",
"line" : 92}
,
{
"name" : "getUnixMountEntryStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixMountEntry*()",
"line" : 95}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 102}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixMountEntry(GUnixMountEntry* gUnixMountEntry)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 110}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Frees a unix mount.\n\t \n",
"line" : 126}
,
{
"name" : "compare",
"kind" : "function",
"protection" : "public",
"type" : "int(UnixMountEntry mount2)",
"comment" : "\n Compares two unix mounts.\n Params:\n mount2 = second GUnixMountEntry to compare.\n Returns: 1, 0 or -1 if mount1 is greater than, equal to, or less than mount2, respectively.\n\t \n",
"line" : 138}
,
{
"name" : "getMountPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the mount path for a unix mount.\n Returns: the mount path for mount_entry.\n\t \n",
"line" : 148}
,
{
"name" : "getDevicePath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the device path for a unix mount.\n Returns: a string containing the device path.\n\t \n",
"line" : 158}
,
{
"name" : "getFsType",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the filesystem type for the unix mount.\n Returns: a string containing the file system type.\n\t \n",
"line" : 168}
,
{
"name" : "isReadonly",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a unix mount is mounted read only.\n Returns: TRUE if mount_entry is read only.\n\t \n",
"line" : 178}
,
{
"name" : "isSystemInternal",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a unix mount is a system path.\n Returns: TRUE if the unix mount is for a system path.\n\t \n",
"line" : 188}
,
{
"name" : "guessIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Guesses the icon of a Unix mount.\n Returns: a GIcon\n\t \n",
"line" : 198}
,
{
"name" : "guessName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Guesses the name of a Unix mount.\n The result is a translated string.\n Returns: A newly allocated string that must be freed with g_free()\n\t \n",
"line" : 214}
,
{
"name" : "guessCanEject",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Guesses whether a Unix mount can be ejected.\n Returns: TRUE if mount_entry is deemed to be ejectable.\n\t \n",
"line" : 224}
,
{
"name" : "guessShouldDisplay",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Guesses whether a Unix mount should be displayed in the UI.\n Returns: TRUE if mount_entry is deemed to be displayable.\n\t \n",
"line" : 234}
,
{
"name" : "pointsGet",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ulong* timeRead)",
"comment" : "\n Gets a GList of GUnixMountPoint containing the unix mount points.\n If time_read is set, it will be filled with the mount timestamp,\n allowing for checking if the mounts have changed with\n g_unix_mounts_points_changed_since().\n Params:\n timeRead = guint64 to contain a timestamp. [allow-none]\n Returns: a GList of the UNIX mountpoints.\n\t \n",
"line" : 249}
,
{
"name" : "mountsGet",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ref ulong timeRead)",
"comment" : "\n Gets a GList of GUnixMountEntry containing the unix mounts.\n If time_read is set, it will be filled with the mount\n timestamp, allowing for checking if the mounts have changed\n with g_unix_mounts_changed_since().\n Params:\n timeRead = guint64 to contain a timestamp, or NULL. [allow-none]\n Returns: a GList of the UNIX mounts.\n\t \n",
"line" : 269}
,
{
"name" : "at",
"kind" : "function",
"protection" : "public",
"type" : "UnixMountEntry(string mountPath, ref ulong timeRead)",
"comment" : "\n Gets a GUnixMountEntry for a given mount path. If time_read\n is set, it will be filled with a unix timestamp for checking\n if the mounts have changed since with g_unix_mounts_changed_since().\n Params:\n mountPath = path for a possible unix mount.\n timeRead = guint64 to contain a timestamp.\n Returns: a GUnixMount.\n\t \n",
"line" : 289}
,
{
"name" : "mountsChangedSince",
"kind" : "function",
"protection" : "public",
"type" : "int(ulong time)",
"comment" : "\n Checks if the unix mounts have changed since a given unix time.\n Params:\n time = guint64 to contain a timestamp.\n Returns: TRUE if the mounts have changed since time.\n\t \n",
"line" : 306}
,
{
"name" : "pointsChangedSince",
"kind" : "function",
"protection" : "public",
"type" : "int(ulong time)",
"comment" : "\n Checks if the unix mount points have changed since a given unix time.\n Params:\n time = guint64 to contain a timestamp.\n Returns: TRUE if the mount points have changed since time.\n\t \n",
"line" : 318}
,
{
"name" : "isMountPathSystemInternal",
"kind" : "function",
"protection" : "public",
"type" : "int(string mountPath)",
"comment" : "\n Determines if mount_path is considered an implementation of the\n OS. This is primarily used for hiding mountable and mounted volumes\n that only are used in the OS and has little to no relevance to the\n casual user.\n Params:\n mountPath = a mount path, e.g. \/media\/disk\n  or \/usr\n Returns: TRUE if mount_path is considered an implementation detail of the OS. Signal Details The \"mountpoints-changed\" signal void user_function (GUnixMountMonitor *monitor, gpointer user_data) : Run Last Emitted when the unix mount points have changed.\n\t \n",
"line" : 334}
]
}
]
}
,
{
"name" : "gio.UnixMountMonitor",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixMountMonitor.d",
"members" : [
{
"name" : "UnixMountMonitor",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Routines for managing mounted UNIX mount points and paths.\n Note that <gio\/gunixmounts.h> belongs to the\n UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 73,
"base" : "ObjectG",
"members" : [
{
"name" : "gUnixMountMonitor",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixMountMonitor*",
"comment" : " the main Gtk struct \n",
"line" : 77}
,
{
"name" : "getUnixMountMonitorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixMountMonitor*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 87}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixMountMonitor(GUnixMountMonitor* gUnixMountMonitor)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 95}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 113}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 121}
,
{
"name" : "onMountpointsChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(UnixMountMonitor)[]",
"line" : 123}
,
{
"name" : "addOnMountpointsChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(UnixMountMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the unix mount points have changed.\n\t \n",
"line" : 127}
,
{
"name" : "callBackMountpointsChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GUnixMountMonitor* monitorStruct, UnixMountMonitor unixMountMonitor)",
"line" : 142}
,
{
"name" : "onMountsChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(UnixMountMonitor)[]",
"line" : 150}
,
{
"name" : "addOnMountsChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(UnixMountMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the unix mounts have changed.\n\t \n",
"line" : 154}
,
{
"name" : "callBackMountsChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GUnixMountMonitor* monitorStruct, UnixMountMonitor unixMountMonitor)",
"line" : 169}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixMountMonitor()",
"comment" : "\n Gets a new GUnixMountMonitor. The default rate limit for which the\n monitor will report consecutive changes for the mount and mount\n point entry files is the default for a GFileMonitor. Use\n g_unix_mount_monitor_set_rate_limit() to change this.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 185}
,
{
"name" : "setRateLimit",
"kind" : "function",
"protection" : "public",
"type" : "void(int limitMsec)",
"comment" : "\n Sets the rate limit to which the mount_monitor will report\n consecutive change events to the mount and mount point entry files.\n Since 2.18\n Params:\n limitMsec = a integer with the limit in milliseconds to\n  poll for changes.\n\t \n",
"line" : 204}
]
}
]
}
,
{
"name" : "gio.UnixMountPoint",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixMountPoint.d",
"members" : [
{
"name" : "UnixMountPoint",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Routines for managing mounted UNIX mount points and paths.\n Note that <gio\/gunixmounts.h> belongs to the\n UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 83,
"base" : "Object",
"members" : [
{
"name" : "gUnixMountPoint",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixMountPoint*",
"comment" : " the main Gtk struct \n",
"line" : 86}
,
{
"name" : "getUnixMountPointStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixMountPoint*()",
"line" : 89}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixMountPoint(GUnixMountPoint* gUnixMountPoint)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 104}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Frees a unix mount point.\n\t \n",
"line" : 120}
,
{
"name" : "compare",
"kind" : "function",
"protection" : "public",
"type" : "int(UnixMountPoint mount2)",
"comment" : "\n Compares two unix mount points.\n Params:\n mount2 = a GUnixMount.\n Returns: 1, 0 or -1 if mount1 is greater than, equal to, or less than mount2, respectively.\n\t \n",
"line" : 132}
,
{
"name" : "getMountPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the mount path for a unix mount point.\n Returns: a string containing the mount path.\n\t \n",
"line" : 142}
,
{
"name" : "getDevicePath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the device path for a unix mount point.\n Returns: a string containing the device path.\n\t \n",
"line" : 152}
,
{
"name" : "getFsType",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the file system type for the mount point.\n Returns: a string containing the file system type.\n\t \n",
"line" : 162}
,
{
"name" : "isReadonly",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a unix mount point is read only.\n Returns: TRUE if a mount point is read only.\n\t \n",
"line" : 172}
,
{
"name" : "isUserMountable",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a unix mount point is mountable by the user.\n Returns: TRUE if the mount point is user mountable.\n\t \n",
"line" : 182}
,
{
"name" : "isLoopback",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a unix mount point is a loopback device.\n Returns: TRUE if the mount point is a loopback. FALSE otherwise.\n\t \n",
"line" : 192}
,
{
"name" : "guessIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Guesses the icon of a Unix mount point.\n Returns: a GIcon\n\t \n",
"line" : 202}
,
{
"name" : "guessName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Guesses the name of a Unix mount point.\n The result is a translated string.\n Returns: A newly allocated string that must be freed with g_free()\n\t \n",
"line" : 218}
,
{
"name" : "guessCanEject",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Guesses whether a Unix mount point can be ejected.\n Returns: TRUE if mount_point is deemed to be ejectable.\n\t \n",
"line" : 228}
]
}
]
}
,
{
"name" : "gio.UnixOutputStream",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixOutputStream.d",
"members" : [
{
"name" : "UnixOutputStream",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GUnixOutputStream implements GOutputStream for writing to a\n UNIX file descriptor, including asynchronous operations. The file\n descriptor must be selectable, so it doesn't work with opened files.\n Note that <gio\/gunixoutputstream.h> belongs\n to the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 73,
"base" : "OutputStream",
"members" : [
{
"name" : "gUnixOutputStream",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixOutputStream*",
"comment" : " the main Gtk struct \n",
"line" : 77}
,
{
"name" : "getUnixOutputStreamStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixOutputStream*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 87}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixOutputStream(GUnixOutputStream* gUnixOutputStream)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 95}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixOutputStream(int fd, int closeFd)",
"comment" : "\n\t \n\n Creates a new GUnixOutputStream for the given fd.\n If close_fd, is TRUE, the file descriptor will be closed when\n the output stream is destroyed.\n Params:\n fd = a UNIX file descriptor\n closeFd = TRUE to close the file descriptor when done\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 131}
,
{
"name" : "setCloseFd",
"kind" : "function",
"protection" : "public",
"type" : "void(int closeFd)",
"comment" : "\n Sets whether the file descriptor of stream shall be closed\n when the stream is closed.\n Since 2.20\n Params:\n closeFd = TRUE to close the file descriptor when done\n\t \n",
"line" : 149}
,
{
"name" : "getCloseFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the file descriptor of stream will be\n closed when the stream is closed.\n Since 2.20\n Returns: TRUE if the file descriptor is closed when done\n\t \n",
"line" : 161}
,
{
"name" : "getFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Return the UNIX file descriptor that the stream writes to.\n Since 2.20\n Returns: The file descriptor of stream\n\t \n",
"line" : 172}
]
}
]
}
,
{
"name" : "gio.UnixSocketAddress",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/UnixSocketAddress.d",
"members" : [
{
"name" : "UnixSocketAddress",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Support for UNIX-domain (also known as local) sockets.\n UNIX domain sockets are generally visible in the filesystem.\n However, some systems support abstract socket names which are not\n visible in the filesystem and not affected by the filesystem\n permissions, visibility, etc. Currently this is only supported\n under Linux. If you attempt to use abstract sockets on other\n systems, function calls may return G_IO_ERROR_NOT_SUPPORTED\n errors. You can use g_unix_socket_address_abstract_names_supported()\n to see if abstract names are supported.\n Note that <gio\/gunixsocketaddress.h> belongs to\n the UNIX-specific GIO interfaces, thus you have to use the\n gio-unix-2.0.pc pkg-config file when using it.\n \n",
"line" : 81,
"base" : "SocketAddress",
"members" : [
{
"name" : "gUnixSocketAddress",
"kind" : "variable",
"protection" : "protected",
"type" : "GUnixSocketAddress*",
"comment" : " the main Gtk struct \n",
"line" : 85}
,
{
"name" : "getUnixSocketAddressStruct",
"kind" : "function",
"protection" : "public",
"type" : "GUnixSocketAddress*()",
"line" : 88}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 95}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixSocketAddress(GUnixSocketAddress* gUnixSocketAddress)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 103}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 121}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixSocketAddress(string path)",
"comment" : "\n\t \n\n Creates a new GUnixSocketAddress for path.\n To create abstract socket addresses, on systems that support that,\n use g_unix_socket_address_new_abstract().\n Since 2.22\n Params:\n path = the socket path\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 139}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixSocketAddress(string path, int pathLen)",
"comment" : "\n Warning\n g_unix_socket_address_new_abstract is deprecated and should not be used in newly-written code. Use g_unix_socket_address_new_with_type().\n Creates a new G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED\n GUnixSocketAddress for path.\n Params:\n path = the abstract name\n pathLen = the length of path, or -1\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 160}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "UnixSocketAddress(char[] path, GUnixSocketAddressType type)",
"comment" : "\n Creates a new GUnixSocketAddress of type type with name path.\n If type is G_UNIX_SOCKET_ADDRESS_PATH, this is equivalent to\n calling g_unix_socket_address_new().\n If path_type is G_UNIX_SOCKET_ADDRESS_ABSTRACT, then path_len\n bytes of path will be copied to the socket's path, and only those\n bytes will be considered part of the name. (If path_len is -1,\n then path is assumed to be NUL-terminated.) For example, if path\n was \"test\", then calling g_socket_address_get_native_size() on the\n returned socket would return 7 (2 bytes of overhead, 1 byte for the\n abstract-socket indicator byte, and 4 bytes for the name \"test\").\n If path_type is G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED, then\n path_len bytes of path will be copied to the socket's path, the\n rest of the path will be padded with 0 bytes, and the entire\n zero-padded buffer will be considered the name. (As above, if\n path_len is -1, then path is assumed to be NUL-terminated.) In\n this case, g_socket_address_get_native_size() will always return\n the full size of a struct sockaddr_un, although\n g_unix_socket_address_get_path_len() will still return just the\n length of path.\n G_UNIX_SOCKET_ADDRESS_ABSTRACT is preferred over\n G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED for new programs. Of course,\n when connecting to a server created by another process, you must\n use the appropriate type corresponding to how that process created\n its listening socket.\n Since 2.26\n Params:\n path = the name\n type = a GUnixSocketAddressType\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 202}
,
{
"name" : "getIsAbstract",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Warning\n g_unix_socket_address_get_is_abstract is deprecated and should not be used in newly-written code. Use g_unix_socket_address_get_address_type()\n Tests if address is abstract.\n Since 2.22\n Returns: TRUE if the address is abstract, FALSE otherwise\n\t \n",
"line" : 220}
,
{
"name" : "getAddressType",
"kind" : "function",
"protection" : "public",
"type" : "GUnixSocketAddressType()",
"comment" : "\n Gets address's type.\n Since 2.26\n Returns: a GUnixSocketAddressType\n\t \n",
"line" : 231}
,
{
"name" : "getPath",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets address's path, or for abstract sockets the \"name\".\n Guaranteed to be zero-terminated, but an abstract socket\n may contain embedded zeros, and thus you should use\n g_unix_socket_address_get_path_len() to get the true length\n of this string.\n Since 2.22\n Returns: the path for address\n\t \n",
"line" : 246}
,
{
"name" : "getPathLen",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the length of address's path.\n For details, see g_unix_socket_address_get_path().\n Since 2.22\n Returns: the length of the path\n\t \n",
"line" : 258}
,
{
"name" : "abstractNamesSupported",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if abstract unix domain socket names are supported.\n Since 2.22\n Returns: TRUE if supported, FALSE otherwise\n\t \n",
"line" : 269}
]
}
]
}
,
{
"name" : "gio.Vfs",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Vfs.d",
"members" : [
{
"name" : "Vfs",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Entry point for using GIO functionality.\n \n",
"line" : 74,
"base" : "ObjectG",
"members" : [
{
"name" : "gVfs",
"kind" : "variable",
"protection" : "protected",
"type" : "GVfs*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getVfsStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVfs*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Vfs(GVfs* gVfs)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 114}
,
{
"name" : "getFileForPath",
"kind" : "function",
"protection" : "public",
"type" : "File(string path)",
"comment" : "\n\t \n\n Gets a GFile for path.\n Params:\n path = a string containing a VFS path.\n Returns: a GFile. Free the returned object with g_object_unref().\n\t \n",
"line" : 129}
,
{
"name" : "getFileForUri",
"kind" : "function",
"protection" : "public",
"type" : "File(string uri)",
"comment" : "\n Gets a GFile for uri.\n This operation never fails, but the returned object\n might not support any I\/O operation if the URI\n is malformed or if the URI scheme is not supported.\n Params:\n uri = a string containing a URI\n Returns: a GFile. Free the returned object with g_object_unref().\n\t \n",
"line" : 149}
,
{
"name" : "parseName",
"kind" : "function",
"protection" : "public",
"type" : "File(string parseName)",
"comment" : "\n This operation never fails, but the returned object might\n not support any I\/O operations if the parse_name cannot\n be parsed by the GVfs module.\n Params:\n parseName = a string to be parsed by the VFS module.\n Returns: a GFile for the given parse_name. Free the returned object with g_object_unref().\n\t \n",
"line" : 168}
,
{
"name" : "getDefault",
"kind" : "function",
"protection" : "public",
"type" : "Vfs()",
"comment" : "\n Gets the default GVfs for the system.\n Returns: a GVfs.\n\t \n",
"line" : 183}
,
{
"name" : "getLocal",
"kind" : "function",
"protection" : "public",
"type" : "Vfs()",
"comment" : "\n Gets the local GVfs for the system.\n Returns: a GVfs.\n\t \n",
"line" : 198}
,
{
"name" : "isActive",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if the VFS is active.\n Returns: TRUE if construction of the vfs was successful and it is now active.\n\t \n",
"line" : 213}
,
{
"name" : "getSupportedUriSchemes",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets a list of URI schemes supported by vfs.\n Returns: a NULL-terminated array of strings. The returned array belongs to GIO and must not be freed or modified.\n\t \n",
"line" : 223}
]
}
]
}
,
{
"name" : "gio.Volume",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/Volume.d",
"members" : [
{
"name" : "Volume",
"kind" : "class",
"protection" : "public",
"comment" : "\n \n",
"line" : 71,
"base" : "ObjectG",
"interfaces" : [
"VolumeIF"],
"members" : [
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 78}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Volume(GVolume* gVolume)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 86}
]
}
]
}
,
{
"name" : "gio.VolumeIF",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/VolumeIF.d",
"members" : [
{
"name" : "VolumeIF",
"kind" : "interface",
"protection" : "public",
"comment" : "\n Description\n The GVolume interface represents user-visible objects that can be\n mounted. Note, when porting from GnomeVFS, GVolume is the moral\n equivalent of GnomeVFSDrive.\n Mounting a GVolume instance is an asynchronous operation. For more\n information about asynchronous operations, see GAsyncReady and\n GSimpleAsyncReady. To mount a GVolume, first call\n g_volume_mount() with (at least) the GVolume instance, optionally\n a GMountOperation object and a GAsyncReadyCallback.\n Typically, one will only want to pass NULL for the\n GMountOperation if automounting all volumes when a desktop session\n starts since it's not desirable to put up a lot of dialogs asking\n for credentials.\n The callback will be fired when the operation has resolved (either\n with success or failure), and a GAsyncReady structure will be\n passed to the callback. That callback should then call\n g_volume_mount_finish() with the GVolume instance and the\n GAsyncReady data to see if the operation was completed\n successfully. If an error is present when g_volume_mount_finish()\n is called, then it will be filled with any error information.\n It is sometimes necessary to directly access the underlying\n operating system object behind a volume (e.g. for passing a volume\n to an application via the commandline). For this purpose, GIO\n allows to obtain an 'identifier' for the volume. There can be\n different kinds of identifiers, such as Hal UDIs, filesystem labels,\n traditional Unix devices (e.g. \/dev\/sda2),\n uuids. GIO uses predefind strings as names for the different kinds\n of identifiers: G_VOLUME_IDENTIFIER_KIND_HAL_UDI,\n G_VOLUME_IDENTIFIER_KIND_LABEL, etc. Use g_volume_get_identifier()\n to obtain an identifier for a volume.\n Note that G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available\n when the gvfs hal volume monitor is in use. Other volume monitors\n will generally be able to provide the G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE\n identifier, which can be used to obtain a hal device by means of\n libhal_manger_find_device_string_match().\n \n",
"line" : 138,
"members" : [
{
"name" : "getVolumeTStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVolume*()",
"line" : 141}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 144}
,
{
"name" : "onChangedListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(VolumeIF)[]()",
"comment" : "\n\t \n",
"line" : 150}
,
{
"name" : "addOnChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(VolumeIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the volume has been changed.\n\t \n",
"line" : 154}
,
{
"name" : "onRemovedListeners",
"kind" : "function",
"protection" : "public",
"type" : "void delegate(VolumeIF)[]()",
"line" : 155}
,
{
"name" : "addOnRemoved",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(VolumeIF) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n This signal is emitted when the GVolume have been removed. If\n the recipient is holding references to the object they should\n release them so the object can be finalized.\n\t \n",
"line" : 161}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name of volume.\n Returns: the name for the given volume. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 167}
,
{
"name" : "getUuid",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the UUID for the volume. The reference is typically based on\n the file system UUID for the volume in question and should be\n considered an opaque string. Returns NULL if there is no UUID\n available.\n Returns: the UUID for volume or NULL if no UUID can be computed. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 176}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "IconIF()",
"comment" : "\n Gets the icon for volume.\n Returns: a GIcon. The returned object should be unreffed with g_object_unref() when no longer needed. [transfer full]\n\t \n",
"line" : 182}
,
{
"name" : "getDrive",
"kind" : "function",
"protection" : "public",
"type" : "DriveIF()",
"comment" : "\n Gets the drive for the volume.\n Returns: a GDrive or NULL if volume is not associated with a drive. The returned object should be unreffed with g_object_unref() when no longer needed. [transfer full]\n\t \n",
"line" : 188}
,
{
"name" : "getMount",
"kind" : "function",
"protection" : "public",
"type" : "MountIF()",
"comment" : "\n Gets the mount for the volume.\n Returns: a GMount or NULL if volume isn't mounted. The returned object should be unreffed with g_object_unref() when no longer needed. [transfer full]\n\t \n",
"line" : 194}
,
{
"name" : "canMount",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a volume can be mounted.\n Returns: TRUE if the volume can be mounted. FALSE otherwise.\n\t \n",
"line" : 200}
,
{
"name" : "shouldAutomount",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the volume should be automatically mounted.\n Returns: TRUE if the volume should be automatically mounted.\n\t \n",
"line" : 206}
,
{
"name" : "getActivationRoot",
"kind" : "function",
"protection" : "public",
"type" : "File()",
"comment" : "\n Gets the activation root for a GVolume if it is known ahead of\n mount time. Returns NULL otherwise. If not NULL and if volume\n is mounted, then the result of g_mount_get_root() on the\n GMount object obtained from g_volume_get_mount() will always\n either be equal or a prefix of what this function returns. In\n other words, in code\n  GMount *mount;\n  GFile *mount_root\n  GFile *volume_activation_root;\n  mount = g_volume_get_mount (volume); \/+* mounted, so never NULL +\/\n  mount_root = g_mount_get_root (mount);\n  volume_activation_root = g_volume_get_activation_root(volume); \/+* assume not NULL +\/\n then the expression\n  (g_file_has_prefix (volume_activation_root, mount_root) ||\n  g_file_equal (volume_activation_root, mount_root))\n will always be TRUE.\n Activation roots are typically used in GVolumeMonitor\n implementations to find the underlying mount to shadow, see\n g_mount_is_shadowed() for more details.\n Since 2.18\n Returns: the activation root of volume or NULL. Use g_object_unref() to free.\n\t \n",
"line" : 231}
,
{
"name" : "mount",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountMountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Mounts a volume. This is an asynchronous operation, and is\n finished by calling g_volume_mount_finish() with the volume\n and GAsyncResult returned in the callback.\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction. [allow-none]\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data that gets passed to callback\n\t \n",
"line" : 244}
,
{
"name" : "mountFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes mounting a volume. If any errors occured during the operation,\n error will be set to contain the errors and FALSE will be returned.\n If the mount operation succeeded, g_volume_get_mount() on volume\n is guaranteed to return the mount right after calling this\n function; there's no need to listen for the 'mount-added' signal on\n GVolumeMonitor.\n Params:\n result = a GAsyncResult\n Returns: TRUE, FALSE if operation failed.\n Throws: GException on failure.\n\t \n",
"line" : 258}
,
{
"name" : "canEject",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if a volume can be ejected.\n Returns: TRUE if the volume can be ejected. FALSE otherwise.\n\t \n",
"line" : 264}
,
{
"name" : "eject",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Warning\n g_volume_eject has been deprecated since version 2.22 and should not be used in newly-written code. Use g_volume_eject_with_operation() instead.\n Ejects a volume. This is an asynchronous operation, and is\n finished by calling g_volume_eject_finish() with the volume\n and GAsyncResult returned in the callback.\n Params:\n flags = flags affecting the unmount if required for eject\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data that gets passed to callback\n\t \n",
"line" : 278}
,
{
"name" : "ejectFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_volume_eject_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_volume_eject_with_operation_finish() instead.\n Finishes ejecting a volume. If any errors occured during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n result = a GAsyncResult.\n Returns: TRUE, FALSE if operation failed.\n Throws: GException on failure.\n\t \n",
"line" : 290}
,
{
"name" : "ejectWithOperation",
"kind" : "function",
"protection" : "public",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, extern (C) void function(GObject*, GAsyncResult*, void*) callback, void* userData)",
"comment" : "\n Ejects a volume. This is an asynchronous operation, and is\n finished by calling g_volume_eject_with_operation_finish() with the volume\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n flags = flags affecting the unmount if required for eject\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 304}
,
{
"name" : "ejectWithOperationFinish",
"kind" : "function",
"protection" : "public",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes ejecting a volume. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the volume was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 315}
,
{
"name" : "enumerateIdentifiers",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the kinds of identifiers\n that volume has. Use g_volume_get_identifer() to obtain\n the identifiers themselves.\n Returns: a NULL-terminated array of strings containing kinds of identifiers. Use g_strfreev() to free.\n\t \n",
"line" : 323}
,
{
"name" : "getIdentifier",
"kind" : "function",
"protection" : "public",
"type" : "string(string kind)",
"comment" : "\n Gets the identifier of the given kind for volume.\n See the introduction\n for more information about volume identifiers.\n Params:\n kind = the kind of identifier to return\n Returns: a newly allocated string containing the requested identfier, or NULL if the GVolume doesn't have this kind of identifier Signal Details The \"changed\" signal void user_function (GVolume *arg0, gpointer user_data) : Run Last Emitted when the volume has been changed.\n\t \n",
"line" : 333}
]
}
]
}
,
{
"name" : "gio.VolumeMonitor",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/VolumeMonitor.d",
"members" : [
{
"name" : "VolumeMonitor",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GVolumeMonitor is for listing the user interesting devices and volumes\n on the computer. In other words, what a file selector or file manager\n would show in a sidebar.\n GVolumeMonitor is not thread-default-context\n aware, and so should not be used other than from the main\n thread, with no thread-default-context active.\n \n",
"line" : 97,
"base" : "ObjectG",
"members" : [
{
"name" : "gVolumeMonitor",
"kind" : "variable",
"protection" : "protected",
"type" : "GVolumeMonitor*",
"comment" : " the main Gtk struct \n",
"line" : 101}
,
{
"name" : "getVolumeMonitorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVolumeMonitor*()",
"line" : 104}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 111}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VolumeMonitor(GVolumeMonitor* gVolumeMonitor)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 119}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 137}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VolumeMonitor()",
"comment" : "\n Gets the volume monitor used by gio.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 147}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"protection" : "public",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 160}
,
{
"name" : "onDriveChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(DriveIF, VolumeMonitor)[]",
"line" : 162}
,
{
"name" : "addOnDriveChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a drive changes.\n\t \n",
"line" : 166}
,
{
"name" : "callBackDriveChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GDrive* drive, VolumeMonitor volumeMonitor)",
"line" : 181}
,
{
"name" : "onDriveConnectedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(DriveIF, VolumeMonitor)[]",
"line" : 189}
,
{
"name" : "addOnDriveConnected",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a drive is connected to the system.\n\t \n",
"line" : 193}
,
{
"name" : "callBackDriveConnected",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GDrive* drive, VolumeMonitor volumeMonitor)",
"line" : 208}
,
{
"name" : "onDriveDisconnectedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(DriveIF, VolumeMonitor)[]",
"line" : 216}
,
{
"name" : "addOnDriveDisconnected",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a drive is disconnected from the system.\n\t \n",
"line" : 220}
,
{
"name" : "callBackDriveDisconnected",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GDrive* drive, VolumeMonitor volumeMonitor)",
"line" : 235}
,
{
"name" : "onDriveEjectButtonListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(DriveIF, VolumeMonitor)[]",
"line" : 243}
,
{
"name" : "addOnDriveEjectButton",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the eject button is pressed on drive.\n Since 2.18\n\t \n",
"line" : 248}
,
{
"name" : "callBackDriveEjectButton",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GDrive* drive, VolumeMonitor volumeMonitor)",
"line" : 263}
,
{
"name" : "onDriveStopButtonListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(DriveIF, VolumeMonitor)[]",
"line" : 271}
,
{
"name" : "addOnDriveStopButton",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(DriveIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when the stop button is pressed on drive.\n Since 2.22\n\t \n",
"line" : 276}
,
{
"name" : "callBackDriveStopButton",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GDrive* drive, VolumeMonitor volumeMonitor)",
"line" : 291}
,
{
"name" : "onMountAddedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(MountIF, VolumeMonitor)[]",
"line" : 299}
,
{
"name" : "addOnMountAdded",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mount is added.\n\t \n",
"line" : 303}
,
{
"name" : "callBackMountAdded",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GMount* mount, VolumeMonitor volumeMonitor)",
"line" : 318}
,
{
"name" : "onMountChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(MountIF, VolumeMonitor)[]",
"line" : 326}
,
{
"name" : "addOnMountChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mount changes.\n\t \n",
"line" : 330}
,
{
"name" : "callBackMountChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GMount* mount, VolumeMonitor volumeMonitor)",
"line" : 345}
,
{
"name" : "onMountPreUnmountListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(MountIF, VolumeMonitor)[]",
"line" : 353}
,
{
"name" : "addOnMountPreUnmount",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mount is about to be removed.\n\t \n",
"line" : 357}
,
{
"name" : "callBackMountPreUnmount",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GMount* mount, VolumeMonitor volumeMonitor)",
"line" : 372}
,
{
"name" : "onMountRemovedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(MountIF, VolumeMonitor)[]",
"line" : 380}
,
{
"name" : "addOnMountRemoved",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(MountIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mount is removed.\n\t \n",
"line" : 384}
,
{
"name" : "callBackMountRemoved",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GMount* mount, VolumeMonitor volumeMonitor)",
"line" : 399}
,
{
"name" : "onVolumeAddedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(VolumeIF, VolumeMonitor)[]",
"line" : 407}
,
{
"name" : "addOnVolumeAdded",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(VolumeIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mountable volume is added to the system.\n\t \n",
"line" : 411}
,
{
"name" : "callBackVolumeAdded",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GVolume* volume, VolumeMonitor volumeMonitor)",
"line" : 426}
,
{
"name" : "onVolumeChangedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(VolumeIF, VolumeMonitor)[]",
"line" : 434}
,
{
"name" : "addOnVolumeChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(VolumeIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when mountable volume is changed.\n\t \n",
"line" : 438}
,
{
"name" : "callBackVolumeChanged",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GVolume* volume, VolumeMonitor volumeMonitor)",
"line" : 453}
,
{
"name" : "onVolumeRemovedListeners",
"kind" : "variable",
"protection" : "public",
"type" : "void delegate(VolumeIF, VolumeMonitor)[]",
"line" : 461}
,
{
"name" : "addOnVolumeRemoved",
"kind" : "function",
"protection" : "public",
"type" : "void(void delegate(VolumeIF, VolumeMonitor) dlg, GConnectFlags connectFlags = cast(GConnectFlags)0)",
"comment" : "\n Emitted when a mountable volume is removed from the system.\n See Also\n GFileMonitor\n\t \n",
"line" : 467}
,
{
"name" : "callBackVolumeRemoved",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(GVolumeMonitor* volumeMonitorStruct, GVolume* volume, VolumeMonitor volumeMonitor)",
"line" : 482}
,
{
"name" : "getConnectedDrives",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets a list of drives connected to the system.\n The returned list should be freed with g_list_free(), after\n its elements have been unreffed with g_object_unref().\n Returns: a GList of connected GDrive objects. [element-type GDrive][transfer full GDrive]\n\t \n",
"line" : 497}
,
{
"name" : "getVolumes",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets a list of the volumes on the system.\n The returned list should be freed with g_list_free(), after\n its elements have been unreffed with g_object_unref().\n Returns: a GList of GVolume objects. [element-type GVolume][transfer full GVolume]\n\t \n",
"line" : 514}
,
{
"name" : "getMounts",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets a list of the mounts on the system.\n The returned list should be freed with g_list_free(), after\n its elements have been unreffed with g_object_unref().\n Returns: a GList of GMount objects. [element-type GMount][transfer full GMount]\n\t \n",
"line" : 531}
,
{
"name" : "adoptOrphanMount",
"kind" : "function",
"protection" : "public",
"type" : "VolumeIF(MountIF mount)",
"comment" : "\n Warning\n g_volume_monitor_adopt_orphan_mount has been deprecated since version 2.20 and should not be used in newly-written code. Instead of using this function, GVolumeMonitor\n implementations should instead create shadow mounts with the URI of\n the mount they intend to adopt. See the proxy volume monitor in\n gvfs for an example of this. Also see g_mount_is_shadowed(),\n g_mount_shadow() and g_mount_unshadow() functions.\n This function should be called by any GVolumeMonitor\n implementation when a new GMount object is created that is not\n associated with a GVolume object. It must be called just before\n emitting the mount_added signal.\n If the return value is not NULL, the caller must associate the\n returned GVolume object with the GMount. This involves returning\n it in its g_mount_get_volume() implementation. The caller must\n also listen for the \"removed\" signal on the returned object\n and give up its reference when handling that signal\n Similary, if implementing g_volume_monitor_adopt_orphan_mount(),\n the implementor must take a reference to mount and return it in\n its g_volume_get_mount() implemented. Also, the implementor must\n listen for the \"unmounted\" signal on mount and give up its\n reference upon handling that signal.\n There are two main use cases for this function.\n One is when implementing a user space file system driver that reads\n blocks of a block device that is already represented by the native\n volume monitor (for example a CD Audio file system driver). Such\n a driver will generate its own GMount object that needs to be\n assoicated with the GVolume object that represents the volume.\n The other is for implementing a GVolumeMonitor whose sole purpose\n is to return GVolume objects representing entries in the users\n \"favorite servers\" list or similar.\n Params:\n mount = a GMount object to find a parent for\n Returns: the GVolume object that is the parent for mount or NULL if no wants to adopt the GMount.\n\t \n",
"line" : 576}
,
{
"name" : "getMountForUuid",
"kind" : "function",
"protection" : "public",
"type" : "MountIF(string uuid)",
"comment" : "\n Finds a GMount object by its UUID (see g_mount_get_uuid())\n Params:\n uuid = the UUID to look for\n Returns: a GMount or NULL if no such mount is available. Free the returned object with g_object_unref().\n\t \n",
"line" : 593}
,
{
"name" : "getVolumeForUuid",
"kind" : "function",
"protection" : "public",
"type" : "VolumeIF(string uuid)",
"comment" : "\n Finds a GVolume object by its UUID (see g_volume_get_uuid())\n Params:\n uuid = the UUID to look for\n Returns: a GVolume or NULL if no such volume is available. Free the returned object with g_object_unref(). Signal Details The \"drive-changed\" signal void user_function (GVolumeMonitor *volume_monitor, GDrive *drive, gpointer user_data) : Run Last Emitted when a drive changes.\n\t \n",
"line" : 610}
]
}
]
}
,
{
"name" : "gio.VolumeT",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/VolumeT.d",
"members" : [
{
"name" : "VolumeT(TStruct)",
"kind" : "template",
"protection" : "public",
"comment" : "\n Description\n The GVolume interface represents user-visible objects that can be\n mounted. Note, when porting from GnomeVFS, GVolume is the moral\n equivalent of GnomeVFSDrive.\n Mounting a GVolume instance is an asynchronous operation. For more\n information about asynchronous operations, see GAsyncReady and\n GSimpleAsyncReady. To mount a GVolume, first call\n g_volume_mount() with (at least) the GVolume instance, optionally\n a GMountOperation object and a GAsyncReadyCallback.\n Typically, one will only want to pass NULL for the\n GMountOperation if automounting all volumes when a desktop session\n starts since it's not desirable to put up a lot of dialogs asking\n for credentials.\n The callback will be fired when the operation has resolved (either\n with success or failure), and a GAsyncReady structure will be\n passed to the callback. That callback should then call\n g_volume_mount_finish() with the GVolume instance and the\n GAsyncReady data to see if the operation was completed\n successfully. If an error is present when g_volume_mount_finish()\n is called, then it will be filled with any error information.\n It is sometimes necessary to directly access the underlying\n operating system object behind a volume (e.g. for passing a volume\n to an application via the commandline). For this purpose, GIO\n allows to obtain an 'identifier' for the volume. There can be\n different kinds of identifiers, such as Hal UDIs, filesystem labels,\n traditional Unix devices (e.g. \/dev\/sda2),\n uuids. GIO uses predefind strings as names for the different kinds\n of identifiers: G_VOLUME_IDENTIFIER_KIND_HAL_UDI,\n G_VOLUME_IDENTIFIER_KIND_LABEL, etc. Use g_volume_get_identifier()\n to obtain an identifier for a volume.\n Note that G_VOLUME_IDENTIFIER_KIND_HAL_UDI will only be available\n when the gvfs hal volume monitor is in use. Other volume monitors\n will generally be able to provide the G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE\n identifier, which can be used to obtain a hal device by means of\n libhal_manger_find_device_string_match().\n \n",
"line" : 138,
"members" : [
{
"name" : "gVolume",
"kind" : "variable",
"type" : "GVolume*",
"comment" : " the main Gtk struct \n",
"line" : 142}
,
{
"name" : "getVolumeTStruct",
"kind" : "function",
"type" : "GVolume*()",
"line" : 145}
,
{
"name" : "connectedSignals",
"kind" : "variable",
"type" : "int[const(char)[]]",
"comment" : "\n\t \n",
"line" : 153}
,
{
"name" : "_onChangedListeners",
"kind" : "variable",
"type" : "void delegate(VolumeIF)[]",
"line" : 155}
,
{
"name" : "onChangedListeners",
"kind" : "function",
"type" : "void delegate(VolumeIF)[]()",
"line" : 156}
,
{
"name" : "addOnChanged",
"kind" : "function",
"type" : "void(void delegate(VolumeIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n Emitted when the volume has been changed.\n\t \n",
"line" : 163}
,
{
"name" : "callBackChanged",
"kind" : "function",
"type" : "extern (C) void(GVolume* arg0Struct, VolumeIF volumeIF)",
"line" : 178}
,
{
"name" : "_onRemovedListeners",
"kind" : "variable",
"type" : "void delegate(VolumeIF)[]",
"line" : 186}
,
{
"name" : "onRemovedListeners",
"kind" : "function",
"type" : "void delegate(VolumeIF)[]()",
"line" : 187}
,
{
"name" : "addOnRemoved",
"kind" : "function",
"type" : "void(void delegate(VolumeIF) dlg, ConnectFlags connectFlags = cast(ConnectFlags)0)",
"comment" : "\n This signal is emitted when the GVolume have been removed. If\n the recipient is holding references to the object they should\n release them so the object can be finalized.\n\t \n",
"line" : 196}
,
{
"name" : "callBackRemoved",
"kind" : "function",
"type" : "extern (C) void(GVolume* arg0Struct, VolumeIF volumeIF)",
"line" : 211}
,
{
"name" : "getName",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the name of volume.\n Returns: the name for the given volume. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 224}
,
{
"name" : "getUuid",
"kind" : "function",
"type" : "string()",
"comment" : "\n Gets the UUID for the volume. The reference is typically based on\n the file system UUID for the volume in question and should be\n considered an opaque string. Returns NULL if there is no UUID\n available.\n Returns: the UUID for volume or NULL if no UUID can be computed. The returned string should be freed with g_free() when no longer needed.\n\t \n",
"line" : 237}
,
{
"name" : "getIcon",
"kind" : "function",
"type" : "IconIF()",
"comment" : "\n Gets the icon for volume.\n Returns: a GIcon. The returned object should be unreffed with g_object_unref() when no longer needed. [transfer full]\n\t \n",
"line" : 247}
,
{
"name" : "getDrive",
"kind" : "function",
"type" : "DriveIF()",
"comment" : "\n Gets the drive for the volume.\n Returns: a GDrive or NULL if volume is not associated with a drive. The returned object should be unreffed with g_object_unref() when no longer needed. [transfer full]\n\t \n",
"line" : 262}
,
{
"name" : "getMount",
"kind" : "function",
"type" : "MountIF()",
"comment" : "\n Gets the mount for the volume.\n Returns: a GMount or NULL if volume isn't mounted. The returned object should be unreffed with g_object_unref() when no longer needed. [transfer full]\n\t \n",
"line" : 277}
,
{
"name" : "canMount",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a volume can be mounted.\n Returns: TRUE if the volume can be mounted. FALSE otherwise.\n\t \n",
"line" : 292}
,
{
"name" : "shouldAutomount",
"kind" : "function",
"type" : "int()",
"comment" : "\n Returns whether the volume should be automatically mounted.\n Returns: TRUE if the volume should be automatically mounted.\n\t \n",
"line" : 302}
,
{
"name" : "getActivationRoot",
"kind" : "function",
"type" : "File()",
"comment" : "\n Gets the activation root for a GVolume if it is known ahead of\n mount time. Returns NULL otherwise. If not NULL and if volume\n is mounted, then the result of g_mount_get_root() on the\n GMount object obtained from g_volume_get_mount() will always\n either be equal or a prefix of what this function returns. In\n other words, in code\n  GMount *mount;\n  GFile *mount_root\n  GFile *volume_activation_root;\n  mount = g_volume_get_mount (volume); \/+* mounted, so never NULL +\/\n  mount_root = g_mount_get_root (mount);\n  volume_activation_root = g_volume_get_activation_root(volume); \/+* assume not NULL +\/\n then the expression\n  (g_file_has_prefix (volume_activation_root, mount_root) ||\n  g_file_equal (volume_activation_root, mount_root))\n will always be TRUE.\n Activation roots are typically used in GVolumeMonitor\n implementations to find the underlying mount to shadow, see\n g_mount_is_shadowed() for more details.\n Since 2.18\n Returns: the activation root of volume or NULL. Use g_object_unref() to free.\n\t \n",
"line" : 331}
,
{
"name" : "mount",
"kind" : "function",
"type" : "void(GMountMountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Mounts a volume. This is an asynchronous operation, and is\n finished by calling g_volume_mount_finish() with the volume\n and GAsyncResult returned in the callback.\n Params:\n flags = flags affecting the operation\n mountOperation = a GMountOperation or NULL to avoid user interaction. [allow-none]\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data that gets passed to callback\n\t \n",
"line" : 353}
,
{
"name" : "mountFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes mounting a volume. If any errors occured during the operation,\n error will be set to contain the errors and FALSE will be returned.\n If the mount operation succeeded, g_volume_get_mount() on volume\n is guaranteed to return the mount right after calling this\n function; there's no need to listen for the 'mount-added' signal on\n GVolumeMonitor.\n Params:\n result = a GAsyncResult\n Returns: TRUE, FALSE if operation failed.\n Throws: GException on failure.\n\t \n",
"line" : 371}
,
{
"name" : "canEject",
"kind" : "function",
"type" : "int()",
"comment" : "\n Checks if a volume can be ejected.\n Returns: TRUE if the volume can be ejected. FALSE otherwise.\n\t \n",
"line" : 390}
,
{
"name" : "eject",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Warning\n g_volume_eject has been deprecated since version 2.22 and should not be used in newly-written code. Use g_volume_eject_with_operation() instead.\n Ejects a volume. This is an asynchronous operation, and is\n finished by calling g_volume_eject_finish() with the volume\n and GAsyncResult returned in the callback.\n Params:\n flags = flags affecting the unmount if required for eject\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data that gets passed to callback\n\t \n",
"line" : 408}
,
{
"name" : "ejectFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Warning\n g_volume_eject_finish has been deprecated since version 2.22 and should not be used in newly-written code. Use g_volume_eject_with_operation_finish() instead.\n Finishes ejecting a volume. If any errors occured during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Params:\n result = a GAsyncResult.\n Returns: TRUE, FALSE if operation failed.\n Throws: GException on failure.\n\t \n",
"line" : 424}
,
{
"name" : "ejectWithOperation",
"kind" : "function",
"type" : "void(GMountUnmountFlags flags, MountOperation mountOperation, Cancellable cancellable, GAsyncReadyCallback callback, void* userData)",
"comment" : "\n Ejects a volume. This is an asynchronous operation, and is\n finished by calling g_volume_eject_with_operation_finish() with the volume\n and GAsyncResult data returned in the callback.\n Since 2.22\n Params:\n flags = flags affecting the unmount if required for eject\n mountOperation = a GMountOperation or NULL to avoid user interaction.\n cancellable = optional GCancellable object, NULL to ignore.\n callback = a GAsyncReadyCallback, or NULL.\n userData = user data passed to callback.\n\t \n",
"line" : 451}
,
{
"name" : "ejectWithOperationFinish",
"kind" : "function",
"type" : "int(AsyncResultIF result)",
"comment" : "\n Finishes ejecting a volume. If any errors occurred during the operation,\n error will be set to contain the errors and FALSE will be returned.\n Since 2.22\n Params:\n result = a GAsyncResult.\n Returns: TRUE if the volume was successfully ejected. FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 466}
,
{
"name" : "enumerateIdentifiers",
"kind" : "function",
"type" : "string[]()",
"comment" : "\n Gets the kinds of identifiers\n that volume has. Use g_volume_get_identifer() to obtain\n the identifiers themselves.\n Returns: a NULL-terminated array of strings containing kinds of identifiers. Use g_strfreev() to free.\n\t \n",
"line" : 487}
,
{
"name" : "getIdentifier",
"kind" : "function",
"type" : "string(string kind)",
"comment" : "\n Gets the identifier of the given kind for volume.\n See the introduction\n for more information about volume identifiers.\n Params:\n kind = the kind of identifier to return\n Returns: a newly allocated string containing the requested identfier, or NULL if the GVolume doesn't have this kind of identifier Signal Details The \"changed\" signal void user_function (GVolume *arg0, gpointer user_data) : Run Last Emitted when the volume has been changed.\n\t \n",
"line" : 501}
]
}
]
}
,
{
"name" : "gio.ZlibCompressor",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ZlibCompressor.d",
"members" : [
{
"name" : "ZlibCompressor",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GZlibCompressor is an implementation of GConverter that\n compresses data using zlib.\n \n",
"line" : 77,
"base" : "ObjectG",
"interfaces" : [
"ConverterIF"],
"members" : [
{
"name" : "gZlibCompressor",
"kind" : "variable",
"protection" : "protected",
"type" : "GZlibCompressor*",
"comment" : " the main Gtk struct \n",
"line" : 81}
,
{
"name" : "getZlibCompressorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GZlibCompressor*()",
"line" : 84}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 91}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZlibCompressor(GZlibCompressor* gZlibCompressor)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 99}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 117}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZlibCompressor(GZlibCompressorFormat format, int level)",
"comment" : "\n\t \n\n Creates a new GZlibCompressor.\n Since 2.24\n Params:\n format = The format to use for the compressed data\n level = compression level (0-9), -1 for default\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 137}
,
{
"name" : "getFileInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo()",
"comment" : "\n Returns the \"file-info\" property.\n Since 2.26\n Returns: a GFileInfo, or NULL. [transfer none]\n\t \n",
"line" : 153}
,
{
"name" : "setFileInfo",
"kind" : "function",
"protection" : "public",
"type" : "void(FileInfo fileInfo)",
"comment" : "\n Sets file_info in compressor. If non-NULL, and compressor's\n \"format\" property is G_ZLIB_COMPRESSOR_FORMAT_GZIP,\n it will be used to set the file name and modification time in\n the GZIP header of the compressed data.\n Note: it is an error to call this function while a compression is in\n progress; it may only be called immediately after creation of compressor,\n or after resetting it with g_converter_reset().\n Since 2.26\n Params:\n fileInfo = a GFileInfo. [allow-none]\n\t \n",
"line" : 176}
]
}
]
}
,
{
"name" : "gio.ZlibDecompressor",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/gio\/ZlibDecompressor.d",
"members" : [
{
"name" : "ZlibDecompressor",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GZlibDecompressor is an implementation of GConverter that\n decompresses data compressed with zlib.\n \n",
"line" : 77,
"base" : "ObjectG",
"interfaces" : [
"ConverterIF"],
"members" : [
{
"name" : "gZlibDecompressor",
"kind" : "variable",
"protection" : "protected",
"type" : "GZlibDecompressor*",
"comment" : " the main Gtk struct \n",
"line" : 81}
,
{
"name" : "getZlibDecompressorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GZlibDecompressor*()",
"line" : 84}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 91}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZlibDecompressor(GZlibDecompressor* gZlibDecompressor)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 99}
,
{
"name" : "setStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void(GObject* obj)",
"line" : 117}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ZlibDecompressor(GZlibCompressorFormat format)",
"comment" : "\n\t \n\n Creates a new GZlibDecompressor.\n Since 2.24\n Params:\n format = The format to use for the compressed data\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 136}
,
{
"name" : "getFileInfo",
"kind" : "function",
"protection" : "public",
"type" : "FileInfo()",
"comment" : "\n Retrieves the GFileInfo constructed from the GZIP header data\n of compressed data processed by compressor, or NULL if decompressor's\n \"format\" property is not G_ZLIB_COMPRESSOR_FORMAT_GZIP,\n or the header data was not fully processed yet, or it not present in the\n data stream at all.\n Since 2.26\n Returns: a GFileInfo, or NULL. [transfer none]\n\t \n",
"line" : 156}
]
}
]
}
]
