[
{
"name" : "glib.Allocator",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Allocator.d",
"members" : [
{
"name" : "Allocator",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Prior to 2.10, GAllocator was used as an efficient way to allocate\n small pieces of memory for use with the GList, GSList and GNode\n data structures. Since 2.10, it has been completely replaced by the\n slice allocator and\n deprecated.\n \n",
"line" : 74,
"base" : "Object",
"members" : [
{
"name" : "gAllocator",
"kind" : "variable",
"protection" : "protected",
"type" : "GAllocator*",
"comment" : " the main Gtk struct \n",
"line" : 77}
,
{
"name" : "getAllocatorStruct",
"kind" : "function",
"protection" : "public",
"type" : "GAllocator*()",
"line" : 80}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 87}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Allocator(GAllocator* gAllocator)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 95}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Allocator(string name, uint nPreallocs)",
"comment" : "\n\t \n\n Warning\n g_allocator_new has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Creates a new GAllocator.\n Params:\n name = the name of the GAllocator. This name is used to set the\n  name of the GMemChunk used by the GAllocator, and is only\n  used for debugging.\n nPreallocs = the number of elements in each block of memory\n  allocated. Larger blocks mean less calls to\n  g_malloc(), but some memory may be wasted. (GLib uses\n  128 elements per block by default.) The value must be\n  between 1 and 65535.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 124}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_allocator_free has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Frees all of the memory allocated by the GAllocator.\n\t \n",
"line" : 141}
]
}
]
}
,
{
"name" : "glib.ArrayG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ArrayG.d",
"members" : [
{
"name" : "ArrayG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Arrays are similar to standard C arrays, except that they grow\n automatically as elements are added.\n Array elements can be of any size (though all elements of one array\n are the same size), and the array can be automatically cleared to\n '0's and zero-terminated.\n To create a new array use g_array_new().\n To add elements to an array, use g_array_append_val(),\n g_array_append_vals(), g_array_prepend_val(), and\n g_array_prepend_vals().\n To access an element of an array, use g_array_index().\n To set the size of an array, use g_array_set_size().\n To free an array, use g_array_free().\n $(DDOC_COMMENT example)\n \n",
"line" : 83,
"base" : "Object",
"members" : [
{
"name" : "gArray",
"kind" : "variable",
"protection" : "protected",
"type" : "GArray*",
"comment" : " the main Gtk struct \n",
"line" : 86}
,
{
"name" : "getArrayGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GArray*()",
"line" : 89}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ArrayG(GArray* gArray)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 104}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ArrayG(int zeroTerminated, int clear, uint elementSize)",
"comment" : "\n\t \n\n Creates a new GArray with a reference count of 1.\n Params:\n zeroTerminated = TRUE if the array should have an extra element at\n  the end which is set to 0.\n clear = TRUE if GArray elements should be automatically cleared\n  to 0 when they are allocated.\n elementSize = the size of each element in bytes.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 127}
,
{
"name" : "sizedNew",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(int zeroTerminated, int clear, uint elementSize, uint reservedSize)",
"comment" : "\n Creates a new GArray with reserved_size elements preallocated and\n a reference count of 1. This avoids frequent reallocation, if you\n are going to add many elements to the array. Note however that the\n size of the array is still 0.\n Params:\n zeroTerminated = TRUE if the array should have an extra element at\n  the end with all bits cleared.\n clear = TRUE if all bits in the array should be cleared to 0 on\n  allocation.\n elementSize = size of each element in the array.\n reservedSize = number of elements preallocated.\n Returns: the new GArray.\n\t \n",
"line" : 152}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG()",
"comment" : "\n Atomically increments the reference count of array by one. This\n function is MT-safe and may be called from any thread.\n Since 2.22\n Returns: The passed in GArray.\n\t \n",
"line" : 169}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Atomically decrements the reference count of array by one. If the\n reference count drops to 0, all memory allocated by the array is\n released. This function is MT-safe and may be called from any\n thread.\n Since 2.22\n\t \n",
"line" : 187}
,
{
"name" : "getElementSize",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the size of the elements in array.\n Since 2.22\n Returns: Size of each element, in bytes.\n\t \n",
"line" : 198}
,
{
"name" : "appendVals",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(void* data, uint len)",
"comment" : "\n Adds len elements onto the end of the array.\n Params:\n data = a pointer to the elements to append to the end of the array.\n len = the number of elements to append.\n Returns: the GArray.\n\t \n",
"line" : 211}
,
{
"name" : "prependVals",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(void* data, uint len)",
"comment" : "\n Adds len elements onto the start of the array.\n This operation is slower than g_array_append_vals() since the\n existing elements in the array have to be moved to make space for\n the new elements.\n Params:\n data = a pointer to the elements to prepend to the start of the\n  array.\n len = the number of elements to prepend.\n Returns: the GArray.\n\t \n",
"line" : 233}
,
{
"name" : "insertVals",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(uint index, void* data, uint len)",
"comment" : "\n Inserts len elements into a GArray at the given index.\n Params:\n index = the index to place the elements at.\n data = a pointer to the elements to insert.\n len = the number of elements to insert.\n Returns: the GArray.\n\t \n",
"line" : 252}
,
{
"name" : "removeIndex",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(uint index)",
"comment" : "\n Removes the element at the given index from a GArray. The following\n elements are moved down one place.\n Params:\n index = the index of the element to remove.\n Returns: the GArray.\n\t \n",
"line" : 270}
,
{
"name" : "removeIndexFast",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(uint index)",
"comment" : "\n Removes the element at the given index from a GArray. The last\n element in the array is used to fill in the space, so this function\n does not preserve the order of the GArray. But it is faster than\n g_array_remove_index().\n Params:\n index = the index of the element to remove.\n Returns: the GArray.\n\t \n",
"line" : 290}
,
{
"name" : "removeRange",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(uint index, uint length)",
"comment" : "\n Removes the given number of elements starting at the given index\n from a GArray. The following elements are moved to close the gap.\n Since 2.4\n Params:\n index = the index of the first element to remove.\n length = the number of elements to remove.\n Returns: the GArray.\n\t \n",
"line" : 310}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*) compareFunc)",
"comment" : "\n Sorts a GArray using compare_func which should be a qsort()-style\n comparison function (returns less than zero for first arg is less\n than second arg, zero for equal, greater zero if first arg is\n greater than second arg).\n If two array elements compare equal, their order in the sorted array\n is undefined.\n Params:\n compareFunc = comparison function.\n\t \n",
"line" : 331}
,
{
"name" : "sortWithData",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n Like g_array_sort(), but the comparison function receives an extra\n user data argument.\n Params:\n compareFunc = comparison function.\n userData = data to pass to compare_func.\n\t \n",
"line" : 344}
,
{
"name" : "setSize",
"kind" : "function",
"protection" : "public",
"type" : "ArrayG(uint length)",
"comment" : "\n Sets the size of the array, expanding it if necessary. If the array\n was created with clear_ set to TRUE, the new elements are set to 0.\n Params:\n length = the new size of the GArray.\n Returns: the GArray.\n\t \n",
"line" : 357}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "string(int freeSegment)",
"comment" : "\n Frees the memory allocated for the GArray. If free_segment is\n TRUE it frees the memory block holding the elements as well and\n also each element if array has a element_free_func set. Pass\n FALSE if you want to free the GArray wrapper but preserve the\n underlying array for use elsewhere. If the reference count of array\n is greater than one, the GArray wrapper is preserved but the size\n of array will be set to zero.\n Note\n If array elements contain dynamically-allocated memory,\n they should be freed separately.\n Params:\n freeSegment = if TRUE the actual element data is freed as well.\n Returns: the element data if free_segment is FALSE, otherwise NULL. The element data should be freed using g_free().\n\t \n",
"line" : 383}
]
}
]
}
,
{
"name" : "glib.AsyncQueue",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/AsyncQueue.d",
"members" : [
{
"name" : "AsyncQueue",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Often you need to communicate between different threads. In general\n it's safer not to do this by shared memory, but by explicit message\n passing. These messages only make sense asynchronously for\n multi-threaded applications though, as a synchronous operation could\n as well be done in the same thread.\n Asynchronous queues are an exception from most other GLib data\n structures, as they can be used simultaneously from multiple threads\n without explicit locking and they bring their own builtin reference\n counting. This is because the nature of an asynchronous queue is that\n it will always be used by at least 2 concurrent threads.\n For using an asynchronous queue you first have to create one with\n g_async_queue_new(). A newly-created queue will get the reference\n count 1. Whenever another thread is creating a new reference of (that\n is, pointer to) the queue, it has to increase the reference count\n (using g_async_queue_ref()). Also, before removing this reference,\n the reference count has to be decreased (using g_async_queue_unref()).\n After that the queue might no longer exist so you must not access\n it after that point.\n A thread, which wants to send a message to that queue simply calls\n g_async_queue_push() to push the message to the queue.\n A thread, which is expecting messages from an asynchronous queue\n simply calls g_async_queue_pop() for that queue. If no message is\n available in the queue at that point, the thread is now put to sleep\n until a message arrives. The message will be removed from the queue\n and returned. The functions g_async_queue_try_pop() and\n g_async_queue_timed_pop() can be used to only check for the presence\n of messages or to only wait a certain time for messages respectively.\n For almost every function there exist two variants, one that locks\n the queue and one that doesn't. That way you can hold the queue lock\n (acquire it with g_async_queue_lock() and release it with\n g_async_queue_unlock()) over multiple queue accessing instructions.\n This can be necessary to ensure the integrity of the queue, but should\n only be used when really necessary, as it can make your life harder\n if used unwisely. Normally you should only use the locking function\n variants (those without the suffix _unlocked)\n \n",
"line" : 106,
"base" : "Object",
"members" : [
{
"name" : "gAsyncQueue",
"kind" : "variable",
"protection" : "protected",
"type" : "GAsyncQueue*",
"comment" : " the main Gtk struct \n",
"line" : 109}
,
{
"name" : "getAsyncQueueStruct",
"kind" : "function",
"protection" : "public",
"type" : "GAsyncQueue*()",
"line" : 112}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 119}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "AsyncQueue(GAsyncQueue* gAsyncQueue)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 127}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "AsyncQueue()",
"comment" : "\n\t \n\n Creates a new asynchronous queue with the initial reference count of 1.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 144}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "AsyncQueue(extern (C) void function(void* cbData) itemFreeFunc)",
"comment" : "\n Creates a new asynchronous queue with an initial reference count of 1 and\n sets up a destroy notify function that is used to free any remaining\n queue items when the queue is destroyed after the final unref.\n Since 2.16\n Params:\n itemFreeFunc = function to free queue elements\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 164}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "AsyncQueue()",
"comment" : "\n Increases the reference count of the asynchronous queue by 1. You\n do not need to hold the lock to call this function.\n Returns: the queue that was passed in (since 2.6)\n\t \n",
"line" : 180}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decreases the reference count of the asynchronous queue by 1. If\n the reference count went to 0, the queue will be destroyed and the\n memory allocated will be freed. So you are not allowed to use the\n queue afterwards, as it might have disappeared. You do not need to\n hold the lock to call this function.\n\t \n",
"line" : 198}
,
{
"name" : "push",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Pushes the data into the queue. data must not be NULL.\n Params:\n data = data to push into the queue.\n\t \n",
"line" : 209}
,
{
"name" : "pushSorted",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data, extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Inserts data into queue using func to determine the new\n position.\n This function requires that the queue is sorted before pushing on\n new elements.\n This function will lock queue before it sorts the queue and unlock\n it when it is finished.\n For an example of func see g_async_queue_sort().\n Since 2.10\n Params:\n data = the data to push into the queue\n func = the GCompareDataFunc is used to sort queue. This function\n  is passed two elements of the queue. The function should return\n  0 if they are equal, a negative value if the first element\n  should be higher in the queue or a positive value if the first\n  element should be lower in the queue than the second element.\n userData = user data passed to func.\n\t \n",
"line" : 233}
,
{
"name" : "pop",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Pops data from the queue. This function blocks until data become\n available.\n Returns: data from the queue.\n\t \n",
"line" : 244}
,
{
"name" : "tryPop",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Tries to pop data from the queue. If no data is available, NULL is\n returned.\n Returns: data from the queue or NULL, when no data is available immediately.\n\t \n",
"line" : 255}
,
{
"name" : "timedPop",
"kind" : "function",
"protection" : "public",
"type" : "void*(TimeVal endTime)",
"comment" : "\n Pops data from the queue. If no data is received before end_time,\n NULL is returned.\n To easily calculate end_time a combination of g_get_current_time()\n and g_time_val_add() can be used.\n Params:\n endTime = a GTimeVal, determining the final time.\n Returns: data from the queue or NULL, when no data is received before end_time.\n\t \n",
"line" : 270}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the length of the queue, negative values mean waiting\n threads, positive values mean available entries in the\n queue. Actually this function returns the number of data items in\n the queue minus the number of waiting threads. Thus a return value\n of 0 could mean 'n' entries in the queue and 'n' thread waiting.\n That can happen due to locking of the queue or due to\n scheduling.\n Returns: the length of the queue.\n\t \n",
"line" : 286}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Sorts queue using func.\n This function will lock queue before it sorts the queue and unlock\n it when it is finished.\n If you were sorting a list of priority numbers to make sure the\n Since 2.10\n Params:\n func = the GCompareDataFunc is used to sort queue. This\n  function is passed two elements of the queue. The function\n  should return 0 if they are equal, a negative value if the\n  first element should be higher in the queue or a positive\n  value if the first element should be lower in the queue than\n  the second element.\n userData = user data passed to func\n\t \n",
"line" : 307}
,
{
"name" : "lock",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Acquires the queue's lock. After that you can only call the\n g_async_queue_*_unlocked() function variants on that\n queue. Otherwise it will deadlock.\n\t \n",
"line" : 318}
,
{
"name" : "unlock",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Releases the queue's lock.\n\t \n",
"line" : 327}
,
{
"name" : "refUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_async_queue_ref_unlocked is deprecated and should not be used in newly-written code.\n Increases the reference count of the asynchronous queue by 1.\n Deprecated: Since 2.8, reference counting is done atomically\n so g_async_queue_ref() can be used regardless of the queue's\n lock.\n\t \n",
"line" : 341}
,
{
"name" : "unrefAndUnlock",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_async_queue_unref_and_unlock is deprecated and should not be used in newly-written code.\n Decreases the reference count of the asynchronous queue by 1 and\n releases the lock. This function must be called while holding the\n queue's lock. If the reference count went to 0, the queue will be\n destroyed and the memory allocated will be freed.\n Deprecated: Since 2.8, reference counting is done atomically\n so g_async_queue_unref() can be used regardless of the queue's\n lock.\n\t \n",
"line" : 358}
,
{
"name" : "pushUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Pushes the data into the queue. data must not be NULL. This\n function must be called while holding the queue's lock.\n Params:\n data = data to push into the queue.\n\t \n",
"line" : 370}
,
{
"name" : "pushSortedUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data, extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Inserts data into queue using func to determine the new\n position.\n This function requires that the queue is sorted before pushing on\n new elements.\n This function is called while holding the queue's lock.\n For an example of func see g_async_queue_sort().\n Since 2.10\n Params:\n data = the data to push into the queue\n func = the GCompareDataFunc is used to sort queue. This function\n  is passed two elements of the queue. The function should return\n  0 if they are equal, a negative value if the first element\n  should be higher in the queue or a positive value if the first\n  element should be lower in the queue than the second element.\n userData = user data passed to func.\n\t \n",
"line" : 393}
,
{
"name" : "popUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Pops data from the queue. This function blocks until data become\n available. This function must be called while holding the queue's\n lock.\n Returns: data from the queue.\n\t \n",
"line" : 405}
,
{
"name" : "tryPopUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Tries to pop data from the queue. If no data is available, NULL is\n returned. This function must be called while holding the queue's\n lock.\n Returns: data from the queue or NULL, when no data is available immediately.\n\t \n",
"line" : 417}
,
{
"name" : "timedPopUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void*(TimeVal endTime)",
"comment" : "\n Pops data from the queue. If no data is received before end_time,\n NULL is returned. This function must be called while holding the\n queue's lock.\n To easily calculate end_time a combination of g_get_current_time()\n and g_time_val_add() can be used.\n Params:\n endTime = a GTimeVal, determining the final time.\n Returns: data from the queue or NULL, when no data is received before end_time.\n\t \n",
"line" : 433}
,
{
"name" : "lengthUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the length of the queue, negative values mean waiting\n threads, positive values mean available entries in the\n queue. Actually this function returns the number of data items in\n the queue minus the number of waiting threads. Thus a return value\n of 0 could mean 'n' entries in the queue and 'n' thread waiting.\n That can happen due to locking of the queue or due to\n scheduling. This function must be called while holding the queue's\n lock.\n Returns: the length of the queue.\n\t \n",
"line" : 450}
,
{
"name" : "sortUnlocked",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Sorts queue using func.\n This function is called while holding the queue's lock.\n Since 2.10\n Params:\n func = the GCompareDataFunc is used to sort queue. This\n  function is passed two elements of the queue. The function\n  should return 0 if they are equal, a negative value if the\n  first element should be higher in the queue or a positive\n  value if the first element should be lower in the queue than\n  the second element.\n userData = user data passed to func\n\t \n",
"line" : 469}
]
}
]
}
,
{
"name" : "glib.Atomic",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Atomic.d",
"members" : [
{
"name" : "Atomic",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The following functions can be used to atomically access integers and\n pointers. They are implemented as inline assembler function on most\n platforms and use slower fall-backs otherwise. Using them can sometimes\n save you from using a performance-expensive GMutex to protect the\n integer or pointer.\n The most important usage is reference counting. Using\n g_atomic_int_inc() and g_atomic_int_dec_and_test() makes reference\n counting a very fast operation.\n Note\n You must not directly read integers or pointers concurrently\n accessed by multiple threads, but use the atomic accessor functions\n instead. That is, always use g_atomic_int_get() and g_atomic_pointer_get()\n for read outs. They provide the neccessary synchonization mechanisms\n like memory barriers to access memory locations concurrently.\n Note\n If you are using those functions for anything apart from\n simple reference counting, you should really be aware of the implications\n of doing that. There are literally thousands of ways to shoot yourself\n in the foot. So if in doubt, use a GMutex. If you don't know, what\n memory barriers are, do not use anything but g_atomic_int_inc() and\n g_atomic_int_dec_and_test().\n Note\n It is not safe to set an integer or pointer just by assigning\n to it, when it is concurrently accessed by other threads with the following\n functions. Use g_atomic_int_compare_and_exchange() or\n g_atomic_pointer_compare_and_exchange() respectively.\n \n",
"line" : 93,
"base" : "Object",
"members" : [
{
"name" : "intGet",
"kind" : "function",
"protection" : "public",
"type" : "int(int* atomic)",
"comment" : "\n\t \n\n Reads the value of the integer pointed to by atomic.\n Also acts as a memory barrier.\n Since 2.4\n Params:\n atomic = a pointer to an integer\n Returns: the value of *atomic\n\t \n",
"line" : 106}
,
{
"name" : "intSet",
"kind" : "function",
"protection" : "public",
"type" : "void(int* atomic, int newval)",
"comment" : "\n Sets the value of the integer pointed to by atomic.\n Also acts as a memory barrier.\n Since 2.10\n Params:\n atomic = a pointer to an integer\n newval = the new value\n\t \n",
"line" : 120}
,
{
"name" : "intAdd",
"kind" : "function",
"protection" : "public",
"type" : "void(int* atomic, int val)",
"comment" : "\n Atomically adds val to the integer pointed to by atomic.\n Also acts as a memory barrier.\n Since 2.4\n Params:\n atomic = a pointer to an integer\n val = the value to add to *atomic\n\t \n",
"line" : 134}
,
{
"name" : "intExchangeAndAdd",
"kind" : "function",
"protection" : "public",
"type" : "int(int* atomic, int val)",
"comment" : "\n Atomically adds val to the integer pointed to by atomic.\n It returns the value of *atomic just before the addition\n took place. Also acts as a memory barrier.\n Since 2.4\n Params:\n atomic = a pointer to an integer\n val = the value to add to *atomic\n Returns: the value of *atomic before the addition.\n\t \n",
"line" : 150}
,
{
"name" : "intCompareAndExchange",
"kind" : "function",
"protection" : "public",
"type" : "int(int* atomic, int oldval, int newval)",
"comment" : "\n Compares oldval with the integer pointed to by atomic and\n if they are equal, atomically exchanges *atomic with newval.\n Also acts as a memory barrier.\n Since 2.4\n Params:\n atomic = a pointer to an integer\n oldval = the assumed old value of *atomic\n newval = the new value of *atomic\n Returns: TRUE, if *atomic was equal oldval. FALSE otherwise.\n\t \n",
"line" : 167}
,
{
"name" : "pointerGet",
"kind" : "function",
"protection" : "public",
"type" : "void*(void** atomic)",
"comment" : "\n Reads the value of the pointer pointed to by atomic.\n Also acts as a memory barrier.\n Since 2.4\n Params:\n atomic = a pointer to a gpointer.\n Returns: the value to add to *atomic.\n\t \n",
"line" : 181}
,
{
"name" : "pointerSet",
"kind" : "function",
"protection" : "public",
"type" : "void(void** atomic, void* newval)",
"comment" : "\n Sets the value of the pointer pointed to by atomic.\n Also acts as a memory barrier.\n Since 2.10\n Params:\n atomic = a pointer to a gpointer\n newval = the new value\n\t \n",
"line" : 195}
,
{
"name" : "pointerCompareAndExchange",
"kind" : "function",
"protection" : "public",
"type" : "int(void** atomic, void* oldval, void* newval)",
"comment" : "\n Compares oldval with the pointer pointed to by atomic and\n if they are equal, atomically exchanges *atomic with newval.\n Also acts as a memory barrier.\n Since 2.4\n Params:\n atomic = a pointer to a gpointer\n oldval = the assumed old value of *atomic\n newval = the new value of *atomic\n Returns: TRUE, if *atomic was equal oldval. FALSE otherwise.\n\t \n",
"line" : 212}
,
{
"name" : "intInc",
"kind" : "function",
"protection" : "public",
"type" : "void(int* atomic)",
"comment" : "\n Atomically increments the integer pointed to by atomic by 1.\n Since 2.4\n Params:\n atomic = a pointer to an integer.\n\t \n",
"line" : 224}
,
{
"name" : "intDecAndTest",
"kind" : "function",
"protection" : "public",
"type" : "int(int* atomic)",
"comment" : "\n Atomically decrements the integer pointed to by atomic by 1.\n Since 2.4\n Params:\n atomic = a pointer to an integer\n Returns: TRUE if the integer pointed to by atomic is 0 after decrementing it\n\t \n",
"line" : 237}
]
}
]
}
,
{
"name" : "glib.Base64",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Base64.d",
"members" : [
{
"name" : "Base64",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Base64 is an encoding that allows a sequence of arbitrary bytes to be\n encoded as a sequence of printable ASCII characters. For the definition\n of Base64, see RFC\n 1421 or RFC\n 2045. Base64 is most commonly used as a MIME transfer encoding\n for email.\n GLib supports incremental encoding using g_base64_encode_step() and\n g_base64_encode_close(). Incremental decoding can be done with\n g_base64_decode_step(). To encode or decode data in one go, use\n g_base64_encode() or g_base64_decode(). To avoid memory allocation when\n decoding, you can use g_base64_decode_inplace().\n Support for Base64 encoding has been added in GLib 2.12.\n \n",
"line" : 81,
"base" : "Object",
"members" : [
{
"name" : "encodeStep",
"kind" : "function",
"protection" : "public",
"type" : "ulong(char* inn, ulong len, int breakLines, string f_out, ref int state, ref int save)",
"comment" : "\n\t \n\n Incrementally encode a sequence of binary data into its Base-64 stringified\n representation. By calling this function multiple times you can convert\n data in chunks to avoid having to have the full encoded data in memory.\n When all of the data has been converted you must call\n g_base64_encode_close() to flush the saved state.\n The output buffer must be large enough to fit all the data that will\n be written to it. Due to the way base64 encodes you will need\n at least: (len \/ 3 + 1) * 4 + 4 bytes (+ 4 may be needed in case of\n Since 2.12\n Params:\n in = the binary data to encode\n len = the length of in\n breakLines = whether to break long lines\n out = pointer to destination buffer\n state = Saved state between steps, initialize to 0\n save = Saved state between steps, initialize to 0\n Returns: The number of bytes of output that was written\n\t \n",
"line" : 105}
,
{
"name" : "encodeClose",
"kind" : "function",
"protection" : "public",
"type" : "ulong(int breakLines, string f_out, ref int state, ref int save)",
"comment" : "\n Flush the status from a sequence of calls to g_base64_encode_step().\n The output buffer must be large enough to fit all the data that will\n be written to it. It will need up to 4 bytes, or up to 5 bytes if\n line-breaking is enabled.\n Since 2.12\n Params:\n breakLines = whether to break long lines\n out = pointer to destination buffer\n state = Saved state from g_base64_encode_step()\n save = Saved state from g_base64_encode_step()\n Returns: The number of bytes of output that was written\n\t \n",
"line" : 124}
,
{
"name" : "encode",
"kind" : "function",
"protection" : "public",
"type" : "string(char* data, ulong len)",
"comment" : "\n Encode a sequence of binary data into its Base-64 stringified\n representation.\n Since 2.12\n Params:\n data = the binary data to encode\n len = the length of data\n Returns: a newly allocated, zero-terminated Base-64 encoded string representing data. The returned string must be freed with g_free().\n\t \n",
"line" : 139}
,
{
"name" : "decodeStep",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string inn, ulong len, char* f_out, ref int state, ref uint save)",
"comment" : "\n Incrementally decode a sequence of binary data from its Base-64 stringified\n representation. By calling this function multiple times you can convert\n data in chunks to avoid having to have the full encoded data in memory.\n The output buffer must be large enough to fit all the data that will\n be written to it. Since base64 encodes 3 bytes in 4 chars you need\n at least: (len \/ 4) * 3 + 3 bytes (+ 3 may be needed in case of non-zero\n state).\n Since 2.12\n Params:\n in = binary input data\n len = max length of in data to decode\n out = output buffer\n state = Saved state between steps, initialize to 0\n save = Saved state between steps, initialize to 0\n Returns: The number of bytes of output that was written\n\t \n",
"line" : 162}
,
{
"name" : "decode",
"kind" : "function",
"protection" : "public",
"type" : "char[](string text)",
"comment" : "\n Decode a sequence of Base-64 encoded text into binary data\n Since 2.12\n Params:\n text = zero-terminated string with base64 text to decode\n Returns: a newly allocated buffer containing the binary data that text represents. The returned buffer must be freed with g_free().\n\t \n",
"line" : 175}
,
{
"name" : "decodeInplace",
"kind" : "function",
"protection" : "public",
"type" : "char[](string text)",
"comment" : "\n Decode a sequence of Base-64 encoded text into binary data\n by overwriting the input data.\n Since 2.20\n Params:\n text = zero-terminated string with base64 text to decode\n Returns: The binary data that text responds. This pointer is the same as the input text.\n\t \n",
"line" : 191}
]
}
]
}
,
{
"name" : "glib.BBTree",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/BBTree.d",
"members" : [
{
"name" : "BBTree",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GTree structure and its associated functions provide a sorted\n collection of key\/value pairs optimized for searching and traversing\n in order.\n To create a new GTree use g_tree_new().\n To insert a key\/value pair into a GTree use g_tree_insert().\n To lookup the value corresponding to a given key, use\n g_tree_lookup() and g_tree_lookup_extended().\n To find out the number of nodes in a GTree, use g_tree_nnodes(). To\n get the height of a GTree, use g_tree_height().\n To traverse a GTree, calling a function for each node visited in\n the traversal, use g_tree_foreach().\n To remove a key\/value pair use g_tree_remove().\n To destroy a GTree, use g_tree_destroy().\n \n",
"line" : 81,
"base" : "Object",
"members" : [
{
"name" : "gTree",
"kind" : "variable",
"protection" : "protected",
"type" : "GTree*",
"comment" : " the main Gtk struct \n",
"line" : 84}
,
{
"name" : "getBBTreeStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTree*()",
"line" : 87}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 94}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BBTree(GTree* gTree)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 102}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BBTree(extern (C) int function(void*, void*) keyCompareFunc)",
"comment" : "\n\t \n\n Creates a new GTree.\n Params:\n keyCompareFunc = the function used to order the nodes in the GTree.\n  It should return values similar to the standard strcmp() function -\n  0 if the two arguments are equal, a negative value if the first argument\n  comes before the second, or a positive value if the first argument comes\n  after the second.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 125}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "BBTree()",
"comment" : "\n Increments the reference count of tree by one. It is safe to call\n this function from any thread.\n Since 2.22\n Returns: the passed in GTree.\n\t \n",
"line" : 142}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decrements the reference count of tree by one. If the reference count\n drops to 0, all keys and values will be destroyed (if destroy\n functions were specified) and all memory allocated by tree will be\n released.\n It is safe to call this function from any thread.\n Since 2.22\n\t \n",
"line" : 161}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BBTree(extern (C) int function(void*, void*, void*) keyCompareFunc, void* keyCompareData)",
"comment" : "\n Creates a new GTree with a comparison function that accepts user data.\n See g_tree_new() for more details.\n Params:\n keyCompareFunc = qsort()-style comparison function.\n keyCompareData = data to pass to comparison function.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 175}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BBTree(extern (C) int function(void*, void*, void*) keyCompareFunc, void* keyCompareData, extern (C) void function(void* cbData) keyDestroyFunc, extern (C) void function(void* cbData) valueDestroyFunc)",
"comment" : "\n Creates a new GTree like g_tree_new() and allows to specify functions\n to free the memory allocated for the key and value that get called when\n removing the entry from the GTree.\n Params:\n keyCompareFunc = qsort()-style comparison function.\n keyCompareData = data to pass to comparison function.\n keyDestroyFunc = a function to free the memory allocated for the key\n  used when removing the entry from the GTree or NULL if you don't\n  want to supply such a function.\n valueDestroyFunc = a function to free the memory allocated for the\n  value used when removing the entry from the GTree or NULL if you\n  don't want to supply such a function.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 201}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "void(void* key, void* value)",
"comment" : "\n Inserts a key\/value pair into a GTree. If the given key already exists\n in the GTree its corresponding value is set to the new value. If you\n supplied a value_destroy_func when creating the GTree, the old value is\n freed using that function. If you supplied a key_destroy_func when\n creating the GTree, the passed key is freed using that function.\n The tree is automatically 'balanced' as new key\/value pairs are added,\n so that the distance from the root to every leaf is as small as possible.\n Params:\n key = the key to insert.\n value = the value corresponding to the key.\n\t \n",
"line" : 224}
,
{
"name" : "replace",
"kind" : "function",
"protection" : "public",
"type" : "void(void* key, void* value)",
"comment" : "\n Inserts a new key and value into a GTree similar to g_tree_insert().\n The difference is that if the key already exists in the GTree, it gets\n replaced by the new key. If you supplied a value_destroy_func when\n creating the GTree, the old value is freed using that function. If you\n supplied a key_destroy_func when creating the GTree, the old key is\n freed using that function.\n The tree is automatically 'balanced' as new key\/value pairs are added,\n so that the distance from the root to every leaf is as small as possible.\n Params:\n key = the key to insert.\n value = the value corresponding to the key.\n\t \n",
"line" : 243}
,
{
"name" : "nnodes",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the number of nodes in a GTree.\n Returns: the number of nodes in the GTree.\n\t \n",
"line" : 253}
,
{
"name" : "height",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the height of a GTree.\n If the GTree contains no nodes, the height is 0.\n If the GTree contains only one root node the height is 1.\n If the root node has children the height is 2, etc.\n Returns: the height of the GTree.\n\t \n",
"line" : 266}
,
{
"name" : "lookup",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* key)",
"comment" : "\n Gets the value corresponding to the given key. Since a GTree is\n automatically balanced as key\/value pairs are added, key lookup is very\n fast.\n Params:\n key = the key to look up.\n Returns: the value corresponding to the key, or NULL if the key was not found.\n\t \n",
"line" : 280}
,
{
"name" : "lookupExtended",
"kind" : "function",
"protection" : "public",
"type" : "int(void* lookupKey, void** origKey, void** value)",
"comment" : "\n Looks up a key in the GTree, returning the original key and the\n associated value and a gboolean which is TRUE if the key was found. This\n is useful if you need to free the memory allocated for the original key,\n for example before calling g_tree_remove().\n Params:\n lookupKey = the key to look up.\n origKey = returns the original key.\n value = returns the value associated with the key.\n Returns: TRUE if the key was found in the GTree.\n\t \n",
"line" : 297}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each of the key\/value pairs in the GTree.\n The function is passed the key and value of each pair, and the given\n data parameter. The tree is traversed in sorted order.\n The tree may not be modified while iterating over it (you can't\n add\/remove items). To remove all items matching a predicate, you need\n to add each item to a list in your GTraverseFunc as you walk over\n the tree, then walk the list and remove each item.\n Params:\n func = the function to call for each node visited. If this function\n  returns TRUE, the traversal is stopped.\n userData = user data to pass to the function.\n\t \n",
"line" : 316}
,
{
"name" : "traverse",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) traverseFunc, GTraverseType traverseType, void* userData)",
"comment" : "\n Warning\n g_tree_traverse has been deprecated since version 2.2 and should not be used in newly-written code. The order of a balanced tree is somewhat arbitrary. If you\n just want to visit all nodes in sorted order, use g_tree_foreach()\n instead. If you really need to visit nodes in a different order, consider\n using an N-ary Tree.\n Calls the given function for each node in the GTree.\n Params:\n traverseFunc = the function to call for each node visited. If this\n  function returns TRUE, the traversal is stopped.\n traverseType = the order in which nodes are visited, one of G_IN_ORDER,\n  G_PRE_ORDER and G_POST_ORDER.\n userData = user data to pass to the function.\n\t \n",
"line" : 336}
,
{
"name" : "search",
"kind" : "function",
"protection" : "public",
"type" : "void*(extern (C) int function(void*, void*) searchFunc, void* userData)",
"comment" : "\n Searches a GTree using search_func.\n The search_func is called with a pointer to the key of a key\/value pair in\n the tree, and the passed in user_data. If search_func returns 0 for a\n key\/value pair, then g_tree_search_func() will return the value of that\n pair. If search_func returns -1, searching will proceed among the\n key\/value pairs that have a smaller key; if search_func returns 1,\n searching will proceed among the key\/value pairs that have a larger key.\n Params:\n searchFunc = a function used to search the GTree.\n userData = the data passed as the second argument to the search_func\n function.\n Returns: the value corresponding to the found key, or NULL if the key was not found.\n\t \n",
"line" : 356}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "int(void* key)",
"comment" : "\n Removes a key\/value pair from a GTree.\n If the GTree was created using g_tree_new_full(), the key and value\n are freed using the supplied destroy functions, otherwise you have to\n make sure that any dynamically allocated values are freed yourself.\n If the key does not exist in the GTree, the function does nothing.\n Params:\n key = the key to remove.\n Returns: TRUE if the key was found (prior to 2.8, this function returned nothing)\n\t \n",
"line" : 372}
,
{
"name" : "steal",
"kind" : "function",
"protection" : "public",
"type" : "int(void* key)",
"comment" : "\n Removes a key and its associated value from a GTree without calling\n the key and value destroy functions.\n If the key does not exist in the GTree, the function does nothing.\n Params:\n key = the key to remove.\n Returns: TRUE if the key was found (prior to 2.8, this function returned nothing)\n\t \n",
"line" : 386}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes all keys and values from the GTree and decreases its\n reference count by one. If keys and\/or values are dynamically\n allocated, you should either free them first or create the GTree\n using g_tree_new_full(). In the latter case the destroy functions\n you supplied will be called on all keys and values before destroying\n the GTree.\n\t \n",
"line" : 400}
]
}
]
}
,
{
"name" : "glib.BookmarkFile",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/BookmarkFile.d",
"members" : [
{
"name" : "BookmarkFile",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GBookmarkFile lets you parse, edit or create files containing bookmarks\n to URI, along with some meta-data about the resource pointed by the URI\n like its MIME type, the application that is registering the bookmark and\n the icon that should be used to represent the bookmark. The data is stored\n using the\n Desktop Bookmark\n Specification.\n The syntax of the bookmark files is described in detail inside the Desktop\n Bookmark Specification, here is a quick summary: bookmark files use a\n sub-class of the XML Bookmark Exchange Language\n specification, consisting of valid UTF-8 encoded XML, under the\n xbel root element; each bookmark is stored inside a\n bookmark element, using its URI: no relative paths can\n be used inside a bookmark file. The bookmark may have a user defined title\n and description, to be used instead of the URI. Under the\n metadata element, with its owner\n attribute set to http:\/\/freedesktop.org, is stored the\n meta-data about a resource pointed by its URI. The meta-data consists of\n the resource's MIME type; the applications that have registered a bookmark;\n the groups to which a bookmark belongs to; a visibility flag, used to set\n the bookmark as \"private\" to the applications and groups that has it\n registered; the URI and MIME type of an icon, to be used when displaying\n the bookmark inside a GUI.\n $(DDOC_COMMENT example)\n A bookmark file might contain more than one bookmark; each bookmark\n is accessed through its URI.\n The important caveat of bookmark files is that when you add a new\n bookmark you must also add the application that is registering it, using\n g_bookmark_file_add_application() or g_bookmark_file_set_app_info().\n If a bookmark has no applications then it won't be dumped when creating\n the on disk representation, using g_bookmark_file_to_data() or\n g_bookmark_file_to_file().\n The GBookmarkFile parser was added in GLib 2.12.\n \n",
"line" : 107,
"base" : "Object",
"members" : [
{
"name" : "gBookmarkFile",
"kind" : "variable",
"protection" : "protected",
"type" : "GBookmarkFile*",
"comment" : " the main Gtk struct \n",
"line" : 110}
,
{
"name" : "getBookmarkFileStruct",
"kind" : "function",
"protection" : "public",
"type" : "GBookmarkFile*()",
"line" : 113}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 120}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BookmarkFile(GBookmarkFile* gBookmarkFile)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 128}
,
{
"name" : "setGroups",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string[] groups, uint length)",
"comment" : "\n Sets a list of group names for the item with URI uri. Each previously\n set group name list is removed.\n If uri cannot be found then an item for it is created.\n Since 2.12\n Params:\n uri =  an item's URI\n groups =  an array of group names, or NULL to remove all groups\n length =  number of group name values in groups\n\t \n",
"line" : 148}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "BookmarkFile()",
"comment" : "\n\t \n\n Creates a new empty GBookmarkFile object.\n Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()\n or g_bookmark_file_load_from_data_dirs() to read an existing bookmark\n file.\n Since 2.12\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 165}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a GBookmarkFile.\n Since 2.12\n\t \n",
"line" : 180}
,
{
"name" : "loadFromFile",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename)",
"comment" : "\n Loads a desktop bookmark file into an empty GBookmarkFile structure.\n If the file could not be loaded then error is set to either a GFileError\n or GBookmarkFileError.\n Since 2.12\n Params:\n filename = the path of a filename to load, in the GLib file name encoding\n Returns: TRUE if a desktop bookmark file could be loaded\n Throws: GException on failure.\n\t \n",
"line" : 196}
,
{
"name" : "loadFromData",
"kind" : "function",
"protection" : "public",
"type" : "int(string data, ulong length)",
"comment" : "\n Loads a bookmark file from memory into an empty GBookmarkFile\n structure. If the object cannot be created then error is set to a\n GBookmarkFileError.\n Since 2.12\n Params:\n data = desktop bookmarks loaded in memory\n length = the length of data in bytes\n Returns: TRUE if a desktop bookmark could be loaded.\n Throws: GException on failure.\n\t \n",
"line" : 222}
,
{
"name" : "loadFromDataDirs",
"kind" : "function",
"protection" : "public",
"type" : "int(string file, out string fullPath)",
"comment" : "\n This function looks for a desktop bookmark file named file in the\n paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),\n loads the file into bookmark and returns the file's full path in\n full_path. If the file could not be loaded then an error is\n set to either a GFileError or GBookmarkFileError.\n Since 2.12\n Params:\n file = a relative path to a filename to open and parse\n fullPath = return location for a string containing the full path\n  of the file, or NULL\n Returns: TRUE if a key file could be loaded, FALSE othewise\n Throws: GException on failure.\n\t \n",
"line" : 251}
,
{
"name" : "toData",
"kind" : "function",
"protection" : "public",
"type" : "string(out ulong length)",
"comment" : "\n This function outputs bookmark as a string.\n Since 2.12\n Params:\n length = return location for the length of the returned string, or NULL\n Returns: a newly allocated string holding the contents of the GBookmarkFile\n Throws: GException on failure.\n\t \n",
"line" : 276}
,
{
"name" : "toFile",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename)",
"comment" : "\n This function outputs bookmark into a file. The write process is\n guaranteed to be atomic by using g_file_set_contents() internally.\n Since 2.12\n Params:\n filename = path of the output file\n Returns: TRUE if the file was successfully written.\n Throws: GException on failure.\n\t \n",
"line" : 300}
,
{
"name" : "hasItem",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri)",
"comment" : "\n Looks whether the desktop bookmark has an item with its URI set to uri.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: TRUE if uri is inside bookmark, FALSE otherwise\n\t \n",
"line" : 322}
,
{
"name" : "hasGroup",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, string group)",
"comment" : "\n Checks whether group appears in the list of groups to which\n the bookmark for uri belongs to.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n group = the group name to be searched\n Returns: TRUE if group was found.\n Throws: GException on failure.\n\t \n",
"line" : 340}
,
{
"name" : "hasApplication",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, string name)",
"comment" : "\n Checks whether the bookmark for uri inside bookmark has been\n registered by application name.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n name = the name of the application\n Returns: TRUE if the application name was found\n Throws: GException on failure.\n\t \n",
"line" : 367}
,
{
"name" : "getSize",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the number of bookmarks inside bookmark.\n Since 2.12\n Returns: the number of bookmarks\n\t \n",
"line" : 387}
,
{
"name" : "getUris",
"kind" : "function",
"protection" : "public",
"type" : "string[](out ulong length)",
"comment" : "\n Returns all URIs of the bookmarks in the bookmark file bookmark.\n The array of returned URIs will be NULL-terminated, so length may\n optionally be NULL.\n Since 2.12\n Params:\n length = return location for the number of returned URIs, or NULL\n Returns: a newly allocated NULL-terminated array of strings. Use g_strfreev() to free it.\n\t \n",
"line" : 402}
,
{
"name" : "getTitle",
"kind" : "function",
"protection" : "public",
"type" : "string(string uri)",
"comment" : "\n Returns the title of the bookmark for uri.\n If uri is NULL, the title of bookmark is returned.\n In the event the URI cannot be found, NULL is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI or NULL\n Returns: a newly allocated string or NULL if the specified URI cannot be found.\n Throws: GException on failure.\n\t \n",
"line" : 419}
,
{
"name" : "getDescription",
"kind" : "function",
"protection" : "public",
"type" : "string(string uri)",
"comment" : "\n Retrieves the description of the bookmark for uri.\n In the event the URI cannot be found, NULL is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: a newly allocated string or NULL if the specified URI cannot be found.\n Throws: GException on failure.\n\t \n",
"line" : 444}
,
{
"name" : "getMimeType",
"kind" : "function",
"protection" : "public",
"type" : "string(string uri)",
"comment" : "\n Retrieves the MIME type of the resource pointed by uri.\n In the event the URI cannot be found, NULL is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the\n event that the MIME type cannot be found, NULL is returned and\n error is set to G_BOOKMARK_FILE_ERROR_INVALID_VALUE.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: a newly allocated string or NULL if the specified URI cannot be found.\n Throws: GException on failure.\n\t \n",
"line" : 471}
,
{
"name" : "getIsPrivate",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri)",
"comment" : "\n Gets whether the private flag of the bookmark for uri is set.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the\n event that the private flag cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_INVALID_VALUE.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: TRUE if the private flag is set, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 498}
,
{
"name" : "getIcon",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, out string href, out string mimeType)",
"comment" : "\n Gets the icon of the bookmark for uri.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n href = return location for the icon's location or NULL\n mimeType = return location for the icon's MIME type or NULL\n Returns: TRUE if the icon for the bookmark for the URI was found. You should free the returned strings.\n Throws: GException on failure.\n\t \n",
"line" : 525}
,
{
"name" : "getAdded",
"kind" : "function",
"protection" : "public",
"type" : "uint(string uri)",
"comment" : "\n Gets the time the bookmark for uri was added to bookmark\n In the event the URI cannot be found, -1 is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: a timestamp\n Throws: GException on failure.\n\t \n",
"line" : 554}
,
{
"name" : "getModified",
"kind" : "function",
"protection" : "public",
"type" : "uint(string uri)",
"comment" : "\n Gets the time when the bookmark for uri was last modified.\n In the event the URI cannot be found, -1 is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: a timestamp\n Throws: GException on failure.\n\t \n",
"line" : 579}
,
{
"name" : "getVisited",
"kind" : "function",
"protection" : "public",
"type" : "uint(string uri)",
"comment" : "\n Gets the time the bookmark for uri was last visited.\n In the event the URI cannot be found, -1 is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: a timestamp.\n Throws: GException on failure.\n\t \n",
"line" : 604}
,
{
"name" : "getGroups",
"kind" : "function",
"protection" : "public",
"type" : "string[](string uri, out ulong length)",
"comment" : "\n Retrieves the list of group names of the bookmark for uri.\n In the event the URI cannot be found, NULL is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n The returned array is NULL terminated, so length may optionally\n be NULL.\n Since 2.12\n Params:\n uri = a valid URI\n length = return location for the length of the returned string, or NULL\n Returns: a newly allocated NULL-terminated array of group names. Use g_strfreev() to free it.\n Throws: GException on failure.\n\t \n",
"line" : 632}
,
{
"name" : "getApplications",
"kind" : "function",
"protection" : "public",
"type" : "string[](string uri, out ulong length)",
"comment" : "\n Retrieves the names of the applications that have registered the\n bookmark for uri.\n In the event the URI cannot be found, NULL is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n uri = a valid URI\n length = return location of the length of the returned list, or NULL\n Returns: a newly allocated NULL-terminated array of strings. Use g_strfreev() to free it.\n Throws: GException on failure.\n\t \n",
"line" : 659}
,
{
"name" : "getAppInfo",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, string name, out string exec, out uint count, out uint stamp)",
"comment" : "\n Gets the registration informations of app_name for the bookmark for\n uri. See g_bookmark_file_set_app_info() for more informations about\n the returned data.\n The string returned in app_exec must be freed.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND. In the\n event that no application with name app_name has registered a bookmark\n for uri, FALSE is returned and error is set to\n G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting\n the command line fails, an error of the G_SHELL_ERROR domain is\n set and FALSE is returned.\n Since 2.12\n Params:\n uri = a valid URI\n name = an application's name\n exec = location for the command line of the application, or NULL\n count = return location for the registration count, or NULL\n stamp = return location for the last registration time, or NULL\n Returns: TRUE on success.\n Throws: GException on failure.\n\t \n",
"line" : 696}
,
{
"name" : "setTitle",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string title)",
"comment" : "\n Sets title as the title of the bookmark for uri inside the\n bookmark file bookmark.\n If uri is NULL, the title of bookmark is set.\n If a bookmark for uri cannot be found then it is created.\n Since 2.12\n Params:\n uri = a valid URI or NULL\n title = a UTF-8 encoded string\n\t \n",
"line" : 723}
,
{
"name" : "setDescription",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string description)",
"comment" : "\n Sets description as the description of the bookmark for uri.\n If uri is NULL, the description of bookmark is set.\n If a bookmark for uri cannot be found then it is created.\n Since 2.12\n Params:\n uri = a valid URI or NULL\n description = a string\n\t \n",
"line" : 738}
,
{
"name" : "setMimeType",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string mimeType)",
"comment" : "\n Sets mime_type as the MIME type of the bookmark for uri.\n If a bookmark for uri cannot be found then it is created.\n Since 2.12\n Params:\n uri = a valid URI\n mimeType = a MIME type\n\t \n",
"line" : 752}
,
{
"name" : "setIsPrivate",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, int isPrivate)",
"comment" : "\n Sets the private flag of the bookmark for uri.\n If a bookmark for uri cannot be found then it is created.\n Since 2.12\n Params:\n uri = a valid URI\n isPrivate = TRUE if the bookmark should be marked as private\n\t \n",
"line" : 766}
,
{
"name" : "setIcon",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string href, string mimeType)",
"comment" : "\n Sets the icon for the bookmark for uri. If href is NULL, unsets\n the currently set icon. href can either be a full URL for the icon\n file or the icon name following the Icon Naming specification.\n If no bookmark for uri is found one is created.\n Since 2.12\n Params:\n uri = a valid URI\n href = the URI of the icon for the bookmark, or NULL\n mimeType = the MIME type of the icon for the bookmark\n\t \n",
"line" : 783}
,
{
"name" : "setAdded",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, uint added)",
"comment" : "\n Sets the time the bookmark for uri was added into bookmark.\n If no bookmark for uri is found then it is created.\n Since 2.12\n Params:\n uri = a valid URI\n added = a timestamp or -1 to use the current time\n\t \n",
"line" : 797}
,
{
"name" : "setModified",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, uint modified)",
"comment" : "\n Sets the last time the bookmark for uri was last modified.\n If no bookmark for uri is found then it is created.\n The \"modified\" time should only be set when the bookmark's meta-data\n was actually changed. Every function of GBookmarkFile that\n modifies a bookmark also changes the modification time, except for\n g_bookmark_file_set_visited().\n Since 2.12\n Params:\n uri = a valid URI\n modified = a timestamp or -1 to use the current time\n\t \n",
"line" : 815}
,
{
"name" : "setVisited",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, uint visited)",
"comment" : "\n Sets the time the bookmark for uri was last visited.\n If no bookmark for uri is found then it is created.\n The \"visited\" time should only be set if the bookmark was launched,\n either using the command line retrieved by g_bookmark_file_get_app_info()\n or by the default application for the bookmark's MIME type, retrieved\n using g_bookmark_file_get_mime_type(). Changing the \"visited\" time\n does not affect the \"modified\" time.\n Since 2.12\n Params:\n uri = a valid URI\n visited = a timestamp or -1 to use the current time\n\t \n",
"line" : 834}
,
{
"name" : "setAppInfo",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, string name, string exec, int count, uint stamp)",
"comment" : "\n Sets the meta-data of application name inside the list of\n applications that have registered a bookmark for uri inside\n bookmark.\n You should rarely use this function; use g_bookmark_file_add_application()\n and g_bookmark_file_remove_application() instead.\n name can be any UTF-8 encoded string used to identify an\n application.\n exec can have one of these two modifiers: \"f\", which will\n be expanded as the local file name retrieved from the bookmark's\n URI; \"u\", which will be expanded as the bookmark's URI.\n The expansion is done automatically when retrieving the stored\n command line using the g_bookmark_file_get_app_info() function.\n count is the number of times the application has registered the\n bookmark; if is < 0, the current registration count will be increased\n by one, if is 0, the application with name will be removed from\n the list of registered applications.\n stamp is the Unix time of the last registration; if it is -1, the\n current time will be used.\n If you try to remove an application by setting its registration count to\n zero, and no bookmark for uri is found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,\n in the event that no application name has registered a bookmark\n for uri, FALSE is returned and error is set to\n G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. Otherwise, if no bookmark\n for uri is found, one is created.\n Since 2.12\n Params:\n uri = a valid URI\n name = an application's name\n exec = an application's command line\n count = the number of registrations done for this application\n stamp = the time of the last registration for this application\n Returns: TRUE if the application's meta-data was successfully changed.\n Throws: GException on failure.\n\t \n",
"line" : 876}
,
{
"name" : "addGroup",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string group)",
"comment" : "\n Adds group to the list of groups to which the bookmark for uri\n belongs to.\n If no bookmark for uri is found then it is created.\n Since 2.12\n Params:\n uri = a valid URI\n group = the group name to be added\n\t \n",
"line" : 900}
,
{
"name" : "addApplication",
"kind" : "function",
"protection" : "public",
"type" : "void(string uri, string name, string exec)",
"comment" : "\n Adds the application with name and exec to the list of\n applications that have registered a bookmark for uri into\n bookmark.\n Every bookmark inside a GBookmarkFile must have at least an\n application registered. Each application must provide a name, a\n command line useful for launching the bookmark, the number of times\n the bookmark has been registered by the application and the last\n time the application registered this bookmark.\n If name is NULL, the name of the application will be the\n same returned by g_get_application_name(); if exec is NULL, the\n command line will be a composition of the program name as\n returned by g_get_prgname() and the \"u\" modifier, which will be\n expanded to the bookmark's URI.\n This function will automatically take care of updating the\n registrations count and timestamping in case an application\n with the same name had already registered a bookmark for\n uri inside bookmark.\n If no bookmark for uri is found, one is created.\n Since 2.12\n Params:\n uri = a valid URI\n name = the name of the application registering the bookmark\n  or NULL\n exec = command line to be used to launch the bookmark or NULL\n\t \n",
"line" : 932}
,
{
"name" : "removeGroup",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, string group)",
"comment" : "\n Removes group from the list of groups to which the bookmark\n for uri belongs to.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n In the event no group was defined, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_INVALID_VALUE.\n Since 2.12\n Params:\n uri = a valid URI\n group = the group name to be removed\n Returns: TRUE if group was successfully removed.\n Throws: GException on failure.\n\t \n",
"line" : 952}
,
{
"name" : "removeApplication",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri, string name)",
"comment" : "\n Removes application registered with name from the list of applications\n that have registered a bookmark for uri inside bookmark.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n In the event that no application with name app_name has registered\n a bookmark for uri, FALSE is returned and error is set to\n G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.\n Since 2.12\n Params:\n uri = a valid URI\n name = the name of the application\n Returns: TRUE if the application was successfully removed.\n Throws: GException on failure.\n\t \n",
"line" : 982}
,
{
"name" : "removeItem",
"kind" : "function",
"protection" : "public",
"type" : "int(string uri)",
"comment" : "\n Removes the bookmark for uri from the bookmark file bookmark.\n Since 2.12\n Params:\n uri = a valid URI\n Returns: TRUE if the bookmark was removed successfully.\n Throws: GException on failure.\n\t \n",
"line" : 1005}
,
{
"name" : "moveItem",
"kind" : "function",
"protection" : "public",
"type" : "int(string oldUri, string newUri)",
"comment" : "\n Changes the URI of a bookmark item from old_uri to new_uri. Any\n existing bookmark for new_uri will be overwritten. If new_uri is\n NULL, then the bookmark is removed.\n In the event the URI cannot be found, FALSE is returned and\n error is set to G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.\n Since 2.12\n Params:\n oldUri = a valid URI\n newUri = a valid URI, or NULL\n Returns: TRUE if the URI was successfully changed\n Throws: GException on failure.\n\t \n",
"line" : 1033}
]
}
]
}
,
{
"name" : "glib.ByteArray",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ByteArray.d",
"members" : [
{
"name" : "ByteArray",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GByteArray is based on GArray, to provide arrays of bytes which\n grow automatically as elements are added.\n To create a new GByteArray use g_byte_array_new().\n To add elements to a GByteArray, use g_byte_array_append(), and\n g_byte_array_prepend().\n To set the size of a GByteArray, use g_byte_array_set_size().\n To free a GByteArray, use g_byte_array_free().\n $(DDOC_COMMENT example)\n \n",
"line" : 76,
"base" : "Object",
"members" : [
{
"name" : "gByteArray",
"kind" : "variable",
"protection" : "protected",
"type" : "GByteArray*",
"comment" : " the main Gtk struct \n",
"line" : 79}
,
{
"name" : "getByteArrayStruct",
"kind" : "function",
"protection" : "public",
"type" : "GByteArray*()",
"line" : 82}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 89}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ByteArray(GByteArray* gByteArray)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 97}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ByteArray()",
"comment" : "\n\t \n\n Creates a new GByteArray with a reference count of 1.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 114}
,
{
"name" : "sizedNew",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(uint reservedSize)",
"comment" : "\n Creates a new GByteArray with reserved_size bytes preallocated.\n This avoids frequent reallocation, if you are going to add many\n bytes to the array. Note however that the size of the array is still\n 0.\n Params:\n reservedSize = number of bytes preallocated.\n Returns: the new GByteArray.\n\t \n",
"line" : 134}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray()",
"comment" : "\n Atomically increments the reference count of array by one. This\n function is MT-safe and may be called from any thread.\n Since 2.22\n Returns: The passed in GByteArray.\n\t \n",
"line" : 151}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Atomically decrements the reference count of array by one. If the\n reference count drops to 0, all memory allocated by the array is\n released. This function is MT-safe and may be called from any\n thread.\n Since 2.22\n\t \n",
"line" : 169}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(ubyte[] data)",
"comment" : "\n Adds the given bytes to the end of the GByteArray. The array will\n grow in size automatically if necessary.\n Params:\n data = the byte data to be added.\n Returns: the GByteArray.\n\t \n",
"line" : 182}
,
{
"name" : "prepend",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(ubyte[] data)",
"comment" : "\n Adds the given data to the start of the GByteArray. The array will\n grow in size automatically if necessary.\n Params:\n data = the byte data to be added.\n Returns: the GByteArray.\n\t \n",
"line" : 200}
,
{
"name" : "removeIndex",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(uint index)",
"comment" : "\n Removes the byte at the given index from a GByteArray. The\n following bytes are moved down one place.\n Params:\n index = the index of the byte to remove.\n Returns: the GByteArray.\n\t \n",
"line" : 218}
,
{
"name" : "removeIndexFast",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(uint index)",
"comment" : "\n Removes the byte at the given index from a GByteArray. The last\n element in the array is used to fill in the space, so this function\n does not preserve the order of the GByteArray. But it is faster\n than g_byte_array_remove_index().\n Params:\n index = the index of the byte to remove.\n Returns: the GByteArray.\n\t \n",
"line" : 238}
,
{
"name" : "removeRange",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(uint index, uint length)",
"comment" : "\n Removes the given number of bytes starting at the given index from a\n GByteArray. The following elements are moved to close the gap.\n Since 2.4\n Params:\n index = the index of the first byte to remove.\n length = the number of bytes to remove.\n Returns: the GByteArray.\n\t \n",
"line" : 258}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*) compareFunc)",
"comment" : "\n Sorts a byte array, using compare_func which should be a\n qsort()-style comparison function (returns less than zero for first\n arg is less than second arg, zero for equal, greater than zero if\n first arg is greater than second arg).\n If two array elements compare equal, their order in the sorted array\n is undefined.\n Params:\n compareFunc = comparison function.\n\t \n",
"line" : 279}
,
{
"name" : "sortWithData",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n Like g_byte_array_sort(), but the comparison function takes an extra\n user data argument.\n Params:\n compareFunc = comparison function.\n userData = data to pass to compare_func.\n\t \n",
"line" : 292}
,
{
"name" : "setSize",
"kind" : "function",
"protection" : "public",
"type" : "ByteArray(uint length)",
"comment" : "\n Sets the size of the GByteArray, expanding it if necessary.\n Params:\n length = the new size of the GByteArray.\n Returns: the GByteArray.\n\t \n",
"line" : 304}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "ubyte*(int freeSegment)",
"comment" : "\n Frees the memory allocated by the GByteArray. If free_segment is\n TRUE it frees the actual byte data. If the reference count of\n array is greater than one, the GByteArray wrapper is preserved but\n the size of array will be set to zero.\n Params:\n freeSegment = if TRUE the actual byte data is freed as well.\n Returns: the element data if free_segment is FALSE, otherwise NULL. The element data should be freed using g_free().\n\t \n",
"line" : 324}
]
}
]
}
,
{
"name" : "glib.Cache",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Cache.d",
"members" : [
{
"name" : "Cache",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GCache allows sharing of complex data structures, in order to\n save system resources.\n GTK+ uses caches for GtkStyles and GdkGCs. These consume a lot of\n resources, so a GCache is used to see if a GtkStyle or GdkGC with\n the required properties already exists. If it does, then the\n existing object is used instead of creating a new one.\n GCache uses keys and values. A GCache key describes the properties\n of a particular resource. A GCache value is the actual resource.\n \n",
"line" : 75,
"base" : "Object",
"members" : [
{
"name" : "gCache",
"kind" : "variable",
"protection" : "protected",
"type" : "GCache*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getCacheStruct",
"kind" : "function",
"protection" : "public",
"type" : "GCache*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Cache(GCache* gCache)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Cache(extern (C) void* function(void*) valueNewFunc, extern (C) void function(void* cbData) valueDestroyFunc, extern (C) void* function(void*) keyDupFunc, extern (C) void function(void* cbData) keyDestroyFunc, extern (C) uint function(void*) hashKeyFunc, extern (C) uint function(void*) hashValueFunc, extern (C) int function(void*, void*) keyEqualFunc)",
"comment" : "\n\t \n\n Creates a new GCache.\n Params:\n valueNewFunc = a function to create a new object given a key.\n  This is called by g_cache_insert() if an object\n  with the given key does not already exist.\n valueDestroyFunc = a function to destroy an object. It is called\n  by g_cache_remove() when the object is no\n  longer needed (i.e. its reference count drops\n  to 0).\n keyDupFunc = a function to copy a key. It is called by\n  g_cache_insert() if the key does not already exist in\n  the GCache.\n keyDestroyFunc = a function to destroy a key. It is called by\n  g_cache_remove() when the object is no longer\n  needed (i.e. its reference count drops to 0).\n hashKeyFunc = a function to create a hash value from a key.\n hashValueFunc = a function to create a hash value from a value.\n keyEqualFunc = a function to compare two keys. It should return\n  TRUE if the two keys are equivalent.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 131}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* key)",
"comment" : "\n Gets the value corresponding to the given key, creating it if\n necessary. It first checks if the value already exists in the\n GCache, by using the key_equal_func function passed to\n g_cache_new(). If it does already exist it is returned, and its\n reference count is increased by one. If the value does not currently\n exist, if is created by calling the value_new_func. The key is\n duplicated by calling key_dup_func and the duplicated key and value\n are inserted into the GCache.\n Params:\n key = a key describing a GCache object.\n Returns: a pointer to a GCache value.\n\t \n",
"line" : 155}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(void* value)",
"comment" : "\n Decreases the reference count of the given value. If it drops to 0\n then the value and its corresponding key are destroyed, using the\n value_destroy_func and key_destroy_func passed to g_cache_new().\n Params:\n value = the value to remove.\n\t \n",
"line" : 168}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees the memory allocated for the GCache.\n Note that it does not destroy the keys and values which were\n contained in the GCache.\n\t \n",
"line" : 179}
,
{
"name" : "keyForeach",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each of the keys in the GCache.\n NOTE func is passed three parameters, the value and key of a cache\n entry and the user_data. The order of value and key is different\n from the order in which g_hash_table_foreach() passes key-value\n pairs to its callback function !\n Params:\n func = the function to call with each GCache key.\n userData = user data to pass to the function.\n\t \n",
"line" : 195}
,
{
"name" : "valueForeach",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*, void*) func, void* userData)",
"comment" : "\n Warning\n g_cache_value_foreach has been deprecated since version 2.10 and should not be used in newly-written code. The reason is that it passes pointers to internal\n  data structures to func; use g_cache_key_foreach()\n  instead\n Calls the given function for each of the values in the GCache.\n Params:\n func = the function to call with each GCache value.\n userData = user data to pass to the function.\n\t \n",
"line" : 211}
]
}
]
}
,
{
"name" : "glib.CharacterSet",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/CharacterSet.d",
"members" : [
{
"name" : "CharacterSet",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The g_convert() family of function wraps the functionality of iconv(). In\n addition to pure character set conversions, GLib has functions to deal\n with the extra complications of encodings for file names.\n File Name Encodings\n Historically, Unix has not had a defined encoding for file\n names: a file name is valid as long as it does not have path\n separators in it (\"\/\"). However, displaying file names may\n require conversion: from the character set in which they were\n created, to the character set in which the application\n operates. Consider the Spanish file name\n \"Presentación.sxi\". If the\n application which created it uses ISO-8859-1 for its encoding,\n Character: P r e s e n t a c i ó n . s x i\n Hex code: 50 72 65 73 65 6e 74 61 63 69 f3 6e 2e 73 78 69\n However, if the application use UTF-8, the actual file name on\n disk would look like this:\n Character: P r e s e n t a c i ó n . s x i\n Hex code: 50 72 65 73 65 6e 74 61 63 69 c3 b3 6e 2e 73 78 69\n Glib uses UTF-8 for its strings, and GUI toolkits like GTK+\n that use Glib do the same thing. If you get a file name from\n the file system, for example, from readdir(3) or from g_dir_read_name(),\n and you wish to display the file name to the user, you\n will need to convert it into UTF-8. The\n opposite case is when the user types the name of a file he\n wishes to save: the toolkit will give you that string in\n UTF-8 encoding, and you will need to convert it to the\n character set used for file names before you can create the\n file with open(2) or fopen(3).\n By default, Glib assumes that file names on disk are in UTF-8\n encoding. This is a valid assumption for file systems which\n were created relatively recently: most applications use UTF-8\n encoding for their strings, and that is also what they use for\n the file names they create. However, older file systems may\n still contain file names created in \"older\" encodings, such as\n ISO-8859-1. In this case, for compatibility reasons, you may\n want to instruct Glib to use that particular encoding for file\n names rather than UTF-8. You can do this by specifying the\n encoding for file names in the G_FILENAME_ENCODING\n environment variable. For example, if your installation uses\n ISO-8859-1 for file names, you can put this in your\n ~\/.profile:\n export G_FILENAME_ENCODING=ISO-8859-1\n Glib provides the functions g_filename_to_utf8() and\n g_filename_from_utf8() to perform the necessary conversions. These\n functions convert file names from the encoding specified in\n G_FILENAME_ENCODING to UTF-8 and vice-versa.\n  Figure  2, “Conversion between File Name Encodings” illustrates how\n these functions are used to convert between UTF-8 and the\n encoding for file names in the file system.\n Figure  2.  Conversion between File Name Encodings\n Checklist for Application Writers\n This section is a practical summary of the detailed\n description above. You can use this as a checklist of\n things to do to make sure your applications process file\n name encodings correctly.\n If you get a file name from the file system from a function\n such as readdir(3) or gtk_file_chooser_get_filename(),\n you do not need to do any conversion to pass that\n file name to functions like open(2), rename(2), or\n fopen(3) — those are \"raw\" file names which the file\n system understands.\n If you need to display a file name, convert it to UTF-8 first by\n using g_filename_to_utf8(). If conversion fails, display a string like\n \"Unknown file name\". Do not\n convert this string back into the encoding used for file names if you\n wish to pass it to the file system; use the original file name instead.\n For example, the document window of a word processor could display\n \"Unknown file name\" in its title bar but still let the user save the\n file, as it would keep the raw file name internally. This can happen\n if the user has not set the G_FILENAME_ENCODING\n environment variable even though he has files whose names are not\n encoded in UTF-8.\n If your user interface lets the user type a file name for saving or\n renaming, convert it to the encoding used for file names in the file\n system by using g_filename_from_utf8(). Pass the converted file name\n to functions like fopen(3). If conversion fails, ask the user to enter\n a different file name. This can happen if the user types Japanese\n characters when G_FILENAME_ENCODING is set to\n ISO-8859-1, for example.\n \n",
"line" : 156,
"base" : "Object",
"members" : [
{
"name" : "convert",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len, string toCodeset, string fromCodeset, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n\t \n\n Converts a string from one character set to another.\n Note that you should use g_iconv() for streaming\n conversions[2].\n Params:\n str = the string to convert\n len = the length of the string, or -1 if the string is\n  nul-terminated[1].\n toCodeset = name of character set into which to convert str\n fromCodeset = character set of str.\n bytesRead = location to store the number of bytes in the\n  input string that were successfully converted, or NULL.\n  Even if the conversion was successful, this may be\n  less than len if there were partial characters\n  at the end of the input. If the error\n  G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value\n  stored will the byte offset after the last valid\n  input sequence.\n bytesWritten = the number of bytes stored in the output buffer (not\n  including the terminating nul).\n Returns: If the conversion was successful, a newly allocated nul-terminated string, which must be freed with g_free(). Otherwise NULL and error will be set.\n Throws: GException on failure.\n\t \n",
"line" : 184}
,
{
"name" : "convertWithFallback",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len, string toCodeset, string fromCodeset, string fallback, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n Converts a string from one character set to another, possibly\n including fallback sequences for characters not representable\n in the output. Note that it is not guaranteed that the specification\n for the fallback sequences in fallback will be honored. Some\n systems may do an approximate conversion from from_codeset\n to to_codeset in their iconv() functions,\n in which case GLib will simply return that approximate conversion.\n Note that you should use g_iconv() for streaming\n conversions[2].\n Params:\n str = the string to convert\n len = the length of the string, or -1 if the string is\n  nul-terminated[1].\n toCodeset = name of character set into which to convert str\n fromCodeset = character set of str.\n fallback = UTF-8 string to use in place of character not\n  present in the target encoding. (The string must be\n  representable in the target encoding).\n  If NULL, characters not in the target encoding will\n  be represented as Unicode escapes \\uxxxx or \\Uxxxxyyyy.\n bytesRead = location to store the number of bytes in the\n  input string that were successfully converted, or NULL.\n  Even if the conversion was successful, this may be\n  less than len if there were partial characters\n  at the end of the input.\n bytesWritten = the number of bytes stored in the output buffer (not\n  including the terminating nul).\n Returns: If the conversion was successful, a newly allocated nul-terminated string, which must be freed with g_free(). Otherwise NULL and error will be set.\n Throws: GException on failure.\n\t \n",
"line" : 230}
,
{
"name" : "localeToUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(string opsysstring, long len, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n Converts a string which is in the encoding used for strings by\n the C runtime (usually the same as that used by the operating\n system) in the current locale into a\n UTF-8 string.\n Params:\n opsysstring = a string in the encoding of the current locale. On Windows\n  this means the system codepage.\n len = the length of the string, or -1 if the string is\n  nul-terminated[1].\n bytesRead = location to store the number of bytes in the\n  input string that were successfully converted, or NULL.\n  Even if the conversion was successful, this may be\n  less than len if there were partial characters\n  at the end of the input. If the error\n  G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value\n  stored will the byte offset after the last valid\n  input sequence.\n bytesWritten = the number of bytes stored in the output buffer (not\n  including the terminating nul).\n Returns: The converted string, or NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 268}
,
{
"name" : "filenameToUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(string opsysstring, long len, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n Converts a string which is in the encoding used by GLib for\n filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8\n for filenames; on other platforms, this function indirectly depends on\n the current locale.\n Params:\n opsysstring = a string in the encoding for filenames\n len = the length of the string, or -1 if the string is\n  nul-terminated[1].\n bytesRead = location to store the number of bytes in the\n  input string that were successfully converted, or NULL.\n  Even if the conversion was successful, this may be\n  less than len if there were partial characters\n  at the end of the input. If the error\n  G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value\n  stored will the byte offset after the last valid\n  input sequence.\n bytesWritten = the number of bytes stored in the output buffer (not\n  including the terminating nul).\n Returns: The converted string, or NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 305}
,
{
"name" : "filenameFromUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(string utf8string, long len, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n Converts a string from UTF-8 to the encoding GLib uses for\n filenames. Note that on Windows GLib uses UTF-8 for filenames;\n on other platforms, this function indirectly depends on the\n current locale.\n Params:\n utf8string = a UTF-8 encoded string.\n len = the length of the string, or -1 if the string is\n  nul-terminated.\n bytesRead = location to store the number of bytes in the\n  input string that were successfully converted, or NULL.\n  Even if the conversion was successful, this may be\n  less than len if there were partial characters\n  at the end of the input. If the error\n  G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value\n  stored will the byte offset after the last valid\n  input sequence.\n bytesWritten = the number of bytes stored in the output buffer (not\n  including the terminating nul).\n Returns: The converted string, or NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 342}
,
{
"name" : "getFilenameCharsets",
"kind" : "function",
"protection" : "public",
"type" : "int(out string[] charsets)",
"comment" : "\n Determines the preferred character sets used for filenames.\n The first character set from the charsets is the filename encoding, the\n subsequent character sets are used when trying to generate a displayable\n representation of a filename, see g_filename_display_name().\n On Unix, the character sets are determined by consulting the\n environment variables G_FILENAME_ENCODING and\n G_BROKEN_FILENAMES. On Windows, the character set\n used in the GLib API is always UTF-8 and said environment variables\n have no effect.\n G_FILENAME_ENCODING may be set to a comma-separated list\n of character set names. The special token \"@locale\" is taken to\n mean the character set for the current\n locale. If G_FILENAME_ENCODING is not set, but\n G_BROKEN_FILENAMES is, the character set of the current\n locale is taken as the filename encoding. If neither environment variable\n is set, UTF-8 is taken as the filename encoding, but the character\n set of the current locale is also put in the list of encodings.\n The returned charsets belong to GLib and must not be freed.\n Note that on Unix, regardless of the locale character set or\n G_FILENAME_ENCODING value, the actual file names present\n on a system might be in any random encoding or just gibberish.\n Since 2.6\n Params:\n charsets = return location for the NULL-terminated list of encoding names\n Returns: TRUE if the filename encoding is UTF-8.\n\t \n",
"line" : 384}
,
{
"name" : "filenameDisplayName",
"kind" : "function",
"protection" : "public",
"type" : "string(string filename)",
"comment" : "\n Converts a filename into a valid UTF-8 string. The conversion is\n not necessarily reversible, so you should keep the original around\n and use the return value of this function only for display purposes.\n Unlike g_filename_to_utf8(), the result is guaranteed to be non-NULL\n even if the filename actually isn't in the GLib file name encoding.\n If GLib can not make sense of the encoding of filename, as a last resort it\n replaces unknown characters with U+FFFD, the Unicode replacement character.\n You can search the result for the UTF-8 encoding of this character (which is\n \"\\357\\277\\275\" in octal notation) to find out if filename was in an invalid\n encoding.\n If you know the whole pathname of the file you should use\n g_filename_display_basename(), since that allows location-based\n translation of filenames.\n Since 2.6\n Params:\n filename = a pathname hopefully in the GLib file name encoding\n Returns: a newly allocated string containing a rendition of the filename in valid UTF-8\n\t \n",
"line" : 414}
,
{
"name" : "filenameDisplayBasename",
"kind" : "function",
"protection" : "public",
"type" : "string(string filename)",
"comment" : "\n Returns the display basename for the particular filename, guaranteed\n to be valid UTF-8. The display name might not be identical to the filename,\n for instance there might be problems converting it to UTF-8, and some files\n can be translated in the display.\n If GLib can not make sense of the encoding of filename, as a last resort it\n replaces unknown characters with U+FFFD, the Unicode replacement character.\n You can search the result for the UTF-8 encoding of this character (which is\n \"\\357\\277\\275\" in octal notation) to find out if filename was in an invalid\n encoding.\n You must pass the whole absolute pathname to this functions so that\n translation of well known locations can be done.\n This function is preferred over g_filename_display_name() if you know the\n whole path, as it allows translation.\n Since 2.6\n Params:\n filename = an absolute pathname in the GLib file name encoding\n Returns: a newly allocated string containing a rendition of the basename of the filename in valid UTF-8\n\t \n",
"line" : 439}
,
{
"name" : "localeFromUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(string utf8string, long len, out ulong bytesRead, out ulong bytesWritten)",
"comment" : "\n Converts a string from UTF-8 to the encoding used for strings by\n the C runtime (usually the same as that used by the operating\n system) in the current locale. On\n Windows this means the system codepage.\n Params:\n utf8string = a UTF-8 encoded string\n len = the length of the string, or -1 if the string is\n  nul-terminated[1].\n bytesRead = location to store the number of bytes in the\n  input string that were successfully converted, or NULL.\n  Even if the conversion was successful, this may be\n  less than len if there were partial characters\n  at the end of the input. If the error\n  G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value\n  stored will the byte offset after the last valid\n  input sequence.\n bytesWritten = the number of bytes stored in the output buffer (not\n  including the terminating nul).\n Returns: The converted string, or NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 467}
,
{
"name" : "getCharset",
"kind" : "function",
"protection" : "public",
"type" : "int(out string charset)",
"comment" : "\n Obtains the character set for the current\n locale; you might use this character set as an argument to\n g_convert(), to convert from the current locale's encoding to some\n other encoding. (Frequently g_locale_to_utf8() and g_locale_from_utf8()\n are nice shortcuts, though.)\n On Windows the character set returned by this function is the\n so-called system default ANSI code-page. That is the character set\n used by the \"narrow\" versions of C library and Win32 functions that\n handle file names. It might be different from the character set\n used by the C library's current locale.\n The return value is TRUE if the locale's encoding is UTF-8, in that\n case you can perhaps avoid calling g_convert().\n The string returned in charset is not allocated, and should not be\n freed.\n Params:\n charset = return location for character set name\n Returns: TRUE if the returned charset is UTF-8 [1] Note that some encodings may allow nul bytes to occur inside strings. In that case, using -1 for the len parameter is unsafe. [2] Despite the fact that byes_read can return information about partial characters, the g_convert_... functions are not generally suitable for streaming. If the underlying converter being used maintains internal state, then this won't be preserved across successive calls to g_convert(), g_convert_with_iconv() or g_convert_with_fallback(). (An example of this is the GNU C converter for CP1255 which does not emit a base character until it knows that the next character is not a mark that could combine with the base character.)\n\t \n",
"line" : 501}
]
}
]
}
,
{
"name" : "glib.Checksum",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Checksum.d",
"members" : [
{
"name" : "Checksum",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GLib provides a generic API for computing checksums (or \"digests\")\n for a sequence of arbitrary bytes, using various hashing algorithms\n like MD5, SHA-1 and SHA-256. Checksums are commonly used in various\n environments and specifications.\n GLib supports incremental checksums using the GChecksum data\n structure, by calling g_checksum_update() as long as there's data\n available and then using g_checksum_get_string() or\n g_checksum_get_digest() to compute the checksum and return it either\n as a string in hexadecimal form, or as a raw sequence of bytes. To\n compute the checksum for binary blobs and NUL-terminated strings in\n one go, use the convenience functions g_compute_checksum_for_data()\n and g_compute_checksum_for_string(), respectively.\n Support for checksums has been added in GLib 2.16\n \n",
"line" : 83,
"base" : "Object",
"members" : [
{
"name" : "gChecksum",
"kind" : "variable",
"protection" : "protected",
"type" : "GChecksum*",
"comment" : " the main Gtk struct \n",
"line" : 86}
,
{
"name" : "getChecksumStruct",
"kind" : "function",
"protection" : "public",
"type" : "GChecksum*()",
"line" : 89}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Checksum(GChecksum* gChecksum)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 104}
,
{
"name" : "typeGetLength",
"kind" : "function",
"protection" : "public",
"type" : "long(GChecksumType checksumType)",
"comment" : "\n\t \n\n Gets the length in bytes of digests of type checksum_type\n Since 2.16\n Params:\n checksumType = a GChecksumType\n Returns: the checksum length, or -1 if checksum_type is not supported.\n\t \n",
"line" : 124}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Checksum(GChecksumType checksumType)",
"comment" : "\n Creates a new GChecksum, using the checksum algorithm checksum_type.\n If the checksum_type is not known, NULL is returned.\n A GChecksum can be used to compute the checksum, or digest, of an\n arbitrary binary blob, using different hashing algorithms.\n A GChecksum works by feeding a binary blob through g_checksum_update()\n until there is data to be checked; the digest can then be extracted\n using g_checksum_get_string(), which will return the checksum as a\n hexadecimal string; or g_checksum_get_digest(), which will return a\n vector of raw bytes. Once either g_checksum_get_string() or\n g_checksum_get_digest() have been called on a GChecksum, the checksum\n will be closed and it won't be possible to call g_checksum_update()\n on it anymore.\n Since 2.16\n Params:\n checksumType = the desired type of checksum\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 148}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "Checksum()",
"comment" : "\n Copies a GChecksum. If checksum has been closed, by calling\n g_checksum_get_string() or g_checksum_get_digest(), the copied\n checksum will be closed as well.\n Since 2.16\n Returns: the copy of the passed GChecksum. Use g_checksum_free() when finished using it.\n\t \n",
"line" : 166}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees the memory allocated for checksum.\n Since 2.16\n\t \n",
"line" : 181}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Resets the state of the checksum back to its initial state.\n Since 2.18\n\t \n",
"line" : 191}
,
{
"name" : "update",
"kind" : "function",
"protection" : "public",
"type" : "void(char* data, long length)",
"comment" : "\n Feeds data into an existing GChecksum. The checksum must still be\n open, that is g_checksum_get_string() or g_checksum_get_digest() must\n not have been called on checksum.\n Since 2.16\n Params:\n data = buffer used to compute the checksum\n length = size of the buffer, or -1 if it is a null-terminated string.\n\t \n",
"line" : 206}
,
{
"name" : "getString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the digest as an hexadecimal string.\n Once this function has been called the GChecksum can no longer be\n updated with g_checksum_update().\n The hexadecimal characters will be lower case.\n Since 2.16\n Returns: the hexadecimal representation of the checksum. The returned string is owned by the checksum and should not be modified or freed.\n\t \n",
"line" : 220}
,
{
"name" : "getDigest",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte* buffer, ulong* digestLen)",
"comment" : "\n Gets the digest from checksum as a raw binary vector and places it\n into buffer. The size of the digest depends on the type of checksum.\n Once this function has been called, the GChecksum is closed and can\n no longer be updated with g_checksum_update().\n Since 2.16\n Params:\n buffer = output buffer\n digestLen = an inout parameter. The caller initializes it to the size of buffer.\n  After the call it contains the length of the digest.\n\t \n",
"line" : 237}
,
{
"name" : "gComputeChecksumForData",
"kind" : "function",
"protection" : "public",
"type" : "string(GChecksumType checksumType, char* data, ulong length)",
"comment" : "\n Computes the checksum for a binary data of length. This is a\n convenience wrapper for g_checksum_new(), g_checksum_get_string()\n and g_checksum_free().\n The hexadecimal string returned will be in lower case.\n Since 2.16\n Params:\n checksumType = a GChecksumType\n data = binary blob to compute the digest of\n length = length of data\n Returns: the digest of the binary data as a string in hexadecimal. The returned string should be freed with g_free() when done using it.\n\t \n",
"line" : 255}
,
{
"name" : "gComputeChecksumForString",
"kind" : "function",
"protection" : "public",
"type" : "string(GChecksumType checksumType, string str, long length)",
"comment" : "\n Computes the checksum of a string.\n The hexadecimal string returned will be in lower case.\n Since 2.16\n Params:\n checksumType = a GChecksumType\n str = the string to compute the checksum of\n length = the length of the string, or -1 if the string is null-terminated.\n Returns: the checksum as a hexadecimal string. The returned string should be freed with g_free() when done using it.\n\t \n",
"line" : 271}
]
}
]
}
,
{
"name" : "glib.Child",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Child.d",
"members" : [
{
"name" : "Child",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The main event loop manages all the available sources of events for\n GLib and GTK+ applications. These events can come from any number of\n different types of sources such as file descriptors (plain files,\n pipes or sockets) and timeouts. New types of event sources can also\n be added using g_source_attach().\n To allow multiple independent sets of sources to be handled in\n different threads, each source is associated with a GMainContext.\n A GMainContext can only be running in a single thread, but\n sources can be added to it and removed from it from other threads.\n Each event source is assigned a priority. The default priority,\n G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n Values greater than 0 denote lower priorities. Events from high priority\n sources are always processed before events from lower priority sources.\n Idle functions can also be added, and assigned a priority. These will\n be run whenever no events with a higher priority are ready to be processed.\n The GMainLoop data type represents a main event loop. A GMainLoop is\n created with g_main_loop_new(). After adding the initial event sources,\n g_main_loop_run() is called. This continuously checks for new events from\n each of the event sources and dispatches them. Finally, the processing of\n an event from one of the sources leads to a call to g_main_loop_quit() to\n exit the main loop, and g_main_loop_run() returns.\n It is possible to create new instances of GMainLoop recursively.\n This is often used in GTK+ applications when showing modal dialog\n boxes. Note that event sources are associated with a particular\n GMainContext, and will be checked and dispatched for all main\n loops associated with that GMainContext.\n GTK+ contains wrappers of some of these functions, e.g. gtk_main(),\n gtk_main_quit() and gtk_events_pending().\n Creating new source types\n One of the unusual features of the GMainLoop functionality\n is that new types of event source can be created and used in\n addition to the builtin type of event source. A new event source\n type is used for handling GDK events. A new source type is created\n by deriving from the GSource structure.\n The derived type of source is represented by a structure that has\n the GSource structure as a first element, and other elements specific\n to the new source type. To create an instance of the new source type,\n call g_source_new() passing in the size of the derived structure and\n a table of functions. These GSourceFuncs determine the behavior of\n the new source type.\n New source types basically interact with the main context\n in two ways. Their prepare function in GSourceFuncs can set a timeout\n to determine the maximum amount of time that the main loop will sleep\n before checking the source again. In addition, or as well, the source\n can add file descriptors to the set that the main context checks using\n g_source_add_poll().\n <hr>\n Customizing the main loop iteration\n Single iterations of a GMainContext can be run with\n g_main_context_iteration(). In some cases, more detailed control\n of exactly how the details of the main loop work is desired, for\n instance, when integrating the GMainLoop with an external main loop.\n In such cases, you can call the component functions of\n g_main_context_iteration() directly. These functions are\n g_main_context_prepare(), g_main_context_query(),\n g_main_context_check() and g_main_context_dispatch().\n The operation of these functions can best be seen in terms\n of a state diagram, as shown in Figure  1, “States of a Main Context”.\n Figure  1.  States of a Main Context\n \n",
"line" : 129,
"base" : "Object",
"members" : [
{
"name" : "watchSourceNew",
"kind" : "function",
"protection" : "public",
"type" : "Source(int pid)",
"comment" : "\n\t \n\n Creates a new child_watch source.\n The source will not initially be associated with any GMainContext\n and must be added to one with g_source_attach() before it will be\n executed.\n Note that child watch sources can only be used in conjunction with\n g_spawn... when the G_SPAWN_DO_NOT_REAP_CHILD\n flag is used.\n Note that on platforms where GPid must be explicitly closed\n (see g_spawn_close_pid()) pid must not be closed while the\n source is still active. Typically, you will want to call\n g_spawn_close_pid() in the callback function for the source.\n Note further that using g_child_watch_source_new() is not\n compatible with calling waitpid(-1) in\n the application. Calling waitpid() for individual pids will\n still work fine.\n Since 2.4\n Params:\n pid = process to watch. On POSIX the pid of a child process. On\n Windows a handle for a process (which doesn't have to be a child).\n Returns: the newly-created child watch source\n\t \n",
"line" : 156}
,
{
"name" : "watchAdd",
"kind" : "function",
"protection" : "public",
"type" : "uint(int pid, extern (C) void function(int, int, void*) funct, void* data)",
"comment" : "\n Sets a function to be called when the child indicated by pid\n exits, at a default priority, G_PRIORITY_DEFAULT.\n If you obtain pid from g_spawn_async() or g_spawn_async_with_pipes()\n you will need to pass G_SPAWN_DO_NOT_REAP_CHILD as flag to\n the spawn function for the child watching to work.\n Note that on platforms where GPid must be explicitly closed\n (see g_spawn_close_pid()) pid must not be closed while the\n source is still active. Typically, you will want to call\n g_spawn_close_pid() in the callback function for the source.\n GLib supports only a single callback per process id.\n This internally creates a main loop source using\n g_child_watch_source_new() and attaches it to the main loop context\n using g_source_attach(). You can do these steps manually if you\n need greater control.\n Since 2.4\n Params:\n pid = process id to watch. On POSIX the pid of a child process. On\n Windows a handle for a process (which doesn't have to be a child).\n data = data to pass to function\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 189}
,
{
"name" : "watchAddFull",
"kind" : "function",
"protection" : "public",
"type" : "uint(int priority, int pid, extern (C) void function(int, int, void*) funct, void* data, extern (C) void function(void* cbData) notify)",
"comment" : "\n Sets a function to be called when the child indicated by pid\n exits, at the priority priority.\n If you obtain pid from g_spawn_async() or g_spawn_async_with_pipes()\n you will need to pass G_SPAWN_DO_NOT_REAP_CHILD as flag to\n the spawn function for the child watching to work.\n Note that on platforms where GPid must be explicitly closed\n (see g_spawn_close_pid()) pid must not be closed while the\n source is still active. Typically, you will want to call\n g_spawn_close_pid() in the callback function for the source.\n GLib supports only a single callback per process id.\n This internally creates a main loop source using\n g_child_watch_source_new() and attaches it to the main loop context\n using g_source_attach(). You can do these steps manually if you\n need greater control.\n Since 2.4\n Params:\n priority = the priority of the idle source. Typically this will be in the\n  range between G_PRIORITY_DEFAULT_IDLE and G_PRIORITY_HIGH_IDLE.\n pid = process to watch. On POSIX the pid of a child process. On\n Windows a handle for a process (which doesn't have to be a child).\n data = data to pass to function\n notify = function to call when the idle is removed, or NULL\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 220}
]
}
]
}
,
{
"name" : "glib.ConstructionException",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ConstructionException.d",
"members" : [
{
"name" : "ConstructionException",
"kind" : "class",
"protection" : "public",
"line" : 62,
"base" : "Exception",
"members" : [
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ConstructionException(string message)",
"line" : 64}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 69}
]
}
]
}
,
{
"name" : "glib.DataList",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/DataList.d",
"members" : [
{
"name" : "DataList",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Keyed data lists provide lists of arbitrary data elements which can\n be accessed either with a string or with a GQuark corresponding to\n the string.\n The GQuark methods are quicker, since the strings have to be\n converted to GQuarks anyway.\n Data lists are used for associating arbitrary data with GObjects,\n using g_object_set_data() and related functions.\n To create a datalist, use g_datalist_init().\n To add data elements to a datalist use g_datalist_id_set_data(),\n g_datalist_id_set_data_full(), g_datalist_set_data() and\n g_datalist_set_data_full().\n To get data elements from a datalist use g_datalist_id_get_data()\n and g_datalist_get_data().\n To iterate over all data elements in a datalist use\n g_datalist_foreach() (not thread-safe).\n To remove data elements from a datalist use\n g_datalist_id_remove_data() and g_datalist_remove_data().\n To remove all data elements from a datalist, use g_datalist_clear().\n \n",
"line" : 85,
"base" : "Object",
"members" : [
{
"name" : "gData",
"kind" : "variable",
"protection" : "protected",
"type" : "GData*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getDataListStruct",
"kind" : "function",
"protection" : "public",
"type" : "GData*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DataList(GData* gData)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void(GData** datalist)",
"comment" : "\n\t \n\n Resets the datalist to NULL. It does not free any memory or call\n any destroy functions.\n Params:\n datalist = a pointer to a pointer to a datalist.\n\t \n",
"line" : 125}
,
{
"name" : "idSetDataFull",
"kind" : "function",
"protection" : "public",
"type" : "void(GData** datalist, uint keyId, void* data, extern (C) void function(void* cbData) destroyFunc)",
"comment" : "\n Sets the data corresponding to the given GQuark id, and the\n function to be called when the element is removed from the datalist.\n Any previous data with the same key is removed, and its destroy\n function is called.\n Params:\n datalist = a datalist.\n keyId = the GQuark to identify the data element.\n data = the data element or NULL to remove any previous element\n  corresponding to key_id.\n destroyFunc = the function to call when the data element is\n  removed. This function will be called with the data\n  element and can be used to free any memory allocated\n  for it. If data is NULL, then destroy_func must\n  also be NULL.\n\t \n",
"line" : 147}
,
{
"name" : "idGetData",
"kind" : "function",
"protection" : "public",
"type" : "void*(GData** datalist, uint keyId)",
"comment" : "\n Retrieves the data element corresponding to key_id.\n Params:\n datalist = a datalist.\n keyId = the GQuark identifying a data element.\n Returns: the data element, or NULL if it is not found.\n\t \n",
"line" : 160}
,
{
"name" : "idRemoveNoNotify",
"kind" : "function",
"protection" : "public",
"type" : "void*(GData** datalist, uint keyId)",
"comment" : "\n Removes an element, without calling its destroy notification\n function.\n Params:\n datalist = a datalist.\n keyId = the GQuark identifying a data element.\n Returns: the data previously stored at key_id, or NULL if none.\n\t \n",
"line" : 174}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(GData** datalist, extern (C) void function(uint, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each data element of the datalist. The\n function is called with each data element's GQuark id and data,\n together with the given user_data parameter. Note that this\n function is NOT thread-safe. So unless datalist can be protected\n from any modifications during invocation of this function, it should\n not be called.\n Params:\n datalist = a datalist.\n func = the function to call for each data element.\n userData = user data to pass to the function.\n\t \n",
"line" : 192}
,
{
"name" : "clear",
"kind" : "function",
"protection" : "public",
"type" : "void(GData** datalist)",
"comment" : "\n Frees all the data elements of the datalist. The data elements'\n destroy functions are called if they have been set.\n Params:\n datalist = a datalist.\n\t \n",
"line" : 204}
,
{
"name" : "setFlags",
"kind" : "function",
"protection" : "public",
"type" : "void(GData** datalist, uint flags)",
"comment" : "\n Turns on flag values for a data list. This function is used\n to keep a small number of boolean flags in an object with\n a data list without using any additional space. It is\n not generally useful except in circumstances where space\n is very tight. (It is used in the base GObject type, for\n example.)\n Since 2.8\n Params:\n datalist = pointer to the location that holds a list\n flags = the flags to turn on. The values of the flags are\n  restricted by G_DATALIST_FLAGS_MASK (currently\n  3; giving two possible boolean flags).\n  A value for flags that doesn't fit within the mask is\n  an error.\n\t \n",
"line" : 226}
,
{
"name" : "unsetFlags",
"kind" : "function",
"protection" : "public",
"type" : "void(GData** datalist, uint flags)",
"comment" : "\n Turns off flag values for a data list. See g_datalist_unset_flags()\n Since 2.8\n Params:\n datalist = pointer to the location that holds a list\n flags = the flags to turn off. The values of the flags are\n  restricted by G_DATALIST_FLAGS_MASK (currently\n  3: giving two possible boolean flags).\n  A value for flags that doesn't fit within the mask is\n  an error.\n\t \n",
"line" : 243}
,
{
"name" : "getFlags",
"kind" : "function",
"protection" : "public",
"type" : "uint(GData** datalist)",
"comment" : "\n Gets flags values packed in together with the datalist.\n See g_datalist_set_flags().\n Since 2.8\n Params:\n datalist = pointer to the location that holds a list\n Returns: the flags of the datalist\n\t \n",
"line" : 257}
]
}
]
}
,
{
"name" : "glib.Dataset",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Dataset.d",
"members" : [
{
"name" : "Dataset",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Datasets associate groups of data elements with particular memory\n locations. These are useful if you need to associate data with a\n structure returned from an external library. Since you cannot modify\n the structure, you use its location in memory as the key into a\n dataset, where you can associate any number of data elements with it.\n There are two forms of most of the dataset functions. The first form\n uses strings to identify the data elements associated with a\n location. The second form uses GQuark identifiers, which are\n created with a call to g_quark_from_string() or\n g_quark_from_static_string(). The second form is quicker, since it\n does not require looking up the string in the hash table of GQuark\n identifiers.\n There is no function to create a dataset. It is automatically\n created as soon as you add elements to it.\n To add data elements to a dataset use g_dataset_id_set_data(),\n g_dataset_id_set_data_full(), g_dataset_set_data() and\n g_dataset_set_data_full().\n To get data elements from a dataset use g_dataset_id_get_data() and\n g_dataset_get_data().\n To iterate over all data elements in a dataset use\n g_dataset_foreach() (not thread-safe).\n To remove data elements from a dataset use\n g_dataset_id_remove_data() and g_dataset_remove_data().\n To destroy a dataset, use g_dataset_destroy().\n \n",
"line" : 91,
"base" : "Object",
"members" : [
{
"name" : "idSetDataFull",
"kind" : "function",
"protection" : "public",
"type" : "void(void* datasetLocation, uint keyId, void* data, extern (C) void function(void* cbData) destroyFunc)",
"comment" : "\n\t \n\n Sets the data element associated with the given GQuark id, and also\n the function to call when the data element is destroyed. Any\n previous data with the same key is removed, and its destroy function\n is called.\n Params:\n datasetLocation = the location identifying the dataset.\n keyId = the GQuark id to identify the data element.\n data = the data element.\n destroyFunc = the function to call when the data element is\n  removed. This function will be called with the data\n  element and can be used to free any memory allocated\n  for it.\n\t \n",
"line" : 110}
,
{
"name" : "idGetData",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* datasetLocation, uint keyId)",
"comment" : "\n Gets the data element corresponding to a GQuark.\n Params:\n datasetLocation = the location identifying the dataset.\n keyId = the GQuark id to identify the data element.\n Returns: the data element corresponding to the GQuark, or NULL if it is not found.\n\t \n",
"line" : 123}
,
{
"name" : "idRemoveNoNotify",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* datasetLocation, uint keyId)",
"comment" : "\n Removes an element, without calling its destroy notification\n function.\n Params:\n datasetLocation = the location identifying the dataset.\n keyId = the GQuark ID identifying the data element.\n Returns: the data previously stored at key_id, or NULL if none.\n\t \n",
"line" : 137}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(void* datasetLocation, extern (C) void function(uint, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each data element which is associated\n with the given location. Note that this function is NOT thread-safe.\n So unless datalist can be protected from any modifications during\n invocation of this function, it should not be called.\n Params:\n datasetLocation = the location identifying the dataset.\n func = the function to call for each data element.\n userData = user data to pass to the function.\n\t \n",
"line" : 153}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void(void* datasetLocation)",
"comment" : "\n Destroys the dataset, freeing all memory allocated, and calling any\n destroy functions set for data elements.\n Params:\n datasetLocation = the location identifying the dataset.\n\t \n",
"line" : 165}
]
}
]
}
,
{
"name" : "glib.Date",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Date.d",
"members" : [
{
"name" : "Date",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GDate data structure represents a day between January 1, Year 1,\n and sometime a few thousand years in the future (right now it will go\n to the year 65535 or so, but g_date_set_parse() only parses up to the\n year 8000 or so - just count on \"a few thousand\"). GDate is meant to\n represent everyday dates, not astronomical dates or historical dates\n or ISO timestamps or the like. It extrapolates the current Gregorian\n calendar forward and backward in time; there is no attempt to change\n the calendar to match time periods or locations. GDate does not store\n time information; it represents a day.\n The GDate implementation has several nice features; it is only a\n 64-bit struct, so storing large numbers of dates is very efficient. It\n can keep both a Julian and day-month-year representation of the date,\n since some calculations are much easier with one representation or the\n other. A Julian representation is simply a count of days since some\n fixed day in the past; for GDate the fixed day is January 1, 1 AD.\n (\"Julian\" dates in the GDate API aren't really Julian dates in the\n technical sense; technically, Julian dates count from the start of the\n Julian period, Jan 1, 4713 BC).\n GDate is simple to use. First you need a \"blank\" date; you can get a\n dynamically allocated date from g_date_new(), or you can declare an\n automatic variable or array and initialize it to a sane state by\n calling g_date_clear(). A cleared date is sane; it's safe to call\n g_date_set_dmy() and the other mutator functions to initialize the\n value of a cleared date. However, a cleared date is initially\n invalid, meaning that it doesn't represent a day\n that exists. It is undefined to call any of the date calculation\n routines on an invalid date. If you obtain a date from a user or other\n unpredictable source, you should check its validity with the\n g_date_valid() predicate. g_date_valid() is also used to check for\n errors with g_date_set_parse() and other functions that can\n fail. Dates can be invalidated by calling g_date_clear() again.\n It is very important to use the API to access the GDate\n struct. Often only the day-month-year or only the Julian\n representation is valid. Sometimes neither is valid. Use the API.\n GLib doesn't contain any time-manipulation functions; however, there\n is a GTime typedef and a GTimeVal struct which represents a more\n precise time (with microseconds). You can request the current time as\n a GTimeVal with g_get_current_time().\n \n",
"line" : 111,
"base" : "Object",
"members" : [
{
"name" : "gDate",
"kind" : "variable",
"protection" : "protected",
"type" : "GDate*",
"comment" : " the main Gtk struct \n",
"line" : 114}
,
{
"name" : "getDateStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDate*()",
"line" : 117}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 124}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Date(GDate* gDate)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 132}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Date()",
"comment" : "\n\t \n\n Allocates a GDate and initializes it to a sane state. The new date will\n be cleared (as if you'd called g_date_clear()) but invalid (it won't\n represent an existing day). Free the return value with g_date_free().\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 151}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Date(ubyte day, GDateMonth month, ushort year)",
"comment" : "\n Like g_date_new(), but also sets the value of the date. Assuming the\n day-month-year triplet you pass in represents an existing day, the\n returned date will be valid.\n Params:\n day = day of the month\n month = month of the year\n year = year\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 172}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Date(uint julianDay)",
"comment" : "\n Like g_date_new(), but also sets the value of the date. Assuming the\n Julian day number you pass in is valid (greater than 0, less than an\n unreasonably large number), the returned date will be valid.\n Params:\n julianDay = days since January 1, Year 1\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 191}
,
{
"name" : "clear",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nDates)",
"comment" : "\n Initializes one or more GDate structs to a sane but invalid\n state. The cleared dates will not represent an existing date, but will\n not contain garbage. Useful to init a date declared on the stack.\n Validity can be tested with g_date_valid().\n Params:\n nDates = number of dates to clear\n\t \n",
"line" : 210}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a GDate returned from g_date_new().\n\t \n",
"line" : 219}
,
{
"name" : "setDay",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte day)",
"comment" : "\n Sets the day of the month for a GDate. If the resulting day-month-year\n triplet is invalid, the date will be invalid.\n Params:\n day = day to set\n\t \n",
"line" : 231}
,
{
"name" : "setMonth",
"kind" : "function",
"protection" : "public",
"type" : "void(GDateMonth month)",
"comment" : "\n Sets the month of the year for a GDate. If the resulting\n day-month-year triplet is invalid, the date will be invalid.\n Params:\n month = month to set\n\t \n",
"line" : 243}
,
{
"name" : "setYear",
"kind" : "function",
"protection" : "public",
"type" : "void(ushort year)",
"comment" : "\n Sets the year for a GDate. If the resulting day-month-year triplet is\n invalid, the date will be invalid.\n Params:\n year = year to set\n\t \n",
"line" : 255}
,
{
"name" : "setDmy",
"kind" : "function",
"protection" : "public",
"type" : "void(ubyte day, GDateMonth month, ushort y)",
"comment" : "\n Sets the value of a GDate from a day, month, and year. The day-month-year\n triplet must be valid; if you aren't sure it is, call g_date_valid_dmy() to\n check before you set it.\n Params:\n day = day\n month = month\n y = year\n\t \n",
"line" : 270}
,
{
"name" : "setJulian",
"kind" : "function",
"protection" : "public",
"type" : "void(uint julianDate)",
"comment" : "\n Sets the value of a GDate from a Julian day number.\n Params:\n julianDate = Julian day number (days since January 1, Year 1)\n\t \n",
"line" : 281}
,
{
"name" : "setTime",
"kind" : "function",
"protection" : "public",
"type" : "void(int time)",
"comment" : "\n Warning\n g_date_set_time has been deprecated since version 2.10 and should not be used in newly-written code. Use g_date_set_time_t() instead.\n Sets the value of a date from a GTime value.\n The time to date conversion is done using the user's current timezone.\n Params:\n time = GTime value to set.\n\t \n",
"line" : 295}
,
{
"name" : "setTimeT",
"kind" : "function",
"protection" : "public",
"type" : "void(uint timet)",
"comment" : "\n Sets the value of a date to the date corresponding to a time\n specified as a time_t. The time to date conversion is done using\n the user's current timezone.\n Since 2.10\n Params:\n timet = time_t value to set\n\t \n",
"line" : 309}
,
{
"name" : "setTimeVal",
"kind" : "function",
"protection" : "public",
"type" : "void(TimeVal timeval)",
"comment" : "\n Sets the value of a date from a GTimeVal value. Note that the\n tv_usec member is ignored, because GDate can't make use of the\n additional precision.\n The time to date conversion is done using the user's current timezone.\n Since 2.10\n Params:\n timeval = GTimeVal value to set\n\t \n",
"line" : 324}
,
{
"name" : "setParse",
"kind" : "function",
"protection" : "public",
"type" : "void(string str)",
"comment" : "\n Parses a user-inputted string str, and try to figure out what date it\n represents, taking the current locale\n into account. If the string is successfully parsed, the date will be\n valid after the call. Otherwise, it will be invalid. You should check\n using g_date_valid() to see whether the parsing succeeded.\n This function is not appropriate for file formats and the like; it\n isn't very precise, and its exact behavior varies with the\n locale. It's intended to be a heuristic routine that guesses what the\n user means by a given string (and it does work pretty well in that\n capacity).\n Params:\n str = string to parse\n\t \n",
"line" : 344}
,
{
"name" : "addDays",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nDays)",
"comment" : "\n Increments a date some number of days. To move forward by weeks, add\n weeks*7 days. The date must be valid.\n Params:\n nDays = number of days to move the date forward\n\t \n",
"line" : 356}
,
{
"name" : "subtractDays",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nDays)",
"comment" : "\n Moves a date some number of days into the past. To move by weeks, just\n move by weeks*7 days. The date must be valid.\n Params:\n nDays = number of days to move\n\t \n",
"line" : 368}
,
{
"name" : "addMonths",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nMonths)",
"comment" : "\n Increments a date by some number of months. If the day of the month is\n greater than 28, this routine may change the day of the month (because\n the destination month may not have the current day in it). The date\n must be valid.\n Params:\n nMonths = number of months to move forward\n\t \n",
"line" : 382}
,
{
"name" : "subtractMonths",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nMonths)",
"comment" : "\n Moves a date some number of months into the past. If the current day of\n the month doesn't exist in the destination month, the day of the month\n may change. The date must be valid.\n Params:\n nMonths = number of months to move\n\t \n",
"line" : 395}
,
{
"name" : "addYears",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nYears)",
"comment" : "\n Increments a date by some number of years. If the date is February 29,\n and the destination year is not a leap year, the date will be changed\n to February 28. The date must be valid.\n Params:\n nYears = number of years to move forward\n\t \n",
"line" : 408}
,
{
"name" : "subtractYears",
"kind" : "function",
"protection" : "public",
"type" : "void(uint nYears)",
"comment" : "\n Moves a date some number of years into the past. If the current day\n doesn't exist in the destination year (i.e. it's February 29 and you\n move to a non-leap-year) then the day is changed to February 29. The date\n must be valid.\n Params:\n nYears = number of years to move\n\t \n",
"line" : 422}
,
{
"name" : "daysBetween",
"kind" : "function",
"protection" : "public",
"type" : "int(Date date2)",
"comment" : "\n Computes the number of days between two dates.\n If date2 is prior to date1, the returned value is negative.\n Both dates must be valid.\n Params:\n date2 = the second date\n Returns: the number of days between date1 and date2\n\t \n",
"line" : 436}
,
{
"name" : "compare",
"kind" : "function",
"protection" : "public",
"type" : "int(Date rhs)",
"comment" : "\n qsort()-style comparsion function for dates. Both\n dates must be valid.\n Params:\n rhs = second date to compare\n Returns: 0 for equal, less than zero if lhs is less than rhs, greater than zero if lhs is greater than rhs\n\t \n",
"line" : 449}
,
{
"name" : "clamp",
"kind" : "function",
"protection" : "public",
"type" : "void(Date minDate, Date maxDate)",
"comment" : "\n If date is prior to min_date, sets date equal to min_date.\n If date falls after max_date, sets date equal to max_date.\n Otherwise, date is unchanged.\n Either of min_date and max_date may be NULL. All non-NULL dates\n must be valid.\n Params:\n minDate = minimum accepted value for date\n maxDate = maximum accepted value for date\n\t \n",
"line" : 465}
,
{
"name" : "order",
"kind" : "function",
"protection" : "public",
"type" : "void(Date date2)",
"comment" : "\n Checks if date1 is less than or equal to date2,\n and swap the values if this is not the case.\n Params:\n date2 = the second date\n\t \n",
"line" : 477}
,
{
"name" : "getDay",
"kind" : "function",
"protection" : "public",
"type" : "ubyte()",
"comment" : "\n Returns the day of the month. The date must be valid.\n Returns: day of the month\n\t \n",
"line" : 487}
,
{
"name" : "getMonth",
"kind" : "function",
"protection" : "public",
"type" : "GDateMonth()",
"comment" : "\n Returns the month of the year. The date must be valid.\n Returns: month of the year as a GDateMonth\n\t \n",
"line" : 497}
,
{
"name" : "getYear",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Returns the year of a GDate. The date must be valid.\n Returns: year in which the date falls\n\t \n",
"line" : 507}
,
{
"name" : "getJulian",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the Julian day or \"serial number\" of the GDate. The\n Julian day is simply the number of days since January 1, Year 1; i.e.,\n January 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,\n etc. The date must be valid.\n Returns: Julian day\n\t \n",
"line" : 520}
,
{
"name" : "getWeekday",
"kind" : "function",
"protection" : "public",
"type" : "GDateWeekday()",
"comment" : "\n Returns the day of the week for a GDate. The date must be valid.\n Returns: day of the week as a GDateWeekday.\n\t \n",
"line" : 530}
,
{
"name" : "getDayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the day of the year, where Jan 1 is the first day of the\n year. The date must be valid.\n Returns: day of the year\n\t \n",
"line" : 541}
,
{
"name" : "getDaysInMonth",
"kind" : "function",
"protection" : "public",
"type" : "ubyte(GDateMonth month, ushort year)",
"comment" : "\n Returns the number of days in a month, taking leap years into account.\n Params:\n month = month\n year = year\n Returns: number of days in month during the year\n\t \n",
"line" : 554}
,
{
"name" : "isFirstOfMonth",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns TRUE if the date is on the first of a month. The date must be valid.\n Returns: TRUE if the date is the first of the month\n\t \n",
"line" : 564}
,
{
"name" : "isLastOfMonth",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns TRUE if the date is the last day of the month. The date must be valid.\n Returns: TRUE if the date is the last day of the month\n\t \n",
"line" : 574}
,
{
"name" : "isLeapYear",
"kind" : "function",
"protection" : "public",
"type" : "int(ushort year)",
"comment" : "\n Returns TRUE if the year is a leap year.[4]\n Params:\n year = year to check\n Returns: TRUE if the year is a leap year\n\t \n",
"line" : 586}
,
{
"name" : "getMondayWeekOfYear",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the week of the year, where weeks are understood to start on\n Monday. If the date is before the first Monday of the year, return\n 0. The date must be valid.\n Returns: week of the year\n\t \n",
"line" : 598}
,
{
"name" : "getMondayWeeksInYear",
"kind" : "function",
"protection" : "public",
"type" : "ubyte(ushort year)",
"comment" : "\n Returns the number of weeks in the year, where weeks are taken to start\n on Monday. Will be 52 or 53. The date must be valid. (Years always have 52\n 7-day periods, plus 1 or 2 extra days depending on whether it's a leap\n year. This function is basically telling you how many Mondays are in\n the year, i.e. there are 53 Mondays if one of the extra days happens\n to be a Monday.)\n Params:\n year = a year\n Returns: number of Mondays in the year\n\t \n",
"line" : 615}
,
{
"name" : "getSundayWeekOfYear",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the week of the year during which this date falls, if weeks\n are understood to being on Sunday. The date must be valid. Can return 0 if\n the day is before the first Sunday of the year.\n Returns: week number\n\t \n",
"line" : 627}
,
{
"name" : "getSundayWeeksInYear",
"kind" : "function",
"protection" : "public",
"type" : "ubyte(ushort year)",
"comment" : "\n Returns the number of weeks in the year, where weeks are taken to start\n on Sunday. Will be 52 or 53. The date must be valid. (Years always have 52\n 7-day periods, plus 1 or 2 extra days depending on whether it's a leap\n year. This function is basically telling you how many Sundays are in\n the year, i.e. there are 53 Sundays if one of the extra days happens\n to be a Sunday.)\n Params:\n year = year to count weeks in\n Returns: number of weeks\n\t \n",
"line" : 644}
,
{
"name" : "getIso8601_WeekOfYear",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the week of the year, where weeks are interpreted according\n to ISO 8601.\n Since 2.6\n Returns: ISO 8601 week number of the year.\n\t \n",
"line" : 656}
,
{
"name" : "strftime",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string s, ulong slen, string format, Date date)",
"comment" : "\n Generates a printed representation of the date, in a\n locale-specific way. Works just like\n the platform's C library strftime() function, but only accepts date-related\n formats; time-related formats give undefined results. Date must be valid.\n Unlike strftime() (which uses the locale encoding), works on a UTF-8 format\n string and stores a UTF-8 result.\n This function does not provide any conversion specifiers in addition\n to those implemented by the platform's C library. For example, don't\n expect that using g_date_strftime() would make the F provided by the C99\n strftime() work on Windows where the C library only complies to C89.\n Params:\n s = destination buffer\n slen = buffer size\n format = format string\n date = valid GDate\n Returns: number of characters written to the buffer, or 0 the buffer was too small\n\t \n",
"line" : 680}
,
{
"name" : "toStructTm",
"kind" : "function",
"protection" : "public",
"type" : "void(void* tm)",
"comment" : "\n Fills in the date-related bits of a struct tm\n using the date value. Initializes the non-date parts with something\n sane but meaningless.\n Params:\n tm = struct tm to fill.\n\t \n",
"line" : 693}
,
{
"name" : "valid",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns TRUE if the GDate represents an existing day. The date must not\n contain garbage; it should have been initialized with g_date_clear()\n if it wasn't allocated by one of the g_date_new() variants.\n Returns: Whether the date is valid\n\t \n",
"line" : 705}
,
{
"name" : "validDay",
"kind" : "function",
"protection" : "public",
"type" : "int(ubyte day)",
"comment" : "\n Returns TRUE if the day of the month is valid (a day is valid if it's\n between 1 and 31 inclusive).\n Params:\n day = day to check\n Returns: TRUE if the day is valid\n\t \n",
"line" : 718}
,
{
"name" : "validMonth",
"kind" : "function",
"protection" : "public",
"type" : "int(GDateMonth month)",
"comment" : "\n Returns TRUE if the month value is valid. The 12 GDateMonth\n enumeration values are the only valid months.\n Params:\n month = month\n Returns: TRUE if the month is valid\n\t \n",
"line" : 731}
,
{
"name" : "validYear",
"kind" : "function",
"protection" : "public",
"type" : "int(ushort year)",
"comment" : "\n Returns TRUE if the year is valid. Any year greater than 0 is valid,\n though there is a 16-bit limit to what GDate will understand.\n Params:\n year = year\n Returns: TRUE if the year is valid\n\t \n",
"line" : 744}
,
{
"name" : "validDmy",
"kind" : "function",
"protection" : "public",
"type" : "int(ubyte day, GDateMonth month, ushort year)",
"comment" : "\n Returns TRUE if the day-month-year triplet forms a valid, existing day\n in the range of days GDate understands (Year 1 or later, no more than\n a few thousand years in the future).\n Params:\n day = day\n month = month\n year = year\n Returns: TRUE if the date is a valid one\n\t \n",
"line" : 760}
,
{
"name" : "validJulian",
"kind" : "function",
"protection" : "public",
"type" : "int(uint julianDate)",
"comment" : "\n Returns TRUE if the Julian day is valid. Anything greater than zero\n is basically a valid Julian, though there is a 32-bit limit.\n Params:\n julianDate = Julian day to check\n Returns: TRUE if the Julian day is valid\n\t \n",
"line" : 773}
,
{
"name" : "validWeekday",
"kind" : "function",
"protection" : "public",
"type" : "int(GDateWeekday weekday)",
"comment" : "\n Returns TRUE if the weekday is valid. The seven GDateWeekday enumeration\n values are the only valid weekdays.\n Params:\n weekday = weekday\n Returns: TRUE if the weekday is valid [4] For the purposes of this function, leap year is every year divisible by 4 unless that year is divisible by 100. If it is divisible by 100 it would be a leap year only if that year is also divisible by 400.\n\t \n",
"line" : 786}
]
}
]
}
,
{
"name" : "glib.DateTime",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/DateTime.d",
"members" : [
{
"name" : "DateTime",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GDateTime is a structure that combines a Gregorian date and time\n into a single structure. It provides many conversion and methods to\n manipulate dates and times. Time precision is provided down to\n microseconds and the time can range (proleptically) from 0001-01-01\n 00:00:00 to 9999-12-31 23:59:59.999999. GDateTime follows POSIX\n time in the sense that it is oblivious to leap seconds.\n GDateTime is an immutable object; once it has been created it cannot\n be modified further. All modifiers will create a new GDateTime.\n Nearly all such functions can fail due to the date or time going out\n of range, in which case NULL will be returned.\n GDateTime is reference counted: the reference count is increased by calling\n g_date_time_ref() and decreased by calling g_date_time_unref(). When the\n reference count drops to 0, the resources allocated by the GDateTime\n structure are released.\n Many parts of the API may produce non-obvious results. As an\n example, adding two months to January 31st will yield March 31st\n whereas adding one month and then one month again will yield either\n March 28th or March 29th. Also note that adding 24 hours is not\n always the same as adding one day (since days containing daylight\n savings time transitions are either 23 or 25 hours in length).\n GDateTime is available since GLib 2.26.\n \n",
"line" : 106,
"base" : "Object",
"members" : [
{
"name" : "gDateTime",
"kind" : "variable",
"protection" : "protected",
"type" : "GDateTime*",
"comment" : " the main Gtk struct \n",
"line" : 109}
,
{
"name" : "getDateTimeStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDateTime*()",
"line" : 112}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 119}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DateTime(GDateTime* gDateTime)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 127}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DateTime(long t, bool utc = true)",
"comment" : "\n Creates a GDateTime corresponding to the given Unix time t\n Unix time is the number of seconds that have elapsed since 1970-01-01\n 00:00:00 UTC, regardless of the local time offset.\n\n This call can fail (returning NULL) if t represents a time outside\n of the supported range of GDateTime.\n You should release the return value by calling g_date_time_unref()\n when you are done with it.\n Since 2.26\n\n Params:\n     t   = the Unix time\n     utc = If true use utc else use the local timezone.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 153}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DateTime(TimeVal tv, bool utc = true)",
"comment" : "\n Creates a GDateTime corresponding to the given GTimeVal tv.\n The time contained in a GTimeVal is always stored in the form of\n seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the\n local time offset.\n\n This call can fail (returning NULL) if tv represents a time outside\n of the supported range of GDateTime.\n You should release the return value by calling unref()\n when you are done with it.\n Since 2.26\n\n Params:\n     tv  = a GTimeVal\n     utc = If true use utc else use the local timezone.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 191}
,
{
"name" : "opEquals",
"kind" : "function",
"protection" : "public",
"type" : "bool(Object rhs)",
"line" : 214}
,
{
"name" : "opCmp",
"kind" : "function",
"protection" : "public",
"type" : "int(Object rhs)",
"line" : 237}
,
{
"name" : "toHash",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"line" : 247}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Atomically decrements the reference count of datetime by one.\n When the reference count reaches zero, the resources allocated by\n datetime are freed\n Since 2.26\n\t \n",
"line" : 261}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "DateTime()",
"comment" : "\n Atomically increments the reference count of datetime by one.\n Since 2.26\n Returns: the GDateTime with the reference count increased\n\t \n",
"line" : 272}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DateTime(TimeZone tz)",
"comment" : "\n Creates a GDateTime corresponding to this exact instant in the given\n time zone tz. The time is as accurate as the system allows, to a\n maximum accuracy of 1 microsecond.\n This function will always succeed unless the system clock is set to\n truly insane values (or unless GLib is still being used after the\n year 9999).\n You should release the return value by calling g_date_time_unref()\n when you are done with it.\n Since 2.26\n Params:\n tz = a GTimeZone\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 297}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "DateTime(TimeZone tz, int year, int month, int day, int hour, int minute, double seconds)",
"comment" : "\n Creates a new GDateTime corresponding to the given date and time in\n the time zone tz.\n The year must be between 1 and 9999, month between 1 and 12 and day\n between 1 and 28, 29, 30 or 31 depending on the month and the year.\n hour must be between 0 and 23 and minute must be between 0 and 59.\n seconds must be at least 0.0 and must be strictly less than 60.0.\n It will be rounded down to the nearest microsecond.\n If the given time is not representable in the given time zone (for\n example, 02:30 on March 14th 2010 in Toronto, due to daylight savings\n time) then the time will be rounded up to the nearest existing time\n (in this case, 03:00). If this matters to you then you should verify\n the return value for containing the same as the numbers you gave.\n In the case that the given time is ambiguous in the given time zone\n (for example, 01:30 on November 7th 2010 in Toronto, due to daylight\n Since 2.26\n Params:\n tz = a GTimeZone\n year = the year component of the date\n month = the month component of the date\n day = the day component of the date\n hour = the hour component of the date\n minute = the minute component of the date\n seconds = the number of seconds past the minute\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 334}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(long timespan)",
"comment" : "\n Creates a copy of datetime and adds the specified timespan to the copy.\n Since 2.26\n Params:\n timespan = a GTimeSpan\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 352}
,
{
"name" : "addYears",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int years)",
"comment" : "\n Creates a copy of datetime and adds the specified number of years to the\n copy.\n Since 2.26\n Params:\n years = the number of years\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 371}
,
{
"name" : "addMonths",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int months)",
"comment" : "\n Creates a copy of datetime and adds the specified number of months to the\n copy.\n Since 2.26\n Params:\n months = the number of months\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 390}
,
{
"name" : "addWeeks",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int weeks)",
"comment" : "\n Creates a copy of datetime and adds the specified number of weeks to the\n copy.\n Since 2.26\n Params:\n weeks = the number of weeks\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 409}
,
{
"name" : "addDays",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int days)",
"comment" : "\n Creates a copy of datetime and adds the specified number of days to the\n copy.\n Since 2.26\n Params:\n days = the number of days\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 428}
,
{
"name" : "addHours",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int hours)",
"comment" : "\n Creates a copy of datetime and adds the specified number of hours\n Since 2.26\n Params:\n hours = the number of hours to add\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 446}
,
{
"name" : "addMinutes",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int minutes)",
"comment" : "\n Creates a copy of datetime adding the specified number of minutes.\n Since 2.26\n Params:\n minutes = the number of minutes to add\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 464}
,
{
"name" : "addSeconds",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(double seconds)",
"comment" : "\n Creates a copy of datetime and adds the specified number of seconds.\n Since 2.26\n Params:\n seconds = the number of seconds to add\n Returns: the newly created GDateTime which should be freed with g_date_time_unref().\n\t \n",
"line" : 482}
,
{
"name" : "addFull",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(int years, int months, int days, int hours, int minutes, double seconds)",
"comment" : "\n Creates a new GDateTime adding the specified values to the current date and\n time in datetime.\n Since 2.26\n Params:\n years = the number of years to add\n months = the number of months to add\n days = the number of days to add\n hours = the number of hours to add\n minutes = the number of minutes to add\n seconds = the number of seconds to add\n Returns: the newly created GDateTime that should be freed with g_date_time_unref().\n\t \n",
"line" : 506}
,
{
"name" : "compare",
"kind" : "function",
"protection" : "public",
"type" : "int(DateTime dt1, DateTime dt2)",
"comment" : "\n GCompareFunc-compatible comparison for GDateTime's. Both\n GDateTime<-- -->'s must be non-NULL.\n Since 2.26\n Params:\n dt1 = first GDateTime to compare\n dt2 = second GDateTime to compare\n Returns: 0 for equal, less than zero if dt1 is less than dt2, greater than zero if dt2 is greator than dt1.\n\t \n",
"line" : 526}
,
{
"name" : "difference",
"kind" : "function",
"protection" : "public",
"type" : "long(DateTime begin)",
"comment" : "\n Calculates the difference in time between end and begin. The\n Since 2.26\n Params:\n begin = a GDateTime\n Returns: the difference between the two GDateTime, as a time span expressed in microseconds.\n\t \n",
"line" : 539}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "public",
"type" : "uint(DateTime datetime)",
"comment" : "\n Hashes datetime into a guint, suitable for use within GHashTable.\n Since 2.26\n Params:\n datetime = a GDateTime\n Returns: a guint containing the hash\n\t \n",
"line" : 552}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(DateTime dt1, DateTime dt2)",
"comment" : "\n Checks to see if dt1 and dt2 are equal.\n Equal here means that they represent the same moment after converting\n them to the same time zone.\n Since 2.26\n Params:\n dt1 = a GDateTime\n dt2 = a GDateTime\n Returns: TRUE if dt1 and dt2 are equal\n\t \n",
"line" : 568}
,
{
"name" : "getYmd",
"kind" : "function",
"protection" : "public",
"type" : "void(int* year, int* month, int* day)",
"comment" : "\n Retrieves the Gregorian day, month, and year of a given GDateTime.\n Since 2.26\n Params:\n year = the return location for the gregorian year, or NULL. [out]\n month = the return location for the monty of the year, or NULL. [out]\n day = the return location for the day of the month, or NULL. [out]\n\t \n",
"line" : 582}
,
{
"name" : "getYear",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the year represented by datetime in the Gregorian calendar.\n Since 2.26\n Returns: the year represented by datetime\n\t \n",
"line" : 593}
,
{
"name" : "getMonth",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the month of the year represented by datetime in the Gregorian\n calendar.\n Since 2.26\n Returns: the month represented by datetime\n\t \n",
"line" : 605}
,
{
"name" : "getDayOfMonth",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the day of the month represented by datetime in the gregorian\n calendar.\n Since 2.26\n Returns: the day of the month\n\t \n",
"line" : 617}
,
{
"name" : "getWeekNumberingYear",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the ISO 8601 week-numbering year in which the week containing\n datetime falls.\n This function, taken together with g_date_time_get_week_of_year() and\n g_date_time_get_day_of_week() can be used to determine the full ISO\n week date on which datetime falls.\n This is usually equal to the normal Gregorian year (as returned by\n Since 2.26\n Returns: the ISO 8601 week-numbering year for datetime\n\t \n",
"line" : 633}
,
{
"name" : "getWeekOfYear",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the ISO 8601 week number for the week containing datetime.\n The ISO 8601 week number is the same for every day of the week (from\n Moday through Sunday). That can produce some unusual results\n (described below).\n The first week of the year is week 1. This is the week that contains\n the first Thursday of the year. Equivalently, this is the first week\n that has more than 4 of its days falling within the calendar year.\n The value 0 is never returned by this function. Days contained\n within a year but occuring before the first ISO 8601 week of that\n year are considered as being contained in the last week of the\n previous year. Similarly, the final days of a calendar year may be\n considered as being part of the first ISO 8601 week of the next year\n if 4 or more days of that week are contained within the new year.\n Since 2.26\n Returns: the ISO 8601 week number for datetime.\n\t \n",
"line" : 656}
,
{
"name" : "getDayOfWeek",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the ISO 8601 day of the week on which datetime falls (1 is\n Monday, 2 is Tuesday... 7 is Sunday).\n Since 2.26\n Returns: the day of the week\n\t \n",
"line" : 668}
,
{
"name" : "getDayOfYear",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the day of the year represented by datetime in the Gregorian\n calendar.\n Since 2.26\n Returns: the day of the year\n\t \n",
"line" : 680}
,
{
"name" : "getHour",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the hour of the day represented by datetime\n Since 2.26\n Returns: the hour of the day\n\t \n",
"line" : 691}
,
{
"name" : "getMinute",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the minute of the hour represented by datetime\n Since 2.26\n Returns: the minute of the hour\n\t \n",
"line" : 702}
,
{
"name" : "getSecond",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the second of the minute represented by datetime\n Since 2.26\n Returns: the second represented by datetime\n\t \n",
"line" : 713}
,
{
"name" : "getMicrosecond",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the microsecond of the date represented by datetime\n Since 2.26\n Returns: the microsecond of the second\n\t \n",
"line" : 724}
,
{
"name" : "getSeconds",
"kind" : "function",
"protection" : "public",
"type" : "double()",
"comment" : "\n Retrieves the number of seconds since the start of the last minute,\n including the fractional part.\n Since 2.26\n Returns: the number of seconds\n\t \n",
"line" : 736}
,
{
"name" : "toUnix",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n Gives the Unix time corresponding to datetime, rounding down to the\n nearest second.\n Unix time is the number of seconds that have elapsed since 1970-01-01\n 00:00:00 UTC, regardless of the time zone associated with datetime.\n Since 2.26\n Returns: the Unix time corresponding to datetime\n\t \n",
"line" : 750}
,
{
"name" : "toTimeval",
"kind" : "function",
"protection" : "public",
"type" : "int(TimeVal tv)",
"comment" : "\n Stores the instant in time that datetime represents into tv.\n The time contained in a GTimeVal is always stored in the form of\n seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time\n zone associated with datetime.\n On systems where 'long' is 32bit (ie: all 32bit systems and all\n Windows systems), a GTimeVal is incapable of storing the entire\n range of values that GDateTime is capable of expressing. On those\n systems, this function returns FALSE to indicate that the time is\n out of range.\n On systems where 'long' is 64bit, this function never fails.\n Since 2.26\n Params:\n tv = a GTimeVal to modify\n Returns: TRUE if successful, else FALSE\n\t \n",
"line" : 772}
,
{
"name" : "getUtcOffset",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n Determines the offset to UTC in effect at the time and in the time\n zone of datetime.\n The offset is the number of microseconds that you add to UTC time to\n arrive at local time for the time zone (ie: negative numbers for time\n zones west of GMT, positive numbers for east).\n If datetime represents UTC time, then the offset is always zero.\n Since 2.26\n Returns: the number of microseconds that should be added to UTC to get the local time\n\t \n",
"line" : 788}
,
{
"name" : "getTimezoneAbbreviation",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Determines the time zone abbreviation to be used at the time and in\n the time zone of datetime.\n For example, in Toronto this is currently \"EST\" during the winter\n months and \"EDT\" during the summer months when daylight savings\n time is in effect.\n Since 2.26\n Returns: the time zone abbreviation. The returned string is owned by the GDateTime and it should not be modified or freed. [transfer none]\n\t \n",
"line" : 803}
,
{
"name" : "isDaylightSavings",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if daylight savings time is in effect at the time and in\n the time zone of datetime.\n Since 2.26\n Returns: TRUE if daylight savings time is in effect\n\t \n",
"line" : 815}
,
{
"name" : "toTimezone",
"kind" : "function",
"protection" : "public",
"type" : "DateTime(TimeZone tz)",
"comment" : "\n Create a new GDateTime corresponding to the same instant in time as\n datetime, but in the time zone tz.\n This call can fail in the case that the time goes out of bounds. For\n example, converting 0001-01-01 00:00:00 UTC to a time zone west of\n Greenwich will fail (due to the year 0 being out of range).\n You should release the return value by calling g_date_time_unref()\n when you are done with it.\n Since 2.26\n Params:\n tz = the new GTimeZone\n Returns: a new GDateTime, or NULL\n\t \n",
"line" : 834}
,
{
"name" : "toLocal",
"kind" : "function",
"protection" : "public",
"type" : "DateTime()",
"comment" : "\n Creates a new GDateTime corresponding to the same instant in time as\n datetime, but in the local time zone.\n This call is equivalent to calling g_date_time_to_timezone() with the\n time zone returned by g_time_zone_new_local().\n Since 2.26\n Returns: the newly created GDateTime\n\t \n",
"line" : 853}
,
{
"name" : "toUtc",
"kind" : "function",
"protection" : "public",
"type" : "DateTime()",
"comment" : "\n Creates a new GDateTime corresponding to the same instant in time as\n datetime, but in UTC.\n This call is equivalent to calling g_date_time_to_timezone() with the\n time zone returned by g_time_zone_new_utc().\n Since 2.26\n Returns: the newly created GDateTime\n\t \n",
"line" : 872}
,
{
"name" : "format",
"kind" : "function",
"protection" : "public",
"type" : "string(string format)",
"comment" : "\n Creates a newly allocated string representing the requested format.\n Since 2.26\n Params:\n format = a valid UTF-8 string, containing the format for the\n  GDateTime\n Returns: a newly allocated string formatted to the requested format or NULL in the case that there was an error. The string should be freed with g_free().\n\t \n",
"line" : 891}
]
}
]
}
,
{
"name" : "glib.Directory",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Directory.d",
"members" : [
{
"name" : "Directory",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n There is a group of functions which wrap the common POSIX functions\n dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),\n g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these\n wrappers is to make it possible to handle file names with any Unicode\n characters in them on Windows without having to use ifdefs and the\n wide character API in the application code.\n The pathname argument should be in the GLib file name encoding. On\n POSIX this is the actual on-disk encoding which might correspond to\n the locale settings of the process (or the\n G_FILENAME_ENCODING environment variable), or not.\n On Windows the GLib file name encoding is UTF-8. Note that the\n Microsoft C library does not use UTF-8, but has separate APIs for\n current system code page and wide characters (UTF-16). The GLib\n wrappers call the wide character API if present (on modern Windows\n systems), otherwise convert to\/from the system code page.\n Another group of functions allows to open and read directories\n in the GLib file name encoding. These are g_dir_open(),\n g_dir_read_name(), g_dir_rewind(), g_dir_close().\n \n",
"line" : 92,
"base" : "Object",
"members" : [
{
"name" : "gDir",
"kind" : "variable",
"protection" : "protected",
"type" : "GDir*",
"comment" : " the main Gtk struct \n",
"line" : 95}
,
{
"name" : "getDirectoryStruct",
"kind" : "function",
"protection" : "public",
"type" : "GDir*()",
"line" : 98}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Directory(GDir* gDir)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 113}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "Directory(string path, uint flags)",
"comment" : "\n\t \n\n Opens a directory for reading. The names of the files in the\n directory can then be retrieved using g_dir_read_name(). Note\n that the ordering is not defined.\n Params:\n path = the path to the directory you are interested in. On Unix\n  in the on-disk encoding. On Windows in UTF-8\n flags = Currently must be set to 0. Reserved for future use.\n Returns: a newly allocated GDir on success, NULL on failure. If non-NULL, you must free the result with g_dir_close() when you are finished with it.\n Throws: GException on failure.\n\t \n",
"line" : 137}
,
{
"name" : "readName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Retrieves the name of another entry in the directory, or NULL.\n The order of entries returned from this function is not defined,\n and may vary by file system or other operating-system dependent\n factors.\n On Unix, the '.' and '..' entries are omitted, and the returned\n name is in the on-disk encoding.\n On Windows, as is true of all GLib functions which operate on\n filenames, the returned name is in UTF-8.\n Returns: The entry's name or NULL if there are no more entries. The return value is owned by GLib and must not be modified or freed.\n\t \n",
"line" : 167}
,
{
"name" : "rewind",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Resets the given directory. The next call to g_dir_read_name()\n will return the first entry again.\n\t \n",
"line" : 177}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Closes the directory and deallocates all related resources.\n\t \n",
"line" : 186}
]
}
]
}
,
{
"name" : "glib.ErrorG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ErrorG.d",
"members" : [
{
"name" : "ErrorG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GLib provides a standard method of reporting errors from a called function to\n the calling code. (This is the same problem solved by exceptions in other\n languages.) It's important to understand that this method is both a\n data type (the GError object) and a set of\n rules. If you use GError incorrectly, then your code will not\n properly interoperate with other code that uses GError, and users of your API\n will probably get confused.\n First and foremost: GError should only be used to report\n recoverable runtime errors, never to report programming errors. If\n the programmer has screwed up, then you should use g_warning(),\n g_return_if_fail(), g_assert(), g_error(), or some similar facility.\n (Incidentally, remember that the g_error() function should\n only be used for programming errors, it should not be used\n to print any error reportable via GError.)\n Examples of recoverable runtime errors are \"file not found\" or \"failed to parse\n input.\" Examples of programming errors are \"NULL passed to strcmp()\" or\n \"attempted to free the same pointer twice.\" These two kinds of errors are\n fundamentally different: runtime errors should be handled or reported to the\n user, programming errors should be eliminated by fixing the bug in the program.\n This is why most functions in GLib and GTK+ do not use the GError facility.\n Functions that can fail take a return location for a GError as their last argument.\n For example:\n $(DDOC_COMMENT example)\n If you pass a non-NULL value for the error argument, it should\n point to a location where an error can be placed. For example:\n $(DDOC_COMMENT example)\n Note that err != NULL in this example is a\n reliable indicator of whether\n g_file_get_contents() failed. Additionally, g_file_get_contents() returns\n a boolean which indicates whether it was successful.\n Because g_file_get_contents() returns FALSE on failure, if you are only\n interested in whether it failed and don't need to display an error message, you\n can pass NULL for the error argument:\n $(DDOC_COMMENT example)\n The GError object contains three fields: domain indicates\n the module the error-reporting function is located in, code\n indicates the specific error that occurred, and message is a\n user-readable error message with as many details as possible. Several functions\n are provided to deal with an error received from a called function:\n g_error_matches() returns TRUE if the error matches a given domain and code,\n g_propagate_error() copies an error into an error location (so the calling\n function will receive it), and g_clear_error() clears an error location by\n freeing the error and resetting the location to NULL. To display an error to the\n user, simply display error->message, perhaps along with\n additional context known only to the calling function (the file being opened, or\n whatever -- though in the g_file_get_contents() case,\n error->message already contains a filename).\n When implementing a function that can report errors, the basic tool is\n g_set_error(). Typically, if a fatal error occurs you want to g_set_error(),\n then return immediately. g_set_error() does nothing if the error location passed\n to it is NULL. Here's an example:\n $(DDOC_COMMENT example)\n Things are somewhat more complicated if you yourself call another function that\n can report a GError. If the sub-function indicates fatal errors in some way\n other than reporting a GError, such as by returning TRUE on success, you can\n simply do the following:\n $(DDOC_COMMENT example)\n If the sub-function does not indicate errors other than by reporting a GError,\n you need to create a temporary GError since the passed-in one may be NULL.\n g_propagate_error() is intended for use in this case.\n $(DDOC_COMMENT example)\n Error pileups are always a bug. For example, this code is incorrect:\n $(DDOC_COMMENT example)\n tmp_error should be checked immediately after\n sub_function_that_can_fail(), and either cleared or propagated upward. The rule\n is: after each error, you must either handle the error, or return it to the\n calling function. Note that passing NULL for the error location is the\n equivalent of handling an error by always doing nothing about it. So the\n following code is fine, assuming errors in sub_function_that_can_fail() are not\n fatal to my_function_that_can_fail():\n $(DDOC_COMMENT example)\n Note that passing NULL for the error location ignores\n errors; it's equivalent to try { sub_function_that_can_fail(); } catch\n (...) {} in C++. It does not mean to leave errors\n unhandled; it means to handle them by doing nothing.\n Error domains and codes are conventionally named as follows:\n The error domain is called\n <NAMESPACE>_<MODULE>_ERROR, for example\n G_SPAWN_ERROR or G_THREAD_ERROR:\n $(DDOC_COMMENT example)\n The quark function for the error domain is called <namespace>_<module>_error_quark, for example g_spawn_error_quark() or %g_thread_error_quark().\n The error codes are in an enumeration called\n <Namespace><Module>Error; for example,\n GThreadError or GSpawnError.\n Members of the error code enumeration are called <NAMESPACE>_<MODULE>_ERROR_<CODE>, for example G_SPAWN_ERROR_FORK or G_THREAD_ERROR_AGAIN.\n If there's a \"generic\" or \"unknown\" error code for unrecoverable errors it\n doesn't make sense to distinguish with specific codes, it should be called\n <NAMESPACE>_<MODULE>_ERROR_FAILED, for\n example G_SPAWN_ERROR_FAILED or G_THREAD_ERROR_FAILED.\n Summary of rules for use of GError:\n  Do not report programming errors via GError.\n  The last argument of a function that returns an error should be a\n  location where a GError can be placed (i.e. \"GError** error\"). If\n  GError is used with varargs, the GError** should be the last\n  argument before the \"...\".\n  The caller may pass NULL for the GError** if they are not interested\n  in details of the exact error that occurred.\n  If NULL is passed for the GError** argument, then errors should\n  not be returned to the caller, but your function should still\n  abort and return if an error occurs. That is, control flow should\n  not be affected by whether the caller wants to get a GError.\n  If a GError is reported, then your function by definition\n  had a fatal failure and did not complete whatever it was supposed\n  to do. If the failure was not fatal, then you handled it\n  and you should not report it. If it was fatal, then you must report it\n  and discontinue whatever you were doing immediately.\n  A GError* must be initialized to NULL before passing its address to\n  a function that can report errors.\n  \"Piling up\" errors is always a bug. That is, if you assign a new\n  GError to a GError* that is non-NULL, thus overwriting the previous\n  error, it indicates that you should have aborted the operation instead\n  of continuing. If you were able to continue, you should have cleared\n  the previous error with g_clear_error(). g_set_error() will complain\n  if you pile up errors.\n  By convention, if you return a boolean value indicating success\n  then TRUE means success and FALSE means failure. If FALSE is returned,\n  the error must be set to a non-NULL value.\n  A NULL return value is also frequently used to mean that an error\n  occurred. You should make clear in your documentation whether NULL is\n  a valid return value in non-error cases; if NULL is a valid value,\n  then users must check whether an error was returned to see if the\n  function succeeded.\n  When implementing a function that can report errors, you may want to\n  add a check at the top of your function that the error return location\n  is either NULL or contains a NULL error\n  (e.g. g_return_if_fail (error == NULL || *error ==\n  NULL);).\n \n",
"line" : 197,
"base" : "Object",
"members" : [
{
"name" : "gError",
"kind" : "variable",
"protection" : "protected",
"type" : "GError*",
"comment" : " the main Gtk struct \n",
"line" : 200}
,
{
"name" : "getErrorGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GError*()",
"line" : 203}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 210}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ErrorG(GError* gError)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 218}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ErrorG(uint domain, int code, string message)",
"comment" : "\n\t \n\n Creates a new GError; unlike g_error_new(), message is\n not a printf()-style format string. Use this function if\n message contains text you don't have control over,\n that could include printf() escape sequences.\n Params:\n domain = error domain\n code = error code\n message = error message\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 242}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ErrorG(uint domain, int code, string format, void* args)",
"comment" : "\n Creates a new GError with the given domain and code,\n and a message formatted with format.\n Since 2.22\n Params:\n domain = error domain\n code = error code\n format = printf()-style format for error message\n args = va_list of parameters for the message format\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 264}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a GError and associated resources.\n\t \n",
"line" : 278}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "ErrorG()",
"comment" : "\n Makes a copy of error.\n Returns: a new GError\n\t \n",
"line" : 288}
,
{
"name" : "matches",
"kind" : "function",
"protection" : "public",
"type" : "int(uint domain, int code)",
"comment" : "\n Returns TRUE if error matches domain and code, FALSE\n otherwise. In particular, when error is NULL, FALSE will\n be returned.\n Params:\n domain = an error domain\n code = an error code\n Returns: whether error has domain and code\n\t \n",
"line" : 308}
,
{
"name" : "gSetErrorLiteral",
"kind" : "function",
"protection" : "public",
"type" : "void(out ErrorG err, uint domain, int code, string message)",
"comment" : "\n Does nothing if err is NULL; if err is non-NULL, then *err\n must be NULL. A new GError is created and assigned to *err.\n Unlike g_set_error(), message is not a printf()-style format string.\n Use this function if message contains text you don't have control over,\n that could include printf() escape sequences.\n Since 2.18\n Params:\n err = a return location for a GError, or NULL\n domain = error domain\n code = error code\n message = error message\n\t \n",
"line" : 327}
,
{
"name" : "gPropagateError",
"kind" : "function",
"protection" : "public",
"type" : "void(out ErrorG dest, ErrorG src)",
"comment" : "\n If dest is NULL, free src; otherwise, moves src into *dest.\n The error variable dest points to must be NULL.\n Params:\n dest = error return location\n src = error to move into the return location\n\t \n",
"line" : 344}
,
{
"name" : "gClearError",
"kind" : "function",
"protection" : "public",
"type" : "void(ref ErrorG err)",
"comment" : "\n If err is NULL, does nothing. If err is non-NULL,\n calls g_error_free() on *err and sets *err to NULL.\n Params:\n err = a GError return location\n\t \n",
"line" : 360}
]
}
]
}
,
{
"name" : "glib.FileUtils",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/FileUtils.d",
"members" : [
{
"name" : "FileUtils",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n There is a group of functions which wrap the common POSIX functions\n dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),\n g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these\n wrappers is to make it possible to handle file names with any Unicode\n characters in them on Windows without having to use ifdefs and the\n wide character API in the application code.\n The pathname argument should be in the GLib file name encoding. On\n POSIX this is the actual on-disk encoding which might correspond to\n the locale settings of the process (or the\n G_FILENAME_ENCODING environment variable), or not.\n On Windows the GLib file name encoding is UTF-8. Note that the\n Microsoft C library does not use UTF-8, but has separate APIs for\n current system code page and wide characters (UTF-16). The GLib\n wrappers call the wide character API if present (on modern Windows\n systems), otherwise convert to\/from the system code page.\n Another group of functions allows to open and read directories\n in the GLib file name encoding. These are g_dir_open(),\n g_dir_read_name(), g_dir_rewind(), g_dir_close().\n \n",
"line" : 100,
"base" : "Object",
"members" : [
{
"name" : "fileErrorFromErrno",
"kind" : "function",
"protection" : "public",
"type" : "GFileError(int errNo)",
"comment" : "\n\t \n\n Gets a GFileError constant based on the passed-in errno.\n For example, if you pass in EEXIST this function returns\n G_FILE_ERROR_EXIST. Unlike errno values, you can portably\n assume that all GFileError values will exist.\n Normally a GFileError value goes into a GError returned\n from a function that manipulates files. So you would use\n g_file_error_from_errno() when constructing a GError.\n Params:\n errNo = an \"errno\" value\n Returns: GFileError corresponding to the given errno\n\t \n",
"line" : 117}
,
{
"name" : "fileGetContents",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, out string contents, out ulong length)",
"comment" : "\n Reads an entire file into allocated memory, with good error\n checking.\n If the call was successful, it returns TRUE and sets contents to the file\n contents and length to the length of the file contents in bytes. The string\n stored in contents will be nul-terminated, so for text files you can pass\n NULL for the length argument. If the call was not successful, it returns\n FALSE and sets error. The error domain is G_FILE_ERROR. Possible error\n codes are those in the GFileError enumeration. In the error case,\n contents is set to NULL and length is set to zero.\n Params:\n filename = name of a file to read contents from, in the GLib file name encoding\n contents = location to store an allocated string, use g_free() to free\n  the returned string\n length = location to store length in bytes of the contents, or NULL\n Returns: TRUE on success, FALSE if an error occurred\n Throws: GException on failure.\n\t \n",
"line" : 141}
,
{
"name" : "fileSetContents",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, string contents, long length)",
"comment" : "\n Writes all of contents to a file named filename, with good error checking.\n If a file called filename already exists it will be overwritten.\n This write is atomic in the sense that it is first written to a temporary\n Since 2.8\n Params:\n filename = name of a file to write contents to, in the GLib file name\n  encoding\n contents = string to write to the file\n length = length of contents, or -1 if contents is a nul-terminated string\n Returns: TRUE on success, FALSE if an error occurred\n Throws: GException on failure.\n\t \n",
"line" : 171}
,
{
"name" : "fileTest",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, GFileTest test)",
"comment" : "\n Returns TRUE if any of the tests in the bitfield test are\n TRUE. For example, (G_FILE_TEST_EXISTS |\n G_FILE_TEST_IS_DIR) will return TRUE if the file exists;\n the check whether it's a directory doesn't matter since the existence\n test is TRUE. With the current set of available tests, there's no point\n passing in more than one test at a time.\n Apart from G_FILE_TEST_IS_SYMLINK all tests follow symbolic links,\n so for a symbolic link to a regular file g_file_test() will return\n TRUE for both G_FILE_TEST_IS_SYMLINK and G_FILE_TEST_IS_REGULAR.\n Note, that for a dangling symbolic link g_file_test() will return\n TRUE for G_FILE_TEST_IS_SYMLINK and FALSE for all other flags.\n You should never use g_file_test() to test whether it is safe\n to perform an operation, because there is always the possibility\n of the condition changing before you actually perform the operation.\n For example, you might think you could use G_FILE_TEST_IS_SYMLINK\n to know whether it is safe to write to a file without being\n tricked into writing into a different location. It doesn't work!\n $(DDOC_COMMENT example)\n Another thing to note is that G_FILE_TEST_EXISTS and\n G_FILE_TEST_IS_EXECUTABLE are implemented using the access()\n system call. This usually doesn't matter, but if your program\n is setuid or setgid it means that these tests will give you\n the answer for the real user ID and group ID, rather than the\n effective user ID and group ID.\n On Windows, there are no symlinks, so testing for\n G_FILE_TEST_IS_SYMLINK will always return FALSE. Testing for\n G_FILE_TEST_IS_EXECUTABLE will just check that the file exists and\n its name indicates that it is executable, checking for well-known\n extensions and those listed in the PATHEXT environment variable.\n Params:\n filename = a filename to test in the GLib file name encoding\n test = bitfield of GFileTest flags\n Returns: whether a test was TRUE\n\t \n",
"line" : 221}
,
{
"name" : "mkstemp",
"kind" : "function",
"protection" : "public",
"type" : "int(string tmpl)",
"comment" : "\n Opens a temporary file. See the mkstemp() documentation\n on most UNIX-like systems.\n The parameter is a string that should follow the rules for\n mkstemp() templates, i.e. contain the string \"XXXXXX\".\n g_mkstemp() is slightly more flexible than mkstemp()\n in that the sequence does not have to occur at the very end of the\n template. The X string will\n be modified to form the name of a file that didn't exist.\n The string should be in the GLib file name encoding. Most importantly,\n on Windows it should be in UTF-8.\n Params:\n tmpl = template filename\n Returns: A file handle (as from open()) to the file opened for reading and writing. The file is opened in binary mode on platforms where there is a difference. The file handle should be closed with close(). In case of errors, -1 is returned.\n\t \n",
"line" : 242}
,
{
"name" : "mkstempFull",
"kind" : "function",
"protection" : "public",
"type" : "int(string tmpl, int flags, int mode)",
"comment" : "\n Opens a temporary file. See the mkstemp() documentation\n on most UNIX-like systems.\n The parameter is a string that should follow the rules for\n mkstemp() templates, i.e. contain the string \"XXXXXX\".\n g_mkstemp_full() is slightly more flexible than mkstemp()\n in that the sequence does not have to occur at the very end of the\n template and you can pass a mode and additional flags. The X\n string will be modified to form the name of a file that didn't exist.\n The string should be in the GLib file name encoding. Most importantly,\n on Windows it should be in UTF-8.\n Since 2.22\n Params:\n tmpl = template filename\n flags = flags to pass to an open() call in addition to O_EXCL and\n  O_CREAT, which are passed automatically\n mode = permissios to create the temporary file with\n Returns: A file handle (as from open()) to the file opened for reading and writing. The file handle should be closed with close(). In case of errors, -1 is returned.\n\t \n",
"line" : 267}
,
{
"name" : "fileOpenTmp",
"kind" : "function",
"protection" : "public",
"type" : "int(string tmpl, out string nameUsed)",
"comment" : "\n Opens a file for writing in the preferred directory for temporary\n files (as returned by g_get_tmp_dir()).\n tmpl should be a string in the GLib file name encoding containing\n a sequence of six 'X' characters, as the parameter to g_mkstemp().\n However, unlike these functions, the template should only be a\n basename, no directory components are allowed. If template is\n NULL, a default template is used.\n Note that in contrast to g_mkstemp() (and mkstemp())\n tmpl is not modified, and might thus be a read-only literal string.\n The actual name used is returned in name_used if non-NULL. This\n string should be freed with g_free() when not needed any longer.\n The returned name is in the GLib file name encoding.\n Params:\n tmpl = Template for file name, as in g_mkstemp(), basename only,\n  or NULL, to a default template\n nameUsed = location to store actual name used, or NULL\n Returns: A file handle (as from open()) to the file opened for reading and writing. The file is opened in binary mode on platforms where there is a difference. The file handle should be closed with close(). In case of errors, -1 is returned and error will be set.\n Throws: GException on failure.\n\t \n",
"line" : 293}
,
{
"name" : "fileReadLink",
"kind" : "function",
"protection" : "public",
"type" : "string(string filename)",
"comment" : "\n Reads the contents of the symbolic link filename like the POSIX\n readlink() function. The returned string is in the encoding used\n for filenames. Use g_filename_to_utf8() to convert it to UTF-8.\n Since 2.4\n Params:\n filename = the symbolic link\n Returns: A newly-allocated string with the contents of the symbolic link, or NULL if an error occurred.\n Throws: GException on failure.\n\t \n",
"line" : 320}
,
{
"name" : "mkdirWithParents",
"kind" : "function",
"protection" : "public",
"type" : "int(string pathname, int mode)",
"comment" : "\n Create a directory if it doesn't already exist. Create intermediate\n parent directories as needed, too.\n Since 2.8\n Params:\n pathname = a pathname in the GLib file name encoding\n mode = permissions to use for newly created directories\n Returns: 0 if the directory already exists, or was successfully created. Returns -1 if an error occurred, with errno set.\n\t \n",
"line" : 344}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, int flags, int mode)",
"comment" : "\n A wrapper for the POSIX open() function. The open() function is\n used to convert a pathname into a file descriptor.\n On POSIX systems file descriptors are implemented by the operating\n system. On Windows, it's the C library that implements open() and\n file descriptors. The actual Win32 API for opening files is quite\n different, see MSDN documentation for CreateFile(). The Win32 API\n uses file handles, which are more randomish integers, not small\n integers like file descriptors.\n Because file descriptors are specific to the C library on Windows,\n the file descriptor returned by this function makes sense only to\n functions in the same C library. Thus if the GLib-using code uses a\n different C library than GLib does, the file descriptor returned by\n this function cannot be passed to C library functions like write()\n or read().\n See your C library manual for more details about open().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n flags = as in open()\n mode = as in open()\n Returns: a new file descriptor, or -1 if an error occurred. The return value can be used exactly like the return value from open().\n\t \n",
"line" : 373}
,
{
"name" : "rename",
"kind" : "function",
"protection" : "public",
"type" : "int(string oldfilename, string newfilename)",
"comment" : "\n A wrapper for the POSIX rename() function. The rename() function\n renames a file, moving it between directories if required.\n See your C library manual for more details about how rename() works\n on your system. It is not possible in general on Windows to rename\n a file that is open to some process.\n Since 2.6\n Params:\n oldfilename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n newfilename = a pathname in the GLib file name encoding\n Returns: 0 if the renaming succeeded, -1 if an error occurred\n\t \n",
"line" : 391}
,
{
"name" : "mkdir",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, int mode)",
"comment" : "\n A wrapper for the POSIX mkdir() function. The mkdir() function\n attempts to create a directory with the given name and permissions.\n The mode argument is ignored on Windows.\n See your C library manual for more details about mkdir().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n mode = permissions to use for the newly created directory\n Returns: 0 if the directory was successfully created, -1 if an error occurred\n\t \n",
"line" : 408}
,
{
"name" : "stat",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, void* buf)",
"comment" : "\n A wrapper for the POSIX stat() function. The stat() function\n returns information about a file. On Windows the stat() function in\n the C library checks only the FAT-style READONLY attribute and does\n not look at the ACL at all. Thus on Windows the protection bits in\n the st_mode field are a fabrication of little use.\n On Windows the Microsoft C libraries have several variants of the\n stat struct and stat() function with names\n like \"_stat\", \"_stat32\", \"_stat32i64\" and \"_stat64i32\". The one\n used here is for 32-bit code the one with 32-bit size and time\n fields, specifically called \"_stat32\".\n In Microsoft's compiler, by default \"struct stat\" means one with\n 64-bit time fields while in MinGW \"struct stat\" is the legacy one\n with 32-bit fields. To hopefully clear up this messs, the gstdio.h\n header defines a type GStatBuf which is the appropriate struct type\n depending on the platform and\/or compiler being used. On POSIX it\n is just \"struct stat\", but note that even on POSIX platforms,\n \"stat\" might be a macro.\n See your C library manual for more details about stat().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n buf = a pointer to a stat struct, which\n  will be filled with the file information\n Returns: 0 if the information was successfully retrieved, -1 if an error occurred\n\t \n",
"line" : 440}
,
{
"name" : "lstat",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, void* buf)",
"comment" : "\n A wrapper for the POSIX lstat() function. The lstat() function is\n like stat() except that in the case of symbolic links, it returns\n information about the symbolic link itself and not the file that it\n refers to. If the system does not support symbolic links g_lstat()\n is identical to g_stat().\n See your C library manual for more details about lstat().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n buf = a pointer to a stat struct, which\n  will be filled with the file information\n Returns: 0 if the information was successfully retrieved, -1 if an error occurred\n\t \n",
"line" : 460}
,
{
"name" : "unlink",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename)",
"comment" : "\n A wrapper for the POSIX unlink() function. The unlink() function\n deletes a name from the filesystem. If this was the last link to the\n file and no processes have it opened, the diskspace occupied by the\n file is freed.\n See your C library manual for more details about unlink(). Note\n that on Windows, it is in general not possible to delete files that\n are open to some process, or mapped into memory.\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n Returns: 0 if the name was successfully deleted, -1 if an error occurred\n\t \n",
"line" : 479}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename)",
"comment" : "\n A wrapper for the POSIX remove() function. The remove() function\n deletes a name from the filesystem.\n See your C library manual for more details about how remove() works\n on your system. On Unix, remove() removes also directories, as it\n calls unlink() for files and rmdir() for directories. On Windows,\n although remove() in the C library only works for files, this\n function tries first remove() and then if that fails rmdir(), and\n thus works for both files and directories. Note however, that on\n Windows, it is in general not possible to remove a file that is\n open to some process, or mapped into memory.\n If this function fails on Windows you can't infer too much from the\n errno value. rmdir() is tried regardless of what caused remove() to\n fail. Any errno value set by remove() will be overwritten by that\n set by rmdir().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n Returns: 0 if the file was successfully removed, -1 if an error occurred\n\t \n",
"line" : 505}
,
{
"name" : "rmdir",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename)",
"comment" : "\n A wrapper for the POSIX rmdir() function. The rmdir() function\n deletes a directory from the filesystem.\n See your C library manual for more details about how rmdir() works\n on your system.\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n Returns: 0 if the directory was successfully removed, -1 if an error occurred\n\t \n",
"line" : 521}
,
{
"name" : "fopen",
"kind" : "function",
"protection" : "public",
"type" : "shared(_iobuf)*(string filename, string mode)",
"comment" : "\n A wrapper for the stdio fopen() function. The fopen() function\n opens a file and associates a new stream with it.\n Because file descriptors are specific to the C library on Windows,\n and a file descriptor is partof the FILE struct, the\n FILE pointer returned by this function makes sense\n only to functions in the same C library. Thus if the GLib-using\n code uses a different C library than GLib does, the\n FILE pointer returned by this function cannot be\n passed to C library functions like fprintf() or fread().\n See your C library manual for more details about fopen().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n mode = a string describing the mode in which the file should be\n  opened\n Returns: A FILE pointer if the file was successfully opened, or NULL if an error occurred\n\t \n",
"line" : 545}
,
{
"name" : "freopen",
"kind" : "function",
"protection" : "public",
"type" : "shared(_iobuf)*(string filename, string mode, shared(_iobuf)* stream)",
"comment" : "\n A wrapper for the POSIX freopen() function. The freopen() function\n opens a file and associates it with an existing stream.\n See your C library manual for more details about freopen().\n Since 2.6\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n mode = a string describing the mode in which the file should be\n  opened\n stream = an existing stream which will be reused, or NULL\n Returns: A FILE pointer if the file was successfully opened, or NULL if an error occurred.\n\t \n",
"line" : 563}
,
{
"name" : "chmod",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, int mode)",
"comment" : "\n A wrapper for the POSIX chmod() function. The chmod() function is\n used to set the permissions of a file system object.\n On Windows the file protection mechanism is not at all POSIX-like,\n and the underlying chmod() function in the C library just sets or\n clears the FAT-style READONLY attribute. It does not touch any\n ACL. Software that needs to manage file permissions on Windows\n exactly should use the Win32 API.\n See your C library manual for more details about chmod().\n Since 2.8\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n mode = as in chmod()\n Returns: zero if the operation succeeded, -1 on error.\n\t \n",
"line" : 584}
,
{
"name" : "access",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, int mode)",
"comment" : "\n A wrapper for the POSIX access() function. This function is used to\n test a pathname for one or several of read, write or execute\n permissions, or just existence.\n On Windows, the file protection mechanism is not at all POSIX-like,\n and the underlying function in the C library only checks the\n FAT-style READONLY attribute, and does not look at the ACL of a\n file at all. This function is this in practise almost useless on\n Windows. Software that needs to handle file permissions on Windows\n more exactly should use the Win32 API.\n See your C library manual for more details about access().\n Since 2.8\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n mode = as in access()\n Returns: zero if the pathname refers to an existing file system object that has all the tested permissions, or -1 otherwise or on error.\n\t \n",
"line" : 607}
,
{
"name" : "creat",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, int mode)",
"comment" : "\n A wrapper for the POSIX creat() function. The creat() function is\n used to convert a pathname into a file descriptor, creating a file\n if necessary.\n On POSIX systems file descriptors are implemented by the operating\n system. On Windows, it's the C library that implements creat() and\n file descriptors. The actual Windows API for opening files is\n different, see MSDN documentation for CreateFile(). The Win32 API\n uses file handles, which are more randomish integers, not small\n integers like file descriptors.\n Because file descriptors are specific to the C library on Windows,\n the file descriptor returned by this function makes sense only to\n functions in the same C library. Thus if the GLib-using code uses a\n different C library than GLib does, the file descriptor returned by\n this function cannot be passed to C library functions like write()\n or read().\n See your C library manual for more details about creat().\n Since 2.8\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n mode = as in creat()\n Returns: a new file descriptor, or -1 if an error occurred. The return value can be used exactly like the return value from creat().\n\t \n",
"line" : 636}
,
{
"name" : "chdir",
"kind" : "function",
"protection" : "public",
"type" : "int(string path)",
"comment" : "\n A wrapper for the POSIX chdir() function. The function changes the\n current directory of the process to path.\n See your C library manual for more details about chdir().\n Since 2.8\n Params:\n path = a pathname in the GLib file name encoding (UTF-8 on Windows)\n Returns: 0 on success, -1 if an error occurred.\n\t \n",
"line" : 651}
,
{
"name" : "utime",
"kind" : "function",
"protection" : "public",
"type" : "int(string filename, void* utb)",
"comment" : "\n A wrapper for the POSIX utime() function. The utime() function\n sets the access and modification timestamps of a file.\n See your C library manual for more details about how utime() works\n on your system.\n Since 2.18\n Params:\n filename = a pathname in the GLib file name encoding (UTF-8 on Windows)\n utb = a pointer to a struct utimbuf.\n Returns: 0 if the operation was successful, -1 if an error occurred\n\t \n",
"line" : 668}
]
}
]
}
,
{
"name" : "glib.GException",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/GException.d",
"members" : [
{
"name" : "GException",
"kind" : "class",
"protection" : "public",
"line" : 68,
"base" : "Exception",
"members" : [
{
"name" : "error",
"kind" : "variable",
"protection" : "public",
"type" : "glib.ErrorG.ErrorG",
"line" : 70}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "GException(ErrorG error)",
"line" : 72}
]
}
]
}
,
{
"name" : "glib.GLib",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/GLib.d",
"members" : [
{
"name" : "Version",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GLib provides version information, primarily useful in configure checks\n for builds that have a configure script. Applications will not\n typically use the features described here.\n \n",
"line" : 72,
"base" : "Object",
"members" : [
]
}
]
}
,
{
"name" : "glib.HashTable",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/HashTable.d",
"members" : [
{
"name" : "HashTable",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GHashTable provides associations between keys and values which is\n optimized so that given a key, the associated value can be found\n very quickly.\n Note that neither keys nor values are copied when inserted into the\n GHashTable, so they must exist for the lifetime of the GHashTable.\n This means that the use of static strings is OK, but temporary\n strings (i.e. those created in buffers and those returned by GTK+\n widgets) should be copied with g_strdup() before being inserted.\n If keys or values are dynamically allocated, you must be careful to\n ensure that they are freed when they are removed from the\n GHashTable, and also when they are overwritten by new insertions\n into the GHashTable. It is also not advisable to mix static strings\n and dynamically-allocated strings in a GHashTable, because it then\n becomes difficult to determine whether the string should be freed.\n To create a GHashTable, use g_hash_table_new().\n To insert a key and value into a GHashTable, use\n g_hash_table_insert().\n To lookup a value corresponding to a given key, use\n g_hash_table_lookup() and g_hash_table_lookup_extended().\n To remove a key and value, use g_hash_table_remove().\n To call a function for each key and value pair use\n g_hash_table_foreach() or use a iterator to iterate over the\n key\/value pairs in the hash table, see GHashTableIter.\n To destroy a GHashTable use g_hash_table_destroy().\n \n",
"line" : 99,
"base" : "Object",
"members" : [
{
"name" : "gHashTable",
"kind" : "variable",
"protection" : "protected",
"type" : "GHashTable*",
"comment" : " the main Gtk struct \n",
"line" : 102}
,
{
"name" : "getHashTableStruct",
"kind" : "function",
"protection" : "public",
"type" : "GHashTable*()",
"line" : 105}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 112}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HashTable(GHashTable* gHashTable)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 120}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HashTable(extern (C) uint function(void*) hashFunc, extern (C) int function(void*, void*) keyEqualFunc)",
"comment" : "\n\t \n\n Creates a new GHashTable with a reference count of 1.\n Params:\n hashFunc = a function to create a hash value from a key.\n  Hash values are used to determine where keys are stored within the\n  GHashTable data structure. The g_direct_hash(), g_int_hash(),\n  g_int64_hash(), g_double_hash() and g_str_hash() functions are provided\n  for some common types of keys.\n  If hash_func is NULL, g_direct_hash() is used.\n keyEqualFunc = a function to check two keys for equality. This is\n  used when looking up keys in the GHashTable. The g_direct_equal(),\n  g_int_equal(), g_int64_equal(), g_double_equal() and g_str_equal()\n  functions are provided for the most common types of keys.\n  If key_equal_func is NULL, keys are compared directly in a similar\n  fashion to g_direct_equal(), but without the overhead of a function call.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 150}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HashTable(extern (C) uint function(void*) hashFunc, extern (C) int function(void*, void*) keyEqualFunc, extern (C) void function(void* cbData) keyDestroyFunc, extern (C) void function(void* cbData) valueDestroyFunc)",
"comment" : "\n Creates a new GHashTable like g_hash_table_new() with a reference count\n of 1 and allows to specify functions to free the memory allocated for the\n key and value that get called when removing the entry from the GHashTable.\n Params:\n hashFunc = a function to create a hash value from a key.\n keyEqualFunc = a function to check two keys for equality.\n keyDestroyFunc = a function to free the memory allocated for the key\n  used when removing the entry from the GHashTable or NULL if you\n  don't want to supply such a function.\n valueDestroyFunc = a function to free the memory allocated for the\n  value used when removing the entry from the GHashTable or NULL if\n  you don't want to supply such a function.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 176}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "void(void* key, void* value)",
"comment" : "\n Inserts a new key and value into a GHashTable.\n If the key already exists in the GHashTable its current value is replaced\n with the new value. If you supplied a value_destroy_func when creating the\n GHashTable, the old value is freed using that function. If you supplied\n a key_destroy_func when creating the GHashTable, the passed key is freed\n using that function.\n Params:\n key = a key to insert.\n value = the value to associate with the key.\n\t \n",
"line" : 198}
,
{
"name" : "replace",
"kind" : "function",
"protection" : "public",
"type" : "void(void* key, void* value)",
"comment" : "\n Inserts a new key and value into a GHashTable similar to\n g_hash_table_insert(). The difference is that if the key already exists\n in the GHashTable, it gets replaced by the new key. If you supplied a\n value_destroy_func when creating the GHashTable, the old value is freed\n using that function. If you supplied a key_destroy_func when creating the\n GHashTable, the old key is freed using that function.\n Params:\n key = a key to insert.\n value = the value to associate with the key.\n\t \n",
"line" : 215}
,
{
"name" : "size",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the number of elements contained in the GHashTable.\n Returns: the number of key\/value pairs in the GHashTable.\n\t \n",
"line" : 225}
,
{
"name" : "lookup",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* key)",
"comment" : "\n Looks up a key in a GHashTable. Note that this function cannot\n distinguish between a key that is not present and one which is present\n and has the value NULL. If you need this distinction, use\n g_hash_table_lookup_extended().\n Params:\n key = the key to look up.\n Returns: the associated value, or NULL if the key is not found.\n\t \n",
"line" : 240}
,
{
"name" : "lookupExtended",
"kind" : "function",
"protection" : "public",
"type" : "int(void* lookupKey, void** origKey, void** value)",
"comment" : "\n Looks up a key in the GHashTable, returning the original key and the\n associated value and a gboolean which is TRUE if the key was found. This\n is useful if you need to free the memory allocated for the original key,\n for example before calling g_hash_table_remove().\n You can actually pass NULL for lookup_key to test\n whether the NULL key exists.\n Params:\n lookupKey = the key to look up\n origKey = return location for the original key, or NULL\n value = return location for the value associated with the key, or NULL\n Returns: TRUE if the key was found in the GHashTable.\n\t \n",
"line" : 259}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each of the key\/value pairs in the\n GHashTable. The function is passed the key and value of each\n pair, and the given user_data parameter. The hash table may not\n be modified while iterating over it (you can't add\/remove\n items). To remove all items matching a predicate, use\n g_hash_table_foreach_remove().\n See g_hash_table_find() for performance caveats for linear\n order searches in contrast to g_hash_table_lookup().\n Params:\n func = the function to call for each key\/value pair.\n userData = user data to pass to the function.\n\t \n",
"line" : 278}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "void*(extern (C) int function(void*, void*, void*) predicate, void* userData)",
"comment" : "\n Calls the given function for key\/value pairs in the GHashTable until\n predicate returns TRUE. The function is passed the key and value of\n each pair, and the given user_data parameter. The hash table may not\n be modified while iterating over it (you can't add\/remove items).\n Note, that hash tables are really only optimized for forward lookups,\n i.e. g_hash_table_lookup().\n So code that frequently issues g_hash_table_find() or\n g_hash_table_foreach() (e.g. in the order of once per every entry in a\n hash table) should probably be reworked to use additional or different\n data structures for reverse lookups (keep in mind that an O(n) find\/foreach\n operation issued for all n values in a hash table ends up needing O(n*n)\n operations).\n Since 2.4\n Params:\n predicate = function to test the key\/value pairs for a certain property.\n userData = user data to pass to the function.\n Returns: The value of the first key\/value pair is returned, for which func evaluates to TRUE. If no pair with the requested property is found, NULL is returned.\n\t \n",
"line" : 303}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "int(void* key)",
"comment" : "\n Removes a key and its associated value from a GHashTable.\n If the GHashTable was created using g_hash_table_new_full(), the\n key and value are freed using the supplied destroy functions, otherwise\n you have to make sure that any dynamically allocated values are freed\n yourself.\n Params:\n key = the key to remove.\n Returns: TRUE if the key was found and removed from the GHashTable.\n\t \n",
"line" : 319}
,
{
"name" : "steal",
"kind" : "function",
"protection" : "public",
"type" : "int(void* key)",
"comment" : "\n Removes a key and its associated value from a GHashTable without\n calling the key and value destroy functions.\n Params:\n key = the key to remove.\n Returns: TRUE if the key was found and removed from the GHashTable.\n\t \n",
"line" : 332}
,
{
"name" : "foreachRemove",
"kind" : "function",
"protection" : "public",
"type" : "uint(extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each key\/value pair in the GHashTable.\n If the function returns TRUE, then the key\/value pair is removed from the\n GHashTable. If you supplied key or value destroy functions when creating\n the GHashTable, they are used to free the memory allocated for the removed\n keys and values.\n See GHashTableIter for an alternative way to loop over the\n key\/value pairs in the hash table.\n Params:\n func = the function to call for each key\/value pair.\n userData = user data to pass to the function.\n Returns: the number of key\/value pairs removed.\n\t \n",
"line" : 351}
,
{
"name" : "foreachSteal",
"kind" : "function",
"protection" : "public",
"type" : "uint(extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each key\/value pair in the GHashTable.\n If the function returns TRUE, then the key\/value pair is removed from the\n GHashTable, but no key or value destroy functions are called.\n See GHashTableIter for an alternative way to loop over the\n key\/value pairs in the hash table.\n Params:\n func = the function to call for each key\/value pair.\n userData = user data to pass to the function.\n Returns: the number of key\/value pairs removed.\n\t \n",
"line" : 368}
,
{
"name" : "removeAll",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes all keys and their associated values from a GHashTable.\n If the GHashTable was created using g_hash_table_new_full(), the keys\n and values are freed using the supplied destroy functions, otherwise you\n have to make sure that any dynamically allocated values are freed\n yourself.\n Since 2.12\n\t \n",
"line" : 382}
,
{
"name" : "stealAll",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes all keys and their associated values from a GHashTable\n without calling the key and value destroy functions.\n Since 2.12\n\t \n",
"line" : 393}
,
{
"name" : "getKeys",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Retrieves every key inside hash_table. The returned data is valid\n until hash_table is modified.\n Since 2.14\n Returns: a GList containing all the keys inside the hash table. The content of the list is owned by the hash table and should not be modified or freed. Use g_list_free() when done using the list.\n\t \n",
"line" : 405}
,
{
"name" : "getValues",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Retrieves every value inside hash_table. The returned data is\n valid until hash_table is modified.\n Since 2.14\n Returns: a GList containing all the values inside the hash table. The content of the list is owned by the hash table and should not be modified or freed. Use g_list_free() when done using the list.\n\t \n",
"line" : 422}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Destroys all keys and values in the GHashTable and decrements its\n reference count by 1. If keys and\/or values are dynamically allocated,\n you should either free them first or create the GHashTable with destroy\n notifiers using g_hash_table_new_full(). In the latter case the destroy\n functions you supplied will be called on all keys and values during the\n destruction phase.\n\t \n",
"line" : 441}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "HashTable()",
"comment" : "\n Atomically increments the reference count of hash_table by one.\n This function is MT-safe and may be called from any thread.\n Since 2.10\n Returns: the passed in GHashTable.\n\t \n",
"line" : 453}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Atomically decrements the reference count of hash_table by one.\n If the reference count drops to 0, all keys and values will be\n destroyed, and all memory allocated by the hash table is released.\n This function is MT-safe and may be called from any thread.\n Since 2.10\n\t \n",
"line" : 471}
,
{
"name" : "gDirectEqual",
"kind" : "function",
"protection" : "public",
"type" : "int(void* v1, void* v2)",
"comment" : "\n Compares two gpointer arguments and returns TRUE if they are equal.\n It can be passed to g_hash_table_new() as the key_equal_func\n parameter, when using pointers as keys in a GHashTable.\n Params:\n v1 = a key.\n v2 = a key to compare with v1.\n Returns: TRUE if the two keys match.\n\t \n",
"line" : 486}
,
{
"name" : "gDirectHash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* v)",
"comment" : "\n Converts a gpointer to a hash value.\n It can be passed to g_hash_table_new() as the hash_func parameter,\n when using pointers as keys in a GHashTable.\n Params:\n v = a gpointer key\n Returns: a hash value corresponding to the key.\n\t \n",
"line" : 500}
,
{
"name" : "gIntEqual",
"kind" : "function",
"protection" : "public",
"type" : "int(void* v1, void* v2)",
"comment" : "\n Compares the two gint values being pointed to and returns\n TRUE if they are equal.\n It can be passed to g_hash_table_new() as the key_equal_func\n parameter, when using pointers to integers as keys in a GHashTable.\n Params:\n v1 = a pointer to a gint key.\n v2 = a pointer to a gint key to compare with v1.\n Returns: TRUE if the two keys match.\n\t \n",
"line" : 516}
,
{
"name" : "gIntHash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* v)",
"comment" : "\n Converts a pointer to a gint to a hash value.\n It can be passed to g_hash_table_new() as the hash_func parameter,\n when using pointers to integers values as keys in a GHashTable.\n Params:\n v = a pointer to a gint key\n Returns: a hash value corresponding to the key.\n\t \n",
"line" : 530}
,
{
"name" : "gInt64_Equal",
"kind" : "function",
"protection" : "public",
"type" : "int(void* v1, void* v2)",
"comment" : "\n Compares the two gint64 values being pointed to and returns\n TRUE if they are equal.\n It can be passed to g_hash_table_new() as the key_equal_func\n parameter, when using pointers to 64-bit integers as keys in a GHashTable.\n Since 2.22\n Params:\n v1 = a pointer to a gint64 key.\n v2 = a pointer to a gint64 key to compare with v1.\n Returns: TRUE if the two keys match.\n\t \n",
"line" : 547}
,
{
"name" : "gInt64_Hash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* v)",
"comment" : "\n Converts a pointer to a gint64 to a hash value.\n It can be passed to g_hash_table_new() as the hash_func parameter,\n when using pointers to 64-bit integers values as keys in a GHashTable.\n Since 2.22\n Params:\n v = a pointer to a gint64 key\n Returns: a hash value corresponding to the key.\n\t \n",
"line" : 562}
,
{
"name" : "gDoubleEqual",
"kind" : "function",
"protection" : "public",
"type" : "int(void* v1, void* v2)",
"comment" : "\n Compares the two gdouble values being pointed to and returns\n TRUE if they are equal.\n It can be passed to g_hash_table_new() as the key_equal_func\n parameter, when using pointers to doubles as keys in a GHashTable.\n Since 2.22\n Params:\n v1 = a pointer to a gdouble key.\n v2 = a pointer to a gdouble key to compare with v1.\n Returns: TRUE if the two keys match.\n\t \n",
"line" : 579}
,
{
"name" : "gDoubleHash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* v)",
"comment" : "\n Converts a pointer to a gdouble to a hash value.\n It can be passed to g_hash_table_new() as the hash_func parameter,\n when using pointers to doubles as keys in a GHashTable.\n Since 2.22\n Params:\n v = a pointer to a gdouble key\n Returns: a hash value corresponding to the key.\n\t \n",
"line" : 594}
,
{
"name" : "gStrEqual",
"kind" : "function",
"protection" : "public",
"type" : "int(void* v1, void* v2)",
"comment" : "\n Compares two strings for byte-by-byte equality and returns TRUE\n if they are equal. It can be passed to g_hash_table_new() as the\n key_equal_func parameter, when using strings as keys in a GHashTable.\n Note that this function is primarily meant as a hash table comparison\n function. For a general-purpose, NULL-safe string comparison function,\n see g_strcmp0().\n Params:\n v1 = a key\n v2 = a key to compare with v1\n Returns: TRUE if the two keys match\n\t \n",
"line" : 612}
,
{
"name" : "gStrHash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* v)",
"comment" : "\n Converts a string to a hash value.\n It can be passed to g_hash_table_new() as the hash_func\n parameter, when using strings as keys in a GHashTable.\n Params:\n v = a string key\n Returns: a hash value corresponding to the key\n\t \n",
"line" : 626}
]
}
]
}
,
{
"name" : "glib.HashTableIter",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/HashTableIter.d",
"members" : [
{
"name" : "HashTableIter",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GHashTable provides associations between keys and values which is\n optimized so that given a key, the associated value can be found\n very quickly.\n Note that neither keys nor values are copied when inserted into the\n GHashTable, so they must exist for the lifetime of the GHashTable.\n This means that the use of static strings is OK, but temporary\n strings (i.e. those created in buffers and those returned by GTK+\n widgets) should be copied with g_strdup() before being inserted.\n If keys or values are dynamically allocated, you must be careful to\n ensure that they are freed when they are removed from the\n GHashTable, and also when they are overwritten by new insertions\n into the GHashTable. It is also not advisable to mix static strings\n and dynamically-allocated strings in a GHashTable, because it then\n becomes difficult to determine whether the string should be freed.\n To create a GHashTable, use g_hash_table_new().\n To insert a key and value into a GHashTable, use\n g_hash_table_insert().\n To lookup a value corresponding to a given key, use\n g_hash_table_lookup() and g_hash_table_lookup_extended().\n To remove a key and value, use g_hash_table_remove().\n To call a function for each key and value pair use\n g_hash_table_foreach() or use a iterator to iterate over the\n key\/value pairs in the hash table, see GHashTableIter.\n To destroy a GHashTable use g_hash_table_destroy().\n \n",
"line" : 94,
"base" : "Object",
"members" : [
{
"name" : "gHashTableIter",
"kind" : "variable",
"protection" : "protected",
"type" : "GHashTableIter*",
"comment" : " the main Gtk struct \n",
"line" : 97}
,
{
"name" : "getHashTableIterStruct",
"kind" : "function",
"protection" : "public",
"type" : "GHashTableIter*()",
"line" : 100}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 107}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "HashTableIter(GHashTableIter* gHashTableIter)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 115}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void(HashTable hashTable)",
"comment" : "\n\t \n\n Initializes a key\/value pair iterator and associates it with\n hash_table. Modifying the hash table after calling this function\n invalidates the returned iterator.\n $(DDOC_COMMENT example)\n Since 2.16\n Params:\n hashTable = a GHashTable.\n\t \n",
"line" : 137}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "int(void** key, void** value)",
"comment" : "\n Advances iter and retrieves the key and\/or value that are now\n pointed to as a result of this advancement. If FALSE is returned,\n key and value are not set, and the iterator becomes invalid.\n Since 2.16\n Params:\n key = a location to store the key, or NULL.\n value = a location to store the value, or NULL.\n Returns: FALSE if the end of the GHashTable has been reached.\n\t \n",
"line" : 153}
,
{
"name" : "getHashTable",
"kind" : "function",
"protection" : "public",
"type" : "HashTable()",
"comment" : "\n Returns the GHashTable associated with iter.\n Since 2.16\n Returns: the GHashTable associated with iter.\n\t \n",
"line" : 164}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes the key\/value pair currently pointed to by the iterator\n from its associated GHashTable. Can only be called after\n g_hash_table_iter_next() returned TRUE, and cannot be called more\n than once for the same key\/value pair.\n If the GHashTable was created using g_hash_table_new_full(), the\n key and value are freed using the supplied destroy functions, otherwise\n you have to make sure that any dynamically allocated values are freed\n yourself.\n Since 2.16\n\t \n",
"line" : 186}
,
{
"name" : "steal",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes the key\/value pair currently pointed to by the iterator\n from its associated GHashTable, without calling the key and value\n destroy functions. Can only be called after\n g_hash_table_iter_next() returned TRUE, and cannot be called more\n than once for the same key\/value pair.\n Since 2.16\n\t \n",
"line" : 200}
]
}
]
}
,
{
"name" : "glib.Hostname",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Hostname.d",
"members" : [
{
"name" : "Hostname",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Functions for manipulating internet hostnames; in particular, for\n converting between Unicode and ASCII-encoded forms of\n Internationalized Domain Names (IDNs).\n The Internationalized Domain\n Names for Applications (IDNA) standards allow for the use\n of Unicode domain names in applications, while providing\n backward-compatibility with the old ASCII-only DNS, by defining an\n ASCII-Compatible Encoding of any given Unicode name, which can be\n used with non-IDN-aware applications and protocols. (For example,\n \"  αν語.org\" maps to \"xn--4wa8awb4637h.org\".)\n \n",
"line" : 79,
"base" : "Object",
"members" : [
{
"name" : "toAscii",
"kind" : "function",
"protection" : "public",
"type" : "string(string hostname)",
"comment" : "\n\t \n\n Converts hostname to its canonical ASCII form; an ASCII-only\n string containing no uppercase letters and not ending with a\n trailing dot.\n Since 2.22\n Params:\n hostname = a valid UTF-8 or ASCII hostname\n Returns: an ASCII hostname, which must be freed, or NULL if hostname is in some way invalid.\n\t \n",
"line" : 93}
,
{
"name" : "toUnicode",
"kind" : "function",
"protection" : "public",
"type" : "string(string hostname)",
"comment" : "\n Converts hostname to its canonical presentation form; a UTF-8\n string in Unicode normalization form C, containing no uppercase\n letters, no forbidden characters, and no ASCII-encoded segments,\n and not ending with a trailing dot.\n Of course if hostname is not an internationalized hostname, then\n the canonical presentation form will be entirely ASCII.\n Since 2.22\n Params:\n hostname = a valid UTF-8 or ASCII hostname\n Returns: a UTF-8 hostname, which must be freed, or NULL if hostname is in some way invalid.\n\t \n",
"line" : 111}
,
{
"name" : "isNonAscii",
"kind" : "function",
"protection" : "public",
"type" : "int(string hostname)",
"comment" : "\n Tests if hostname contains Unicode characters. If this returns\n TRUE, you need to encode the hostname with g_hostname_to_ascii()\n before using it in non-IDN-aware contexts.\n Note that a hostname might contain a mix of encoded and unencoded\n segments, and so it is possible for g_hostname_is_non_ascii() and\n g_hostname_is_ascii_encoded() to both return TRUE for a name.\n Since 2.22\n Params:\n hostname = a hostname\n Returns: TRUE if hostname contains any non-ASCII characters\n\t \n",
"line" : 129}
,
{
"name" : "isAsciiEncoded",
"kind" : "function",
"protection" : "public",
"type" : "int(string hostname)",
"comment" : "\n Tests if hostname contains segments with an ASCII-compatible\n encoding of an Internationalized Domain Name. If this returns\n TRUE, you should decode the hostname with g_hostname_to_unicode()\n before displaying it to the user.\n Note that a hostname might contain a mix of encoded and unencoded\n segments, and so it is possible for g_hostname_is_non_ascii() and\n g_hostname_is_ascii_encoded() to both return TRUE for a name.\n Since 2.22\n Params:\n hostname = a hostname\n Returns: TRUE if hostname contains any ASCII-encoded segments.\n\t \n",
"line" : 148}
,
{
"name" : "isIpAddress",
"kind" : "function",
"protection" : "public",
"type" : "int(string hostname)",
"comment" : "\n Tests if hostname is the string form of an IPv4 or IPv6 address.\n (Eg, \"192.168.0.1\".)\n Since 2.22\n Params:\n hostname = a hostname (or IP address in string form)\n Returns: TRUE if hostname is an IP address\n\t \n",
"line" : 162}
]
}
]
}
,
{
"name" : "glib.Idle",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Idle.d",
"members" : [
{
"name" : "Idle",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The main event loop manages all the available sources of events for\n GLib and GTK+ applications. These events can come from any number of\n different types of sources such as file descriptors (plain files,\n pipes or sockets) and timeouts. New types of event sources can also\n be added using g_source_attach().\n To allow multiple independent sets of sources to be handled in\n different threads, each source is associated with a GMainContext.\n A GMainContext can only be running in a single thread, but\n sources can be added to it and removed from it from other threads.\n Each event source is assigned a priority. The default priority,\n G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n Values greater than 0 denote lower priorities. Events from high priority\n sources are always processed before events from lower priority sources.\n Idle functions can also be added, and assigned a priority. These will\n be run whenever no events with a higher priority are ready to be processed.\n The GMainLoop data type represents a main event loop. A GMainLoop is\n created with g_main_loop_new(). After adding the initial event sources,\n g_main_loop_run() is called. This continuously checks for new events from\n each of the event sources and dispatches them. Finally, the processing of\n an event from one of the sources leads to a call to g_main_loop_quit() to\n exit the main loop, and g_main_loop_run() returns.\n It is possible to create new instances of GMainLoop recursively.\n This is often used in GTK+ applications when showing modal dialog\n boxes. Note that event sources are associated with a particular\n GMainContext, and will be checked and dispatched for all main\n loops associated with that GMainContext.\n GTK+ contains wrappers of some of these functions, e.g. gtk_main(),\n gtk_main_quit() and gtk_events_pending().\n Creating new source types\n One of the unusual features of the GMainLoop functionality\n is that new types of event source can be created and used in\n addition to the builtin type of event source. A new event source\n type is used for handling GDK events. A new source type is created\n by deriving from the GSource structure.\n The derived type of source is represented by a structure that has\n the GSource structure as a first element, and other elements specific\n to the new source type. To create an instance of the new source type,\n call g_source_new() passing in the size of the derived structure and\n a table of functions. These GSourceFuncs determine the behavior of\n the new source type.\n New source types basically interact with the main context\n in two ways. Their prepare function in GSourceFuncs can set a timeout\n to determine the maximum amount of time that the main loop will sleep\n before checking the source again. In addition, or as well, the source\n can add file descriptors to the set that the main context checks using\n g_source_add_poll().\n <hr>\n Customizing the main loop iteration\n Single iterations of a GMainContext can be run with\n g_main_context_iteration(). In some cases, more detailed control\n of exactly how the details of the main loop work is desired, for\n instance, when integrating the GMainLoop with an external main loop.\n In such cases, you can call the component functions of\n g_main_context_iteration() directly. These functions are\n g_main_context_prepare(), g_main_context_query(),\n g_main_context_check() and g_main_context_dispatch().\n The operation of these functions can best be seen in terms\n of a state diagram, as shown in Figure  1, “States of a Main Context”.\n Figure  1.  States of a Main Context\n \n",
"line" : 129,
"base" : "Object",
"members" : [
{
"name" : "idleListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate()[]",
"comment" : " Holds all idle delegates \n",
"line" : 132}
,
{
"name" : "idleID",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " our idle ID \n",
"line" : 134}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Idle(bool delegate() dlg, bool fireNow = false)",
"comment" : "\n Creates a new idle cycle.\n Params:\n    \tinterval = the idle in milieconds\n    \tdlg = the delegate to be executed\n    \tfireNow = When true the delegate will be executed emmidiatly\n\t \n",
"line" : 143}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Idle(bool delegate() dlg, GPriority priority, bool fireNow = false)",
"comment" : "\n Creates a new idle cycle.\n Params:\n    \tdlg = the delegate to be executed\n      priority = Priority for the idle function\n    \tfireNow = When true the delegate will be executed emmidiatly\n\t \n",
"line" : 163}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " \n",
"line" : 177}
,
{
"name" : "addListener",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate() dlg, bool fireNow = false)",
"comment" : "\n Adds a new delegate to this idle cycle\n Params:\n    \tdlg =\n    \tfireNow =\n\t \n",
"line" : 200}
,
{
"name" : "idleCallback",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) bool(Idle idle)",
"comment" : "\n The callback execution from glib\n Params:\n    \tidle =\n Returns:\n\t \n",
"line" : 218}
,
{
"name" : "callAllListeners",
"kind" : "function",
"protection" : "private",
"type" : "bool()",
"comment" : "\n Executes all delegates on the execution list\n Returns:\n\t \n",
"line" : 227}
,
{
"name" : "sourceNew",
"kind" : "function",
"protection" : "public",
"type" : "Source()",
"comment" : "\n\t \n\n Creates a new idle source.\n The source will not initially be associated with any GMainContext\n and must be added to one with g_source_attach() before it will be\n executed. Note that the default priority for idle sources is\n G_PRIORITY_DEFAULT_IDLE, as compared to other sources which\n have a default priority of G_PRIORITY_DEFAULT.\n Returns: the newly-created idle source\n\t \n",
"line" : 260}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "uint(extern (C) int function(void*) funct, void* data)",
"comment" : "\n Adds a function to be called whenever there are no higher priority\n events pending to the default main loop. The function is given the\n default idle priority, G_PRIORITY_DEFAULT_IDLE. If the function\n returns FALSE it is automatically removed from the list of event\n sources and will not be called again.\n This internally creates a main loop source using g_idle_source_new()\n and attaches it to the main loop context using g_source_attach().\n You can do these steps manually if you need greater control.\n Params:\n data = data to pass to function.\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 284}
,
{
"name" : "addFull",
"kind" : "function",
"protection" : "public",
"type" : "uint(int priority, extern (C) int function(void*) funct, void* data, extern (C) void function(void* cbData) notify)",
"comment" : "\n Adds a function to be called whenever there are no higher priority\n events pending. If the function returns FALSE it is automatically\n removed from the list of event sources and will not be called again.\n This internally creates a main loop source using g_idle_source_new()\n and attaches it to the main loop context using g_source_attach().\n You can do these steps manually if you need greater control.\n Params:\n priority = the priority of the idle source. Typically this will be in the\n  range between G_PRIORITY_DEFAULT_IDLE and G_PRIORITY_HIGH_IDLE.\n data = data to pass to function\n notify = function to call when the idle is removed, or NULL\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 304}
,
{
"name" : "removeByData",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Removes the idle function with the given data.\n Params:\n data = the data for the idle source's callback.\n Returns: TRUE if an idle source was found and removed.\n\t \n",
"line" : 316}
]
}
]
}
,
{
"name" : "glib.Internationalization",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Internationalization.d",
"members" : [
{
"name" : "Internationalization",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GLib doesn't force any particular localization method upon its users.\n But since GLib itself is localized using the gettext() mechanism, it seems\n natural to offer the de-facto standard gettext() support macros in an\n easy-to-use form.\n In order to use these macros in an application, you must include\n glib\/gi18n.h. For use in a library, must include\n glib\/gi18n-lib.h after defining\n the GETTEXT_PACKAGE macro suitably for your library:\n $(DDOC_COMMENT example)\n The gettext manual covers details of how to set up message extraction\n with xgettext.\n \n",
"line" : 80,
"base" : "Object",
"members" : [
{
"name" : "dgettext",
"kind" : "function",
"protection" : "public",
"type" : "string(string domain, string msgid)",
"comment" : "\n\t \n\n This function is a wrapper of dgettext() which does not translate\n the message if the default domain as set with textdomain() has no\n translations for the current locale.\n The advantage of using this function over dgettext() proper is that\n libraries using this function (like GTK+) will not use translations\n if the application using the library does not have translations for\n the current locale. This results in a consistent English-only\n interface instead of one having partial translations. For this\n feature to work, the call to textdomain() and setlocale() should\n precede any g_dgettext() invocations. For GTK+, it means calling\n textdomain() before gtk_init or its variants.\n This function disables translations if and only if upon its first\n Since 2.18\n Params:\n domain = the translation domain to use, or NULL to use\n  the domain set with textdomain()\n msgid = message to translate\n Returns: The translated string\n\t \n",
"line" : 105}
,
{
"name" : "dcgettext",
"kind" : "function",
"protection" : "public",
"type" : "string(string domain, string msgid, int category)",
"comment" : "\n This is a variant of g_dgettext() that allows specifying a locale\n category instead of always using LC_MESSAGES. See g_dgettext() for\n more information about how this functions differs from calling\n dcgettext() directly.\n Since 2.26\n Params:\n domain = the translation domain to use, or NULL to use\n  the domain set with textdomain(). [allow-none]\n msgid = message to translate\n category = a locale category\n Returns: the translated string for the given locale category\n\t \n",
"line" : 124}
,
{
"name" : "dngettext",
"kind" : "function",
"protection" : "public",
"type" : "string(string domain, string msgid, string msgidPlural, ulong n)",
"comment" : "\n This function is a wrapper of dngettext() which does not translate\n the message if the default domain as set with textdomain() has no\n translations for the current locale.\n See g_dgettext() for details of how this differs from dngettext()\n proper.\n Since 2.18\n Params:\n domain = the translation domain to use, or NULL to use\n  the domain set with textdomain()\n msgid = message to translate\n msgidPlural = plural form of the message\n n = the quantity for which translation is needed\n Returns: The translated string\n\t \n",
"line" : 145}
,
{
"name" : "dpgettext",
"kind" : "function",
"protection" : "public",
"type" : "string(string domain, string msgctxtid, ulong msgidoffset)",
"comment" : "\n This function is a variant of g_dgettext() which supports\n a disambiguating message context. GNU gettext uses the\n '\\004' character to separate the message context and\n message id in msgctxtid.\n If 0 is passed as msgidoffset, this function will fall back to\n trying to use the deprecated convention of using \"|\" as a separation\n character.\n This uses g_dgettext() internally. See that functions for differences\n with dgettext() proper.\n Applications should normally not use this function directly,\n but use the C_() macro for translations with context.\n Since 2.16\n Params:\n domain = the translation domain to use, or NULL to use\n  the domain set with textdomain()\n msgctxtid = a combined message context and message id, separated\n  by a \\004 character\n msgidoffset = the offset of the message id in msgctxid\n Returns: The translated string\n\t \n",
"line" : 172}
,
{
"name" : "dpgettext2",
"kind" : "function",
"protection" : "public",
"type" : "string(string domain, string context, string msgid)",
"comment" : "\n This function is a variant of g_dgettext() which supports\n a disambiguating message context. GNU gettext uses the\n '\\004' character to separate the message context and\n message id in msgctxtid.\n This uses g_dgettext() internally. See that functions for differences\n with dgettext() proper.\n This function differs from C_() in that it is not a macro and\n thus you may use non-string-literals as context and msgid arguments.\n Since 2.18\n Params:\n domain = the translation domain to use, or NULL to use\n  the domain set with textdomain()\n context = the message context\n msgid = the message\n Returns: The translated string\n\t \n",
"line" : 195}
,
{
"name" : "stripContext",
"kind" : "function",
"protection" : "public",
"type" : "string(string msgid, string msgval)",
"comment" : "\n An auxiliary function for gettext() support (see Q_()).\n Since 2.4\n Params:\n msgid = a string\n msgval = another string\n Returns: msgval, unless msgval is identical to msgid and contains a '|' character, in which case a pointer to the substring of msgid after the first '|' character is returned.\n\t \n",
"line" : 209}
,
{
"name" : "getLanguageNames",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Computes a list of applicable locale names, which can be used to\n e.g. construct locale-dependent filenames or search paths. The returned\n list is sorted from most desirable to least desirable and always contains\n the default locale \"C\".\n For example, if LANGUAGE=de:en_US, then the returned list is\n \"de\", \"en_US\", \"en\", \"C\".\n This function consults the environment variables LANGUAGE,\n LC_ALL, LC_MESSAGES and LANG\n to find the list of locales specified by the user.\n Since 2.6\n Returns: a NULL-terminated array of strings owned by GLib that must not be modified or freed.\n\t \n",
"line" : 228}
]
}
]
}
,
{
"name" : "glib.IOChannel",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/IOChannel.d",
"members" : [
{
"name" : "IOChannel",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GIOChannel data type aims to provide a portable method for\n using file descriptors, pipes, and sockets, and integrating them\n into the main event\n loop. Currently full support is available on UNIX platforms,\n support for Windows is only partially complete.\n To create a new GIOChannel on UNIX systems use\n g_io_channel_unix_new(). This works for plain file descriptors,\n pipes and sockets. Alternatively, a channel can be created for a\n file in a system independent manner using g_io_channel_new_file().\n Once a GIOChannel has been created, it can be used in a generic\n manner with the functions g_io_channel_read_chars(),\n g_io_channel_write_chars(), g_io_channel_seek_position(), and\n g_io_channel_shutdown().\n To add a GIOChannel to the main event loop use\n g_io_add_watch() or g_io_add_watch_full(). Here you specify which\n events you are interested in on the GIOChannel, and provide a\n function to be called whenever these events occur.\n GIOChannel instances are created with an initial reference count of\n 1. g_io_channel_ref() and g_io_channel_unref() can be used to\n increment or decrement the reference count respectively. When the\n reference count falls to 0, the GIOChannel is freed. (Though it\n isn't closed automatically, unless it was created using\n g_io_channel_new_from_file().) Using g_io_add_watch() or\n g_io_add_watch_full() increments a channel's reference count.\n The new functions g_io_channel_read_chars(),\n g_io_channel_read_line(), g_io_channel_read_line_string(),\n g_io_channel_read_to_end(), g_io_channel_write_chars(),\n g_io_channel_seek_position(), and g_io_channel_flush() should not be\n mixed with the deprecated functions g_io_channel_read(),\n g_io_channel_write(), and g_io_channel_seek() on the same channel.\n \n",
"line" : 116,
"base" : "Object",
"members" : [
{
"name" : "gIOChannel",
"kind" : "variable",
"protection" : "protected",
"type" : "GIOChannel*",
"comment" : " the main Gtk struct \n",
"line" : 119}
,
{
"name" : "getIOChannelStruct",
"kind" : "function",
"protection" : "public",
"type" : "GIOChannel*()",
"line" : 122}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 129}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOChannel(GIOChannel* gIOChannel)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 137}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(out string strReturn, out ulong terminatorPos)",
"comment" : "\n Reads a line, including the terminating character(s),\n from a GIOChannel into a newly-allocated string.\n str_return will contain allocated memory if the return\n is G_IO_STATUS_NORMAL.\n Params:\n strReturn =  The line read from the GIOChannel, including the\n  line terminator. This data should be freed with g_free()\n  when no longer needed. This is a nul-terminated string.\n  If a length of zero is returned, this will be NULL instead.\n terminatorPos =  location to store position of line terminator, or NULL\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 169}
,
{
"name" : "readToEnd",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(out string strReturn)",
"comment" : "\n Reads all the remaining data from the file.\n Params:\n strReturn =  Location to store a pointer to a string holding\n  the remaining data in the GIOChannel. This data should\n  be freed with g_free() when no longer needed. This\n  data is terminated by an extra nul character, but there\n  may be other nuls in the intervening data.\n Returns: G_IO_STATUS_NORMAL on success.  This function never returns G_IO_STATUS_EOF.\n Throws: GException on failure.\n\t \n",
"line" : 205}
,
{
"name" : "unixNew",
"kind" : "function",
"protection" : "public",
"type" : "IOChannel(int fd)",
"comment" : "\n\t \n\n Creates a new GIOChannel given a file descriptor. On UNIX systems\n this works for plain files, pipes, and sockets.\n The returned GIOChannel has a reference count of 1.\n The default encoding for GIOChannel is UTF-8. If your application\n is reading output from a command using via pipe, you may need to set\n the encoding to the encoding of the current locale (see\n g_get_charset()) with the g_io_channel_set_encoding() function.\n If you want to read raw binary data without interpretation, then\n call the g_io_channel_set_encoding() function with NULL for the\n encoding argument.\n This function is available in GLib on Windows, too, but you should\n avoid using it on Windows. The domain of file descriptors and\n sockets overlap. There is no way for GLib to know which one you mean\n in case the argument you pass to this function happens to be both a\n valid file descriptor and socket. If that happens a warning is\n issued, and GLib assumes that it is the file descriptor you mean.\n Params:\n fd = a file descriptor.\n Returns: a new GIOChannel.\n\t \n",
"line" : 255}
,
{
"name" : "unixGetFd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the file descriptor of the GIOChannel.\n On Windows this function returns the file descriptor or socket of\n the GIOChannel.\n Returns: the file descriptor of the GIOChannel.\n\t \n",
"line" : 272}
,
{
"name" : "win32_NewFd",
"kind" : "function",
"protection" : "public",
"type" : "IOChannel(int fd)",
"comment" : "\n Creates a new GIOChannel given a file descriptor on Windows. This\n works for file descriptors from the C runtime.\n This function works for file descriptors as returned by the open(),\n creat(), pipe() and fileno() calls in the Microsoft C runtime. In\n order to meaningfully use this function your code should use the\n same C runtime as GLib uses, which is msvcrt.dll. Note that in\n current Microsoft compilers it is near impossible to convince it to\n build code that would use msvcrt.dll. The last Microsoft compiler\n version that supported using msvcrt.dll as the C runtime was version\n 6. The GNU compiler and toolchain for Windows, also known as Mingw,\n fully supports msvcrt.dll.\n If you have created a GIOChannel for a file descriptor and started\n watching (polling) it, you shouldn't call read() on the file\n descriptor. This is because adding polling for a file descriptor is\n implemented in GLib on Windows by starting a thread that sits\n blocked in a read() from the file descriptor most of the time. All\n reads from the file descriptor should be done by this internal GLib\n thread. Your code should call only g_io_channel_read().\n This function is available only in GLib on Windows.\n Params:\n fd = a C library file descriptor.\n Returns: a new GIOChannel.\n\t \n",
"line" : 302}
,
{
"name" : "win32_NewSocket",
"kind" : "function",
"protection" : "public",
"type" : "IOChannel(int socket)",
"comment" : "\n Creates a new GIOChannel given a socket on Windows.\n This function works for sockets created by Winsock. It's available\n only in GLib on Windows.\n Polling a GSource created to watch a channel for a socket puts the\n socket in non-blocking mode. This is a side-effect of the\n implementation and unavoidable.\n Params:\n socket = a Winsock socket\n Returns: a new GIOChannel\n\t \n",
"line" : 324}
,
{
"name" : "win32_NewMessages",
"kind" : "function",
"protection" : "public",
"type" : "IOChannel(ulong hwnd)",
"comment" : "\n Creates a new GIOChannel given a window handle on Windows.\n This function creates a GIOChannel that can be used to poll for\n Windows messages for the window in question.\n Params:\n hwnd = a window handle.\n Returns: a new GIOChannel.\n\t \n",
"line" : 343}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Initializes a GIOChannel struct.\n This is called by each of the above functions when creating a\n GIOChannel, and so is not often needed by the application\n programmer (unless you are creating a new type of GIOChannel).\n\t \n",
"line" : 360}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "IOChannel(string filename, string mode)",
"comment" : "\n Open a file filename as a GIOChannel using mode mode. This\n channel will be closed when the last reference to it is dropped,\n so there is no need to call g_io_channel_close() (though doing\n so will not cause problems, as long as no attempt is made to\n access the channel after it is closed).\n Params:\n filename = A string containing the name of a file\n mode = One of \"r\", \"w\", \"a\", \"r+\", \"w+\", \"a+\". These have\n  the same meaning as in fopen()\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 379}
,
{
"name" : "readChars",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(string buf, ulong count, out ulong bytesRead)",
"comment" : "\n Replacement for g_io_channel_read() with the new API.\n Params:\n buf = a buffer to read data into\n count = the size of the buffer. Note that the buffer may\n  not be complelely filled even if there is data\n  in the buffer if the remaining data is not a\n  complete character.\n bytesRead = The number of bytes read. This may be zero even on\n  success if count < 6 and the channel's encoding is non-NULL.\n  This indicates that the next UTF-8 character is too wide for\n  the buffer.\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 413}
,
{
"name" : "readUnichar",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(out uint thechar)",
"comment" : "\n Reads a Unicode character from channel.\n This function cannot be called on a channel with NULL encoding.\n Params:\n thechar = a location to return a character\n Returns: a GIOStatus\n Throws: GException on failure.\n\t \n",
"line" : 436}
,
{
"name" : "readLineString",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(StringG buffer, out ulong terminatorPos)",
"comment" : "\n Reads a line from a GIOChannel, using a GString as a buffer.\n Params:\n buffer = a GString into which the line will be written.\n  If buffer already contains data, the old data will\n  be overwritten.\n terminatorPos = location to store position of line terminator, or NULL\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 461}
,
{
"name" : "writeChars",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(string buf, long count, out ulong bytesWritten)",
"comment" : "\n Replacement for g_io_channel_write() with the new API.\n On seekable channels with encodings other than NULL or UTF-8, generic\n mixing of reading and writing is not allowed. A call to g_io_channel_write_chars()\n may only be made on a channel from which data has been read in the\n cases described in the documentation for g_io_channel_set_encoding().\n Params:\n buf = a buffer to write data from\n count = the size of the buffer. If -1, the buffer\n  is taken to be a nul-terminated string.\n bytesWritten = The number of bytes written. This can be nonzero\n  even if the return value is not G_IO_STATUS_NORMAL.\n  If the return value is G_IO_STATUS_NORMAL and the\n  channel is blocking, this will always be equal\n  to count if count >= 0.\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 494}
,
{
"name" : "writeUnichar",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(uint thechar)",
"comment" : "\n Writes a Unicode character to channel.\n This function cannot be called on a channel with NULL encoding.\n Params:\n thechar = a character\n Returns: a GIOStatus\n Throws: GException on failure.\n\t \n",
"line" : 517}
,
{
"name" : "flush",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus()",
"comment" : "\n Flushes the write buffer for the GIOChannel.\n Returns: the status of the operation: One of G_IO_STATUS_NORMAL, G_IO_STATUS_AGAIN, or G_IO_STATUS_ERROR.\n Throws: GException on failure.\n\t \n",
"line" : 537}
,
{
"name" : "seekPosition",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(long offset, GSeekType type)",
"comment" : "\n Replacement for g_io_channel_seek() with the new API.\n Params:\n offset = The offset in bytes from the position specified by type\n type = a GSeekType. The type G_SEEK_CUR is only allowed in those\n  cases where a call to g_io_channel_set_encoding()\n  is allowed. See the documentation for\n  g_io_channel_set_encoding() for details.\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 563}
,
{
"name" : "shutdown",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(int flush)",
"comment" : "\n Close an IO channel. Any pending data to be written will be\n flushed if flush is TRUE. The channel will not be freed until the\n last reference is dropped using g_io_channel_unref().\n Params:\n flush = if TRUE, flush pending\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 587}
,
{
"name" : "errorFromErrno",
"kind" : "function",
"protection" : "public",
"type" : "GIOChannelError(int en)",
"comment" : "\n Converts an errno error number to a GIOChannelError.\n Params:\n en = an errno error number, e.g. EINVAL\n Returns: a GIOChannelError error number, e.g. G_IO_CHANNEL_ERROR_INVAL.\n\t \n",
"line" : 608}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "IOChannel()",
"comment" : "\n Increments the reference count of a GIOChannel.\n Returns: the channel that was passed in (since 2.6)\n\t \n",
"line" : 618}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decrements the reference count of a GIOChannel.\n\t \n",
"line" : 632}
,
{
"name" : "gIoCreateWatch",
"kind" : "function",
"protection" : "public",
"type" : "Source(GIOCondition condition)",
"comment" : "\n Creates a GSource that's dispatched when condition is met for the\n given channel. For example, if condition is G_IO_IN, the source will\n be dispatched when there's data available for reading.\n g_io_add_watch() is a simpler interface to this same functionality, for\n the case where you want to add the source to the default main loop context\n at the default priority.\n On Windows, polling a GSource created to watch a channel for a socket\n puts the socket in non-blocking mode. This is a side-effect of the\n implementation and unavoidable.\n Params:\n condition = conditions to watch for\n Returns: a new GSource\n\t \n",
"line" : 652}
,
{
"name" : "gIoAddWatch",
"kind" : "function",
"protection" : "public",
"type" : "uint(GIOCondition condition, extern (C) int function(GIOChannel*, GIOCondition, void*) func, void* userData)",
"comment" : "\n Adds the GIOChannel into the default main loop context\n with the default priority.\n Params:\n condition = the condition to watch for\n func = the function to call when the condition is satisfied\n userData = user data to pass to func\n Returns: the event source id\n\t \n",
"line" : 672}
,
{
"name" : "gIoAddWatchFull",
"kind" : "function",
"protection" : "public",
"type" : "uint(int priority, GIOCondition condition, extern (C) int function(GIOChannel*, GIOCondition, void*) func, void* userData, extern (C) void function(void* cbData) notify)",
"comment" : "\n Adds the GIOChannel into the default main loop context\n with the given priority.\n This internally creates a main loop source using g_io_create_watch()\n and attaches it to the main loop context with g_source_attach().\n You can do these steps manually if you need greater control.\n Params:\n priority = the priority of the GIOChannel source\n condition = the condition to watch for\n func = the function to call when the condition is satisfied\n userData = user data to pass to func\n notify = the function to call when the source is removed\n Returns: the event source id\n\t \n",
"line" : 692}
,
{
"name" : "getBufferSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Gets the buffer size.\n Returns: the size of the buffer.\n\t \n",
"line" : 702}
,
{
"name" : "setBufferSize",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong size)",
"comment" : "\n Sets the buffer size.\n Params:\n size = the size of the buffer, or 0 to let GLib pick a good size\n\t \n",
"line" : 713}
,
{
"name" : "getBufferCondition",
"kind" : "function",
"protection" : "public",
"type" : "GIOCondition()",
"comment" : "\n This function returns a GIOCondition depending on whether there\n is data to be read\/space to write data in the internal buffers in\n the GIOChannel. Only the flags G_IO_IN and G_IO_OUT may be set.\n Returns: A GIOCondition\n\t \n",
"line" : 725}
,
{
"name" : "getFlags",
"kind" : "function",
"protection" : "public",
"type" : "GIOFlags()",
"comment" : "\n Gets the current flags for a GIOChannel, including read-only\n flags such as G_IO_FLAG_IS_READABLE.\n The values of the flags G_IO_FLAG_IS_READABLE and G_IO_FLAG_IS_WRITEABLE\n are cached for internal use by the channel when it is created.\n If they should change at some later point (e.g. partial shutdown\n of a socket with the UNIX shutdown() function), the user\n should immediately call g_io_channel_get_flags() to update\n the internal values of these flags.\n Returns: the flags which are set on the channel\n\t \n",
"line" : 742}
,
{
"name" : "setFlags",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(GIOFlags flags)",
"comment" : "\n Sets the (writeable) flags in channel to (flags  G_IO_CHANNEL_SET_MASK).\n Params:\n flags = the flags to set on the IO channel\n Returns: the status of the operation.\n Throws: GException on failure.\n\t \n",
"line" : 755}
,
{
"name" : "getLineTerm",
"kind" : "function",
"protection" : "public",
"type" : "string(out int length)",
"comment" : "\n This returns the string that GIOChannel uses to determine\n where in the file a line break occurs. A value of NULL\n indicates autodetection.\n Params:\n length = a location to return the length of the line terminator\n Returns: The line termination string. This value is owned by GLib and must not be freed.\n\t \n",
"line" : 778}
,
{
"name" : "setLineTerm",
"kind" : "function",
"protection" : "public",
"type" : "void(string lineTerm, int length)",
"comment" : "\n This sets the string that GIOChannel uses to determine\n where in the file a line break occurs.\n Params:\n lineTerm = The line termination string. Use NULL for autodetect.\n  Autodetection breaks on \"\\n\", \"\\r\\n\", \"\\r\", \"\\0\", and\n  the Unicode paragraph separator. Autodetection should\n  not be used for anything other than file-based channels.\n length = The length of the termination string. If -1 is passed, the\n  string is assumed to be nul-terminated. This option allows\n  termination strings with embedded nuls.\n\t \n",
"line" : 796}
,
{
"name" : "getBuffered",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether channel is buffered.\n Returns: TRUE if the channel is buffered.\n\t \n",
"line" : 806}
,
{
"name" : "setBuffered",
"kind" : "function",
"protection" : "public",
"type" : "void(int buffered)",
"comment" : "\n The buffering state can only be set if the channel's encoding\n is NULL. For any other encoding, the channel must be buffered.\n A buffered channel can only be set unbuffered if the channel's\n internal buffers have been flushed. Newly created channels or\n channels which have returned G_IO_STATUS_EOF\n not require such a flush. For write-only channels, a call to\n g_io_channel_flush() is sufficient. For all other channels,\n the buffers may be flushed by a call to g_io_channel_seek_position().\n This includes the possibility of seeking with seek type G_SEEK_CUR\n and an offset of zero. Note that this means that socket-based\n channels cannot be set unbuffered once they have had data\n read from them.\n On unbuffered channels, it is safe to mix read and write\n calls from the new and old APIs, if this is necessary for\n maintaining old code.\n The default state of the channel is buffered.\n Params:\n buffered = whether to set the channel buffered or unbuffered\n\t \n",
"line" : 832}
,
{
"name" : "getEncoding",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the encoding for the input\/output of the channel.\n The internal encoding is always UTF-8. The encoding NULL\n makes the channel safe for binary data.\n Returns: A string containing the encoding, this string is owned by GLib and must not be freed.\n\t \n",
"line" : 844}
,
{
"name" : "setEncoding",
"kind" : "function",
"protection" : "public",
"type" : "GIOStatus(string encoding)",
"comment" : "\n Sets the encoding for the input\/output of the channel.\n The internal encoding is always UTF-8. The default encoding\n for the external file is UTF-8.\n The encoding NULL is safe to use with binary data.\n The encoding can only be set if one of the following conditions\n Params:\n encoding = the encoding type\n Returns: G_IO_STATUS_NORMAL if the encoding was successfully set.\n Throws: GException on failure.\n\t \n",
"line" : 861}
,
{
"name" : "getCloseOnUnref",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the file\/socket\/whatever associated with channel\n will be closed when channel receives its final unref and is\n destroyed. The default value of this is TRUE for channels created\n by g_io_channel_new_file(), and FALSE for all other channels.\n Returns: Whether the channel will be closed on the final unref of the GIOChannel data structure.\n\t \n",
"line" : 883}
,
{
"name" : "setCloseOnUnref",
"kind" : "function",
"protection" : "public",
"type" : "void(int doClose)",
"comment" : "\n Setting this flag to TRUE for a channel you have already closed\n can cause problems.\n Params:\n doClose = Whether to close the channel on the final unref of\n  the GIOChannel data structure. The default value of\n  this is TRUE for channels created by g_io_channel_new_file(),\n  and FALSE for all other channels.\n\t \n",
"line" : 898}
,
{
"name" : "read",
"kind" : "function",
"protection" : "public",
"type" : "GIOError(string buf, ulong count, out ulong bytesRead)",
"comment" : "\n Warning\n g_io_channel_read has been deprecated since version 2.2 and should not be used in newly-written code. Use g_io_channel_read_chars() instead.\n Reads data from a GIOChannel.\n Params:\n buf = a buffer to read the data into (which should be at least\n  count bytes long)\n count = the number of bytes to read from the GIOChannel\n bytesRead = returns the number of bytes actually read\n Returns: G_IO_ERROR_NONE if the operation was successful.\n\t \n",
"line" : 915}
,
{
"name" : "write",
"kind" : "function",
"protection" : "public",
"type" : "GIOError(string buf, ulong count, out ulong bytesWritten)",
"comment" : "\n Warning\n g_io_channel_write has been deprecated since version 2.2 and should not be used in newly-written code. Use g_io_channel_write_chars() instead.\n Writes data to a GIOChannel.\n Params:\n buf = the buffer containing the data to write\n count = the number of bytes to write\n bytesWritten = the number of bytes actually written\n Returns: G_IO_ERROR_NONE if the operation was successful.\n\t \n",
"line" : 931}
,
{
"name" : "seek",
"kind" : "function",
"protection" : "public",
"type" : "GIOError(long offset, GSeekType type)",
"comment" : "\n Warning\n g_io_channel_seek has been deprecated since version 2.2 and should not be used in newly-written code. Use g_io_channel_seek_position() instead.\n Sets the current position in the GIOChannel, similar to the standard\n library function fseek().\n Params:\n offset = an offset, in bytes, which is added to the position specified\n  by type\n type = the position in the file, which can be G_SEEK_CUR (the current\n  position), G_SEEK_SET (the start of the file), or G_SEEK_END\n  (the end of the file)\n Returns: G_IO_ERROR_NONE if the operation was successful.\n\t \n",
"line" : 950}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_io_channel_close has been deprecated since version 2.2 and should not be used in newly-written code. Use g_io_channel_shutdown() instead.\n Close an IO channel. Any pending data to be written will be\n flushed, ignoring errors. The channel will not be freed until the\n last reference is dropped using g_io_channel_unref().\n\t \n",
"line" : 963}
]
}
]
}
,
{
"name" : "glib.KeyFile",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/KeyFile.d",
"members" : [
{
"name" : "KeyFile",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GKeyFile lets you parse, edit or create files containing groups of\n key-value pairs, which we call key files for\n lack of a better name. Several freedesktop.org specifications use\n key files now, e.g the\n Desktop\n Entry Specification and the\n Icon\n Theme Specification.\n The syntax of key files is described in detail in the\n Desktop\n Entry Specification, here is a quick summary: Key files\n consists of groups of key-value pairs, interspersed with comments.\n $(DDOC_COMMENT example)\n Lines beginning with a '#' and blank lines are considered comments.\n Groups are started by a header line containing the group name enclosed\n in '[' and ']', and ended implicitly by the start of the next group or\n the end of the file. Each key-value pair must be contained in a group.\n Key-value pairs generally have the form key=value,\n with the exception of localized strings, which have the form\n key[locale]=value, with a locale identifier of the form\n lang_COUNTRYMODIFIER where COUNTRY and\n MODIFIER are optional. Space before and after the\n '=' character are ignored. Newline, tab, carriage return and backslash\n characters in value are escaped as \\n, \\t, \\r, and \\\\, respectively.\n To preserve leading spaces in values, these can also be escaped as \\s.\n Key files can store strings (possibly with localized variants), integers,\n booleans and lists of these. Lists are separated by a separator character,\n typically ';' or ','. To use the list separator character in a value in\n a list, it has to be escaped by prefixing it with a backslash.\n This syntax is obviously inspired by the .ini\n files commonly met on Windows, but there are some important differences:\n .ini files use the ';' character to begin comments,\n  key files use the '#' character.\n Key files do not allow for ungrouped keys meaning only comments can precede the first group.\n Key files are always encoded in UTF-8.\n Key and Group names are case-sensitive, for example a group called\n [GROUP] is a different group from [group].\n .ini files don't have a strongly typed boolean entry type, they only\n have GetProfileInt. In GKeyFile only\n true and false (in lower case) are allowed.\n Note that in contrast to the\n Desktop\n Entry Specification, groups in key files may contain the same\n key multiple times; the last entry wins. Key files may also contain\n multiple groups with the same name; they are merged together.\n Another difference is that keys and group names in key files are not\n restricted to ASCII characters.\n \n",
"line" : 121,
"base" : "Object",
"members" : [
{
"name" : "gKeyFile",
"kind" : "variable",
"protection" : "protected",
"type" : "GKeyFile*",
"comment" : " the main Gtk struct \n",
"line" : 124}
,
{
"name" : "getKeyFileStruct",
"kind" : "function",
"protection" : "public",
"type" : "GKeyFile*()",
"line" : 127}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 134}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "KeyFile(GKeyFile* gKeyFile)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 142}
,
{
"name" : "loadFromDirs",
"kind" : "function",
"protection" : "public",
"type" : "int(string file, string[] searchDirs, out string fullPath, GKeyFileFlags flags)",
"comment" : "\n This function looks for a key file named file in the paths\n specified in search_dirs, loads the file into key_file and\n returns the file's full path in full_path. If the file could not\n be loaded then an error is set to either a GFileError or\n GKeyFileError.\n Since 2.14\n Params:\n file =  a relative path to a filename to open and parse\n searchDirs =  NULL-terminated array of directories to search\n fullPath =  return location for a string containing the full path\n  of the file, or NULL\n flags =  flags from GKeyFileFlags\n Returns: TRUE if a key file could be loaded, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 168}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "KeyFile()",
"comment" : "\n\t \n\n Creates a new empty GKeyFile object. Use\n g_key_file_load_from_file(), g_key_file_load_from_data(),\n g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to\n read an existing key file.\n Since 2.6\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 196}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a GKeyFile.\n Since 2.6\n\t \n",
"line" : 211}
,
{
"name" : "setListSeparator",
"kind" : "function",
"protection" : "public",
"type" : "void(char separator)",
"comment" : "\n Sets the character which is used to separate\n values in lists. Typically ';' or ',' are used\n as separators. The default list separator is ';'.\n Since 2.6\n Params:\n separator = the separator\n\t \n",
"line" : 225}
,
{
"name" : "loadFromFile",
"kind" : "function",
"protection" : "public",
"type" : "int(string file, GKeyFileFlags flags)",
"comment" : "\n Loads a key file into an empty GKeyFile structure.\n If the file could not be loaded then error is set to\n either a GFileError or GKeyFileError.\n Since 2.6\n Params:\n file = the path of a filename to load, in the GLib filename encoding\n flags = flags from GKeyFileFlags\n Returns: TRUE if a key file could be loaded, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 242}
,
{
"name" : "loadFromData",
"kind" : "function",
"protection" : "public",
"type" : "int(string data, ulong length, GKeyFileFlags flags)",
"comment" : "\n Loads a key file from memory into an empty GKeyFile structure.\n If the object cannot be created then error is set to a GKeyFileError.\n Since 2.6\n Params:\n data = key file loaded in memory\n length = the length of data in bytes\n flags = flags from GKeyFileFlags\n Returns: TRUE if a key file could be loaded, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 268}
,
{
"name" : "loadFromDataDirs",
"kind" : "function",
"protection" : "public",
"type" : "int(string file, out string fullPath, GKeyFileFlags flags)",
"comment" : "\n This function looks for a key file named file in the paths\n returned from g_get_user_data_dir() and g_get_system_data_dirs(),\n loads the file into key_file and returns the file's full path in\n full_path. If the file could not be loaded then an error is\n set to either a GFileError or GKeyFileError.\n Since 2.6\n Params:\n file = a relative path to a filename to open and parse\n fullPath = return location for a string containing the full path\n  of the file, or NULL\n flags = flags from GKeyFileFlags\n Returns: TRUE if a key file could be loaded, FALSE othewise\n Throws: GException on failure.\n\t \n",
"line" : 298}
,
{
"name" : "toData",
"kind" : "function",
"protection" : "public",
"type" : "string(out ulong length)",
"comment" : "\n This function outputs key_file as a string.\n Note that this function never reports an error,\n so it is safe to pass NULL as error.\n Since 2.6\n Params:\n length = return location for the length of the\n  returned string, or NULL\n Returns: a newly allocated string holding the contents of the GKeyFile\n Throws: GException on failure.\n\t \n",
"line" : 326}
,
{
"name" : "getStartGroup",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the name of the start group of the file.\n Since 2.6\n Returns: The start group of the key file.\n\t \n",
"line" : 346}
,
{
"name" : "getGroups",
"kind" : "function",
"protection" : "public",
"type" : "string[](out ulong length)",
"comment" : "\n Returns all groups in the key file loaded with key_file.\n The array of returned groups will be NULL-terminated, so\n length may optionally be NULL.\n Since 2.6\n Params:\n length = return location for the number of returned groups, or NULL\n Returns: a newly-allocated NULL-terminated array of strings. Use g_strfreev() to free it.\n\t \n",
"line" : 361}
,
{
"name" : "getKeys",
"kind" : "function",
"protection" : "public",
"type" : "string[](string groupName, out ulong length)",
"comment" : "\n Returns all keys for the group name group_name. The array of\n returned keys will be NULL-terminated, so length may\n optionally be NULL. In the event that the group_name cannot\n be found, NULL is returned and error is set to\n G_KEY_FILE_ERROR_GROUP_NOT_FOUND.\n Since 2.6\n Params:\n groupName = a group name\n length = return location for the number of keys returned, or NULL\n Returns: a newly-allocated NULL-terminated array of strings. Use g_strfreev() to free it.\n Throws: GException on failure.\n\t \n",
"line" : 380}
,
{
"name" : "hasGroup",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName)",
"comment" : "\n Looks whether the key file has the group group_name.\n Since 2.6\n Params:\n groupName = a group name\n Returns: TRUE if group_name is a part of key_file, FALSE otherwise.\n\t \n",
"line" : 402}
,
{
"name" : "hasKey",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName, string key)",
"comment" : "\n Looks whether the key file has the key key in the group\n group_name.\n Since 2.6\n Params:\n groupName = a group name\n key = a key name\n Returns: TRUE if key is a part of group_name, FALSE otherwise.\n Throws: GException on failure.\n\t \n",
"line" : 418}
,
{
"name" : "getValue",
"kind" : "function",
"protection" : "public",
"type" : "string(string groupName, string key)",
"comment" : "\n Returns the raw value associated with key under group_name.\n Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.\n In the event the key cannot be found, NULL is returned and\n error is set to G_KEY_FILE_ERROR_KEY_NOT_FOUND. In the\n event that the group_name cannot be found, NULL is returned\n and error is set to G_KEY_FILE_ERROR_GROUP_NOT_FOUND.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n Returns: a newly allocated string or NULL if the specified key cannot be found.\n Throws: GException on failure.\n\t \n",
"line" : 447}
,
{
"name" : "getString",
"kind" : "function",
"protection" : "public",
"type" : "string(string groupName, string key)",
"comment" : "\n Returns the string value associated with key under group_name.\n Unlike g_key_file_get_value(), this function handles escape sequences\n like \\s.\n In the event the key cannot be found, NULL is returned and\n error is set to G_KEY_FILE_ERROR_KEY_NOT_FOUND. In the\n event that the group_name cannot be found, NULL is returned\n and error is set to G_KEY_FILE_ERROR_GROUP_NOT_FOUND.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n Returns: a newly allocated string or NULL if the specified key cannot be found.\n Throws: GException on failure.\n\t \n",
"line" : 477}
,
{
"name" : "getLocaleString",
"kind" : "function",
"protection" : "public",
"type" : "string(string groupName, string key, string locale)",
"comment" : "\n Returns the value associated with key under group_name\n translated in the given locale if available. If locale is\n NULL then the current locale is assumed.\n If key cannot be found then NULL is returned and error is set\n to G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated\n with key cannot be interpreted or no suitable translation can\n be found then the untranslated value is returned.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n locale = a locale identifier or NULL\n Returns: a newly allocated string or NULL if the specified key cannot be found.\n Throws: GException on failure.\n\t \n",
"line" : 508}
,
{
"name" : "getBoolean",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName, string key)",
"comment" : "\n Returns the value associated with key under group_name as a\n boolean.\n If key cannot be found then FALSE is returned and error is set\n to G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value\n associated with key cannot be interpreted as a boolean then FALSE\n is returned and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n Returns: the value associated with the key as a boolean, or FALSE if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 537}
,
{
"name" : "getInteger",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName, string key)",
"comment" : "\n Returns the value associated with key under group_name as an\n integer.\n If key cannot be found then 0 is returned and error is set to\n G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated\n with key cannot be interpreted as an integer then 0 is returned\n and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n Returns: the value associated with the key as an integer, or 0 if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 566}
,
{
"name" : "getInt64",
"kind" : "function",
"protection" : "public",
"type" : "long(string groupName, string key)",
"comment" : "\n Returns the value associated with key under group_name as a signed\n 64-bit integer. This is similar to g_key_file_get_integer() but can return\n 64-bit results without truncation.\n Since 2.26\n Params:\n groupName = a non-NULL group name\n key = a non-NULL key\n Returns: the value associated with the key as a signed 64-bit integer, or 0 if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 592}
,
{
"name" : "getUint64",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string groupName, string key)",
"comment" : "\n Returns the value associated with key under group_name as an unsigned\n 64-bit integer. This is similar to g_key_file_get_integer() but can return\n large positive results without truncation.\n Since 2.26\n Params:\n groupName = a non-NULL group name\n key = a non-NULL key\n Returns: the value associated with the key as an unsigned 64-bit integer, or 0 if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 618}
,
{
"name" : "getDouble",
"kind" : "function",
"protection" : "public",
"type" : "double(string groupName, string key)",
"comment" : "\n Returns the value associated with key under group_name as a\n double. If group_name is NULL, the start_group is used.\n If key cannot be found then 0.0 is returned and error is set to\n G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated\n with key cannot be interpreted as a double then 0.0 is returned\n and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.\n Since 2.12\n Params:\n groupName = a group name\n key = a key\n Returns: the value associated with the key as a double, or 0.0 if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 647}
,
{
"name" : "getStringList",
"kind" : "function",
"protection" : "public",
"type" : "string[](string groupName, string key, out ulong length)",
"comment" : "\n Returns the values associated with key under group_name.\n In the event the key cannot be found, NULL is returned and\n error is set to G_KEY_FILE_ERROR_KEY_NOT_FOUND. In the\n event that the group_name cannot be found, NULL is returned\n and error is set to G_KEY_FILE_ERROR_GROUP_NOT_FOUND.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n length = return location for the number of returned strings, or NULL\n Returns: a NULL-terminated string array or NULL if the specified key cannot be found. The array should be freed with g_strfreev().\n Throws: GException on failure.\n\t \n",
"line" : 676}
,
{
"name" : "getLocaleStringList",
"kind" : "function",
"protection" : "public",
"type" : "string[](string groupName, string key, string locale, out ulong length)",
"comment" : "\n Returns the values associated with key under group_name\n translated in the given locale if available. If locale is\n NULL then the current locale is assumed.\n If key cannot be found then NULL is returned and error is set\n to G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated\n with key cannot be interpreted or no suitable translations\n can be found then the untranslated values are returned. The\n returned array is NULL-terminated, so length may optionally\n be NULL.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n locale = a locale identifier or NULL\n length = return location for the number of returned strings or NULL\n Returns: a newly allocated NULL-terminated string array or NULL if the key isn't found. The string array should be freed with g_strfreev().\n Throws: GException on failure.\n\t \n",
"line" : 710}
,
{
"name" : "getBooleanList",
"kind" : "function",
"protection" : "public",
"type" : "int[](string groupName, string key)",
"comment" : "\n Returns the values associated with key under group_name as\n booleans.\n If key cannot be found then NULL is returned and error is set to\n G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated\n with key cannot be interpreted as booleans then NULL is returned\n and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n Returns: the values associated with the key as a list of booleans, or NULL if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 739}
,
{
"name" : "getIntegerList",
"kind" : "function",
"protection" : "public",
"type" : "int[](string groupName, string key)",
"comment" : "\n Returns the values associated with key under group_name as\n integers.\n If key cannot be found then NULL is returned and error is set to\n G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated\n with key cannot be interpreted as integers then NULL is returned\n and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n Returns: the values associated with the key as a list of integers, or NULL if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 769}
,
{
"name" : "getDoubleList",
"kind" : "function",
"protection" : "public",
"type" : "double[](string groupName, string key)",
"comment" : "\n Returns the values associated with key under group_name as\n doubles.\n If key cannot be found then NULL is returned and error is set to\n G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated\n with key cannot be interpreted as doubles then NULL is returned\n and error is set to G_KEY_FILE_ERROR_INVALID_VALUE.\n Since 2.12\n Params:\n groupName = a group name\n key = a key\n Returns: the values associated with the key as a list of doubles, or NULL if the key was not found or could not be parsed.\n Throws: GException on failure.\n\t \n",
"line" : 799}
,
{
"name" : "getComment",
"kind" : "function",
"protection" : "public",
"type" : "string(string groupName, string key)",
"comment" : "\n Retrieves a comment above key from group_name.\n If key is NULL then comment will be read from above\n group_name. If both key and group_name are NULL, then\n comment will be read from above the first group in the file.\n Since 2.6\n Params:\n groupName = a group name, or NULL\n key = a key\n Returns: a comment that should be freed with g_free()\n Throws: GException on failure.\n\t \n",
"line" : 827}
,
{
"name" : "setValue",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, string value)",
"comment" : "\n Associates a new value with key under group_name.\n If key cannot be found then it is created. If group_name cannot\n be found then it is created. To set an UTF-8 string which may contain\n characters that need escaping (such as newlines or spaces), use\n g_key_file_set_string().\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n value = a string\n\t \n",
"line" : 854}
,
{
"name" : "setString",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, string string)",
"comment" : "\n Associates a new string value with key under group_name.\n If key cannot be found then it is created.\n If group_name cannot be found then it is created.\n Unlike g_key_file_set_value(), this function handles characters\n that need escaping, such as newlines.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n string = a string\n\t \n",
"line" : 872}
,
{
"name" : "setLocaleString",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, string locale, string string)",
"comment" : "\n Associates a string value for key and locale under group_name.\n If the translation for key cannot be found then it is created.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n locale = a locale identifier\n string = a string\n\t \n",
"line" : 888}
,
{
"name" : "setBoolean",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, int value)",
"comment" : "\n Associates a new boolean value with key under group_name.\n If key cannot be found then it is created.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n value = TRUE or FALSE\n\t \n",
"line" : 903}
,
{
"name" : "setInteger",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, int value)",
"comment" : "\n Associates a new integer value with key under group_name.\n If key cannot be found then it is created.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n value = an integer value\n\t \n",
"line" : 918}
,
{
"name" : "setInt64",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, long value)",
"comment" : "\n Associates a new integer value with key under group_name.\n If key cannot be found then it is created.\n Since 2.26\n Params:\n groupName = a group name\n key = a key\n value = an integer value\n\t \n",
"line" : 933}
,
{
"name" : "setUint64",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, ulong value)",
"comment" : "\n Associates a new integer value with key under group_name.\n If key cannot be found then it is created.\n Since 2.26\n Params:\n groupName = a group name\n key = a key\n value = an integer value\n\t \n",
"line" : 948}
,
{
"name" : "setDouble",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, double value)",
"comment" : "\n Associates a new double value with key under group_name.\n If key cannot be found then it is created.\n Since 2.12\n Params:\n groupName = a group name\n key = a key\n value = an double value\n\t \n",
"line" : 963}
,
{
"name" : "setStringList",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, string[] list)",
"comment" : "\n Associates a list of string values for key under group_name.\n If key cannot be found then it is created.\n If group_name cannot be found then it is created.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n list = an array of string values\n\t \n",
"line" : 979}
,
{
"name" : "setLocaleStringList",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, string locale, string[] list)",
"comment" : "\n Associates a list of string values for key and locale under\n group_name. If the translation for key cannot be found then\n it is created.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n locale = a locale identifier\n list = a NULL-terminated array of locale string values\n\t \n",
"line" : 996}
,
{
"name" : "setBooleanList",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, int[] list)",
"comment" : "\n Associates a list of boolean values with key under group_name.\n If key cannot be found then it is created.\n If group_name is NULL, the start_group is used.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n list = an array of boolean values\n\t \n",
"line" : 1012}
,
{
"name" : "setIntegerList",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, int[] list)",
"comment" : "\n Associates a list of integer values with key under group_name.\n If key cannot be found then it is created.\n Since 2.6\n Params:\n groupName = a group name\n key = a key\n list = an array of integer values\n\t \n",
"line" : 1027}
,
{
"name" : "setDoubleList",
"kind" : "function",
"protection" : "public",
"type" : "void(string groupName, string key, double[] list)",
"comment" : "\n Associates a list of double values with key under\n group_name. If key cannot be found then it is created.\n Since 2.12\n Params:\n groupName = a group name\n key = a key\n list = an array of double values\n\t \n",
"line" : 1042}
,
{
"name" : "setComment",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName, string key, string comment)",
"comment" : "\n Places a comment above key from group_name.\n If key is NULL then comment will be written above group_name.\n If both key and group_name are NULL, then comment will be\n written above the first group in the file.\n Since 2.6\n Params:\n groupName = a group name, or NULL\n key = a key\n comment = a comment\n Returns: TRUE if the comment was written, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 1061}
,
{
"name" : "removeGroup",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName)",
"comment" : "\n Removes the specified group, group_name,\n from the key file.\n Since 2.6\n Params:\n groupName = a group name\n Returns: TRUE if the group was removed, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 1085}
,
{
"name" : "removeKey",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName, string key)",
"comment" : "\n Removes key in group_name from the key file.\n Since 2.6\n Params:\n groupName = a group name\n key = a key name to remove\n Returns: TRUE if the key was removed, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 1109}
,
{
"name" : "removeComment",
"kind" : "function",
"protection" : "public",
"type" : "int(string groupName, string key)",
"comment" : "\n Removes a comment above key from group_name.\n If key is NULL then comment will be removed above group_name.\n If both key and group_name are NULL, then comment will\n be removed above the first group in the file.\n Since 2.6\n Params:\n groupName = a group name, or NULL\n key = a key\n Returns: TRUE if the comment was removed, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 1136}
]
}
]
}
,
{
"name" : "glib.ListG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ListG.d",
"members" : [
{
"name" : "ListG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GList structure and its associated functions provide a standard\n doubly-linked list data structure.\n Each element in the list contains a piece of data, together with\n pointers which link to the previous and next elements in the list.\n Using these pointers it is possible to move through the list in both\n directions (unlike the Singly-Linked Lists which\n only allows movement through the list in the forward direction).\n The data contained in each element can be either integer values, by\n using one of the Type\n Conversion Macros, or simply pointers to any type of data.\n List elements are allocated from the slice allocator, which is more\n efficient than allocating elements individually.\n Note that most of the GList functions expect to be passed a pointer\n to the first element in the list. The functions which insert\n elements return the new start of the list, which may have changed.\n There is no function to create a GList. NULL is considered to be\n the empty list so you simply set a GList* to NULL.\n To add elements, use g_list_append(), g_list_prepend(),\n g_list_insert() and g_list_insert_sorted().\n To remove elements, use g_list_remove().\n To find elements in the list use g_list_first(), g_list_last(),\n g_list_next(), g_list_previous(), g_list_nth(), g_list_nth_data(),\n g_list_find() and g_list_find_custom().\n To find the index of an element use g_list_position() and\n g_list_index().\n To call a function for each element in the list use g_list_foreach().\n To free the entire list, use g_list_free().\n \n",
"line" : 95,
"base" : "Object",
"members" : [
{
"name" : "gList",
"kind" : "variable",
"protection" : "protected",
"type" : "GList*",
"comment" : " the main Gtk struct \n",
"line" : 98}
,
{
"name" : "getListGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GList*()",
"line" : 101}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 108}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ListG(GList* gList)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 116}
,
{
"name" : "data",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : " \n",
"line" : 127}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n get the next element\n Returns: the next element, or NULL if there are no more elements.\n\t \n",
"line" : 136}
,
{
"name" : "previous",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n get the previous element\n Returns: the previous element, or NULL if there are no more elements.\n\t \n",
"line" : 145}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data)",
"comment" : "\n\t \n\n Adds a new element on to the end of the list.\n Note\n The return value is the new start of the list, which\n may have changed, so make sure you store the new value.\n Note\n Note that g_list_append() has to traverse the entire list\n to find the end, which is inefficient when adding multiple\n elements. A common idiom to avoid the inefficiency is to prepend\n the elements and reverse the list when all elements have been added.\n $(DDOC_COMMENT example)\n Params:\n data = the data for the new element\n Returns: the new start of the GList\n\t \n",
"line" : 168}
,
{
"name" : "prepend",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data)",
"comment" : "\n Adds a new element on to the start of the list.\n Note\n The return value is the new start of the list, which\n may have changed, so make sure you store the new value.\n $(DDOC_COMMENT example)\n Params:\n data = the data for the new element\n Returns: the new start of the GList\n\t \n",
"line" : 189}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data, int position)",
"comment" : "\n Inserts a new element into the list at the given position.\n Params:\n data = the data for the new element\n position = the position to insert the element. If this is\n  negative, or is larger than the number of elements in the\n  list, the new element is added on to the end of the list.\n Returns: the new start of the GList\n\t \n",
"line" : 209}
,
{
"name" : "insertBefore",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ListG sibling, void* data)",
"comment" : "\n Inserts a new element into the list before the given position.\n Params:\n sibling = the list element before which the new element\n  is inserted or NULL to insert at the end of the list\n data = the data for the new element\n Returns: the new start of the GList\n\t \n",
"line" : 228}
,
{
"name" : "insertSorted",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data, extern (C) int function(void*, void*) func)",
"comment" : "\n Inserts a new element into the list, using the given comparison\n function to determine its position.\n Params:\n data = the data for the new element\n func = the function to compare elements in the list. It should\n  return a number > 0 if the first parameter comes after the\n  second parameter in the sort order.\n Returns: the new start of the GList\n\t \n",
"line" : 249}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data)",
"comment" : "\n Removes an element from a GList.\n If two elements contain the same data, only the first is removed.\n If none of the elements contain the data, the GList is unchanged.\n Params:\n data = the data of the element to remove\n Returns: the new start of the GList\n\t \n",
"line" : 268}
,
{
"name" : "removeLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ListG llink)",
"comment" : "\n Removes an element from a GList, without freeing the element.\n The removed element's prev and next links are set to NULL, so\n that it becomes a self-contained list with one element.\n Params:\n llink = an element in the GList\n Returns: the new start of the GList, without the element\n\t \n",
"line" : 287}
,
{
"name" : "deleteLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ListG link)",
"comment" : "\n Removes the node link_ from the list and frees it.\n Compare this to g_list_remove_link() which removes the node\n without freeing it.\n Params:\n link = node to delete from list\n Returns: the new head of list\n\t \n",
"line" : 306}
,
{
"name" : "removeAll",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data)",
"comment" : "\n Removes all list nodes with data equal to data.\n Returns the new head of the list. Contrast with\n g_list_remove() which removes only the first node\n matching the given data.\n Params:\n data = data to remove\n Returns: new head of list\n\t \n",
"line" : 326}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees all of the memory used by a GList.\n The freed elements are returned to the slice allocator.\n Note\n If list elements contain dynamically-allocated memory,\n they should be freed first.\n\t \n",
"line" : 344}
,
{
"name" : "alloc",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Allocates space for one GList element. It is called by\n g_list_append(), g_list_prepend(), g_list_insert() and\n g_list_insert_sorted() and so is rarely used on its own.\n Returns: a pointer to the newly-allocated GList element.\n\t \n",
"line" : 356}
,
{
"name" : "free1",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees one GList element.\n It is usually used after g_list_remove_link().\n\t \n",
"line" : 371}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the number of elements in a GList.\n Note\n This function iterates over the whole list to\n count its elements.\n Returns: the number of elements in the GList\n\t \n",
"line" : 384}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Copies a GList.\n Note\n Note that this is a \"shallow\" copy. If the list elements\n consist of pointers to data, the pointers are copied but\n the actual data is not.\n Returns: a copy of list\n\t \n",
"line" : 398}
,
{
"name" : "reverse",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Reverses a GList.\n It simply switches the next and prev pointers of each element.\n Returns: the start of the reversed GList\n\t \n",
"line" : 414}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "ListG(extern (C) int function(void*, void*) compareFunc)",
"comment" : "\n Sorts a GList using the given comparison function.\n Params:\n compareFunc = the comparison function used to sort the GList.\n  This function is passed the data from 2 elements of the GList\n  and should return 0 if they are equal, a negative value if the\n  first element comes before the second, or a positive value if\n  the first element comes after the second.\n Returns: the start of the sorted GList\n\t \n",
"line" : 435}
,
{
"name" : "insertSortedWithData",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data, extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Inserts a new element into the list, using the given comparison\n function to determine its position.\n Since 2.10\n Params:\n data = the data for the new element\n func = the function to compare elements in the list.\n  It should return a number > 0 if the first parameter\n  comes after the second parameter in the sort order.\n userData = user data to pass to comparison function.\n Returns: the new start of the GList\n\t \n",
"line" : 458}
,
{
"name" : "sortWithData",
"kind" : "function",
"protection" : "public",
"type" : "ListG(extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n Like g_list_sort(), but the comparison function accepts\n a user data argument.\n Params:\n compareFunc = comparison function\n userData = user data to pass to comparison function\n Returns: the new head of list\n\t \n",
"line" : 477}
,
{
"name" : "concat",
"kind" : "function",
"protection" : "public",
"type" : "ListG(ListG list2)",
"comment" : "\n Adds the second GList onto the end of the first GList.\n Note that the elements of the second GList are not copied.\n They are used directly.\n Params:\n list2 = the GList to add to the end of the first GList\n Returns: the start of the new GList\n\t \n",
"line" : 496}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*) func, void* userData)",
"comment" : "\n Calls a function for each element of a GList.\n Params:\n func = the function to call with each element's data\n userData = user data to pass to the function\n\t \n",
"line" : 513}
,
{
"name" : "first",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets the first element in a GList.\n Returns: the first element in the GList, or NULL if the GList has no elements\n\t \n",
"line" : 523}
,
{
"name" : "last",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Gets the last element in a GList.\n Returns: the last element in the GList, or NULL if the GList has no elements\n\t \n",
"line" : 538}
,
{
"name" : "nth",
"kind" : "function",
"protection" : "public",
"type" : "ListG(uint n)",
"comment" : "\n Gets the element at the given position in a GList.\n Params:\n n = the position of the element, counting from 0\n Returns: the element, or NULL if the position is off the end of the GList\n\t \n",
"line" : 555}
,
{
"name" : "nthData",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint n)",
"comment" : "\n Gets the data of the element at the given position.\n Params:\n n = the position of the element\n Returns: the element's data, or NULL if the position is off the end of the GList\n\t \n",
"line" : 572}
,
{
"name" : "nthPrev",
"kind" : "function",
"protection" : "public",
"type" : "ListG(uint n)",
"comment" : "\n Gets the element n places before list.\n Params:\n n = the position of the element, counting from 0\n Returns: the element, or NULL if the position is off the end of the GList\n\t \n",
"line" : 584}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data)",
"comment" : "\n Finds the element in a GList which\n contains the given data.\n Params:\n data = the element data to find\n Returns: the found GList element, or NULL if it is not found\n\t \n",
"line" : 602}
,
{
"name" : "findCustom",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data, extern (C) int function(void*, void*) func)",
"comment" : "\n Finds an element in a GList, using a supplied function to\n find the desired element. It iterates over the list, calling\n the given function which should return 0 when the desired\n element is found. The function takes two gconstpointer arguments,\n the GList element's data as the first argument and the\n given user data.\n Params:\n data = user data passed to the function\n func = the function to call for each element.\n  It should return 0 when the desired element is found\n Returns: the found GList element, or NULL if it is not found\n\t \n",
"line" : 626}
,
{
"name" : "position",
"kind" : "function",
"protection" : "public",
"type" : "int(ListG llink)",
"comment" : "\n Gets the position of the given element\n in the GList (starting from 0).\n Params:\n llink = an element in the GList\n Returns: the position of the element in the GList, or -1 if the element is not found\n\t \n",
"line" : 644}
,
{
"name" : "index",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Gets the position of the element containing\n the given data (starting from 0).\n Params:\n data = the data to find\n Returns: the index of the element containing the data, or -1 if the data is not found\n\t \n",
"line" : 657}
,
{
"name" : "pushAllocator",
"kind" : "function",
"protection" : "public",
"type" : "void(void* allocator)",
"comment" : "\n Warning\n g_list_push_allocator has been deprecated since version 2.10 and should not be used in newly-written code. It does nothing, since GList has been converted\n  to the slice\n  allocator\n Sets the allocator to use to allocate GList elements. Use\n g_list_pop_allocator() to restore the previous allocator.\n Note that this function is not available if GLib has been compiled\n with --disable-mem-pools\n Params:\n allocator = the GAllocator to use when allocating GList elements.\n\t \n",
"line" : 675}
,
{
"name" : "popAllocator",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_list_pop_allocator has been deprecated since version 2.10 and should not be used in newly-written code. It does nothing, since GList has been converted\n  to the slice\n  allocator\n Restores the previous GAllocator, used when allocating GList\n elements.\n Note that this function is not available if GLib has been compiled\n with --disable-mem-pools\n\t \n",
"line" : 691}
]
}
]
}
,
{
"name" : "glib.ListSG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ListSG.d",
"members" : [
{
"name" : "ListSG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GSList structure and its associated functions provide a\n standard singly-linked list data structure.\n Each element in the list contains a piece of data, together with a\n pointer which links to the next element in the list. Using this\n pointer it is possible to move through the list in one direction\n only (unlike the Doubly-Linked Lists which\n allow movement in both directions).\n The data contained in each element can be either integer values, by\n using one of the Type\n Conversion Macros, or simply pointers to any type of data.\n List elements are allocated from the slice allocator, which is more\n efficient than allocating elements individually.\n Note that most of the GSList functions expect to be passed a\n pointer to the first element in the list. The functions which insert\n elements return the new start of the list, which may have changed.\n There is no function to create a GSList. NULL is considered to be\n the empty list so you simply set a GSList* to NULL.\n To add elements, use g_slist_append(), g_slist_prepend(),\n g_slist_insert() and g_slist_insert_sorted().\n To remove elements, use g_slist_remove().\n To find elements in the list use g_slist_last(), g_slist_next(),\n g_slist_nth(), g_slist_nth_data(), g_slist_find() and\n g_slist_find_custom().\n To find the index of an element use g_slist_position() and\n g_slist_index().\n To call a function for each element in the list use\n g_slist_foreach().\n To free the entire list, use g_slist_free().\n \n",
"line" : 96,
"base" : "Object",
"members" : [
{
"name" : "gSList",
"kind" : "variable",
"protection" : "protected",
"type" : "GSList*",
"comment" : " the main Gtk struct \n",
"line" : 99}
,
{
"name" : "getListSGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSList*()",
"line" : 102}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 109}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ListSG(GSList* gSList)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 117}
,
{
"name" : "data",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : " \n",
"line" : 128}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "ListSG()",
"comment" : "\n get the next element\n Returns: the next element, or NULL if there are no more elements.\n\t \n",
"line" : 137}
,
{
"name" : "alloc",
"kind" : "function",
"protection" : "public",
"type" : "ListSG()",
"comment" : "\n\t \n\n Allocates space for one GSList element. It is called by the\n g_slist_append(), g_slist_prepend(), g_slist_insert() and\n g_slist_insert_sorted() functions and so is rarely used on its own.\n Returns: a pointer to the newly-allocated GSList element.\n\t \n",
"line" : 151}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data)",
"comment" : "\n Adds a new element on to the end of the list.\n Note\n The return value is the new start of the list, which may\n have changed, so make sure you store the new value.\n Note\n Note that g_slist_append() has to traverse the entire list\n to find the end, which is inefficient when adding multiple\n elements. A common idiom to avoid the inefficiency is to prepend\n the elements and reverse the list when all elements have been added.\n $(DDOC_COMMENT example)\n Params:\n data = the data for the new element\n Returns: the new start of the GSList\n\t \n",
"line" : 177}
,
{
"name" : "prepend",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data)",
"comment" : "\n Adds a new element on to the start of the list.\n Note\n The return value is the new start of the list, which\n may have changed, so make sure you store the new value.\n $(DDOC_COMMENT example)\n Params:\n data = the data for the new element\n Returns: the new start of the GSList\n\t \n",
"line" : 198}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data, int position)",
"comment" : "\n Inserts a new element into the list at the given position.\n Params:\n data = the data for the new element\n position = the position to insert the element.\n  If this is negative, or is larger than the number\n  of elements in the list, the new element is added on\n  to the end of the list.\n Returns: the new start of the GSList\n\t \n",
"line" : 219}
,
{
"name" : "insertBefore",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(ListSG sibling, void* data)",
"comment" : "\n Inserts a node before sibling containing data.\n Params:\n sibling = node to insert data before\n data = data to put in the newly-inserted node\n Returns: the new head of the list.\n\t \n",
"line" : 237}
,
{
"name" : "insertSorted",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data, extern (C) int function(void*, void*) func)",
"comment" : "\n Inserts a new element into the list, using the given\n comparison function to determine its position.\n Params:\n data = the data for the new element\n func = the function to compare elements in the list.\n  It should return a number > 0 if the first parameter\n  comes after the second parameter in the sort order.\n Returns: the new start of the GSList\n\t \n",
"line" : 258}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data)",
"comment" : "\n Removes an element from a GSList.\n If two elements contain the same data, only the first is removed.\n If none of the elements contain the data, the GSList is unchanged.\n Params:\n data = the data of the element to remove\n Returns: the new start of the GSList\n\t \n",
"line" : 277}
,
{
"name" : "removeLink",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(ListSG link)",
"comment" : "\n Removes an element from a GSList, without\n freeing the element. The removed element's next\n link is set to NULL, so that it becomes a\n self-contained list with one element.\n Params:\n link = an element in the GSList\n Returns: the new start of the GSList, without the element\n\t \n",
"line" : 297}
,
{
"name" : "deleteLink",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(ListSG link)",
"comment" : "\n Removes the node link_ from the list and frees it.\n Compare this to g_slist_remove_link() which removes the node\n without freeing it.\n Params:\n link = node to delete\n Returns: the new head of list\n\t \n",
"line" : 316}
,
{
"name" : "removeAll",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data)",
"comment" : "\n Removes all list nodes with data equal to data.\n Returns the new head of the list. Contrast with\n g_slist_remove() which removes only the first node\n matching the given data.\n Params:\n data = data to remove\n Returns: new head of list\n\t \n",
"line" : 336}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees all of the memory used by a GSList.\n The freed elements are returned to the slice allocator.\n\t \n",
"line" : 351}
,
{
"name" : "free1",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees one GSList element.\n It is usually used after g_slist_remove_link().\n\t \n",
"line" : 361}
,
{
"name" : "length",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the number of elements in a GSList.\n Note\n This function iterates over the whole list to\n count its elements.\n Returns: the number of elements in the GSList\n\t \n",
"line" : 374}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "ListSG()",
"comment" : "\n Copies a GSList.\n Note\n Note that this is a \"shallow\" copy. If the list elements\n consist of pointers to data, the pointers are copied but\n the actual data isn't.\n Returns: a copy of list\n\t \n",
"line" : 388}
,
{
"name" : "reverse",
"kind" : "function",
"protection" : "public",
"type" : "ListSG()",
"comment" : "\n Reverses a GSList.\n Returns: the start of the reversed GSList\n\t \n",
"line" : 403}
,
{
"name" : "insertSortedWithData",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data, extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Inserts a new element into the list, using the given\n comparison function to determine its position.\n Since 2.10\n Params:\n data = the data for the new element\n func = the function to compare elements in the list.\n  It should return a number > 0 if the first parameter\n  comes after the second parameter in the sort order.\n userData = data to pass to comparison function\n Returns: the new start of the GSList\n\t \n",
"line" : 426}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(extern (C) int function(void*, void*) compareFunc)",
"comment" : "\n Sorts a GSList using the given comparison function.\n Params:\n compareFunc = the comparison function used to sort the GSList.\n  This function is passed the data from 2 elements of the GSList\n  and should return 0 if they are equal, a negative value if the\n  first element comes before the second, or a positive value if\n  the first element comes after the second.\n Returns: the start of the sorted GSList\n\t \n",
"line" : 447}
,
{
"name" : "sortWithData",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n Like g_slist_sort(), but the sort function accepts a user data argument.\n Params:\n compareFunc = comparison function\n userData = data to pass to comparison function\n Returns: new head of the list\n\t \n",
"line" : 465}
,
{
"name" : "concat",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(ListSG list2)",
"comment" : "\n Adds the second GSList onto the end of the first GSList.\n Note that the elements of the second GSList are not copied.\n They are used directly.\n Params:\n list2 = the GSList to add to the end of the first GSList\n Returns: the start of the new GSList\n\t \n",
"line" : 484}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*) func, void* userData)",
"comment" : "\n Calls a function for each element of a GSList.\n Params:\n func = the function to call with each element's data\n userData = user data to pass to the function\n\t \n",
"line" : 501}
,
{
"name" : "last",
"kind" : "function",
"protection" : "public",
"type" : "ListSG()",
"comment" : "\n Gets the last element in a GSList.\n Note\n This function iterates over the whole list.\n Returns: the last element in the GSList, or NULL if the GSList has no elements\n\t \n",
"line" : 513}
,
{
"name" : "nth",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(uint n)",
"comment" : "\n Gets the element at the given position in a GSList.\n Params:\n n = the position of the element, counting from 0\n Returns: the element, or NULL if the position is off the end of the GSList\n\t \n",
"line" : 530}
,
{
"name" : "nthData",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint n)",
"comment" : "\n Gets the data of the element at the given position.\n Params:\n n = the position of the element\n Returns: the element's data, or NULL if the position is off the end of the GSList\n\t \n",
"line" : 547}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data)",
"comment" : "\n Finds the element in a GSList which\n contains the given data.\n Params:\n data = the element data to find\n Returns: the found GSList element, or NULL if it is not found\n\t \n",
"line" : 560}
,
{
"name" : "findCustom",
"kind" : "function",
"protection" : "public",
"type" : "ListSG(void* data, extern (C) int function(void*, void*) func)",
"comment" : "\n Finds an element in a GSList, using a supplied function to\n find the desired element. It iterates over the list, calling\n the given function which should return 0 when the desired\n element is found. The function takes two gconstpointer arguments,\n the GSList element's data as the first argument and the\n given user data.\n Params:\n data = user data passed to the function\n func = the function to call for each element.\n  It should return 0 when the desired element is found\n Returns: the found GSList element, or NULL if it is not found\n\t \n",
"line" : 584}
,
{
"name" : "position",
"kind" : "function",
"protection" : "public",
"type" : "int(ListSG llink)",
"comment" : "\n Gets the position of the given element\n in the GSList (starting from 0).\n Params:\n llink = an element in the GSList\n Returns: the position of the element in the GSList, or -1 if the element is not found\n\t \n",
"line" : 602}
,
{
"name" : "index",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Gets the position of the element containing\n the given data (starting from 0).\n Params:\n data = the data to find\n Returns: the index of the element containing the data, or -1 if the data is not found\n\t \n",
"line" : 615}
,
{
"name" : "pushAllocator",
"kind" : "function",
"protection" : "public",
"type" : "void(void* dummy)",
"comment" : "\n Warning\n g_slist_push_allocator has been deprecated since version 2.10 and should not be used in newly-written code. It does nothing, since GSList has been converted\n  to the slice\n  allocator\n Sets the allocator to use to allocate GSList elements. Use\n g_slist_pop_allocator() to restore the previous allocator.\n Note that this function is not available if GLib has been compiled\n with --disable-mem-pools\n Params:\n dummy = the GAllocator to use when allocating GSList elements.\n\t \n",
"line" : 633}
,
{
"name" : "popAllocator",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_slist_pop_allocator has been deprecated since version 2.10 and should not be used in newly-written code. It does nothing, since GSList has been converted\n  to the slice\n  allocator\n Restores the previous GAllocator, used when allocating GSList\n elements.\n Note that this function is not available if GLib has been compiled\n with --disable-mem-pools\n\t \n",
"line" : 649}
]
}
]
}
,
{
"name" : "glib.MainContext",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MainContext.d",
"members" : [
{
"name" : "MainContext",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The main event loop manages all the available sources of events for\n GLib and GTK+ applications. These events can come from any number of\n different types of sources such as file descriptors (plain files,\n pipes or sockets) and timeouts. New types of event sources can also\n be added using g_source_attach().\n To allow multiple independent sets of sources to be handled in\n different threads, each source is associated with a GMainContext.\n A GMainContext can only be running in a single thread, but\n sources can be added to it and removed from it from other threads.\n Each event source is assigned a priority. The default priority,\n G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n Values greater than 0 denote lower priorities. Events from high priority\n sources are always processed before events from lower priority sources.\n Idle functions can also be added, and assigned a priority. These will\n be run whenever no events with a higher priority are ready to be processed.\n The GMainLoop data type represents a main event loop. A GMainLoop is\n created with g_main_loop_new(). After adding the initial event sources,\n g_main_loop_run() is called. This continuously checks for new events from\n each of the event sources and dispatches them. Finally, the processing of\n an event from one of the sources leads to a call to g_main_loop_quit() to\n exit the main loop, and g_main_loop_run() returns.\n It is possible to create new instances of GMainLoop recursively.\n This is often used in GTK+ applications when showing modal dialog\n boxes. Note that event sources are associated with a particular\n GMainContext, and will be checked and dispatched for all main\n loops associated with that GMainContext.\n GTK+ contains wrappers of some of these functions, e.g. gtk_main(),\n gtk_main_quit() and gtk_events_pending().\n Creating new source types\n One of the unusual features of the GMainLoop functionality\n is that new types of event source can be created and used in\n addition to the builtin type of event source. A new event source\n type is used for handling GDK events. A new source type is created\n by deriving from the GSource structure.\n The derived type of source is represented by a structure that has\n the GSource structure as a first element, and other elements specific\n to the new source type. To create an instance of the new source type,\n call g_source_new() passing in the size of the derived structure and\n a table of functions. These GSourceFuncs determine the behavior of\n the new source type.\n New source types basically interact with the main context\n in two ways. Their prepare function in GSourceFuncs can set a timeout\n to determine the maximum amount of time that the main loop will sleep\n before checking the source again. In addition, or as well, the source\n can add file descriptors to the set that the main context checks using\n g_source_add_poll().\n <hr>\n Customizing the main loop iteration\n Single iterations of a GMainContext can be run with\n g_main_context_iteration(). In some cases, more detailed control\n of exactly how the details of the main loop work is desired, for\n instance, when integrating the GMainLoop with an external main loop.\n In such cases, you can call the component functions of\n g_main_context_iteration() directly. These functions are\n g_main_context_prepare(), g_main_context_query(),\n g_main_context_check() and g_main_context_dispatch().\n The operation of these functions can best be seen in terms\n of a state diagram, as shown in Figure  1, “States of a Main Context”.\n Figure  1.  States of a Main Context\n \n",
"line" : 136,
"base" : "Object",
"members" : [
{
"name" : "gMainContext",
"kind" : "variable",
"protection" : "protected",
"type" : "GMainContext*",
"comment" : " the main Gtk struct \n",
"line" : 139}
,
{
"name" : "getMainContextStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMainContext*()",
"line" : 142}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 149}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MainContext(GMainContext* gMainContext)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 157}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MainContext()",
"comment" : "\n\t \n\n Creates a new GMainContext structure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 174}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "MainContext()",
"comment" : "\n Increases the reference count on a GMainContext object by one.\n Returns: the context that was passed in (since 2.6)\n\t \n",
"line" : 189}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decreases the reference count on a GMainContext object by one. If\n the result is zero, free the context and free all associated memory.\n\t \n",
"line" : 204}
,
{
"name" : "defaulx",
"kind" : "function",
"protection" : "public",
"type" : "MainContext()",
"comment" : "\n Returns the global default main context. This is the main context\n used for main loop functions when a main loop is not explicitly\n specified, and corresponds to the \"main\" main loop. See also\n g_main_context_get_thread_default().\n Returns: the global default main context.\n\t \n",
"line" : 217}
,
{
"name" : "iteration",
"kind" : "function",
"protection" : "public",
"type" : "int(int mayBlock)",
"comment" : "\n Runs a single iteration for the given main loop. This involves\n checking to see if any event sources are ready to be processed,\n then if no events sources are ready and may_block is TRUE, waiting\n for a source to become ready, then dispatching the highest priority\n events sources that are ready. Otherwise, if may_block is FALSE\n sources are not waited to become ready, only those highest priority\n events sources will be dispatched (if any), that are ready at this\n given moment without further waiting.\n Note that even when may_block is TRUE, it is still possible for\n g_main_context_iteration() to return FALSE, since the the wait may\n be interrupted for other reasons than an event source becoming ready.\n Params:\n mayBlock = whether the call may block.\n Returns: TRUE if events were dispatched.\n\t \n",
"line" : 244}
,
{
"name" : "pending",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if any sources have pending events for the given context.\n Returns: TRUE if events are pending.\n\t \n",
"line" : 254}
,
{
"name" : "findSourceById",
"kind" : "function",
"protection" : "public",
"type" : "Source(uint sourceId)",
"comment" : "\n Finds a GSource given a pair of context and ID.\n Params:\n sourceId = the source ID, as returned by g_source_get_id().\n Returns: the GSource if found, otherwise, NULL\n\t \n",
"line" : 266}
,
{
"name" : "findSourceByUserData",
"kind" : "function",
"protection" : "public",
"type" : "Source(void* userData)",
"comment" : "\n Finds a source with the given user data for the callback. If\n multiple sources exist with the same user data, the first\n one found will be returned.\n Params:\n userData = the user_data for the callback.\n Returns: the source, if one was found, otherwise NULL\n\t \n",
"line" : 285}
,
{
"name" : "findSourceByFuncsUserData",
"kind" : "function",
"protection" : "public",
"type" : "Source(GSourceFuncs* funcs, void* userData)",
"comment" : "\n Finds a source with the given source functions and user data. If\n multiple sources exist with the same source function and user data,\n the first one found will be returned.\n Params:\n funcs = the source_funcs passed to g_source_new().\n userData = the user data from the callback.\n Returns: the source, if one was found, otherwise NULL\n\t \n",
"line" : 305}
,
{
"name" : "wakeup",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n If context is currently waiting in a poll(), interrupt\n the poll(), and continue the iteration process.\n\t \n",
"line" : 320}
,
{
"name" : "acquire",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Tries to become the owner of the specified context.\n If some other thread is the owner of the context,\n returns FALSE immediately. Ownership is properly\n recursive: the owner can require ownership again\n and will release ownership when g_main_context_release()\n is called as many times as g_main_context_acquire().\n You must be the owner of a context before you\n can call g_main_context_prepare(), g_main_context_query(),\n g_main_context_check(), g_main_context_dispatch().\n Returns: TRUE if the operation succeeded, and this thread is now the owner of context.\n\t \n",
"line" : 338}
,
{
"name" : "release",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Releases ownership of a context previously acquired by this thread\n with g_main_context_acquire(). If the context was acquired multiple\n times, the ownership will be released only when g_main_context_release()\n is called as many times as it was acquired.\n\t \n",
"line" : 350}
,
{
"name" : "isOwner",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines whether this thread holds the (recursive)\n ownership of this GMaincontext. This is useful to\n know before waiting on another thread that may be\n blocking to get ownership of context.\n Since 2.10\n Returns: TRUE if current thread is owner of context.\n\t \n",
"line" : 364}
,
{
"name" : "wait",
"kind" : "function",
"protection" : "public",
"type" : "int(Cond cond, Mutex mutex)",
"comment" : "\n Tries to become the owner of the specified context,\n as with g_main_context_acquire(). But if another thread\n is the owner, atomically drop mutex and wait on cond until\n that owner releases ownership or until cond is signaled, then\n try again (once) to become the owner.\n Params:\n cond = a condition variable\n mutex = a mutex, currently held\n Returns: TRUE if the operation succeeded, and this thread is now the owner of context.\n\t \n",
"line" : 381}
,
{
"name" : "prepare",
"kind" : "function",
"protection" : "public",
"type" : "int(out int priority)",
"comment" : "\n Prepares to poll sources within a main loop. The resulting information\n for polling is determined by calling g_main_context_query().\n Params:\n priority = location to store priority of highest priority\n  source already ready.\n Returns: TRUE if some source is ready to be dispatched prior to polling.\n\t \n",
"line" : 395}
,
{
"name" : "query",
"kind" : "function",
"protection" : "public",
"type" : "int(int maxPriority, out int timeout, GPollFD* fds, int nFds)",
"comment" : "\n Determines information necessary to poll this main loop.\n Params:\n maxPriority = maximum priority source to check\n timeout = location to store timeout to be used in polling\n fds = location to store GPollFD records that need to be polled.\n nFds = length of fds.\n Returns: the number of records actually stored in fds, or, if more than n_fds records need to be stored, the number of records that need to be stored.\n\t \n",
"line" : 410}
,
{
"name" : "check",
"kind" : "function",
"protection" : "public",
"type" : "int(int maxPriority, GPollFD* fds, int nFds)",
"comment" : "\n Passes the results of polling back to the main loop.\n Params:\n maxPriority = the maximum numerical priority of sources to check\n fds = array of GPollFD's that was passed to the last call to\n  g_main_context_query()\n nFds = return value of g_main_context_query()\n Returns: TRUE if some sources are ready to be dispatched.\n\t \n",
"line" : 425}
,
{
"name" : "dispatch",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Dispatches all pending sources.\n\t \n",
"line" : 434}
,
{
"name" : "setPollFunc",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(GPollFD*, uint, int) func)",
"comment" : "\n Sets the function to use to handle polling of file descriptors. It\n will be used instead of the poll() system call\n (or GLib's replacement function, which is used where\n poll() isn't available).\n This function could possibly be used to integrate the GLib event\n loop with an external event loop.\n Params:\n func = the function to call to poll all file descriptors\n\t \n",
"line" : 450}
,
{
"name" : "getPollFunc",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) int function(GPollFD*, uint, int)()",
"comment" : "\n Gets the poll function set by g_main_context_set_poll_func().\n Returns: the poll function\n\t \n",
"line" : 460}
,
{
"name" : "addPoll",
"kind" : "function",
"protection" : "public",
"type" : "void(GPollFD* fd, int priority)",
"comment" : "\n Adds a file descriptor to the set of file descriptors polled for\n this context. This will very seldomly be used directly. Instead\n a typical event source will use g_source_add_poll() instead.\n Params:\n fd = a GPollFD structure holding information about a file\n  descriptor to watch.\n priority = the priority for this file descriptor which should be\n  the same as the priority used for g_source_attach() to ensure that the\n  file descriptor is polled whenever the results may be needed.\n\t \n",
"line" : 477}
,
{
"name" : "removePoll",
"kind" : "function",
"protection" : "public",
"type" : "void(GPollFD* fd)",
"comment" : "\n Removes file descriptor from the set of file descriptors to be\n polled for a particular context.\n Params:\n fd = a GPollFD descriptor previously added with g_main_context_add_poll()\n\t \n",
"line" : 489}
,
{
"name" : "getThreadDefault",
"kind" : "function",
"protection" : "public",
"type" : "MainContext()",
"comment" : "\n Gets the thread-default GMainContext for this thread. Asynchronous\n operations that want to be able to be run in contexts other than\n the default one should call this method to get a GMainContext to\n add their GSources to. (Note that even in single-threaded\n programs applications may sometimes want to temporarily push a\n non-default context, so it is not safe to assume that this will\n always return NULL if threads are not initialized.)\n Since 2.22\n Returns: the thread-default GMainContext, or NULL if the thread-default context is the global default context.\n\t \n",
"line" : 506}
,
{
"name" : "pushThreadDefault",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Acquires context and sets it as the thread-default context for the\n current thread. This will cause certain asynchronous operations\n (such as most gio-based I\/O) which are\n started in this thread to run under context and deliver their\n results to its main loop, rather than running under the global\n default context in the main thread. Note that calling this function\n changes the context returned by\n g_main_context_get_thread_default(), not the\n one returned by g_main_context_default(), so it does not affect the\n context used by functions like g_idle_add().\n Normally you would call this function shortly after creating a new\n thread, passing it a GMainContext which will be run by a\n GMainLoop in that thread, to set a new default context for all\n async operations in that thread. (In this case, you don't need to\n ever call g_main_context_pop_thread_default().) In some cases\n however, you may want to schedule a single operation in a\n non-default context, or temporarily use a non-default context in\n the main thread. In that case, you can wrap the call to the\n asynchronous operation inside a\n g_main_context_push_thread_default() \/\n g_main_context_pop_thread_default() pair, but it is up to you to\n ensure that no other asynchronous operations accidentally get\n started while the non-default context is active.\n Beware that libraries that predate this function may not correctly\n handle being used from a thread with a thread-default context. Eg,\n see g_file_supports_thread_contexts().\n Since 2.22\n\t \n",
"line" : 546}
,
{
"name" : "popThreadDefault",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Pops context off the thread-default context stack (verifying that\n it was on the top of the stack).\n Since 2.22\n\t \n",
"line" : 557}
]
}
]
}
,
{
"name" : "glib.MainLoop",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MainLoop.d",
"members" : [
{
"name" : "MainLoop",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The main event loop manages all the available sources of events for\n GLib and GTK+ applications. These events can come from any number of\n different types of sources such as file descriptors (plain files,\n pipes or sockets) and timeouts. New types of event sources can also\n be added using g_source_attach().\n To allow multiple independent sets of sources to be handled in\n different threads, each source is associated with a GMainContext.\n A GMainContext can only be running in a single thread, but\n sources can be added to it and removed from it from other threads.\n Each event source is assigned a priority. The default priority,\n G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n Values greater than 0 denote lower priorities. Events from high priority\n sources are always processed before events from lower priority sources.\n Idle functions can also be added, and assigned a priority. These will\n be run whenever no events with a higher priority are ready to be processed.\n The GMainLoop data type represents a main event loop. A GMainLoop is\n created with g_main_loop_new(). After adding the initial event sources,\n g_main_loop_run() is called. This continuously checks for new events from\n each of the event sources and dispatches them. Finally, the processing of\n an event from one of the sources leads to a call to g_main_loop_quit() to\n exit the main loop, and g_main_loop_run() returns.\n It is possible to create new instances of GMainLoop recursively.\n This is often used in GTK+ applications when showing modal dialog\n boxes. Note that event sources are associated with a particular\n GMainContext, and will be checked and dispatched for all main\n loops associated with that GMainContext.\n GTK+ contains wrappers of some of these functions, e.g. gtk_main(),\n gtk_main_quit() and gtk_events_pending().\n Creating new source types\n One of the unusual features of the GMainLoop functionality\n is that new types of event source can be created and used in\n addition to the builtin type of event source. A new event source\n type is used for handling GDK events. A new source type is created\n by deriving from the GSource structure.\n The derived type of source is represented by a structure that has\n the GSource structure as a first element, and other elements specific\n to the new source type. To create an instance of the new source type,\n call g_source_new() passing in the size of the derived structure and\n a table of functions. These GSourceFuncs determine the behavior of\n the new source type.\n New source types basically interact with the main context\n in two ways. Their prepare function in GSourceFuncs can set a timeout\n to determine the maximum amount of time that the main loop will sleep\n before checking the source again. In addition, or as well, the source\n can add file descriptors to the set that the main context checks using\n g_source_add_poll().\n <hr>\n Customizing the main loop iteration\n Single iterations of a GMainContext can be run with\n g_main_context_iteration(). In some cases, more detailed control\n of exactly how the details of the main loop work is desired, for\n instance, when integrating the GMainLoop with an external main loop.\n In such cases, you can call the component functions of\n g_main_context_iteration() directly. These functions are\n g_main_context_prepare(), g_main_context_query(),\n g_main_context_check() and g_main_context_dispatch().\n The operation of these functions can best be seen in terms\n of a state diagram, as shown in Figure  1, “States of a Main Context”.\n Figure  1.  States of a Main Context\n \n",
"line" : 143,
"base" : "Object",
"members" : [
{
"name" : "gMainLoop",
"kind" : "variable",
"protection" : "protected",
"type" : "GMainLoop*",
"comment" : " the main Gtk struct \n",
"line" : 146}
,
{
"name" : "getMainLoopStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMainLoop*()",
"line" : 149}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 156}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MainLoop(GMainLoop* gMainLoop)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 164}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MainLoop(MainContext context, int isRunning)",
"comment" : "\n\t \n\n Creates a new GMainLoop structure.\n Params:\n context = a GMainContext (if NULL, the default context will be used).\n isRunning = set to TRUE to indicate that the loop is running. This\n is not very important since calling g_main_loop_run() will set this to\n TRUE anyway.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 194}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "MainLoop()",
"comment" : "\n Increases the reference count on a GMainLoop object by one.\n Returns: loop\n\t \n",
"line" : 209}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decreases the reference count on a GMainLoop object by one. If\n the result is zero, free the loop and free all associated memory.\n\t \n",
"line" : 224}
,
{
"name" : "run",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Runs a main loop until g_main_loop_quit() is called on the loop.\n If this is called for the thread of the loop's GMainContext,\n it will process events from the loop, otherwise it will\n simply wait.\n\t \n",
"line" : 236}
,
{
"name" : "quit",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Stops a GMainLoop from running. Any calls to g_main_loop_run()\n for the loop will return.\n Note that sources that have already been dispatched when\n g_main_loop_quit() is called will still be executed.\n\t \n",
"line" : 248}
,
{
"name" : "isRunning",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks to see if the main loop is currently being run via g_main_loop_run().\n Returns: TRUE if the mainloop is currently being run.\n\t \n",
"line" : 258}
,
{
"name" : "getContext",
"kind" : "function",
"protection" : "public",
"type" : "MainContext()",
"comment" : "\n Returns the GMainContext of loop.\n Returns: the GMainContext of loop\n\t \n",
"line" : 268}
,
{
"name" : "mainDepth",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the depth of the stack of calls to\n g_main_context_dispatch() on any GMainContext in the current thread.\n  That is, when called from the toplevel, it gives 0. When\n called from within a callback from g_main_context_iteration()\n (or g_main_loop_run(), etc.) it returns 1. When called from within\n a callback to a recursive call to g_main_context_iterate(),\n it returns 2. And so forth.\n Returns: The main loop recursion level in the current thread\n\t \n",
"line" : 289}
,
{
"name" : "mainCurrentSource",
"kind" : "function",
"protection" : "public",
"type" : "Source()",
"comment" : "\n Returns the currently firing source for this thread.\n Since 2.12\n Returns: The currently firing source or NULL.\n\t \n",
"line" : 300}
,
{
"name" : "poll",
"kind" : "function",
"protection" : "public",
"type" : "int(GPollFD[] fds, int timeout)",
"comment" : "\n Polls fds, as with the poll() system call, but portably. (On\n systems that don't have poll(), it is emulated using select().)\n This is used internally by GMainContext, but it can be called\n directly if you need to block until a file descriptor is ready, but\n don't want to run the full main loop.\n Each element of fds is a GPollFD describing a single file\n descriptor to poll. The fd field indicates the file descriptor,\n and the events field indicates the events to poll for. On return,\n the revents fields will be filled with the events that actually\n occurred.\n On POSIX systems, the file descriptors in fds can be any sort of\n file descriptor, but the situation is much more complicated on\n Windows. If you need to use g_poll() in code that has to run on\n Windows, the easiest solution is to construct all of your\n GPollFDs with g_io_channel_win32_make_pollfd().\n Since 2.20\n Params:\n fds = file descriptors to poll\n timeout = amount of time to wait, in milliseconds, or -1 to wait forever\n Returns: the number of entries in fds whose revents fields were filled in, or 0 if the operation timed out, or -1 on error or if the call was interrupted.\n\t \n",
"line" : 333}
]
}
]
}
,
{
"name" : "glib.MappedFile",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MappedFile.d",
"members" : [
{
"name" : "MappedFile",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n There is a group of functions which wrap the common POSIX functions\n dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),\n g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these\n wrappers is to make it possible to handle file names with any Unicode\n characters in them on Windows without having to use ifdefs and the\n wide character API in the application code.\n The pathname argument should be in the GLib file name encoding. On\n POSIX this is the actual on-disk encoding which might correspond to\n the locale settings of the process (or the\n G_FILENAME_ENCODING environment variable), or not.\n On Windows the GLib file name encoding is UTF-8. Note that the\n Microsoft C library does not use UTF-8, but has separate APIs for\n current system code page and wide characters (UTF-16). The GLib\n wrappers call the wide character API if present (on modern Windows\n systems), otherwise convert to\/from the system code page.\n Another group of functions allows to open and read directories\n in the GLib file name encoding. These are g_dir_open(),\n g_dir_read_name(), g_dir_rewind(), g_dir_close().\n \n",
"line" : 92,
"base" : "Object",
"members" : [
{
"name" : "gMappedFile",
"kind" : "variable",
"protection" : "protected",
"type" : "GMappedFile*",
"comment" : " the main Gtk struct \n",
"line" : 95}
,
{
"name" : "getMappedFileStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMappedFile*()",
"line" : 98}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MappedFile(GMappedFile* gMappedFile)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MappedFile(string filename, int writable)",
"comment" : "\n\t \n\n Maps a file into memory. On UNIX, this is using the mmap() function.\n If writable is TRUE, the mapped buffer may be modified, otherwise\n it is an error to modify the mapped buffer. Modifications to the buffer\n are not visible to other processes mapping the same file, and are not\n written back to the file.\n Note that modifications of the underlying file might affect the contents\n of the GMappedFile. Therefore, mapping should only be used if the file\n will not be modified, or if all modifications of the file are done\n atomically (e.g. using g_file_set_contents()).\n Since 2.8\n Params:\n filename = The path of the file to load, in the GLib filename encoding\n writable = whether the mapping should be writable\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 143}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "MappedFile()",
"comment" : "\n Increments the reference count of file by one. It is safe to call\n this function from any thread.\n Since 2.22\n Returns: the passed in GMappedFile.\n\t \n",
"line" : 168}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decrements the reference count of file by one. If the reference count\n drops to 0, unmaps the buffer of file and frees it.\n It is safe to call this function from any thread.\n Since 2.22\n\t \n",
"line" : 185}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_mapped_file_free has been deprecated since version 2.22 and should not be used in newly-written code. Use g_mapped_file_unref() instead.\n This call existed before GMappedFile had refcounting and is currently\n exactly the same as g_mapped_file_unref().\n Since 2.8\n\t \n",
"line" : 198}
,
{
"name" : "getLength",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Returns the length of the contents of a GMappedFile.\n Since 2.8\n Returns: the length of the contents of file.\n\t \n",
"line" : 209}
,
{
"name" : "getContents",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the contents of a GMappedFile.\n Note that the contents may not be zero-terminated,\n even if the GMappedFile is backed by a text file.\n If the file is empty then NULL is returned.\n Since 2.8\n Returns: the contents of file, or NULL.\n\t \n",
"line" : 223}
]
}
]
}
,
{
"name" : "glib.MatchInfo",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MatchInfo.d",
"members" : [
{
"name" : "MatchInfo",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The g_regex_*() functions implement regular\n expression pattern matching using syntax and semantics similar to\n Perl regular expression.\n Some functions accept a start_position argument, setting it differs\n from just passing over a shortened string and setting G_REGEX_MATCH_NOTBOL\n in the case of a pattern that begins with any kind of lookbehind assertion.\n For example, consider the pattern \"\\Biss\\B\" which finds occurrences of \"iss\"\n in the middle of words. (\"\\B\" matches only if the current position in the\n subject is not a word boundary.) When applied to the string \"Mississipi\"\n from the fourth byte, namely \"issipi\", it does not match, because \"\\B\" is\n always false at the start of the subject, which is deemed to be a word\n boundary. However, if the entire string is passed , but with\n start_position set to 4, it finds the second occurrence of \"iss\" because\n it is able to look behind the starting point to discover that it is\n preceded by a letter.\n Note that, unless you set the G_REGEX_RAW flag, all the strings passed\n to these functions must be encoded in UTF-8. The lengths and the positions\n inside the strings are in bytes and not in characters, so, for instance,\n \"\\xc3\\xa0\" (i.e. \"  \") is two bytes long but it is treated as a\n single character. If you set G_REGEX_RAW the strings can be non-valid\n UTF-8 strings and a byte is treated as a character, so \"\\xc3\\xa0\" is two\n bytes and two characters long.\n When matching a pattern, \"\\n\" matches only against a \"\\n\" character in\n the string, and \"\\r\" matches only a \"\\r\" character. To match any newline\n sequence use \"\\R\". This particular group matches either the two-character\n sequence CR + LF (\"\\r\\n\"), or one of the single characters LF (linefeed,\n U+000A, \"\\n\"), VT vertical tab, U+000B, \"\\v\"), FF (formfeed, U+000C, \"\\f\"),\n CR (carriage return, U+000D, \"\\r\"), NEL (next line, U+0085), LS (line\n separator, U+2028), or PS (paragraph separator, U+2029).\n The behaviour of the dot, circumflex, and dollar metacharacters are\n affected by newline characters, the default is to recognize any newline\n character (the same characters recognized by \"\\R\"). This can be changed\n with G_REGEX_NEWLINE_CR, G_REGEX_NEWLINE_LF and G_REGEX_NEWLINE_CRLF\n compile options, and with G_REGEX_MATCH_NEWLINE_ANY,\n G_REGEX_MATCH_NEWLINE_CR, G_REGEX_MATCH_NEWLINE_LF and\n G_REGEX_MATCH_NEWLINE_CRLF match options. These settings are also\n relevant when compiling a pattern if G_REGEX_EXTENDED is set, and an\n unescaped \"#\" outside a character class is encountered. This indicates\n a comment that lasts until after the next newline.\n Creating and manipulating the same GRegex structure from different\n threads is not a problem as GRegex does not modify its internal\n state between creation and destruction, on the other hand GMatchInfo\n is not threadsafe.\n The regular expressions low-level functionalities are obtained through\n the excellent PCRE library\n written by Philip Hazel.\n \n",
"line" : 122,
"base" : "Object",
"members" : [
{
"name" : "gMatchInfo",
"kind" : "variable",
"protection" : "protected",
"type" : "GMatchInfo*",
"comment" : " the main Gtk struct \n",
"line" : 125}
,
{
"name" : "getMatchInfoStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMatchInfo*()",
"line" : 128}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 135}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MatchInfo(GMatchInfo* gMatchInfo)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 143}
,
{
"name" : "getRegex",
"kind" : "function",
"protection" : "public",
"type" : "Regex()",
"comment" : "\n\t \n\n Returns GRegex object used in match_info. It belongs to Glib\n and must not be freed. Use g_regex_ref() if you need to keep it\n after you free match_info object.\n Since 2.14\n Returns: GRegex object used in match_info\n\t \n",
"line" : 163}
,
{
"name" : "getString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the string searched with match_info. This is the\n string passed to g_regex_match() or g_regex_replace() so\n you may not free it before calling this function.\n Since 2.14\n Returns: the string searched with match_info\n\t \n",
"line" : 181}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees all the memory associated with the GMatchInfo structure.\n Since 2.14\n\t \n",
"line" : 191}
,
{
"name" : "matches",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether the previous match operation succeeded.\n Since 2.14\n Returns: TRUE if the previous match operation succeeded, FALSE otherwise\n\t \n",
"line" : 202}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Scans for the next match using the same parameters of the previous\n call to g_regex_match_full() or g_regex_match() that returned\n match_info.\n The match is done on the string passed to the match function, so you\n cannot free it before calling this function.\n Since 2.14\n Returns: TRUE is the string matched, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 218}
,
{
"name" : "getMatchCount",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Retrieves the number of matched substrings (including substring 0,\n that is the whole matched text), so 1 is returned if the pattern\n has no substrings in it and 0 is returned if the match failed.\n If the last match was obtained using the DFA algorithm, that is\n using g_regex_match_all() or g_regex_match_all_full(), the retrieved\n count is not that of the number of capturing parentheses but that of\n the number of matched substrings.\n Since 2.14\n Returns: Number of matched substrings, or -1 if an error occurred\n\t \n",
"line" : 244}
,
{
"name" : "isPartialMatch",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Usually if the string passed to g_regex_match*() matches as far as\n it goes, but is too short to match the entire pattern, FALSE is\n returned. There are circumstances where it might be helpful to\n distinguish this case from other cases in which there is no match.\n Consider, for example, an application where a human is required to\n type in data for a field with specific formatting requirements. An\n example might be a date in the form ddmmmyy, defined by the pattern\n \"^\\d?\\d(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\d\\d$\".\n If the application sees the user’s keystrokes one by one, and can\n check that what has been typed so far is potentially valid, it is\n able to raise an error as soon as a mistake is made.\n GRegex supports the concept of partial matching by means of the\n G_REGEX_MATCH_PARTIAL flag. When this is set the return code for\n g_regex_match() or g_regex_match_full() is, as usual, TRUE\n for a complete match, FALSE otherwise. But, when these functions\n return FALSE, you can check if the match was partial calling\n g_match_info_is_partial_match().\n When using partial matching you cannot use g_match_info_fetch*().\n Because of the way certain internal optimizations are implemented\n the partial matching algorithm cannot be used with all patterns.\n So repeated single characters such as \"a{2,4}\" and repeated single\n meta-sequences such as \"\\d+\" are not permitted if the maximum number\n of occurrences is greater than one. Optional items such as \"\\d?\"\n (where the maximum is one) are permitted. Quantifiers with any values\n are permitted after parentheses, so the invalid examples above can be\n coded thus \"(a){2,4}\" and \"(\\d)+\". If G_REGEX_MATCH_PARTIAL is set\n for a pattern that does not conform to the restrictions, matching\n functions return an error.\n Since 2.14\n Returns: TRUE if the match was partial, FALSE otherwise\n\t \n",
"line" : 282}
,
{
"name" : "expandReferences",
"kind" : "function",
"protection" : "public",
"type" : "string(string stringToExpand)",
"comment" : "\n Returns a new string containing the text in string_to_expand with\n references and escape sequences expanded. References refer to the last\n match done with string against regex and have the same syntax used by\n g_regex_replace().\n The string_to_expand must be UTF-8 encoded even if G_REGEX_RAW was\n passed to g_regex_new().\n The backreferences are extracted from the string passed to the match\n function, so you cannot call this function after freeing the string.\n match_info may be NULL in which case string_to_expand must not\n contain references. For instance \"foo\\n\" does not refer to an actual\n pattern and '\\n' merely will be replaced with \\n character,\n while to expand \"\\0\" (whole match) one needs the result of a match.\n Use g_regex_check_replacement() to find out whether string_to_expand\n contains references.\n Since 2.14\n Params:\n stringToExpand = the string to expand\n Returns: the expanded string, or NULL if an error occurred. [allow-none]\n Throws: GException on failure.\n\t \n",
"line" : 309}
,
{
"name" : "fetch",
"kind" : "function",
"protection" : "public",
"type" : "string(int matchNum)",
"comment" : "\n Retrieves the text matching the match_num'th capturing\n parentheses. 0 is the full text of the match, 1 is the first paren\n set, 2 the second, and so on.\n If match_num is a valid sub pattern but it didn't match anything\n (e.g. sub pattern 1, matching \"b\" against \"(a)?b\") then an empty\n string is returned.\n If the match was obtained using the DFA algorithm, that is using\n g_regex_match_all() or g_regex_match_all_full(), the retrieved\n string is not that of a set of parentheses but that of a matched\n substring. Substrings are matched in reverse order of length, so\n 0 is the longest match.\n The string is fetched from the string passed to the match function,\n so you cannot call this function after freeing the string.\n Since 2.14\n Params:\n matchNum = number of the sub expression\n Returns: The matched substring, or NULL if an error occurred. You have to free the string yourself. [allow-none]\n\t \n",
"line" : 343}
,
{
"name" : "fetchPos",
"kind" : "function",
"protection" : "public",
"type" : "int(int matchNum, out int startPos, out int endPos)",
"comment" : "\n Retrieves the position in bytes of the match_num'th capturing\n parentheses. 0 is the full text of the match, 1 is the first\n paren set, 2 the second, and so on.\n If match_num is a valid sub pattern but it didn't match anything\n (e.g. sub pattern 1, matching \"b\" against \"(a)?b\") then start_pos\n and end_pos are set to -1 and TRUE is returned.\n If the match was obtained using the DFA algorithm, that is using\n g_regex_match_all() or g_regex_match_all_full(), the retrieved\n position is not that of a set of parentheses but that of a matched\n substring. Substrings are matched in reverse order of length, so\n 0 is the longest match.\n Since 2.14\n Params:\n matchNum = number of the sub expression\n startPos = pointer to location where to store\n  the start position, or NULL. [out][allow-none]\n endPos = pointer to location where to store\n  the end position, or NULL. [out][allow-none]\n Returns: TRUE if the position was fetched, FALSE otherwise. If the position cannot be fetched, start_pos and end_pos are left unchanged\n\t \n",
"line" : 370}
,
{
"name" : "fetchNamed",
"kind" : "function",
"protection" : "public",
"type" : "string(string name)",
"comment" : "\n Retrieves the text matching the capturing parentheses named name.\n If name is a valid sub pattern name but it didn't match anything\n (e.g. sub pattern \"X\", matching \"b\" against \"(?P<X>a)?b\")\n then an empty string is returned.\n The string is fetched from the string passed to the match function,\n so you cannot call this function after freeing the string.\n Since 2.14\n Params:\n name = name of the subexpression\n Returns: The matched substring, or NULL if an error occurred. You have to free the string yourself. [allow-none]\n\t \n",
"line" : 388}
,
{
"name" : "fetchNamedPos",
"kind" : "function",
"protection" : "public",
"type" : "int(string name, out int startPos, out int endPos)",
"comment" : "\n Retrieves the position in bytes of the capturing parentheses named name.\n If name is a valid sub pattern name but it didn't match anything\n (e.g. sub pattern \"X\", matching \"b\" against \"(?P<X>a)?b\")\n then start_pos and end_pos are set to -1 and TRUE is returned.\n Since 2.14\n Params:\n name = name of the subexpression\n startPos = pointer to location where to store\n  the start position, or NULL. [out][allow-none]\n endPos = pointer to location where to store\n  the end position, or NULL. [out][allow-none]\n Returns: TRUE if the position was fetched, FALSE otherwise. If the position cannot be fetched, start_pos and end_pos are left unchanged.\n\t \n",
"line" : 408}
,
{
"name" : "fetchAll",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Bundles up pointers to each of the matching substrings from a match\n and stores them in an array of gchar pointers. The first element in\n the returned array is the match number 0, i.e. the entire matched\n text.\n If a sub pattern didn't match anything (e.g. sub pattern 1, matching\n \"b\" against \"(a)?b\") then an empty string is inserted.\n If the last match was obtained using the DFA algorithm, that is using\n g_regex_match_all() or g_regex_match_all_full(), the retrieved\n strings are not that matched by sets of parentheses but that of the\n matched substring. Substrings are matched in reverse order of length,\n so the first one is the longest match.\n The strings are fetched from the string passed to the match function,\n so you cannot call this function after freeing the string.\n Since 2.14\n Returns: a NULL-terminated array of gchar * pointers. It must be freed using g_strfreev(). If the previous match failed NULL is returned. [allow-none]\n\t \n",
"line" : 431}
]
}
]
}
,
{
"name" : "glib.MemoryChunk",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MemoryChunk.d",
"members" : [
{
"name" : "MemoryChunk",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Memory chunks provide an space-efficient way to allocate equal-sized\n pieces of memory, called atoms. However, due to the administrative\n overhead (in particular for G_ALLOC_AND_FREE, and when used from\n multiple threads), they are in practise often slower than direct use\n of g_malloc(). Therefore, memory chunks have been deprecated in\n favor of the slice\n allocator, which has been added in 2.10. All internal uses of\n memory chunks in GLib have been converted to the\n g_slice API.\n There are two types of memory chunks, G_ALLOC_ONLY, and\n G_ALLOC_AND_FREE.\n  G_ALLOC_ONLY\n chunks only allow allocation of atoms. The atoms can never be freed\n individually. The memory chunk can only be free in its entirety.\n  G_ALLOC_AND_FREE chunks do\n allow atoms to be freed individually. The disadvantage of this is\n that the memory chunk has to keep track of which atoms have been\n freed. This results in more memory being used and a slight\n degradation in performance.\n To create a memory chunk use g_mem_chunk_new() or the convenience\n macro g_mem_chunk_create().\n To allocate a new atom use g_mem_chunk_alloc(),\n g_mem_chunk_alloc0(), or the convenience macros g_chunk_new() or\n g_chunk_new0().\n To free an atom use g_mem_chunk_free(), or the convenience macro\n g_chunk_free(). (Atoms can only be freed if the memory chunk is\n created with the type set to G_ALLOC_AND_FREE.)\n To free any blocks of memory which are no longer being used, use\n g_mem_chunk_clean(). To clean all memory chunks, use g_blow_chunks().\n To reset the memory chunk, freeing all of the atoms, use\n g_mem_chunk_reset().\n To destroy a memory chunk, use g_mem_chunk_destroy().\n To help debug memory chunks, use g_mem_chunk_info() and\n g_mem_chunk_print().\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n \n",
"line" : 107,
"base" : "Object",
"members" : [
{
"name" : "gMemChunk",
"kind" : "variable",
"protection" : "protected",
"type" : "GMemChunk*",
"comment" : " the main Gtk struct \n",
"line" : 110}
,
{
"name" : "getMemoryChunkStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMemChunk*()",
"line" : 113}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 120}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryChunk(GMemChunk* gMemChunk)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 128}
,
{
"name" : "print",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_mem_chunk_print has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Outputs debugging information for a GMemChunk.\n It outputs the name of the GMemChunk (set with g_mem_chunk_new()),\n the number of bytes used, and the number of blocks of memory allocated.\n\t \n",
"line" : 156}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "MemoryChunk(string name, int atomSize, ulong areaSize, int type)",
"comment" : "\n\t \n\n Warning\n g_mem_chunk_new has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Creates a new GMemChunk.\n Params:\n name = a string to identify the GMemChunk. It is not copied so it\n  should be valid for the lifetime of the GMemChunk. It is\n  only used in g_mem_chunk_print(), which is used for debugging.\n atomSize = the size, in bytes, of each element in the GMemChunk.\n areaSize = the size, in bytes, of each block of memory allocated to\n  contain the atoms.\n type = the type of the GMemChunk. G_ALLOC_AND_FREE is used if the\n  atoms will be freed individually. G_ALLOC_ONLY should be\n  used if atoms will never be freed individually.\n  G_ALLOC_ONLY is quicker, since it does not need to track\n  free atoms, but it obviously wastes memory if you no longer\n  need many of the atoms.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 194}
,
{
"name" : "alloc",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Warning\n g_mem_chunk_alloc has been deprecated since version 2.10 and should not be used in newly-written code. Use g_slice_alloc() instead\n Allocates an atom of memory from a GMemChunk.\n Returns: a pointer to the allocated atom.\n\t \n",
"line" : 211}
,
{
"name" : "alloc0",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Warning\n g_mem_chunk_alloc0 has been deprecated since version 2.10 and should not be used in newly-written code. Use g_slice_alloc0() instead\n Allocates an atom of memory from a GMemChunk, setting the memory to\n 0.\n Returns: a pointer to the allocated atom.\n\t \n",
"line" : 224}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void(void* mem)",
"comment" : "\n Warning\n g_mem_chunk_free has been deprecated since version 2.10 and should not be used in newly-written code. Use g_slice_free1() instead\n Frees an atom in a GMemChunk. This should only be called if the\n GMemChunk was created with G_ALLOC_AND_FREE. Otherwise it will\n simply return.\n Params:\n mem = a pointer to the atom to free.\n\t \n",
"line" : 239}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_mem_chunk_destroy has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Frees all of the memory allocated for a GMemChunk.\n\t \n",
"line" : 251}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_mem_chunk_reset has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Resets a GMemChunk to its initial state. It frees all of the\n currently allocated blocks of memory.\n\t \n",
"line" : 264}
,
{
"name" : "clean",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_mem_chunk_clean has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Frees any blocks in a GMemChunk which are no longer being used.\n\t \n",
"line" : 276}
,
{
"name" : "blowChunks",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_blow_chunks has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Calls g_mem_chunk_clean() on all GMemChunk objects.\n\t \n",
"line" : 288}
,
{
"name" : "info",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_mem_chunk_info has been deprecated since version 2.10 and should not be used in newly-written code. Use the slice\n  allocator instead\n Outputs debugging information for all GMemChunk objects currently\n in use. It outputs the number of GMemChunk objects currently\n allocated, and calls g_mem_chunk_print() to output information on\n each one.\n\t \n",
"line" : 303}
]
}
]
}
,
{
"name" : "glib.Memory",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Memory.d",
"members" : [
{
"name" : "Memory",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n These functions provide support for allocating and freeing memory.\n Note\n If any call to allocate memory fails, the application is terminated.\n This also means that there is no need to check if the call succeeded.\n Note\n It's important to match g_malloc() with g_free(), plain malloc() with free(),\n and (if you're using C++) new with delete and new[] with delete[]. Otherwise\n bad things can happen, since these allocators may use different memory\n pools (and new\/delete call constructors and destructors). See also\n g_mem_set_vtable().\n \n",
"line" : 77,
"base" : "Object",
"members" : [
{
"name" : "malloc",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBytes)",
"comment" : "\n\t \n\n Allocates n_bytes bytes of memory.\n If n_bytes is 0 it returns NULL.\n Params:\n nBytes = the number of bytes to allocate\n Returns: a pointer to the allocated memory\n\t \n",
"line" : 89}
,
{
"name" : "malloc0",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBytes)",
"comment" : "\n Allocates n_bytes bytes of memory, initialized to 0's.\n If n_bytes is 0 it returns NULL.\n Params:\n nBytes = the number of bytes to allocate\n Returns: a pointer to the allocated memory\n\t \n",
"line" : 102}
,
{
"name" : "realloc",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* mem, ulong nBytes)",
"comment" : "\n Reallocates the memory pointed to by mem, so that it now has space for\n n_bytes bytes of memory. It returns the new address of the memory, which may\n have been moved. mem may be NULL, in which case it's considered to\n have zero-length. n_bytes may be 0, in which case NULL will be returned\n and mem will be freed unless it is NULL.\n Params:\n mem = the memory to reallocate\n nBytes = new size of the memory in bytes\n Returns: the new address of the allocated memory\n\t \n",
"line" : 119}
,
{
"name" : "tryMalloc",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBytes)",
"comment" : "\n Attempts to allocate n_bytes, and returns NULL on failure.\n Contrast with g_malloc(), which aborts the program on failure.\n Params:\n nBytes = number of bytes to allocate.\n Returns: the allocated memory, or NULL.\n\t \n",
"line" : 132}
,
{
"name" : "tryMalloc0",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBytes)",
"comment" : "\n Attempts to allocate n_bytes, initialized to 0's, and returns NULL on\n failure. Contrast with g_malloc0(), which aborts the program on failure.\n Since 2.8\n Params:\n nBytes = number of bytes to allocate\n Returns: the allocated memory, or NULL\n\t \n",
"line" : 146}
,
{
"name" : "tryRealloc",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* mem, ulong nBytes)",
"comment" : "\n Attempts to realloc mem to a new size, n_bytes, and returns NULL\n on failure. Contrast with g_realloc(), which aborts the program\n on failure. If mem is NULL, behaves the same as g_try_malloc().\n Params:\n mem = previously-allocated memory, or NULL.\n nBytes = number of bytes to allocate.\n Returns: the allocated memory, or NULL.\n\t \n",
"line" : 161}
,
{
"name" : "mallocN",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBlocks, ulong nBlockBytes)",
"comment" : "\n This function is similar to g_malloc(), allocating (n_blocks * n_block_bytes) bytes,\n but care is taken to detect possible overflow during multiplication.\n Since 2.24\n Params:\n nBlocks = the number of blocks to allocate\n nBlockBytes = the size of each block in bytes\n Returns: a pointer to the allocated memory\n\t \n",
"line" : 176}
,
{
"name" : "malloc0_N",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBlocks, ulong nBlockBytes)",
"comment" : "\n This function is similar to g_malloc0(), allocating (n_blocks * n_block_bytes) bytes,\n but care is taken to detect possible overflow during multiplication.\n Since 2.24\n Params:\n nBlocks = the number of blocks to allocate\n nBlockBytes = the size of each block in bytes\n Returns: a pointer to the allocated memory\n\t \n",
"line" : 191}
,
{
"name" : "reallocN",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* mem, ulong nBlocks, ulong nBlockBytes)",
"comment" : "\n This function is similar to g_realloc(), allocating (n_blocks * n_block_bytes) bytes,\n but care is taken to detect possible overflow during multiplication.\n Since 2.24\n Params:\n mem = the memory to reallocate\n nBlocks = the number of blocks to allocate\n nBlockBytes = the size of each block in bytes\n Returns: the new address of the allocated memory\n\t \n",
"line" : 207}
,
{
"name" : "tryMallocN",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBlocks, ulong nBlockBytes)",
"comment" : "\n This function is similar to g_try_malloc(), allocating (n_blocks * n_block_bytes) bytes,\n but care is taken to detect possible overflow during multiplication.\n Since 2.24\n Params:\n nBlocks = the number of blocks to allocate\n nBlockBytes = the size of each block in bytes\n Returns: the allocated memory, or NULL.\n\t \n",
"line" : 222}
,
{
"name" : "tryMalloc0_N",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong nBlocks, ulong nBlockBytes)",
"comment" : "\n This function is similar to g_try_malloc0(), allocating (n_blocks * n_block_bytes) bytes,\n but care is taken to detect possible overflow during multiplication.\n Since 2.24\n Params:\n nBlocks = the number of blocks to allocate\n nBlockBytes = the size of each block in bytes\n Returns: the allocated memory, or NULL\n\t \n",
"line" : 237}
,
{
"name" : "tryReallocN",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* mem, ulong nBlocks, ulong nBlockBytes)",
"comment" : "\n This function is similar to g_try_realloc(), allocating (n_blocks * n_block_bytes) bytes,\n but care is taken to detect possible overflow during multiplication.\n Since 2.24\n Params:\n mem = previously-allocated memory, or NULL.\n nBlocks = the number of blocks to allocate\n nBlockBytes = the size of each block in bytes\n Returns: the allocated memory, or NULL.\n\t \n",
"line" : 253}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void(void* mem)",
"comment" : "\n Frees the memory pointed to by mem.\n If mem is NULL it simply returns.\n Params:\n mem = the memory to free\n\t \n",
"line" : 265}
,
{
"name" : "memdup",
"kind" : "function",
"protection" : "public",
"type" : "void*(void* mem, uint byteSize)",
"comment" : "\n Allocates byte_size bytes of memory, and copies byte_size bytes into it\n from mem. If mem is NULL it returns NULL.\n Params:\n mem = the memory to copy.\n byteSize = the number of bytes to copy.\n Returns: a pointer to the newly-allocated copy of the memory, or NULL if mem is NULL.\n\t \n",
"line" : 279}
,
{
"name" : "memSetVtable",
"kind" : "function",
"protection" : "public",
"type" : "void(GMemVTable* vtable)",
"comment" : "\n Sets the GMemVTable to use for memory allocation. You can use this to provide\n custom memory allocation routines. This function must be called\n before using any other GLib functions. The vtable only needs to\n provide malloc(), realloc(), and free() functions; GLib can provide default\n implementations of the others. The malloc() and realloc() implementations\n should return NULL on failure, GLib will handle error-checking for you.\n vtable is copied, so need not persist after this function has been called.\n Params:\n vtable = table of memory allocation routines.\n\t \n",
"line" : 296}
,
{
"name" : "memIsSystemMalloc",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks whether the allocator used by g_malloc() is the system's\n malloc implementation. If it returns TRUE memory allocated with\n malloc() can be used interchangeable with memory allocated using g_malloc().\n This function is useful for avoiding an extra copy of allocated memory returned\n by a non-GLib-based API.\n A different allocator can be set using g_mem_set_vtable().\n Returns: if TRUE, malloc() and g_malloc() can be mixed.\n\t \n",
"line" : 311}
,
{
"name" : "memProfile",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Outputs a summary of memory usage.\n It outputs the frequency of allocations of different sizes,\n the total number of bytes which have been allocated,\n the total number of bytes which have been freed,\n and the difference between the previous two values, i.e. the number of bytes\n still in use.\n Note that this function will not output anything unless you have\n previously installed the glib_mem_profiler_table with g_mem_set_vtable().\n\t \n",
"line" : 327}
]
}
]
}
,
{
"name" : "glib.MemorySlice",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MemorySlice.d",
"members" : [
{
"name" : "MemorySlice",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Memory slices provide a space-efficient and multi-processing scalable\n way to allocate equal-sized pieces of memory, just like the original\n GMemChunks (from GLib <= 2.8), while avoiding their excessive\n memory-waste, scalability and performance problems.\n To achieve these goals, the slice allocator uses a sophisticated,\n layered design that has been inspired by Bonwick's slab allocator\n [6].\n It uses posix_memalign() to optimize allocations of many equally-sized\n chunks, and has per-thread free lists (the so-called magazine layer)\n to quickly satisfy allocation requests of already known structure sizes.\n This is accompanied by extra caching logic to keep freed memory around\n for some time before returning it to the system. Memory that is unused\n due to alignment constraints is used for cache colorization (random\n distribution of chunk addresses) to improve CPU cache utilization. The\n caching layer of the slice allocator adapts itself to high lock contention\n to improve scalability.\n The slice allocator can allocate blocks as small as two pointers, and\n unlike malloc(), it does not reserve extra space per block. For large block\n sizes, g_slice_new() and g_slice_alloc() will automatically delegate to the\n system malloc() implementation. For newly written code it is recommended\n to use the new g_slice API instead of g_malloc() and\n friends, as long as objects are not resized during their lifetime and the\n object size used at allocation time is still available when freeing.\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n \n",
"line" : 92,
"base" : "Object",
"members" : [
{
"name" : "alloc",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong blockSize)",
"comment" : "\n\t \n\n Allocates a block of memory from the slice allocator.\n The block adress handed out can be expected to be aligned\n to at least 1 * sizeof (void*),\n though in general slices are 2 * sizeof (void*) bytes aligned,\n if a malloc() fallback implementation is used instead,\n the alignment may be reduced in a libc dependent fashion.\n Note that the underlying slice allocation mechanism can\n be changed with the G_SLICE=always-malloc\n environment variable.\n Since 2.10\n Params:\n blockSize = the number of bytes to allocate\n Returns: a pointer to the allocated memory block\n\t \n",
"line" : 112}
,
{
"name" : "alloc0",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong blockSize)",
"comment" : "\n Allocates a block of memory via g_slice_alloc()\n and initialize the returned memory to 0.\n Note that the underlying slice allocation mechanism can\n be changed with the G_SLICE=always-malloc\n environment variable.\n Since 2.10\n Params:\n blockSize = the number of bytes to allocate\n Returns: a pointer to the allocated block\n\t \n",
"line" : 129}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong blockSize, void* memBlock)",
"comment" : "\n Allocates a block of memory from the slice allocator and copies\n block_size bytes into it from mem_block.\n Since 2.14\n Params:\n blockSize = the number of bytes to allocate\n memBlock = the memory to copy\n Returns: a pointer to the allocated memory block\n\t \n",
"line" : 144}
,
{
"name" : "free1",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong blockSize, void* memBlock)",
"comment" : "\n Frees a block of memory. The memory must have been allocated via\n g_slice_alloc() or g_slice_alloc0()\n and the block_size has to match the size specified upon allocation.\n Note that the exact release behaviour can be changed with the\n G_DEBUG=gc-friendly environment variable,\n also see G_SLICE for related debugging options.\n Since 2.10\n Params:\n blockSize = the size of the block\n memBlock = a pointer to the block to free\n\t \n",
"line" : 162}
,
{
"name" : "freeChainWithOffset",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong blockSize, void* memChain, ulong nextOffset)",
"comment" : "\n Frees a linked list of memory blocks of structure type type.\n The memory blocks must be equal-sized, allocated via\n g_slice_alloc() or g_slice_alloc0()\n and linked together by a next pointer (similar to GSList). The offset\n of the next field in each block is passed as third argument.\n Note that the exact release behaviour can be changed with the\n G_DEBUG=gc-friendly environment variable,\n also see G_SLICE for related debugging options.\n Since 2.10\n Params:\n blockSize = the size of the blocks\n memChain = a pointer to the first block of the chain\n nextOffset = the offset of the next field in the blocks\n\t \n",
"line" : 183}
]
}
]
}
,
{
"name" : "glib.MessageLog",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/MessageLog.d",
"members" : [
{
"name" : "MessageLog",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n These functions provide support for logging error messages or messages\n used for debugging.\n There are several built-in levels of messages, defined in GLogLevelFlags.\n These can be extended with user-defined levels.\n \n",
"line" : 73,
"base" : "Object",
"members" : [
{
"name" : "logv",
"kind" : "function",
"protection" : "public",
"type" : "void(string logDomain, GLogLevelFlags logLevel, string format, void* args)",
"comment" : "\n\t \n\n Logs an error or debugging message.\n If the log level has been set as fatal, the abort()\n function is called to terminate the program.\n Params:\n logDomain = the log domain.\n logLevel = the log level.\n format = the message format. See the printf()\n documentation.\n args = the parameters to insert into the format string.\n\t \n",
"line" : 89}
,
{
"name" : "logSetHandler",
"kind" : "function",
"protection" : "public",
"type" : "uint(string logDomain, GLogLevelFlags logLevels, extern (C) void function(char*, GLogLevelFlags, char*, void*) logFunc, void* userData)",
"comment" : "\n Sets the log handler for a domain and a set of log levels.\n To handle fatal and recursive messages the log_levels parameter\n must be combined with the G_LOG_FLAG_FATAL and G_LOG_FLAG_RECURSION\n bit flags.\n Note that since the G_LOG_LEVEL_ERROR log level is always fatal, if\n you want to set a handler for this log level you must combine it with\n G_LOG_FLAG_FATAL.\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n $(DDOC_COMMENT example)\n Params:\n logDomain = the log domain, or NULL for the default \"\" application domain.\n logLevels = the log levels to apply the log handler for. To handle fatal\n and recursive messages as well, combine the log levels with the\n G_LOG_FLAG_FATAL and G_LOG_FLAG_RECURSION bit flags.\n logFunc = the log handler function.\n userData = data passed to the log handler.\n Returns: the id of the new handler.\n\t \n",
"line" : 115}
,
{
"name" : "logRemoveHandler",
"kind" : "function",
"protection" : "public",
"type" : "void(string logDomain, uint handlerId)",
"comment" : "\n Removes the log handler.\n Params:\n logDomain = the log domain.\n handlerId = the id of the handler, which was returned in g_log_set_handler().\n\t \n",
"line" : 127}
,
{
"name" : "logSetAlwaysFatal",
"kind" : "function",
"protection" : "public",
"type" : "GLogLevelFlags(GLogLevelFlags fatalMask)",
"comment" : "\n Sets the message levels which are always fatal, in any log domain.\n When a message with any of these levels is logged the program terminates.\n You can only set the levels defined by GLib to be fatal.\n G_LOG_LEVEL_ERROR is always fatal.\n You can also make some message levels\n fatal at runtime by setting the G_DEBUG environment variable (see\n Running GLib Applications).\n Params:\n fatalMask = the mask containing bits set for each level of error which is\n to be fatal.\n Returns: the old fatal mask.\n\t \n",
"line" : 146}
,
{
"name" : "logSetFatalMask",
"kind" : "function",
"protection" : "public",
"type" : "GLogLevelFlags(string logDomain, GLogLevelFlags fatalMask)",
"comment" : "\n Sets the log levels which are fatal in the given domain.\n G_LOG_LEVEL_ERROR is always fatal.\n Params:\n logDomain = the log domain.\n fatalMask = the new fatal mask.\n Returns: the old fatal mask for the log domain.\n\t \n",
"line" : 160}
,
{
"name" : "logDefaultHandler",
"kind" : "function",
"protection" : "public",
"type" : "void(string logDomain, GLogLevelFlags logLevel, string message, void* unusedData)",
"comment" : "\n The default log handler set up by GLib; g_log_set_default_handler()\n allows to install an alternate default log handler.\n This is used if no log handler has been set for the particular log domain\n and log level combination. It outputs the message to stderr or stdout\n and if the log level is fatal it calls abort().\n stderr is used for levels G_LOG_LEVEL_ERROR, G_LOG_LEVEL_CRITICAL,\n G_LOG_LEVEL_WARNING and G_LOG_LEVEL_MESSAGE. stdout is used for the rest.\n Params:\n logDomain = the log domain of the message.\n logLevel = the level of the message.\n message = the message.\n unusedData = data passed from g_log() which is unused.\n\t \n",
"line" : 180}
,
{
"name" : "logSetDefaultHandler",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void function(char*, GLogLevelFlags, char*, void*)(extern (C) void function(char*, GLogLevelFlags, char*, void*) logFunc, void* userData)",
"comment" : "\n Installs a default log handler which is used if no\n log handler has been set for the particular log domain\n and log level combination. By default, GLib uses\n g_log_default_handler() as default log handler.\n Since 2.6\n Params:\n logFunc = the log handler function.\n userData = data passed to the log handler.\n Returns: the previous default log handler\n\t \n",
"line" : 197}
]
}
]
}
,
{
"name" : "glib.Messages",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Messages.d",
"members" : [
{
"name" : "Messages",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n These functions provide support for outputting messages.\n The g_return family of macros (g_return_if_fail(),\n g_return_val_if_fail(), g_return_if_reached(), g_return_val_if_reached())\n should only be used for programming errors, a typical use case is\n checking for invalid parameters at the beginning of a public function.\n They should not be used if you just mean \"if (error) return\", they\n should only be used if you mean \"if (bug in program) return\".\n The program behavior is generally considered undefined after one of these\n checks fails. They are not intended for normal control flow, only to\n give a perhaps-helpful warning before giving up.\n \n",
"line" : 79,
"base" : "Object",
"members" : [
{
"name" : "setPrintHandler",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void function(char*)(extern (C) void function(char*) func)",
"comment" : "\n\t \n\n Sets the print handler.\n Any messages passed to g_print() will be output via the new handler.\n The default handler simply outputs the message to stdout.\n By providing your own handler you can redirect the output, to a GTK+\n widget or a log file for example.\n Params:\n func = the new print handler.\n Returns: the old print handler.\n\t \n",
"line" : 94}
,
{
"name" : "setPrinterrHandler",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void function(char*)(extern (C) void function(char*) func)",
"comment" : "\n Sets the handler for printing error messages.\n Any messages passed to g_printerr() will be output via the new handler.\n The default handler simply outputs the message to stderr.\n By providing your own handler you can redirect the output, to a GTK+\n widget or a log file for example.\n Params:\n func = the new error message handler.\n Returns: the old error message handler.\n\t \n",
"line" : 110}
,
{
"name" : "onErrorQuery",
"kind" : "function",
"protection" : "public",
"type" : "void(string prgName)",
"comment" : "\n Prompts the user with [E]xit, [H]alt, show [S]tack trace or [P]roceed.\n This function is intended to be used for debugging use only. The following\n example shows how it can be used together with the g_log() functions.\n $(DDOC_COMMENT example)\n If [E]xit is selected, the application terminates with a call to\n _exit(0).\n If [H]alt is selected, the application enters an infinite loop.\n The infinite loop can only be stopped by killing the application,\n or by setting glib_on_error_halt to FALSE (possibly via a debugger).\n If [S]tack trace is selected, g_on_error_stack_trace() is called. This\n invokes gdb, which attaches to the current process and shows a stack trace.\n The prompt is then shown again.\n If [P]roceed is selected, the function returns.\n This function may cause different actions on non-UNIX platforms.\n Params:\n prgName = the program name, needed by gdb for the [S]tack trace option.\n If prg_name is NULL, g_get_prgname() is called to get the program name\n (which will work correctly if gdk_init() or gtk_init() has been called).\n\t \n",
"line" : 136}
,
{
"name" : "onErrorStackTrace",
"kind" : "function",
"protection" : "public",
"type" : "void(string prgName)",
"comment" : "\n Invokes gdb, which attaches to the current process and shows a stack trace.\n Called by g_on_error_query() when the [S]tack trace option is selected.\n This function may cause different actions on non-UNIX platforms.\n Params:\n prgName = the program name, needed by gdb for the [S]tack trace option.\n If prg_name is NULL, g_get_prgname() is called to get the program name\n (which will work correctly if gdk_init() or gtk_init() has been called).\n\t \n",
"line" : 151}
]
}
]
}
,
{
"name" : "glib.Module",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Module.d",
"members" : [
{
"name" : "Module",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n These functions provide a portable way to dynamically load object files\n (commonly known as 'plug-ins').\n The current implementation supports all systems that provide\n an implementation of dlopen() (e.g. Linux\/Sun), as well as HP-UX via its\n shl_load() mechanism, and Windows platforms via DLLs.\n A program which wants to use these functions must be linked to the\n libraries output by the command pkg-config --libs gmodule-2.0.\n To use them you must first determine whether dynamic loading\n is supported on the platform by calling g_module_supported().\n If it is, you can open a module with g_module_open(),\n find the module's symbols (e.g. function names) with g_module_symbol(),\n and later close the module with g_module_close().\n g_module_name() will return the file name of a currently opened module.\n If any of the above functions fail, the error status can be found with\n g_module_error().\n The GModule implementation features reference counting for opened modules,\n and supports hook functions within a module which are called when the\n module is loaded and unloaded (see GModuleCheckInit and GModuleUnload).\n If your module introduces static data to common subsystems in the running\n program, e.g. through calling g_quark_from_static_string (\"my-module-stuff\"),\n it must ensure that it is never unloaded, by calling g_module_make_resident().\n $(DDOC_COMMENT example)\n \n",
"line" : 92,
"base" : "Object",
"members" : [
{
"name" : "gModule",
"kind" : "variable",
"protection" : "protected",
"type" : "GModule*",
"comment" : " the main Gtk struct \n",
"line" : 95}
,
{
"name" : "getModuleStruct",
"kind" : "function",
"protection" : "public",
"type" : "GModule*()",
"line" : 98}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Module(GModule* gModule)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 113}
,
{
"name" : "supported",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n\t \n\n Checks if modules are supported on the current platform.\n Returns: TRUE if modules are supported.\n\t \n",
"line" : 130}
,
{
"name" : "buildPath",
"kind" : "function",
"protection" : "public",
"type" : "string(string directory, string moduleName)",
"comment" : "\n A portable way to build the filename of a module. The platform-specific\n prefix and suffix are added to the filename, if needed, and the result is\n added to the directory, using the correct separator character.\n The directory should specify the directory where the module can be found.\n It can be NULL or an empty string to indicate that the module is in a standard\n platform-specific directory, though this is not recommended since the\n wrong module may be found.\n For example, calling g_module_build_path() on a Linux system with a directory\n of \/lib and a module_name of \"mylibrary\" will return\n \/lib\/libmylibrary.so. On a Windows system, using\n \\Windows as the directory it will return\n \\Windows\\mylibrary.dll.\n Params:\n directory = the directory where the module is. This can be NULL or the empty\n string to indicate that the standard platform-specific directories will be\n used, though that is not recommended.\n moduleName = the name of the module.\n Returns: the complete path of the module, including the standard library prefix and suffix. This should be freed when no longer needed.\n\t \n",
"line" : 156}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "Module(string fileName, GModuleFlags flags)",
"comment" : "\n Opens a module. If the module has already been opened, its reference\n count is incremented.\n First of all g_module_open() tries to open file_name as a module. If\n that fails and file_name has the \".la\"-suffix (and is a libtool archive)\n it tries to open the corresponding module. If that fails and it doesn't\n have the proper module suffix for the platform (G_MODULE_SUFFIX), this\n suffix will be appended and the corresponding module will be opended. If\n that fails and file_name doesn't have the \".la\"-suffix, this suffix is\n appended and g_module_open() tries to open the corresponding module. If\n eventually that fails as well, NULL is returned.\n Params:\n fileName = the name of the file containing the module, or NULL to obtain\n  a GModule representing the main program itself.\n flags = the flags used for opening the module. This can be the logical\n OR of any of the GModuleFlags.\n Returns: a GModule on success, or NULL on failure.\n\t \n",
"line" : 180}
,
{
"name" : "symbol",
"kind" : "function",
"protection" : "public",
"type" : "int(string symbolName, void** symbol)",
"comment" : "\n Gets a symbol pointer from a module, such as one exported by G_MODULE_EXPORT.\n Note that a valid symbol can be NULL.\n Params:\n symbolName = the name of the symbol to find.\n symbol = returns the pointer to the symbol value.\n Returns: TRUE on success.\n\t \n",
"line" : 199}
,
{
"name" : "name",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the filename from a GModule.\n Returns: the filename of the module, or \"main\" if the module is the main program itself.\n\t \n",
"line" : 209}
,
{
"name" : "makeResident",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Ensures that a module will never be unloaded.\n Any future g_module_close() calls on the module will be ignored.\n\t \n",
"line" : 219}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Closes a module.\n Returns: TRUE on success.\n\t \n",
"line" : 229}
,
{
"name" : "error",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets a string describing the last module error.\n Returns: a string describing the last module error.\n\t \n",
"line" : 239}
]
}
]
}
,
{
"name" : "glib.Node",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Node.d",
"members" : [
{
"name" : "Node",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GNode struct and its associated functions provide a N-ary tree\n data structure, where nodes in the tree can contain arbitrary data.\n To create a new tree use g_node_new().\n To insert a node into a tree use g_node_insert(),\n g_node_insert_before(), g_node_append() and g_node_prepend().\n To create a new node and insert it into a tree use\n g_node_insert_data(), g_node_insert_data_before(),\n g_node_append_data() and g_node_prepend_data().\n To reverse the children of a node use g_node_reverse_children().\n To find a node use g_node_get_root(), g_node_find(),\n g_node_find_child(), g_node_child_index(), g_node_child_position(),\n g_node_first_child(), g_node_last_child(), g_node_nth_child(),\n g_node_first_sibling(), g_node_prev_sibling(), g_node_next_sibling()\n or g_node_last_sibling().\n To get information about a node or tree use G_NODE_IS_LEAF(),\n G_NODE_IS_ROOT(), g_node_depth(), g_node_n_nodes(),\n g_node_n_children(), g_node_is_ancestor() or g_node_max_height().\n To traverse a tree, calling a function for each node visited in the\n traversal, use g_node_traverse() or g_node_children_foreach().\n To remove a node or subtree from a tree use g_node_unlink() or\n g_node_destroy().\n \n",
"line" : 89,
"base" : "Object",
"members" : [
{
"name" : "gNode",
"kind" : "variable",
"protection" : "protected",
"type" : "GNode*",
"comment" : " the main Gtk struct \n",
"line" : 92}
,
{
"name" : "getNodeStruct",
"kind" : "function",
"protection" : "public",
"type" : "GNode*()",
"line" : 95}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 102}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Node(GNode* gNode)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 110}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Node(void* data)",
"comment" : "\n\t \n\n Creates a new GNode containing the given data.\n Used to create the first node in a tree.\n Params:\n data = the data of the new node\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 130}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "Node()",
"comment" : "\n Recursively copies a GNode (but does not deep-copy the data inside the\n nodes, see g_node_copy_deep() if you need that).\n Returns: a new GNode containing the same data pointers\n\t \n",
"line" : 146}
,
{
"name" : "copyDeep",
"kind" : "function",
"protection" : "public",
"type" : "Node(extern (C) void* function(void*, void*) copyFunc, void* data)",
"comment" : "\n Recursively copies a GNode and its data.\n Since 2.4\n Params:\n copyFunc = the function which is called to copy the data inside each node,\n  or NULL to use the original data.\n data = data to pass to copy_func\n Returns: a new GNode containing copies of the data in node.\n\t \n",
"line" : 166}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "Node(int position, Node node)",
"comment" : "\n Inserts a GNode beneath the parent at the given position.\n Params:\n position = the position to place node at, with respect to its siblings\n  If position is -1, node is inserted as the last child of parent\n node = the GNode to insert\n Returns: the inserted GNode\n\t \n",
"line" : 185}
,
{
"name" : "insertBefore",
"kind" : "function",
"protection" : "public",
"type" : "Node(Node sibling, Node node)",
"comment" : "\n Inserts a GNode beneath the parent before the given sibling.\n Params:\n sibling = the sibling GNode to place node before.\n  If sibling is NULL, the node is inserted as the last child of parent.\n node = the GNode to insert\n Returns: the inserted GNode\n\t \n",
"line" : 204}
,
{
"name" : "insertAfter",
"kind" : "function",
"protection" : "public",
"type" : "Node(Node sibling, Node node)",
"comment" : "\n Inserts a GNode beneath the parent after the given sibling.\n Params:\n sibling = the sibling GNode to place node after.\n  If sibling is NULL, the node is inserted as the first child of parent.\n node = the GNode to insert\n Returns: the inserted GNode\n\t \n",
"line" : 223}
,
{
"name" : "prepend",
"kind" : "function",
"protection" : "public",
"type" : "Node(Node node)",
"comment" : "\n Inserts a GNode as the first child of the given parent.\n Params:\n node = the GNode to insert\n Returns: the inserted GNode\n\t \n",
"line" : 240}
,
{
"name" : "reverseChildren",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Reverses the order of the children of a GNode.\n (It doesn't change the order of the grandchildren.)\n\t \n",
"line" : 255}
,
{
"name" : "traverse",
"kind" : "function",
"protection" : "public",
"type" : "void(GTraverseType order, GTraverseFlags flags, int maxDepth, extern (C) int function(GNode*, void*) func, void* data)",
"comment" : "\n Traverses a tree starting at the given root GNode.\n It calls the given function for each node visited.\n The traversal can be halted at any point by returning TRUE from func.\n Params:\n order = the order in which nodes are visited - G_IN_ORDER,\n  G_PRE_ORDER, G_POST_ORDER, or G_LEVEL_ORDER.\n flags = which types of children are to be visited, one of\n  G_TRAVERSE_ALL, G_TRAVERSE_LEAVES and G_TRAVERSE_NON_LEAVES\n maxDepth = the maximum depth of the traversal. Nodes below this\n  depth will not be visited. If max_depth is -1 all nodes in\n  the tree are visited. If depth is 1, only the root is visited.\n  If depth is 2, the root and its children are visited. And so on.\n func = the function to call for each visited GNode\n data = user data to pass to the function\n\t \n",
"line" : 277}
,
{
"name" : "childrenForeach",
"kind" : "function",
"protection" : "public",
"type" : "void(GTraverseFlags flags, extern (C) void function(GNode*, void*) func, void* data)",
"comment" : "\n Calls a function for each of the children of a GNode.\n Note that it doesn't descend beneath the child nodes.\n Params:\n flags = which types of children are to be visited, one of\n  G_TRAVERSE_ALL, G_TRAVERSE_LEAVES and G_TRAVERSE_NON_LEAVES\n func = the function to call for each visited node\n data = user data to pass to the function\n\t \n",
"line" : 292}
,
{
"name" : "getRoot",
"kind" : "function",
"protection" : "public",
"type" : "Node()",
"comment" : "\n Gets the root of a tree.\n Returns: the root of the tree\n\t \n",
"line" : 302}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "Node(GTraverseType order, GTraverseFlags flags, void* data)",
"comment" : "\n Finds a GNode in a tree.\n Params:\n order = the order in which nodes are visited - G_IN_ORDER,\n  G_PRE_ORDER, G_POST_ORDER, or G_LEVEL_ORDER\n flags = which types of children are to be searched, one of\n  G_TRAVERSE_ALL, G_TRAVERSE_LEAVES and G_TRAVERSE_NON_LEAVES\n data = the data to find\n Returns: the found GNode, or NULL if the data is not found\n\t \n",
"line" : 323}
,
{
"name" : "findChild",
"kind" : "function",
"protection" : "public",
"type" : "Node(GTraverseFlags flags, void* data)",
"comment" : "\n Finds the first child of a GNode with the given data.\n Params:\n flags = which types of children are to be searched, one of\n  G_TRAVERSE_ALL, G_TRAVERSE_LEAVES and G_TRAVERSE_NON_LEAVES\n data = the data to find\n Returns: the found child GNode, or NULL if the data is not found\n\t \n",
"line" : 342}
,
{
"name" : "childIndex",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Gets the position of the first child of a GNode\n which contains the given data.\n Params:\n data = the data to find\n Returns: the index of the child of node which contains data, or -1 if the data is not found\n\t \n",
"line" : 360}
,
{
"name" : "childPosition",
"kind" : "function",
"protection" : "public",
"type" : "int(Node child)",
"comment" : "\n Gets the position of a GNode with respect to its siblings.\n child must be a child of node. The first child is numbered 0,\n the second 1, and so on.\n Params:\n child = a child of node\n Returns: the position of child with respect to its siblings\n\t \n",
"line" : 374}
,
{
"name" : "lastChild",
"kind" : "function",
"protection" : "public",
"type" : "Node()",
"comment" : "\n Gets the last child of a GNode.\n Returns: the last child of node, or NULL if node has no children\n\t \n",
"line" : 384}
,
{
"name" : "nthChild",
"kind" : "function",
"protection" : "public",
"type" : "Node(uint n)",
"comment" : "\n Gets a child of a GNode, using the given index.\n The first child is at index 0. If the index is\n too big, NULL is returned.\n Params:\n n = the index of the desired child\n Returns: the child of node at index n\n\t \n",
"line" : 403}
,
{
"name" : "firstSibling",
"kind" : "function",
"protection" : "public",
"type" : "Node()",
"comment" : "\n Gets the first sibling of a GNode.\n This could possibly be the node itself.\n Returns: the first sibling of node\n\t \n",
"line" : 419}
,
{
"name" : "lastSibling",
"kind" : "function",
"protection" : "public",
"type" : "Node()",
"comment" : "\n Gets the last sibling of a GNode.\n This could possibly be the node itself.\n Returns: the last sibling of node\n\t \n",
"line" : 435}
,
{
"name" : "depth",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the depth of a GNode.\n If node is NULL the depth is 0. The root node has a depth of 1.\n For the children of the root node the depth is 2. And so on.\n Returns: the depth of the GNode\n\t \n",
"line" : 452}
,
{
"name" : "nNodes",
"kind" : "function",
"protection" : "public",
"type" : "uint(GTraverseFlags flags)",
"comment" : "\n Gets the number of nodes in a tree.\n Params:\n flags = which types of children are to be counted, one of\n  G_TRAVERSE_ALL, G_TRAVERSE_LEAVES and G_TRAVERSE_NON_LEAVES\n Returns: the number of nodes in the tree\n\t \n",
"line" : 465}
,
{
"name" : "nChildren",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the number of children of a GNode.\n Returns: the number of children of node\n\t \n",
"line" : 475}
,
{
"name" : "isAncestor",
"kind" : "function",
"protection" : "public",
"type" : "int(Node descendant)",
"comment" : "\n Returns TRUE if node is an ancestor of descendant.\n This is true if node is the parent of descendant,\n or if node is the grandparent of descendant etc.\n Params:\n descendant = a GNode\n Returns: TRUE if node is an ancestor of descendant\n\t \n",
"line" : 489}
,
{
"name" : "maxHeight",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Gets the maximum height of all branches beneath a GNode.\n This is the maximum distance from the GNode to all leaf nodes.\n If root is NULL, 0 is returned. If root has no children,\n 1 is returned. If root has children, 2 is returned. And so on.\n Returns: the maximum height of the tree beneath root\n\t \n",
"line" : 502}
,
{
"name" : "unlink",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Unlinks a GNode from a tree, resulting in two separate trees.\n\t \n",
"line" : 511}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes root and its children from the tree, freeing any memory\n allocated.\n\t \n",
"line" : 521}
,
{
"name" : "pushAllocator",
"kind" : "function",
"protection" : "public",
"type" : "void(void* dummy)",
"comment" : "\n Warning\n g_node_push_allocator has been deprecated since version 2.10 and should not be used in newly-written code. It does nothing, since GNode has been converted to\n  the slice\n  allocator\n Sets the allocator to use to allocate GNode elements. Use\n g_node_pop_allocator() to restore the previous allocator.\n Note that this function is not available if GLib has been compiled\n with --disable-mem-pools\n Params:\n dummy = the GAllocator to use when allocating GNode elements.\n\t \n",
"line" : 539}
,
{
"name" : "popAllocator",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_node_pop_allocator has been deprecated since version 2.10 and should not be used in newly-written code. It does nothing, since GNode has been converted to\n  the slice\n  allocator\n Restores the previous GAllocator, used when allocating GNode\n elements.\n Note that this function is not available if GLib has been compiled\n with --disable-mem-pools\n\t \n",
"line" : 555}
]
}
]
}
,
{
"name" : "glib.OptionContext",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/OptionContext.d",
"members" : [
{
"name" : "OptionContext",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GOption commandline parser is intended to be a simpler replacement\n for the popt library. It supports short and long commandline options,\n as shown in the following example:\n testtreemodel -r 1 --max-size 20 --rand --display=:1.0 -vb -- file1 file2\n The example demonstrates a number of features of the GOption\n commandline parser\n  Options can be single letters, prefixed by a single dash. Multiple\n  short options can be grouped behind a single dash.\n  Long options are prefixed by two consecutive dashes.\n  Options can have an extra argument, which can be a number, a string or\n  a filename. For long options, the extra argument can be appended with\n  an equals sign after the option name, which is useful if the extra\n  argument starts with a dash, which would otherwise cause it to be\n  interpreted as another option.\n  Non-option arguments are returned to the application as rest arguments.\n  An argument consisting solely of two dashes turns off further parsing,\n  any remaining arguments (even those starting with a dash) are returned\n  to the application as rest arguments.\n Another important feature of GOption is that it can automatically\n generate nicely formatted help output. Unless it is explicitly turned\n off with g_option_context_set_help_enabled(), GOption will recognize\n the --help, -?,\n --help-all and\n --help-groupname options\n (where groupname is the name of a\n GOptionGroup) and write a text similar to the one shown in the\n following example to stdout.\n $(DDOC_COMMENT example)\n GOption groups options in GOptionGroups, which makes it easy to\n incorporate options from multiple sources. The intended use for this is\n to let applications collect option groups from the libraries it uses,\n add them to their GOptionContext, and parse all options by a single call\n to g_option_context_parse(). See gtk_get_option_group() for an example.\n If an option is declared to be of type string or filename, GOption takes\n care of converting it to the right encoding; strings are returned in\n UTF-8, filenames are returned in the GLib filename encoding. Note that\n this only works if setlocale() has been called before\n g_option_context_parse().\n Here is a complete example of setting up GOption to parse the example\n commandline above and produce the example help output.\n $(DDOC_COMMENT example)\n \n",
"line" : 119,
"base" : "Object",
"members" : [
{
"name" : "gOptionContext",
"kind" : "variable",
"protection" : "protected",
"type" : "GOptionContext*",
"comment" : " the main Gtk struct \n",
"line" : 122}
,
{
"name" : "getOptionContextStruct",
"kind" : "function",
"protection" : "public",
"type" : "GOptionContext*()",
"line" : 125}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 132}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OptionContext(GOptionContext* gOptionContext)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 140}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "int(out int argc, out string[] argv)",
"comment" : "\n Parses the command line arguments, recognizing options\n which have been added to context. A side-effect of\n calling this function is that g_set_prgname() will be\n called.\n If the parsing is successful, any parsed arguments are\n removed from the array and argc and argv are updated\n accordingly. A '--' option is stripped from argv\n unless there are unparsed options before and after it,\n or some of the options after it start with '-'. In case\n of an error, argc and argv are left unmodified.\n If automatic --help support is enabled\n (see g_option_context_set_help_enabled()), and the\n argv array contains one of the recognized help options,\n this function will produce help output to stdout and\n call exit (0).\n Note that function depends on the\n current locale for\n automatic character set conversion of string and filename\n arguments.\n Since 2.6\n Params:\n argc =  a pointer to the number of command line arguments\n argv =  a pointer to the array of command line arguments\n Returns: TRUE if the parsing was successful,  FALSE if an error occurred\n Throws: GException on failure.\n\t \n",
"line" : 177}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OptionContext(string parameterString)",
"comment" : "\n\t \n\n Creates a new option context.\n The parameter_string can serve multiple purposes. It can be used\n to add descriptions for \"rest\" arguments, which are not parsed by\n the GOptionContext, typically something like \"FILES\" or\n \"FILE1 FILE2...\". If you are using G_OPTION_REMAINING for\n collecting \"rest\" arguments, GLib handles this automatically by\n using the arg_description of the corresponding GOptionEntry in\n the usage summary.\n Another usage is to give a short summary of the program\n functionality, like \" - frob the strings\", which will be displayed\n in the same line as the usage. For a longer description of the\n program functionality that should be displayed as a paragraph\n below the usage line, use g_option_context_set_summary().\n Note that the parameter_string is translated using the\n function set with g_option_context_set_translate_func(), so\n it should normally be passed untranslated.\n Since 2.6\n Params:\n parameterString = a string which is displayed in\n  the first line of --help output, after the\n  usage summary\n  programname [OPTION...]\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 222}
,
{
"name" : "setSummary",
"kind" : "function",
"protection" : "public",
"type" : "void(string summary)",
"comment" : "\n Adds a string to be displayed in --help output\n before the list of options. This is typically a summary of the\n program functionality.\n Note that the summary is translated (see\n g_option_context_set_translate_func() and\n g_option_context_set_translation_domain()).\n Since 2.12\n Params:\n summary = a string to be shown in --help output\n  before the list of options, or NULL\n\t \n",
"line" : 245}
,
{
"name" : "getSummary",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the summary. See g_option_context_set_summary().\n Since 2.12\n Returns: the summary\n\t \n",
"line" : 256}
,
{
"name" : "setDescription",
"kind" : "function",
"protection" : "public",
"type" : "void(string description)",
"comment" : "\n Adds a string to be displayed in --help output\n after the list of options. This text often includes a bug reporting\n address.\n Note that the summary is translated (see\n g_option_context_set_translate_func()).\n Since 2.12\n Params:\n description = a string to be shown in --help output\n  after the list of options, or NULL\n\t \n",
"line" : 273}
,
{
"name" : "getDescription",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the description. See g_option_context_set_description().\n Since 2.12\n Returns: the description\n\t \n",
"line" : 284}
,
{
"name" : "setTranslateFunc",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) char* function(char*, void*) func, void* data, extern (C) void function(void* cbData) destroyNotify)",
"comment" : "\n Sets the function which is used to translate the contexts\n user-visible strings, for --help output.\n If func is NULL, strings are not translated.\n Note that option groups have their own translation functions,\n this function only affects the parameter_string (see g_option_context_new()),\n the summary (see g_option_context_set_summary()) and the description\n (see g_option_context_set_description()).\n If you are using gettext(), you only need to set the translation\n domain, see g_option_context_set_translation_domain().\n Since 2.12\n Params:\n func = the GTranslateFunc, or NULL\n data = user data to pass to func, or NULL\n destroyNotify = a function which gets called to free data, or NULL\n\t \n",
"line" : 306}
,
{
"name" : "setTranslationDomain",
"kind" : "function",
"protection" : "public",
"type" : "void(string domain)",
"comment" : "\n A convenience function to use gettext() for translating\n user-visible strings.\n Since 2.12\n Params:\n domain = the domain to use\n\t \n",
"line" : 319}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees context and all the groups which have been\n added to it.\n Please note that parsed arguments need to be freed separately (see\n GOptionEntry).\n Since 2.6\n\t \n",
"line" : 332}
,
{
"name" : "setHelpEnabled",
"kind" : "function",
"protection" : "public",
"type" : "void(int helpEnabled)",
"comment" : "\n Enables or disables automatic generation of --help\n output. By default, g_option_context_parse() recognizes\n --help, -h,\n -?, --help-all\n and --help-groupname and creates\n suitable output to stdout.\n Since 2.6\n Params:\n helpEnabled = TRUE to enable --help, FALSE to disable it\n\t \n",
"line" : 349}
,
{
"name" : "getHelpEnabled",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether automatic --help generation\n is turned on for context. See g_option_context_set_help_enabled().\n Since 2.6\n Returns: TRUE if automatic help generation is turned on.\n\t \n",
"line" : 361}
,
{
"name" : "setIgnoreUnknownOptions",
"kind" : "function",
"protection" : "public",
"type" : "void(int ignoreUnknown)",
"comment" : "\n Sets whether to ignore unknown options or not. If an argument is\n ignored, it is left in the argv array after parsing. By default,\n g_option_context_parse() treats unknown options as error.\n This setting does not affect non-option arguments (i.e. arguments\n which don't start with a dash). But note that GOption cannot reliably\n determine whether a non-option belongs to a preceding unknown option.\n Since 2.6\n Params:\n ignoreUnknown = TRUE to ignore unknown options, FALSE to produce\n  an error when unknown options are met\n\t \n",
"line" : 379}
,
{
"name" : "getIgnoreUnknownOptions",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether unknown options are ignored or not. See\n g_option_context_set_ignore_unknown_options().\n Since 2.6\n Returns: TRUE if unknown options are ignored.\n\t \n",
"line" : 391}
,
{
"name" : "getHelp",
"kind" : "function",
"protection" : "public",
"type" : "string(int mainHelp, OptionGroup group)",
"comment" : "\n Returns a formatted, translated help text for the given context.\n To obtain the text produced by --help, call\n g_option_context_get_help (context, TRUE, NULL).\n To obtain the text produced by --help-all, call\n g_option_context_get_help (context, FALSE, NULL).\n To obtain the help text for an option group, call\n g_option_context_get_help (context, FALSE, group).\n Since 2.14\n Params:\n mainHelp = if TRUE, only include the main group\n group = the GOptionGroup to create help for, or NULL\n Returns: A newly allocated string containing the help text\n\t \n",
"line" : 411}
,
{
"name" : "addMainEntries",
"kind" : "function",
"protection" : "public",
"type" : "void(GOptionEntry* entries, string translationDomain)",
"comment" : "\n A convenience function which creates a main group if it doesn't\n exist, adds the entries to it and sets the translation domain.\n Since 2.6\n Params:\n entries = a NULL-terminated array of GOptionEntrys\n translationDomain = a translation domain to use for translating\n  the --help output for the options in entries\n  with gettext(), or NULL\n\t \n",
"line" : 427}
,
{
"name" : "addGroup",
"kind" : "function",
"protection" : "public",
"type" : "void(OptionGroup group)",
"comment" : "\n Adds a GOptionGroup to the context, so that parsing with context\n will recognize the options in the group. Note that the group will\n be freed together with the context when g_option_context_free() is\n called, so you must not free the group yourself after adding it\n to a context.\n Since 2.6\n Params:\n group = the group to add\n\t \n",
"line" : 443}
,
{
"name" : "setMainGroup",
"kind" : "function",
"protection" : "public",
"type" : "void(OptionGroup group)",
"comment" : "\n Sets a GOptionGroup as main group of the context.\n This has the same effect as calling g_option_context_add_group(),\n the only difference is that the options in the main group are\n treated differently when generating --help output.\n Since 2.6\n Params:\n group = the group to set as main group\n\t \n",
"line" : 458}
,
{
"name" : "getMainGroup",
"kind" : "function",
"protection" : "public",
"type" : "OptionGroup()",
"comment" : "\n Returns a pointer to the main group of context.\n Since 2.6\n Returns: the main group of context, or NULL if context doesn't have a main group. Note that group belongs to context and should not be modified or freed.\n\t \n",
"line" : 469}
]
}
]
}
,
{
"name" : "glib.OptionGroup",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/OptionGroup.d",
"members" : [
{
"name" : "OptionGroup",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GOption commandline parser is intended to be a simpler replacement\n for the popt library. It supports short and long commandline options,\n as shown in the following example:\n testtreemodel -r 1 --max-size 20 --rand --display=:1.0 -vb -- file1 file2\n The example demonstrates a number of features of the GOption\n commandline parser\n  Options can be single letters, prefixed by a single dash. Multiple\n  short options can be grouped behind a single dash.\n  Long options are prefixed by two consecutive dashes.\n  Options can have an extra argument, which can be a number, a string or\n  a filename. For long options, the extra argument can be appended with\n  an equals sign after the option name, which is useful if the extra\n  argument starts with a dash, which would otherwise cause it to be\n  interpreted as another option.\n  Non-option arguments are returned to the application as rest arguments.\n  An argument consisting solely of two dashes turns off further parsing,\n  any remaining arguments (even those starting with a dash) are returned\n  to the application as rest arguments.\n Another important feature of GOption is that it can automatically\n generate nicely formatted help output. Unless it is explicitly turned\n off with g_option_context_set_help_enabled(), GOption will recognize\n the --help, -?,\n --help-all and\n --help-groupname options\n (where groupname is the name of a\n GOptionGroup) and write a text similar to the one shown in the\n following example to stdout.\n $(DDOC_COMMENT example)\n GOption groups options in GOptionGroups, which makes it easy to\n incorporate options from multiple sources. The intended use for this is\n to let applications collect option groups from the libraries it uses,\n add them to their GOptionContext, and parse all options by a single call\n to g_option_context_parse(). See gtk_get_option_group() for an example.\n If an option is declared to be of type string or filename, GOption takes\n care of converting it to the right encoding; strings are returned in\n UTF-8, filenames are returned in the GLib filename encoding. Note that\n this only works if setlocale() has been called before\n g_option_context_parse().\n Here is a complete example of setting up GOption to parse the example\n commandline above and produce the example help output.\n $(DDOC_COMMENT example)\n \n",
"line" : 110,
"base" : "Object",
"members" : [
{
"name" : "gOptionGroup",
"kind" : "variable",
"protection" : "protected",
"type" : "GOptionGroup*",
"comment" : " the main Gtk struct \n",
"line" : 113}
,
{
"name" : "getOptionGroupStruct",
"kind" : "function",
"protection" : "public",
"type" : "GOptionGroup*()",
"line" : 116}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 123}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OptionGroup(GOptionGroup* gOptionGroup)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 131}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "OptionGroup(string name, string description, string helpDescription, void* userData, extern (C) void function(void* cbData) destroy)",
"comment" : "\n\t \n\n Creates a new GOptionGroup.\n Since 2.6\n Params:\n name = the name for the option group, this is used to provide\n  help for the options in this group with --help-name\n description = a description for this group to be shown in\n  --help. This string is translated using the translation\n  domain or translation function of the group\n helpDescription = a description for the --help-name option.\n  This string is translated using the translation domain or translation function\n  of the group\n userData = user data that will be passed to the pre- and post-parse hooks,\n  the error hook and to callbacks of G_OPTION_ARG_CALLBACK options, or NULL\n destroy = a function that will be called to free user_data, or NULL\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 161}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a GOptionGroup. Note that you must not\n free groups which have been added to a GOptionContext.\n Since 2.6\n\t \n",
"line" : 177}
,
{
"name" : "addEntries",
"kind" : "function",
"protection" : "public",
"type" : "void(GOptionEntry* entries)",
"comment" : "\n Adds the options specified in entries to group.\n Since 2.6\n Params:\n entries = a NULL-terminated array of GOptionEntrys\n\t \n",
"line" : 189}
,
{
"name" : "setParseHooks",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(GOptionContext*, GOptionGroup*, void*, GError**) preParseFunc, extern (C) int function(GOptionContext*, GOptionGroup*, void*, GError**) postParseFunc)",
"comment" : "\n Associates two functions with group which will be called\n from g_option_context_parse() before the first option is parsed\n and after the last option has been parsed, respectively.\n Note that the user data to be passed to pre_parse_func and\n post_parse_func can be specified when constructing the group\n with g_option_group_new().\n Since 2.6\n Params:\n preParseFunc = a function to call before parsing, or NULL\n postParseFunc = a function to call after parsing, or NULL\n\t \n",
"line" : 207}
,
{
"name" : "setErrorHook",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(GOptionContext*, GOptionGroup*, void*, GError**) errorFunc)",
"comment" : "\n Associates a function with group which will be called\n from g_option_context_parse() when an error occurs.\n Note that the user data to be passed to error_func can be\n specified when constructing the group with g_option_group_new().\n Since 2.6\n Params:\n errorFunc = a function to call when an error occurs\n\t \n",
"line" : 222}
,
{
"name" : "setTranslateFunc",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) char* function(char*, void*) func, void* data, extern (C) void function(void* cbData) destroyNotify)",
"comment" : "\n Sets the function which is used to translate user-visible\n strings, for --help output. Different\n groups can use different GTranslateFuncs. If func\n is NULL, strings are not translated.\n If you are using gettext(), you only need to set the translation\n domain, see g_option_group_set_translation_domain().\n Since 2.6\n Params:\n func = the GTranslateFunc, or NULL\n data = user data to pass to func, or NULL\n destroyNotify = a function which gets called to free data, or NULL\n\t \n",
"line" : 241}
,
{
"name" : "setTranslationDomain",
"kind" : "function",
"protection" : "public",
"type" : "void(string domain)",
"comment" : "\n A convenience function to use gettext() for translating\n user-visible strings.\n Since 2.6\n Params:\n domain = the domain to use\n\t \n",
"line" : 254}
]
}
]
}
,
{
"name" : "glib.Pattern",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Pattern.d",
"members" : [
{
"name" : "Pattern",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The g_pattern_match* functions match a string\n against a pattern containing '*' and '?' wildcards with similar\n semantics as the standard glob() function: '*' matches an arbitrary,\n possibly empty, string, '?' matches an arbitrary character.\n Note that in contrast to glob(), the '\/' character\n can be matched by the wildcards, there are no\n '[...]' character ranges and '*' and '?' can\n not be escaped to include them literally in a\n pattern.\n When multiple strings must be matched against the same pattern, it\n is better to compile the pattern to a GPatternSpec using\n g_pattern_spec_new() and use g_pattern_match_string() instead of\n g_pattern_match_simple(). This avoids the overhead of repeated\n pattern compilation.\n \n",
"line" : 85,
"base" : "Object",
"members" : [
{
"name" : "gPatternSpec",
"kind" : "variable",
"protection" : "protected",
"type" : "GPatternSpec*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getPatternStruct",
"kind" : "function",
"protection" : "public",
"type" : "GPatternSpec*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Pattern(GPatternSpec* gPatternSpec)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Pattern(string pattern)",
"comment" : "\n\t \n\n Compiles a pattern to a GPatternSpec.\n Params:\n pattern = a zero-terminated UTF-8 encoded string\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 125}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees the memory allocated for the GPatternSpec.\n\t \n",
"line" : 139}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(Pattern pspec2)",
"comment" : "\n Compares two compiled pattern specs and returns whether they will\n match the same set of strings.\n Params:\n pspec2 = another GPatternSpec\n Returns: Whether the compiled patterns are equal\n\t \n",
"line" : 152}
,
{
"name" : "match",
"kind" : "function",
"protection" : "public",
"type" : "int(uint stringLength, string string, string stringReversed)",
"comment" : "\n Matches a string against a compiled pattern. Passing the correct\n length of the string given is mandatory. The reversed string can be\n omitted by passing NULL, this is more efficient if the reversed\n version of the string to be matched is not at hand, as\n g_pattern_match() will only construct it if the compiled pattern\n requires reverse matches.\n Note that, if the user code will (possibly) match a string against a\n multitude of patterns containing wildcards, chances are high that\n some patterns will require a reversed string. In this case, it's\n more efficient to provide the reversed string to avoid multiple\n constructions thereof in the various calls to g_pattern_match().\n Note also that the reverse of a UTF-8 encoded string can in general\n not be obtained by g_strreverse(). This works\n only if the string doesn't contain any multibyte characters. GLib\n offers the g_utf8_strreverse() function to reverse UTF-8 encoded\n strings.\n Params:\n stringLength = the length of string (in bytes, i.e. strlen(),\n  not g_utf8_strlen())\n string = the UTF-8 encoded string to match\n stringReversed = the reverse of string or NULL\n Returns: TRUE if string matches pspec\n\t \n",
"line" : 182}
,
{
"name" : "matchString",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Matches a string against a compiled pattern. If the string is to be\n matched against more than one pattern, consider using\n g_pattern_match() instead while supplying the reversed string.\n Params:\n string = the UTF-8 encoded string to match\n Returns: TRUE if string matches pspec\n\t \n",
"line" : 196}
,
{
"name" : "matchSimple",
"kind" : "function",
"protection" : "public",
"type" : "int(string pattern, string string)",
"comment" : "\n Matches a string against a pattern given as a string. If this\n function is to be called in a loop, it's more efficient to compile\n the pattern once with g_pattern_spec_new() and call\n g_pattern_match_string() repeatedly.\n Params:\n pattern = the UTF-8 encoded pattern\n string = the UTF-8 encoded string to match\n Returns: TRUE if string matches pspec\n\t \n",
"line" : 212}
]
}
]
}
,
{
"name" : "glib.PtrArray",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/PtrArray.d",
"members" : [
{
"name" : "PtrArray",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Pointer Arrays are similar to Arrays but are used only for storing\n pointers.\n Note\n If you remove elements from the array, elements at the\n end of the array are moved into the space previously occupied by the\n removed element. This means that you should not rely on the index of\n particular elements remaining the same. You should also be careful\n when deleting elements while iterating over the array.\n To create a pointer array, use g_ptr_array_new().\n To add elements to a pointer array, use g_ptr_array_add().\n To remove elements from a pointer array, use g_ptr_array_remove(),\n g_ptr_array_remove_index() or g_ptr_array_remove_index_fast().\n To access an element of a pointer array, use g_ptr_array_index().\n To set the size of a pointer array, use g_ptr_array_set_size().\n To free a pointer array, use g_ptr_array_free().\n $(DDOC_COMMENT example)\n \n",
"line" : 84,
"base" : "Object",
"members" : [
{
"name" : "gPtrArray",
"kind" : "variable",
"protection" : "protected",
"type" : "GPtrArray*",
"comment" : " the main Gtk struct \n",
"line" : 87}
,
{
"name" : "getPtrArrayStruct",
"kind" : "function",
"protection" : "public",
"type" : "GPtrArray*()",
"line" : 90}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 97}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "PtrArray(GPtrArray* gPtrArray)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 105}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "PtrArray()",
"comment" : "\n\t \n\n Creates a new GPtrArray with a reference count of 1.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 122}
,
{
"name" : "sizedNew",
"kind" : "function",
"protection" : "public",
"type" : "PtrArray(uint reservedSize)",
"comment" : "\n Creates a new GPtrArray with reserved_size pointers preallocated\n and a reference count of 1. This avoids frequent reallocation, if\n you are going to add many pointers to the array. Note however that\n the size of the array is still 0.\n Params:\n reservedSize = number of pointers preallocated.\n Returns: the new GPtrArray.\n\t \n",
"line" : 142}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "PtrArray(extern (C) void function(void* cbData) elementFreeFunc)",
"comment" : "\n Creates a new GPtrArray with a reference count of 1 and use element_free_func\n for freeing each element when the array is destroyed either via\n g_ptr_array_unref(), when g_ptr_array_free() is called with free_segment\n set to TRUE or when removing elements.\n Since 2.22\n Params:\n elementFreeFunc = A function to free elements with destroy array or NULL.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 163}
,
{
"name" : "setFreeFunc",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void* cbData) elementFreeFunc)",
"comment" : "\n Sets a function for freeing each element when array is destroyed\n either via g_ptr_array_unref(), when g_ptr_array_free() is called\n with free_segment set to TRUE or when removing elements.\n Since 2.22\n Params:\n elementFreeFunc = A function to free elements with destroy array or NULL.\n\t \n",
"line" : 182}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "PtrArray()",
"comment" : "\n Atomically increments the reference count of array by one. This\n function is MT-safe and may be called from any thread.\n Since 2.22\n Returns: The passed in GPtrArray.\n\t \n",
"line" : 194}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Atomically decrements the reference count of array by one. If the\n reference count drops to 0, the effect is the same as calling\n g_ptr_array_free() with free_segment set to TRUE. This function\n is MT-safe and may be called from any thread.\n Since 2.22\n\t \n",
"line" : 212}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Adds a pointer to the end of the pointer array. The array will grow\n in size automatically if necessary.\n Params:\n data = the pointer to add.\n\t \n",
"line" : 224}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Removes the first occurrence of the given pointer from the pointer\n array. The following elements are moved down one place. If array\n has a non-NULL GDestroyNotify function it is called for the\n removed element.\n It returns TRUE if the pointer was removed, or FALSE if the\n pointer was not found.\n Params:\n data = the pointer to remove.\n Returns: TRUE if the pointer is removed. FALSE if the pointer is not found in the array.\n\t \n",
"line" : 241}
,
{
"name" : "removeIndex",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint index)",
"comment" : "\n Removes the pointer at the given index from the pointer array. The\n following elements are moved down one place. If array has a\n non-NULL GDestroyNotify function it is called for the removed\n element.\n Params:\n index = the index of the pointer to remove.\n Returns: the pointer which was removed.\n\t \n",
"line" : 256}
,
{
"name" : "removeFast",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Removes the first occurrence of the given pointer from the pointer\n array. The last element in the array is used to fill in the space,\n so this function does not preserve the order of the array. But it is\n faster than g_ptr_array_remove(). If array has a non-NULL\n GDestroyNotify function it is called for the removed element.\n It returns TRUE if the pointer was removed, or FALSE if the\n pointer was not found.\n Params:\n data = the pointer to remove.\n Returns: TRUE if the pointer was found in the array.\n\t \n",
"line" : 274}
,
{
"name" : "removeIndexFast",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint index)",
"comment" : "\n Removes the pointer at the given index from the pointer array. The\n last element in the array is used to fill in the space, so this\n function does not preserve the order of the array. But it is faster\n than g_ptr_array_remove_index(). If array has a non-NULL\n GDestroyNotify function it is called for the removed element.\n Params:\n index = the index of the pointer to remove.\n Returns: the pointer which was removed.\n\t \n",
"line" : 290}
,
{
"name" : "removeRange",
"kind" : "function",
"protection" : "public",
"type" : "void(uint index, uint length)",
"comment" : "\n Removes the given number of pointers starting at the given index\n from a GPtrArray. The following elements are moved to close the\n gap. If array has a non-NULL GDestroyNotify function it is called\n for the removed elements.\n Since 2.4\n Params:\n index = the index of the first pointer to remove.\n length = the number of pointers to remove.\n\t \n",
"line" : 306}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*) compareFunc)",
"comment" : "\n Sorts the array, using compare_func which should be a qsort()-style\n comparison function (returns less than zero for first arg is less\n than second arg, zero for equal, greater than zero if irst arg is\n greater than second arg).\n If two array elements compare equal, their order in the sorted array\n is undefined.\n Note\n The comparison function for g_ptr_array_sort() doesn't\n take the pointers from the array as arguments, it takes pointers to\n the pointers in the array.\n Params:\n compareFunc = comparison function.\n\t \n",
"line" : 326}
,
{
"name" : "sortWithData",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n Like g_ptr_array_sort(), but the comparison function has an extra\n user data argument.\n Note\n The comparison function for g_ptr_array_sort_with_data()\n doesn't take the pointers from the array as arguments, it takes\n pointers to the pointers in the array.\n Params:\n compareFunc = comparison function.\n userData = data to pass to compare_func.\n\t \n",
"line" : 343}
,
{
"name" : "setSize",
"kind" : "function",
"protection" : "public",
"type" : "void(int length)",
"comment" : "\n Sets the size of the array. When making the array larger,\n newly-added elements will be set to NULL. When making it smaller,\n if array has a non-NULL GDestroyNotify function then it will be\n called for the removed elements.\n Params:\n length = the new length of the pointer array.\n\t \n",
"line" : 357}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void**(int freeSeg)",
"comment" : "\n Frees the memory allocated for the GPtrArray. If free_seg is TRUE\n it frees the memory block holding the elements as well. Pass FALSE\n if you want to free the GPtrArray wrapper but preserve the\n underlying array for use elsewhere. If the reference count of array\n is greater than one, the GPtrArray wrapper is preserved but the\n size of array will be set to zero.\n Note\n If array contents point to dynamically-allocated\n memory, they should be freed separately if free_seg is TRUE and no\n GDestroyNotify function has been set for array.\n Params:\n freeSeg = if TRUE the actual pointer array is freed as well.\n Returns: the pointer array if free_seg is FALSE, otherwise NULL. The pointer array should be freed using g_free().\n\t \n",
"line" : 378}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*) func, void* userData)",
"comment" : "\n Calls a function for each element of a GPtrArray.\n Since 2.4\n Params:\n func = the function to call for each array element\n userData = user data to pass to the function\n\t \n",
"line" : 391}
]
}
]
}
,
{
"name" : "glib.Quark",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Quark.d",
"members" : [
{
"name" : "Quark",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Quarks are associations between strings and integer identifiers.\n Given either the string or the GQuark identifier it is possible to\n retrieve the other.\n Quarks are used for both Datasets and Keyed Data Lists.\n To create a new quark from a string, use g_quark_from_string() or\n g_quark_from_static_string().\n To find the string corresponding to a given GQuark, use\n g_quark_to_string().\n To find the GQuark corresponding to a given string, use\n g_quark_try_string().\n Another use for the string pool maintained for the quark functions\n is string interning, using g_intern_string() or\n g_intern_static_string(). An interned string is a canonical\n representation for a string. One important advantage of interned\n strings is that they can be compared for equality by a simple\n pointer comparision, rather than using strcmp().\n \n",
"line" : 85,
"base" : "Object",
"members" : [
{
"name" : "gQuark",
"kind" : "variable",
"protection" : "protected",
"type" : "uint*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getQuarkStruct",
"kind" : "function",
"protection" : "public",
"type" : "uint*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Quark(uint* gQuark)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "fromString",
"kind" : "function",
"protection" : "public",
"type" : "uint(string string)",
"comment" : "\n\t \n\n Gets the GQuark identifying the given string. If the string does\n not currently have an associated GQuark, a new GQuark is created,\n using a copy of the string.\n Params:\n string = a string.\n Returns: the GQuark identifying the string, or 0 if string is NULL.\n\t \n",
"line" : 127}
,
{
"name" : "fromStaticString",
"kind" : "function",
"protection" : "public",
"type" : "uint(string string)",
"comment" : "\n Gets the GQuark identifying the given (static) string. If the\n string does not currently have an associated GQuark, a new GQuark\n is created, linked to the given string.\n Note that this function is identical to g_quark_from_string() except\n that if a new GQuark is created the string itself is used rather\n than a copy. This saves memory, but can only be used if the string\n will always exist. It can be used with\n statically allocated strings in the main program, but not with\n statically allocated memory in dynamically loaded modules, if you\n expect to ever unload the module again (e.g. do not use this\n function in GTK+ theme engines).\n Params:\n string = a string.\n Returns: the GQuark identifying the string, or 0 if string is NULL.\n\t \n",
"line" : 149}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(uint quark)",
"comment" : "\n Gets the string associated with the given GQuark.\n Params:\n quark = a GQuark.\n Returns: the string associated with the GQuark.\n\t \n",
"line" : 161}
,
{
"name" : "tryString",
"kind" : "function",
"protection" : "public",
"type" : "uint(string string)",
"comment" : "\n Gets the GQuark associated with the given string, or 0 if string is\n NULL or it has no associated GQuark.\n If you want the GQuark to be created if it doesn't already exist,\n use g_quark_from_string() or g_quark_from_static_string().\n Params:\n string = a string.\n Returns: the GQuark associated with the string, or 0 if string is NULL or there is no GQuark associated with it.\n\t \n",
"line" : 176}
,
{
"name" : "gInternString",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Returns a canonical representation for string. Interned strings can\n be compared for equality by comparing the pointers, instead of using strcmp().\n Since 2.10\n Params:\n string = a string\n Returns: a canonical representation for the string\n\t \n",
"line" : 190}
,
{
"name" : "gInternStaticString",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Returns a canonical representation for string. Interned strings can\n be compared for equality by comparing the pointers, instead of using strcmp().\n g_intern_static_string() does not copy the string, therefore string must\n not be freed or modified.\n Since 2.10\n Params:\n string = a static string\n Returns: a canonical representation for the string\n\t \n",
"line" : 206}
]
}
]
}
,
{
"name" : "glib.QueueG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/QueueG.d",
"members" : [
{
"name" : "QueueG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GQueue structure and its associated functions provide a standard\n queue data structure. Internally, GQueue uses the same data structure as\n GList to store elements.\n The data contained in each element can be either integer values, by using one\n of the\n Type Conversion Macros,\n or simply pointers to any type of data.\n To create a new GQueue, use g_queue_new().\n To initialize a statically-allocated GQueue, use G_QUEUE_INIT or\n g_queue_init().\n To add elements, use g_queue_push_head(), g_queue_push_head_link(),\n g_queue_push_tail() and g_queue_push_tail_link().\n To remove elements, use g_queue_pop_head() and g_queue_pop_tail().\n To free the entire queue, use g_queue_free().\n \n",
"line" : 85,
"base" : "Object",
"members" : [
{
"name" : "gQueue",
"kind" : "variable",
"protection" : "protected",
"type" : "GQueue*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getQueueGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GQueue*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "QueueG(GQueue* gQueue)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "QueueG()",
"comment" : "\n\t \n\n Creates a new GQueue.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 123}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees the memory allocated for the GQueue. Only call this function if\n queue was created with g_queue_new(). If queue elements contain\n dynamically-allocated memory, they should be freed first.\n\t \n",
"line" : 139}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n A statically-allocated GQueue must be initialized with this function\n before it can be used. Alternatively you can initialize it with\n G_QUEUE_INIT. It is not necessary to initialize queues created with\n g_queue_new().\n Since 2.14\n\t \n",
"line" : 152}
,
{
"name" : "clear",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes all the elements in queue. If queue elements contain\n dynamically-allocated memory, they should be freed first.\n Since 2.14\n\t \n",
"line" : 163}
,
{
"name" : "isEmpty",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns TRUE if the queue is empty.\n Returns: TRUE if the queue is empty.\n\t \n",
"line" : 173}
,
{
"name" : "getLength",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the number of items in queue.\n Since 2.4\n Returns: The number of items in queue.\n\t \n",
"line" : 184}
,
{
"name" : "reverse",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Reverses the order of the items in queue.\n Since 2.4\n\t \n",
"line" : 194}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "QueueG()",
"comment" : "\n Copies a queue. Note that is a shallow copy. If the elements in the\n queue consist of pointers to data, the pointers are copied, but the\n actual data is not.\n Since 2.4\n Returns: A copy of queue\n\t \n",
"line" : 207}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*) func, void* userData)",
"comment" : "\n Calls func for each element in the queue passing user_data to the\n function.\n Since 2.4\n Params:\n func = the function to call for each element's data\n userData = user data to pass to func\n\t \n",
"line" : 226}
,
{
"name" : "find",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data)",
"comment" : "\n Finds the first link in queue which contains data.\n Since 2.4\n Params:\n data = data to find\n Returns: The first link in queue which contains data.\n\t \n",
"line" : 239}
,
{
"name" : "findCustom",
"kind" : "function",
"protection" : "public",
"type" : "ListG(void* data, extern (C) int function(void*, void*) func)",
"comment" : "\n Finds an element in a GQueue, using a supplied function to find the\n desired element. It iterates over the queue, calling the given function\n which should return 0 when the desired element is found. The function\n takes two gconstpointer arguments, the GQueue element's data as the\n first argument and the given user data as the second argument.\n Since 2.4\n Params:\n data = user data passed to func\n func = a GCompareFunc to call for each element. It should return 0\n when the desired element is found\n Returns: The found link, or NULL if it wasn't found\n\t \n",
"line" : 263}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n Sorts queue using compare_func.\n Since 2.4\n Params:\n compareFunc = the GCompareDataFunc used to sort queue. This function\n  is passed two elements of the queue and should return 0 if they are\n  equal, a negative value if the first comes before the second, and\n  a positive value if the second comes before the first.\n userData = user data passed to compare_func\n\t \n",
"line" : 284}
,
{
"name" : "pushHead",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Adds a new element at the head of the queue.\n Params:\n data = the data for the new element.\n\t \n",
"line" : 295}
,
{
"name" : "pushTail",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Adds a new element at the tail of the queue.\n Params:\n data = the data for the new element.\n\t \n",
"line" : 306}
,
{
"name" : "pushNth",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data, int n)",
"comment" : "\n Inserts a new element into queue at the given position\n Since 2.4\n Params:\n data = the data for the new element\n n = the position to insert the new element. If n is negative or\n  larger than the number of elements in the queue, the element is\n  added to the end of the queue.\n\t \n",
"line" : 321}
,
{
"name" : "popHead",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Removes the first element of the queue.\n Returns: the data of the first element in the queue, or NULL if the queue is empty.\n\t \n",
"line" : 331}
,
{
"name" : "popTail",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Removes the last element of the queue.\n Returns: the data of the last element in the queue, or NULL if the queue is empty.\n\t \n",
"line" : 341}
,
{
"name" : "popNth",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint n)",
"comment" : "\n Removes the n'th element of queue.\n Since 2.4\n Params:\n n = the position of the element.\n Returns: the element's data, or NULL if n is off the end of queue.\n\t \n",
"line" : 354}
,
{
"name" : "peekHead",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Returns the first element of the queue.\n Returns: the data of the first element in the queue, or NULL if the queue is empty.\n\t \n",
"line" : 364}
,
{
"name" : "peekTail",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Returns the last element of the queue.\n Returns: the data of the last element in the queue, or NULL if the queue is empty.\n\t \n",
"line" : 374}
,
{
"name" : "peekNth",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint n)",
"comment" : "\n Returns the n'th element of queue.\n Since 2.4\n Params:\n n = the position of the element.\n Returns: The data for the n'th element of queue, or NULL if n is off the end of queue.\n\t \n",
"line" : 387}
,
{
"name" : "index",
"kind" : "function",
"protection" : "public",
"type" : "int(void* data)",
"comment" : "\n Returns the position of the first element in queue which contains data.\n Since 2.4\n Params:\n data = the data to find.\n Returns: The position of the first element in queue which contains data, or -1 if no element in queue contains data.\n\t \n",
"line" : 400}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Removes the first element in queue that contains data.\n Since 2.4\n Params:\n data = data to remove.\n\t \n",
"line" : 412}
,
{
"name" : "removeAll",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Remove all elemeents in queue which contains data.\n Since 2.4\n Params:\n data = data to remove\n\t \n",
"line" : 424}
,
{
"name" : "insertBefore",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG sibling, void* data)",
"comment" : "\n Inserts data into queue before sibling.\n sibling must be part of queue.\n Since 2.4\n Params:\n sibling = a GList link that must be part of queue\n data = the data to insert\n\t \n",
"line" : 438}
,
{
"name" : "insertAfter",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG sibling, void* data)",
"comment" : "\n Inserts data into queue after sibling\n sibling must be part of queue\n Since 2.4\n Params:\n sibling = a GList link that must be part of queue\n data = the data to insert\n\t \n",
"line" : 452}
,
{
"name" : "insertSorted",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data, extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Inserts data into queue using func to determine the new position.\n Since 2.4\n Params:\n data = the data to insert\n func = the GCompareDataFunc used to compare elements in the queue. It is\n  called with two elements of the queue and user_data. It should\n  return 0 if the elements are equal, a negative value if the first\n  element comes before the second, and a positive value if the second\n  element comes before the first.\n userData = user data passed to func.\n\t \n",
"line" : 470}
,
{
"name" : "pushHeadLink",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG link)",
"comment" : "\n Adds a new element at the head of the queue.\n Params:\n link = a single GList element, not a list with\n  more than one element.\n\t \n",
"line" : 482}
,
{
"name" : "pushTailLink",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG link)",
"comment" : "\n Adds a new element at the tail of the queue.\n Params:\n link = a single GList element, not a list with\n  more than one element.\n\t \n",
"line" : 494}
,
{
"name" : "pushNthLink",
"kind" : "function",
"protection" : "public",
"type" : "void(int n, ListG link)",
"comment" : "\n Inserts link into queue at the given position.\n Since 2.4\n Params:\n n = the position to insert the link. If this is negative or larger than\n  the number of elements in queue, the link is added to the end of\n  queue.\n link = the link to add to queue\n\t \n",
"line" : 509}
,
{
"name" : "popHeadLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Removes the first element of the queue.\n Returns: the GList element at the head of the queue, or NULL if the queue is empty.\n\t \n",
"line" : 519}
,
{
"name" : "popTailLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Removes the last element of the queue.\n Returns: the GList element at the tail of the queue, or NULL if the queue is empty.\n\t \n",
"line" : 534}
,
{
"name" : "popNthLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG(uint n)",
"comment" : "\n Removes and returns the link at the given position.\n Since 2.4\n Params:\n n = the link's position\n Returns: The n'th link, or NULL if n is off the end of queue.\n\t \n",
"line" : 552}
,
{
"name" : "peekHeadLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Returns the first link in queue\n Since 2.4\n Returns: the first link in queue, or NULL if queue is empty\n\t \n",
"line" : 568}
,
{
"name" : "peekTailLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG()",
"comment" : "\n Returns the last link queue.\n Since 2.4\n Returns: the last link in queue, or NULL if queue is empty\n\t \n",
"line" : 584}
,
{
"name" : "peekNthLink",
"kind" : "function",
"protection" : "public",
"type" : "ListG(uint n)",
"comment" : "\n Returns the link at the given position\n Since 2.4\n Params:\n n = the position of the link\n Returns: The link at the n'th position, or NULL if n is off the end of the list\n\t \n",
"line" : 602}
,
{
"name" : "linkIndex",
"kind" : "function",
"protection" : "public",
"type" : "int(ListG link)",
"comment" : "\n Returns the position of link_ in queue.\n Since 2.4\n Params:\n link = A GList link\n Returns: The position of link_, or -1 if the link is not part of queue\n\t \n",
"line" : 620}
,
{
"name" : "unlink",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG link)",
"comment" : "\n Unlinks link_ so that it will no longer be part of queue. The link is\n not freed.\n link_ must be part of queue,\n Since 2.4\n Params:\n link = a GList link that must be part of queue\n\t \n",
"line" : 634}
,
{
"name" : "deleteLink",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG link)",
"comment" : "\n Removes link_ from queue and frees it.\n link_ must be part of queue.\n Since 2.4\n Params:\n link = a GList link that must be part of queue\n\t \n",
"line" : 647}
]
}
]
}
,
{
"name" : "glib.RandG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/RandG.d",
"members" : [
{
"name" : "RandG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The following functions allow you to use a portable, fast and good\n pseudo-random number generator (PRNG). It uses the Mersenne Twister\n PRNG, which was originally developed by Makoto Matsumoto and Takuji\n Nishimura. Further information can be found at\n www.math.keio.ac.jp\/~matumoto\/emt.html.\n If you just need a random number, you simply call the\n g_random_* functions, which will create a\n globally used GRand and use the according\n g_rand_* functions internally. Whenever you\n need a stream of reproducible random numbers, you better create a\n GRand yourself and use the g_rand_* functions\n directly, which will also be slightly faster. Initializing a GRand\n with a certain seed will produce exactly the same series of random\n numbers on all platforms. This can thus be used as a seed for e.g.\n games.\n The g_rand*_range functions will return high\n quality equally distributed random numbers, whereas for example the\n (g_random_int()%max) approach often\n doesn't yield equally distributed numbers.\n GLib changed the seeding algorithm for the pseudo-random number\n generator Mersenne Twister, as used by\n GRand and GRandom.\n This was necessary, because some seeds would yield very bad\n pseudo-random streams. Also the pseudo-random integers generated by\n g_rand*_int_range() will have a slightly better\n equal distribution with the new version of GLib.\n The original seeding and generation algorithms, as found in GLib\n 2.0.x, can be used instead of the new ones by setting the\n environment variable G_RANDOM_VERSION to the value of\n '2.0'. Use the GLib-2.0 algorithms only if you have sequences of\n numbers generated with Glib-2.0 that you need to reproduce exactly.\n \n",
"line" : 104,
"base" : "Object",
"members" : [
{
"name" : "gRand",
"kind" : "variable",
"protection" : "protected",
"type" : "GRand*",
"comment" : " the main Gtk struct \n",
"line" : 107}
,
{
"name" : "getRandGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GRand*()",
"line" : 110}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 117}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "RandG(GRand* gRand)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 125}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "RandG(uint seed)",
"comment" : "\n\t \n\n Creates a new random number generator initialized with seed.\n Params:\n seed = a value to initialize the random number generator.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 144}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "RandG(uint[] seed)",
"comment" : "\n Creates a new random number generator initialized with seed.\n Since 2.4\n Params:\n seed = an array of seeds to initialize the random number generator.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 162}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "RandG()",
"comment" : "\n Creates a new random number generator initialized with a seed taken\n either from \/dev\/urandom (if existing) or from\n the current time (as a fallback).\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 179}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "RandG()",
"comment" : "\n Copies a GRand into a new one with the same exact state as before.\n This way you can take a snapshot of the random number generator for\n replaying later.\n Since 2.4\n Returns: the new GRand.\n\t \n",
"line" : 197}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees the memory allocated for the GRand.\n\t \n",
"line" : 211}
,
{
"name" : "setSeed",
"kind" : "function",
"protection" : "public",
"type" : "void(uint seed)",
"comment" : "\n Sets the seed for the random number generator GRand to seed.\n Params:\n seed = a value to reinitialize the random number generator.\n\t \n",
"line" : 222}
,
{
"name" : "setSeedArray",
"kind" : "function",
"protection" : "public",
"type" : "void(uint[] seed)",
"comment" : "\n Initializes the random number generator by an array of\n longs. Array can be of arbitrary size, though only the\n first 624 values are taken. This function is useful\n if you have many low entropy seeds, or if you require more then\n 32bits of actual entropy for your application.\n Since 2.4\n Params:\n seed = array to initialize with\n\t \n",
"line" : 238}
,
{
"name" : "randInt",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the next random guint32 from rand_ equally distributed over\n the range [0..2^32-1].\n Params:\n rand = a GRand.\n Returns: A random number.\n\t \n",
"line" : 251}
,
{
"name" : "randIntRange",
"kind" : "function",
"protection" : "public",
"type" : "int(int begin, int end)",
"comment" : "\n Returns the next random gint32 from rand_ equally distributed over\n the range [begin..end-1].\n Params:\n rand = a GRand.\n begin = lower closed bound of the interval.\n end = upper open bound of the interval.\n Returns: A random number.\n\t \n",
"line" : 266}
,
{
"name" : "randDouble",
"kind" : "function",
"protection" : "public",
"type" : "double()",
"comment" : "\n Returns the next random gdouble from rand_ equally distributed over\n the range [0..1).\n Params:\n rand = a GRand.\n Returns: A random number.\n\t \n",
"line" : 279}
,
{
"name" : "randDoubleRange",
"kind" : "function",
"protection" : "public",
"type" : "double(double begin, double end)",
"comment" : "\n Returns the next random gdouble from rand_ equally distributed over\n the range [begin..end).\n Params:\n rand = a GRand.\n begin = lower closed bound of the interval.\n end = upper open bound of the interval.\n Returns: A random number.\n\t \n",
"line" : 294}
,
{
"name" : "randomSetSeed",
"kind" : "function",
"protection" : "public",
"type" : "void(uint seed)",
"comment" : "\n Sets the seed for the global random number generator, which is used\n by the g_random_* functions, to seed.\n Params:\n seed = a value to reinitialize the global random number generator.\n\t \n",
"line" : 306}
,
{
"name" : "randomInt",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Return a random guint32 equally distributed over the range\n [0..2^32-1].\n Returns: A random number.\n\t \n",
"line" : 317}
,
{
"name" : "randomIntRange",
"kind" : "function",
"protection" : "public",
"type" : "int(int begin, int end)",
"comment" : "\n Returns a random gint32 equally distributed over the range\n [begin..end-1].\n Params:\n begin = lower closed bound of the interval.\n end = upper open bound of the interval.\n Returns: A random number.\n\t \n",
"line" : 331}
,
{
"name" : "randomDouble",
"kind" : "function",
"protection" : "public",
"type" : "double()",
"comment" : "\n Returns a random gdouble equally distributed over the range [0..1).\n Returns: A random number.\n\t \n",
"line" : 341}
,
{
"name" : "randomDoubleRange",
"kind" : "function",
"protection" : "public",
"type" : "double(double begin, double end)",
"comment" : "\n Returns a random gdouble equally distributed over the range [begin..end).\n Params:\n begin = lower closed bound of the interval.\n end = upper open bound of the interval.\n Returns: A random number.\n\t \n",
"line" : 354}
]
}
]
}
,
{
"name" : "glib.Regex",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Regex.d",
"members" : [
{
"name" : "Regex",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The g_regex_*() functions implement regular\n expression pattern matching using syntax and semantics similar to\n Perl regular expression.\n Some functions accept a start_position argument, setting it differs\n from just passing over a shortened string and setting G_REGEX_MATCH_NOTBOL\n in the case of a pattern that begins with any kind of lookbehind assertion.\n For example, consider the pattern \"\\Biss\\B\" which finds occurrences of \"iss\"\n in the middle of words. (\"\\B\" matches only if the current position in the\n subject is not a word boundary.) When applied to the string \"Mississipi\"\n from the fourth byte, namely \"issipi\", it does not match, because \"\\B\" is\n always false at the start of the subject, which is deemed to be a word\n boundary. However, if the entire string is passed , but with\n start_position set to 4, it finds the second occurrence of \"iss\" because\n it is able to look behind the starting point to discover that it is\n preceded by a letter.\n Note that, unless you set the G_REGEX_RAW flag, all the strings passed\n to these functions must be encoded in UTF-8. The lengths and the positions\n inside the strings are in bytes and not in characters, so, for instance,\n \"\\xc3\\xa0\" (i.e. \"  \") is two bytes long but it is treated as a\n single character. If you set G_REGEX_RAW the strings can be non-valid\n UTF-8 strings and a byte is treated as a character, so \"\\xc3\\xa0\" is two\n bytes and two characters long.\n When matching a pattern, \"\\n\" matches only against a \"\\n\" character in\n the string, and \"\\r\" matches only a \"\\r\" character. To match any newline\n sequence use \"\\R\". This particular group matches either the two-character\n sequence CR + LF (\"\\r\\n\"), or one of the single characters LF (linefeed,\n U+000A, \"\\n\"), VT vertical tab, U+000B, \"\\v\"), FF (formfeed, U+000C, \"\\f\"),\n CR (carriage return, U+000D, \"\\r\"), NEL (next line, U+0085), LS (line\n separator, U+2028), or PS (paragraph separator, U+2029).\n The behaviour of the dot, circumflex, and dollar metacharacters are\n affected by newline characters, the default is to recognize any newline\n character (the same characters recognized by \"\\R\"). This can be changed\n with G_REGEX_NEWLINE_CR, G_REGEX_NEWLINE_LF and G_REGEX_NEWLINE_CRLF\n compile options, and with G_REGEX_MATCH_NEWLINE_ANY,\n G_REGEX_MATCH_NEWLINE_CR, G_REGEX_MATCH_NEWLINE_LF and\n G_REGEX_MATCH_NEWLINE_CRLF match options. These settings are also\n relevant when compiling a pattern if G_REGEX_EXTENDED is set, and an\n unescaped \"#\" outside a character class is encountered. This indicates\n a comment that lasts until after the next newline.\n Creating and manipulating the same GRegex structure from different\n threads is not a problem as GRegex does not modify its internal\n state between creation and destruction, on the other hand GMatchInfo\n is not threadsafe.\n The regular expressions low-level functionalities are obtained through\n the excellent PCRE library\n written by Philip Hazel.\n \n",
"line" : 124,
"base" : "Object",
"members" : [
{
"name" : "gRegex",
"kind" : "variable",
"protection" : "protected",
"type" : "GRegex*",
"comment" : " the main Gtk struct \n",
"line" : 127}
,
{
"name" : "getRegexStruct",
"kind" : "function",
"protection" : "public",
"type" : "GRegex*()",
"line" : 130}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 137}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Regex(GRegex* gRegex)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 145}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Regex(string pattern, GRegexCompileFlags compileOptions, GRegexMatchFlags matchOptions)",
"comment" : "\n\t \n\n Compiles the regular expression to an internal form, and does\n the initial setup of the GRegex structure.\n Since 2.14\n Params:\n pattern = the regular expression\n compileOptions = compile options for the regular expression, or 0\n matchOptions = match options for the regular expression, or 0\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 169}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "Regex()",
"comment" : "\n Increases reference count of regex by 1.\n Since 2.14\n Returns: regex\n\t \n",
"line" : 193}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decreases reference count of regex by 1. When reference count drops\n to zero, it frees all the memory associated with the regex structure.\n Since 2.14\n\t \n",
"line" : 209}
,
{
"name" : "getPattern",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the pattern string associated with regex, i.e. a copy of\n the string passed to g_regex_new().\n Since 2.14\n Returns: the pattern of regex\n\t \n",
"line" : 221}
,
{
"name" : "getMaxBackref",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the number of the highest back reference\n in the pattern, or 0 if the pattern does not contain\n back references.\n Since 2.14\n Returns: the number of the highest back reference\n\t \n",
"line" : 234}
,
{
"name" : "getCaptureCount",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the number of capturing subpatterns in the pattern.\n Since 2.14\n Returns: the number of capturing subpatterns\n\t \n",
"line" : 245}
,
{
"name" : "getStringNumber",
"kind" : "function",
"protection" : "public",
"type" : "int(string name)",
"comment" : "\n Retrieves the number of the subexpression named name.\n Since 2.14\n Params:\n name = name of the subexpression\n Returns: The number of the subexpression or -1 if name does not exists\n\t \n",
"line" : 258}
,
{
"name" : "getCompileFlags",
"kind" : "function",
"protection" : "public",
"type" : "GRegexCompileFlags()",
"comment" : "\n Returns the compile options that regex was created with.\n Since 2.26\n Returns: flags from GRegexCompileFlags\n\t \n",
"line" : 269}
,
{
"name" : "getMatchFlags",
"kind" : "function",
"protection" : "public",
"type" : "GRegexMatchFlags()",
"comment" : "\n Returns the match options that regex was created with.\n Since 2.26\n Returns: flags from GRegexMatchFlags\n\t \n",
"line" : 280}
,
{
"name" : "escapeString",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, int length)",
"comment" : "\n Escapes the special characters used for regular expressions\n in string, for instance \"a.b*c\" becomes \"a\\.b\\*c\". This\n function is useful to dynamically generate regular expressions.\n string can contain nul characters that are replaced with \"\\0\",\n in this case remember to specify the correct length of string\n in length.\n Since 2.14\n Params:\n string = the string to escape. [array length=length]\n length = the length of string, or -1 if string is nul-terminated\n Returns: a newly-allocated escaped string\n\t \n",
"line" : 299}
,
{
"name" : "matchSimple",
"kind" : "function",
"protection" : "public",
"type" : "int(string pattern, string string, GRegexCompileFlags compileOptions, GRegexMatchFlags matchOptions)",
"comment" : "\n Scans for a match in string for pattern.\n This function is equivalent to g_regex_match() but it does not\n require to compile the pattern with g_regex_new(), avoiding some\n lines of code when you need just to do a match without extracting\n substrings, capture counts, and so on.\n If this function is to be called on the same pattern more than\n once, it's more efficient to compile the pattern once with\n g_regex_new() and then use g_regex_match().\n Since 2.14\n Params:\n pattern = the regular expression\n string = the string to scan for matches\n compileOptions = compile options for the regular expression, or 0\n matchOptions = match options, or 0\n Returns: TRUE if the string matched, FALSE otherwise\n\t \n",
"line" : 322}
,
{
"name" : "match",
"kind" : "function",
"protection" : "public",
"type" : "int(string string, GRegexMatchFlags matchOptions, out MatchInfo matchInfo)",
"comment" : "\n Scans for a match in string for the pattern in regex.\n The match_options are combined with the match options specified\n when the regex structure was created, letting you have more\n flexibility in reusing GRegex structures.\n A GMatchInfo structure, used to get information on the match,\n is stored in match_info if not NULL. Note that if match_info\n is not NULL then it is created even if the function returns FALSE,\n i.e. you must free it regardless if regular expression actually matched.\n To retrieve all the non-overlapping matches of the pattern in\n string you can use g_match_info_next().\n $(DDOC_COMMENT example)\n string is not copied and is used in GMatchInfo internally. If\n you use any GMatchInfo method (except g_match_info_free()) after\n freeing or modifying string then the behaviour is undefined.\n Since 2.14\n Params:\n string = the string to scan for matches\n matchOptions = match options\n matchInfo = pointer to location where to store\n  the GMatchInfo, or NULL if you do not need it. [out][allow-none]\n Returns: TRUE is the string matched, FALSE otherwise\n\t \n",
"line" : 351}
,
{
"name" : "matchFull",
"kind" : "function",
"protection" : "public",
"type" : "int(string string, long stringLen, int startPosition, GRegexMatchFlags matchOptions, out MatchInfo matchInfo)",
"comment" : "\n Scans for a match in string for the pattern in regex.\n The match_options are combined with the match options specified\n when the regex structure was created, letting you have more\n flexibility in reusing GRegex structures.\n Setting start_position differs from just passing over a shortened\n string and setting G_REGEX_MATCH_NOTBOL in the case of a pattern\n that begins with any kind of lookbehind assertion, such as \"\\b\".\n A GMatchInfo structure, used to get information on the match, is\n stored in match_info if not NULL. Note that if match_info is\n not NULL then it is created even if the function returns FALSE,\n i.e. you must free it regardless if regular expression actually\n matched.\n string is not copied and is used in GMatchInfo internally. If\n you use any GMatchInfo method (except g_match_info_free()) after\n freeing or modifying string then the behaviour is undefined.\n To retrieve all the non-overlapping matches of the pattern in\n string you can use g_match_info_next().\n $(DDOC_COMMENT example)\n Since 2.14\n Params:\n string = the string to scan for matches. [array length=string_len]\n stringLen = the length of string, or -1 if string is nul-terminated\n startPosition = starting index of the string to match\n matchOptions = match options\n matchInfo = pointer to location where to store\n  the GMatchInfo, or NULL if you do not need it. [out][allow-none]\n Returns: TRUE is the string matched, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 392}
,
{
"name" : "matchAll",
"kind" : "function",
"protection" : "public",
"type" : "int(string string, GRegexMatchFlags matchOptions, out MatchInfo matchInfo)",
"comment" : "\n Using the standard algorithm for regular expression matching only\n the longest match in the string is retrieved. This function uses\n a different algorithm so it can retrieve all the possible matches.\n For more documentation see g_regex_match_all_full().\n A GMatchInfo structure, used to get information on the match, is\n stored in match_info if not NULL. Note that if match_info is\n not NULL then it is created even if the function returns FALSE,\n i.e. you must free it regardless if regular expression actually\n matched.\n string is not copied and is used in GMatchInfo internally. If\n you use any GMatchInfo method (except g_match_info_free()) after\n freeing or modifying string then the behaviour is undefined.\n Since 2.14\n Params:\n string = the string to scan for matches\n matchOptions = match options\n matchInfo = pointer to location where to store\n  the GMatchInfo, or NULL if you do not need it. [out][allow-none]\n Returns: TRUE is the string matched, FALSE otherwise\n\t \n",
"line" : 430}
,
{
"name" : "matchAllFull",
"kind" : "function",
"protection" : "public",
"type" : "int(string string, long stringLen, int startPosition, GRegexMatchFlags matchOptions, out MatchInfo matchInfo)",
"comment" : "\n Using the standard algorithm for regular expression matching only\n the longest match in the string is retrieved, it is not possibile\n to obtain all the available matches. For instance matching\n \"<a> <b> <c>\" against the pattern \"<.*>\"\n you get \"<a> <b> <c>\".\n This function uses a different algorithm (called DFA, i.e. deterministic\n finite automaton), so it can retrieve all the possible matches, all\n starting at the same point in the string. For instance matching\n \"<a> <b> <c>\" against the pattern \"<.*>\"\n you would obtain three matches: \"<a> <b> <c>\",\n \"<a> <b>\" and \"<a>\".\n The number of matched strings is retrieved using\n g_match_info_get_match_count(). To obtain the matched strings and\n their position you can use, respectively, g_match_info_fetch() and\n g_match_info_fetch_pos(). Note that the strings are returned in\n reverse order of length; that is, the longest matching string is\n given first.\n Note that the DFA algorithm is slower than the standard one and it\n is not able to capture substrings, so backreferences do not work.\n Setting start_position differs from just passing over a shortened\n string and setting G_REGEX_MATCH_NOTBOL in the case of a pattern\n that begins with any kind of lookbehind assertion, such as \"\\b\".\n A GMatchInfo structure, used to get information on the match, is\n stored in match_info if not NULL. Note that if match_info is\n not NULL then it is created even if the function returns FALSE,\n i.e. you must free it regardless if regular expression actually\n matched.\n string is not copied and is used in GMatchInfo internally. If\n you use any GMatchInfo method (except g_match_info_free()) after\n freeing or modifying string then the behaviour is undefined.\n Since 2.14\n Params:\n string = the string to scan for matches. [array length=string_len]\n stringLen = the length of string, or -1 if string is nul-terminated\n startPosition = starting index of the string to match\n matchOptions = match options\n matchInfo = pointer to location where to store\n  the GMatchInfo, or NULL if you do not need it. [out][allow-none]\n Returns: TRUE is the string matched, FALSE otherwise\n Throws: GException on failure.\n\t \n",
"line" : 483}
,
{
"name" : "splitSimple",
"kind" : "function",
"protection" : "public",
"type" : "string[](string pattern, string string, GRegexCompileFlags compileOptions, GRegexMatchFlags matchOptions)",
"comment" : "\n Breaks the string on the pattern, and returns an array of\n the tokens. If the pattern contains capturing parentheses,\n then the text for each of the substrings will also be returned.\n If the pattern does not match anywhere in the string, then the\n whole string is returned as the first token.\n This function is equivalent to g_regex_split() but it does\n not require to compile the pattern with g_regex_new(), avoiding\n some lines of code when you need just to do a split without\n extracting substrings, capture counts, and so on.\n If this function is to be called on the same pattern more than\n once, it's more efficient to compile the pattern once with\n g_regex_new() and then use g_regex_split().\n As a special case, the result of splitting the empty string \"\"\n is an empty vector, not a vector containing a single string.\n The reason for this special case is that being able to represent\n a empty vector is typically more useful than consistent handling\n of empty elements. If you do need to represent empty elements,\n you'll need to check for the empty string before calling this\n function.\n A pattern that can match empty strings splits string into\n separate characters wherever it matches the empty string between\n characters. For example splitting \"ab c\" using as a separator\n \"\\s*\", you will get \"a\", \"b\" and \"c\".\n Since 2.14\n Params:\n pattern = the regular expression\n string = the string to scan for matches\n compileOptions = compile options for the regular expression, or 0\n matchOptions = match options, or 0\n Returns: a NULL-terminated array of strings. Free it using g_strfreev()\n\t \n",
"line" : 532}
,
{
"name" : "split",
"kind" : "function",
"protection" : "public",
"type" : "string[](string string, GRegexMatchFlags matchOptions)",
"comment" : "\n Breaks the string on the pattern, and returns an array of the tokens.\n If the pattern contains capturing parentheses, then the text for each\n of the substrings will also be returned. If the pattern does not match\n anywhere in the string, then the whole string is returned as the first\n token.\n As a special case, the result of splitting the empty string \"\" is an\n empty vector, not a vector containing a single string. The reason for\n this special case is that being able to represent a empty vector is\n typically more useful than consistent handling of empty elements. If\n you do need to represent empty elements, you'll need to check for the\n empty string before calling this function.\n A pattern that can match empty strings splits string into separate\n characters wherever it matches the empty string between characters.\n For example splitting \"ab c\" using as a separator \"\\s*\", you will get\n \"a\", \"b\" and \"c\".\n Since 2.14\n Params:\n string = the string to split with the pattern\n matchOptions = match time option flags\n Returns: a NULL-terminated gchar ** array. Free it using g_strfreev()\n\t \n",
"line" : 560}
,
{
"name" : "splitFull",
"kind" : "function",
"protection" : "public",
"type" : "string[](string string, long stringLen, int startPosition, GRegexMatchFlags matchOptions, int maxTokens)",
"comment" : "\n Breaks the string on the pattern, and returns an array of the tokens.\n If the pattern contains capturing parentheses, then the text for each\n of the substrings will also be returned. If the pattern does not match\n anywhere in the string, then the whole string is returned as the first\n token.\n As a special case, the result of splitting the empty string \"\" is an\n empty vector, not a vector containing a single string. The reason for\n this special case is that being able to represent a empty vector is\n typically more useful than consistent handling of empty elements. If\n you do need to represent empty elements, you'll need to check for the\n empty string before calling this function.\n A pattern that can match empty strings splits string into separate\n characters wherever it matches the empty string between characters.\n For example splitting \"ab c\" using as a separator \"\\s*\", you will get\n \"a\", \"b\" and \"c\".\n Setting start_position differs from just passing over a shortened\n string and setting G_REGEX_MATCH_NOTBOL in the case of a pattern\n that begins with any kind of lookbehind assertion, such as \"\\b\".\n Since 2.14\n Params:\n string = the string to split with the pattern. [array length=string_len]\n stringLen = the length of string, or -1 if string is nul-terminated\n startPosition = starting index of the string to match\n matchOptions = match time option flags\n maxTokens = the maximum number of tokens to split string into.\n  If this is less than 1, the string is split completely\n Returns: a NULL-terminated gchar ** array. Free it using g_strfreev()\n Throws: GException on failure.\n\t \n",
"line" : 596}
,
{
"name" : "replace",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, long stringLen, int startPosition, string replacement, GRegexMatchFlags matchOptions)",
"comment" : "\n Replaces all occurrences of the pattern in regex with the\n replacement text. Backreferences of the form '\\number' or\n '\\g<number>' in the replacement text are interpolated by the\n number-th captured subexpression of the match, '\\g<name>' refers\n to the captured subexpression with the given name. '\\0' refers to the\n complete match, but '\\0' followed by a number is the octal representation\n of a character. To include a literal '\\' in the replacement, write '\\\\'.\n Since 2.14\n Params:\n string = the string to perform matches against. [array length=string_len]\n stringLen = the length of string, or -1 if string is nul-terminated\n startPosition = starting index of the string to match\n replacement = text to replace each match with\n matchOptions = options for the match\n Returns: a newly allocated string containing the replacements\n Throws: GException on failure.\n\t \n",
"line" : 629}
,
{
"name" : "replaceLiteral",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, long stringLen, int startPosition, string replacement, GRegexMatchFlags matchOptions)",
"comment" : "\n Replaces all occurrences of the pattern in regex with the\n replacement text. replacement is replaced literally, to\n include backreferences use g_regex_replace().\n Setting start_position differs from just passing over a\n shortened string and setting G_REGEX_MATCH_NOTBOL in the\n case of a pattern that begins with any kind of lookbehind\n assertion, such as \"\\b\".\n Since 2.14\n Params:\n string = the string to perform matches against. [array length=string_len]\n stringLen = the length of string, or -1 if string is nul-terminated\n startPosition = starting index of the string to match\n replacement = text to replace each match with\n matchOptions = options for the match\n Returns: a newly allocated string containing the replacements\n Throws: GException on failure.\n\t \n",
"line" : 662}
,
{
"name" : "replaceEval",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, long stringLen, int startPosition, GRegexMatchFlags matchOptions, extern (C) int function(GMatchInfo*, GString*, void*) eval, void* userData)",
"comment" : "\n Replaces occurrences of the pattern in regex with the output of\n eval for that occurrence.\n Setting start_position differs from just passing over a shortened\n string and setting G_REGEX_MATCH_NOTBOL in the case of a pattern\n that begins with any kind of lookbehind assertion, such as \"\\b\".\n The following example uses g_regex_replace_eval() to replace multiple\n Since 2.14\n Params:\n string = string to perform matches against. [array length=string_len]\n stringLen = the length of string, or -1 if string is nul-terminated\n startPosition = starting index of the string to match\n matchOptions = options for the match\n eval = a function to call for each match\n userData = user data to pass to the function\n Returns: a newly allocated string containing the replacements\n Throws: GException on failure.\n\t \n",
"line" : 695}
,
{
"name" : "checkReplacement",
"kind" : "function",
"protection" : "public",
"type" : "int(string replacement, out int hasReferences)",
"comment" : "\n Checks whether replacement is a valid replacement string\n (see g_regex_replace()), i.e. that all escape sequences in\n it are valid.\n If has_references is not NULL then replacement is checked\n for pattern references. For instance, replacement text 'foo\\n'\n does not contain references and may be evaluated without information\n about actual match, but '\\0\\1' (whole match followed by first\n subpattern) requires valid GMatchInfo object.\n Since 2.14\n Params:\n replacement = the replacement string\n hasReferences = location to store information about\n  references in replacement or NULL. [out][allow-none]\n Returns: whether replacement is a valid replacement string\n Throws: GException on failure.\n\t \n",
"line" : 727}
]
}
]
}
,
{
"name" : "glib.Relation",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Relation.d",
"members" : [
{
"name" : "Relation",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GRelation is a table of data which can be indexed on any number\n of fields, rather like simple database tables. A GRelation contains\n a number of records, called tuples. Each record contains a number of\n fields. Records are not ordered, so it is not possible to find the\n record at a particular index.\n Note that GRelation tables are currently limited to 2 fields.\n To create a GRelation, use g_relation_new().\n To specify which fields should be indexed, use g_relation_index().\n Note that this must be called before any tuples are added to the\n GRelation.\n To add records to a GRelation use g_relation_insert().\n To determine if a given record appears in a GRelation, use\n g_relation_exists(). Note that fields are compared directly, so\n pointers must point to the exact same position (i.e. different\n copies of the same string will not match.)\n To count the number of records which have a particular value in a\n given field, use g_relation_count().\n To get all the records which have a particular value in a given\n field, use g_relation_select(). To access fields of the resulting\n records, use g_tuples_index(). To free the resulting records use\n g_tuples_destroy().\n To delete all records which have a particular value in a given\n field, use g_relation_delete().\n To destroy the GRelation, use g_relation_destroy().\n To help debug GRelation objects, use g_relation_print().\n GRelation has been marked as deprecated, since this API has never\n been fully implemented, is not very actively maintained and rarely\n used.\n \n",
"line" : 100,
"base" : "Object",
"members" : [
{
"name" : "gRelation",
"kind" : "variable",
"protection" : "protected",
"type" : "GRelation*",
"comment" : " the main Gtk struct \n",
"line" : 103}
,
{
"name" : "getRelationStruct",
"kind" : "function",
"protection" : "public",
"type" : "GRelation*()",
"line" : 106}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 113}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Relation(GRelation* gRelation)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 121}
,
{
"name" : "print",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Outputs information about all records in a GRelation, as well as the indexes.\n It is for debugging.\n\t \n",
"line" : 145}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Relation(int fields)",
"comment" : "\n\t \n\n Warning\n g_relation_new has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Creates a new GRelation with the given number of fields. Note that\n currently the number of fields must be 2.\n Params:\n fields = the number of fields.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 172}
,
{
"name" : "index",
"kind" : "function",
"protection" : "public",
"type" : "void(int field, extern (C) uint function(void*) hashFunc, extern (C) int function(void*, void*) keyEqualFunc)",
"comment" : "\n Warning\n g_relation_index has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Creates an index on the given field. Note that this must be called\n before any records are added to the GRelation.\n Params:\n field = the field to index, counting from 0.\n hashFunc = a function to produce a hash value from the field data.\n keyEqualFunc = a function to compare two values of the given field.\n\t \n",
"line" : 193}
,
{
"name" : "count",
"kind" : "function",
"protection" : "public",
"type" : "int(void* key, int field)",
"comment" : "\n Warning\n g_relation_count has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Returns the number of tuples in a GRelation that have the given\n value in the given field.\n Params:\n key = the value to compare with.\n field = the field of each record to match.\n Returns: the number of matches.\n\t \n",
"line" : 209}
,
{
"name" : "select",
"kind" : "function",
"protection" : "public",
"type" : "Tuples(void* key, int field)",
"comment" : "\n Warning\n g_relation_select has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Returns all of the tuples which have the given key in the given\n field. Use g_tuples_index() to access the returned records. The\n returned records should be freed with g_tuples_destroy().\n Params:\n key = the value to compare with.\n field = the field of each record to match.\n Returns: the records (tuples) that matched.\n\t \n",
"line" : 226}
,
{
"name" : "delet",
"kind" : "function",
"protection" : "public",
"type" : "int(void* key, int field)",
"comment" : "\n Warning\n g_relation_delete has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Deletes any records from a GRelation that have the given key value\n in the given field.\n Params:\n key = the value to compare with.\n field = the field of each record to match.\n Returns: the number of records deleted.\n\t \n",
"line" : 247}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_relation_destroy has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Destroys the GRelation, freeing all memory allocated. However, it\n does not free memory allocated for the tuple data, so you should\n free that first if appropriate.\n\t \n",
"line" : 260}
]
}
]
}
,
{
"name" : "glib.ScannerG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ScannerG.d",
"members" : [
{
"name" : "ScannerG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GScanner and its associated functions provide a general purpose\n lexical scanner.\n \n",
"line" : 72,
"base" : "Object",
"members" : [
{
"name" : "gScanner",
"kind" : "variable",
"protection" : "protected",
"type" : "GScanner*",
"comment" : " the main Gtk struct \n",
"line" : 75}
,
{
"name" : "getScannerGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GScanner*()",
"line" : 78}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 85}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ScannerG(GScanner* gScanner)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 93}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ScannerG(GScannerConfig* configTempl)",
"comment" : "\n\t \n\n Creates a new GScanner.\n The config_templ structure specifies the initial settings of the scanner,\n which are copied into the GScanner config field.\n If you pass NULL then the default settings are used.\n Params:\n configTempl = the initial scanner settings.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 115}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees all memory used by the GScanner.\n\t \n",
"line" : 129}
,
{
"name" : "inputFile",
"kind" : "function",
"protection" : "public",
"type" : "void(int inputFd)",
"comment" : "\n Prepares to scan a file.\n Params:\n inputFd = a file descriptor.\n\t \n",
"line" : 140}
,
{
"name" : "syncFileOffset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Rewinds the filedescriptor to the current buffer position and blows\n the file read ahead buffer. This is useful for third party uses of\n the scanners filedescriptor, which hooks onto the current scanning\n position.\n\t \n",
"line" : 152}
,
{
"name" : "inputText",
"kind" : "function",
"protection" : "public",
"type" : "void(string text, uint textLen)",
"comment" : "\n Prepares to scan a text buffer.\n Params:\n text = the text buffer to scan.\n textLen = the length of the text buffer.\n\t \n",
"line" : 164}
,
{
"name" : "peekNextToken",
"kind" : "function",
"protection" : "public",
"type" : "GTokenType()",
"comment" : "\n Parses the next token, without removing it from the input stream.\n The token data is placed in the\n next_token,\n next_value,\n next_line, and\n next_position fields of the GScanner structure.\n Note that, while the token is not removed from the input stream (i.e.\n the next call to g_scanner_get_next_token() will return the same token),\n it will not be reevaluated. This can lead to surprising results when\n changing scope or the scanner configuration after peeking the next token.\n Getting the next token after switching the scope or configuration will\n return whatever was peeked before, regardless of any symbols that may\n have been added or removed in the new scope.\n Returns: the type of the token.\n\t \n",
"line" : 186}
,
{
"name" : "getNextToken",
"kind" : "function",
"protection" : "public",
"type" : "GTokenType()",
"comment" : "\n Parses the next token just like g_scanner_peek_next_token() and also\n removes it from the input stream.\n The token data is placed in the\n token,\n value,\n line, and\n position fields of the GScanner structure.\n Returns: the type of the token.\n\t \n",
"line" : 202}
,
{
"name" : "eof",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns TRUE if the scanner has reached the end of the file or text buffer.\n Returns: TRUE if the scanner has reached the end of the file or text buffer.\n\t \n",
"line" : 212}
,
{
"name" : "curLine",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the current line in the input stream (counting from 1).\n This is the line of the last token parsed via g_scanner_get_next_token().\n Returns: the current line.\n\t \n",
"line" : 223}
,
{
"name" : "curPosition",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the current position in the current line (counting from 0).\n This is the position of the last token parsed via g_scanner_get_next_token().\n Returns: the current position on the line.\n\t \n",
"line" : 234}
,
{
"name" : "curToken",
"kind" : "function",
"protection" : "public",
"type" : "GTokenType()",
"comment" : "\n Gets the current token type.\n This is simply the token field in the GScanner\n structure.\n Returns: the current token type.\n\t \n",
"line" : 246}
,
{
"name" : "curValue",
"kind" : "function",
"protection" : "public",
"type" : "GTokenValue()",
"comment" : "\n Gets the current token value.\n This is simply the value field in the GScanner\n structure.\n Returns: the current token value.\n\t \n",
"line" : 258}
,
{
"name" : "setScope",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint scopeId)",
"comment" : "\n Sets the current scope.\n Params:\n scopeId = the new scope id.\n Returns: the old scope id.\n\t \n",
"line" : 270}
,
{
"name" : "scopeAddSymbol",
"kind" : "function",
"protection" : "public",
"type" : "void(uint scopeId, string symbol, void* value)",
"comment" : "\n Adds a symbol to the given scope.\n Params:\n scopeId = the scope id.\n symbol = the symbol to add.\n value = the value of the symbol.\n\t \n",
"line" : 283}
,
{
"name" : "scopeForeachSymbol",
"kind" : "function",
"protection" : "public",
"type" : "void(uint scopeId, extern (C) void function(void*, void*, void*) func, void* userData)",
"comment" : "\n Calls the given function for each of the symbol\/value pairs in the\n given scope of the GScanner. The function is passed the symbol and\n value of each pair, and the given user_data parameter.\n Params:\n scopeId = the scope id.\n func = the function to call for each symbol\/value pair.\n userData = user data to pass to the function.\n\t \n",
"line" : 298}
,
{
"name" : "scopeLookupSymbol",
"kind" : "function",
"protection" : "public",
"type" : "void*(uint scopeId, string symbol)",
"comment" : "\n Looks up a symbol in a scope and return its value. If the\n symbol is not bound in the scope, NULL is returned.\n Params:\n scopeId = the scope id.\n symbol = the symbol to look up.\n Returns: the value of symbol in the given scope, or NULL if symbol is not bound in the given scope.\n\t \n",
"line" : 312}
,
{
"name" : "scopeRemoveSymbol",
"kind" : "function",
"protection" : "public",
"type" : "void(uint scopeId, string symbol)",
"comment" : "\n Removes a symbol from a scope.\n Params:\n scopeId = the scope id.\n symbol = the symbol to remove.\n\t \n",
"line" : 324}
,
{
"name" : "lookupSymbol",
"kind" : "function",
"protection" : "public",
"type" : "void*(string symbol)",
"comment" : "\n Looks up a symbol in the current scope and return its value. If the\n symbol is not bound in the current scope, NULL is returned.\n Params:\n symbol = the symbol to look up.\n Returns: the value of symbol in the current scope, or NULL if symbol is not bound in the current scope.\n\t \n",
"line" : 337}
,
{
"name" : "unexpToken",
"kind" : "function",
"protection" : "public",
"type" : "void(GTokenType expectedToken, string identifierSpec, string symbolSpec, string symbolName, string message, int isError)",
"comment" : "\n Outputs a message through the scanner's msg_handler, resulting from an\n unexpected token in the input stream.\n Note that you should not call g_scanner_peek_next_token() followed by\n g_scanner_unexp_token() without an intermediate call to\n g_scanner_get_next_token(), as g_scanner_unexp_token() evaluates the\n scanner's current token (not the peeked token) to construct part\n of the message.\n Params:\n expectedToken = the expected token.\n identifierSpec = a string describing how the scanner's user refers to\n  identifiers (NULL defaults to \"identifier\").\n  This is used if expected_token is G_TOKEN_IDENTIFIER\n  or G_TOKEN_IDENTIFIER_NULL.\n symbolSpec = a string describing how the scanner's user refers to\n  symbols (NULL defaults to \"symbol\").\n  This is used if expected_token is G_TOKEN_SYMBOL or\n  any token value greater than G_TOKEN_LAST.\n symbolName = the name of the symbol, if the scanner's current token\n  is a symbol.\n message = a message string to output at the end of the warning\/error, or NULL.\n isError = if TRUE it is output as an error. If FALSE it is output as a\n  warning.\n\t \n",
"line" : 367}
]
}
]
}
,
{
"name" : "glib.Sequence",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Sequence.d",
"members" : [
{
"name" : "Sequence",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GSequence data structure has the API of a list, but is\n implemented internally with a balanced binary tree. This means that\n it is possible to maintain a sorted list of n elements in time O(n\n log n). The data contained in each element can be either integer\n values, by using of the Type Conversion Macros,\n or simply pointers to any type of data.\n A GSequence is accessed through iterators,\n represented by a GSequenceIter. An iterator represents a position\n between two elements of the sequence. For example, the\n begin iterator represents the gap immediately\n before the first element of the sequence, and the\n end iterator represents the gap immediately\n after the last element. In an empty sequence, the begin and end\n iterators are the same.\n Some methods on GSequence operate on ranges of items. For example\n g_sequence_foreach_range() will call a user-specified function on\n each element with the given range. The range is delimited by the\n gaps represented by the passed-in iterators, so if you pass in the\n begin and end iterators, the range in question is the entire\n sequence.\n The function g_sequence_get() is used with an iterator to access the\n element immediately following the gap that the iterator represents.\n The iterator is said to point to that element.\n Iterators are stable across most operations on a GSequence. For\n example an iterator pointing to some element of a sequence will\n continue to point to that element even after the sequence is sorted.\n Even moving an element to another sequence using for example\n g_sequence_move_range() will not invalidate the iterators pointing\n to it. The only operation that will invalidate an iterator is when\n the element it points to is removed from any sequence.\n \n",
"line" : 102,
"base" : "Object",
"members" : [
{
"name" : "gSequence",
"kind" : "variable",
"protection" : "protected",
"type" : "GSequence*",
"comment" : " the main Gtk struct \n",
"line" : 105}
,
{
"name" : "getSequenceStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSequence*()",
"line" : 108}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 115}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Sequence(GSequence* gSequence)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 123}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Sequence(extern (C) void function(void* cbData) dataDestroy)",
"comment" : "\n\t \n\n Creates a new GSequence. The data_destroy function, if non-NULL will\n be called on all items when the sequence is destroyed and on items that\n are removed from the sequence.\n Since 2.14\n Params:\n dataDestroy = a GDestroyNotify function, or NULL\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 145}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees the memory allocated for seq. If seq has a data destroy\n function associated with it, that function is called on all items in\n seq.\n Since 2.14\n\t \n",
"line" : 162}
,
{
"name" : "getLength",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the length of seq\n Since 2.14\n Returns: the length of seq\n\t \n",
"line" : 173}
,
{
"name" : "foreac",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function(void*, void*) func, void* userData)",
"comment" : "\n Calls func for each item in the sequence passing user_data\n to the function.\n Since 2.14\n Params:\n func = the function to call for each item in seq\n userData = user data passed to func\n\t \n",
"line" : 187}
,
{
"name" : "foreachRange",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter begin, SequenceIter end, extern (C) void function(void*, void*) func, void* userData)",
"comment" : "\n Calls func for each item in the range (begin, end) passing\n user_data to the function.\n Since 2.14\n Params:\n begin = a GSequenceIter\n end = a GSequenceIter\n func = a GFunc\n userData = user data passed to func\n\t \n",
"line" : 203}
,
{
"name" : "sort",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) cmpFunc, void* cmpData)",
"comment" : "\n Sorts seq using cmp_func.\n Since 2.14\n Params:\n cmpFunc = the GCompareDataFunc used to sort seq. This function is\n  passed two items of seq and should return 0 if they are equal,\n  a negative value if the first comes before the second, and a\n  positive value if the second comes before the first.\n cmpData = user data passed to cmp_func\n\t \n",
"line" : 219}
,
{
"name" : "sortIter",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(GSequenceIter*, GSequenceIter*, void*) cmpFunc, void* cmpData)",
"comment" : "\n Like g_sequence_sort(), but uses a GSequenceIterCompareFunc instead\n of a GCompareDataFunc as the compare function\n Since 2.14\n Params:\n cmpFunc = the GSequenceItercompare used to compare iterators in the\n  sequence. It is called with two iterators pointing into seq. It should\n  return 0 if the iterators are equal, a negative value if the first\n  iterator comes before the second, and a positive value if the second\n  iterator comes before the first.\n cmpData = user data passed to cmp_func\n\t \n",
"line" : 237}
,
{
"name" : "getBeginIter",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter()",
"comment" : "\n Returns the begin iterator for seq.\n Since 2.14\n Returns: the begin iterator for seq.\n\t \n",
"line" : 248}
,
{
"name" : "getEndIter",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter()",
"comment" : "\n Returns the end iterator for seg\n Since 2.14\n Returns: the end iterator for seq\n\t \n",
"line" : 264}
,
{
"name" : "getIterAtPos",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(int pos)",
"comment" : "\n Returns the iterator at position pos. If pos is negative or larger\n than the number of items in seq, the end iterator is returned.\n Since 2.14\n Params:\n pos = a position in seq, or -1 for the end.\n Returns: The GSequenceIter at position pos\n\t \n",
"line" : 283}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(void* data)",
"comment" : "\n Adds a new item to the end of seq.\n Since 2.14\n Params:\n data = the data for the new item\n Returns: an iterator pointing to the new item\n\t \n",
"line" : 301}
,
{
"name" : "prepend",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(void* data)",
"comment" : "\n Adds a new item to the front of seq\n Since 2.14\n Params:\n data = the data for the new item\n Returns: an iterator pointing to the new item\n\t \n",
"line" : 319}
,
{
"name" : "insertBefore",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(SequenceIter iter, void* data)",
"comment" : "\n Inserts a new item just before the item pointed to by iter.\n Since 2.14\n Params:\n iter = a GSequenceIter\n data = the data for the new item\n Returns: an iterator pointing to the new item\n\t \n",
"line" : 338}
,
{
"name" : "move",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter src, SequenceIter dest)",
"comment" : "\n Moves the item pointed to by src to the position indicated by dest.\n After calling this function dest will point to the position immediately\n after src. It is allowed for src and dest to point into different\n sequences.\n Since 2.14\n Params:\n src = a GSequenceIter pointing to the item to move\n dest = a GSequenceIter pointing to the position to which\n  the item is moved.\n\t \n",
"line" : 360}
,
{
"name" : "swap",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter a, SequenceIter b)",
"comment" : "\n Swaps the items pointed to by a and b. It is allowed for a and b\n to point into difference sequences.\n Since 2.14\n Params:\n a = a GSequenceIter\n b = a GSequenceIter\n\t \n",
"line" : 374}
,
{
"name" : "insertSorted",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(void* data, extern (C) int function(void*, void*, void*) cmpFunc, void* cmpData)",
"comment" : "\n Inserts data into sequence using func to determine the new position.\n The sequence must already be sorted according to cmp_func; otherwise the\n new position of data is undefined.\n Since 2.14\n Params:\n data = the data to insert\n cmpFunc = the GCompareDataFunc used to compare items in the sequence. It\n  is called with two items of the seq and user_data. It should\n  return 0 if the items are equal, a negative value if the first\n  item comes before the second, and a positive value if the second\n  item comes before the first.\n cmpData = user data passed to cmp_func.\n Returns: a GSequenceIter pointing to the new item.\n\t \n",
"line" : 395}
,
{
"name" : "insertSortedIter",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(void* data, extern (C) int function(GSequenceIter*, GSequenceIter*, void*) iterCmp, void* cmpData)",
"comment" : "\n Like g_sequence_insert_sorted(), but uses\n a GSequenceIterCompareFunc instead of a GCompareDataFunc as\n the compare function.\n Since 2.14\n Params:\n data = data for the new item\n iterCmp = the GSequenceItercompare used to compare iterators in the\n  sequence. It is called with two iterators pointing into seq. It should\n  return 0 if the iterators are equal, a negative value if the first\n  iterator comes before the second, and a positive value if the second\n  iterator comes before the first.\n cmpData = user data passed to cmp_func\n Returns: a GSequenceIter pointing to the new item\n\t \n",
"line" : 421}
,
{
"name" : "sortChanged",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter iter, extern (C) int function(void*, void*, void*) cmpFunc, void* cmpData)",
"comment" : "\n Moves the data pointed to a new position as indicated by cmp_func. This\n function should be called for items in a sequence already sorted according\n to cmp_func whenever some aspect of an item changes so that cmp_func\n may return different values for that item.\n Since 2.14\n Params:\n iter = A GSequenceIter\n cmpFunc = the GCompareDataFunc used to compare items in the sequence. It\n  is called with two items of the seq and user_data. It should\n  return 0 if the items are equal, a negative value if the first\n  item comes before the second, and a positive value if the second\n  item comes before the first.\n cmpData = user data passed to cmp_func.\n\t \n",
"line" : 447}
,
{
"name" : "sortChangedIter",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter iter, extern (C) int function(GSequenceIter*, GSequenceIter*, void*) iterCmp, void* cmpData)",
"comment" : "\n Like g_sequence_sort_changed(), but uses\n a GSequenceIterCompareFunc instead of a GCompareDataFunc as\n the compare function.\n Since 2.14\n Params:\n iter = a GSequenceIter\n iterCmp = the GSequenceItercompare used to compare iterators in the\n  sequence. It is called with two iterators pointing into seq. It should\n  return 0 if the iterators are equal, a negative value if the first\n  iterator comes before the second, and a positive value if the second\n  iterator comes before the first.\n cmpData = user data passed to cmp_func\n\t \n",
"line" : 467}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter iter)",
"comment" : "\n Removes the item pointed to by iter. It is an error to pass the\n end iterator to this function.\n If the sequnce has a data destroy function associated with it, this\n function is called on the data for the removed item.\n Since 2.14\n Params:\n iter = a GSequenceIter\n\t \n",
"line" : 482}
,
{
"name" : "removeRange",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter begin, SequenceIter end)",
"comment" : "\n Removes all items in the (begin, end) range.\n If the sequence has a data destroy function associated with it, this\n function is called on the data for the removed items.\n Since 2.14\n Params:\n begin = a GSequenceIter\n end = a GSequenceIter\n\t \n",
"line" : 497}
,
{
"name" : "moveRange",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter dest, SequenceIter begin, SequenceIter end)",
"comment" : "\n Inserts the (begin, end) range at the destination pointed to by ptr.\n The begin and end iters must point into the same sequence. It is\n allowed for dest to point to a different sequence than the one pointed\n into by begin and end.\n If dest is NULL, the range indicated by begin and end is\n removed from the sequence. If dest iter points to a place within\n the (begin, end) range, the range does not move.\n Since 2.14\n Params:\n dest = a GSequenceIter\n begin = a GSequenceIter\n end = a GSequenceIter\n\t \n",
"line" : 517}
,
{
"name" : "search",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(void* data, extern (C) int function(void*, void*, void*) cmpFunc, void* cmpData)",
"comment" : "\n Returns an iterator pointing to the position where data would\n be inserted according to cmp_func and cmp_data.\n Since 2.14\n Params:\n data = data for the new item\n cmpFunc = the GCompareDataFunc used to compare items in the sequence. It\n  is called with two items of the seq and user_data. It should\n  return 0 if the items are equal, a negative value if the first\n  item comes before the second, and a positive value if the second\n  item comes before the first.\n cmpData = user data passed to cmp_func.\n Returns: an GSequenceIter pointing to the position where data would have been inserted according to cmp_func and cmp_data.\n\t \n",
"line" : 537}
,
{
"name" : "searchIter",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(void* data, extern (C) int function(GSequenceIter*, GSequenceIter*, void*) iterCmp, void* cmpData)",
"comment" : "\n Like g_sequence_search(), but uses\n a GSequenceIterCompareFunc instead of a GCompareDataFunc as\n the compare function.\n Since 2.14\n Params:\n data = data for the new item\n iterCmp = the GSequenceIterCompare function used to compare iterators\n  in the sequence. It is called with two iterators pointing into seq.\n  It should return 0 if the iterators are equal, a negative value if the\n  first iterator comes before the second, and a positive value if the\n  second iterator comes before the first.\n cmpData = user data passed to iter_cmp\n Returns: a GSequenceIter pointing to the position in seq where data would have been inserted according to iter_cmp and cmp_data.\n\t \n",
"line" : 563}
,
{
"name" : "get",
"kind" : "function",
"protection" : "public",
"type" : "void*(SequenceIter iter)",
"comment" : "\n Returns the data that iter points to.\n Since 2.14\n Params:\n iter = a GSequenceIter\n Returns: the data that iter points to\n\t \n",
"line" : 581}
,
{
"name" : "set",
"kind" : "function",
"protection" : "public",
"type" : "void(SequenceIter iter, void* data)",
"comment" : "\n Changes the data for the item pointed to by iter to be data. If\n the sequence has a data destroy function associated with it, that\n function is called on the existing data that iter pointed to.\n Since 2.14\n Params:\n iter = a GSequenceIter\n data = new data for the item\n\t \n",
"line" : 596}
,
{
"name" : "rangeGetMidpoint",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(SequenceIter begin, SequenceIter end)",
"comment" : "\n Finds an iterator somewhere in the range (begin, end). This\n iterator will be close to the middle of the range, but is not\n guaranteed to be exactly in the middle.\n The begin and end iterators must both point to the same sequence and\n begin must come before or be equal to end in the sequence.\n Since 2.14\n Params:\n begin = a GSequenceIter\n end = a GSequenceIter\n Returns: A GSequenceIter pointing somewhere in the (begin, end) range.\n\t \n",
"line" : 614}
]
}
]
}
,
{
"name" : "glib.SequenceIter",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/SequenceIter.d",
"members" : [
{
"name" : "SequenceIter",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GSequence data structure has the API of a list, but is\n implemented internally with a balanced binary tree. This means that\n it is possible to maintain a sorted list of n elements in time O(n\n log n). The data contained in each element can be either integer\n values, by using of the Type Conversion Macros,\n or simply pointers to any type of data.\n A GSequence is accessed through iterators,\n represented by a GSequenceIter. An iterator represents a position\n between two elements of the sequence. For example, the\n begin iterator represents the gap immediately\n before the first element of the sequence, and the\n end iterator represents the gap immediately\n after the last element. In an empty sequence, the begin and end\n iterators are the same.\n Some methods on GSequence operate on ranges of items. For example\n g_sequence_foreach_range() will call a user-specified function on\n each element with the given range. The range is delimited by the\n gaps represented by the passed-in iterators, so if you pass in the\n begin and end iterators, the range in question is the entire\n sequence.\n The function g_sequence_get() is used with an iterator to access the\n element immediately following the gap that the iterator represents.\n The iterator is said to point to that element.\n Iterators are stable across most operations on a GSequence. For\n example an iterator pointing to some element of a sequence will\n continue to point to that element even after the sequence is sorted.\n Even moving an element to another sequence using for example\n g_sequence_move_range() will not invalidate the iterators pointing\n to it. The only operation that will invalidate an iterator is when\n the element it points to is removed from any sequence.\n \n",
"line" : 101,
"base" : "Object",
"members" : [
{
"name" : "gSequenceIter",
"kind" : "variable",
"protection" : "protected",
"type" : "GSequenceIter*",
"comment" : " the main Gtk struct \n",
"line" : 104}
,
{
"name" : "getSequenceIterStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSequenceIter*()",
"line" : 107}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 114}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SequenceIter(GSequenceIter* gSequenceIter)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 122}
,
{
"name" : "isBegin",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n\t \n\n Returns whether iter is the begin iterator\n Since 2.14\n Returns: whether iter is the begin iterator\n\t \n",
"line" : 140}
,
{
"name" : "isEnd",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether iter is the end iterator\n Since 2.14\n Returns: Whether iter is the end iterator.\n\t \n",
"line" : 151}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter()",
"comment" : "\n Returns an iterator pointing to the next position after iter. If\n iter is the end iterator, the end iterator is returned.\n Since 2.14\n Returns: a GSequenceIter pointing to the next position after iter.\n\t \n",
"line" : 163}
,
{
"name" : "prev",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter()",
"comment" : "\n Returns an iterator pointing to the previous position before iter. If\n iter is the begin iterator, the begin iterator is returned.\n Since 2.14\n Returns: a GSequenceIter pointing to the previous position before iter.\n\t \n",
"line" : 180}
,
{
"name" : "getPosition",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the position of iter\n Since 2.14\n Returns: the position of iter\n\t \n",
"line" : 196}
,
{
"name" : "move",
"kind" : "function",
"protection" : "public",
"type" : "SequenceIter(int delta)",
"comment" : "\n Returns the GSequenceIter which is delta positions away from iter.\n If iter is closer than -delta positions to the beginning of the sequence,\n the begin iterator is returned. If iter is closer than delta positions\n to the end of the sequence, the end iterator is returned.\n Since 2.14\n Params:\n delta = A positive or negative number indicating how many positions away\n  from iter the returned GSequenceIter will be.\n Returns: a GSequenceIter which is delta positions away from iter.\n\t \n",
"line" : 213}
,
{
"name" : "getSequence",
"kind" : "function",
"protection" : "public",
"type" : "Sequence()",
"comment" : "\n Returns the GSequence that iter points into.\n Since 2.14\n Returns: the GSequence that iter points into.\n\t \n",
"line" : 229}
,
{
"name" : "compare",
"kind" : "function",
"protection" : "public",
"type" : "int(SequenceIter b)",
"comment" : "\n Returns a negative number if a comes before b, 0 if they are equal,\n and a positive number if a comes after b.\n The a and b iterators must point into the same sequence.\n Since 2.14\n Params:\n a = a GSequenceIter\n b = a GSequenceIter\n Returns: A negative number if a comes before b, 0 if they are equal, and a positive number if a comes after b.\n\t \n",
"line" : 250}
]
}
]
}
,
{
"name" : "glib.ShellUtils",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ShellUtils.d",
"members" : [
{
"name" : "ShellUtils",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n \n",
"line" : 74,
"base" : "Object",
"members" : [
{
"name" : "parseArgv",
"kind" : "function",
"protection" : "public",
"type" : "int(string commandLine, out int argcp, out string[] argvp)",
"comment" : "\n Parses a command line into an argument vector, in much the same way\n the shell would, but without many of the expansions the shell would\n perform (variable expansion, globs, operators, filename expansion,\n etc. are not supported). The results are defined to be the same as\n those you would get from a UNIX98 \/bin\/sh, as long as the input\n contains none of the unsupported shell expansions. If the input\n does contain such expansions, they are passed through\n literally. Possible errors are those from the G_SHELL_ERROR\n domain. Free the returned vector with g_strfreev().\n Params:\n commandLine =  command line to parse\n argcp =  return location for number of args\n argvp =  return location for array of args\n Returns: TRUE on success, FALSE if error set\n Throws: GException on failure.\n\t \n",
"line" : 93}
,
{
"name" : "quote",
"kind" : "function",
"protection" : "public",
"type" : "string(string unquotedString)",
"comment" : "\n\t \n\n Quotes a string so that the shell (\/bin\/sh) will interpret the\n quoted string to mean unquoted_string. If you pass a filename to\n the shell, for example, you should first quote it with this\n function. The return value must be freed with g_free(). The\n quoting style used is undefined (single or double quotes may be\n used).\n Params:\n unquotedString = a literal string\n Returns: quoted string\n\t \n",
"line" : 124}
,
{
"name" : "unquote",
"kind" : "function",
"protection" : "public",
"type" : "string(string quotedString)",
"comment" : "\n Unquotes a string as the shell (\/bin\/sh) would. Only handles\n quotes; if a string contains file globs, arithmetic operators,\n variables, backticks, redirections, or other special-to-the-shell\n features, the result will be different from the result a real shell\n would produce (the variables, backticks, etc. will be passed\n through literally instead of being expanded). This function is\n guaranteed to succeed if applied to the result of\n g_shell_quote(). If it fails, it returns NULL and sets the\n error. The quoted_string need not actually contain quoted or\n escaped text; g_shell_unquote() simply goes through the string and\n unquotes\/unescapes anything that the shell would. Both single and\n double quotes are handled, as are escapes including escaped\n newlines. The return value must be freed with g_free(). Possible\n errors are in the G_SHELL_ERROR domain.\n Shell quoting rules are a bit strange. Single quotes preserve the\n literal string exactly. escape sequences are not allowed; not even\n \\' - if you want a ' in the quoted text, you have to do something\n like 'foo'\\''bar'. Double quotes allow $, `, \", \\, and newline to\n be escaped with backslash. Otherwise double quotes preserve things\n literally.\n Params:\n quotedString = shell-quoted string\n Returns: an unquoted string\n Throws: GException on failure.\n\t \n",
"line" : 156}
]
}
]
}
,
{
"name" : "glib.SimpleXML",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/SimpleXML.d",
"members" : [
{
"name" : "SimpleXML",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The \"GMarkup\" parser is intended to parse a simple markup format\n that's a subset of XML. This is a small, efficient, easy-to-use\n parser. It should not be used if you expect to interoperate with other\n applications generating full-scale XML. However, it's very useful for\n application data files, config files, etc. where you know your\n application will be the only one writing the file. Full-scale XML\n parsers should be able to parse the subset used by GMarkup, so you can\n easily migrate to full-scale XML at a later time if the need arises.\n GMarkup is not guaranteed to signal an error on all invalid XML; the\n parser may accept documents that an XML parser would not. However, XML\n documents which are not well-formed[5] are not considered valid GMarkup\n documents.\n Simplifications to XML include:\n Only UTF-8 encoding is allowed.\n No user-defined entities.\n Processing instructions, comments and the doctype declaration are \"passed\n through\" but are not interpreted in any way.\n No DTD or validation.\n The markup format does support:\n Elements\n Attributes\n 5 standard entities: amp; lt; gt; quot; apos;\n Character references\n Sections marked as CDATA\n \n",
"line" : 101,
"base" : "Object",
"members" : [
{
"name" : "gMarkupParseContext",
"kind" : "variable",
"protection" : "protected",
"type" : "GMarkupParseContext*",
"comment" : " the main Gtk struct \n",
"line" : 104}
,
{
"name" : "getSimpleXMLStruct",
"kind" : "function",
"protection" : "public",
"type" : "GMarkupParseContext*()",
"line" : 107}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 114}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimpleXML(GMarkupParseContext* gMarkupParseContext)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 122}
,
{
"name" : "escapeText",
"kind" : "function",
"protection" : "public",
"type" : "string(string text, long length)",
"comment" : "\n\t \n\n Escapes text so that the markup parser will parse it verbatim.\n Less than, greater than, ampersand, etc. are replaced with the\n corresponding entities. This function would typically be used\n when writing out a file to be parsed with the markup parser.\n Note that this function doesn't protect whitespace and line endings\n from being processed according to the XML rules for normalization\n of line endings and attribute values.\n Note also that this function will produce character references in\n the range of x1; ... x1f; for all control sequences\n except for tabstop, newline and carriage return. The character\n references in this range are not valid XML 1.0, but they are\n valid XML 1.1 and will be accepted by the GMarkup parser.\n Params:\n text = some valid UTF-8 text\n length = length of text in bytes, or -1 if the text is nul-terminated\n Returns: a newly allocated string with the escaped text\n\t \n",
"line" : 153}
,
{
"name" : "vprintfEscaped",
"kind" : "function",
"protection" : "public",
"type" : "string(string format, void* args)",
"comment" : "\n Formats the data in args according to format, escaping\n all string and character arguments in the fashion\n of g_markup_escape_text(). See g_markup_printf_escaped().\n Since 2.4\n Params:\n format = printf() style format string\n args = variable argument list, similar to vprintf()\n Returns: newly allocated result from formatting operation. Free with g_free().\n\t \n",
"line" : 169}
,
{
"name" : "endParse",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Signals to the GMarkupParseContext that all data has been\n fed into the parse context with g_markup_parse_context_parse().\n This function reports an error if the document isn't complete,\n for example if elements are still open.\n Returns: TRUE on success, FALSE if an error was set\n Throws: GException on failure.\n\t \n",
"line" : 183}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a GMarkupParseContext. Can't be called from inside\n one of the GMarkupParser functions. Can't be called while\n a subparser is pushed.\n\t \n",
"line" : 203}
,
{
"name" : "getPosition",
"kind" : "function",
"protection" : "public",
"type" : "void(out int lineNumber, out int charNumber)",
"comment" : "\n Retrieves the current line number and the number of the character on\n that line. Intended for use in error messages; there are no strict\n semantics for what constitutes the \"current\" line number other than\n \"the best number we could come up with for error messages.\"\n Params:\n lineNumber = return location for a line number, or NULL\n charNumber = return location for a char-on-line number, or NULL\n\t \n",
"line" : 218}
,
{
"name" : "getElement",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Retrieves the name of the currently open element.\n If called from the start_element or end_element handlers this will\n give the element_name as passed to those functions. For the parent\n elements, see g_markup_parse_context_get_element_stack().\n Since 2.2\n Returns: the name of the currently open element, or NULL\n\t \n",
"line" : 232}
,
{
"name" : "getElementStack",
"kind" : "function",
"protection" : "public",
"type" : "ListSG()",
"comment" : "\n Retrieves the element stack from the internal state of the parser.\n The returned GSList is a list of strings where the first item is\n the currently open tag (as would be returned by\n g_markup_parse_context_get_element()) and the next item is its\n immediate parent.\n This function is intended to be used in the start_element and\n end_element handlers where g_markup_parse_context_get_element()\n would merely return the name of the element that is being\n processed.\n Since 2.16\n Returns: the element stack, which must not be modified\n\t \n",
"line" : 251}
,
{
"name" : "getUserData",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Returns the user_data associated with context. This will either\n be the user_data that was provided to g_markup_parse_context_new()\n or to the most recent call of g_markup_parse_context_push().\n Since 2.18\n Returns: the provided user_data. The returned data belongs to the markup context and will be freed when g_markup_context_free() is called.\n\t \n",
"line" : 269}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "SimpleXML(GMarkupParser* parser, GMarkupParseFlags flags, void* userData, extern (C) void function(void* cbData) userDataDnotify)",
"comment" : "\n Creates a new parse context. A parse context is used to parse\n marked-up documents. You can feed any number of documents into\n a context, as long as no errors occur; once an error occurs,\n the parse context can't continue to parse text (you have to free it\n and create a new parse context).\n Params:\n parser = a GMarkupParser\n flags = one or more GMarkupParseFlags\n userData = user data to pass to GMarkupParser functions\n userDataDnotify = user data destroy notifier called when the parse context is freed\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 288}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "int(string text, long textLen)",
"comment" : "\n Feed some data to the GMarkupParseContext. The data need not\n be valid UTF-8; an error will be signaled if it's invalid.\n The data need not be an entire document; you can feed a document\n into the parser incrementally, via multiple calls to this function.\n Typically, as you receive data from a network connection or file,\n you feed each received chunk of data into this function, aborting\n the process if an error occurs. Once an error is reported, no further\n data may be fed to the GMarkupParseContext; all errors are fatal.\n Params:\n text = chunk of text to parse\n textLen = length of text in bytes\n Returns: FALSE if an error occurred, TRUE on success\n Throws: GException on failure.\n\t \n",
"line" : 314}
,
{
"name" : "push",
"kind" : "function",
"protection" : "public",
"type" : "void(GMarkupParser* parser, void* userData)",
"comment" : "\n Temporarily redirects markup data to a sub-parser.\n This function may only be called from the start_element handler of\n a GMarkupParser. It must be matched with a corresponding call to\n g_markup_parse_context_pop() in the matching end_element handler\n (except in the case that the parser aborts due to an error).\n All tags, text and other data between the matching tags is\n redirected to the subparser given by parser. user_data is used\n as the user_data for that parser. user_data is also passed to the\n error callback in the event that an error occurs. This includes\n errors that occur in subparsers of the subparser.\n The end tag matching the start tag for which this call was made is\n handled by the previous parser (which is given its own user_data)\n which is why g_markup_parse_context_pop() is provided to allow \"one\n last access\" to the user_data provided to this function. In the\n case of error, the user_data provided here is passed directly to\n the error callback of the subparser and g_markup_parse_context()\n should not be called. In either case, if user_data was allocated\n then it ought to be freed from both of these locations.\n This function is not intended to be directly called by users\n interested in invoking subparsers. Instead, it is intended to be\n used by the subparsers themselves to implement a higher-level\n interface.\n As an example, see the following implementation of a simple\n parser that counts the number of tags encountered.\n $(DDOC_COMMENT example)\n In order to allow this parser to be easily used as a subparser, the\n Since 2.18\n Params:\n parser = a GMarkupParser\n userData = user data to pass to GMarkupParser functions\n\t \n",
"line" : 361}
,
{
"name" : "pop",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Completes the process of a temporary sub-parser redirection.\n This function exists to collect the user_data allocated by a\n matching call to g_markup_parse_context_push(). It must be called\n in the end_element handler corresponding to the start_element\n handler during which g_markup_parse_context_push() was called. You\n must not call this function from the error callback -- the\n user_data is provided directly to the callback in that case.\n This function is not intended to be directly called by users\n interested in invoking subparsers. Instead, it is intended to be\n used by the subparsers themselves to implement a higher-level\n interface.\n Since 2.18\n Returns: the user_data passed to g_markup_parse_context_push().\n\t \n",
"line" : 382}
]
}
]
}
,
{
"name" : "glib.Source",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Source.d",
"members" : [
{
"name" : "Source",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The main event loop manages all the available sources of events for\n GLib and GTK+ applications. These events can come from any number of\n different types of sources such as file descriptors (plain files,\n pipes or sockets) and timeouts. New types of event sources can also\n be added using g_source_attach().\n To allow multiple independent sets of sources to be handled in\n different threads, each source is associated with a GMainContext.\n A GMainContext can only be running in a single thread, but\n sources can be added to it and removed from it from other threads.\n Each event source is assigned a priority. The default priority,\n G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n Values greater than 0 denote lower priorities. Events from high priority\n sources are always processed before events from lower priority sources.\n Idle functions can also be added, and assigned a priority. These will\n be run whenever no events with a higher priority are ready to be processed.\n The GMainLoop data type represents a main event loop. A GMainLoop is\n created with g_main_loop_new(). After adding the initial event sources,\n g_main_loop_run() is called. This continuously checks for new events from\n each of the event sources and dispatches them. Finally, the processing of\n an event from one of the sources leads to a call to g_main_loop_quit() to\n exit the main loop, and g_main_loop_run() returns.\n It is possible to create new instances of GMainLoop recursively.\n This is often used in GTK+ applications when showing modal dialog\n boxes. Note that event sources are associated with a particular\n GMainContext, and will be checked and dispatched for all main\n loops associated with that GMainContext.\n GTK+ contains wrappers of some of these functions, e.g. gtk_main(),\n gtk_main_quit() and gtk_events_pending().\n Creating new source types\n One of the unusual features of the GMainLoop functionality\n is that new types of event source can be created and used in\n addition to the builtin type of event source. A new event source\n type is used for handling GDK events. A new source type is created\n by deriving from the GSource structure.\n The derived type of source is represented by a structure that has\n the GSource structure as a first element, and other elements specific\n to the new source type. To create an instance of the new source type,\n call g_source_new() passing in the size of the derived structure and\n a table of functions. These GSourceFuncs determine the behavior of\n the new source type.\n New source types basically interact with the main context\n in two ways. Their prepare function in GSourceFuncs can set a timeout\n to determine the maximum amount of time that the main loop will sleep\n before checking the source again. In addition, or as well, the source\n can add file descriptors to the set that the main context checks using\n g_source_add_poll().\n <hr>\n Customizing the main loop iteration\n Single iterations of a GMainContext can be run with\n g_main_context_iteration(). In some cases, more detailed control\n of exactly how the details of the main loop work is desired, for\n instance, when integrating the GMainLoop with an external main loop.\n In such cases, you can call the component functions of\n g_main_context_iteration() directly. These functions are\n g_main_context_prepare(), g_main_context_query(),\n g_main_context_check() and g_main_context_dispatch().\n The operation of these functions can best be seen in terms\n of a state diagram, as shown in Figure  1, “States of a Main Context”.\n Figure  1.  States of a Main Context\n \n",
"line" : 135,
"base" : "Object",
"members" : [
{
"name" : "gSource",
"kind" : "variable",
"protection" : "protected",
"type" : "GSource*",
"comment" : " the main Gtk struct \n",
"line" : 138}
,
{
"name" : "getSourceStruct",
"kind" : "function",
"protection" : "public",
"type" : "GSource*()",
"line" : 141}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 148}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Source(GSource* gSource)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 156}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Source(GSourceFuncs* sourceFuncs, uint structSize)",
"comment" : "\n\t \n\n Creates a new GSource structure. The size is specified to\n allow creating structures derived from GSource that contain\n additional data. The size passed in must be at least\n sizeof (GSource).\n The source will not initially be associated with any GMainContext\n and must be added to one with g_source_attach() before it will be\n executed.\n Params:\n sourceFuncs = structure containing functions that implement\n  the sources behavior.\n structSize = size of the GSource structure to create.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 183}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "Source()",
"comment" : "\n Increases the reference count on a source by one.\n Returns: source\n\t \n",
"line" : 198}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Decreases the reference count of a source by one. If the\n resulting reference count is zero the source and associated\n memory will be destroyed.\n\t \n",
"line" : 214}
,
{
"name" : "setFuncs",
"kind" : "function",
"protection" : "public",
"type" : "void(GSourceFuncs* funcs)",
"comment" : "\n Sets the source functions (can be used to override\n default implementations) of an unattached source.\n Since 2.12\n Params:\n funcs = the new GSourceFuncs\n\t \n",
"line" : 227}
,
{
"name" : "attach",
"kind" : "function",
"protection" : "public",
"type" : "uint(MainContext context)",
"comment" : "\n Adds a GSource to a context so that it will be executed within\n that context. Remove it by calling g_source_destroy().\n Params:\n context = a GMainContext (if NULL, the default context will be used)\n Returns: the ID (greater than 0) for the source within the GMainContext.\n\t \n",
"line" : 240}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Removes a source from its GMainContext, if any, and mark it as\n destroyed. The source cannot be subsequently added to another\n context.\n\t \n",
"line" : 251}
,
{
"name" : "isDestroyed",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns whether source has been destroyed.\n This is important when you operate upon your objects\n from within idle handlers, but may have freed the object\n before the dispatch of your idle handler.\n $(DDOC_COMMENT example)\n This will fail in a multi-threaded application if the\n widget is destroyed before the idle handler fires due\n to the use after free in the callback. A solution, to\n this particular problem, is to check to if the source\n has already been destroy within the callback.\n $(DDOC_COMMENT example)\n Since 2.12\n Returns: TRUE if the source has been destroyed\n\t \n",
"line" : 272}
,
{
"name" : "setPriority",
"kind" : "function",
"protection" : "public",
"type" : "void(int priority)",
"comment" : "\n Sets the priority of a source. While the main loop is being\n run, a source will be dispatched if it is ready to be dispatched and no sources\n at a higher (numerically smaller) priority are ready to be dispatched.\n Params:\n priority = the new priority.\n\t \n",
"line" : 285}
,
{
"name" : "getPriority",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Gets the priority of a source.\n Returns: the priority of the source\n\t \n",
"line" : 295}
,
{
"name" : "setCanRecurse",
"kind" : "function",
"protection" : "public",
"type" : "void(int canRecurse)",
"comment" : "\n Sets whether a source can be called recursively. If can_recurse is\n TRUE, then while the source is being dispatched then this source\n will be processed normally. Otherwise, all processing of this\n source is blocked until the dispatch function returns.\n Params:\n canRecurse = whether recursion is allowed for this source\n\t \n",
"line" : 309}
,
{
"name" : "getCanRecurse",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks whether a source is allowed to be called recursively.\n see g_source_set_can_recurse().\n Returns: whether recursion is allowed.\n\t \n",
"line" : 320}
,
{
"name" : "getId",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the numeric ID for a particular source. The ID of a source\n is a positive integer which is unique within a particular main loop\n context. The reverse\n mapping from ID to source is done by g_main_context_find_source_by_id().\n Returns: the ID (greater than 0) for the source\n\t \n",
"line" : 333}
,
{
"name" : "getName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets a name for the source, used in debugging and profiling.\n The name may be NULL if it has never been set with\n g_source_set_name().\n Since 2.26\n Returns: the name of the source\n\t \n",
"line" : 346}
,
{
"name" : "setName",
"kind" : "function",
"protection" : "public",
"type" : "void(string name)",
"comment" : "\n Sets a name for the source, used in debugging and profiling.\n The name defaults to NULL.\n The source name should describe in a human-readable way\n what the source does. For example, \"X11 event queue\"\n or \"GTK+ repaint idle handler\" or whatever it is.\n It is permitted to call this function multiple times, but is not\n recommended due to the potential performance impact. For example,\n one could change the name in the \"check\" function of a GSourceFuncs\n to include details like the event type in the source name.\n Since 2.26\n Params:\n name = debug name for the source\n\t \n",
"line" : 366}
,
{
"name" : "setNameById",
"kind" : "function",
"protection" : "public",
"type" : "void(uint tag, string name)",
"comment" : "\n Sets the name of a source using its ID.\n This is a convenience utility to set source names from the return\n value of g_idle_add(), g_timeout_add(), etc.\n Since 2.26\n Params:\n tag = a GSource ID\n name = debug name for the source\n\t \n",
"line" : 381}
,
{
"name" : "getContext",
"kind" : "function",
"protection" : "public",
"type" : "MainContext()",
"comment" : "\n Gets the GMainContext with which the source is associated.\n Calling this function on a destroyed source is an error.\n Returns: the GMainContext with which the source is associated, or NULL if the context has not yet been added to a source.\n\t \n",
"line" : 392}
,
{
"name" : "setCallback",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*) func, void* data, extern (C) void function(void* cbData) notify)",
"comment" : "\n Sets the callback function for a source. The callback for a source is\n called from the source's dispatch function.\n The exact type of func depends on the type of source; ie. you\n should not count on func being called with data as its first\n parameter.\n Typically, you won't use this function. Instead use functions specific\n to the type of source you are using.\n Params:\n func = a callback function\n data = the data to pass to callback function\n notify = a function to call when data is no longer in use, or NULL.\n\t \n",
"line" : 416}
,
{
"name" : "setCallbackIndirect",
"kind" : "function",
"protection" : "public",
"type" : "void(void* callbackData, GSourceCallbackFuncs* callbackFuncs)",
"comment" : "\n Sets the callback function storing the data as a refcounted callback\n \"object\". This is used internally. Note that calling\n g_source_set_callback_indirect() assumes\n an initial reference count on callback_data, and thus\n callback_funcs->unref will eventually be called once more\n than callback_funcs->ref.\n Params:\n callbackData = pointer to callback data \"object\"\n callbackFuncs = functions for reference counting callback_data\n  and getting the callback and data\n\t \n",
"line" : 434}
,
{
"name" : "addPoll",
"kind" : "function",
"protection" : "public",
"type" : "void(GPollFD* fd)",
"comment" : "\n Adds a file descriptor to the set of file descriptors polled for\n this source. This is usually combined with g_source_new() to add an\n event source. The event source's check function will typically test\n the revents field in the GPollFD struct and return TRUE if events need\n to be processed.\n Params:\n fd = a GPollFD structure holding information about a file\n  descriptor to watch.\n\t \n",
"line" : 450}
,
{
"name" : "removePoll",
"kind" : "function",
"protection" : "public",
"type" : "void(GPollFD* fd)",
"comment" : "\n Removes a file descriptor from the set of file descriptors polled for\n this source.\n Params:\n fd = a GPollFD structure previously passed to g_source_add_poll().\n\t \n",
"line" : 462}
,
{
"name" : "getCurrentTime",
"kind" : "function",
"protection" : "public",
"type" : "void(TimeVal timeval)",
"comment" : "\n Gets the \"current time\" to be used when checking\n this source. The advantage of calling this function over\n calling g_get_current_time() directly is that when\n checking multiple sources, GLib can cache a single value\n instead of having to repeatedly get the system time.\n Params:\n timeval = GTimeVal structure in which to store current time.\n\t \n",
"line" : 477}
,
{
"name" : "remove",
"kind" : "function",
"protection" : "public",
"type" : "int(uint tag)",
"comment" : "\n Removes the source with the given id from the default main context.\n The id of\n a GSource is given by g_source_get_id(), or will be returned by the\n functions g_source_attach(), g_idle_add(), g_idle_add_full(),\n g_timeout_add(), g_timeout_add_full(), g_child_watch_add(),\n g_child_watch_add_full(), g_io_add_watch(), and g_io_add_watch_full().\n See also g_source_destroy(). You must use g_source_destroy() for sources\n added to a non-default main context.\n Params:\n tag = the ID of the source to remove.\n Returns: TRUE if the source was found and removed.\n\t \n",
"line" : 496}
,
{
"name" : "removeByFuncsUserData",
"kind" : "function",
"protection" : "public",
"type" : "int(GSourceFuncs* funcs, void* userData)",
"comment" : "\n Removes a source from the default main loop context given the\n source functions and user data. If multiple sources exist with the\n same source functions and user data, only one will be destroyed.\n Params:\n funcs = The source_funcs passed to g_source_new()\n userData = the user data for the callback\n Returns: TRUE if a source was found and removed.\n\t \n",
"line" : 511}
,
{
"name" : "removeByUserData",
"kind" : "function",
"protection" : "public",
"type" : "int(void* userData)",
"comment" : "\n Removes a source from the default main loop context given the user\n data for the callback. If multiple sources exist with the same user\n data, only one will be destroyed.\n Params:\n userData = the user_data for the callback.\n Returns: TRUE if a source was found and removed.\n\t \n",
"line" : 525}
]
}
]
}
,
{
"name" : "glib.Spawn",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Spawn.d",
"members" : [
{
"name" : "Spawn",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n \n",
"line" : 103,
"base" : "Object",
"members" : [
{
"name" : "splitlines",
"kind" : "alias",
"protection" : "public",
"line" : 120}
,
{
"name" : "workingDirectory",
"kind" : "variable",
"protection" : "public",
"type" : "string",
"line" : 122}
,
{
"name" : "argv",
"kind" : "variable",
"protection" : "public",
"type" : "string[]",
"line" : 123}
,
{
"name" : "envp",
"kind" : "variable",
"protection" : "public",
"type" : "string[]",
"line" : 124}
,
{
"name" : "flags",
"kind" : "variable",
"protection" : "public",
"type" : "GSpawnFlags",
"line" : 125}
,
{
"name" : "childSetup",
"kind" : "variable",
"protection" : "public",
"type" : "extern (C) void function(void* cbData)",
"line" : 126}
,
{
"name" : "userData",
"kind" : "variable",
"protection" : "public",
"type" : "void*",
"line" : 127}
,
{
"name" : "childPid",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 128}
,
{
"name" : "standardInput",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 129}
,
{
"name" : "standardOutput",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 130}
,
{
"name" : "standardError",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 131}
,
{
"name" : "error",
"kind" : "variable",
"protection" : "public",
"type" : "GError*",
"line" : 132}
,
{
"name" : "stdIn",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 133}
,
{
"name" : "stdOut",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 134}
,
{
"name" : "stdErr",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 135}
,
{
"name" : "exitStatus",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 138}
,
{
"name" : "strOutput",
"kind" : "variable",
"protection" : "public",
"type" : "char*",
"line" : 139}
,
{
"name" : "strError",
"kind" : "variable",
"protection" : "public",
"type" : "char*",
"line" : 140}
,
{
"name" : "ChildWatch",
"kind" : "alias",
"protection" : "public",
"type" : "bool delegate(Spawn)",
"line" : 142}
,
{
"name" : "externalWatch",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(Spawn)",
"line" : 143}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Spawn(string program, string[] envp = null)",
"comment" : "\n Creates a Spawn for execution.\n\t \n",
"line" : 148}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Spawn(string[] program, string[] envp = null)",
"comment" : "\n Creates a Spawn for execution.\n\t \n",
"line" : 157}
,
{
"name" : "addChildWatch",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate(Spawn) dlg)",
"comment" : "\n Adds a delegate to be notified on the end of the child process.\n Params:\n    \tdlg =\n\t \n",
"line" : 168}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Closes all open streams and child process.\n\t \n",
"line" : 176}
,
{
"name" : "addParm",
"kind" : "function",
"protection" : "public",
"type" : "void(string parm)",
"comment" : "\n Adds a parameter to the execution program\n\t \n",
"line" : 203}
,
{
"name" : "getLastError",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the last error message\n\t \n",
"line" : 211}
,
{
"name" : "execAsyncWithPipes",
"kind" : "function",
"protection" : "public",
"type" : "int(bool delegate(Spawn) externalWatch = null, bool delegate(string) readOutput = null, bool delegate(string) readError = null)",
"comment" : "\n Executes the prepared process\n\t \n",
"line" : 223}
,
{
"name" : "ReadFile",
"kind" : "class",
"protection" : "public",
"line" : 263,
"base" : "Thread",
"members" : [
{
"name" : "read",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate(string)",
"line" : 265}
,
{
"name" : "file",
"kind" : "variable",
"protection" : "public",
"type" : "shared(_iobuf)*",
"line" : 266}
,
{
"name" : "lineCount",
"kind" : "variable",
"protection" : "public",
"type" : "int",
"line" : 268}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ReadFile(shared(_iobuf)* file, bool delegate(string) read)",
"line" : 270}
,
{
"name" : "run",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"line" : 283}
,
{
"name" : "this",
"kind" : "variable",
"protection" : "public",
"type" : "glib.Spawn.Spawn",
"line" : 263}
]
}
,
{
"name" : "readLine",
"kind" : "function",
"protection" : "private",
"type" : "string(shared(_iobuf)* stream, int max = 4096)",
"line" : 318}
,
{
"name" : "childWatchCallback",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) void(int pid, int status, Spawn spawn)",
"line" : 346}
,
{
"name" : "endOfOutput",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 358}
,
{
"name" : "endOfError",
"kind" : "function",
"protection" : "public",
"type" : "bool()",
"line" : 364}
,
{
"name" : "getOutputString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 370}
,
{
"name" : "getErrorString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"line" : 375}
,
{
"name" : "getExitStatus",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"line" : 380}
,
{
"name" : "commandLineSync",
"kind" : "function",
"protection" : "public",
"type" : "int(bool delegate(Spawn) externalWatch = null, bool delegate(string) readOutput = null, bool delegate(string) readError = null)",
"comment" : "\n Executes a command synchronasly and\n optionally calls delegates for sysout, syserr and end of job\n\n\t \n",
"line" : 390}
,
{
"name" : "async",
"kind" : "function",
"protection" : "public",
"type" : "int(string workingDirectory, string[] argv, string[] envp, GSpawnFlags flags, extern (C) void function(void* cbData) childSetup, void* userData, int* childPid)",
"comment" : "\n\t \n\n See g_spawn_async_with_pipes() for a full description; this function\n simply calls the g_spawn_async_with_pipes() without any pipes.\n You should call g_spawn_close_pid() on the returned child process\n reference when you don't need it any more.\n Note\n If you are writing a GTK+ application, and the program you\n are spawning is a graphical application, too, then you may\n want to use gdk_spawn_on_screen() instead to ensure that\n the spawned program opens its windows on the right screen.\n Note\n  Note that the returned child_pid on Windows is a\n handle to the child process and not its identifier. Process handles\n and process identifiers are different concepts on Windows.\n Params:\n workingDirectory = child's current working directory, or NULL to inherit parent's\n argv = child's argument vector\n envp = child's environment, or NULL to inherit parent's\n flags = flags from GSpawnFlags\n childSetup = function to run in the child just before exec()\n userData = user data for child_setup\n childPid = return location for child process reference, or NULL\n Returns: TRUE on success, FALSE if error is set\n Throws: GException on failure.\n\t \n",
"line" : 459}
,
{
"name" : "sync",
"kind" : "function",
"protection" : "public",
"type" : "int(string workingDirectory, string[] argv, string[] envp, GSpawnFlags flags, extern (C) void function(void* cbData) childSetup, void* userData, out string standardOutput, out string standardError, out int exitStatus)",
"comment" : "\n Executes a child synchronously (waits for the child to exit before returning).\n All output from the child is stored in standard_output and standard_error,\n if those parameters are non-NULL. Note that you must set the\n G_SPAWN_STDOUT_TO_DEV_NULL and G_SPAWN_STDERR_TO_DEV_NULL flags when\n passing NULL for standard_output and standard_error.\n If exit_status is non-NULL, the exit status of the child is stored\n there as it would be returned by waitpid(); standard UNIX macros such\n as WIFEXITED() and WEXITSTATUS() must be used to evaluate the exit status.\n Note that this function call waitpid() even if exit_status is NULL, and\n does not accept the G_SPAWN_DO_NOT_REAP_CHILD flag.\n If an error occurs, no data is returned in standard_output,\n standard_error, or exit_status.\n This function calls g_spawn_async_with_pipes() internally; see that\n function for full details on the other parameters and details on\n how these functions work on Windows.\n Params:\n workingDirectory = child's current working directory, or NULL to inherit parent's\n argv = child's argument vector\n envp = child's environment, or NULL to inherit parent's\n flags = flags from GSpawnFlags\n childSetup = function to run in the child just before exec()\n userData = user data for child_setup\n standardOutput = return location for child output, or NULL\n standardError = return location for child error messages, or NULL\n exitStatus = return location for child exit status, as returned by waitpid(), or NULL\n Returns: TRUE on success, FALSE if an error was set.\n\t \n",
"line" : 502}
,
{
"name" : "commandLineAsync",
"kind" : "function",
"protection" : "public",
"type" : "int(string commandLine)",
"comment" : "\n A simple version of g_spawn_async() that parses a command line with\n g_shell_parse_argv() and passes it to g_spawn_async(). Runs a\n command line in the background. Unlike g_spawn_async(), the\n G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note\n that G_SPAWN_SEARCH_PATH can have security implications, so\n consider using g_spawn_async() directly if appropriate. Possible\n errors are those from g_shell_parse_argv() and g_spawn_async().\n The same concerns on Windows apply as for g_spawn_command_line_sync().\n Params:\n commandLine = a command line\n Returns: TRUE on success, FALSE if error is set.\n Throws: GException on failure.\n\t \n",
"line" : 535}
,
{
"name" : "commandLineSync",
"kind" : "function",
"protection" : "public",
"type" : "int(string commandLine, out string standardOutput, out string standardError, out int exitStatus)",
"comment" : "\n A simple version of g_spawn_sync() with little-used parameters\n removed, taking a command line instead of an argument vector. See\n g_spawn_sync() for full details. command_line will be parsed by\n g_shell_parse_argv(). Unlike g_spawn_sync(), the G_SPAWN_SEARCH_PATH flag\n is enabled. Note that G_SPAWN_SEARCH_PATH can have security\n implications, so consider using g_spawn_sync() directly if\n appropriate. Possible errors are those from g_spawn_sync() and those\n from g_shell_parse_argv().\n If exit_status is non-NULL, the exit status of the child is stored there as\n it would be returned by waitpid(); standard UNIX macros such as WIFEXITED()\n and WEXITSTATUS() must be used to evaluate the exit status.\n On Windows, please note the implications of g_shell_parse_argv()\n parsing command_line. Parsing is done according to Unix shell rules, not\n Windows command interpreter rules.\n Space is a separator, and backslashes are\n special. Thus you cannot simply pass a command_line containing\n canonical Windows paths, like \"c:\\\\program files\\\\app\\\\app.exe\", as\n the backslashes will be eaten, and the space will act as a\n separator. You need to enclose such paths with single quotes, like\n \"'c:\\\\program files\\\\app\\\\app.exe' 'e:\\\\folder\\\\argument.txt'\".\n Params:\n commandLine = a command line\n standardOutput = return location for child output\n standardError = return location for child errors\n exitStatus = return location for child exit status, as returned by waitpid()\n Returns: TRUE on success, FALSE if an error was set\n\t \n",
"line" : 578}
,
{
"name" : "closePid",
"kind" : "function",
"protection" : "public",
"type" : "void(int pid)",
"comment" : "\n On some platforms, notably Windows, the GPid type represents a resource\n which must be closed to prevent resource leaking. g_spawn_close_pid()\n is provided for this purpose. It should be used on all platforms, even\n though it doesn't do anything under UNIX.\n Params:\n pid = The process reference to close\n\t \n",
"line" : 605}
]
}
]
}
,
{
"name" : "glib.Str",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Str.d",
"members" : [
{
"name" : "Str",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This section describes a number of utility functions for creating,\n duplicating, and manipulating strings.\n Note that the functions g_printf(), g_fprintf(), g_sprintf(), g_snprintf(),\n g_vprintf(), g_vfprintf(), g_vsprintf() and g_vsnprintf() are declared in\n the header gprintf.h which is not\n included in glib.h (otherwise using\n glib.h would drag in stdio.h), so\n you'll have to explicitly include <glib\/gprintf.h>\n in order to use the GLib printf() functions.\n While you may use the printf() functions to format UTF-8 strings, notice that\n the precision of a %Ns parameter is interpreted as the\n number of bytes, not characters to print.\n On top of that, the GNU libc implementation of the printf() functions has the \"feature\"\n that it checks that the string given for the %Ns parameter\n consists of a whole number of characters in the current encoding. So, unless you\n are sure you are always going to be in an UTF-8 locale or your know your text is restricted\n to ASCII, avoid using %Ns.\n If your intention is to format strings for a certain number of columns, then\n %Ns is not a correct solution anyway, since it fails to take\n wide characters (see g_unichar_iswide()) into account.\n \n",
"line" : 107,
"base" : "Object",
"members" : [
{
"name" : "digits",
"kind" : "variable",
"protection" : "public",
"type" : "const(char[10LU])",
"comment" : " 0..9\n",
"line" : 109}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(char* s, ulong len = cast(ulong)0)",
"comment" : "\n Convert C-style 0 terminated string s to char[] string.\n copied from phobos\n\t \n",
"line" : 115}
,
{
"name" : "toStringz",
"kind" : "function",
"protection" : "public",
"type" : "char*(string s)",
"comment" : "\n Convert array of chars s[] to a C-style 0 terminated string.\n copied from phobos\n\t \n",
"line" : 133}
,
{
"name" : "toStringzArray",
"kind" : "function",
"protection" : "public",
"type" : "char**(string[] args)",
"comment" : " \n",
"line" : 167}
,
{
"name" : "toStringArray",
"kind" : "function",
"protection" : "public",
"type" : "string[](char** args)",
"comment" : " \n",
"line" : 185}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(bool b)",
"comment" : " \n",
"line" : 206}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "char[](char c)",
"comment" : " \n",
"line" : 212}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(ubyte ub)",
"comment" : " ditto\n \n",
"line" : 221}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(ushort us)",
"comment" : " ditto\n \n",
"line" : 223}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(uint u)",
"comment" : " \n",
"line" : 226}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(ulong u)",
"comment" : " \n",
"line" : 267}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(byte b)",
"comment" : " ditto\n \n",
"line" : 300}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(short s)",
"comment" : " ditto\n \n",
"line" : 302}
,
{
"name" : "toString",
"kind" : "function",
"protection" : "public",
"type" : "string(int i)",
"comment" : " \n",
"line" : 305}
,
{
"name" : "strdup",
"kind" : "function",
"protection" : "public",
"type" : "string(string str)",
"comment" : "\n\t \n\n Duplicates a string. If str is NULL it returns NULL.\n The returned string should be freed with g_free()\n when no longer needed.\n Params:\n str = the string to duplicate\n Returns: a newly-allocated copy of str\n\t \n",
"line" : 349}
,
{
"name" : "strndup",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, ulong n)",
"comment" : "\n Duplicates the first n bytes of a string, returning a newly-allocated\n buffer n + 1 bytes long which will always be nul-terminated.\n If str is less than n bytes long the buffer is padded with nuls.\n If str is NULL it returns NULL.\n The returned value should be freed when no longer needed.\n Note\n To copy a number of characters from a UTF-8 encoded string, use\n g_utf8_strncpy() instead.\n Params:\n str = the string to duplicate\n n = the maximum number of bytes to copy from str\n Returns: a newly-allocated buffer containing the first n bytes of str, nul-terminated\n\t \n",
"line" : 369}
,
{
"name" : "strdupv",
"kind" : "function",
"protection" : "public",
"type" : "string[](string[] strArray)",
"comment" : "\n Copies NULL-terminated array of strings. The copy is a deep copy;\n the new array should be freed by first freeing each string, then\n the array itself. g_strfreev() does this for you. If called\n on a NULL value, g_strdupv() simply returns NULL.\n Params:\n strArray = NULL-terminated array of strings.\n Returns: a new NULL-terminated array of strings.\n\t \n",
"line" : 384}
,
{
"name" : "strnfill",
"kind" : "function",
"protection" : "public",
"type" : "string(ulong length, char fillChar)",
"comment" : "\n Creates a new string length bytes long filled with fill_char.\n The returned string should be freed when no longer needed.\n Params:\n length = the length of the new string\n fillChar = the byte to fill the string with\n Returns: a newly-allocated string filled the fill_char\n\t \n",
"line" : 398}
,
{
"name" : "stpcpy",
"kind" : "function",
"protection" : "public",
"type" : "string(string dest, string src)",
"comment" : "\n Copies a nul-terminated string into the dest buffer, include the\n trailing nul, and return a pointer to the trailing nul byte.\n This is useful for concatenating multiple strings together\n without having to repeatedly scan for the end.\n Params:\n dest = destination buffer.\n src = source string.\n Returns: a pointer to trailing nul byte.\n\t \n",
"line" : 414}
,
{
"name" : "strstrLen",
"kind" : "function",
"protection" : "public",
"type" : "string(string haystack, long haystackLen, string needle)",
"comment" : "\n Searches the string haystack for the first occurrence\n of the string needle, limiting the length of the search\n to haystack_len.\n Params:\n haystack = a string.\n haystackLen = the maximum length of haystack. Note that -1 is\n a valid length, if haystack is nul-terminated, meaning it will\n search through the whole string.\n needle = the string to search for.\n Returns: a pointer to the found occurrence, or NULL if not found.\n\t \n",
"line" : 432}
,
{
"name" : "strrstr",
"kind" : "function",
"protection" : "public",
"type" : "string(string haystack, string needle)",
"comment" : "\n Searches the string haystack for the last occurrence\n of the string needle.\n Params:\n haystack = a nul-terminated string.\n needle = the nul-terminated string to search for.\n Returns: a pointer to the found occurrence, or NULL if not found.\n\t \n",
"line" : 446}
,
{
"name" : "strrstrLen",
"kind" : "function",
"protection" : "public",
"type" : "string(string haystack, long haystackLen, string needle)",
"comment" : "\n Searches the string haystack for the last occurrence\n of the string needle, limiting the length of the search\n to haystack_len.\n Params:\n haystack = a nul-terminated string.\n haystackLen = the maximum length of haystack.\n needle = the nul-terminated string to search for.\n Returns: a pointer to the found occurrence, or NULL if not found.\n\t \n",
"line" : 462}
,
{
"name" : "strHasPrefix",
"kind" : "function",
"protection" : "public",
"type" : "int(string str, string prefix)",
"comment" : "\n Looks whether the string str begins with prefix.\n Since 2.2\n Params:\n str = a nul-terminated string.\n prefix = the nul-terminated prefix to look for.\n Returns: TRUE if str begins with prefix, FALSE otherwise.\n\t \n",
"line" : 476}
,
{
"name" : "strHasSuffix",
"kind" : "function",
"protection" : "public",
"type" : "int(string str, string suffix)",
"comment" : "\n Looks whether the string str ends with suffix.\n Since 2.2\n Params:\n str = a nul-terminated string.\n suffix = the nul-terminated suffix to look for.\n Returns: TRUE if str end with suffix, FALSE otherwise.\n\t \n",
"line" : 490}
,
{
"name" : "strcmp0",
"kind" : "function",
"protection" : "public",
"type" : "int(string str1, string str2)",
"comment" : "\n Compares str1 and str2 like strcmp(). Handles NULL\n gracefully by sorting it before non-NULL strings.\n Comparing two NULL pointers returns 0.\n Since 2.16\n Params:\n str1 = a C string or NULL\n str2 = another C string or NULL\n Returns: -1, 0 or 1, if str1 is <, == or > than str2.\n\t \n",
"line" : 506}
,
{
"name" : "strlcpy",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string dest, string src, ulong destSize)",
"comment" : "\n Portability wrapper that calls strlcpy() on systems which have it,\n and emulates strlcpy() otherwise. Copies src to dest; dest is\n guaranteed to be nul-terminated; src must be nul-terminated;\n dest_size is the buffer size, not the number of chars to copy.\n At most dest_size - 1 characters will be copied. Always nul-terminates\n (unless dest_size == 0). This function does not\n allocate memory. Unlike strncpy(), this function doesn't pad dest (so\n it's often faster). It returns the size of the attempted result,\n strlen (src), so if retval >= dest_size, truncation occurred.\n Note\n Caveat: strlcpy() is supposedly more secure than\n strcpy() or strncpy(), but if you really want to avoid screwups,\n g_strdup() is an even better idea.\n Params:\n dest = destination buffer\n src = source buffer\n destSize = length of dest in bytes\n Returns: length of src\n\t \n",
"line" : 532}
,
{
"name" : "strlcat",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string dest, string src, ulong destSize)",
"comment" : "\n Portability wrapper that calls strlcat() on systems which have it,\n and emulates it otherwise. Appends nul-terminated src string to dest,\n guaranteeing nul-termination for dest. The total size of dest won't\n exceed dest_size.\n At most dest_size - 1 characters will be copied.\n Unlike strncat, dest_size is the full size of dest, not the space left over.\n This function does NOT allocate memory.\n This always NUL terminates (unless siz == 0 or there were no NUL characters\n in the dest_size characters of dest to start with).\n Note\n Caveat: this is supposedly a more secure alternative to\n strcat() or strncat(), but for real security g_strconcat() is harder\n to mess up.\n Params:\n dest = destination buffer, already containing one nul-terminated string\n src = source buffer\n destSize = length of dest buffer in bytes (not length of existing string\n  inside dest)\n Returns: size of attempted result, which is MIN (dest_size, strlen (original dest)) + strlen (src), so if retval >= dest_size, truncation occurred.\n\t \n",
"line" : 559}
,
{
"name" : "strdupVprintf",
"kind" : "function",
"protection" : "public",
"type" : "string(string format, void* args)",
"comment" : "\n Similar to the standard C vsprintf() function but safer, since it\n calculates the maximum space required and allocates memory to hold\n the result. The returned string should be freed with g_free() when\n no longer needed.\n See also g_vasprintf(), which offers the same functionality, but\n additionally returns the length of the allocated string.\n Params:\n format = a standard printf() format string, but notice\n  string precision pitfalls\n args = the list of parameters to insert into the format string\n Returns: a newly-allocated string holding the result\n\t \n",
"line" : 578}
,
{
"name" : "vprintf",
"kind" : "function",
"protection" : "public",
"type" : "int(string format, void* args)",
"comment" : "\n An implementation of the standard vprintf() function which supports\n positional parameters, as specified in the Single Unix Specification.\n Since 2.2\n Params:\n format = a standard printf() format string, but notice\n  string precision pitfalls.\n args = the list of arguments to insert in the output.\n Returns: the number of bytes printed.\n\t \n",
"line" : 594}
,
{
"name" : "vfprintf",
"kind" : "function",
"protection" : "public",
"type" : "int(shared(_iobuf)* file, string format, void* args)",
"comment" : "\n An implementation of the standard fprintf() function which supports\n positional parameters, as specified in the Single Unix Specification.\n Since 2.2\n Params:\n file = the stream to write to.\n format = a standard printf() format string, but notice\n  string precision pitfalls.\n args = the list of arguments to insert in the output.\n Returns: the number of bytes printed.\n\t \n",
"line" : 611}
,
{
"name" : "vsprintf",
"kind" : "function",
"protection" : "public",
"type" : "int(string string, string format, void* args)",
"comment" : "\n An implementation of the standard vsprintf() function which supports\n positional parameters, as specified in the Single Unix Specification.\n Since 2.2\n Params:\n string = the buffer to hold the output.\n format = a standard printf() format string, but notice\n  string precision pitfalls.\n args = the list of arguments to insert in the output.\n Returns: the number of bytes printed.\n\t \n",
"line" : 628}
,
{
"name" : "vsnprintf",
"kind" : "function",
"protection" : "public",
"type" : "int(string string, ulong n, string format, void* args)",
"comment" : "\n A safer form of the standard vsprintf() function. The output is guaranteed\n to not exceed n characters (including the terminating nul character), so\n it is easy to ensure that a buffer overflow cannot occur.\n See also g_strdup_vprintf().\n In versions of GLib prior to 1.2.3, this function may return -1 if the\n output was truncated, and the truncated string may not be nul-terminated.\n In versions prior to 1.3.12, this function returns the length of the output\n string.\n The return value of g_vsnprintf() conforms to the vsnprintf() function\n as standardized in ISO C99. Note that this is different from traditional\n vsnprintf(), which returns the length of the output string.\n The format string may contain positional parameters, as specified in\n the Single Unix Specification.\n Params:\n string = the buffer to hold the output.\n n = the maximum number of bytes to produce (including the\n  terminating nul character).\n format = a standard printf() format string, but notice\n  string precision pitfalls.\n args = the list of arguments to insert in the output.\n Returns: the number of bytes which would be produced if the buffer was large enough.\n\t \n",
"line" : 657}
,
{
"name" : "vasprintf",
"kind" : "function",
"protection" : "public",
"type" : "int(out string string, string format, void* args)",
"comment" : "\n An implementation of the GNU vasprintf() function which supports\n positional parameters, as specified in the Single Unix Specification.\n This function is similar to g_vsprintf(), except that it allocates a\n string to hold the output, instead of putting the output in a buffer\n you allocate in advance.\n Since 2.4\n Params:\n string = the return location for the newly-allocated string.\n format = a standard printf() format string, but notice\n  string precision pitfalls.\n args = the list of arguments to insert in the output.\n Returns: the number of bytes printed.\n\t \n",
"line" : 677}
,
{
"name" : "printfStringUpperBound",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string format, void* args)",
"comment" : "\n Calculates the maximum space needed to store the output of the sprintf()\n function.\n Params:\n format = the format string. See the printf() documentation.\n args = the parameters to be inserted into the format string.\n Returns: the maximum space needed to store the formatted string.\n\t \n",
"line" : 696}
,
{
"name" : "asciiIsalnum",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is alphanumeric.\n Unlike the standard C library isalnum() function, this only\n recognizes standard ASCII letters and ignores the locale, returning\n FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII alphanumeric character\n\t \n",
"line" : 714}
,
{
"name" : "asciiIsalpha",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is alphabetic (i.e. a letter).\n Unlike the standard C library isalpha() function, this only\n recognizes standard ASCII letters and ignores the locale, returning\n FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII alphabetic character\n\t \n",
"line" : 732}
,
{
"name" : "asciiIscntrl",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is a control character.\n Unlike the standard C library iscntrl() function, this only\n recognizes standard ASCII control characters and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII control character.\n\t \n",
"line" : 750}
,
{
"name" : "asciiIsdigit",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is digit (0-9).\n Unlike the standard C library isdigit() function,\n this takes a char, not an int, so don't call it\n on EOF but no need to cast to guchar before passing a possibly\n non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII digit.\n\t \n",
"line" : 766}
,
{
"name" : "asciiIsgraph",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is a printing character and not a space.\n Unlike the standard C library isgraph() function,\n this only recognizes standard ASCII characters and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII printing character other than space.\n\t \n",
"line" : 784}
,
{
"name" : "asciiIslower",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is an ASCII lower case letter.\n Unlike the standard C library islower() function,\n this only recognizes standard ASCII letters and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to worry about casting to guchar\n before passing a possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII lower case letter\n\t \n",
"line" : 802}
,
{
"name" : "asciiIsprint",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is a printing character.\n Unlike the standard C library isprint() function,\n this only recognizes standard ASCII characters and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII printing character.\n\t \n",
"line" : 820}
,
{
"name" : "asciiIspunct",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is a punctuation character.\n Unlike the standard C library ispunct() function,\n this only recognizes standard ASCII letters and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII punctuation character.\n\t \n",
"line" : 838}
,
{
"name" : "asciiIsspace",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is a white-space character.\n Unlike the standard C library isspace() function,\n this only recognizes standard ASCII white-space and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII white-space character\n\t \n",
"line" : 856}
,
{
"name" : "asciiIsupper",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is an ASCII upper case letter.\n Unlike the standard C library isupper() function,\n this only recognizes standard ASCII letters and ignores the locale,\n returning FALSE for all non-ASCII characters. Also unlike the standard\n library function, this takes a char, not an int,\n so don't call it on EOF but no need to worry about casting to guchar\n before passing a possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII upper case letter\n\t \n",
"line" : 874}
,
{
"name" : "asciiIsxdigit",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines whether a character is a hexadecimal-digit character.\n Unlike the standard C library isxdigit() function,\n this takes a char, not an int, so\n don't call it on EOF but no need to cast to guchar before passing a\n possibly non-ASCII character in.\n Params:\n c = any character\n Returns: TRUE if c is an ASCII hexadecimal-digit character.\n\t \n",
"line" : 890}
,
{
"name" : "asciiDigitValue",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines the numeric value of a character as a decimal\n digit. Differs from g_unichar_digit_value() because it takes\n a char, so there's no worry about sign extension if characters\n are signed.\n Params:\n c = an ASCII character.\n Returns: If c is a decimal digit (according to g_ascii_isdigit()), its numeric value. Otherwise, -1.\n\t \n",
"line" : 905}
,
{
"name" : "asciiXdigitValue",
"kind" : "function",
"protection" : "public",
"type" : "int(char c)",
"comment" : "\n Determines the numeric value of a character as a hexidecimal\n digit. Differs from g_unichar_xdigit_value() because it takes\n a char, so there's no worry about sign extension if characters\n are signed.\n Params:\n c = an ASCII character.\n Returns: If c is a hex digit (according to g_ascii_isxdigit()), its numeric value. Otherwise, -1.\n\t \n",
"line" : 920}
,
{
"name" : "asciiStrcasecmp",
"kind" : "function",
"protection" : "public",
"type" : "int(string s1, string s2)",
"comment" : "\n Compare two strings, ignoring the case of ASCII characters.\n Unlike the BSD strcasecmp() function, this only recognizes standard\n ASCII letters and ignores the locale, treating all non-ASCII\n bytes as if they are not letters.\n This function should be used only on strings that are known to be\n in encodings where the bytes corresponding to ASCII letters always\n represent themselves. This includes UTF-8 and the ISO-8859-*\n charsets, but not for instance double-byte encodings like the\n Windows Codepage 932, where the trailing bytes of double-byte\n characters include all ASCII letters. If you compare two CP932\n strings using this function, you will get false matches.\n Params:\n s1 = string to compare with s2.\n s2 = string to compare with s1.\n Returns: 0 if the strings match, a negative value if s1 < s2, or a positive value if s1 > s2.\n\t \n",
"line" : 943}
,
{
"name" : "asciiStrncasecmp",
"kind" : "function",
"protection" : "public",
"type" : "int(string s1, string s2, ulong n)",
"comment" : "\n Compare s1 and s2, ignoring the case of ASCII characters and any\n characters after the first n in each string.\n Unlike the BSD strcasecmp() function, this only recognizes standard\n ASCII letters and ignores the locale, treating all non-ASCII\n characters as if they are not letters.\n The same warning as in g_ascii_strcasecmp() applies: Use this\n function only on strings known to be in encodings where bytes\n corresponding to ASCII letters always represent themselves.\n Params:\n s1 = string to compare with s2.\n s2 = string to compare with s1.\n n = number of characters to compare.\n Returns: 0 if the strings match, a negative value if s1 < s2, or a positive value if s1 > s2.\n\t \n",
"line" : 964}
,
{
"name" : "asciiStrup",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts all lower case ASCII letters to upper case ASCII letters.\n Params:\n str = a string.\n len = length of str in bytes, or -1 if str is nul-terminated.\n Returns: a newly allocated string, with all the lower case characters in str converted to upper case, with semantics that exactly match g_ascii_toupper(). (Note that this is unlike the old g_strup(), which modified the string in place.)\n\t \n",
"line" : 977}
,
{
"name" : "asciiStrdown",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts all upper case ASCII letters to lower case ASCII letters.\n Params:\n str = a string.\n len = length of str in bytes, or -1 if str is nul-terminated.\n Returns: a newly-allocated string, with all the upper case characters in str converted to lower case, with semantics that exactly match g_ascii_tolower(). (Note that this is unlike the old g_strdown(), which modified the string in place.)\n\t \n",
"line" : 990}
,
{
"name" : "asciiTolower",
"kind" : "function",
"protection" : "public",
"type" : "char(char c)",
"comment" : "\n Convert a character to ASCII lower case.\n Unlike the standard C library tolower() function, this only\n recognizes standard ASCII letters and ignores the locale, returning\n all non-ASCII characters unchanged, even if they are lower case\n letters in a particular character set. Also unlike the standard\n library function, this takes and returns a char, not an int, so\n don't call it on EOF but no need to worry about casting to guchar\n before passing a possibly non-ASCII character in.\n Params:\n c = any character.\n Returns: the result of converting c to lower case. If c is not an ASCII upper case letter, c is returned unchanged.\n\t \n",
"line" : 1009}
,
{
"name" : "asciiToupper",
"kind" : "function",
"protection" : "public",
"type" : "char(char c)",
"comment" : "\n Convert a character to ASCII upper case.\n Unlike the standard C library toupper() function, this only\n recognizes standard ASCII letters and ignores the locale, returning\n all non-ASCII characters unchanged, even if they are upper case\n letters in a particular character set. Also unlike the standard\n library function, this takes and returns a char, not an int, so\n don't call it on EOF but no need to worry about casting to guchar\n before passing a possibly non-ASCII character in.\n Params:\n c = any character.\n Returns: the result of converting c to upper case. If c is not an ASCII lower case letter, c is returned unchanged.\n\t \n",
"line" : 1028}
,
{
"name" : "stringAsciiUp",
"kind" : "function",
"protection" : "public",
"type" : "StringG(StringG string)",
"comment" : "\n Converts all lower case ASCII letters to upper case ASCII letters.\n Params:\n string = a GString\n Returns: passed-in string pointer, with all the lower case characters converted to upper case in place, with semantics that exactly match g_ascii_toupper().\n\t \n",
"line" : 1040}
,
{
"name" : "stringAsciiDown",
"kind" : "function",
"protection" : "public",
"type" : "StringG(StringG string)",
"comment" : "\n Converts all upper case ASCII letters to lower case ASCII letters.\n Params:\n string = a GString\n Returns: passed-in string pointer, with all the upper case characters converted to lower case in place, with semantics that exactly match g_ascii_tolower().\n\t \n",
"line" : 1057}
,
{
"name" : "strup",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Warning\n g_strup has been deprecated since version 2.2 and should not be used in newly-written code. This function is totally broken for the reasons discussed\n in the g_strncasecmp() docs - use g_ascii_strup() or g_utf8_strup() instead.\n Converts a string to upper case.\n Params:\n string = the string to convert.\n Returns: the string\n\t \n",
"line" : 1077}
,
{
"name" : "strdown",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Warning\n g_strdown has been deprecated since version 2.2 and should not be used in newly-written code. This function is totally broken for the reasons discussed\n in the g_strncasecmp() docs - use g_ascii_strdown() or g_utf8_strdown()\n instead.\n Converts a string to lower case.\n Params:\n string = the string to convert.\n Returns: the string\n\t \n",
"line" : 1093}
,
{
"name" : "strcasecmp",
"kind" : "function",
"protection" : "public",
"type" : "int(string s1, string s2)",
"comment" : "\n Warning\n g_strcasecmp has been deprecated since version 2.2 and should not be used in newly-written code. See g_strncasecmp() for a discussion of why this function\n  is deprecated and how to replace it.\n A case-insensitive string comparison, corresponding to the standard\n strcasecmp() function on platforms which support it.\n Params:\n s1 = a string.\n s2 = a string to compare with s1.\n Returns: 0 if the strings match, a negative value if s1 < s2, or a positive value if s1 > s2.\n\t \n",
"line" : 1110}
,
{
"name" : "strncasecmp",
"kind" : "function",
"protection" : "public",
"type" : "int(string s1, string s2, uint n)",
"comment" : "\n Warning\n g_strncasecmp has been deprecated since version 2.2 and should not be used in newly-written code. The problem with g_strncasecmp() is that it does the\n comparison by calling toupper()\/tolower(). These functions are\n locale-specific and operate on single bytes. However, it is impossible\n to handle things correctly from an I18N standpoint by operating on\n bytes, since characters may be multibyte. Thus g_strncasecmp() is\n broken if your string is guaranteed to be ASCII, since it's\n locale-sensitive, and it's broken if your string is localized, since\n it doesn't work on many encodings at all, including UTF-8, EUC-JP,\n etc.\n There are therefore two replacement functions: g_ascii_strncasecmp(),\n which only works on ASCII and is not locale-sensitive, and\n g_utf8_casefold(), which is good for case-insensitive sorting of UTF-8.\n A case-insensitive string comparison, corresponding to the standard\n strncasecmp() function on platforms which support it.\n It is similar to g_strcasecmp() except it only compares the first n\n characters of the strings.\n Params:\n s1 = a string.\n s2 = a string to compare with s1.\n n = the maximum number of characters to compare.\n Returns: 0 if the strings match, a negative value if s1 < s2, or a positive value if s1 > s2.\n\t \n",
"line" : 1140}
,
{
"name" : "strreverse",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Reverses all of the bytes in a string. For example,\n g_strreverse (\"abcdef\") will result\n in \"fedcba\".\n Note that g_strreverse() doesn't work on UTF-8 strings\n containing multibyte characters. For that purpose, use\n g_utf8_strreverse().\n Params:\n string = the string to reverse\n Returns: the same pointer passed in as string\n\t \n",
"line" : 1157}
,
{
"name" : "asciiStrtoll",
"kind" : "function",
"protection" : "public",
"type" : "long(string nptr, out string endptr, uint base)",
"comment" : "\n Converts a string to a gint64 value.\n This function behaves like the standard strtoll() function\n does in the C locale. It does this without actually\n changing the current locale, since that would not be\n thread-safe.\n This function is typically used when reading configuration\n files or other non-user input that should be locale independent.\n To handle input from the user you should normally use the\n locale-sensitive system strtoll() function.\n If the correct value would cause overflow, G_MAXINT64 or G_MININT64\n is returned, and ERANGE is stored in errno. If the base is\n outside the valid range, zero is returned, and EINVAL is stored\n in errno. If the string conversion fails, zero is returned, and\n endptr returns nptr (if endptr is non-NULL).\n Since 2.12\n Params:\n nptr = the string to convert to a numeric value.\n endptr = if non-NULL, it returns the character after\n  the last character used in the conversion.\n base = to be used for the conversion, 2..36 or 0\n Returns: the gint64 value or zero on error.\n\t \n",
"line" : 1186}
,
{
"name" : "asciiStrtoull",
"kind" : "function",
"protection" : "public",
"type" : "ulong(string nptr, out string endptr, uint base)",
"comment" : "\n Converts a string to a guint64 value.\n This function behaves like the standard strtoull() function\n does in the C locale. It does this without actually\n changing the current locale, since that would not be\n thread-safe.\n This function is typically used when reading configuration\n files or other non-user input that should be locale independent.\n To handle input from the user you should normally use the\n locale-sensitive system strtoull() function.\n If the correct value would cause overflow, G_MAXUINT64\n is returned, and ERANGE is stored in errno. If the base is\n outside the valid range, zero is returned, and EINVAL is stored\n in errno. If the string conversion fails, zero is returned, and\n endptr returns nptr (if endptr is non-NULL).\n Since 2.2\n Params:\n nptr = the string to convert to a numeric value.\n endptr = if non-NULL, it returns the character after\n  the last character used in the conversion.\n base = to be used for the conversion, 2..36 or 0\n Returns: the guint64 value or zero on error.\n\t \n",
"line" : 1220}
,
{
"name" : "asciiStrtod",
"kind" : "function",
"protection" : "public",
"type" : "double(string nptr, out string endptr)",
"comment" : "\n Converts a string to a gdouble value.\n This function behaves like the standard strtod() function\n does in the C locale. It does this without actually changing\n the current locale, since that would not be thread-safe.\n A limitation of the implementation is that this function\n will still accept localized versions of infinities and NANs.\n This function is typically used when reading configuration\n files or other non-user input that should be locale independent.\n To handle input from the user you should normally use the\n locale-sensitive system strtod() function.\n To convert from a gdouble to a string in a locale-insensitive\n way, use g_ascii_dtostr().\n If the correct value would cause overflow, plus or minus HUGE_VAL\n is returned (according to the sign of the value), and ERANGE is\n stored in errno. If the correct value would cause underflow,\n zero is returned and ERANGE is stored in errno.\n This function resets errno before calling strtod() so that\n you can reliably detect overflow and underflow.\n Params:\n nptr = the string to convert to a numeric value.\n endptr = if non-NULL, it returns the character after\n  the last character used in the conversion.\n Returns: the gdouble value.\n\t \n",
"line" : 1256}
,
{
"name" : "asciiDtostr",
"kind" : "function",
"protection" : "public",
"type" : "string(string buffer, int bufLen, double d)",
"comment" : "\n Converts a gdouble to a string, using the '.' as\n decimal point.\n This functions generates enough precision that converting\n the string back using g_ascii_strtod() gives the same machine-number\n (on machines with IEEE compatible 64bit doubles). It is\n guaranteed that the size of the resulting string will never\n be larger than G_ASCII_DTOSTR_BUF_SIZE bytes.\n Params:\n buffer = A buffer to place the resulting string in\n bufLen = The length of the buffer.\n d = The gdouble to convert\n Returns: The pointer to the buffer with the converted string.\n\t \n",
"line" : 1281}
,
{
"name" : "asciiFormatd",
"kind" : "function",
"protection" : "public",
"type" : "string(string buffer, int bufLen, string format, double d)",
"comment" : "\n Converts a gdouble to a string, using the '.' as\n decimal point. To format the number you pass in\n a printf()-style format string. Allowed conversion\n specifiers are 'e', 'E', 'f', 'F', 'g' and 'G'.\n If you just want to want to serialize the value into a\n string, use g_ascii_dtostr().\n Params:\n buffer = A buffer to place the resulting string in\n bufLen = The length of the buffer.\n format = The printf()-style format to use for the\n  code to use for converting.\n d = The gdouble to convert\n Returns: The pointer to the buffer with the converted string.\n\t \n",
"line" : 1302}
,
{
"name" : "strtod",
"kind" : "function",
"protection" : "public",
"type" : "double(string nptr, out string endptr)",
"comment" : "\n Converts a string to a gdouble value.\n It calls the standard strtod() function to handle the conversion, but\n if the string is not completely converted it attempts the conversion\n again with g_ascii_strtod(), and returns the best match.\n This function should seldomly be used. The normal situation when reading\n numbers not for human consumption is to use g_ascii_strtod(). Only when\n you know that you must expect both locale formatted and C formatted numbers\n should you use this. Make sure that you don't pass strings such as comma\n separated lists of values, since the commas may be interpreted as a decimal\n point in some locales, causing unexpected results.\n Params:\n nptr = the string to convert to a numeric value.\n endptr = if non-NULL, it returns the character after\n  the last character used in the conversion.\n Returns: the gdouble value.\n\t \n",
"line" : 1325}
,
{
"name" : "strchug",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Removes leading whitespace from a string, by moving the rest of the\n characters forward.\n This function doesn't allocate or reallocate any memory; it modifies string\n in place. The pointer to string is returned to allow the nesting of functions.\n Also see g_strchomp() and g_strstrip().\n Params:\n string = a string to remove the leading whitespace from.\n Returns: string.\n\t \n",
"line" : 1346}
,
{
"name" : "strchomp",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Removes trailing whitespace from a string.\n This function doesn't allocate or reallocate any memory; it modifies string in\n place. The pointer to string is returned to allow the nesting of functions.\n Also see g_strchug() and g_strstrip().\n Params:\n string = a string to remove the trailing whitespace from.\n Returns: string.\n\t \n",
"line" : 1361}
,
{
"name" : "strdelimit",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, string delimiters, char newDelimiter)",
"comment" : "\n Converts any delimiter characters in string to new_delimiter.\n Any characters in string which are found in delimiters are changed\n to the new_delimiter character. Modifies string in place, and returns\n string itself, not a copy. The return value is to allow nesting such as\n g_ascii_strup (g_strdelimit (str, \"abc\", '?')).\n Params:\n string = the string to convert.\n delimiters = a string containing the current delimiters, or NULL to use the\n standard delimiters defined in G_STR_DELIMITERS.\n newDelimiter = the new delimiter character.\n Returns: string.\n\t \n",
"line" : 1380}
,
{
"name" : "strescape",
"kind" : "function",
"protection" : "public",
"type" : "string(string source, string exceptions)",
"comment" : "\n Escapes the special characters '\\b', '\\f', '\\n', '\\r', '\\t', '\\' and\n '\"' in the string source by inserting a '\\' before\n them. Additionally all characters in the range 0x01-0x1F (everything\n below SPACE) and in the range 0x7F-0xFF (all non-ASCII chars) are\n replaced with a '\\' followed by their octal representation. Characters\n supplied in exceptions are not escaped.\n g_strcompress() does the reverse conversion.\n Params:\n source = a string to escape.\n exceptions = a string of characters not to escape in source.\n Returns: a newly-allocated copy of source with certain characters escaped. See above.\n\t \n",
"line" : 1399}
,
{
"name" : "strcompress",
"kind" : "function",
"protection" : "public",
"type" : "string(string source)",
"comment" : "\n Replaces all escaped characters with their one byte equivalent. It\n does the reverse conversion of g_strescape().\n Params:\n source = a string to compress.\n Returns: a newly-allocated copy of source with all escaped character compressed.\n\t \n",
"line" : 1412}
,
{
"name" : "strcanon",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, string validChars, char substitutor)",
"comment" : "\n For each character in string, if the character is not in valid_chars,\n replaces the character with substitutor. Modifies string in place,\n and return string itself, not a copy. The return value is to allow\n nesting such as g_ascii_strup (g_strcanon (str, \"abc\", '?')).\n Params:\n string = a nul-terminated array of bytes.\n validChars = bytes permitted in string.\n substitutor = replacement character for disallowed bytes.\n Returns: string.\n\t \n",
"line" : 1429}
,
{
"name" : "strsplit",
"kind" : "function",
"protection" : "public",
"type" : "string[](string string, string delimiter, int maxTokens)",
"comment" : "\n Splits a string into a maximum of max_tokens pieces, using the given\n delimiter. If max_tokens is reached, the remainder of string is appended\n to the last token.\n As a special case, the result of splitting the empty string \"\" is an empty\n vector, not a vector containing a single string. The reason for this\n special case is that being able to represent a empty vector is typically\n more useful than consistent handling of empty elements. If you do need\n to represent empty elements, you'll need to check for the empty string\n before calling g_strsplit().\n Params:\n string = a string to split.\n delimiter = a string which specifies the places at which to split the string.\n  The delimiter is not included in any of the resulting strings, unless\n  max_tokens is reached.\n maxTokens = the maximum number of pieces to split string into. If this is\n  less than 1, the string is split completely.\n Returns: a newly-allocated NULL-terminated array of strings. Use g_strfreev() to free it.\n\t \n",
"line" : 1454}
,
{
"name" : "strsplitSet",
"kind" : "function",
"protection" : "public",
"type" : "string[](string string, string delimiters, int maxTokens)",
"comment" : "\n Splits string into a number of tokens not containing any of the characters\n in delimiter. A token is the (possibly empty) longest string that does not\n contain any of the characters in delimiters. If max_tokens is reached, the\n remainder is appended to the last token.\n For example the result of g_strsplit_set (\"abc:def\/ghi\", \":\/\", -1) is a\n NULL-terminated vector containing the three strings \"abc\", \"def\",\n and \"ghi\".\n The result if g_strsplit_set (\":def\/ghi:\", \":\/\", -1) is a NULL-terminated\n vector containing the four strings \"\", \"def\", \"ghi\", and \"\".\n As a special case, the result of splitting the empty string \"\" is an empty\n vector, not a vector containing a single string. The reason for this\n special case is that being able to represent a empty vector is typically\n more useful than consistent handling of empty elements. If you do need\n to represent empty elements, you'll need to check for the empty string\n before calling g_strsplit_set().\n Note that this function works on bytes not characters, so it can't be used\n to delimit UTF-8 strings for anything but ASCII characters.\n Since 2.4\n Params:\n string = The string to be tokenized\n delimiters = A nul-terminated string containing bytes that are used\n  to split the string.\n maxTokens = The maximum number of tokens to split string into.\n  If this is less than 1, the string is split completely\n Returns: a newly-allocated NULL-terminated array of strings. Use g_strfreev() to free it.\n\t \n",
"line" : 1487}
,
{
"name" : "strfreev",
"kind" : "function",
"protection" : "public",
"type" : "void(string[] strArray)",
"comment" : "\n Frees a NULL-terminated array of strings, and the array itself.\n If called on a NULL value, g_strfreev() simply returns.\n Params:\n strArray = a NULL-terminated array of strings to free.\n\t \n",
"line" : 1499}
,
{
"name" : "strjoinv",
"kind" : "function",
"protection" : "public",
"type" : "string(string separator, string[] strArray)",
"comment" : "\n Joins a number of strings together to form one long string, with the\n optional separator inserted between each of them. The returned string\n should be freed with g_free().\n Params:\n separator = a string to insert between each of the strings, or NULL\n strArray = a NULL-terminated array of strings to join\n Returns: a newly-allocated string containing all of the strings joined together, with separator between them\n\t \n",
"line" : 1514}
,
{
"name" : "strvLength",
"kind" : "function",
"protection" : "public",
"type" : "uint(string[] strArray)",
"comment" : "\n Returns the length of the given NULL-terminated\n string array str_array.\n Since 2.6\n Params:\n strArray = a NULL-terminated array of strings.\n Returns: length of str_array.\n\t \n",
"line" : 1528}
,
{
"name" : "strerror",
"kind" : "function",
"protection" : "public",
"type" : "string(int errnum)",
"comment" : "\n Returns a string corresponding to the given error code, e.g.\n \"no such process\". You should use this function in preference to\n strerror(), because it returns a string in UTF-8 encoding, and since\n not all platforms support the strerror() function.\n Params:\n errnum = the system error number. See the standard C errno\n  documentation\n Returns: a UTF-8 string describing the error code. If the error code is unknown, it returns \"unknown error (<code>)\". The string can only be used until the next call to g_strerror()\n\t \n",
"line" : 1544}
,
{
"name" : "strsignal",
"kind" : "function",
"protection" : "public",
"type" : "string(int signum)",
"comment" : "\n Returns a string describing the given signal, e.g. \"Segmentation fault\".\n You should use this function in preference to strsignal(), because it\n returns a string in UTF-8 encoding, and since not all platforms support\n the strsignal() function.\n Params:\n signum = the signal number. See the signal\n  documentation\n Returns: a UTF-8 string describing the signal. If the signal is unknown, it returns \"unknown signal (<signum>)\". The string can only be used until the next call to g_strsignal()\n\t \n",
"line" : 1560}
]
}
]
}
,
{
"name" : "glib.StringCompletion",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/StringCompletion.d",
"members" : [
{
"name" : "StringCompletion",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GCompletion provides support for automatic completion of a string\n using any group of target strings. It is typically used for file\n name completion as is common in many UNIX shells.\n A GCompletion is created using g_completion_new(). Target items are\n added and removed with g_completion_add_items(),\n g_completion_remove_items() and g_completion_clear_items(). A\n completion attempt is requested with g_completion_complete() or\n g_completion_complete_utf8(). When no longer needed, the\n GCompletion is freed with g_completion_free().\n Items in the completion can be simple strings (e.g. filenames), or\n pointers to arbitrary data structures. If data structures are used\n you must provide a GCompletionFunc in g_completion_new(), which\n retrieves the item's string from the data structure. You can change\n the way in which strings are compared by setting a different\n GCompletionStrncmpFunc in g_completion_set_compare().\n GCompletion has been marked as deprecated, since this API is rarely\n used and not very actively maintained.\n \n",
"line" : 89,
"base" : "Object",
"members" : [
{
"name" : "gCompletion",
"kind" : "variable",
"protection" : "protected",
"type" : "GCompletion*",
"comment" : " the main Gtk struct \n",
"line" : 92}
,
{
"name" : "getStringCompletionStruct",
"kind" : "function",
"protection" : "public",
"type" : "GCompletion*()",
"line" : 95}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 102}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringCompletion(GCompletion* gCompletion)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 110}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringCompletion(extern (C) char* function(void*) func)",
"comment" : "\n\t \n\n Warning\n g_completion_new is deprecated and should not be used in newly-written code.\n Creates a new GCompletion.\n Params:\n func = the function to be called to return the string representing\n  an item in the GCompletion, or NULL if strings are going to\n  be used as the GCompletion items.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 133}
,
{
"name" : "addItems",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG items)",
"comment" : "\n Warning\n g_completion_add_items has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Adds items to the GCompletion.\n Params:\n items = the list of items to add.\n\t \n",
"line" : 151}
,
{
"name" : "removeItems",
"kind" : "function",
"protection" : "public",
"type" : "void(ListG items)",
"comment" : "\n Warning\n g_completion_remove_items has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Removes items from a GCompletion.\n Params:\n items = the items to remove.\n\t \n",
"line" : 164}
,
{
"name" : "clearItems",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_completion_clear_items has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Removes all items from the GCompletion.\n\t \n",
"line" : 175}
,
{
"name" : "complete",
"kind" : "function",
"protection" : "public",
"type" : "ListG(string prefix, out string newPrefix)",
"comment" : "\n Warning\n g_completion_complete has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Attempts to complete the string prefix using the GCompletion\n target items.\n Params:\n prefix = the prefix string, typically typed by the user, which is\n  compared with each of the items.\n newPrefix = if non-NULL, returns the longest prefix which is\n  common to all items that matched prefix, or NULL if\n  no items matched prefix. This string should be freed\n  when no longer needed.\n Returns: the list of items whose strings begin with prefix. This should not be changed.\n\t \n",
"line" : 195}
,
{
"name" : "completeUtf8",
"kind" : "function",
"protection" : "public",
"type" : "ListG(string prefix, out string newPrefix)",
"comment" : "\n Warning\n g_completion_complete_utf8 has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Attempts to complete the string prefix using the GCompletion target items.\n In contrast to g_completion_complete(), this function returns the largest common\n prefix that is a valid UTF-8 string, omitting a possible common partial\n character.\n You should use this function instead of g_completion_complete() if your\n items are UTF-8 strings.\n Since 2.4\n Params:\n prefix = the prefix string, typically used by the user, which is compared\n  with each of the items\n newPrefix = if non-NULL, returns the longest prefix which is common to all\n  items that matched prefix, or NULL if no items matched prefix.\n  This string should be freed when no longer needed.\n Returns: the list of items whose strings begin with prefix. This should not be changed.\n\t \n",
"line" : 228}
,
{
"name" : "setCompare",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(char*, char*, ulong) strncmpFunc)",
"comment" : "\n Warning\n g_completion_set_compare has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Sets the function to use for string comparisons. The default string\n comparison function is strncmp().\n Params:\n cmp = a GCompletion.\n strncmpFunc = the string comparison function.\n\t \n",
"line" : 252}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Warning\n g_completion_free has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Frees all memory used by the GCompletion.\n\t \n",
"line" : 263}
]
}
]
}
,
{
"name" : "glib.StringGChunk",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/StringGChunk.d",
"members" : [
{
"name" : "StringGChunk",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n String chunks are used to store groups of strings. Memory is\n allocated in blocks, and as strings are added to the GStringChunk\n they are copied into the next free position in a block. When a block\n is full a new block is allocated.\n When storing a large number of strings, string chunks are more\n efficient than using g_strdup() since fewer calls to malloc() are\n needed, and less memory is wasted in memory allocation overheads.\n By adding strings with g_string_chunk_insert_const() it is also\n possible to remove duplicates.\n To create a new GStringChunk use g_string_chunk_new().\n To add strings to a GStringChunk use g_string_chunk_insert().\n To add strings to a GStringChunk, but without duplicating strings\n which are already in the GStringChunk, use\n g_string_chunk_insert_const().\n To free the entire GStringChunk use g_string_chunk_free(). It is\n not possible to free individual strings.\n \n",
"line" : 85,
"base" : "Object",
"members" : [
{
"name" : "gStringChunk",
"kind" : "variable",
"protection" : "protected",
"type" : "GStringChunk*",
"comment" : " the main Gtk struct \n",
"line" : 88}
,
{
"name" : "getStringGChunkStruct",
"kind" : "function",
"protection" : "public",
"type" : "GStringChunk*()",
"line" : 91}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringGChunk(GStringChunk* gStringChunk)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 106}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringGChunk(ulong size)",
"comment" : "\n\t \n\n Creates a new GStringChunk.\n Params:\n size = the default size of the blocks of memory which are\n  allocated to store the strings. If a particular string\n  is larger than this default size, a larger block of\n  memory will be allocated for it.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 128}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Adds a copy of string to the GStringChunk.\n It returns a pointer to the new copy of the string\n in the GStringChunk. The characters in the string\n can be changed, if necessary, though you should not\n change anything after the end of the string.\n Unlike g_string_chunk_insert_const(), this function\n does not check for duplicates. Also strings added\n with g_string_chunk_insert() will not be searched\n by g_string_chunk_insert_const() when looking for\n duplicates.\n Params:\n string = the string to add\n Returns: a pointer to the copy of string within the GStringChunk\n\t \n",
"line" : 154}
,
{
"name" : "insertConst",
"kind" : "function",
"protection" : "public",
"type" : "string(string string)",
"comment" : "\n Adds a copy of string to the GStringChunk, unless the same\n string has already been added to the GStringChunk with\n g_string_chunk_insert_const().\n This function is useful if you need to copy a large number\n of strings but do not want to waste space storing duplicates.\n But you must remember that there may be several pointers to\n the same string, and so any changes made to the strings\n should be done very carefully.\n Note that g_string_chunk_insert_const() will not return a\n pointer to a string added with g_string_chunk_insert(), even\n if they do match.\n Params:\n string = the string to add\n Returns: a pointer to the new or existing copy of string within the GStringChunk\n\t \n",
"line" : 176}
,
{
"name" : "insertLen",
"kind" : "function",
"protection" : "public",
"type" : "string(string string, long len)",
"comment" : "\n Adds a copy of the first len bytes of string to the GStringChunk.\n The copy is nul-terminated.\n Since this function does not stop at nul bytes, it is the caller's\n responsibility to ensure that string has at least len addressable\n bytes.\n The characters in the returned string can be changed, if necessary,\n though you should not change anything after the end of the string.\n Since 2.4\n Params:\n string = bytes to insert\n len = number of bytes of string to insert, or -1 to insert a\n  nul-terminated string\n Returns: a pointer to the copy of string within the GStringChunk\n\t \n",
"line" : 197}
,
{
"name" : "clear",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees all strings contained within the GStringChunk.\n After calling g_string_chunk_clear() it is not safe to\n access any of the strings which were contained within it.\n Since 2.14\n\t \n",
"line" : 209}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees all memory allocated by the GStringChunk.\n After calling g_string_chunk_free() it is not safe to\n access any of the strings which were contained within it.\n\t \n",
"line" : 220}
]
}
]
}
,
{
"name" : "glib.StringG",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/StringG.d",
"members" : [
{
"name" : "StringG",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GString is an object that handles the memory management of a C string\n for you. You can think of it as similar to a Java StringBuffer.\n In addition to the string itself, GString stores the length of the string,\n so can be used for binary data with embedded nul bytes. To access the C\n string managed by the GString string, simply use string->str.\n \n",
"line" : 75,
"base" : "Object",
"members" : [
{
"name" : "gString",
"kind" : "variable",
"protection" : "protected",
"type" : "GString*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getStringGStruct",
"kind" : "function",
"protection" : "public",
"type" : "GString*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringG(GString* gString)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringG(string init)",
"comment" : "\n\t \n\n Creates a new GString, initialized with the given string.\n Params:\n init = the initial text to copy into the string\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 115}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "StringG(string init, long len)",
"comment" : "\n Creates a new GString with len bytes of the init buffer.\n Because a length is provided, init need not be nul-terminated,\n and can contain embedded nul bytes.\n Since this function does not stop at nul bytes, it is the caller's\n responsibility to ensure that init has at least len addressable\n bytes.\n Params:\n init = initial contents of the string\n len = length of init to use\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 138}
,
{
"name" : "sizedNew",
"kind" : "function",
"protection" : "public",
"type" : "StringG(ulong dflSize)",
"comment" : "\n Creates a new GString, with enough space for dfl_size\n bytes. This is useful if you are going to add a lot of\n text to the string and don't want it to be reallocated\n too often.\n Params:\n dflSize = the default size of the space allocated to\n  hold the string\n Returns: the new GString\n\t \n",
"line" : 159}
,
{
"name" : "assign",
"kind" : "function",
"protection" : "public",
"type" : "StringG(string rval)",
"comment" : "\n Copies the bytes from a string into a GString,\n destroying any previous contents. It is rather like\n the standard strcpy() function, except that you do not\n have to worry about having enough space to copy the string.\n Params:\n string = the destination GString. Its current contents\n  are destroyed.\n rval = the string to copy into string\n Returns: string\n\t \n",
"line" : 181}
,
{
"name" : "vprintf",
"kind" : "function",
"protection" : "public",
"type" : "void(string format, void* args)",
"comment" : "\n Writes a formatted string into a GString.\n This function is similar to g_string_printf() except that\n the arguments to the format string are passed as a va_list.\n Since 2.14\n Params:\n string = a GString\n format = the string format. See the printf() documentation\n args = the parameters to insert into the format string\n\t \n",
"line" : 202}
,
{
"name" : "appendVprintf",
"kind" : "function",
"protection" : "public",
"type" : "void(string format, void* args)",
"comment" : "\n Appends a formatted string onto the end of a GString.\n This function is similar to g_string_append_printf()\n except that the arguments to the format string are passed\n as a va_list.\n Since 2.14\n Params:\n string = a GString\n format = the string format. See the printf() documentation\n args = the list of arguments to insert in the output\n\t \n",
"line" : 219}
,
{
"name" : "append",
"kind" : "function",
"protection" : "public",
"type" : "StringG(string val)",
"comment" : "\n Adds a string onto the end of a GString, expanding\n it if necessary.\n Params:\n string = a GString\n val = the string to append onto the end of string\n Returns: string\n\t \n",
"line" : 233}
,
{
"name" : "appendC",
"kind" : "function",
"protection" : "public",
"type" : "StringG(char c)",
"comment" : "\n Adds a byte onto the end of a GString, expanding\n it if necessary.\n Params:\n c = the byte to append onto the end of string\n Returns: string\n\t \n",
"line" : 251}
,
{
"name" : "appendUnichar",
"kind" : "function",
"protection" : "public",
"type" : "StringG(uint wc)",
"comment" : "\n Converts a Unicode character into UTF-8, and appends it\n to the string.\n Params:\n wc = a Unicode character\n Returns: string\n\t \n",
"line" : 269}
,
{
"name" : "appendLen",
"kind" : "function",
"protection" : "public",
"type" : "StringG(string val, long len)",
"comment" : "\n Appends len bytes of val to string. Because len is\n provided, val may contain embedded nuls and need not\n be nul-terminated.\n Since this function does not stop at nul bytes, it is\n the caller's responsibility to ensure that val has at\n least len addressable bytes.\n Params:\n string = a GString\n val = bytes to append\n len = number of bytes of val to use\n Returns: string\n\t \n",
"line" : 293}
,
{
"name" : "appendUriEscaped",
"kind" : "function",
"protection" : "public",
"type" : "StringG(string unescaped, string reservedCharsAllowed, int allowUtf8)",
"comment" : "\n Appends unescaped to string, escaped any characters that\n are reserved in URIs using URI-style escape sequences.\n Since 2.16\n Params:\n string = a GString\n unescaped = a string\n reservedCharsAllowed = a string of reserved characters allowed to be used, or NULL\n allowUtf8 = set TRUE if the escaped string may include UTF8 characters\n Returns: string\n\t \n",
"line" : 315}
,
{
"name" : "prepend",
"kind" : "function",
"protection" : "public",
"type" : "StringG(string val)",
"comment" : "\n Adds a string on to the start of a GString,\n expanding it if necessary.\n Params:\n string = a GString\n val = the string to prepend on the start of string\n Returns: string\n\t \n",
"line" : 334}
,
{
"name" : "prependC",
"kind" : "function",
"protection" : "public",
"type" : "StringG(char c)",
"comment" : "\n Adds a byte onto the start of a GString,\n expanding it if necessary.\n Params:\n c = the byte to prepend on the start of the GString\n Returns: string\n\t \n",
"line" : 352}
,
{
"name" : "prependUnichar",
"kind" : "function",
"protection" : "public",
"type" : "StringG(uint wc)",
"comment" : "\n Converts a Unicode character into UTF-8, and prepends it\n to the string.\n Params:\n wc = a Unicode character\n Returns: string\n\t \n",
"line" : 370}
,
{
"name" : "prependLen",
"kind" : "function",
"protection" : "public",
"type" : "StringG(string val, long len)",
"comment" : "\n Prepends len bytes of val to string.\n Because len is provided, val may contain\n embedded nuls and need not be nul-terminated.\n Since this function does not stop at nul bytes,\n it is the caller's responsibility to ensure that\n val has at least len addressable bytes.\n Params:\n string = a GString\n val = bytes to prepend\n len = number of bytes in val to prepend\n Returns: string\n\t \n",
"line" : 394}
,
{
"name" : "insert",
"kind" : "function",
"protection" : "public",
"type" : "StringG(long pos, string val)",
"comment" : "\n Inserts a copy of a string into a GString,\n expanding it if necessary.\n Params:\n string = a GString\n pos = the position to insert the copy of the string\n val = the string to insert\n Returns: string\n\t \n",
"line" : 414}
,
{
"name" : "insertC",
"kind" : "function",
"protection" : "public",
"type" : "StringG(long pos, char c)",
"comment" : "\n Inserts a byte into a GString, expanding it if necessary.\n Params:\n pos = the position to insert the byte\n c = the byte to insert\n Returns: string\n\t \n",
"line" : 432}
,
{
"name" : "insertUnichar",
"kind" : "function",
"protection" : "public",
"type" : "StringG(long pos, uint wc)",
"comment" : "\n Converts a Unicode character into UTF-8, and insert it\n into the string at the given position.\n Params:\n pos = the position at which to insert character, or -1 to\n  append at the end of the string\n wc = a Unicode character\n Returns: string\n\t \n",
"line" : 452}
,
{
"name" : "insertLen",
"kind" : "function",
"protection" : "public",
"type" : "StringG(long pos, string val, long len)",
"comment" : "\n Inserts len bytes of val into string at pos.\n Because len is provided, val may contain embedded\n nuls and need not be nul-terminated. If pos is -1,\n bytes are inserted at the end of the string.\n Since this function does not stop at nul bytes, it is\n the caller's responsibility to ensure that val has at\n least len addressable bytes.\n Params:\n string = a GString\n pos = position in string where insertion should\n  happen, or -1 for at the end\n val = bytes to insert\n len = number of bytes of val to insert\n Returns: string\n\t \n",
"line" : 479}
,
{
"name" : "overwrite",
"kind" : "function",
"protection" : "public",
"type" : "StringG(ulong pos, string val)",
"comment" : "\n Overwrites part of a string, lengthening it if necessary.\n Since 2.14\n Params:\n string = a GString\n pos = the position at which to start overwriting\n val = the string that will overwrite the string starting at pos\n Returns: string\n\t \n",
"line" : 499}
,
{
"name" : "overwriteLen",
"kind" : "function",
"protection" : "public",
"type" : "StringG(ulong pos, string val, long len)",
"comment" : "\n Overwrites part of a string, lengthening it if necessary.\n This function will work with embedded nuls.\n Since 2.14\n Params:\n string = a GString\n pos = the position at which to start overwriting\n val = the string that will overwrite the string starting at pos\n len = the number of bytes to write from val\n Returns: string\n\t \n",
"line" : 521}
,
{
"name" : "erase",
"kind" : "function",
"protection" : "public",
"type" : "StringG(long pos, long len)",
"comment" : "\n Removes len bytes from a GString, starting at position pos.\n The rest of the GString is shifted down to fill the gap.\n Params:\n pos = the position of the content to remove\n len = the number of bytes to remove, or -1 to remove all\n  following bytes\n Returns: string\n\t \n",
"line" : 541}
,
{
"name" : "truncate",
"kind" : "function",
"protection" : "public",
"type" : "StringG(ulong len)",
"comment" : "\n Cuts off the end of the GString, leaving the first len bytes.\n Params:\n len = the new size of string\n Returns: string\n\t \n",
"line" : 558}
,
{
"name" : "setSize",
"kind" : "function",
"protection" : "public",
"type" : "StringG(ulong len)",
"comment" : "\n Sets the length of a GString. If the length is less than\n the current length, the string will be truncated. If the\n length is greater than the current length, the contents\n of the newly added area are undefined. (However, as\n always, string->str[string->len] will be a nul byte.)\n Params:\n len = the new length\n Returns: string\n\t \n",
"line" : 579}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "string(int freeSegment)",
"comment" : "\n Frees the memory allocated for the GString.\n If free_segment is TRUE it also frees the character data.\n Params:\n string = a GString\n freeSegment = if TRUE the actual character data is freed as well\n Returns: the character data of string (i.e. NULL if free_segment is TRUE)\n\t \n",
"line" : 598}
,
{
"name" : "up",
"kind" : "function",
"protection" : "public",
"type" : "StringG()",
"comment" : "\n Warning\n g_string_up has been deprecated since version 2.2 and should not be used in newly-written code. This function uses the locale-specific\n  toupper() function, which is almost never the right thing.\n  Use g_string_ascii_up() or g_utf8_strup() instead.\n Converts a GString to uppercase.\n Returns: string\n\t \n",
"line" : 612}
,
{
"name" : "down",
"kind" : "function",
"protection" : "public",
"type" : "StringG()",
"comment" : "\n Warning\n g_string_down has been deprecated since version 2.2 and should not be used in newly-written code. This function uses the locale-specific\n  tolower() function, which is almost never the right thing.\n  Use g_string_ascii_down() or g_utf8_strdown() instead.\n Converts a GString to lowercase.\n Returns: the GString.\n\t \n",
"line" : 631}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Creates a hash code for str; for use with GHashTable.\n Returns: hash code for str\n\t \n",
"line" : 646}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(StringG v2)",
"comment" : "\n Compares two strings for equality, returning TRUE if they are equal.\n For use with GHashTable.\n Params:\n v = a GString\n v2 = another GString\n Returns: TRUE if they strings are the same length and contain the same bytes\n\t \n",
"line" : 660}
]
}
]
}
,
{
"name" : "glib.ThreadPool",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/ThreadPool.d",
"members" : [
{
"name" : "ThreadPool",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Sometimes you wish to asynchronously fork out the execution of work\n and continue working in your own thread. If that will happen often,\n the overhead of starting and destroying a thread each time might be\n too high. In such cases reusing already started threads seems like a\n good idea. And it indeed is, but implementing this can be tedious\n and error-prone.\n Therefore GLib provides thread pools for your convenience. An added\n advantage is, that the threads can be shared between the different\n subsystems of your program, when they are using GLib.\n To create a new thread pool, you use g_thread_pool_new(). It is\n destroyed by g_thread_pool_free().\n If you want to execute a certain task within a thread pool, you call\n g_thread_pool_push().\n To get the current number of running threads you call\n g_thread_pool_get_num_threads(). To get the number of still\n unprocessed tasks you call g_thread_pool_unprocessed(). To control\n the maximal number of threads for a thread pool, you use\n g_thread_pool_get_max_threads() and g_thread_pool_set_max_threads().\n Finally you can control the number of unused threads, that are kept\n alive by GLib for future use. The current number can be fetched with\n g_thread_pool_get_num_unused_threads(). The maximal number can be\n controlled by g_thread_pool_get_max_unused_threads() and\n g_thread_pool_set_max_unused_threads(). All currently unused threads\n can be stopped by calling g_thread_pool_stop_unused_threads().\n \n",
"line" : 95,
"base" : "Object",
"members" : [
{
"name" : "gThreadPool",
"kind" : "variable",
"protection" : "protected",
"type" : "GThreadPool*",
"comment" : " the main Gtk struct \n",
"line" : 98}
,
{
"name" : "getThreadPoolStruct",
"kind" : "function",
"protection" : "public",
"type" : "GThreadPool*()",
"line" : 101}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 108}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThreadPool(GThreadPool* gThreadPool)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 116}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "ThreadPool(extern (C) void function(void*, void*) func, void* userData, int maxThreads, int exclusive)",
"comment" : "\n\t \n\n This function creates a new thread pool.\n Whenever you call g_thread_pool_push(), either a new thread is\n created or an unused one is reused. At most max_threads threads\n are running concurrently for this thread pool. max_threads = -1\n allows unlimited threads to be created for this thread pool. The\n newly created or reused thread now executes the function func with\n the two arguments. The first one is the parameter to\n g_thread_pool_push() and the second one is user_data.\n The parameter exclusive determines, whether the thread pool owns\n all threads exclusive or whether the threads are shared\n globally. If exclusive is TRUE, max_threads threads are started\n immediately and they will run exclusively for this thread pool until\n it is destroyed by g_thread_pool_free(). If exclusive is FALSE,\n threads are created, when needed and shared between all\n non-exclusive thread pools. This implies that max_threads may not\n be -1 for exclusive thread pools.\n error can be NULL to ignore errors, or non-NULL to report\n errors. An error can only occur when exclusive is set to TRUE and\n not all max_threads threads could be created.\n Params:\n func = a function to execute in the threads of the new thread pool\n userData = user data that is handed over to func every time it\n  is called\n maxThreads = the maximal number of threads to execute concurrently in\n  the new thread pool, -1 means no limit\n exclusive = should this thread pool be exclusive?\n Throws: GException on failure.\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 159}
,
{
"name" : "push",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Inserts data into the list of tasks to be executed by pool. When\n the number of currently running threads is lower than the maximal\n allowed number of threads, a new thread is started (or reused) with\n the properties given to g_thread_pool_new(). Otherwise data stays\n in the queue until a thread in this pool finishes its previous task\n and processes data.\n error can be NULL to ignore errors, or non-NULL to report\n errors. An error can only occur when a new thread couldn't be\n created. In that case data is simply appended to the queue of work\n to do.\n Params:\n data = a new task for pool\n Throws: GException on failure.\n\t \n",
"line" : 193}
,
{
"name" : "setMaxThreads",
"kind" : "function",
"protection" : "public",
"type" : "void(int maxThreads)",
"comment" : "\n Sets the maximal allowed number of threads for pool. A value of -1\n means, that the maximal number of threads is unlimited.\n Setting max_threads to 0 means stopping all work for pool. It is\n effectively frozen until max_threads is set to a non-zero value\n again.\n A thread is never terminated while calling func, as supplied by\n g_thread_pool_new(). Instead the maximal number of threads only\n has effect for the allocation of new threads in g_thread_pool_push().\n A new thread is allocated, whenever the number of currently\n running threads in pool is smaller than the maximal number.\n error can be NULL to ignore errors, or non-NULL to report\n errors. An error can only occur when a new thread couldn't be\n created.\n Params:\n maxThreads = a new maximal number of threads for pool\n Throws: GException on failure.\n\t \n",
"line" : 225}
,
{
"name" : "getMaxThreads",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the maximal number of threads for pool.\n Returns: the maximal number of threads\n\t \n",
"line" : 243}
,
{
"name" : "getNumThreads",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the number of threads currently running in pool.\n Returns: the number of threads currently running\n\t \n",
"line" : 253}
,
{
"name" : "unprocessed",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the number of tasks still unprocessed in pool.\n Returns: the number of unprocessed tasks\n\t \n",
"line" : 263}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void(int immediate, int wait)",
"comment" : "\n Frees all resources allocated for pool.\n If immediate is TRUE, no new task is processed for\n pool. Otherwise pool is not freed before the last task is\n processed. Note however, that no thread of this pool is\n interrupted, while processing a task. Instead at least all still\n running threads can finish their tasks before the pool is freed.\n If wait_ is TRUE, the functions does not return before all tasks\n to be processed (dependent on immediate, whether all or only the\n currently running) are ready. Otherwise the function returns immediately.\n After calling this function pool must not be used anymore.\n Params:\n immediate = should pool shut down immediately?\n wait = should the function wait for all tasks to be finished?\n\t \n",
"line" : 284}
,
{
"name" : "setMaxUnusedThreads",
"kind" : "function",
"protection" : "public",
"type" : "void(int maxThreads)",
"comment" : "\n Sets the maximal number of unused threads to max_threads. If\n max_threads is -1, no limit is imposed on the number of unused\n threads.\n Params:\n maxThreads = maximal number of unused threads\n\t \n",
"line" : 297}
,
{
"name" : "getMaxUnusedThreads",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the maximal allowed number of unused threads.\n Returns: the maximal number of unused threads\n\t \n",
"line" : 307}
,
{
"name" : "getNumUnusedThreads",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the number of currently unused threads.\n Returns: the number of currently unused threads\n\t \n",
"line" : 317}
,
{
"name" : "stopUnusedThreads",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Stops all currently unused threads. This does not change the\n maximal number of unused threads. This function can be used to\n regularly stop all unused threads e.g. from g_timeout_add().\n\t \n",
"line" : 328}
,
{
"name" : "setSortFunction",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) int function(void*, void*, void*) func, void* userData)",
"comment" : "\n Sets the function used to sort the list of tasks. This allows the\n tasks to be processed by a priority determined by func, and not\n just in the order in which they were added to the pool.\n Note, if the maximum number of threads is more than 1, the order\n that threads are executed can not be guranteed 100%. Threads are\n scheduled by the operating system and are executed at random. It\n cannot be assumed that threads are executed in the order they are\n created.\n Since 2.10\n Params:\n func = the GCompareDataFunc used to sort the list of tasks.\n  This function is passed two tasks. It should return\n  0 if the order in which they are handled does not matter,\n  a negative value if the first task should be processed before\n  the second or a positive value if the second task should be\n  processed first.\n userData = user data passed to func.\n\t \n",
"line" : 353}
,
{
"name" : "setMaxIdleTime",
"kind" : "function",
"protection" : "public",
"type" : "void(uint interval)",
"comment" : "\n This function will set the maximum interval that a thread waiting\n in the pool for new tasks can be idle for before being\n stopped. This function is similar to calling\n g_thread_pool_stop_unused_threads() on a regular timeout, except,\n this is done on a per thread basis.\n By setting interval to 0, idle threads will not be stopped.\n This function makes use of g_async_queue_timed_pop() using\n interval.\n Since 2.10\n Params:\n interval = the maximum interval (1\/1000ths of a second) a thread\n  can be idle.\n\t \n",
"line" : 373}
,
{
"name" : "getMaxIdleTime",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n This function will return the maximum interval that a thread will\n wait in the thread pool for new tasks before being stopped.\n If this function returns 0, threads waiting in the thread pool for\n new work are not stopped.\n Since 2.10\n Returns: the maximum interval to wait for new tasks in the thread pool before stopping the thread (1\/1000ths of a second).\n\t \n",
"line" : 387}
]
}
]
}
,
{
"name" : "glib.Timeout",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Timeout.d",
"members" : [
{
"name" : "Timeout",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The main event loop manages all the available sources of events for\n GLib and GTK+ applications. These events can come from any number of\n different types of sources such as file descriptors (plain files,\n pipes or sockets) and timeouts. New types of event sources can also\n be added using g_source_attach().\n To allow multiple independent sets of sources to be handled in\n different threads, each source is associated with a GMainContext.\n A GMainContext can only be running in a single thread, but\n sources can be added to it and removed from it from other threads.\n Each event source is assigned a priority. The default priority,\n G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.\n Values greater than 0 denote lower priorities. Events from high priority\n sources are always processed before events from lower priority sources.\n Idle functions can also be added, and assigned a priority. These will\n be run whenever no events with a higher priority are ready to be processed.\n The GMainLoop data type represents a main event loop. A GMainLoop is\n created with g_main_loop_new(). After adding the initial event sources,\n g_main_loop_run() is called. This continuously checks for new events from\n each of the event sources and dispatches them. Finally, the processing of\n an event from one of the sources leads to a call to g_main_loop_quit() to\n exit the main loop, and g_main_loop_run() returns.\n It is possible to create new instances of GMainLoop recursively.\n This is often used in GTK+ applications when showing modal dialog\n boxes. Note that event sources are associated with a particular\n GMainContext, and will be checked and dispatched for all main\n loops associated with that GMainContext.\n GTK+ contains wrappers of some of these functions, e.g. gtk_main(),\n gtk_main_quit() and gtk_events_pending().\n Creating new source types\n One of the unusual features of the GMainLoop functionality\n is that new types of event source can be created and used in\n addition to the builtin type of event source. A new event source\n type is used for handling GDK events. A new source type is created\n by deriving from the GSource structure.\n The derived type of source is represented by a structure that has\n the GSource structure as a first element, and other elements specific\n to the new source type. To create an instance of the new source type,\n call g_source_new() passing in the size of the derived structure and\n a table of functions. These GSourceFuncs determine the behavior of\n the new source type.\n New source types basically interact with the main context\n in two ways. Their prepare function in GSourceFuncs can set a timeout\n to determine the maximum amount of time that the main loop will sleep\n before checking the source again. In addition, or as well, the source\n can add file descriptors to the set that the main context checks using\n g_source_add_poll().\n <hr>\n Customizing the main loop iteration\n Single iterations of a GMainContext can be run with\n g_main_context_iteration(). In some cases, more detailed control\n of exactly how the details of the main loop work is desired, for\n instance, when integrating the GMainLoop with an external main loop.\n In such cases, you can call the component functions of\n g_main_context_iteration() directly. These functions are\n g_main_context_prepare(), g_main_context_query(),\n g_main_context_check() and g_main_context_dispatch().\n The operation of these functions can best be seen in terms\n of a state diagram, as shown in Figure  1, “States of a Main Context”.\n Figure  1.  States of a Main Context\n \n",
"line" : 129,
"base" : "Object",
"members" : [
{
"name" : "timeoutListeners",
"kind" : "variable",
"protection" : "public",
"type" : "bool delegate()[]",
"comment" : " Holds all timeout delegates \n",
"line" : 132}
,
{
"name" : "timeoutID",
"kind" : "variable",
"protection" : "public",
"type" : "uint",
"comment" : " our gtk timeout ID \n",
"line" : 134}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Timeout(uint interval, bool delegate() dlg, bool fireNow = false)",
"comment" : "\n Creates a new timeout cycle with the default priority, GPriority.DEFAULT.\n\n Note that timeout functions may be delayed, due to the processing of other\n event sources. Thus they should not be relied on for precise timing.\n After each call to the timeout function, the time of the next timeout is\n recalculated based on the current time and the given interval\n (it does not try to 'catch up' time lost in delays).\n Params:\n    \tinterval = \tthe timeout in milieconds\n    \tdelegate() = \tthe delegate to be executed\n    \tfireNow = \tWhen true the delegate will be executed emmidiatly\n\t \n",
"line" : 150}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Timeout(uint interval, bool delegate() dlg, GPriority priority, bool fireNow = false)",
"comment" : "\n Creates a new timeout cycle.\n Params:\n    \tinterval = \tthe timeout in milieconds\n    \tdelegate() = \tthe delegate to be executed\n      priority = Priority for the timeout function\n    \tfireNow = \tWhen true the delegate will be executed emmidiatly\n\t \n",
"line" : 171}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Timeout(bool delegate() dlg, uint seconds, bool fireNow = false)",
"comment" : "\n Creates a new timeout cycle with the default priority, GPriority.DEFAULT.\n Params:\n    \tdelegate() = \tthe delegate to be executed\n      seconds = interval in seconds.\n    \tfireNow = \tWhen true the delegate will be executed emmidiatly\n\t \n",
"line" : 191}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Timeout(bool delegate() dlg, uint seconds, GPriority priority, bool fireNow = false)",
"comment" : "\n Creates a new timeout cycle.\n Params:\n    \tdelegate() = \tthe delegate to be executed\n      seconds = interval in seconds.\n      priority = Priority for the timeout function\n    \tfireNow = \tWhen true the delegate will be executed emmidiatly\n\t \n",
"line" : 212}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : " \n",
"line" : 226}
,
{
"name" : "addListener",
"kind" : "function",
"protection" : "public",
"type" : "void(bool delegate() dlg, bool fireNow = false)",
"comment" : "\n Adds a new delegate to this timeout cycle\n Params:\n    \tdlg =\n    \tfireNow =\n\t \n",
"line" : 249}
,
{
"name" : "timeoutCallback",
"kind" : "function",
"protection" : "public",
"type" : "extern (C) bool(Timeout timeout)",
"comment" : "\n The callback execution from glib\n Params:\n    \ttimeout =\n Returns:\n\t \n",
"line" : 267}
,
{
"name" : "callAllListeners",
"kind" : "function",
"protection" : "private",
"type" : "bool()",
"comment" : "\n Executes all delegates on the execution list\n Returns:\n\t \n",
"line" : 276}
,
{
"name" : "sourceNew",
"kind" : "function",
"protection" : "public",
"type" : "Source(uint interval)",
"comment" : "\n\t \n\n Creates a new timeout source.\n The source will not initially be associated with any GMainContext\n and must be added to one with g_source_attach() before it will be\n executed.\n Params:\n interval = the timeout interval in milliseconds.\n Returns: the newly-created timeout source\n\t \n",
"line" : 309}
,
{
"name" : "sourceNewSeconds",
"kind" : "function",
"protection" : "public",
"type" : "Source(uint interval)",
"comment" : "\n Creates a new timeout source.\n The source will not initially be associated with any GMainContext\n and must be added to one with g_source_attach() before it will be\n executed.\n The scheduling granularity\/accuracy of this timeout source will be\n in seconds.\n Since 2.14\n Params:\n interval = the timeout interval in seconds\n Returns: the newly-created timeout source\n\t \n",
"line" : 332}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint interval, extern (C) int function(void*) funct, void* data)",
"comment" : "\n Sets a function to be called at regular intervals, with the default\n priority, G_PRIORITY_DEFAULT. The function is called repeatedly\n until it returns FALSE, at which point the timeout is automatically\n destroyed and the function will not be called again. The first call\n to the function will be at the end of the first interval.\n Note that timeout functions may be delayed, due to the processing of other\n event sources. Thus they should not be relied on for precise timing.\n After each call to the timeout function, the time of the next\n timeout is recalculated based on the current time and the given interval\n (it does not try to 'catch up' time lost in delays).\n If you want to have a timer in the \"seconds\" range and do not care\n about the exact time of the first call of the timer, use the\n g_timeout_add_seconds() function; this function allows for more\n optimizations and more efficient system power usage.\n This internally creates a main loop source using g_timeout_source_new()\n and attaches it to the main loop context using g_source_attach(). You can\n do these steps manually if you need greater control.\n Params:\n interval = the time between calls to the function, in milliseconds\n  (1\/1000ths of a second)\n data = data to pass to function\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 367}
,
{
"name" : "addFull",
"kind" : "function",
"protection" : "public",
"type" : "uint(int priority, uint interval, extern (C) int function(void*) funct, void* data, extern (C) void function(void* cbData) notify)",
"comment" : "\n Sets a function to be called at regular intervals, with the given\n priority. The function is called repeatedly until it returns\n FALSE, at which point the timeout is automatically destroyed and\n the function will not be called again. The notify function is\n called when the timeout is destroyed. The first call to the\n function will be at the end of the first interval.\n Note that timeout functions may be delayed, due to the processing of other\n event sources. Thus they should not be relied on for precise timing.\n After each call to the timeout function, the time of the next\n timeout is recalculated based on the current time and the given interval\n (it does not try to 'catch up' time lost in delays).\n This internally creates a main loop source using g_timeout_source_new()\n and attaches it to the main loop context using g_source_attach(). You can\n do these steps manually if you need greater control.\n Params:\n priority = the priority of the timeout source. Typically this will be in\n  the range between G_PRIORITY_DEFAULT and G_PRIORITY_HIGH.\n interval = the time between calls to the function, in milliseconds\n  (1\/1000ths of a second)\n data = data to pass to function\n notify = function to call when the timeout is removed, or NULL\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 397}
,
{
"name" : "addSeconds",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint interval, extern (C) int function(void*) funct, void* data)",
"comment" : "\n Sets a function to be called at regular intervals with the default\n priority, G_PRIORITY_DEFAULT. The function is called repeatedly until\n it returns FALSE, at which point the timeout is automatically destroyed\n and the function will not be called again.\n This internally creates a main loop source using\n g_timeout_source_new_seconds() and attaches it to the main loop context\n using g_source_attach(). You can do these steps manually if you need\n greater control. Also see g_timout_add_seconds_full().\n Since 2.14\n Params:\n interval = the time between calls to the function, in seconds\n data = data to pass to function\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 418}
,
{
"name" : "addSecondsFull",
"kind" : "function",
"protection" : "public",
"type" : "uint(int priority, uint interval, extern (C) int function(void*) funct, void* data, extern (C) void function(void* cbData) notify)",
"comment" : "\n Sets a function to be called at regular intervals, with priority.\n The function is called repeatedly until it returns FALSE, at which\n point the timeout is automatically destroyed and the function will\n not be called again.\n Unlike g_timeout_add(), this function operates at whole second granularity.\n The initial starting point of the timer is determined by the implementation\n and the implementation is expected to group multiple timers together so that\n they fire all at the same time.\n To allow this grouping, the interval to the first timer is rounded\n and can deviate up to one second from the specified interval.\n Subsequent timer iterations will generally run at the specified interval.\n Note that timeout functions may be delayed, due to the processing of other\n event sources. Thus they should not be relied on for precise timing.\n After each call to the timeout function, the time of the next\n timeout is recalculated based on the current time and the given interval\n If you want timing more precise than whole seconds, use g_timeout_add()\n instead.\n The grouping of timers to fire at the same time results in a more power\n and CPU efficient behavior so if your timer is in multiples of seconds\n and you don't require the first timer exactly one second from now, the\n use of g_timeout_add_seconds() is preferred over g_timeout_add().\n This internally creates a main loop source using\n g_timeout_source_new_seconds() and attaches it to the main loop context\n using g_source_attach(). You can do these steps manually if you need\n greater control.\n Since 2.14\n Params:\n priority = the priority of the timeout source. Typically this will be in\n  the range between G_PRIORITY_DEFAULT and G_PRIORITY_HIGH.\n interval = the time between calls to the function, in seconds\n data = data to pass to function\n notify = function to call when the timeout is removed, or NULL\n Returns: the ID (greater than 0) of the event source.\n\t \n",
"line" : 459}
]
}
]
}
,
{
"name" : "glib.Timer",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Timer.d",
"members" : [
{
"name" : "Timer",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GTimer records a start time, and counts microseconds elapsed since\n that time. This is done somewhat differently on different platforms,\n and can be tricky to get exactly right, so GTimer provides a\n portable\/convenient interface.\n Note\n  GTimer uses a higher-quality clock when thread support is available.\n  Therefore, calling g_thread_init() while timers are running may lead to\n  unreliable results. It is best to call g_thread_init() before starting any\n  timers, if you are using threads at all.\n \n",
"line" : 77,
"base" : "Object",
"members" : [
{
"name" : "gTimer",
"kind" : "variable",
"protection" : "protected",
"type" : "GTimer*",
"comment" : " the main Gtk struct \n",
"line" : 80}
,
{
"name" : "getTimerStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTimer*()",
"line" : 83}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 90}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Timer(GTimer* gTimer)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 98}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Timer()",
"comment" : "\n\t \n\n Creates a new timer, and starts timing (i.e. g_timer_start() is\n implicitly called for you).\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 116}
,
{
"name" : "start",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Marks a start time, so that future calls to g_timer_elapsed() will\n report the time since g_timer_start() was called. g_timer_new()\n automatically marks the start time, so no need to call\n g_timer_start() immediately after creating the timer.\n\t \n",
"line" : 133}
,
{
"name" : "stop",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Marks an end time, so calls to g_timer_elapsed() will return the\n difference between this end time and the start time.\n\t \n",
"line" : 143}
,
{
"name" : "continu",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Resumes a timer that has previously been stopped with\n g_timer_stop(). g_timer_stop() must be called before using this\n function.\n Since 2.4\n\t \n",
"line" : 155}
,
{
"name" : "elapsed",
"kind" : "function",
"protection" : "public",
"type" : "double(out ulong microseconds)",
"comment" : "\n If timer has been started but not stopped, obtains the time since\n the timer was started. If timer has been stopped, obtains the\n elapsed time between the time it was started and the time it was\n stopped. The return value is the number of seconds elapsed,\n including any fractional part. The microseconds out parameter is\n essentially useless.\n Warning\n  Calling initialization functions, in particular g_thread_init(), while a\n  timer is running will cause invalid return values from this function.\n Params:\n microseconds = return location for the fractional part of seconds\n  elapsed, in microseconds (that is, the total number\n  of microseconds elapsed, modulo 1000000), or NULL\n Returns: seconds elapsed as a floating point value, including any fractional part.\n\t \n",
"line" : 177}
,
{
"name" : "reset",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n This function is useless; it's fine to call g_timer_start() on an\n already-started timer to reset the start time, so g_timer_reset()\n serves no purpose.\n\t \n",
"line" : 188}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Destroys a timer, freeing associated resources.\n\t \n",
"line" : 197}
]
}
]
}
,
{
"name" : "glib.TimeVal",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/TimeVal.d",
"members" : [
{
"name" : "TimeVal",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n The GDate data structure represents a day between January 1, Year 1,\n and sometime a few thousand years in the future (right now it will go\n to the year 65535 or so, but g_date_set_parse() only parses up to the\n year 8000 or so - just count on \"a few thousand\"). GDate is meant to\n represent everyday dates, not astronomical dates or historical dates\n or ISO timestamps or the like. It extrapolates the current Gregorian\n calendar forward and backward in time; there is no attempt to change\n the calendar to match time periods or locations. GDate does not store\n time information; it represents a day.\n The GDate implementation has several nice features; it is only a\n 64-bit struct, so storing large numbers of dates is very efficient. It\n can keep both a Julian and day-month-year representation of the date,\n since some calculations are much easier with one representation or the\n other. A Julian representation is simply a count of days since some\n fixed day in the past; for GDate the fixed day is January 1, 1 AD.\n (\"Julian\" dates in the GDate API aren't really Julian dates in the\n technical sense; technically, Julian dates count from the start of the\n Julian period, Jan 1, 4713 BC).\n GDate is simple to use. First you need a \"blank\" date; you can get a\n dynamically allocated date from g_date_new(), or you can declare an\n automatic variable or array and initialize it to a sane state by\n calling g_date_clear(). A cleared date is sane; it's safe to call\n g_date_set_dmy() and the other mutator functions to initialize the\n value of a cleared date. However, a cleared date is initially\n invalid, meaning that it doesn't represent a day\n that exists. It is undefined to call any of the date calculation\n routines on an invalid date. If you obtain a date from a user or other\n unpredictable source, you should check its validity with the\n g_date_valid() predicate. g_date_valid() is also used to check for\n errors with g_date_set_parse() and other functions that can\n fail. Dates can be invalidated by calling g_date_clear() again.\n It is very important to use the API to access the GDate\n struct. Often only the day-month-year or only the Julian\n representation is valid. Sometimes neither is valid. Use the API.\n GLib doesn't contain any time-manipulation functions; however, there\n is a GTime typedef and a GTimeVal struct which represents a more\n precise time (with microseconds). You can request the current time as\n a GTimeVal with g_get_current_time().\n \n",
"line" : 109,
"base" : "Object",
"members" : [
{
"name" : "gTimeVal",
"kind" : "variable",
"protection" : "protected",
"type" : "GTimeVal*",
"comment" : " the main Gtk struct \n",
"line" : 112}
,
{
"name" : "getTimeValStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTimeVal*()",
"line" : 115}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 122}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TimeVal(GTimeVal* gTimeVal)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 130}
,
{
"name" : "getCurrentTime",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Equivalent to the UNIX gettimeofday() function, but portable.\n\t \n",
"line" : 146}
,
{
"name" : "usleep",
"kind" : "function",
"protection" : "public",
"type" : "void(ulong microseconds)",
"comment" : "\n Pauses the current thread for the given number of microseconds. There\n are 1 million microseconds per second (represented by the\n G_USEC_PER_SEC macro). g_usleep() may have limited precision,\n depending on hardware and operating system; don't rely on the exact\n length of the sleep.\n Params:\n microseconds = number of microseconds to pause\n\t \n",
"line" : 161}
,
{
"name" : "add",
"kind" : "function",
"protection" : "public",
"type" : "void(long microseconds)",
"comment" : "\n Adds the given number of microseconds to time_. microseconds can\n also be negative to decrease the value of time_.\n Params:\n microseconds = number of microseconds to add to time\n\t \n",
"line" : 173}
,
{
"name" : "fromIso8601",
"kind" : "function",
"protection" : "public",
"type" : "int(string isoDate, GTimeVal* time)",
"comment" : "\n Converts a string containing an ISO 8601 encoded date and time\n to a GTimeVal and puts it into time_.\n Since 2.12\n Params:\n isoDate = an ISO 8601 encoded date string\n time = a GTimeVal\n Returns: TRUE if the conversion was successful.\n\t \n",
"line" : 188}
,
{
"name" : "toIso8601",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Converts time_ into an ISO 8601 encoded string, relative to the\n Coordinated Universal Time (UTC).\n Since 2.12\n Returns: a newly allocated string containing an ISO 8601 date\n\t \n",
"line" : 200}
]
}
]
}
,
{
"name" : "glib.TimeZone",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/TimeZone.d",
"members" : [
{
"name" : "TimeZone",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GTimeZone is a structure that represents a time zone, at no\n particular point in time. It is refcounted and immutable.\n GTimeZone is available since GLib 2.26.\n \n",
"line" : 75,
"base" : "Object",
"members" : [
{
"name" : "gTimeZone",
"kind" : "variable",
"protection" : "protected",
"type" : "GTimeZone*",
"comment" : " the main Gtk struct \n",
"line" : 78}
,
{
"name" : "getTimeZoneStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTimeZone*()",
"line" : 81}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 88}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TimeZone(GTimeZone* gTimeZone)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 96}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Decreases the reference count on tz.\n Since 2.26\n\t \n",
"line" : 113}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "TimeZone()",
"comment" : "\n Increases the reference count on tz.\n Since 2.26\n Returns: a new reference to tz.\n\t \n",
"line" : 124}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TimeZone(string identifier)",
"comment" : "\n Creates a GTimeZone corresponding to identifier.\n identifier can either be an RFC3339\/ISO 8601 time offset or\n something that would pass as a valid value for the\n TZ environment variable (including NULL).\n Valid RFC3339 time offsets are \"Z\" (for UTC) or\n \"±hh:mm\". ISO 8601 additionally specifies\n \"±hhmm\" and \"±hh\".\n The TZ environment variable typically corresponds\n to the name of a file in the zoneinfo database, but there are many\n other possibilities. Note that those other possibilities are not\n currently implemented, but are planned.\n g_time_zone_new_local() calls this function with the value of the\n TZ environment variable. This function itself is\n independent of the value of TZ, but if identifier\n is NULL then \/etc\/localtime will be consulted\n to discover the correct timezone.\n See RFC3339\n §5.6 for a precise definition of valid RFC3339 time offsets\n (the time-offset expansion) and ISO 8601 for the\n full list of valid time offsets. See The\n GNU C Library manual for an explanation of the possible\n values of the TZ environment variable.\n You should release the return value by calling g_time_zone_unref()\n when you are done with it.\n Since 2.26\n Params:\n identifier = a timezone identifier. [allow-none]\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 165}
]
}
]
}
,
{
"name" : "glib.TrashStack",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/TrashStack.d",
"members" : [
{
"name" : "TrashStack",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GTrashStack is an efficient way to keep a stack of unused allocated\n memory chunks. Each memory chunk is required to be large enough to hold\n a gpointer. This allows the stack to be maintained without any space\n overhead, since the stack pointers can be stored inside the memory chunks.\n There is no function to create a GTrashStack. A NULL GTrashStack*\n is a perfectly valid empty stack.\n \n",
"line" : 73,
"base" : "Object",
"members" : [
{
"name" : "gTrashStack",
"kind" : "variable",
"protection" : "protected",
"type" : "GTrashStack*",
"comment" : " the main Gtk struct \n",
"line" : 76}
,
{
"name" : "getTrashStackStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTrashStack*()",
"line" : 79}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 86}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "TrashStack(GTrashStack* gTrashStack)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 94}
,
{
"name" : "push",
"kind" : "function",
"protection" : "public",
"type" : "void(GTrashStack** stackP, void* dataP)",
"comment" : "\n\t \n\n Pushes a piece of memory onto a GTrashStack.\n Params:\n stackP = a pointer to a GTrashStack.\n dataP = the piece of memory to push on the stack.\n\t \n",
"line" : 113}
,
{
"name" : "pop",
"kind" : "function",
"protection" : "public",
"type" : "void*(GTrashStack** stackP)",
"comment" : "\n Pops a piece of memory off a GTrashStack.\n Params:\n stackP = a pointer to a GTrashStack.\n Returns: the element at the top of the stack.\n\t \n",
"line" : 125}
,
{
"name" : "peek",
"kind" : "function",
"protection" : "public",
"type" : "void*(GTrashStack** stackP)",
"comment" : "\n Returns the element at the top of a GTrashStack which may be NULL.\n Params:\n stackP = a pointer to a GTrashStack.\n Returns: the element at the top of the stack.\n\t \n",
"line" : 137}
,
{
"name" : "height",
"kind" : "function",
"protection" : "public",
"type" : "uint(GTrashStack** stackP)",
"comment" : "\n Returns the height of a GTrashStack.\n Note that execution of this function is of O(N) complexity\n where N denotes the number of items on the stack.\n Params:\n stackP = a pointer to a GTrashStack.\n Returns: the height of the stack.\n\t \n",
"line" : 151}
]
}
]
}
,
{
"name" : "glib.Tuples",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Tuples.d",
"members" : [
{
"name" : "Tuples",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n A GRelation is a table of data which can be indexed on any number\n of fields, rather like simple database tables. A GRelation contains\n a number of records, called tuples. Each record contains a number of\n fields. Records are not ordered, so it is not possible to find the\n record at a particular index.\n Note that GRelation tables are currently limited to 2 fields.\n To create a GRelation, use g_relation_new().\n To specify which fields should be indexed, use g_relation_index().\n Note that this must be called before any tuples are added to the\n GRelation.\n To add records to a GRelation use g_relation_insert().\n To determine if a given record appears in a GRelation, use\n g_relation_exists(). Note that fields are compared directly, so\n pointers must point to the exact same position (i.e. different\n copies of the same string will not match.)\n To count the number of records which have a particular value in a\n given field, use g_relation_count().\n To get all the records which have a particular value in a given\n field, use g_relation_select(). To access fields of the resulting\n records, use g_tuples_index(). To free the resulting records use\n g_tuples_destroy().\n To delete all records which have a particular value in a given\n field, use g_relation_delete().\n To destroy the GRelation, use g_relation_destroy().\n To help debug GRelation objects, use g_relation_print().\n GRelation has been marked as deprecated, since this API has never\n been fully implemented, is not very actively maintained and rarely\n used.\n \n",
"line" : 95,
"base" : "Object",
"members" : [
{
"name" : "gTuples",
"kind" : "variable",
"protection" : "protected",
"type" : "GTuples*",
"comment" : " the main Gtk struct \n",
"line" : 98}
,
{
"name" : "getTuplesStruct",
"kind" : "function",
"protection" : "public",
"type" : "GTuples*()",
"line" : 101}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 108}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Tuples(GTuples* gTuples)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 116}
,
{
"name" : "destroy",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Warning\n g_tuples_destroy has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Frees the records which were returned by g_relation_select(). This\n should always be called after g_relation_select() when you are\n finished with the records. The records are not removed from the\n GRelation.\n\t \n",
"line" : 137}
,
{
"name" : "index",
"kind" : "function",
"protection" : "public",
"type" : "void*(int index, int field)",
"comment" : "\n Warning\n g_tuples_index has been deprecated since version 2.26 and should not be used in newly-written code. Rarely used API\n Gets a field from the records returned by g_relation_select(). It\n returns the given field of the record at the given index. The\n returned value should not be changed.\n Params:\n index = the index of the record.\n field = the field to return.\n Returns: the field of the record.\n\t \n",
"line" : 154}
]
}
]
}
,
{
"name" : "glib.Unicode",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Unicode.d",
"members" : [
{
"name" : "Unicode",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This section describes a number of functions for dealing with\n Unicode characters and strings. There are analogues of the\n traditional ctype.h character classification\n and case conversion functions, UTF-8 analogues of some string utility\n functions, functions to perform normalization, case conversion and\n collation on UTF-8 strings and finally functions to convert between\n the UTF-8, UTF-16 and UCS-4 encodings of Unicode.\n The implementations of the Unicode functions in GLib are based\n on the Unicode Character Data tables, which are available from\n www.unicode.org.\n GLib 2.8 supports Unicode 4.0, GLib 2.10 supports Unicode 4.1,\n GLib 2.12 supports Unicode 5.0, GLib 2.16.3 supports Unicode 5.1.\n \n",
"line" : 85,
"base" : "Object",
"members" : [
{
"name" : "unicharValidate",
"kind" : "function",
"protection" : "public",
"type" : "int(uint ch)",
"comment" : "\n\t \n\n Checks whether ch is a valid Unicode character. Some possible\n integer values of ch will not be valid. 0 is considered a valid\n character, though it's normally a string terminator.\n Params:\n ch = a Unicode character\n Returns: TRUE if ch is a valid Unicode character\n\t \n",
"line" : 98}
,
{
"name" : "unicharIsalnum",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is alphanumeric.\n Given some UTF-8 text, obtain a character value\n with g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is an alphanumeric character\n\t \n",
"line" : 112}
,
{
"name" : "unicharIsalpha",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is alphabetic (i.e. a letter).\n Given some UTF-8 text, obtain a character value with\n g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is an alphabetic character\n\t \n",
"line" : 126}
,
{
"name" : "unicharIscntrl",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is a control character.\n Given some UTF-8 text, obtain a character value with\n g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is a control character\n\t \n",
"line" : 140}
,
{
"name" : "unicharIsdefined",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a given character is assigned in the Unicode\n standard.\n Params:\n c = a Unicode character\n Returns: TRUE if the character has an assigned value\n\t \n",
"line" : 153}
,
{
"name" : "unicharIsdigit",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is numeric (i.e. a digit). This\n covers ASCII 0-9 and also digits in other languages\/scripts. Given\n some UTF-8 text, obtain a character value with g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is a digit\n\t \n",
"line" : 167}
,
{
"name" : "unicharIsgraph",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is printable and not a space\n (returns FALSE for control characters, format characters, and\n spaces). g_unichar_isprint() is similar, but returns TRUE for\n spaces. Given some UTF-8 text, obtain a character value with\n g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is printable unless it's a space\n\t \n",
"line" : 183}
,
{
"name" : "unicharIslower",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is a lowercase letter.\n Given some UTF-8 text, obtain a character value with\n g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is a lowercase letter\n\t \n",
"line" : 197}
,
{
"name" : "unicharIsmark",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is a mark (non-spacing mark,\n combining mark, or enclosing mark in Unicode speak).\n Given some UTF-8 text, obtain a character value\n with g_utf8_get_char().\n Note: in most cases where isalpha characters are allowed,\n ismark characters should be allowed to as they are essential\n for writing most European languages as well as many non-Latin\n scripts.\n Since 2.14\n Params:\n c = a Unicode character\n Returns: TRUE if c is a mark character\n\t \n",
"line" : 217}
,
{
"name" : "unicharIsprint",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is printable.\n Unlike g_unichar_isgraph(), returns TRUE for spaces.\n Given some UTF-8 text, obtain a character value with\n g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is printable\n\t \n",
"line" : 232}
,
{
"name" : "unicharIspunct",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is punctuation or a symbol.\n Given some UTF-8 text, obtain a character value with\n g_utf8_get_char().\n Params:\n c = a Unicode character\n Returns: TRUE if c is a punctuation or symbol character\n\t \n",
"line" : 246}
,
{
"name" : "unicharIsspace",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines whether a character is a space, tab, or line separator\n (newline, carriage return, etc.). Given some UTF-8 text, obtain a\n character value with g_utf8_get_char().\n (Note: don't use this to do word breaking; you have to use\n Pango or equivalent to get word breaking right, the algorithm\n is fairly complex.)\n Params:\n c = a Unicode character\n Returns: TRUE if c is a space character\n\t \n",
"line" : 263}
,
{
"name" : "unicharIstitle",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a character is titlecase. Some characters in\n Unicode which are composites, such as the DZ digraph\n have three case variants instead of just two. The titlecase\n form is used at the beginning of a word where only the\n first letter is capitalized. The titlecase form of the DZ\n digraph is U+01F2 LATIN CAPITAL LETTTER D WITH SMALL LETTER Z.\n Params:\n c = a Unicode character\n Returns: TRUE if the character is titlecase\n\t \n",
"line" : 280}
,
{
"name" : "unicharIsupper",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a character is uppercase.\n Params:\n c = a Unicode character\n Returns: TRUE if c is an uppercase character\n\t \n",
"line" : 292}
,
{
"name" : "unicharIsxdigit",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a character is a hexidecimal digit.\n Params:\n c = a Unicode character.\n Returns: TRUE if the character is a hexadecimal digit\n\t \n",
"line" : 304}
,
{
"name" : "unicharIswide",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a character is typically rendered in a double-width\n cell.\n Params:\n c = a Unicode character\n Returns: TRUE if the character is wide\n\t \n",
"line" : 317}
,
{
"name" : "unicharIswideCjk",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a character is typically rendered in a double-width\n cell under legacy East Asian locales. If a character is wide according to\n g_unichar_iswide(), then it is also reported wide with this function, but\n the converse is not necessarily true. See the\n Unicode Standard\n Annex #11 for details.\n If a character passes the g_unichar_iswide() test then it will also pass\n this test, but not the other way around. Note that some characters may\n pas both this test and g_unichar_iszerowidth().\n Since 2.12\n Params:\n c = a Unicode character\n Returns: TRUE if the character is wide in legacy East Asian locales\n\t \n",
"line" : 338}
,
{
"name" : "unicharIszerowidth",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines if a given character typically takes zero width when rendered.\n The return value is TRUE for all non-spacing and enclosing marks\n (e.g., combining accents), format characters, zero-width\n space, but not U+00AD SOFT HYPHEN.\n A typical use of this function is with one of g_unichar_iswide() or\n g_unichar_iswide_cjk() to determine the number of cells a string occupies\n when displayed on a grid display (terminals). However, note that not all\n terminals support zero-width rendering of zero-width marks.\n Since 2.14\n Params:\n c = a Unicode character\n Returns: TRUE if the character has zero width\n\t \n",
"line" : 358}
,
{
"name" : "unicharToupper",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint c)",
"comment" : "\n Converts a character to uppercase.\n Params:\n c = a Unicode character\n Returns: the result of converting c to uppercase. If c is not an lowercase or titlecase character, or has no upper case equivalent c is returned unchanged.\n\t \n",
"line" : 370}
,
{
"name" : "unicharTolower",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint c)",
"comment" : "\n Converts a character to lower case.\n Params:\n c = a Unicode character.\n Returns: the result of converting c to lower case. If c is not an upperlower or titlecase character, or has no lowercase equivalent c is returned unchanged.\n\t \n",
"line" : 382}
,
{
"name" : "unicharTotitle",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint c)",
"comment" : "\n Converts a character to the titlecase.\n Params:\n c = a Unicode character\n Returns: the result of converting c to titlecase. If c is not an uppercase or lowercase character, c is returned unchanged.\n\t \n",
"line" : 394}
,
{
"name" : "unicharDigitValue",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines the numeric value of a character as a decimal\n digit.\n Params:\n c = a Unicode character\n Returns: If c is a decimal digit (according to g_unichar_isdigit()), its numeric value. Otherwise, -1.\n\t \n",
"line" : 407}
,
{
"name" : "unicharXdigitValue",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c)",
"comment" : "\n Determines the numeric value of a character as a hexidecimal\n digit.\n Params:\n c = a Unicode character\n Returns: If c is a hex digit (according to g_unichar_isxdigit()), its numeric value. Otherwise, -1.\n\t \n",
"line" : 420}
,
{
"name" : "unicharType",
"kind" : "function",
"protection" : "public",
"type" : "GUnicodeType(uint c)",
"comment" : "\n Classifies a Unicode character by type.\n Params:\n c = a Unicode character\n Returns: the type of the character.\n\t \n",
"line" : 432}
,
{
"name" : "unicharBreakType",
"kind" : "function",
"protection" : "public",
"type" : "GUnicodeBreakType(uint c)",
"comment" : "\n Determines the break type of c. c should be a Unicode character\n (to derive a character from UTF-8 encoded text, use\n g_utf8_get_char()). The break type is used to find word and line\n breaks (\"text boundaries\"), Pango implements the Unicode boundary\n resolution algorithms and normally you would use a function such\n as pango_break() instead of caring about break types yourself.\n Params:\n c = a Unicode character\n Returns: the break type of c\n\t \n",
"line" : 449}
,
{
"name" : "unicharCombiningClass",
"kind" : "function",
"protection" : "public",
"type" : "int(uint uc)",
"comment" : "\n Determines the canonical combining class of a Unicode character.\n Since 2.14\n Params:\n uc = a Unicode character\n Returns: the combining class of the character\n\t \n",
"line" : 462}
,
{
"name" : "unicodeCanonicalOrdering",
"kind" : "function",
"protection" : "public",
"type" : "void(uint* string, ulong len)",
"comment" : "\n Computes the canonical ordering of a string in-place.\n This rearranges decomposed characters in the string\n according to their combining classes. See the Unicode\n manual for more information.\n Params:\n string = a UCS-4 encoded string.\n len = the maximum length of string to use.\n\t \n",
"line" : 477}
,
{
"name" : "unicodeCanonicalDecomposition",
"kind" : "function",
"protection" : "public",
"type" : "uint*(uint ch, out ulong resultLen)",
"comment" : "\n Computes the canonical decomposition of a Unicode character.\n Params:\n ch = a Unicode character.\n resultLen = location to store the length of the return value.\n Returns: a newly allocated string of Unicode characters. result_len is set to the resulting length of the string.\n\t \n",
"line" : 490}
,
{
"name" : "unicharGetMirrorChar",
"kind" : "function",
"protection" : "public",
"type" : "int(uint ch, uint* mirroredCh)",
"comment" : "\n In Unicode, some characters are mirrored. This\n means that their images are mirrored horizontally in text that is laid\n out from right to left. For instance, \"(\" would become its mirror image,\n \")\", in right-to-left text.\n If ch has the Unicode mirrored property and there is another unicode\n character that typically has a glyph that is the mirror image of ch's\n glyph and mirrored_ch is set, it puts that character in the address\n pointed to by mirrored_ch. Otherwise the original character is put.\n Since 2.4\n Params:\n ch = a Unicode character\n mirroredCh = location to store the mirrored character\n Returns: TRUE if ch has a mirrored character, FALSE otherwise\n\t \n",
"line" : 511}
,
{
"name" : "unicharGetScript",
"kind" : "function",
"protection" : "public",
"type" : "GUnicodeScript(uint ch)",
"comment" : "\n Looks up the GUnicodeScript for a particular character (as defined\n by Unicode Standard Annex 24). No check is made for ch being a\n valid Unicode character; if you pass in invalid character, the\n result is undefined.\n This function is equivalent to pango_script_for_unichar() and the\n two are interchangeable.\n Since 2.14\n Params:\n ch = a Unicode character\n Returns: the GUnicodeScript for the character.\n\t \n",
"line" : 529}
,
{
"name" : "utf8_GetChar",
"kind" : "function",
"protection" : "public",
"type" : "uint(string p)",
"comment" : "\n Converts a sequence of bytes encoded as UTF-8 to a Unicode character.\n If p does not point to a valid UTF-8 encoded character, results are\n undefined. If you are not sure that the bytes are complete\n valid Unicode characters, you should use g_utf8_get_char_validated()\n instead.\n Params:\n p = a pointer to Unicode character encoded as UTF-8\n Returns: the resulting character\n\t \n",
"line" : 545}
,
{
"name" : "utf8_GetCharValidated",
"kind" : "function",
"protection" : "public",
"type" : "uint(string p, long maxLen)",
"comment" : "\n Convert a sequence of bytes encoded as UTF-8 to a Unicode character.\n This function checks for incomplete characters, for invalid characters\n such as characters that are out of the range of Unicode, and for\n overlong encodings of valid characters.\n Params:\n p = a pointer to Unicode character encoded as UTF-8\n maxLen = the maximum number of bytes to read, or -1, for no maximum or\n  if p is nul-terminated\n Returns: the resulting character. If p points to a partial sequence at the end of a string that could begin a valid character (or if max_len is zero), returns (gunichar)-2; otherwise, if p does not point to a valid UTF-8 encoded Unicode character, returns (gunichar)-1.\n\t \n",
"line" : 562}
,
{
"name" : "utf8_OffsetToPointer",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long offset)",
"comment" : "\n Converts from an integer character offset to a pointer to a position\n within the string.\n Since 2.10, this function allows to pass a negative offset to\n step backwards. It is usually worth stepping backwards from the end\n instead of forwards if offset is in the last fourth of the string,\n since moving forward is about 3 times faster than moving backward.\n Note\n This function doesn't abort when reaching the end of str. Therefore\n you should be sure that offset is within string boundaries before\n calling that function. Call g_utf8_strlen() when unsure.\n This limitation exists as this function is called frequently during\n text rendering and therefore has to be as fast as possible.\n Params:\n str = a UTF-8 encoded string\n offset = a character offset within str\n Returns: the resulting pointer\n\t \n",
"line" : 586}
,
{
"name" : "utf8_PointerToOffset",
"kind" : "function",
"protection" : "public",
"type" : "long(string str, string pos)",
"comment" : "\n Converts from a pointer to position within a string to a integer\n character offset.\n Since 2.10, this function allows pos to be before str, and returns\n a negative offset in this case.\n Params:\n str = a UTF-8 encoded string\n pos = a pointer to a position within str\n Returns: the resulting character offset\n\t \n",
"line" : 602}
,
{
"name" : "utf8_PrevChar",
"kind" : "function",
"protection" : "public",
"type" : "string(string p)",
"comment" : "\n Finds the previous UTF-8 character in the string before p.\n p does not have to be at the beginning of a UTF-8 character. No check\n is made to see if the character found is actually valid other than\n it starts with an appropriate byte. If p might be the first\n character of the string, you must use g_utf8_find_prev_char() instead.\n Params:\n p = a pointer to a position within a UTF-8 encoded string\n Returns: a pointer to the found character.\n\t \n",
"line" : 618}
,
{
"name" : "utf8_FindNextChar",
"kind" : "function",
"protection" : "public",
"type" : "string(string p, string end)",
"comment" : "\n Finds the start of the next UTF-8 character in the string after p.\n p does not have to be at the beginning of a UTF-8 character. No check\n is made to see if the character found is actually valid other than\n it starts with an appropriate byte.\n Params:\n p = a pointer to a position within a UTF-8 encoded string\n end = a pointer to the byte following the end of the string,\n or NULL to indicate that the string is nul-terminated.\n Returns: a pointer to the found character or NULL\n\t \n",
"line" : 635}
,
{
"name" : "utf8_FindPrevChar",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, string p)",
"comment" : "\n Given a position p with a UTF-8 encoded string str, find the start\n of the previous UTF-8 character starting before p. Returns NULL if no\n UTF-8 characters are present in str before p.\n p does not have to be at the beginning of a UTF-8 character. No check\n is made to see if the character found is actually valid other than\n it starts with an appropriate byte.\n Params:\n str = pointer to the beginning of a UTF-8 encoded string\n p = pointer to some position within str\n Returns: a pointer to the found character or NULL.\n\t \n",
"line" : 653}
,
{
"name" : "utf8_Strlen",
"kind" : "function",
"protection" : "public",
"type" : "long(string p, long max)",
"comment" : "\n Computes the length of the string in characters, not including\n the terminating nul character.\n Params:\n p = pointer to the start of a UTF-8 encoded string\n max = the maximum number of bytes to examine. If max\n  is less than 0, then the string is assumed to be\n  nul-terminated. If max is 0, p will not be examined and\n  may be NULL.\n Returns: the length of the string in characters\n\t \n",
"line" : 670}
,
{
"name" : "utf8_Strncpy",
"kind" : "function",
"protection" : "public",
"type" : "string(string dest, string src, ulong n)",
"comment" : "\n Like the standard C strncpy() function, but\n copies a given number of characters instead of a given number of\n bytes. The src string must be valid UTF-8 encoded text.\n (Use g_utf8_validate() on all text before trying to use UTF-8\n utility functions with it.)\n Params:\n dest = buffer to fill with characters from src\n src = UTF-8 encoded string\n n = character count\n Returns: dest\n\t \n",
"line" : 688}
,
{
"name" : "utf8_Strchr",
"kind" : "function",
"protection" : "public",
"type" : "string(string p, long len, uint c)",
"comment" : "\n Finds the leftmost occurrence of the given Unicode character\n in a UTF-8 encoded string, while limiting the search to len bytes.\n If len is -1, allow unbounded search.\n Params:\n p = a nul-terminated UTF-8 encoded string\n len = the maximum length of p\n c = a Unicode character\n Returns: NULL if the string does not contain the character, otherwise, a pointer to the start of the leftmost occurrence of the character in the string.\n\t \n",
"line" : 704}
,
{
"name" : "utf8_Strrchr",
"kind" : "function",
"protection" : "public",
"type" : "string(string p, long len, uint c)",
"comment" : "\n Find the rightmost occurrence of the given Unicode character\n in a UTF-8 encoded string, while limiting the search to len bytes.\n If len is -1, allow unbounded search.\n Params:\n p = a nul-terminated UTF-8 encoded string\n len = the maximum length of p\n c = a Unicode character\n Returns: NULL if the string does not contain the character, otherwise, a pointer to the start of the rightmost occurrence of the character in the string.\n\t \n",
"line" : 720}
,
{
"name" : "utf8_Strreverse",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Reverses a UTF-8 string. str must be valid UTF-8 encoded text.\n (Use g_utf8_validate() on all text before trying to use UTF-8\n utility functions with it.)\n This function is intended for programmatic uses of reversed strings.\n It pays no attention to decomposed characters, combining marks, byte\n order marks, directional indicators (LRM, LRO, etc) and similar\n characters which might need special handling when reversing a string\n for display purposes.\n Note that unlike g_strreverse(), this function returns\n newly-allocated memory, which should be freed with g_free() when\n no longer needed.\n Since 2.2\n Params:\n str = a UTF-8 encoded string\n len = the maximum length of str to use, in bytes. If len < 0,\n  then the string is nul-terminated.\n Returns: a newly-allocated string which is the reverse of str.\n\t \n",
"line" : 745}
,
{
"name" : "utf8_Validate",
"kind" : "function",
"protection" : "public",
"type" : "int(string str, long maxLen, out string end)",
"comment" : "\n Validates UTF-8 encoded text. str is the text to validate;\n if str is nul-terminated, then max_len can be -1, otherwise\n max_len should be the number of bytes to validate.\n If end is non-NULL, then the end of the valid range\n will be stored there (i.e. the start of the first invalid\n character if some bytes were invalid, or the end of the text\n being validated otherwise).\n Note that g_utf8_validate() returns FALSE if max_len is\n positive and NUL is met before max_len bytes have been read.\n Returns TRUE if all of str was valid. Many GLib and GTK+\n routines require valid UTF-8 as input;\n so data read from a file or the network should be checked\n with g_utf8_validate() before doing anything else with it.\n Params:\n str = a pointer to character data\n maxLen = max bytes to validate, or -1 to go until NUL\n end = return location for end of valid data\n Returns: TRUE if the text was valid UTF-8\n\t \n",
"line" : 771}
,
{
"name" : "utf8_Strup",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts all Unicode characters in the string that have a case\n to uppercase. The exact manner that this is done depends\n on the current locale, and may result in the number of\n characters in the string increasing. (For instance, the\n German ess-zet will be changed to SS.)\n Params:\n str = a UTF-8 encoded string\n len = length of str, in bytes, or -1 if str is nul-terminated.\n Returns: a newly allocated string, with all characters converted to uppercase.\n\t \n",
"line" : 793}
,
{
"name" : "utf8_Strdown",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts all Unicode characters in the string that have a case\n to lowercase. The exact manner that this is done depends\n on the current locale, and may result in the number of\n characters in the string changing.\n Params:\n str = a UTF-8 encoded string\n len = length of str, in bytes, or -1 if str is nul-terminated.\n Returns: a newly allocated string, with all characters converted to lowercase.\n\t \n",
"line" : 809}
,
{
"name" : "utf8_Casefold",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts a string into a form that is independent of case. The\n result will not correspond to any particular case, but can be\n compared for equality or ordered with the results of calling\n g_utf8_casefold() on other strings.\n Note that calling g_utf8_casefold() followed by g_utf8_collate() is\n only an approximation to the correct linguistic case insensitive\n ordering, though it is a fairly good one. Getting this exactly\n right would require a more sophisticated collation function that\n takes case sensitivity into account. GLib does not currently\n provide such a function.\n Params:\n str = a UTF-8 encoded string\n len = length of str, in bytes, or -1 if str is nul-terminated.\n Returns: a newly allocated string, that is a case independent form of str.\n\t \n",
"line" : 831}
,
{
"name" : "utf8_Normalize",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len, GNormalizeMode mode)",
"comment" : "\n Converts a string into canonical form, standardizing\n such issues as whether a character with an accent\n is represented as a base character and combining\n accent or as a single precomposed character. The\n string has to be valid UTF-8, otherwise NULL is\n returned. You should generally call g_utf8_normalize()\n before comparing two Unicode strings.\n The normalization mode G_NORMALIZE_DEFAULT only\n standardizes differences that do not affect the\n text content, such as the above-mentioned accent\n representation. G_NORMALIZE_ALL also standardizes\n the \"compatibility\" characters in Unicode, such\n as SUPERSCRIPT THREE to the standard forms\n (in this case DIGIT THREE). Formatting information\n may be lost but for most text operations such\n characters should be considered the same.\n G_NORMALIZE_DEFAULT_COMPOSE and G_NORMALIZE_ALL_COMPOSE\n are like G_NORMALIZE_DEFAULT and G_NORMALIZE_ALL,\n but returned a result with composed forms rather\n than a maximally decomposed form. This is often\n useful if you intend to convert the string to\n a legacy encoding or pass it to a system with\n less capable Unicode handling.\n Params:\n str = a UTF-8 encoded string.\n len = length of str, in bytes, or -1 if str is nul-terminated.\n mode = the type of normalization to perform.\n Returns: a newly allocated string, that is the normalized form of str, or NULL if str is not valid UTF-8.\n\t \n",
"line" : 867}
,
{
"name" : "utf8_Collate",
"kind" : "function",
"protection" : "public",
"type" : "int(string str1, string str2)",
"comment" : "\n Compares two strings for ordering using the linguistically\n correct rules for the current locale.\n When sorting a large number of strings, it will be significantly\n faster to obtain collation keys with g_utf8_collate_key() and\n compare the keys with strcmp() when sorting instead of sorting\n the original strings.\n Params:\n str1 = a UTF-8 encoded string\n str2 = a UTF-8 encoded string\n Returns: < 0 if str1 compares before str2, 0 if they compare equal, > 0 if str1 compares after str2.\n\t \n",
"line" : 885}
,
{
"name" : "utf8_CollateKey",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts a string into a collation key that can be compared\n with other collation keys produced by the same function using\n strcmp().\n The results of comparing the collation keys of two strings\n with strcmp() will always be the same as comparing the two\n original keys with g_utf8_collate().\n Note that this function depends on the\n current locale.\n Params:\n str = a UTF-8 encoded string.\n len = length of str, in bytes, or -1 if str is nul-terminated.\n Returns: a newly allocated string. This string should be freed with g_free() when you are done with it.\n\t \n",
"line" : 905}
,
{
"name" : "utf8_CollateKeyForFilename",
"kind" : "function",
"protection" : "public",
"type" : "string(string str, long len)",
"comment" : "\n Converts a string into a collation key that can be compared\n with other collation keys produced by the same function using strcmp().\n In order to sort filenames correctly, this function treats the dot '.'\n as a special case. Most dictionary orderings seem to consider it\n insignificant, thus producing the ordering \"event.c\" \"eventgenerator.c\"\n \"event.h\" instead of \"event.c\" \"event.h\" \"eventgenerator.c\". Also, we\n would like to treat numbers intelligently so that \"file1\" \"file10\" \"file5\"\n is sorted as \"file1\" \"file5\" \"file10\".\n Note that this function depends on the\n current locale.\n Since 2.8\n Params:\n str = a UTF-8 encoded string.\n len = length of str, in bytes, or -1 if str is nul-terminated.\n Returns: a newly allocated string. This string should be freed with g_free() when you are done with it.\n\t \n",
"line" : 928}
,
{
"name" : "utf8_ToUtf16",
"kind" : "function",
"protection" : "public",
"type" : "ushort*(string str, long len, out long itemsRead, out long itemsWritten)",
"comment" : "\n Convert a string from UTF-8 to UTF-16. A 0 character will be\n added to the result after the converted text.\n Params:\n str = a UTF-8 encoded string\n len = the maximum length (number of bytes) of str to use.\n  If len < 0, then the string is nul-terminated.\n itemsRead = location to store number of bytes read, or NULL.\n  If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be\n  returned in case str contains a trailing partial\n  character. If an error occurs then the index of the\n  invalid input is stored here.\n itemsWritten = location to store number of gunichar2 written,\n  or NULL.\n  The value stored here does not include the trailing 0.\n Returns: a pointer to a newly allocated UTF-16 string. This value must be freed with g_free(). If an error occurs, NULL will be returned and error set.\n Throws: GException on failure.\n\t \n",
"line" : 952}
,
{
"name" : "utf8_ToUcs4",
"kind" : "function",
"protection" : "public",
"type" : "uint*(string str, long len, out long itemsRead, out long itemsWritten)",
"comment" : "\n Convert a string from UTF-8 to a 32-bit fixed width\n representation as UCS-4. A trailing 0 will be added to the\n string after the converted text.\n Params:\n str = a UTF-8 encoded string\n len = the maximum length of str to use, in bytes. If len < 0,\n  then the string is nul-terminated.\n itemsRead = location to store number of bytes read, or NULL.\n  If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be\n  returned in case str contains a trailing partial\n  character. If an error occurs then the index of the\n  invalid input is stored here.\n itemsWritten = location to store number of characters written or NULL.\n  The value here stored does not include the trailing 0\n  character.\n Returns: a pointer to a newly allocated UCS-4 string. This value must be freed with g_free(). If an error occurs, NULL will be returned and error set.\n Throws: GException on failure.\n\t \n",
"line" : 986}
,
{
"name" : "utf8_ToUcs4_Fast",
"kind" : "function",
"protection" : "public",
"type" : "uint*(string str, long len, out long itemsWritten)",
"comment" : "\n Convert a string from UTF-8 to a 32-bit fixed width\n representation as UCS-4, assuming valid UTF-8 input.\n This function is roughly twice as fast as g_utf8_to_ucs4()\n but does no error checking on the input.\n Params:\n str = a UTF-8 encoded string\n len = the maximum length of str to use, in bytes. If len < 0,\n  then the string is nul-terminated.\n itemsWritten = location to store the number of characters in the\n  result, or NULL.\n Returns: a pointer to a newly allocated UCS-4 string. This value must be freed with g_free().\n\t \n",
"line" : 1014}
,
{
"name" : "utf16_ToUcs4",
"kind" : "function",
"protection" : "public",
"type" : "uint*(ushort* str, long len, out long itemsRead, out long itemsWritten)",
"comment" : "\n Convert a string from UTF-16 to UCS-4. The result will be\n nul-terminated.\n Params:\n str = a UTF-16 encoded string\n len = the maximum length (number of gunichar2) of str to use.\n  If len < 0, then the string is nul-terminated.\n itemsRead = location to store number of words read, or NULL.\n  If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be\n  returned in case str contains a trailing partial\n  character. If an error occurs then the index of the\n  invalid input is stored here.\n itemsWritten = location to store number of characters written, or NULL.\n  The value stored here does not include the trailing\n  0 character.\n Returns: a pointer to a newly allocated UCS-4 string. This value must be freed with g_free(). If an error occurs, NULL will be returned and error set.\n Throws: GException on failure.\n\t \n",
"line" : 1038}
,
{
"name" : "utf16_ToUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(ushort* str, long len, out long itemsRead, out long itemsWritten)",
"comment" : "\n Convert a string from UTF-16 to UTF-8. The result will be\n terminated with a 0 byte.\n Note that the input is expected to be already in native endianness,\n an initial byte-order-mark character is not handled specially.\n g_convert() can be used to convert a byte buffer of UTF-16 data of\n ambiguous endianess.\n Further note that this function does not validate the result\n string; it may e.g. include embedded NUL characters. The only\n validation done by this function is to ensure that the input can\n be correctly interpreted as UTF-16, i.e. it doesn't contain\n things unpaired surrogates.\n Params:\n str = a UTF-16 encoded string\n len = the maximum length (number of gunichar2) of str to use.\n  If len < 0, then the string is nul-terminated.\n itemsRead = location to store number of words read, or NULL.\n  If NULL, then G_CONVERT_ERROR_PARTIAL_INPUT will be\n  returned in case str contains a trailing partial\n  character. If an error occurs then the index of the\n  invalid input is stored here.\n itemsWritten = location to store number of bytes written, or NULL.\n  The value stored here does not include the trailing\n  0 byte.\n Returns: a pointer to a newly allocated UTF-8 string. This value must be freed with g_free(). If an error occurs, NULL will be returned and error set.\n Throws: GException on failure.\n\t \n",
"line" : 1080}
,
{
"name" : "ucs4_ToUtf16",
"kind" : "function",
"protection" : "public",
"type" : "ushort*(uint* str, long len, out long itemsRead, out long itemsWritten)",
"comment" : "\n Convert a string from UCS-4 to UTF-16. A 0 character will be\n added to the result after the converted text.\n Params:\n str = a UCS-4 encoded string\n len = the maximum length (number of characters) of str to use.\n  If len < 0, then the string is nul-terminated.\n itemsRead = location to store number of bytes read, or NULL.\n  If an error occurs then the index of the invalid input\n  is stored here.\n itemsWritten = location to store number of gunichar2\n  written, or NULL. The value stored here does not\n  include the trailing 0.\n Returns: a pointer to a newly allocated UTF-16 string. This value must be freed with g_free(). If an error occurs, NULL will be returned and error set.\n Throws: GException on failure.\n\t \n",
"line" : 1111}
,
{
"name" : "ucs4_ToUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(uint* str, long len, out long itemsRead, out long itemsWritten)",
"comment" : "\n Convert a string from a 32-bit fixed width representation as UCS-4.\n to UTF-8. The result will be terminated with a 0 byte.\n Params:\n str = a UCS-4 encoded string\n len = the maximum length (number of characters) of str to use.\n  If len < 0, then the string is nul-terminated.\n itemsRead = location to store number of characters read, or NULL.\n itemsWritten = location to store number of bytes written or NULL.\n  The value here stored does not include the trailing 0\n  byte.\n Returns: a pointer to a newly allocated UTF-8 string. This value must be freed with g_free(). If an error occurs, NULL will be returned and error set. In that case, items_read will be set to the position of the first invalid input character.\n Throws: GException on failure.\n\t \n",
"line" : 1140}
,
{
"name" : "unicharToUtf8",
"kind" : "function",
"protection" : "public",
"type" : "int(uint c, string outbuf)",
"comment" : "\n Converts a single character to UTF-8.\n Params:\n c = a Unicode character code\n outbuf = output buffer, must have at least 6 bytes of space.\n  If NULL, the length will be computed and returned\n  and nothing will be written to outbuf.\n Returns: number of bytes written\n\t \n",
"line" : 1164}
]
}
]
}
,
{
"name" : "glib.URI",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/URI.d",
"members" : [
{
"name" : "URI",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n Functions for manipulating Universal Resource Identifiers (URIs) as\n defined by\n RFC 3986. It is highly recommended that you have read and\n understand RFC 3986 for understanding this API.\n \n",
"line" : 77,
"base" : "Object",
"members" : [
{
"name" : "parseScheme",
"kind" : "function",
"protection" : "public",
"type" : "string(string uri)",
"comment" : "\n\t \n\n Since 2.16\n Params:\n uri = a valid URI.\n Returns: The \"Scheme\" component of the URI, or NULL on error. The returned string should be freed when no longer needed.\n\t \n",
"line" : 88}
,
{
"name" : "escapeString",
"kind" : "function",
"protection" : "public",
"type" : "string(string unescaped, string reservedCharsAllowed, int allowUtf8)",
"comment" : "\n Escapes a string for use in a URI.\n Normally all characters that are not \"unreserved\" (i.e. ASCII alphanumerical\n characters plus dash, dot, underscore and tilde) are escaped.\n But if you specify characters in reserved_chars_allowed they are not\n escaped. This is useful for the \"reserved\" characters in the URI\n specification, since those are allowed unescaped in some portions of\n a URI.\n Since 2.16\n Params:\n unescaped = the unescaped input string.\n reservedCharsAllowed = a string of reserved characters that are\n  allowed to be used, or NULL.\n allowUtf8 = TRUE if the result can include UTF-8 characters.\n Returns: an escaped version of unescaped. The returned string should be freed when no longer needed.\n\t \n",
"line" : 110}
,
{
"name" : "unescapeString",
"kind" : "function",
"protection" : "public",
"type" : "string(string escapedString, string illegalCharacters)",
"comment" : "\n Unescapes a whole escaped string.\n If any of the characters in illegal_characters or the character zero appears\n as an escaped character in escaped_string then that is an error and NULL\n will be returned. This is useful it you want to avoid for instance having a\n slash being expanded in an escaped path element, which might confuse pathname\n handling.\n Since 2.16\n Params:\n escapedString = an escaped string to be unescaped.\n illegalCharacters = an optional string of illegal characters not to be allowed.\n Returns: an unescaped version of escaped_string. The returned string should be freed when no longer needed.\n\t \n",
"line" : 129}
,
{
"name" : "unescapeSegment",
"kind" : "function",
"protection" : "public",
"type" : "string(string escapedString, string escapedStringEnd, string illegalCharacters)",
"comment" : "\n Unescapes a segment of an escaped string.\n If any of the characters in illegal_characters or the character zero appears\n as an escaped character in escaped_string then that is an error and NULL\n will be returned. This is useful it you want to avoid for instance having a\n slash being expanded in an escaped path element, which might confuse pathname\n handling.\n Since 2.16\n Params:\n escapedString = a string.\n escapedStringEnd = a string.\n illegalCharacters = an optional string of illegal characters not to be allowed.\n Returns: an unescaped version of escaped_string or NULL on error. The returned string should be freed when no longer needed.\n\t \n",
"line" : 149}
,
{
"name" : "listExtractUris",
"kind" : "function",
"protection" : "public",
"type" : "string[](string uriList)",
"comment" : "\n Splits an URI list conforming to the text\/uri-list\n mime type defined in RFC 2483 into individual URIs,\n discarding any comments. The URIs are not validated.\n Since 2.6\n Params:\n uriList = an URI list\n Returns: a newly allocated NULL-terminated list of strings holding the individual URIs. The array should be freed with g_strfreev().\n\t \n",
"line" : 164}
,
{
"name" : "gFilenameFromUri",
"kind" : "function",
"protection" : "public",
"type" : "string(string uri, char** hostname)",
"comment" : "\n Converts an escaped ASCII-encoded URI to a local filename in the\n encoding used for filenames.\n Params:\n uri = a uri describing a filename (escaped, encoded in ASCII).\n hostname = Location to store hostname for the URI, or NULL.\n  If there is no hostname in the URI, NULL will be\n  stored in this location.\n Returns: a newly-allocated string holding the resulting filename, or NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 181}
,
{
"name" : "gFilenameToUri",
"kind" : "function",
"protection" : "public",
"type" : "string(string filename, string hostname)",
"comment" : "\n Converts an absolute filename to an escaped ASCII-encoded URI, with the path\n component following Section 3.3. of RFC 2396.\n Params:\n filename = an absolute filename specified in the GLib file name encoding,\n  which is the on-disk file name bytes on Unix, and UTF-8 on\n  Windows\n hostname = A UTF-8 encoded hostname, or NULL for none.\n Returns: a newly-allocated string holding the resulting URI, or NULL on an error.\n Throws: GException on failure.\n\t \n",
"line" : 207}
]
}
]
}
,
{
"name" : "glib.Util",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Util.d",
"members" : [
{
"name" : "Util",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n These are portable utility functions.\n \n",
"line" : 73,
"base" : "Object",
"members" : [
{
"name" : "buildFilename",
"kind" : "function",
"protection" : "public",
"type" : "string(string[] firstElement...)",
"comment" : "\n Creates a filename from a series of elements using the correct\n separator for filenames.\n On Unix, this function behaves identically to g_build_path\n (G_DIR_SEPARATOR_S, first_element, ....).\n On Windows, it takes into account that either the backslash\n (\\ or slash (\/) can be used\n as separator in filenames, but otherwise behaves as on Unix. When\n file pathname separators need to be inserted, the one that last\n previously occurred in the parameters (reading from left to right)\n is used.\n No attempt is made to force the resulting filename to be an absolute\n path. If the first element is a relative path, the result will\n be a relative path.\n Params:\n firstElement =  the first element in the path\n ... =  remaining elements in path, terminated by NULL\n Returns: a newly-allocated string that must be freed with g_free().\n\t \n",
"line" : 94}
,
{
"name" : "buildPath",
"kind" : "function",
"protection" : "public",
"type" : "string(string separator, string[] firstElement...)",
"comment" : "\n Creates a path from a series of elements using separator as the\n separator between elements. At the boundary between two elements,\n any trailing occurrences of separator in the first element, or\n leading occurrences of separator in the second element are removed\n and exactly one copy of the separator is inserted.\n Empty elements are ignored.\n The number of leading copies of the separator on the result is\n the same as the number of leading copies of the separator on\n the first non-empty element.\n The number of trailing copies of the separator on the result is\n the same as the number of trailing copies of the separator on\n the last non-empty element. (Determination of the number of\n trailing copies is done without stripping leading copies, so\n if the separator is ABA, ABABA\n has 1 trailing copy.)\n However, if there is only a single non-empty element, and there\n are no characters in that element not part of the leading or\n trailing separators, then the result is exactly the original value\n of that element.\n Other than for determination of the number of leading and trailing\n copies of the separator, elements consisting only of copies\n of the separator are ignored.\n Params:\n separator =  a string used to separator the elements of the path.\n firstElement =  the first element in the path\n ... =  remaining elements in path, terminated by NULL\n Returns: a newly-allocated string that must be freed with g_free().\n\t \n",
"line" : 129}
,
{
"name" : "getApplicationName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n\t \n\n Gets a human-readable name for the application, as set by\n g_set_application_name(). This name should be localized if\n possible, and is intended for display to the user. Contrast with\n g_get_prgname(), which gets a non-localized name. If\n g_set_application_name() has not been called, returns the result of\n g_get_prgname() (which may be NULL if g_set_prgname() has also not\n been called).\n Since 2.2\n Returns: human-readable application name. may return NULL\n\t \n",
"line" : 149}
,
{
"name" : "setApplicationName",
"kind" : "function",
"protection" : "public",
"type" : "void(string applicationName)",
"comment" : "\n Sets a human-readable name for the application. This name should be\n localized if possible, and is intended for display to the user.\n Contrast with g_set_prgname(), which sets a non-localized name.\n g_set_prgname() will be called automatically by gtk_init(),\n but g_set_application_name() will not.\n Note that for thread safety reasons, this function can only\n be called once.\n The application name will be used in contexts such as error messages,\n or when displaying an application's name in the task list.\n Since 2.2\n Params:\n applicationName = localized name of the application\n\t \n",
"line" : 169}
,
{
"name" : "getPrgname",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the name of the program. This name should not\n be localized, contrast with g_get_application_name().\n (If you are using GDK or GTK+ the program name is set in gdk_init(),\n which is called by gtk_init(). The program name is found by taking\n the last component of argv[0].)\n Returns: the name of the program. The returned string belongs to GLib and must not be modified or freed.\n\t \n",
"line" : 183}
,
{
"name" : "setPrgname",
"kind" : "function",
"protection" : "public",
"type" : "void(string prgname)",
"comment" : "\n Sets the name of the program. This name should not\n be localized, contrast with g_set_application_name(). Note that for\n thread-safety reasons this function can only be called once.\n Params:\n prgname = the name of the program.\n\t \n",
"line" : 196}
,
{
"name" : "getenv",
"kind" : "function",
"protection" : "public",
"type" : "string(string variable)",
"comment" : "\n Returns the value of an environment variable. The name and value\n are in the GLib file name encoding. On UNIX, this means the actual\n bytes which might or might not be in some consistent character set\n and encoding. On Windows, it is in UTF-8. On Windows, in case the\n environment variable's value contains references to other\n environment variables, they are expanded.\n Params:\n variable = the environment variable to get, in the GLib file name encoding.\n Returns: the value of the environment variable, or NULL if the environment variable is not found. The returned string may be overwritten by the next call to g_getenv(), g_setenv() or g_unsetenv().\n\t \n",
"line" : 213}
,
{
"name" : "setenv",
"kind" : "function",
"protection" : "public",
"type" : "int(string variable, string value, int overwrite)",
"comment" : "\n Sets an environment variable. Both the variable's name and value\n should be in the GLib file name encoding. On UNIX, this means that\n they can be any sequence of bytes. On Windows, they should be in\n UTF-8.\n Note that on some systems, when variables are overwritten, the memory\n used for the previous variables and its value isn't reclaimed.\n Since 2.4\n Params:\n variable = the environment variable to set, must not contain '='.\n value = the value for to set the variable to.\n overwrite = whether to change the variable if it already exists.\n Returns: FALSE if the environment variable couldn't be set.\n\t \n",
"line" : 233}
,
{
"name" : "unsetenv",
"kind" : "function",
"protection" : "public",
"type" : "void(string variable)",
"comment" : "\n Removes an environment variable from the environment.\n Note that on some systems, when variables are overwritten, the memory\n used for the previous variables and its value isn't reclaimed.\n Furthermore, this function can't be guaranteed to operate in a\n threadsafe way.\n Since 2.4\n Params:\n variable = the environment variable to remove, must not contain '='.\n\t \n",
"line" : 249}
,
{
"name" : "listenv",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the names of all variables set in the environment.\n Since 2.8\n Returns: a NULL-terminated list of strings which must be freed with g_strfreev(). Programs that want to be portable to Windows should typically use this function and g_getenv() instead of using the environ array from the C library directly. On Windows, the strings in the environ array are in system codepage encoding, while in most of the typical use cases for environment variables in GLib-using programs you want the UTF-8 encoding that this function and g_getenv() provide.\n\t \n",
"line" : 260}
,
{
"name" : "getUserName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the user name of the current user. The encoding of the returned\n string is system-defined. On UNIX, it might be the preferred file name\n encoding, or something else, and there is no guarantee that it is even\n consistent on a machine. On Windows, it is always UTF-8.\n Returns: the user name of the current user.\n\t \n",
"line" : 273}
,
{
"name" : "getRealName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the real name of the user. This usually comes from the user's entry\n in the passwd file. The encoding of the returned\n string is system-defined. (On Windows, it is, however, always UTF-8.)\n If the real user name cannot be determined, the string \"Unknown\" is\n returned.\n Returns: the user's real name.\n\t \n",
"line" : 287}
,
{
"name" : "getUserCacheDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns a base directory in which to store non-essential, cached\n data specific to particular user.\n On UNIX platforms this is determined using the mechanisms described in\n the\n XDG Base Directory Specification.\n In this case the directory retrieved will be XDG_CACHE_HOME.\n On Windows is the directory that serves as a common repository for\n temporary Internet files. A typical path is\n C:\\Documents and Settings\\username\\Local Settings\\Temporary Internet Files.\n See documentation for CSIDL_INTERNET_CACHE.\n Since 2.6\n Returns: a string owned by GLib that must not be modified or freed.\n\t \n",
"line" : 307}
,
{
"name" : "getUserDataDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns a base directory in which to access application data such\n as icons that is customized for a particular user.\n On UNIX platforms this is determined using the mechanisms described in\n the\n XDG Base Directory Specification.\n In this case the directory retrieved will be XDG_DATA_HOME.\n On Windows is the virtual folder that represents the My Documents\n desktop item. See documentation for CSIDL_PERSONAL.\n Since 2.6\n Returns: a string owned by GLib that must not be modified or freed.\n\t \n",
"line" : 325}
,
{
"name" : "getUserConfigDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns a base directory in which to store user-specific application\n configuration information such as user preferences and settings.\n On UNIX platforms this is determined using the mechanisms described in\n the\n XDG Base Directory Specification.\n In this case the directory retrieved will be XDG_CONFIG_HOME.\n On Windows is the directory that serves as a common repository for\n application-specific data. A typical path is\n C:\\Documents and Settings\\username\\Application. See documentation for\n CSIDL_APPDATA.\n Since 2.6\n Returns: a string owned by GLib that must not be modified or freed.\n\t \n",
"line" : 345}
,
{
"name" : "getUserSpecialDir",
"kind" : "function",
"protection" : "public",
"type" : "string(GUserDirectory directory)",
"comment" : "\n Returns the full path of a special directory using its logical id.\n On Unix this is done using the XDG special user directories.\n For compatibility with existing practise, G_USER_DIRECTORY_DESKTOP\n falls back to $HOME\/Desktop when XDG special\n user directories have not been set up.\n Depending on the platform, the user might be able to change the path\n of the special directory without requiring the session to restart; GLib\n will not reflect any change once the special directories are loaded.\n Since 2.14\n Params:\n directory = the logical id of special directory\n Returns: the path to the specified special directory, or NULL if the logical id was not found. The returned string is owned by GLib and should not be modified or freed.\n\t \n",
"line" : 365}
,
{
"name" : "getSystemDataDirs",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Returns an ordered list of base directories in which to access\n system-wide application data.\n On UNIX platforms this is determined using the mechanisms described in\n the\n XDG Base Directory Specification\n In this case the list of directories retrieved will be XDG_DATA_DIRS.\n On Windows the first elements in the list are the Application Data\n and Documents folders for All Users. (These can be determined only\n on Windows 2000 or later and are not present in the list on other\n Windows versions.) See documentation for CSIDL_COMMON_APPDATA and\n CSIDL_COMMON_DOCUMENTS.\n Then follows the \"share\" subfolder in the installation folder for\n the package containing the DLL that calls this function, if it can\n be determined.\n Finally the list contains the \"share\" subfolder in the installation\n folder for GLib, and in the installation folder for the package the\n application's .exe file belongs to.\n The installation folders above are determined by looking up the\n folder where the module (DLL or EXE) in question is located. If the\n folder's name is \"bin\", its parent is used, otherwise the folder\n itself.\n Note that on Windows the returned list can vary depending on where\n this function is called.\n Since 2.6\n Returns: a NULL-terminated array of strings owned by GLib that must not be modified or freed.\n\t \n",
"line" : 398}
,
{
"name" : "getSystemConfigDirs",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Returns an ordered list of base directories in which to access\n system-wide configuration information.\n On UNIX platforms this is determined using the mechanisms described in\n the\n XDG Base Directory Specification.\n In this case the list of directories retrieved will be XDG_CONFIG_DIRS.\n On Windows is the directory that contains application data for all users.\n A typical path is C:\\Documents and Settings\\All Users\\Application Data.\n This folder is used for application data that is not user specific.\n For example, an application can store a spell-check dictionary, a database\n of clip art, or a log file in the CSIDL_COMMON_APPDATA folder.\n This information will not roam and is available to anyone using the computer.\n Since 2.6\n Returns: a NULL-terminated array of strings owned by GLib that must not be modified or freed.\n\t \n",
"line" : 420}
,
{
"name" : "reloadUserSpecialDirsCache",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Resets the cache used for g_get_user_special_dir(), so\n that the latest on-disk version is used. Call this only\n if you just changed the data on disk yourself.\n Due to threadsafety issues this may cause leaking of strings\n that were previously returned from g_get_user_special_dir()\n that can't be freed. We ensure to only leak the data for\n the directories that actually changed value though.\n Since 2.22\n\t \n",
"line" : 436}
,
{
"name" : "getHostName",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Return a name for the machine.\n The returned name is not necessarily a fully-qualified domain name,\n or even present in DNS or some other name service at all. It need\n not even be unique on your local network or site, but usually it\n is. Callers should not rely on the return value having any specific\n properties like uniqueness for security purposes. Even if the name\n of the machine is changed while an application is running, the\n return value from this function does not change. The returned\n string is owned by GLib and should not be modified or freed. If no\n name can be determined, a default fixed string \"localhost\" is\n returned.\n Since 2.8\n Returns: the host name of the machine.\n\t \n",
"line" : 457}
,
{
"name" : "getHomeDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the current user's home directory as defined in the\n password database.\n Note that in contrast to traditional UNIX tools, this function\n prefers passwd entries over the HOME\n environment variable.\n One of the reasons for this decision is that applications in many\n cases need special handling to deal with the case where\n HOME is\n Not owned by the user\n Not writeable\n Not even readable\n Since applications are in general not written\n to deal with these situations it was considered better to make\n g_get_home_dir() not pay attention to HOME and to\n return the real home directory for the user. If applications\n Returns: the current user's home directory\n\t \n",
"line" : 481}
,
{
"name" : "getTmpDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the directory to use for temporary files. This is found from\n inspecting the environment variables TMPDIR,\n TMP, and TEMP in that order. If none\n of those are defined \"\/tmp\" is returned on UNIX and \"C:\\\" on Windows.\n The encoding of the returned string is system-defined. On Windows,\n it is always UTF-8. The return value is never NULL or the empty string.\n Returns: the directory to use for temporary files.\n\t \n",
"line" : 496}
,
{
"name" : "getCurrentDir",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Gets the current directory.\n The returned string should be freed when no longer needed. The encoding\n of the returned string is system defined. On Windows, it is always UTF-8.\n Returns: the current directory.\n\t \n",
"line" : 508}
,
{
"name" : "basename",
"kind" : "function",
"protection" : "public",
"type" : "string(string fileName)",
"comment" : "\n Warning\n g_basename has been deprecated since version 2.2 and should not be used in newly-written code. Use g_path_get_basename() instead, but notice that\n g_path_get_basename() allocates new memory for the returned string, unlike\n this function which returns a pointer into the argument.\n Gets the name of the file without any leading directory components.\n It returns a pointer into the given file name string.\n Params:\n fileName = the name of the file.\n Returns: the name of the file without any leading directory components.\n\t \n",
"line" : 525}
,
{
"name" : "pathIsAbsolute",
"kind" : "function",
"protection" : "public",
"type" : "int(string fileName)",
"comment" : "\n Returns TRUE if the given file_name is an absolute file name,\n i.e. it contains a full path from the root directory such as \"\/usr\/local\"\n on UNIX or \"C:\\windows\" on Windows systems.\n Params:\n fileName = a file name.\n Returns: TRUE if file_name is an absolute path.\n\t \n",
"line" : 539}
,
{
"name" : "pathSkipRoot",
"kind" : "function",
"protection" : "public",
"type" : "string(string fileName)",
"comment" : "\n Returns a pointer into file_name after the root component, i.e. after\n the \"\/\" in UNIX or \"C:\\\" under Windows. If file_name is not an absolute\n path it returns NULL.\n Params:\n fileName = a file name.\n Returns: a pointer into file_name after the root component.\n\t \n",
"line" : 553}
,
{
"name" : "pathGetBasename",
"kind" : "function",
"protection" : "public",
"type" : "string(string fileName)",
"comment" : "\n Gets the last component of the filename. If file_name ends with a\n directory separator it gets the component before the last slash. If\n file_name consists only of directory separators (and on Windows,\n possibly a drive letter), a single separator is returned. If\n file_name is empty, it gets \".\".\n Params:\n fileName = the name of the file.\n Returns: a newly allocated string containing the last component of the filename.\n\t \n",
"line" : 569}
,
{
"name" : "pathGetDirname",
"kind" : "function",
"protection" : "public",
"type" : "string(string fileName)",
"comment" : "\n Gets the directory components of a file name. If the file name has no\n directory components \".\" is returned. The returned string should be\n freed when no longer needed.\n Params:\n fileName = the name of the file.\n Returns: the directory components of the file.\n\t \n",
"line" : 583}
,
{
"name" : "buildFilenamev",
"kind" : "function",
"protection" : "public",
"type" : "string(char** args)",
"comment" : "\n Behaves exactly like g_build_filename(), but takes the path elements\n as a string array, instead of varargs. This function is mainly\n meant for language bindings.\n Since 2.8\n Params:\n args = NULL-terminated array of strings containing the path elements.\n Returns: a newly-allocated string that must be freed with g_free().\n\t \n",
"line" : 598}
,
{
"name" : "buildPathv",
"kind" : "function",
"protection" : "public",
"type" : "string(string separator, char** args)",
"comment" : "\n Behaves exactly like g_build_path(), but takes the path elements\n as a string array, instead of varargs. This function is mainly\n meant for language bindings.\n Since 2.8\n Params:\n separator = a string used to separator the elements of the path.\n args = NULL-terminated array of strings containing the path elements.\n Returns: a newly-allocated string that must be freed with g_free().\n\t \n",
"line" : 614}
,
{
"name" : "formatSizeForDisplay",
"kind" : "function",
"protection" : "public",
"type" : "string(long size)",
"comment" : "\n Formats a size (for example the size of a file) into a human readable string.\n Sizes are rounded to the nearest size prefix (KB, MB, GB) and are displayed\n rounded to the nearest tenth. E.g. the file size 3292528 bytes will be\n converted into the string \"3.1 MB\".\n The prefix units base is 1024 (i.e. 1 KB is 1024 bytes).\n This string should be freed with g_free() when not needed any longer.\n Since 2.16\n Params:\n size = a size in bytes.\n Returns: a newly-allocated formatted string containing a human readable file size.\n\t \n",
"line" : 632}
,
{
"name" : "findProgramInPath",
"kind" : "function",
"protection" : "public",
"type" : "string(string program)",
"comment" : "\n Locates the first executable named program in the user's path, in the\n same way that execvp() would locate it. Returns an allocated string\n with the absolute path name, or NULL if the program is not found in\n the path. If program is already an absolute path, returns a copy of\n program if program exists and is executable, and NULL otherwise.\n On Windows, if program does not have a file type suffix, tries\n with the suffixes .exe, .cmd, .bat and .com, and the suffixes in\n the PATHEXT environment variable.\n On Windows, it looks for the file in the same way as CreateProcess()\n would. This means first in the directory where the executing\n program was loaded from, then in the current directory, then in the\n Windows 32-bit system directory, then in the Windows directory, and\n finally in the directories in the PATH environment\n variable. If the program is found, the return value contains the\n full name including the type suffix.\n Params:\n program = a program name in the GLib file name encoding\n Returns: absolute path, or NULL\n\t \n",
"line" : 658}
,
{
"name" : "bitNthLsf",
"kind" : "function",
"protection" : "public",
"type" : "int(ulong mask, int nthBit)",
"comment" : "\n Find the position of the first bit set in mask, searching from (but not\n including) nth_bit upwards. Bits are numbered from 0 (least significant)\n to sizeof(gulong) * 8 - 1 (31 or 63, usually). To start searching from the\n 0th bit, set nth_bit to -1.\n Params:\n mask = a gulong containing flags.\n nthBit = the index of the bit to start the search from.\n Returns: the index of the first bit set which is higher than nth_bit.\n\t \n",
"line" : 674}
,
{
"name" : "bitNthMsf",
"kind" : "function",
"protection" : "public",
"type" : "int(ulong mask, int nthBit)",
"comment" : "\n Find the position of the first bit set in mask, searching from (but not\n including) nth_bit downwards. Bits are numbered from 0 (least significant)\n to sizeof(gulong) * 8 - 1 (31 or 63, usually). To start searching from the\n last bit, set nth_bit to -1 or GLIB_SIZEOF_LONG * 8.\n Params:\n mask = a gulong containing flags.\n nthBit = the index of the bit to start the search from.\n Returns: the index of the first bit set which is lower than nth_bit.\n\t \n",
"line" : 690}
,
{
"name" : "bitStorage",
"kind" : "function",
"protection" : "public",
"type" : "uint(ulong number)",
"comment" : "\n Gets the number of bits used to hold number,\n e.g. if number is 4, 3 bits are needed.\n Params:\n number = a guint.\n Returns: the number of bits used to hold number.\n\t \n",
"line" : 703}
,
{
"name" : "spacedPrimesClosest",
"kind" : "function",
"protection" : "public",
"type" : "uint(uint num)",
"comment" : "\n Gets the smallest prime number from a built-in array of primes which\n is larger than num. This is used within GLib to calculate the optimum\n size of a GHashTable.\n The built-in array of primes ranges from 11 to 13845163 such that\n each prime is approximately 1.5-2 times the previous prime.\n Params:\n num = a guint.\n Returns: the smallest prime number from a built-in array of primes which is larger than num.\n\t \n",
"line" : 719}
,
{
"name" : "atexit",
"kind" : "function",
"protection" : "public",
"type" : "void(extern (C) void function() func)",
"comment" : "\n Specifies a function to be called at normal program termination.\n Since GLib 2.8.2, on Windows g_atexit() actually is a preprocessor\n macro that maps to a call to the atexit() function in the C\n library. This means that in case the code that calls g_atexit(),\n i.e. atexit(), is in a DLL, the function will be called when the\n DLL is detached from the program. This typically makes more sense\n than that the function is called when the GLib DLL is detached,\n which happened earlier when g_atexit() was a function in the GLib\n DLL.\n The behaviour of atexit() in the context of dynamically loaded\n modules is not formally specified and varies wildly.\n On POSIX systems, calling g_atexit() (or atexit()) in a dynamically\n loaded module which is unloaded before the program terminates might\n well cause a crash at program exit.\n Some POSIX systems implement atexit() like Windows, and have each\n dynamically loaded module maintain an own atexit chain that is\n called when the module is unloaded.\n On other POSIX systems, before a dynamically loaded module is\n unloaded, the registered atexit functions (if any) residing in that\n module are called, regardless where the code that registered them\n resided. This is presumably the most robust approach.\n As can be seen from the above, for portability it's best to avoid\n calling g_atexit() (or atexit()) except in the main executable of a\n program.\n Params:\n func = the function to call on normal program termination.\n\t \n",
"line" : 753}
,
{
"name" : "parseDebugString",
"kind" : "function",
"protection" : "public",
"type" : "uint(string string, GDebugKey* keys, uint nkeys)",
"comment" : "\n Parses a string containing debugging options\n into a guint containing bit flags. This is used\n within GDK and GTK+ to parse the debug options passed on the\n command line or through environment variables.\n If string is equal to \"all\", all flags are set. If string\n is equal to \"help\", all the available keys in keys are printed\n out to standard error.\n Params:\n string = a list of debug options separated by colons, spaces, or\n commas, or NULL.\n keys = pointer to an array of GDebugKey which associate\n  strings with bit flags.\n nkeys = the number of GDebugKeys in the array.\n Returns: the combined set of bit flags.\n\t \n",
"line" : 775}
,
{
"name" : "qsortWithData",
"kind" : "function",
"protection" : "public",
"type" : "void(void* pbase, int totalElems, ulong size, extern (C) int function(void*, void*, void*) compareFunc, void* userData)",
"comment" : "\n This is just like the standard C qsort() function, but\n the comparison routine accepts a user data argument.\n Params:\n pbase = start of array to sort\n totalElems = elements in the array\n size = size of each element\n compareFunc = function to compare elements\n userData = data to pass to compare_func\n\t \n",
"line" : 791}
,
{
"name" : "nullifyPointer",
"kind" : "function",
"protection" : "public",
"type" : "void(void** nullifyLocation)",
"comment" : "\n Set the pointer at the specified location to NULL.\n Params:\n nullifyLocation = the memory address of the pointer.\n\t \n",
"line" : 802}
]
}
]
}
,
{
"name" : "glib.VariantBuilder",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/VariantBuilder.d",
"members" : [
{
"name" : "VariantBuilder",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GVariant is a variant datatype; it stores a value along with\n information about the type of that value. The range of possible\n values is determined by the type. The type system used by GVariant\n is GVariantType.\n GVariant instances always have a type and a value (which are given\n at construction time). The type and value of a GVariant instance\n can never change other than by the GVariant itself being\n destroyed. A GVariant can not contain a pointer.\n GVariant is reference counted using g_variant_ref() and\n g_variant_unref(). GVariant also has floating reference counts --\n see g_variant_ref_sink().\n GVariant is completely threadsafe. A GVariant instance can be\n concurrently accessed in any way from any number of threads without\n problems.\n GVariant is heavily optimised for dealing with data in serialised\n form. It works particularly well with data located in memory-mapped\n files. It can perform nearly all deserialisation operations in a\n small constant time, usually touching only a single memory page.\n Serialised GVariant data can also be sent over the network.\n GVariant is largely compatible with DBus. Almost all types of\n GVariant instances can be sent over DBus. See GVariantType for\n exceptions.\n For convenience to C programmers, GVariant features powerful\n varargs-based value construction and destruction. This feature is\n designed to be embedded in other libraries.\n There is a Python-inspired text language for describing GVariant\n values. GVariant includes a printer for this language and a parser\n with type inferencing.\n Memory Use\n  GVariant tries to be quite efficient with respect to memory use.\n  This section gives a rough idea of how much memory is used by the\n  current implementation. The information here is subject to change\n  in the future.\n  The memory allocated by GVariant can be grouped into 4 broad\n  purposes: memory for serialised data, memory for the type\n  information cache, buffer management memory and memory for the\n  GVariant structure itself.\n Serialised Data Memory\n  This is the memory that is used for storing GVariant data in\n  serialised form. This is what would be sent over the network or\n  what would end up on disk.\n  The amount of memory required to store a boolean is 1 byte. 16,\n  32 and 64 bit integers and double precision floating point numbers\n  use their \"natural\" size. Strings (including object path and\n  signature strings) are stored with a nul terminator, and as such\n  use the length of the string plus 1 byte.\n  Maybe types use no space at all to represent the null value and\n  use the same amount of space (sometimes plus one byte) as the\n  equivalent non-maybe-typed value to represent the non-null case.\n  Arrays use the amount of space required to store each of their\n  members, concatenated. Additionally, if the items stored in an\n  array are not of a fixed-size (ie: strings, other arrays, etc)\n  then an additional framing offset is stored for each item. The\n  size of this offset is either 1, 2 or 4 bytes depending on the\n  overall size of the container. Additionally, extra padding bytes\n  are added as required for alignment of child values.\n  Tuples (including dictionary entries) use the amount of space\n  required to store each of their members, concatenated, plus one\n  framing offset (as per arrays) for each non-fixed-sized item in\n  the tuple, except for the last one. Additionally, extra padding\n  bytes are added as required for alignment of child values.\n  Variants use the same amount of space as the item inside of the\n  variant, plus 1 byte, plus the length of the type string for the\n  item inside the variant.\n  As an example, consider a dictionary mapping strings to variants.\n  In the case that the dictionary is empty, 0 bytes are required for\n  the serialisation.\n  If we add an item \"width\" that maps to the int32 value of 500 then\n  we will use 4 byte to store the int32 (so 6 for the variant\n  containing it) and 6 bytes for the string. The variant must be\n  aligned to 8 after the 6 bytes of the string, so that's 2 extra\n  bytes. 6 (string) + 2 (padding) + 6 (variant) is 14 bytes used\n  for the dictionary entry. An additional 1 byte is added to the\n  array as a framing offset making a total of 15 bytes.\n  If we add another entry, \"title\" that maps to a nullable string\n  that happens to have a value of null, then we use 0 bytes for the\n  null value (and 3 bytes for the variant to contain it along with\n  its type string) plus 6 bytes for the string. Again, we need 2\n  padding bytes. That makes a total of 6 + 2 + 3 = 11 bytes.\n  We now require extra padding between the two items in the array.\n  After the 14 bytes of the first item, that's 2 bytes required. We\n  now require 2 framing offsets for an extra two bytes. 14 + 2 + 11\n  + 2 = 29 bytes to encode the entire two-item dictionary.\n Type Information Cache\n  For each GVariant type that currently exists in the program a type\n  information structure is kept in the type information cache. The\n  type information structure is required for rapid deserialisation.\n  Continuing with the above example, if a GVariant exists with the\n  type \"a{sv}\" then a type information struct will exist for\n  \"a{sv}\", \"{sv}\", \"s\", and \"v\". Multiple uses of the same type\n  will share the same type information. Additionally, all\n  single-digit types are stored in read-only static memory and do\n  not contribute to the writable memory footprint of a program using\n  GVariant.\n  Aside from the type information structures stored in read-only\n  memory, there are two forms of type information. One is used for\n  container types where there is a single element type: arrays and\n  maybe types. The other is used for container types where there\n  are multiple element types: tuples and dictionary entries.\n  Array type info structures are 6 * sizeof (void *), plus the\n  memory required to store the type string itself. This means that\n  on 32bit systems, the cache entry for \"a{sv}\" would require 30\n  bytes of memory (plus malloc overhead).\n  Tuple type info structures are 6 * sizeof (void *), plus 4 *\n  sizeof (void *) for each item in the tuple, plus the memory\n  required to store the type string itself. A 2-item tuple, for\n  example, would have a type information structure that consumed\n  writable memory in the size of 14 * sizeof (void *) (plus type\n  string) This means that on 32bit systems, the cache entry for\n  \"{sv}\" would require 61 bytes of memory (plus malloc overhead).\n  This means that in total, for our \"a{sv}\" example, 91 bytes of\n  type information would be allocated.\n  The type information cache, additionally, uses a GHashTable to\n  store and lookup the cached items and stores a pointer to this\n  hash table in static storage. The hash table is freed when there\n  are zero items in the type cache.\n  Although these sizes may seem large it is important to remember\n  that a program will probably only have a very small number of\n  different types of values in it and that only one type information\n  structure is required for many different values of the same type.\n Buffer Management Memory\n  GVariant uses an internal buffer management structure to deal\n  with the various different possible sources of serialised data\n  that it uses. The buffer is responsible for ensuring that the\n  correct call is made when the data is no longer in use by\n  GVariant. This may involve a g_free() or a g_slice_free() or\n  even g_mapped_file_unref().\n  One buffer management structure is used for each chunk of\n  serialised data. The size of the buffer management structure is 4\n  * (void *). On 32bit systems, that's 16 bytes.\n GVariant structure\n  The size of a GVariant structure is 6 * (void *). On 32 bit\n  systems, that's 24 bytes.\n  GVariant structures only exist if they are explicitly created\n  with API calls. For example, if a GVariant is constructed out of\n  serialised data for the example given above (with the dictionary)\n  then although there are 9 individual values that comprise the\n  entire dictionary (two keys, two values, two variants containing\n  the values, two dictionary entries, plus the dictionary itself),\n  only 1 GVariant instance exists -- the one refering to the\n  dictionary.\n  If calls are made to start accessing the other values then\n  GVariant instances will exist for those values only for as long\n  as they are in use (ie: until you call g_variant_unref()). The\n  type information is shared. The serialised data and the buffer\n  management structure for that serialised data is shared by the\n  child.\n Summary\n  To put the entire example together, for our dictionary mapping\n  strings to variants (with two entries, as given above), we are\n  using 91 bytes of memory for type information, 29 byes of memory\n  for the serialised data, 16 bytes for buffer management and 24\n  bytes for the GVariant instance, or a total of 160 bytes, plus\n  malloc overhead. If we were to use g_variant_get_child_value() to\n  access the two dictionary entries, we would use an additional 48\n  bytes. If we were to have other dictionaries of the same type, we\n  would use more memory for the serialised data and buffer\n  management for those dictionaries, but the type information would\n  be shared.\n \n",
"line" : 235,
"base" : "Object",
"members" : [
{
"name" : "gVariantBuilder",
"kind" : "variable",
"protection" : "protected",
"type" : "GVariantBuilder*",
"comment" : " the main Gtk struct \n",
"line" : 238}
,
{
"name" : "getVariantBuilderStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVariantBuilder*()",
"line" : 241}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 248}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantBuilder(GVariantBuilder* gVariantBuilder)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 256}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Decreases the reference count on builder.\n In the event that there are no more references, releases all memory\n associated with the GVariantBuilder.\n Don't call this on stack-allocated GVariantBuilder instances or bad\n things will happen.\n Since 2.24\n\t \n",
"line" : 277}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "VariantBuilder()",
"comment" : "\n Increases the reference count on builder.\n Don't call this on stack-allocated GVariantBuilder instances or bad\n things will happen.\n Since 2.24\n Returns: a new reference to builder\n\t \n",
"line" : 290}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantBuilder(VariantType type)",
"comment" : "\n Allocates and initialises a new GVariantBuilder.\n You should call g_variant_builder_unref() on the return value when it\n is no longer needed. The memory will not be automatically freed by\n any other call.\n In most cases it is easier to place a GVariantBuilder directly on\n the stack of the calling function and initialise it with\n g_variant_builder_init().\n Since 2.24\n Params:\n type = a container type\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 314}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "void(VariantType type)",
"comment" : "\n Initialises a GVariantBuilder structure.\n type must be non-NULL. It specifies the type of container to\n construct. It can be an indefinite type such as\n G_VARIANT_TYPE_ARRAY or a definite type such as \"as\" or \"(ii)\".\n Maybe, array, tuple, dictionary entry and variant-typed values may be\n constructed.\n After the builder is initialised, values are added using\n g_variant_builder_add_value() or g_variant_builder_add().\n After all the child values are added, g_variant_builder_end() frees\n the memory associated with the builder and returns the GVariant that\n was created.\n This function completely ignores the previous contents of builder.\n On one hand this means that it is valid to pass in completely\n uninitialised memory. On the other hand, this means that if you are\n initialising over top of an existing GVariantBuilder you need to\n first call g_variant_builder_clear() in order to avoid leaking\n memory.\n You must not call g_variant_builder_ref() or\n g_variant_builder_unref() on a GVariantBuilder that was initialised\n with this function. If you ever pass a reference to a\n GVariantBuilder outside of the control of your own code then you\n should assume that the person receiving that reference may try to use\n reference counting; you should use g_variant_builder_new() instead of\n this function.\n Since 2.24\n Params:\n type = a container type\n\t \n",
"line" : 354}
,
{
"name" : "clear",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Releases all memory associated with a GVariantBuilder without\n freeing the GVariantBuilder structure itself.\n It typically only makes sense to do this on a stack-allocated\n GVariantBuilder if you want to abort building the value part-way\n through. This function need not be called if you call\n g_variant_builder_end() and it also doesn't need to be called on\n builders allocated with g_variant_builder_new (see\n g_variant_builder_free() for that).\n This function leaves the GVariantBuilder structure set to all-zeros.\n It is valid to call this function on either an initialised\n GVariantBuilder or one that is set to all-zeros but it is not valid\n to call this function on uninitialised memory.\n Since 2.24\n\t \n",
"line" : 375}
,
{
"name" : "addValue",
"kind" : "function",
"protection" : "public",
"type" : "void(Variant value)",
"comment" : "\n Adds value to builder.\n It is an error to call this function in any way that would create an\n inconsistent value to be constructed. Some examples of this are\n putting different types of items into an array, putting the wrong\n types or number of items in a tuple, putting more than one value into\n a variant, etc.\n Since 2.24\n Params:\n value = a GVariant\n\t \n",
"line" : 392}
,
{
"name" : "end",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Ends the builder process and returns the constructed value.\n It is not permissible to use builder in any way after this call\n except for reference counting operations (in the case of a\n heap-allocated GVariantBuilder) or by reinitialising it with\n g_variant_builder_init() (in the case of stack-allocated).\n It is an error to call this function in any way that would create an\n inconsistent value to be constructed (ie: insufficient number of\n items added to a container with a specific number of children\n required). It is also an error to call this function if the builder\n was created with an indefinite array or maybe type and no children\n have been added; in this case it is impossible to infer the type of\n the empty array.\n Since 2.24\n Returns: a new, floating, GVariant. [transfer none]\n\t \n",
"line" : 414}
,
{
"name" : "open",
"kind" : "function",
"protection" : "public",
"type" : "void(VariantType type)",
"comment" : "\n Opens a subcontainer inside the given builder. When done adding\n items to the subcontainer, g_variant_builder_close() must be called.\n It is an error to call this function in any way that would cause an\n inconsistent value to be constructed (ie: adding too many values or\n a value of an incorrect type).\n Since 2.24\n Params:\n type = a GVariantType\n\t \n",
"line" : 435}
,
{
"name" : "close",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Closes the subcontainer inside the given builder that was opened by\n the most recent call to g_variant_builder_open().\n It is an error to call this function in any way that would create an\n inconsistent value to be constructed (ie: too few values added to the\n subcontainer).\n Since 2.24\n\t \n",
"line" : 449}
]
}
]
}
,
{
"name" : "glib.Variant",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/Variant.d",
"members" : [
{
"name" : "Variant",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GVariant is a variant datatype; it stores a value along with\n information about the type of that value. The range of possible\n values is determined by the type. The type system used by GVariant\n is GVariantType.\n GVariant instances always have a type and a value (which are given\n at construction time). The type and value of a GVariant instance\n can never change other than by the GVariant itself being\n destroyed. A GVariant can not contain a pointer.\n GVariant is reference counted using g_variant_ref() and\n g_variant_unref(). GVariant also has floating reference counts --\n see g_variant_ref_sink().\n GVariant is completely threadsafe. A GVariant instance can be\n concurrently accessed in any way from any number of threads without\n problems.\n GVariant is heavily optimised for dealing with data in serialised\n form. It works particularly well with data located in memory-mapped\n files. It can perform nearly all deserialisation operations in a\n small constant time, usually touching only a single memory page.\n Serialised GVariant data can also be sent over the network.\n GVariant is largely compatible with DBus. Almost all types of\n GVariant instances can be sent over DBus. See GVariantType for\n exceptions.\n For convenience to C programmers, GVariant features powerful\n varargs-based value construction and destruction. This feature is\n designed to be embedded in other libraries.\n There is a Python-inspired text language for describing GVariant\n values. GVariant includes a printer for this language and a parser\n with type inferencing.\n Memory Use\n  GVariant tries to be quite efficient with respect to memory use.\n  This section gives a rough idea of how much memory is used by the\n  current implementation. The information here is subject to change\n  in the future.\n  The memory allocated by GVariant can be grouped into 4 broad\n  purposes: memory for serialised data, memory for the type\n  information cache, buffer management memory and memory for the\n  GVariant structure itself.\n Serialised Data Memory\n  This is the memory that is used for storing GVariant data in\n  serialised form. This is what would be sent over the network or\n  what would end up on disk.\n  The amount of memory required to store a boolean is 1 byte. 16,\n  32 and 64 bit integers and double precision floating point numbers\n  use their \"natural\" size. Strings (including object path and\n  signature strings) are stored with a nul terminator, and as such\n  use the length of the string plus 1 byte.\n  Maybe types use no space at all to represent the null value and\n  use the same amount of space (sometimes plus one byte) as the\n  equivalent non-maybe-typed value to represent the non-null case.\n  Arrays use the amount of space required to store each of their\n  members, concatenated. Additionally, if the items stored in an\n  array are not of a fixed-size (ie: strings, other arrays, etc)\n  then an additional framing offset is stored for each item. The\n  size of this offset is either 1, 2 or 4 bytes depending on the\n  overall size of the container. Additionally, extra padding bytes\n  are added as required for alignment of child values.\n  Tuples (including dictionary entries) use the amount of space\n  required to store each of their members, concatenated, plus one\n  framing offset (as per arrays) for each non-fixed-sized item in\n  the tuple, except for the last one. Additionally, extra padding\n  bytes are added as required for alignment of child values.\n  Variants use the same amount of space as the item inside of the\n  variant, plus 1 byte, plus the length of the type string for the\n  item inside the variant.\n  As an example, consider a dictionary mapping strings to variants.\n  In the case that the dictionary is empty, 0 bytes are required for\n  the serialisation.\n  If we add an item \"width\" that maps to the int32 value of 500 then\n  we will use 4 byte to store the int32 (so 6 for the variant\n  containing it) and 6 bytes for the string. The variant must be\n  aligned to 8 after the 6 bytes of the string, so that's 2 extra\n  bytes. 6 (string) + 2 (padding) + 6 (variant) is 14 bytes used\n  for the dictionary entry. An additional 1 byte is added to the\n  array as a framing offset making a total of 15 bytes.\n  If we add another entry, \"title\" that maps to a nullable string\n  that happens to have a value of null, then we use 0 bytes for the\n  null value (and 3 bytes for the variant to contain it along with\n  its type string) plus 6 bytes for the string. Again, we need 2\n  padding bytes. That makes a total of 6 + 2 + 3 = 11 bytes.\n  We now require extra padding between the two items in the array.\n  After the 14 bytes of the first item, that's 2 bytes required. We\n  now require 2 framing offsets for an extra two bytes. 14 + 2 + 11\n  + 2 = 29 bytes to encode the entire two-item dictionary.\n Type Information Cache\n  For each GVariant type that currently exists in the program a type\n  information structure is kept in the type information cache. The\n  type information structure is required for rapid deserialisation.\n  Continuing with the above example, if a GVariant exists with the\n  type \"a{sv}\" then a type information struct will exist for\n  \"a{sv}\", \"{sv}\", \"s\", and \"v\". Multiple uses of the same type\n  will share the same type information. Additionally, all\n  single-digit types are stored in read-only static memory and do\n  not contribute to the writable memory footprint of a program using\n  GVariant.\n  Aside from the type information structures stored in read-only\n  memory, there are two forms of type information. One is used for\n  container types where there is a single element type: arrays and\n  maybe types. The other is used for container types where there\n  are multiple element types: tuples and dictionary entries.\n  Array type info structures are 6 * sizeof (void *), plus the\n  memory required to store the type string itself. This means that\n  on 32bit systems, the cache entry for \"a{sv}\" would require 30\n  bytes of memory (plus malloc overhead).\n  Tuple type info structures are 6 * sizeof (void *), plus 4 *\n  sizeof (void *) for each item in the tuple, plus the memory\n  required to store the type string itself. A 2-item tuple, for\n  example, would have a type information structure that consumed\n  writable memory in the size of 14 * sizeof (void *) (plus type\n  string) This means that on 32bit systems, the cache entry for\n  \"{sv}\" would require 61 bytes of memory (plus malloc overhead).\n  This means that in total, for our \"a{sv}\" example, 91 bytes of\n  type information would be allocated.\n  The type information cache, additionally, uses a GHashTable to\n  store and lookup the cached items and stores a pointer to this\n  hash table in static storage. The hash table is freed when there\n  are zero items in the type cache.\n  Although these sizes may seem large it is important to remember\n  that a program will probably only have a very small number of\n  different types of values in it and that only one type information\n  structure is required for many different values of the same type.\n Buffer Management Memory\n  GVariant uses an internal buffer management structure to deal\n  with the various different possible sources of serialised data\n  that it uses. The buffer is responsible for ensuring that the\n  correct call is made when the data is no longer in use by\n  GVariant. This may involve a g_free() or a g_slice_free() or\n  even g_mapped_file_unref().\n  One buffer management structure is used for each chunk of\n  serialised data. The size of the buffer management structure is 4\n  * (void *). On 32bit systems, that's 16 bytes.\n GVariant structure\n  The size of a GVariant structure is 6 * (void *). On 32 bit\n  systems, that's 24 bytes.\n  GVariant structures only exist if they are explicitly created\n  with API calls. For example, if a GVariant is constructed out of\n  serialised data for the example given above (with the dictionary)\n  then although there are 9 individual values that comprise the\n  entire dictionary (two keys, two values, two variants containing\n  the values, two dictionary entries, plus the dictionary itself),\n  only 1 GVariant instance exists -- the one refering to the\n  dictionary.\n  If calls are made to start accessing the other values then\n  GVariant instances will exist for those values only for as long\n  as they are in use (ie: until you call g_variant_unref()). The\n  type information is shared. The serialised data and the buffer\n  management structure for that serialised data is shared by the\n  child.\n Summary\n  To put the entire example together, for our dictionary mapping\n  strings to variants (with two entries, as given above), we are\n  using 91 bytes of memory for type information, 29 byes of memory\n  for the serialised data, 16 bytes for buffer management and 24\n  bytes for the GVariant instance, or a total of 160 bytes, plus\n  malloc overhead. If we were to use g_variant_get_child_value() to\n  access the two dictionary entries, we would use an additional 48\n  bytes. If we were to have other dictionaries of the same type, we\n  would use more memory for the serialised data and buffer\n  management for those dictionaries, but the type information would\n  be shared.\n \n",
"line" : 247,
"base" : "Object",
"members" : [
{
"name" : "gVariant",
"kind" : "variable",
"protection" : "protected",
"type" : "GVariant*",
"comment" : " the main Gtk struct \n",
"line" : 250}
,
{
"name" : "getVariantStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVariant*()",
"line" : 253}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 260}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(GVariant* gVariant)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 268}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(bool boolean)",
"comment" : "\n Creates a new boolean GVariant instance -- either TRUE or FALSE.\n Since 2.24\n Params:\n boolean = a gboolean value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 285}
,
{
"name" : "fromObjectPath",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string path)",
"comment" : "\n Creates a DBus object path GVariant with the contents of string.\n string must be a valid DBus object path.\n Use Variant.isObjectPath() if you're not sure.\n Since 2.24\n\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 304}
,
{
"name" : "fromSignature",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string signature)",
"comment" : "\n Creates a DBus type signature GVariant with the contents of string.\n string must be a valid DBus type signature.\n Use Variant.isSignature() if you're not sure.\n Since 2.24\n\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 322}
,
{
"name" : "fromByteString",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string byteString)",
"comment" : "\n Creates an array-of-bytes GVariant with the contents of string.\n This function is just like new Variant(string) except that the string\n need not be valid utf8.\n\n The nul terminator character at the end of the string is stored in\n the array.\n\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 342}
,
{
"name" : "fromByteStringArray",
"kind" : "function",
"protection" : "public",
"type" : "Variant(string[] strv)",
"comment" : "\n Constructs an array of bytestring GVariant from the given array of\n strings. If length is -1 then strv is NULL-terminated.\n Since 2.26\n\n Params:\n     strv   = an array of strings.\n     length = the length of strv, or -1\n\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 363}
,
{
"name" : "unref",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Decreases the reference count of value. When its reference count\n drops to 0, the memory used by the variant is freed.\n Since 2.24\n\t \n",
"line" : 382}
,
{
"name" : "doref",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Increases the reference count of value.\n Since 2.24\n Returns: the same value\n\t \n",
"line" : 393}
,
{
"name" : "refSink",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n GVariant uses a floating reference count system. All functions with\n names starting with g_variant_new_ return floating\n references.\n Calling g_variant_ref_sink() on a GVariant with a floating reference\n will convert the floating reference into a full reference. Calling\n g_variant_ref_sink() on a non-floating GVariant results in an\n additional normal reference being added.\n In other words, if the value is floating, then this call \"assumes\n ownership\" of the floating reference, converting it to a normal\n reference. If the value is not floating, then this call adds a\n new normal reference increasing the reference count by one.\n All calls that result in a GVariant instance being inserted into a\n container will call g_variant_ref_sink() on the instance. This means\n that if the value was just created (and has only its floating\n reference) then the container will assume sole ownership of the value\n at that point and the caller will not need to unreference it. This\n makes certain common styles of programming much easier while still\n maintaining normal refcounting semantics in situations where values\n are not floating.\n Since 2.24\n Returns: the same value\n\t \n",
"line" : 427}
,
{
"name" : "isFloating",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks whether value has a floating reference count.\n This function should only ever be used to assert that a given variant\n is or is not floating, or for debug purposes. To acquire a reference\n to a variant that might be floating, always use g_variant_ref_sink().\n See g_variant_ref_sink() for more information about floating reference\n counts.\n Since 2.26\n Returns: whether value is floating\n\t \n",
"line" : 448}
,
{
"name" : "getType",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Determines the type of value.\n The return value is valid for the lifetime of value and must not\n be freed.\n Since 2.24\n Returns: a GVariantType\n\t \n",
"line" : 461}
,
{
"name" : "getTypeString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the type string of value. Unlike the result of calling\n g_variant_type_peek_string(), this string is nul-terminated. This\n string belongs to GVariant and must not be freed.\n Since 2.24\n Returns: the type string for the type of value\n\t \n",
"line" : 479}
,
{
"name" : "isOfType",
"kind" : "function",
"protection" : "public",
"type" : "int(VariantType type)",
"comment" : "\n Checks if a value has a type matching the provided type.\n Since 2.24\n Params:\n type = a GVariantType\n Returns: TRUE if the type of value matches type\n\t \n",
"line" : 492}
,
{
"name" : "isContainer",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if value is a container.\n Returns: TRUE if value is a container\n\t \n",
"line" : 502}
,
{
"name" : "compare",
"kind" : "function",
"protection" : "public",
"type" : "int(void* one, void* two)",
"comment" : "\n Compares one and two.\n The types of one and two are gconstpointer only to allow use of\n this function with GTree, GPtrArray, etc. They must each be a\n GVariant.\n Comparison is only defined for basic types (ie: booleans, numbers,\n strings). For booleans, FALSE is less than TRUE. Numbers are\n ordered in the usual way. Strings are in ASCII lexographical order.\n It is a programmer error to attempt to compare container values or\n two values that have types that are not exactly equal. For example,\n you can not compare a 32-bit signed integer with a 32-bit unsigned\n integer. Also note that this function is not particularly\n well-behaved when it comes to comparison of doubles; in particular,\n the handling of incomparable values (ie: NaN) is undefined.\n If you only require an equality comparison, g_variant_equal() is more\n general.\n Since 2.26\n Params:\n one = a basic-typed GVariant instance. [type GVariant]\n two = a GVariant instance of the same type. [type GVariant]\n Returns: negative value if a < b; zero if a = b; positive value if a > b.\n\t \n",
"line" : 530}
,
{
"name" : "classify",
"kind" : "function",
"protection" : "public",
"type" : "GVariantClass()",
"comment" : "\n Classifies value according to its top-level type.\n Since 2.24\n Returns: the GVariantClass of value\n\t \n",
"line" : 541}
,
{
"name" : "getVa",
"kind" : "function",
"protection" : "public",
"type" : "void(string formatString, out string endptr, void** app)",
"comment" : "\n This function is intended to be used by libraries based on GVariant\n that want to provide g_variant_get()-like functionality to their\n users.\n The API is more general than g_variant_get() to allow a wider range\n of possible uses.\n format_string must still point to a valid format string, but it only\n need to be nul-terminated if endptr is NULL. If endptr is\n non-NULL then it is updated to point to the first character past the\n end of the format string.\n app is a pointer to a va_list. The arguments, according to\n format_string, are collected from this va_list and the list is left\n pointing to the argument following the last.\n These two generalisations allow mixing of multiple calls to\n g_variant_new_va() and g_variant_get_va() within a single actual\n varargs call by the user.\n Since 2.24\n Params:\n formatString = a string that is prefixed with a format string\n endptr = location to store the end pointer,\n  or NULL. [allow-none][default NULL]\n app = a pointer to a va_list\n\t \n",
"line" : 570}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(string formatString, out string endptr, void** app)",
"comment" : "\n This function is intended to be used by libraries based on\n GVariant that want to provide g_variant_new()-like functionality\n to their users.\n The API is more general than g_variant_new() to allow a wider range\n of possible uses.\n format_string must still point to a valid format string, but it only\n needs to be nul-terminated if endptr is NULL. If endptr is\n non-NULL then it is updated to point to the first character past the\n end of the format string.\n app is a pointer to a va_list. The arguments, according to\n format_string, are collected from this va_list and the list is left\n pointing to the argument following the last.\n These two generalisations allow mixing of multiple calls to\n g_variant_new_va() and g_variant_get_va() within a single actual\n varargs call by the user.\n The return value will be floating if it was a newly created GVariant\n instance (for example, if the format string was \"(ii)\"). In the case\n that the format_string was '*', '?', 'r', or a format starting with\n '@' then the collected GVariant pointer will be returned unmodified,\n without adding any additional references.\n In order to behave correctly in all cases it is necessary for the\n calling function to g_variant_ref_sink() the return result before\n returning control to the user that originally provided the pointer.\n At this point, the caller will have their own full reference to the\n result. This can also be done by adding the result to a container,\n or by passing it to another g_variant_new() call.\n Since 2.24\n Params:\n formatString = a string that is prefixed with a format string\n endptr = location to store the end pointer,\n  or NULL. [allow-none][default NULL]\n app = a pointer to a va_list\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 615}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(char b)",
"comment" : "\n Creates a new byte GVariant instance.\n Since 2.24\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 635}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(short int16)",
"comment" : "\n Creates a new int16 GVariant instance.\n Since 2.24\n Params:\n int16 = a gint16 value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 653}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(ushort uint16)",
"comment" : "\n Creates a new uint16 GVariant instance.\n Since 2.24\n Params:\n uint16 = a guint16 value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 671}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(int int32)",
"comment" : "\n Creates a new int32 GVariant instance.\n Since 2.24\n Params:\n int32 = a gint32 value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 689}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(uint uint32)",
"comment" : "\n Creates a new uint32 GVariant instance.\n Since 2.24\n Params:\n uint32 = a guint32 value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 707}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(long int64)",
"comment" : "\n Creates a new int64 GVariant instance.\n Since 2.24\n Params:\n int64 = a gint64 value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 725}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(ulong uint64)",
"comment" : "\n Creates a new uint64 GVariant instance.\n Since 2.24\n Params:\n uint64 = a guint64 value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 743}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(double floating)",
"comment" : "\n Creates a new double GVariant instance.\n Since 2.24\n Params:\n floating = a gdouble floating point value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 761}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(string string)",
"comment" : "\n Creates a string GVariant with the contents of string.\n string must be valid utf8.\n Since 2.24\n Params:\n string = a normal utf8 nul-terminated string\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 780}
,
{
"name" : "isObjectPath",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Determines if a given string is a valid DBus object path. You\n should ensure that a string is a valid DBus object path before\n passing it to g_variant_new_object_path().\n A valid object path starts with '\/' followed by zero or more\n sequences of characters separated by '\/' characters. Each sequence\n must contain only the characters \"[A-Z][a-z][0-9]_\". No sequence\n (including the one following the final '\/' character) may be empty.\n Since 2.24\n Params:\n string = a normal C nul-terminated string\n Returns: TRUE if string is a DBus object path\n\t \n",
"line" : 804}
,
{
"name" : "isSignature",
"kind" : "function",
"protection" : "public",
"type" : "int(string string)",
"comment" : "\n Determines if a given string is a valid DBus type signature. You\n should ensure that a string is a valid DBus type signature before\n passing it to g_variant_new_signature().\n DBus type signatures consist of zero or more definite GVariantType\n strings in sequence.\n Since 2.24\n Params:\n string = a normal C nul-terminated string\n Returns: TRUE if string is a DBus type signature\n\t \n",
"line" : 821}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(Variant value)",
"comment" : "\n Boxes value. The result is a GVariant instance representing a\n variant containing the original value.\n If child is a floating reference (see g_variant_ref_sink()), the new\n instance takes ownership of child.\n Since 2.24\n Params:\n value = a GVariance instance\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 837}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(string[] strv)",
"comment" : "\n Constructs an array of strings GVariant from the given array of\n strings.\n If length is -1 then strv is NULL-terminated.\n Since 2.24\n Params:\n strv = an array of strings. [array length=length][element-type utf8]\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 857}
,
{
"name" : "getBoolean",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the boolean value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_BOOLEAN.\n Since 2.24\n Returns: TRUE or FALSE\n\t \n",
"line" : 875}
,
{
"name" : "getByte",
"kind" : "function",
"protection" : "public",
"type" : "char()",
"comment" : "\n Returns the byte value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_BYTE.\n Since 2.24\n Returns: a guchar\n\t \n",
"line" : 888}
,
{
"name" : "getInt16",
"kind" : "function",
"protection" : "public",
"type" : "short()",
"comment" : "\n Returns the 16-bit signed integer value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_INT16.\n Since 2.24\n Returns: a gint16\n\t \n",
"line" : 901}
,
{
"name" : "getUint16",
"kind" : "function",
"protection" : "public",
"type" : "ushort()",
"comment" : "\n Returns the 16-bit unsigned integer value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_UINT16.\n Since 2.24\n Returns: a guint16\n\t \n",
"line" : 914}
,
{
"name" : "getInt32",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the 32-bit signed integer value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_INT32.\n Since 2.24\n Returns: a gint32\n\t \n",
"line" : 927}
,
{
"name" : "getUint32",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns the 32-bit unsigned integer value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_UINT32.\n Since 2.24\n Returns: a guint32\n\t \n",
"line" : 940}
,
{
"name" : "getInt64",
"kind" : "function",
"protection" : "public",
"type" : "long()",
"comment" : "\n Returns the 64-bit signed integer value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_INT64.\n Since 2.24\n Returns: a gint64\n\t \n",
"line" : 953}
,
{
"name" : "getUint64",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Returns the 64-bit unsigned integer value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_UINT64.\n Since 2.24\n Returns: a guint64\n\t \n",
"line" : 966}
,
{
"name" : "getHandle",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Returns the 32-bit signed integer value of value.\n It is an error to call this function with a value of any type other\n than G_VARIANT_TYPE_HANDLE.\n By convention, handles are indexes into an array of file descriptors\n that are sent alongside a DBus message. If you're not interacting\n with DBus, you probably don't need them.\n Since 2.24\n Returns: a gint32\n\t \n",
"line" : 982}
,
{
"name" : "getDouble",
"kind" : "function",
"protection" : "public",
"type" : "double()",
"comment" : "\n Returns the double precision floating point value of value.\n It is an error to call this function with a value of any type\n other than G_VARIANT_TYPE_DOUBLE.\n Since 2.24\n Returns: a gdouble\n\t \n",
"line" : 995}
,
{
"name" : "getString",
"kind" : "function",
"protection" : "public",
"type" : "string(out ulong length)",
"comment" : "\n Returns the string value of a GVariant instance with a string\n type. This includes the types G_VARIANT_TYPE_STRING,\n G_VARIANT_TYPE_OBJECT_PATH and G_VARIANT_TYPE_SIGNATURE.\n The string will always be utf8 encoded.\n If length is non-NULL then the length of the string (in bytes) is\n returned there. For trusted values, this information is already\n known. For untrusted values, a strlen() will be performed.\n It is an error to call this function with a value of any type\n other than those three.\n The return value remains valid as long as value exists.\n Since 2.24\n Params:\n length = a pointer to a gsize,\n  to store the length. [allow-none][default NULL][out NULL]\n Returns: the constant string, utf8 encoded\n\t \n",
"line" : 1018}
,
{
"name" : "dupString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Similar to g_variant_get_string() except that instead of returning\n a constant string, the string is duplicated.\n The string will always be utf8 encoded.\n The return value must be freed using g_free().\n Since 2.24\n Returns: a newly allocated string, utf8 encoded\n\t \n",
"line" : 1032}
,
{
"name" : "getVariant",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Unboxes value. The result is the GVariant instance that was\n contained in value.\n Since 2.24\n Returns: the item contained in the variant\n\t \n",
"line" : 1046}
,
{
"name" : "getStrv",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the contents of an array of strings GVariant. This call\n makes a shallow copy; the return result should be released with\n g_free(), but the individual strings must not be modified.\n If length is non-NULL then the number of elements in the result\n is stored there. In any case, the resulting array will be\n NULL-terminated.\n For an empty array, length will be set to 0 and a pointer to a\n NULL pointer will be returned.\n Since 2.24\n Returns: an array of constant strings. [array length=length][transfer container length=length]\n\t \n",
"line" : 1069}
,
{
"name" : "dupStrv",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the contents of an array of strings GVariant. This call\n makes a deep copy; the return result should be released with\n g_strfreev().\n If length is non-NULL then the number of elements in the result\n is stored there. In any case, the resulting array will be\n NULL-terminated.\n For an empty array, length will be set to 0 and a pointer to a\n NULL pointer will be returned.\n Since 2.24\n Returns: an array of strings. [array length=length]\n\t \n",
"line" : 1096}
,
{
"name" : "getBytestring",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the string value of a GVariant instance with an\n array-of-bytes type. The string has no particular encoding.\n If the array does not end with a nul terminator character, the empty\n string is returned. For this reason, you can always trust that a\n non-NULL nul-terminated string will be returned by this function.\n If the array contains a nul terminator character somewhere other than\n the last byte then the returned string is the string, up to the first\n such nul character.\n It is an error to call this function with a value that is not an\n array of bytes.\n The return value remains valid as long as value exists.\n Since 2.26\n Returns: the constant string\n\t \n",
"line" : 1126}
,
{
"name" : "dupBytestring",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Similar to g_variant_get_bytestring() except that instead of\n returning a constant string, the string is duplicated.\n The return value must be freed using g_free().\n Since 2.26\n Returns: a newly allocated string\n\t \n",
"line" : 1139}
,
{
"name" : "getBytestringArray",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the contents of an array of array of bytes GVariant. This call\n makes a shallow copy; the return result should be released with\n g_free(), but the individual strings must not be modified.\n If length is non-NULL then the number of elements in the result is\n stored there. In any case, the resulting array will be\n NULL-terminated.\n For an empty array, length will be set to 0 and a pointer to a\n NULL pointer will be returned.\n Since 2.26\n Returns: an array of constant strings. [array length=length]\n\t \n",
"line" : 1159}
,
{
"name" : "dupBytestringArray",
"kind" : "function",
"protection" : "public",
"type" : "string[]()",
"comment" : "\n Gets the contents of an array of array of bytes GVariant. This call\n makes a deep copy; the return result should be released with\n g_strfreev().\n If length is non-NULL then the number of elements in the result is\n stored there. In any case, the resulting array will be\n NULL-terminated.\n For an empty array, length will be set to 0 and a pointer to a\n NULL pointer will be returned.\n Since 2.26\n Returns: an array of strings. [array length=length]\n\t \n",
"line" : 1186}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(VariantType childType, Variant child)",
"comment" : "\n Depending on if child is NULL, either wraps child inside of a\n maybe container or creates a Nothing instance for the given type.\n At least one of child_type and child must be non-NULL.\n If child_type is non-NULL then it must be a definite type.\n If they are both non-NULL then child_type must be the type\n of child.\n If child is a floating reference (see g_variant_ref_sink()), the new\n instance takes ownership of child.\n Since 2.24\n Params:\n childType = the GVariantType of the child, or NULL. [allow-none]\n child = the child value, or NULL. [allow-none]\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 1216}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(VariantType childType, Variant[] children)",
"comment" : "\n Creates a new GVariant array from children.\n child_type must be non-NULL if n_children is zero. Otherwise, the\n child type is determined by inspecting the first element of the\n children array. If child_type is non-NULL then it must be a\n definite type.\n The items of the array are taken from the children array. No entry\n in the children array may be NULL.\n All items in the array must have the same type, which must be the\n same as child_type, if given.\n If the children are floating references (see g_variant_ref_sink()), the\n new instance takes ownership of them as if via g_variant_ref_sink().\n Since 2.24\n Params:\n childType = the element type of the new array. [allow-none]\n children = an array of\n  GVariant pointers, the children. [allow-none][array length=n_children]\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 1246}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(Variant[] children)",
"comment" : "\n Creates a new tuple GVariant out of the items in children. The\n type is determined from the types of children. No entry in the\n children array may be NULL.\n If n_children is 0 then the unit tuple is constructed.\n If the children are floating references (see g_variant_ref_sink()), the\n new instance takes ownership of them as if via g_variant_ref_sink().\n Since 2.24\n Params:\n children = the items to make the tuple out of. [array length=n_children]\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 1276}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(Variant key, Variant value)",
"comment" : "\n Creates a new dictionary entry GVariant. key and value must be\n non-NULL.\n key must be a value of a basic type (ie: not a container).\n If the key or value are floating references (see g_variant_ref_sink()),\n the new instance takes ownership of them as if via g_variant_ref_sink().\n Since 2.24\n Params:\n key = a basic GVariant, the key\n value = a GVariant, the value\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 1306}
,
{
"name" : "getMaybe",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Given a maybe-typed GVariant instance, extract its value. If the\n value is Nothing, then this function returns NULL.\n Since 2.24\n Returns: the contents of value, or NULL. [allow-none]\n\t \n",
"line" : 1323}
,
{
"name" : "nChildren",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Determines the number of children in a container GVariant instance.\n This includes variants, maybes, arrays, tuples and dictionary\n entries. It is an error to call this function on any other type of\n GVariant.\n For variants, the return value is always 1. For values with maybe\n types, it is always zero or one. For arrays, it is the length of the\n array. For tuples it is the number of tuple items (which depends\n only on the type). For dictionary entries, it is always 2\n This function is O(1).\n Since 2.24\n Returns: the number of children in the container\n\t \n",
"line" : 1347}
,
{
"name" : "getChildValue",
"kind" : "function",
"protection" : "public",
"type" : "Variant(ulong index)",
"comment" : "\n Reads a child item out of a container GVariant instance. This\n includes variants, maybes, arrays, tuples and dictionary\n entries. It is an error to call this function on any other type of\n GVariant.\n It is an error if index_ is greater than the number of child items\n in the container. See g_variant_n_children().\n This function is O(1).\n Since 2.24\n Params:\n index = the index of the child to fetch\n Returns: the child at the specified index\n\t \n",
"line" : 1366}
,
{
"name" : "getFixedArray",
"kind" : "function",
"protection" : "public",
"type" : "void*(ulong* nElements, ulong elementSize)",
"comment" : "\n Provides access to the serialised data for an array of fixed-sized\n items.\n value must be an array with fixed-sized elements. Numeric types are\n fixed-size as are tuples containing only other fixed-sized types.\n element_size must be the size of a single element in the array. For\n example, if calling this function for an array of 32 bit integers,\n you might say sizeof (gint32). This value isn't used\n except for the purpose of a double-check that the form of the\n seralised data matches the caller's expectation.\n n_elements, which must be non-NULL is set equal to the number of\n items in the array.\n Since 2.24\n Params:\n nElements = a pointer to the location to store the number of items\n elementSize = the size of each element\n Returns: a pointer to the fixed array. [array length=n_elements]\n\t \n",
"line" : 1395}
,
{
"name" : "getSize",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Determines the number of bytes that would be required to store value\n with g_variant_store().\n If value has a fixed-sized type then this function always returned\n that fixed size.\n In the case that value is already in serialised form or the size has\n already been calculated (ie: this function has been called before)\n then this function is O(1). Otherwise, the size is calculated, an\n operation which is approximately O(n) in the number of values\n involved.\n Since 2.24\n Returns: the serialised size of value\n\t \n",
"line" : 1414}
,
{
"name" : "getData",
"kind" : "function",
"protection" : "public",
"type" : "void*()",
"comment" : "\n Returns a pointer to the serialised form of a GVariant instance.\n The returned data may not be in fully-normalised form if read from an\n untrusted source. The returned data must not be freed; it remains\n valid for as long as value exists.\n If value is a fixed-sized value that was deserialised from a\n corrupted serialised container then NULL may be returned. In this\n case, the proper thing to do is typically to use the appropriate\n number of nul bytes in place of value. If value is not fixed-sized\n then NULL is never returned.\n In the case that value is already in serialised form, this function\n is O(1). If the value is not already in serialised form,\n serialisation occurs implicitly and is approximately O(n) in the size\n of the result.\n Since 2.24\n Returns: the serialised form of value, or NULL\n\t \n",
"line" : 1437}
,
{
"name" : "store",
"kind" : "function",
"protection" : "public",
"type" : "void(void* data)",
"comment" : "\n Stores the serialised form of value at data. data should be\n large enough. See g_variant_get_size().\n The stored data is in machine native byte order but may not be in\n fully-normalised form if read from an untrusted source. See\n g_variant_normalise() for a solution.\n This function is approximately O(n) in the size of data.\n Since 2.24\n Params:\n data = the location to store the serialised data at\n\t \n",
"line" : 1454}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(VariantType type, void* data, ulong size, int trusted, extern (C) void function(void* cbData) notify, void* userData)",
"comment" : "\n Creates a new GVariant instance from serialised data.\n type is the type of GVariant instance that will be constructed.\n The interpretation of data depends on knowing the type.\n data is not modified by this function and must remain valid with an\n unchanging value until such a time as notify is called with\n user_data. If the contents of data change before that time then\n the result is undefined.\n If data is trusted to be serialised data in normal form then\n trusted should be TRUE. This applies to serialised data created\n within this process or read from a trusted location on the disk (such\n as a file installed in \/usr\/lib alongside your application). You\n should set trusted to FALSE if data is read from the network, a\n file in the user's home directory, etc.\n notify will be called with user_data when data is no longer\n needed. The exact time of this call is unspecified and might even be\n before this function returns.\n Since 2.24\n Params:\n type = a definite GVariantType\n data = the serialised data\n size = the size of data\n trusted = TRUE if data is definitely in normal form\n notify = function to call when data is no longer needed\n userData = data for notify\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 1487}
,
{
"name" : "byteswap",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Performs a byteswapping operation on the contents of value. The\n result is that all multi-byte numeric data contained in value is\n byteswapped. That includes 16, 32, and 64bit signed and unsigned\n integers as well as file handles and double precision floating point\n values.\n This function is an identity mapping on any value that does not\n contain multi-byte numeric data. That include strings, booleans,\n bytes and containers containing only these things (recursively).\n The returned value is always in normal form and is marked as trusted.\n Since 2.24\n Returns: the byteswapped form of value\n\t \n",
"line" : 1511}
,
{
"name" : "getNormalForm",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Gets a GVariant instance that has the same value as value and is\n trusted to be in normal form.\n If value is already trusted to be in normal form then a new\n reference to value is returned.\n If value is not already trusted, then it is scanned to check if it\n is in normal form. If it is found to be in normal form then it is\n marked as trusted and a new reference to it is returned.\n If value is found not to be in normal form then a new trusted\n GVariant is created with the same value as value.\n It makes sense to call this function if you've received GVariant\n data from untrusted sources and you want to ensure your serialised\n output is definitely in normal form.\n Since 2.24\n Returns: a trusted GVariant\n\t \n",
"line" : 1538}
,
{
"name" : "isNormalForm",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Checks if value is in normal form.\n The main reason to do this is to detect if a given chunk of\n serialised data is in normal form: load the data into a GVariant\n using g_variant_create_from_data() and then use this function to\n check.\n If value is found to be in normal form then it will be marked as\n being trusted. If the value was already marked as being trusted then\n this function will immediately return TRUE.\n Since 2.24\n Returns: TRUE if value is in normal form\n\t \n",
"line" : 1561}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* value)",
"comment" : "\n Generates a hash value for a GVariant instance.\n The output of this function is guaranteed to be the same for a given\n value only per-process. It may change between different processor\n architectures or even different versions of GLib. Do not use this\n function as a basis for building protocols or file formats.\n The type of value is gconstpointer only to allow use of this\n function with GHashTable. value must be a GVariant.\n Since 2.24\n Params:\n value = a basic GVariant value as a gconstpointer. [type GVariant]\n Returns: a hash value corresponding to value\n\t \n",
"line" : 1580}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(void* one, void* two)",
"comment" : "\n Checks if one and two have the same type and value.\n The types of one and two are gconstpointer only to allow use of\n this function with GHashTable. They must each be a GVariant.\n Since 2.24\n Params:\n one = a GVariant instance. [type GVariant]\n two = a GVariant instance. [type GVariant]\n Returns: TRUE if one and two are equal\n\t \n",
"line" : 1596}
,
{
"name" : "print",
"kind" : "function",
"protection" : "public",
"type" : "string(int typeAnnotate)",
"comment" : "\n Pretty-prints value in the format understood by g_variant_parse().\n If type_annotate is TRUE, then type information is included in\n the output.\n Params:\n typeAnnotate = TRUE if type information should be included in\n  the output\n Returns: a newly-allocated string holding the result.\n\t \n",
"line" : 1611}
,
{
"name" : "printString",
"kind" : "function",
"protection" : "public",
"type" : "StringG(StringG string, int typeAnnotate)",
"comment" : "\n Behaves as g_variant_print(), but operates on a GString.\n If string is non-NULL then it is appended to and returned. Else,\n a new empty GString is allocated and it is returned.\n Since 2.24\n Params:\n string = a GString, or NULL. [allow-none][default NULL]\n typeAnnotate = TRUE if type information should be included in\n  the output\n Returns: a GString containing the string\n\t \n",
"line" : 1628}
,
{
"name" : "parse",
"kind" : "function",
"protection" : "public",
"type" : "Variant(VariantType type, string text, string limit, out string endptr)",
"comment" : "\n Parses a GVariant from a text representation.\n A single GVariant is parsed from the content of text.\n The memory at limit will never be accessed and the parser behaves as\n if the character at limit is the nul terminator. This has the\n effect of bounding text.\n If endptr is non-NULL then text is permitted to contain data\n following the value that this function parses and endptr will be\n updated to point to the first character past the end of the text\n parsed by this function. If endptr is NULL and there is extra data\n then an error is returned.\n If type is non-NULL then the value will be parsed to have that\n type. This may result in additional parse errors (in the case that\n the parsed value doesn't fit the type) but may also result in fewer\n errors (in the case that the type would have been ambiguous, such as\n with empty arrays).\n In the event that the parsing is successful, the resulting GVariant\n is returned.\n In case of any error, NULL will be returned. If error is non-NULL\n then it will be set to reflect the error that occured.\n Officially, the language understood by the parser is \"any string\n produced by g_variant_print()\".\n Params:\n type = a GVariantType, or NULL\n text = a string containing a GVariant in text form\n limit = a pointer to the end of text, or NULL\n endptr = a location to store the end pointer, or NULL\n Returns: a reference to a GVariant, or NULL\n Throws: GException on failure.\n\t \n",
"line" : 1669}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "Variant(string format, void** app)",
"comment" : "\n Parses format and returns the result.\n This is the version of g_variant_new_parsed() intended to be used\n from libraries.\n The return value will be floating if it was a newly created GVariant\n instance. In the case that format simply specified the collection\n of a GVariant pointer (eg: format was \"%*\") then the collected\n GVariant pointer will be returned unmodified, without adding any\n additional references.\n In order to behave correctly in all cases it is necessary for the\n calling function to g_variant_ref_sink() the return result before\n returning control to the user that originally provided the pointer.\n At this point, the caller will have their own full reference to the\n result. This can also be done by adding the result to a container,\n or by passing it to another g_variant_new() call.\n Params:\n format = a text format GVariant\n app = a pointer to a va_list\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 1710}
]
}
]
}
,
{
"name" : "glib.VariantIter",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/VariantIter.d",
"members" : [
{
"name" : "VariantIter",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n GVariant is a variant datatype; it stores a value along with\n information about the type of that value. The range of possible\n values is determined by the type. The type system used by GVariant\n is GVariantType.\n GVariant instances always have a type and a value (which are given\n at construction time). The type and value of a GVariant instance\n can never change other than by the GVariant itself being\n destroyed. A GVariant can not contain a pointer.\n GVariant is reference counted using g_variant_ref() and\n g_variant_unref(). GVariant also has floating reference counts --\n see g_variant_ref_sink().\n GVariant is completely threadsafe. A GVariant instance can be\n concurrently accessed in any way from any number of threads without\n problems.\n GVariant is heavily optimised for dealing with data in serialised\n form. It works particularly well with data located in memory-mapped\n files. It can perform nearly all deserialisation operations in a\n small constant time, usually touching only a single memory page.\n Serialised GVariant data can also be sent over the network.\n GVariant is largely compatible with DBus. Almost all types of\n GVariant instances can be sent over DBus. See GVariantType for\n exceptions.\n For convenience to C programmers, GVariant features powerful\n varargs-based value construction and destruction. This feature is\n designed to be embedded in other libraries.\n There is a Python-inspired text language for describing GVariant\n values. GVariant includes a printer for this language and a parser\n with type inferencing.\n Memory Use\n  GVariant tries to be quite efficient with respect to memory use.\n  This section gives a rough idea of how much memory is used by the\n  current implementation. The information here is subject to change\n  in the future.\n  The memory allocated by GVariant can be grouped into 4 broad\n  purposes: memory for serialised data, memory for the type\n  information cache, buffer management memory and memory for the\n  GVariant structure itself.\n Serialised Data Memory\n  This is the memory that is used for storing GVariant data in\n  serialised form. This is what would be sent over the network or\n  what would end up on disk.\n  The amount of memory required to store a boolean is 1 byte. 16,\n  32 and 64 bit integers and double precision floating point numbers\n  use their \"natural\" size. Strings (including object path and\n  signature strings) are stored with a nul terminator, and as such\n  use the length of the string plus 1 byte.\n  Maybe types use no space at all to represent the null value and\n  use the same amount of space (sometimes plus one byte) as the\n  equivalent non-maybe-typed value to represent the non-null case.\n  Arrays use the amount of space required to store each of their\n  members, concatenated. Additionally, if the items stored in an\n  array are not of a fixed-size (ie: strings, other arrays, etc)\n  then an additional framing offset is stored for each item. The\n  size of this offset is either 1, 2 or 4 bytes depending on the\n  overall size of the container. Additionally, extra padding bytes\n  are added as required for alignment of child values.\n  Tuples (including dictionary entries) use the amount of space\n  required to store each of their members, concatenated, plus one\n  framing offset (as per arrays) for each non-fixed-sized item in\n  the tuple, except for the last one. Additionally, extra padding\n  bytes are added as required for alignment of child values.\n  Variants use the same amount of space as the item inside of the\n  variant, plus 1 byte, plus the length of the type string for the\n  item inside the variant.\n  As an example, consider a dictionary mapping strings to variants.\n  In the case that the dictionary is empty, 0 bytes are required for\n  the serialisation.\n  If we add an item \"width\" that maps to the int32 value of 500 then\n  we will use 4 byte to store the int32 (so 6 for the variant\n  containing it) and 6 bytes for the string. The variant must be\n  aligned to 8 after the 6 bytes of the string, so that's 2 extra\n  bytes. 6 (string) + 2 (padding) + 6 (variant) is 14 bytes used\n  for the dictionary entry. An additional 1 byte is added to the\n  array as a framing offset making a total of 15 bytes.\n  If we add another entry, \"title\" that maps to a nullable string\n  that happens to have a value of null, then we use 0 bytes for the\n  null value (and 3 bytes for the variant to contain it along with\n  its type string) plus 6 bytes for the string. Again, we need 2\n  padding bytes. That makes a total of 6 + 2 + 3 = 11 bytes.\n  We now require extra padding between the two items in the array.\n  After the 14 bytes of the first item, that's 2 bytes required. We\n  now require 2 framing offsets for an extra two bytes. 14 + 2 + 11\n  + 2 = 29 bytes to encode the entire two-item dictionary.\n Type Information Cache\n  For each GVariant type that currently exists in the program a type\n  information structure is kept in the type information cache. The\n  type information structure is required for rapid deserialisation.\n  Continuing with the above example, if a GVariant exists with the\n  type \"a{sv}\" then a type information struct will exist for\n  \"a{sv}\", \"{sv}\", \"s\", and \"v\". Multiple uses of the same type\n  will share the same type information. Additionally, all\n  single-digit types are stored in read-only static memory and do\n  not contribute to the writable memory footprint of a program using\n  GVariant.\n  Aside from the type information structures stored in read-only\n  memory, there are two forms of type information. One is used for\n  container types where there is a single element type: arrays and\n  maybe types. The other is used for container types where there\n  are multiple element types: tuples and dictionary entries.\n  Array type info structures are 6 * sizeof (void *), plus the\n  memory required to store the type string itself. This means that\n  on 32bit systems, the cache entry for \"a{sv}\" would require 30\n  bytes of memory (plus malloc overhead).\n  Tuple type info structures are 6 * sizeof (void *), plus 4 *\n  sizeof (void *) for each item in the tuple, plus the memory\n  required to store the type string itself. A 2-item tuple, for\n  example, would have a type information structure that consumed\n  writable memory in the size of 14 * sizeof (void *) (plus type\n  string) This means that on 32bit systems, the cache entry for\n  \"{sv}\" would require 61 bytes of memory (plus malloc overhead).\n  This means that in total, for our \"a{sv}\" example, 91 bytes of\n  type information would be allocated.\n  The type information cache, additionally, uses a GHashTable to\n  store and lookup the cached items and stores a pointer to this\n  hash table in static storage. The hash table is freed when there\n  are zero items in the type cache.\n  Although these sizes may seem large it is important to remember\n  that a program will probably only have a very small number of\n  different types of values in it and that only one type information\n  structure is required for many different values of the same type.\n Buffer Management Memory\n  GVariant uses an internal buffer management structure to deal\n  with the various different possible sources of serialised data\n  that it uses. The buffer is responsible for ensuring that the\n  correct call is made when the data is no longer in use by\n  GVariant. This may involve a g_free() or a g_slice_free() or\n  even g_mapped_file_unref().\n  One buffer management structure is used for each chunk of\n  serialised data. The size of the buffer management structure is 4\n  * (void *). On 32bit systems, that's 16 bytes.\n GVariant structure\n  The size of a GVariant structure is 6 * (void *). On 32 bit\n  systems, that's 24 bytes.\n  GVariant structures only exist if they are explicitly created\n  with API calls. For example, if a GVariant is constructed out of\n  serialised data for the example given above (with the dictionary)\n  then although there are 9 individual values that comprise the\n  entire dictionary (two keys, two values, two variants containing\n  the values, two dictionary entries, plus the dictionary itself),\n  only 1 GVariant instance exists -- the one refering to the\n  dictionary.\n  If calls are made to start accessing the other values then\n  GVariant instances will exist for those values only for as long\n  as they are in use (ie: until you call g_variant_unref()). The\n  type information is shared. The serialised data and the buffer\n  management structure for that serialised data is shared by the\n  child.\n Summary\n  To put the entire example together, for our dictionary mapping\n  strings to variants (with two entries, as given above), we are\n  using 91 bytes of memory for type information, 29 byes of memory\n  for the serialised data, 16 bytes for buffer management and 24\n  bytes for the GVariant instance, or a total of 160 bytes, plus\n  malloc overhead. If we were to use g_variant_get_child_value() to\n  access the two dictionary entries, we would use an additional 48\n  bytes. If we were to have other dictionaries of the same type, we\n  would use more memory for the serialised data and buffer\n  management for those dictionaries, but the type information would\n  be shared.\n \n",
"line" : 232,
"base" : "Object",
"members" : [
{
"name" : "gVariantIter",
"kind" : "variable",
"protection" : "protected",
"type" : "GVariantIter*",
"comment" : " the main Gtk struct \n",
"line" : 235}
,
{
"name" : "getVariantIterStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVariantIter*()",
"line" : 238}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 245}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantIter(GVariantIter* gVariantIter)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 253}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "VariantIter()",
"comment" : "\n\t \n\n Creates a new heap-allocated GVariantIter to iterate over the\n container that was being iterated over by iter. Iteration begins on\n the new iterator from the current position of the old iterator but\n the two copies are independent past that point.\n Use g_variant_iter_free() to free the return value when you no longer\n need it.\n A reference is taken to the container that iter is iterating over\n and will be releated only when g_variant_iter_free() is called.\n Since 2.24\n Returns: a new heap-allocated GVariantIter\n\t \n",
"line" : 278}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n Frees a heap-allocated GVariantIter. Only call this function on\n iterators that were returned by g_variant_iter_new() or\n g_variant_iter_copy().\n Since 2.24\n\t \n",
"line" : 295}
,
{
"name" : "init",
"kind" : "function",
"protection" : "public",
"type" : "ulong(Variant value)",
"comment" : "\n Initialises (without allocating) a GVariantIter. iter may be\n completely uninitialised prior to this call; its old value is\n ignored.\n The iterator remains valid for as long as value exists, and need not\n be freed in any way.\n Since 2.24\n Params:\n value = a container GVariant\n Returns: the number of items in value\n\t \n",
"line" : 312}
,
{
"name" : "nChildren",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Queries the number of child items in the container that we are\n iterating over. This is the total number of items -- not the number\n of items remaining.\n This function might be useful for preallocation of arrays.\n Since 2.24\n Returns: the number of children in the container\n\t \n",
"line" : 326}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantIter(Variant value)",
"comment" : "\n Creates a heap-allocated GVariantIter for iterating over the items\n in value.\n Use g_variant_iter_free() to free the return value when you no longer\n need it.\n A reference is taken to value and will be released only when\n g_variant_iter_free() is called.\n Since 2.24\n Params:\n value = a container GVariant\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 344}
,
{
"name" : "nextValue",
"kind" : "function",
"protection" : "public",
"type" : "Variant()",
"comment" : "\n Gets the next item in the container. If no more items remain then\n NULL is returned.\n Use g_variant_unref() to drop your reference on the return value when\n you no longer need it.\n $(DDOC_COMMENT example)\n Since 2.24\n Returns: a GVariant, or NULL. [allow-none]\n\t \n",
"line" : 364}
]
}
]
}
,
{
"name" : "glib.VariantType",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/VariantType.d",
"members" : [
{
"name" : "VariantType",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n This section introduces the GVariant type system. It is based, in\n large part, on the DBus type system, with two major changes and some minor\n lifting of restrictions. The DBus\n specification, therefore, provides a significant amount of\n information that is useful when working with GVariant.\n The first major change with respect to the DBus type system is the\n introduction of maybe (or \"nullable\") types. Any type in GVariant can be\n converted to a maybe type, in which case, \"nothing\" (or \"null\") becomes a\n valid value. Maybe types have been added by introducing the\n character \"m\" to type strings.\n The second major change is that the GVariant type system supports the\n concept of \"indefinite types\" -- types that are less specific than\n the normal types found in DBus. For example, it is possible to speak\n of \"an array of any type\" in GVariant, where the DBus type system\n would require you to speak of \"an array of integers\" or \"an array of\n strings\". Indefinite types have been added by introducing the\n characters \"*\", \"?\" and\n \"r\" to type strings.\n Finally, all arbitrary restrictions relating to the complexity of\n types are lifted along with the restriction that dictionary entries\n may only appear nested inside of arrays.\n Just as in DBus, GVariant types are described with strings (\"type\n strings\"). Subject to the differences mentioned above, these strings\n are of the same form as those found in DBus. Note, however: DBus\n always works in terms of messages and therefore individual type\n strings appear nowhere in its interface. Instead, \"signatures\"\n are a concatenation of the strings of the type of each argument in a\n message. GVariant deals with single values directly so GVariant type\n strings always describe the type of exactly one value. This means\n that a DBus signature string is generally not a valid GVariant type\n string -- except in the case that it is the signature of a message\n containing exactly one argument.\n An indefinite type is similar in spirit to what may be called an\n abstract type in other type systems. No value can exist that has an\n indefinite type as its type, but values can exist that have types\n that are subtypes of indefinite types. That is to say,\n g_variant_get_type() will never return an indefinite type, but\n calling g_variant_is_a() with an indefinite type may return TRUE.\n For example, you can not have a value that represents \"an array of no\n particular type\", but you can have an \"array of integers\" which\n certainly matches the type of \"an array of no particular type\", since\n \"array of integers\" is a subtype of \"array of no particular type\".\n This is similar to how instances of abstract classes may not\n directly exist in other type systems, but instances of their\n non-abstract subtypes may. For example, in GTK, no object that has\n the type of GtkBin can exist (since GtkBin is an abstract class),\n but a GtkWindow can certainly be instantiated, and you would say\n that the GtkWindow is a GtkBin (since GtkWindow is a subclass of\n GtkBin).\n A detailed description of GVariant type strings is given here:\n GVariant Type Strings\n  A GVariant type string can be any of the following:\n  any basic type string (listed below)\n  \"v\", \"r\" or\n  \"*\"\n  one of the characters 'a' or\n  'm', followed by another type string\n  the character '(', followed by a concatenation\n  of zero or more other type strings, followed by the character\n  ')'\n  the character '{', followed by a basic type\n  string (see below), followed by another type string, followed by\n  the character '}'\n  A basic type string describes a basic type (as per\n  g_variant_type_is_basic()) and is always a single\n  character in length. The valid basic type strings are\n  \"b\", \"y\",\n  \"n\", \"q\",\n  \"i\", \"u\",\n  \"x\", \"t\",\n  \"h\", \"d\",\n  \"s\", \"o\",\n  \"g\" and \"?\".\n  The above definition is recursive to arbitrary depth.\n  \"aaaaai\" and \"(ui(nq((y)))s)\"\n  are both valid type strings, as is\n  \"a(aa(ui)(qna{ya(yd)}))\".\n  The meaning of each of the characters is as follows:\n  Character\n  Meaning\n  b\n  the type string of G_VARIANT_TYPE_BOOLEAN; a boolean value.\n  y\n  the type string of G_VARIANT_TYPE_BYTE; a byte.\n  n\n  the type string of G_VARIANT_TYPE_INT16; a signed 16 bit\n  integer.\n  q\n  the type string of G_VARIANT_TYPE_UINT16; an unsigned 16 bit\n  integer.\n  i\n  the type string of G_VARIANT_TYPE_INT32; a signed 32 bit\n  integer.\n  u\n  the type string of G_VARIANT_TYPE_UINT32; an unsigned 32 bit\n  integer.\n  x\n  the type string of G_VARIANT_TYPE_INT64; a signed 64 bit\n  integer.\n  t\n  the type string of G_VARIANT_TYPE_UINT64; an unsigned 64 bit\n  integer.\n  h\n  the type string of G_VARIANT_TYPE_HANDLE; a signed 32 bit\n  value that, by convention, is used as an index into an array\n  of file descriptors that are sent alongside a DBus message.\n  d\n  the type string of G_VARIANT_TYPE_DOUBLE; a double precision\n  floating point value.\n  s\n  the type string of G_VARIANT_TYPE_STRING; a string.\n  o\n  the type string of G_VARIANT_TYPE_OBJECT_PATH; a string in\n  the form of a DBus object path.\n  g\n  the type string of G_VARIANT_TYPE_STRING; a string in the\n  form of a DBus type signature.\n  ?\n  the type string of G_VARIANT_TYPE_BASIC; an indefinite type\n  that is a supertype of any of the basic types.\n  v\n  the type string of G_VARIANT_TYPE_VARIANT; a container type\n  that contain any other type of value.\n  a\n  used as a prefix on another type string to mean an array of\n  that type; the type string \"ai\", for\n  example, is the type of an array of 32 bit signed integers.\n  m\n  used as a prefix on another type string to mean a \"maybe\", or\n  \"nullable\", version of that type; the type string\n  \"ms\", for example, is the type of a value\n  that maybe contains a string, or maybe contains nothing.\n  ()\n  used to enclose zero or more other concatenated type strings\n  to create a tuple type; the type string\n  \"(is)\", for example, is the type of a pair\n  of an integer and a string.\n  r\n  the type string of G_VARIANT_TYPE_TUPLE; an indefinite type\n  that is a supertype of any tuple type, regardless of the\n  number of items.\n  {}\n  used to enclose a basic type string concatenated with another\n  type string to create a dictionary entry type, which usually\n  appears inside of an array to form a dictionary; the type\n  string \"a{sd}\", for example, is the type of\n  a dictionary that maps strings to double precision floating\n  point values.\n  The first type (the basic type) is the key type and the second\n  type is the value type. The reason that the first type is\n  restricted to being a basic type is so that it can easily be\n  hashed.\n  *\n  the type string of G_VARIANT_TYPE_ANY; the indefinite type\n  that is a supertype of all types. Note that, as with all type\n  strings, this character represents exactly one type. It\n  cannot be used inside of tuples to mean \"any number of items\".\n  Any type string of a container that contains an indefinite type is,\n  itself, an indefinite type. For example, the type string\n  \"a*\" (corresponding to G_VARIANT_TYPE_ARRAY) is\n  an indefinite type that is a supertype of every array type.\n  \"(*s)\" is a supertype of all tuples that\n  contain exactly two items where the second item is a string.\n  \"a{?*}\" is an indefinite type that is a\n  supertype of all arrays containing dictionary entries where the key\n  is any basic type and the value is any type at all. This is, by\n  definition, a dictionary, so this type string corresponds to\n  G_VARIANT_TYPE_DICTIONARY. Note that, due to the restriction that\n  the key of a dictionary entry must be a basic type,\n  \"{**}\" is not a valid type string.\n \n",
"line" : 242,
"base" : "Object",
"members" : [
{
"name" : "gVariantType",
"kind" : "variable",
"protection" : "protected",
"type" : "GVariantType*",
"comment" : " the main Gtk struct \n",
"line" : 245}
,
{
"name" : "getVariantTypeStruct",
"kind" : "function",
"protection" : "public",
"type" : "GVariantType*()",
"line" : 248}
,
{
"name" : "getStruct",
"kind" : "function",
"protection" : "protected",
"type" : "void*()",
"comment" : " the main Gtk struct as a void* \n",
"line" : 255}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantType(GVariantType* gVariantType)",
"comment" : "\n Sets our main struct and passes it to the parent class\n\t \n",
"line" : 263}
,
{
"name" : "newMaybe",
"kind" : "function",
"protection" : "public",
"type" : "VariantType(VariantType element)",
"comment" : "\n Constructs the type corresponding to a maybe instance containing\n type type or Nothing.\n It is appropriate to call g_variant_type_free() on the return value.\n Since 2.24\n Params:\n element = a GVariantType\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 282}
,
{
"name" : "free",
"kind" : "function",
"protection" : "public",
"type" : "void()",
"comment" : "\n\t \n\n Frees a GVariantType that was allocated with\n g_variant_type_copy(), g_variant_type_new() or one of the container\n type constructor functions.\n In the case that type is NULL, this function does nothing.\n Since 2.24\n\t \n",
"line" : 303}
,
{
"name" : "copy",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Makes a copy of a GVariantType. It is appropriate to call\n g_variant_type_free() on the return value. type may not be NULL.\n Since 2.24\n Returns: a new GVariantType\n\t \n",
"line" : 315}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantType(string typeString)",
"comment" : "\n Creates a new GVariantType corresponding to the type string given\n by type_string. It is appropriate to call g_variant_type_free() on\n the return value.\n It is a programmer error to call this function with an invalid type\n string. Use g_variant_type_string_is_valid() if you are unsure.\n Since 2.24\n Params:\n typeString = a valid GVariant type string\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 337}
,
{
"name" : "stringIsValid",
"kind" : "function",
"protection" : "public",
"type" : "int(string typeString)",
"comment" : "\n Checks if type_string is a valid GVariant type string. This call is\n equivalent to calling g_variant_type_string_scan() and confirming\n that the following character is a nul terminator.\n Since 2.24\n Params:\n typeString = a pointer to any string\n Returns: TRUE if type_string is exactly one valid type string\n\t \n",
"line" : 357}
,
{
"name" : "stringScan",
"kind" : "function",
"protection" : "public",
"type" : "int(string str, string limit, out string endptr)",
"comment" : "\n Scan for a single complete and valid GVariant type string in string.\n The memory pointed to by limit (or bytes beyond it) is never\n accessed.\n If a valid type string is found, endptr is updated to point to the\n first character past the end of the string that was found and TRUE\n is returned.\n If there is no valid type string starting at string, or if the type\n string does not end before limit then FALSE is returned.\n For the simple case of checking if a string is a valid type string,\n see g_variant_type_string_is_valid().\n Since 2.24\n Params:\n string = a pointer to any string\n limit = the end of string, or NULL\n endptr = location to store the end pointer, or NULL\n Returns: TRUE if a valid type string was found\n\t \n",
"line" : 381}
,
{
"name" : "getStringLength",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Returns the length of the type string corresponding to the given\n type. This function must be used to determine the valid extent of\n the memory region returned by g_variant_type_peek_string().\n Since 2.24\n Returns: the length of the corresponding type string\n\t \n",
"line" : 399}
,
{
"name" : "peekString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns the type string corresponding to the given type. The\n result is not nul-terminated; in order to determine its length you\n must call g_variant_type_get_string_length().\n To get a nul-terminated string, see g_variant_type_dup_string().\n Since 2.24\n Returns: the corresponding type string (not nul-terminated)\n\t \n",
"line" : 413}
,
{
"name" : "dupString",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n Returns a newly-allocated copy of the type string corresponding to\n type. The returned string is nul-terminated. It is appropriate to\n call g_free() on the return value.\n Since 2.24\n Returns: the corresponding type string\n\t \n",
"line" : 426}
,
{
"name" : "isDefinite",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is definite (ie: not indefinite).\n A type is definite if its type string does not contain any indefinite\n type characters ('*', '?', or 'r').\n A GVariant instance may not have an indefinite type, so calling\n this function on the result of g_variant_get_type() will always\n result in TRUE being returned. Calling this function on an\n indefinite type like G_VARIANT_TYPE_ARRAY, however, will result in\n FALSE being returned.\n Since 2.24\n Returns: TRUE if type is definite\n\t \n",
"line" : 444}
,
{
"name" : "isContainer",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is a container type.\n Container types are any array, maybe, tuple, or dictionary\n entry types plus the variant type.\n This function returns TRUE for any indefinite type for which every\n definite subtype is a container -- G_VARIANT_TYPE_ARRAY, for\n example.\n Since 2.24\n Returns: TRUE if type is a container type\n\t \n",
"line" : 460}
,
{
"name" : "isBasic",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is a basic type.\n Basic types are booleans, bytes, integers, doubles, strings, object\n paths and signatures.\n Only a basic type may be used as the key of a dictionary entry.\n This function returns FALSE for all indefinite types except\n G_VARIANT_TYPE_BASIC.\n Since 2.24\n Returns: TRUE if type is a basic type\n\t \n",
"line" : 476}
,
{
"name" : "isMaybe",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is a maybe type. This is true if the\n type string for type starts with an 'm'.\n This function returns TRUE for any indefinite type for which every\n definite subtype is a maybe type -- G_VARIANT_TYPE_MAYBE, for\n example.\n Since 2.24\n Returns: TRUE if type is a maybe type\n\t \n",
"line" : 491}
,
{
"name" : "isArray",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is an array type. This is true if the\n type string for type starts with an 'a'.\n This function returns TRUE for any indefinite type for which every\n definite subtype is an array type -- G_VARIANT_TYPE_ARRAY, for\n example.\n Since 2.24\n Returns: TRUE if type is an array type\n\t \n",
"line" : 506}
,
{
"name" : "isTuple",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is a tuple type. This is true if the\n type string for type starts with a '(' or if type is\n G_VARIANT_TYPE_TUPLE.\n This function returns TRUE for any indefinite type for which every\n definite subtype is a tuple type -- G_VARIANT_TYPE_TUPLE, for\n example.\n Since 2.24\n Returns: TRUE if type is a tuple type\n\t \n",
"line" : 522}
,
{
"name" : "isDictEntry",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is a dictionary entry type. This is\n true if the type string for type starts with a '{'.\n This function returns TRUE for any indefinite type for which every\n definite subtype is a dictionary entry type --\n G_VARIANT_TYPE_DICT_ENTRY, for example.\n Since 2.24\n Returns: TRUE if type is a dictionary entry type\n\t \n",
"line" : 537}
,
{
"name" : "isVariant",
"kind" : "function",
"protection" : "public",
"type" : "int()",
"comment" : "\n Determines if the given type is the variant type.\n Since 2.24\n Returns: TRUE if type is the variant type\n\t \n",
"line" : 548}
,
{
"name" : "hash",
"kind" : "function",
"protection" : "public",
"type" : "uint(void* type)",
"comment" : "\n Hashes type.\n The argument type of type is only gconstpointer to allow use with\n GHashTable without function pointer casting. A valid\n GVariantType must be provided.\n Since 2.24\n Params:\n type = a GVariantType\n Returns: the hash value\n\t \n",
"line" : 564}
,
{
"name" : "equal",
"kind" : "function",
"protection" : "public",
"type" : "int(void* type1, void* type2)",
"comment" : "\n Compares type1 and type2 for equality.\n Only returns TRUE if the types are exactly equal. Even if one type\n is an indefinite type and the other is a subtype of it, FALSE will\n be returned if they are not exactly equal. If you want to check for\n subtypes, use g_variant_type_is_subtype_of().\n The argument types of type1 and type2 are only gconstpointer to\n allow use with GHashTable without function pointer casting. For\n both arguments, a valid GVariantType must be provided.\n Since 2.24\n Params:\n type1 = a GVariantType\n type2 = a GVariantType\n Returns: TRUE if type1 and type2 are exactly equal\n\t \n",
"line" : 585}
,
{
"name" : "isSubtypeOf",
"kind" : "function",
"protection" : "public",
"type" : "int(VariantType supertype)",
"comment" : "\n Checks if type is a subtype of supertype.\n This function returns TRUE if type is a subtype of supertype. All\n types are considered to be subtypes of themselves. Aside from that,\n only indefinite types can have subtypes.\n Since 2.24\n Params:\n type = a GVariantType\n supertype = a GVariantType\n Returns: TRUE if type is a subtype of supertype\n\t \n",
"line" : 602}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantType(VariantType element)",
"comment" : "\n Constructs the type corresponding to an array of elements of the\n type type.\n It is appropriate to call g_variant_type_free() on the return value.\n Since 2.24\n Params:\n element = a GVariantType\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 617}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantType(VariantType[] items)",
"comment" : "\n Constructs a new tuple type, from items.\n length is the number of items in items, or -1 to indicate that\n items is NULL-terminated.\n It is appropriate to call g_variant_type_free() on the return value.\n Since 2.24\n Params:\n items = an array of GVariantTypes, one for each item\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 638}
,
{
"name" : "this",
"kind" : "constructor",
"protection" : "public",
"type" : "VariantType(VariantType key, VariantType value)",
"comment" : "\n Constructs the type corresponding to a dictionary entry with a key\n of type key and a value of type value.\n It is appropriate to call g_variant_type_free() on the return value.\n Since 2.24\n Params:\n key = a basic GVariantType\n value = a GVariantType\n Throws: ConstructionException GTK+ fails to create the object.\n\t \n",
"line" : 666}
,
{
"name" : "element",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Determines the element type of an array or maybe type.\n This function may only be used with array or maybe types.\n Since 2.24\n Returns: the element type of type\n\t \n",
"line" : 683}
,
{
"name" : "nItems",
"kind" : "function",
"protection" : "public",
"type" : "ulong()",
"comment" : "\n Determines the number of items contained in a tuple or\n dictionary entry type.\n This function may only be used with tuple or dictionary entry types,\n but must not be used with the generic tuple type\n G_VARIANT_TYPE_TUPLE.\n In the case of a dictionary entry type, this function will always\n return 2.\n Since 2.24\n Returns: the number of items in type\n\t \n",
"line" : 705}
,
{
"name" : "first",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Determines the first item type of a tuple or dictionary entry\n type.\n This function may only be used with tuple or dictionary entry types,\n but must not be used with the generic tuple type\n G_VARIANT_TYPE_TUPLE.\n In the case of a dictionary entry type, this returns the type of\n the key.\n NULL is returned in case of type being G_VARIANT_TYPE_UNIT.\n This call, together with g_variant_type_next() provides an iterator\n interface over tuple and dictionary entry types.\n Since 2.24\n Returns: the first item type of type, or NULL\n\t \n",
"line" : 725}
,
{
"name" : "next",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Determines the next item type of a tuple or dictionary entry\n type.\n type must be the result of a previous call to\n g_variant_type_first() or g_variant_type_next().\n If called on the key type of a dictionary entry then this call\n returns the value type. If called on the value type of a dictionary\n entry then this call returns NULL.\n For tuples, NULL is returned when type is the last item in a tuple.\n Since 2.24\n Returns: the next GVariantType after type, or NULL\n\t \n",
"line" : 748}
,
{
"name" : "key",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Determines the key type of a dictionary entry type.\n This function may only be used with a dictionary entry type. Other\n than the additional restriction, this call is equivalent to\n g_variant_type_first().\n Since 2.24\n Returns: the key type of the dictionary entry\n\t \n",
"line" : 767}
,
{
"name" : "value",
"kind" : "function",
"protection" : "public",
"type" : "VariantType()",
"comment" : "\n Determines the value type of a dictionary entry type.\n This function may only be used with a dictionary entry type.\n Since 2.24\n Returns: the value type of the dictionary entry\n\t \n",
"line" : 784}
]
}
]
}
,
{
"name" : "glib.WindowsUtils",
"kind" : "module",
"file" : "\/home\/anthony\/apps\/gtkd\/src\/glib\/WindowsUtils.d",
"members" : [
{
"name" : "WindowsUtils",
"kind" : "class",
"protection" : "public",
"comment" : "\n Description\n These functions provide some level of UNIX emulation on the Windows platform.\n If your application really needs the POSIX APIs, we suggest you try the Cygwin\n project.\n \n",
"line" : 72,
"base" : "Object",
"members" : [
{
"name" : "errorMessage",
"kind" : "function",
"protection" : "public",
"type" : "string(int error)",
"comment" : "\n\t \n\n Translate a Win32 error code (as returned by GetLastError()) into\n the corresponding message. The message is either language neutral,\n or in the thread's language, or the user's language, the system's\n language, or US English (see docs for FormatMessage()). The\n returned string is in UTF-8. It should be deallocated with\n g_free().\n Params:\n error = error code.\n Returns: newly-allocated error message\n\t \n",
"line" : 88}
,
{
"name" : "getlocale",
"kind" : "function",
"protection" : "public",
"type" : "string()",
"comment" : "\n The setlocale() function in the Microsoft C library uses locale\n names of the form \"English_United States.1252\" etc. We want the\n UNIXish standard form \"en_US\", \"zh_TW\" etc. This function gets the\n current thread locale from Windows - without any encoding info -\n and returns it as a string of the above form for use in forming\n file names etc. The returned string should be deallocated with\n g_free().\n Returns: newly-allocated locale name.\n\t \n",
"line" : 104}
,
{
"name" : "getPackageInstallationDirectory",
"kind" : "function",
"protection" : "public",
"type" : "string(string p, string dllName)",
"comment" : "\n Warning\n g_win32_get_package_installation_directory has been deprecated since version 2.18 and should not be used in newly-written code. Pass the HMODULE of a DLL or EXE to\n g_win32_get_package_installation_directory_of_module() instead.\n Try to determine the installation directory for a software package.\n This function is deprecated. Use\n g_win32_get_package_installation_directory_of_module() instead.\n The use of package is deprecated. You should always pass NULL. A\n warning is printed if non-NULL is passed as package.\n The original intended use of package was for a short identifier of\n the package, typically the same identifier as used for\n GETTEXT_PACKAGE in software configured using GNU\n autotools. The function first looks in the Windows Registry for the\n value #InstallationDirectory in the key\n #HKLM\\Software@package, and if that value\n exists and is a string, returns that.\n It is strongly recommended that packagers of GLib-using libraries\n for Windows do not store installation paths in the Registry to be\n used by this function as that interfers with having several\n parallel installations of the library. Enabling multiple\n installations of different versions of some GLib-using library, or\n GLib itself, is desirable for various reasons.\n For this reason it is recommeded to always pass NULL as\n package to this function, to avoid the temptation to use the\n Registry. In version 2.20 of GLib the package parameter\n will be ignored and this function won't look in the Registry at all.\n If package is NULL, or the above value isn't found in the\n Registry, but dll_name is non-NULL, it should name a DLL loaded\n into the current process. Typically that would be the name of the\n DLL calling this function, looking for its installation\n directory. The function then asks Windows what directory that DLL\n was loaded from. If that directory's last component is \"bin\" or\n \"lib\", the parent directory is returned, otherwise the directory\n itself. If that DLL isn't loaded, the function proceeds as if\n dll_name was NULL.\n If both package and dll_name are NULL, the directory from where\n the main executable of the process was loaded is used instead in\n the same way as above.\n Params:\n dllName = The name of a DLL that a package provides in UTF-8, or NULL.\n Returns: a string containing the installation directory for package. The string is in the GLib file name encoding, i.e. UTF-8. The return value should be freed with g_free() when not needed any longer. If the function fails NULL is returned.\n\t \n",
"line" : 152}
,
{
"name" : "getPackageInstallationDirectoryOfModule",
"kind" : "function",
"protection" : "public",
"type" : "string(void* hmodule)",
"comment" : "\n This function tries to determine the installation directory of a\n software package based on the location of a DLL of the software\n package.\n hmodule should be the handle of a loaded DLL or NULL. The\n function looks up the directory that DLL was loaded from. If\n hmodule is NULL, the directory the main executable of the current\n process is looked up. If that directory's last component is \"bin\"\n or \"lib\", its parent directory is returned, otherwise the directory\n itself.\n It thus makes sense to pass only the handle to a \"public\" DLL of a\n software package to this function, as such DLLs typically are known\n to be installed in a \"bin\" or occasionally \"lib\" subfolder of the\n installation folder. DLLs that are of the dynamically loaded module\n or plugin variety are often located in more private locations\n deeper down in the tree, from which it is impossible for GLib to\n deduce the root of the package installation.\n The typical use case for this function is to have a DllMain() that\n saves the handle for the DLL. Then when code in the DLL needs to\n construct names of files in the installation tree it calls this\n function passing the DLL handle.\n Since 2.16\n Params:\n hmodule = The Win32 handle for a DLL loaded into the current process, or NULL\n Returns: a string containing the guessed installation directory for the software package hmodule is from. The string is in the GLib file name encoding, i.e. UTF-8. The return value should be freed with g_free() when not needed any longer. If the function fails NULL is returned.\n\t \n",
"line" : 184}
,
{
"name" : "getPackageInstallationSubdirectory",
"kind" : "function",
"protection" : "public",
"type" : "string(string p, string dllName, string subdir)",
"comment" : "\n Warning\n g_win32_get_package_installation_subdirectory has been deprecated since version 2.18 and should not be used in newly-written code. Pass the HMODULE of a DLL or EXE to\n g_win32_get_package_installation_directory_of_module() instead, and\n then construct a subdirectory pathname with g_build_filename().\n This function is deprecated. Use\n g_win32_get_package_installation_directory_of_module() and\n g_build_filename() instead.\n Returns a newly-allocated string containing the path of the\n subdirectory subdir in the return value from calling\n g_win32_get_package_installation_directory() with the package and\n dll_name parameters. See the documentation for\n g_win32_get_package_installation_directory() for more details. In\n particular, note that it is deprecated to pass anything except NULL\n as package.\n Params:\n dllName = The name of a DLL that a package provides, in UTF-8, or NULL.\n subdir = A subdirectory of the package installation directory, also in UTF-8\n Returns: a string containing the complete path to subdir inside the installation directory of package. The returned string is in the GLib file name encoding, i.e. UTF-8. The return value should be freed with g_free() when no longer needed. If something goes wrong, NULL is returned.\n\t \n",
"line" : 210}
,
{
"name" : "getWindowsVersion",
"kind" : "function",
"protection" : "public",
"type" : "uint()",
"comment" : "\n Returns version information for the Windows operating system the\n code is running on. See MSDN documentation for the GetVersion()\n function. To summarize, the most significant bit is one on Win9x,\n and zero on NT-based systems. Since version 2.14, GLib works only\n on NT-based systems, so checking whether your are running on Win9x\n in your own software is moot. The least significant byte is 4 on\n Windows NT 4, and 5 on Windows XP. Software that needs really\n detailled version and feature information should use Win32 API like\n GetVersionEx() and VerifyVersionInfo().\n Since 2.6\n Returns: The version information.\n\t \n",
"line" : 229}
,
{
"name" : "localeFilenameFromUtf8",
"kind" : "function",
"protection" : "public",
"type" : "string(string utf8filename)",
"comment" : "\n Converts a filename from UTF-8 to the system codepage.\n On NT-based Windows, on NTFS file systems, file names are in\n Unicode. It is quite possible that Unicode file names contain\n characters not representable in the system codepage. (For instance,\n Greek or Cyrillic characters on Western European or US Windows\n installations, or various less common CJK characters on CJK Windows\n installations.)\n In such a case, and if the filename refers to an existing file, and\n the file system stores alternate short (8.3) names for directory\n entries, the short form of the filename is returned. Note that the\n \"short\" name might in fact be longer than the Unicode name if the\n Unicode name has very short pathname components containing\n non-ASCII characters. If no system codepage name for the file is\n possible, NULL is returned.\n The return value is dynamically allocated and should be freed with\n g_free() when no longer needed.\n Since 2.8\n Params:\n utf8filename = a UTF-8 encoded filename.\n Returns: The converted filename, or NULL on conversion failure and lack of short names.\n\t \n",
"line" : 257}
]
}
]
}
]
