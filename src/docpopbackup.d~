//      docpop.d
//      
//      Copyright 2011 Anthony Goins <anthony@LinuxGen11>
//      
//      This program is free software; you can redistribute it and/or modify
//      it under the terms of the GNU General Public License as published by
//      the Free Software Foundation; either version 2 of the License, or
//      (at your option) any later version.
//      
//      This program is distributed in the hope that it will be useful,
//      but WITHOUT ANY WARRANTY; without even the implied warranty of
//      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//      GNU General Public License for more details.
//      
//      You should have received a copy of the GNU General Public License
//      along with this program; if not, write to the Free Software
//      Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
//      MA 02110-1301, USA.


module docpop;

import ui;

import dcore;

import std.stdio;


import gtk.Builder;
import gtk.TreeView;
import gtk.TreeIter;
import gtk.TextIter;
import gtk.Window;
import gtk.ListStore;
import gtk.TextView;
import gtk.TextIter;
import gtk.Widget;
import gtk.TreePath;
import gtk.TreeViewColumn;

import gdk.Rectangle;
import gdk.Keysyms;

import glib.SimpleXML;


struct STACK
{
    string[]    Possibles;
    int         Xpos;
    int         Ypos;
    int         Type;
}

class DOC_POP
{
    private :

    enum :int { IDLE = 0, ACTIVE, INTERRUPTED}

    Builder         mBuilder;
    Window          mWindow;
    TreeView        mTreeView;
    ListStore       mListStore;
    ListStore[256]  mBackupStore;
    bool[256]       mCalltip;
    int             mDepth;
    int[256]        mDepthX;
    int[256]        mDepthY;

    int             mCurX;
    int             mCurY;
    
    string[]        mPossibles;

    bool            mActive;

    public:

    void Engage()
    {
        mBuilder = new Builder;
        mBuilder.addFromFile(GetConfig.getString("DOC_POP", "glade_file","/home/anthony/.neontotem/dcomposer/docpop.glade"));

        mWindow = cast(Window)mBuilder.getObject("window1");
        mWindow.setTransientFor(dui.GetWindow());
        mTreeView = cast(TreeView)mBuilder.getObject("treeview1");
        mListStore = cast(ListStore)mBuilder.getObject("liststore1");
        foreach (ref backup; mBackupStore)backup = new ListStore([GType.STRING, GType.STRING]);
        
        GetLog.Entry("Engaged DOC_POP");

    }

    void Disengage()
    {
        GetLog.Entry("Disengaged DOC_POP");
    }
    

    void Show(TextView tv, TextIter where)
    {
        mActive = true;
        
        //find location
        GdkRectangle rect;
        int wx, wy, tvX, tvY;

        Rectangle Location = new Rectangle(&rect);

        tv.getIterLocation(where, Location);
        tv.bufferToWindowCoords(GtkTextWindowType.TEXT, rect.x, rect.y, wx, wy);

        tv.getWindow(GtkTextWindowType.TEXT).getOrigin(tvX, tvY);

        wy += tvY;
        wx += tvX;
        wy += rect.height;
        
        mWindow.move(wx, wy);

        mDepthX[mDepth] = wx;
        mDepthY[mDepth] = wy;        
        
        mWindow.resize(tv.getAllocation().width/2, 120);
        
        mWindow.show();
        


    }

    void Hide()
    {
        if(mActive)
        {
            mActive = false;
            mDepth = 0;
            mWindow.hide();
        }
    }
    void Close()
    {
        writeln("here ", mDepth);
        if(mDepth == 0) return Hide();
        if (mCalltip[mDepth-1])
        {

            mDepth--;
            writeln("restoring mdepth ", mDepth);
            RestoreList();

            
        }

        if(mDepth < 1) return Hide();
        mWindow.move(mDepthX[mDepth], mDepthY[mDepth]);       
        
        //RestoreList();
    }

    void FillPossibles(string[] list, bool isCallTip = false)
    {
        auto ti = new TreeIter;

        writeln(mListStore);
        mListStore.clear();

        foreach(l; list)
        {
            l = SimpleXML.escapeText(l, -1);
            mListStore.append(ti);
            mListStore.setValue(ti, 0, l);
        }

    
        

        if(isCallTip)
        {
            
            mDepth++;
            

            mCalltip[mDepth] = true;           

            writeln("backingup mdepth ", mDepth);
            BackupList();       

            writeln("mdepth - ",mDepth);      

        }
        
    }

    bool CatchKey(GdkEventKey * EvntKey, Widget Wydjit)
    {

        
        if(!mWindow.getVisible())return false;
        TreePath tp = new TreePath("0");
        TreeViewColumn tvc = new TreeViewColumn;
        auto key = EvntKey.keyval;

        if ( key == GdkKeysyms.GDK_Escape)
        {
            Hide();
            return true;
        }

        if ((key == GdkKeysyms.GDK_Return ) || (key == GdkKeysyms.GDK_KP_Enter))
        {
            Hide();
            return true;
        }

        if ( (key == GdkKeysyms.GDK_Up) || (key == GdkKeysyms.GDK_KP_Up))
        {
            
            mTreeView.getCursor(tp, tvc);

            if(tp is null) tp = new TreePath(true);
            else tp.prev();

            mTreeView.setCursor(tp, null, false);
            return true;
        }

        if ( (key == GdkKeysyms.GDK_Down) || (key == GdkKeysyms.GDK_KP_Down))
        {
            
            mTreeView.getCursor(tp, tvc);
            if(tp is null) tp = new TreePath(true);
            else 
            tp.next();
            mTreeView.setCursor(tp, null, false);
            return true;
        }

        return false;
    }

    void BackupList()
    {
        mBackupStore[mDepth].clear();

        TreeIter tibackup = new TreeIter;
        TreeIter tisource = new TreeIter;
        auto result = mListStore.getIterFirst(tisource);

        while( result)
        {
            mBackupStore[mDepth].append(tibackup);
            mBackupStore[mDepth].setValue(tibackup,0, mListStore.getValueString(tisource, 0));
            result = mListStore.iterNext(tisource);
        }
    }

    void RestoreList()
    {
        mListStore.clear();

        TreeIter tirestore = new TreeIter;
        TreeIter tisource = new TreeIter;
        auto result = mBackupStore[mDepth].getIterFirst(tisource);

        while( result)
        {
            mListStore.append(tirestore);
            mListStore.setValue(tirestore,0, mBackupStore[mDepth].getValueString(tisource, 0));
            result = mBackupStore[mDepth].iterNext(tisource);

        }
        mTreeView.setModel(mListStore);
    }

}

/*
 * thoughts
 *
 * things that close docpop
 *
 * focus out
 * backspace  .... no maybe not... only if deletes the opening '('
 * escape
 * */
